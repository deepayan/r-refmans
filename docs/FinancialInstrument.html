<!DOCTYPE html><html lang="en"><head><title>Help for package FinancialInstrument</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FinancialInstrument}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FinancialInstrument-package'><p>Construct, manage and store contract specifications for trading</p></a></li>
<li><a href='#.get_rate'><p>get an exchange rate series</p></a></li>
<li><a href='#.to_daily'><p>Extract a single row from each day in an xts object</p></a></li>
<li><a href='#add.defined.by'><p>Add a source to the defined.by field of an <code>instrument</code></p></a></li>
<li><a href='#add.identifier'><p>Add an identifier to an <code>instrument</code></p></a></li>
<li><a href='#all.equal.instrument'><p>instrument all.equal method</p></a></li>
<li><a href='#build_series_symbols'><p>construct a series of symbols based on root symbol and suffix letters</p></a></li>
<li><a href='#build_spread_symbols'><p>build symbols for exchange guaranteed (calendar) spreads</p></a></li>
<li><a href='#buildHierarchy'><p>Construct a hierarchy of instruments useful for aggregation</p></a></li>
<li><a href='#buildRatio'><p>construct price ratios of 2 instruments</p></a></li>
<li><a href='#buildSpread'><p>Construct a price/level series for pre-defined multi-leg spread instrument</p></a></li>
<li><a href='#C2M'><p>Month-to-Code and Code-to-Month</p></a></li>
<li><a href='#CompareInstrumentFiles'><p>Compare Instrument Files</p></a></li>
<li><a href='#currencies'><p>currency metadata to be used by <code>load.instruments</code></p></a></li>
<li><a href='#exchange_rate'><p>constructor for spot exchange rate instruments</p></a></li>
<li><a href='#expires'><p>extract the correct expires value from an <code>instrument</code></p></a></li>
<li><a href='#expires.character'><p>character expires extraction method</p></a></li>
<li><a href='#expires.instrument'><p>instrument expires extraction method</p></a></li>
<li><a href='#expires.spread'><p>spread expires extraction method</p></a></li>
<li><a href='#expires.xts'><p>xts expires extraction method</p></a></li>
<li><a href='#find.instrument'><p>Find the primary_ids of instruments that contain certain strings</p></a></li>
<li><a href='#FindCommonInstrumentAttributes'><p>Find attributes that more than one instrument have in common</p></a></li>
<li><a href='#fn_SpreadBuilder'><p>Calculate prices of a spread from 2 instruments.</p></a></li>
<li><a href='#format_id'><p>format an id</p></a></li>
<li><a href='#formatSpreadPrice'><p>format the price of a synthetic instrument</p></a></li>
<li><a href='#future_series'><p>Constructors for series contracts</p></a></li>
<li><a href='#getInstrument'><p>Primary accessor function for getting objects of class 'instrument'</p></a></li>
<li><a href='#getSymbols.FI'><p>getSymbols method for loading data from split files</p></a></li>
<li><a href='#instrument'><p>instrument class constructors</p></a></li>
<li><a href='#instrument_attr'><p>Add or change an attribute of an instrument</p></a></li>
<li><a href='#instrument.auto'><p>Create an instrument based on name alone</p></a></li>
<li><a href='#instrument.table'><p>Create data.frame with attributes of all instruments</p></a></li>
<li><a href='#is.currency'><p>class test for object supposedly of type 'currency'</p></a></li>
<li><a href='#is.currency.name'><p>check each element of a character vector to see if it is either the</p>
primary_id or an identifier of a <code>currency</code></a></li>
<li><a href='#is.instrument'><p>class test for object supposedly of type 'instrument'</p></a></li>
<li><a href='#is.instrument.name'><p>check each element of a character vector to see if it is either the</p>
primary_id or an identifier of an <code>instrument</code></a></li>
<li><a href='#load.instruments'><p>load instrument metadata into the .instrument environment</p></a></li>
<li><a href='#ls_by_currency'><p>shows or removes instruments of given currency denomination(s)</p></a></li>
<li><a href='#ls_by_expiry'><p>list or remove instruments by expiration date</p></a></li>
<li><a href='#ls_expiries'><p>show unique expiration dates of instruments</p></a></li>
<li><a href='#ls_instruments'><p>List or Remove instrument objects</p></a></li>
<li><a href='#ls_instruments_by'><p>Subset names of instruments</p></a></li>
<li><a href='#ls_strikes'><p>show strike prices of defined options</p></a></li>
<li><a href='#ls_underlyings'><p>show names of underlyings</p></a></li>
<li><a href='#make_spread_id'><p>Construct a primary_id for a <code>spread</code> <code>instrument</code> from the</p>
primary_ids of its members</a></li>
<li><a href='#month_cycle2numeric'><p>coerce month_cycle to a numeric vector</p></a></li>
<li><a href='#next.future_id'><p>Get the primary_id of the next-to-expire (previously expiring) future_series instrument</p></a></li>
<li><a href='#Notionalize'><p>Convert price series to/from notional value</p></a></li>
<li><a href='#option_series.yahoo'><p>constructor for series of options using yahoo data</p></a></li>
<li><a href='#parse_id'><p>Parse a primary_id</p></a></li>
<li><a href='#parse_suffix'><p>parse a suffix_id</p></a></li>
<li><a href='#print.id.list'><p>id.list class print method</p></a></li>
<li><a href='#print.instrument'><p>instrument class print method</p></a></li>
<li><a href='#print.suffix.list'><p>suffix.list class print method</p></a></li>
<li><a href='#redenominate'><p>Redenominate (change the base of) an instrument</p></a></li>
<li><a href='#root_contracts'><p>future metadata to be used by <code>load.instruments</code></p></a></li>
<li><a href='#saveInstruments'><p>Save and Load all instrument definitions</p></a></li>
<li><a href='#saveSymbols.days'><p>Save data to disk</p></a></li>
<li><a href='#setSymbolLookup.FI'><p>set quantmod-style SymbolLookup for instruments</p></a></li>
<li><a href='#sort_ids'><p>sort primary_ids of instruments</p></a></li>
<li><a href='#sort.instrument'><p>instrument class sort method</p></a></li>
<li><a href='#synthetic'><p>synthetic instrument constructors</p></a></li>
<li><a href='#to_secBATV'><p>Convert tick data to one-second data</p></a></li>
<li><a href='#update_instruments.instrument'><p>Update instruments with metadata from another instrument.</p></a></li>
<li><a href='#update_instruments.iShares'><p>update iShares and SPDR ETF metadata</p></a></li>
<li><a href='#update_instruments.masterDATA'><p>Update instrument metadata for ETFs</p></a></li>
<li><a href='#update_instruments.morningstar'><p>Update instrument metadata for ETFs</p></a></li>
<li><a href='#update_instruments.yahoo'><p>updates instrument metadata with data from yahoo</p></a></li>
<li><a href='#volep'><p>generate endpoints for volume bars</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Copyright:</td>
<td>(c) 2004 - 2018</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ross Bennett &lt;rossbennett34@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Title:</td>
<td>Financial Instrument Model Infrastructure and Meta-Data</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Infrastructure for defining meta-data and
    relationships for financial instruments.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/braverock/FinancialInstrument">https://github.com/braverock/FinancialInstrument</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2018-01-10</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), methods, quantmod (&ge; 0.4-3), zoo (&ge; 1.7-5),
xts (&ge; 0.10-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>TTR</td>
</tr>
<tr>
<td>Suggests:</td>
<td>foreach, XML (&ge; 3.96.1.1), testthat, timeSeries</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-10 19:32:13.605564 UTC; brian</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian G. Peterson [aut, cph],
  Peter Carl [aut, cph],
  Garett See [aut, cph],
  Ross Bennett [ctb, cre],
  Lance Levenson [ctb],
  Ilya Kipnis [ctb],
  Alex Petitt [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-10 23:46:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='FinancialInstrument-package'>Construct, manage and store contract specifications for trading</h2><span id='topic+FinancialInstrument-package'></span><span id='topic+FinancialInstrument'></span>

<h3>Description</h3>

<p>Transaction-oriented infrastructure for defining tradable instruments based 
on their contract specifications.  Construct and manage the definition of any 
asset class, including derivatives, exotics and currencies.  Potentially 
useful for portfolio accounting, backtesting, pre-trade pricing and other 
financial research.  Still in active development.
</p>


<h3>Details</h3>

<p>The FinancialInstrument package provides a construct for defining and storing 
meta-data for tradable contracts (referred to as instruments, e.g., stocks, 
futures, options, etc.).  It can be used to create any asset class and 
derivatives, across multiple currencies.
</p>
<p>FinancialInstrument was originally part of a companion package, blotter, that 
provides portfolio accounting functionality.  Blotter accumulates 
transactions into positions, then into portfolios and an account.  
FinancialInstrument is used to contain the meta-data about an instrument, 
which blotter uses to calculate the notional value of positions and the 
resulting P&amp;L.  FinancialInstrument, however, has plenty of utility beyond 
portfolio accounting, and was carved out so that others might take advantage 
of its functionality.
</p>
<p>As used here, 'instruments' are S3 objects of type 'instrument' or a subclass 
thereof that define contract specifications for price series for a tradable 
contract, such as corn futures or IBM common stock.  When defined as 
instruments, these objects are extended to include descriptive information 
and contract specifications that help identify and value the contract.
</p>
<p>A simple example of an instrument is a common stock.  An instrument can be 
defined in brief terms with an identifier (e.g., &quot;IBM&quot;).  Beyond the primary 
identifier, additional identifiers may be added as well and will work as 
'aliases'.  Any identifier will do &ndash; Bloomberg, Reuters-RIC, CUSIP, etc. &ndash; 
as long as it's unique to the workspace. In addition, a stock price will be 
denominated in a currency (e.g., &quot;USD&quot;) and will have a specific tick size 
which is the minimum amount that the price can be quoted and transacted in 
(e.g., $0.01).  We also define a 'multiplier' that is used when calculating 
the notional value of a position or transaction using a quantity and price 
(sometimes called a contract multiplier).  For a stock it's usually '1'.
</p>
<p>More care is needed when dealing with complex instruments, like futures.  
First, we have to define a future as a root contract.  This root is not 
tradable unto itself, but is used to generate a series of futures which are 
tradable and expire through time.  The root contract will provide an 
identifier (e.g., 'C' for the CME's corn contract), a denomination currency, 
a multiplier (one futures contract will cover multiple items) and a minimum 
tick size.  From that definition, a series of expiring contracts can be 
generated (&quot;C_H08&quot;, &quot;C_Z08&quot;, etc.) by specifying a suffix to be associated 
with the series, usually something like 'Z9' or 'Mar10' denoting expiration 
and year.  As you might expect, options are treated similarly.  The package 
also includes constructors for certain synthetic instruments, such as 
spreads.
</p>
<p>FinancialInstrument doesn't try to exhaust the possibilities of attributes, 
so it instead allows for flexibility.  If you wanted to add an attribute to 
tag the exchange the instrument is listed on, just add it when defining the 
instrument (e.g., <code>future('CL', multiplier=1000, currency="USD", 
tick_size=.01, exchange="CME", description="Crude Light futures")</code>).  Or, as 
you can see, we've found it useful to add a field with more slightly more 
detail, such as <code>description='IBM Common Stock'</code>.  You can also add
attribute after the instrument has been created using 
<code><a href="#topic+instrument_attr">instrument_attr</a></code> as shown in the examples section below.
</p>
<p>Defining instruments can be tedious, so we've also included a CSV loader, 
<code><a href="#topic+load.instruments">load.instruments</a></code>, in the package, as well as some functions
that will update instruments with data downloaded from the internet.
See, e.g., <code><a href="#topic+update_instruments.yahoo">update_instruments.yahoo</a></code>, 
<code><a href="#topic+update_instruments.TTR">update_instruments.TTR</a></code>, 
<code><a href="#topic+update_instruments.morningstar">update_instruments.morningstar</a></code>,
<code><a href="#topic+update_instruments.iShares">update_instruments.iShares</a></code>. You can also update an instrument
using the details of another one with 
<code><a href="#topic+update_instruments.instrument">update_instruments.instrument</a></code> which can be useful for creating
a new future_series from an expiring one.
</p>
<p>Once you've defined all these instruments (we keep hundreds or thousands of 
them in our environments), you can save the instrument environment using
<code><a href="#topic+saveInstruments">saveInstruments</a></code>.  When you start a fresh R session, you 
can load your instrument definitions using <code>loadInstruments</code>.  We 
maintain an instrument.RData file that contains definitions for all 
instruments for which we have market data on disk.
</p>
<p>You may want to use <code><a href="#topic+setSymbolLookup.FI">setSymbolLookup.FI</a></code> to define 
where and how your market data are stored so that 
<code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> will work for you.
</p>
<p>FinancialInstrument's functions build and manipulate objects that are stored 
in an environment named &quot;.instrument&quot; at the top level of the package 
(i.e. &quot;FinancialInstrument:::.instrument&quot;) rather than the global 
environment, <code>.GlobalEnv</code>.  Objects may be listed using 
<code>ls_instruments()</code> (or many other ls_* functions).
</p>
<p>We store instruments in their own environment for two reasons.  First, it 
keeps the user's workspace less cluttered and lowers the probability of 
clobbering something.  Second, it allows the user to save and re-use the 
<code>.instrument</code> environment in other workspaces.  Objects created with 
FinancialInstrument may be directly manipulated as any other object, but in 
our use so far we've found that it's relatively rare to do so.  Use the 
<code><a href="#topic+getInstrument">getInstrument</a></code> function to query the contract specs of a 
particular instrument from the environment.
</p>


<h3>Author(s)</h3>

<p>Peter Carl,
Brian G. Peterson,
Garrett See,
</p>
<p>Maintainer: G See <a href="mailto:gsee000@gmail.com">gsee000@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="xts.html#topic+xts-package">xts</a></code>,
<code><a href="quantmod.html#topic+quantmod-package">quantmod</a></code>,
<a href="https://r-forge.r-project.org/R/?group_id=316">blotter</a>,
<a href="https://cran.r-project.org/package=PerformanceAnalytics">PerformanceAnalytics</a>,
<a href="https://r-forge.r-project.org/R/?group_id=1113">qmao, and twsInstrument</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Construct instruments for several different asset classes
# Define a currency and some stocks
require("FinancialInstrument")
currency(c("USD", "EUR")) # define some currencies
stock(c("SPY", "LQD", "IBM", "GS"), currency="USD") # define some stocks
exchange_rate("EURUSD") # define an exchange rate

ls_stocks() #get the names of all the stocks
ls_instruments() # all instruments

getInstrument("IBM")
update_instruments.yahoo(ls_stocks())
update_instruments.TTR(ls_stocks()) # doesn't update ETFs
update_instruments.masterDATA(ls_stocks()) # only updates ETFs
getInstrument("SPY")

## Compare instruments with all.equal.instrument method
all.equal(getInstrument("USD"), getInstrument("USD"))
all.equal(getInstrument("USD"), getInstrument("EUR"))
all.equal(getInstrument("SPY"), getInstrument("LQD"))

## Search for the tickers of instruments that contain words
find.instrument("computer") #IBM
find.instrument("bond")  #LQD

## Find only the ETFs; update_instruments.masterDATA added a "Fund.Type" field
## to the ETFs, but not to the stocks
ls_instruments_by("Fund.Type") # all instruments that have a "Fund.Type" field

# build data.frames with instrument attributes
buildHierarchy(ls_stocks(), "Name", "type", "avg.volume")

## before defining a derivative, must define the root (can define the underlying 
## in the same step)
future("ES", "USD", multiplier=50, tick_size=0.25, 
    underlying_id=synthetic("SPX", "USD", src=list(src='yahoo', name='^GSPC')))

# above, in addition to defining the future root "ES", we defined an instrument 
# named "SPX".  Using the "src" argument causes setSymbolLookup to be called.
# Using the "src" arg as above is the same as 
# setSymbolLookup(SPX=list(src='yahoo', name='^GSPC'))
getSymbols("SPX") # this now works even though the Symbol used by 
                  # getSymbols.yahoo is "^GSPC", not "SPX"

## Back to the futures; we can define a future_series
future_series("ES_U2", identifiers=list(other="ESU2"))
# identifiers are not necessary, but they allow for the instrument to be found 
# by more than one name
getInstrument("ESU2") #this will find the instrument even though the primary_id 
                      #is "ES_U2"
# can also add indentifiers later
add.identifier("ES_U2", inhouse="ES_U12")

# can add an arbitrary field with instrument_attr
instrument_attr("ES_U2", "description", "S&amp;P 500 e-mini")
getInstrument("ES_U2")

option_series.yahoo("GS") # define a bunch of options on "GS"
# option root was automatically created
getInstrument(".GS")
# could also find ".GS" by looking for "GS", but specifiying type
getInstrument("GS", type='option')

# if you do not know what type of instrument you need to define, try
instrument.auto("ESM3")
getInstrument("ESM3")
instrument.auto("USDJPY")
getInstrument("USDJPY")

instrument.auto("QQQ") #doesn't work as well on ambigous tickers 
getInstrument("QQQ")

# Some functions that make it easier to work with futures
M2C() # Month To Code
M2C()[5]
M2C("may")
C2M() # Code To Month
C2M("J")
C2M()[7]
MC2N("G") # Month Code to Numeric
MC2N("H,K,M")

parse_id("ES_U3")
parse_id("EURUSD")

next.future_id("ES_U2")
next.future_id("ZC_H2", "H,K,N,U,Z")
prev.future_id("CL_H2", 1:12)

sort_ids(ls_instruments()) # sort by expiration date, then alphabetically for 
                           # things that don't expire.

format_id("ES_U2", "CYY")
format_id("ES_U2", "CYY", sep="")
format_id("ES_U2", "MMMYY")

## Saving the instrument environment to disk
tmpdir &lt;- tempdir()
saveInstruments("MyInstruments.RData", dir=tmpdir)
rm_instruments(keep.currencies=FALSE)
ls_instruments() #NULL
loadInstruments("MyInstruments.RData", dir=tmpdir)
ls_instruments()
unlink(tmpdir, recursive=TRUE)

#build a spread:
fn_SpreadBuilder(getSymbols(c("IBM", "SPY"), src='yahoo'))
head(IBM.SPY)
getInstrument("IBM.SPY")

# alternatively, define a spread, then build it
spread(members=c("IBM", "GS", "SPY"), memberratio=c(1, -2, 1))
buildSpread("IBM.GS.SPY") #Since we hadn't yet downloaded "GS", buildSpread 
                          #downloaded it temporarily
chartSeries(IBM.GS.SPY)

## fn_SpreadBuilder will return as many columns as it can 
## (Bid, Ask, Mid, or Op, Cl, Ad), but only works on 2 instrument spreads
## buildSpread works with any number of legs, but returns a single price column

getFX("EUR/USD", from=Sys.Date()-499) # download exchange rate from Oanda

IBM.EUR &lt;- redenominate("IBM", "EUR") #price IBM in EUR instead of dollars
chartSeries(IBM, subset='last 500 days', TA=NULL)
addTA(Ad(IBM.EUR), on=1, col='red')


## End(Not run)
</code></pre>

<hr>
<h2 id='.get_rate'>get an exchange rate series</h2><span id='topic+.get_rate'></span>

<h3>Description</h3>

<p>Try to find exchange rate data in an environment, inverting if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_rate(ccy1, ccy2, env = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_rate_+3A_ccy1">ccy1</code></td>
<td>
<p>chr name of 1st currency</p>
</td></tr>
<tr><td><code id=".get_rate_+3A_ccy2">ccy2</code></td>
<td>
<p>chr name of 2nd currency</p>
</td></tr>
<tr><td><code id=".get_rate_+3A_env">env</code></td>
<td>
<p>environment in which to look for data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xts object with as many columns as practicable.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildRatio">buildRatio</a></code>
<code><a href="#topic+redenominate">redenominate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
EURUSD &lt;- getSymbols("EURUSD=x",src='yahoo',auto.assign=FALSE)
USDEUR &lt;- .get_rate("USD","EUR")
head(USDEUR)
head(EURUSD)

## End(Not run)
</code></pre>

<hr>
<h2 id='.to_daily'>Extract a single row from each day in an xts object</h2><span id='topic+.to_daily'></span>

<h3>Description</h3>

<p>Extract a single row from each day in an xts object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.to_daily(x, EOD_time = "15:00:00")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".to_daily_+3A_x">x</code></td>
<td>
<p>xts object of sub-daily data.</p>
</td></tr>
<tr><td><code id=".to_daily_+3A_eod_time">EOD_time</code></td>
<td>
<p>time of day to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xts object with daily scale.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p>quantmod:::to.daily, quantmod:::to.period
</p>

<hr>
<h2 id='add.defined.by'>Add a source to the defined.by field of an <code>instrument</code></h2><span id='topic+add.defined.by'></span>

<h3>Description</h3>

<p>Concatenate a string or strings (passed through dots) to the defined.by 
field of an instrument (separated by semi-colons).  Any duplicates will be
removed.  See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.defined.by(primary_ids, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.defined.by_+3A_primary_ids">primary_ids</code></td>
<td>
<p>character vector of primary_ids of 
<code><a href="#topic+instrument">instrument</a></code>s</p>
</td></tr>
<tr><td><code id="add.defined.by_+3A_...">...</code></td>
<td>
<p>strings, or character vector, or semi-colon delimited string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there is already a value for the <code>defined.by</code> attribute of the 
<code>primary_id</code> instrument, that string will be split on semi-colons and
converted to a character vector.  That will be <code>c</code>ombined with any new 
strings (in <code>...</code>).  The unique value of this new vector will then
be converted into a semi-colon delimited string that will be assigned to 
the <code>defined.by</code> attribute of the <code>primary_ids</code>' instruments
</p>
<p>Many functions that create or update instrument definitions will also add or
update the value of the defined.by attribute of that instrument.  If an 
instrument has been updated by more than one function, it's <code>defined.by</code>
attribute will likely be a semi-colon delimited string (e.g. 
&ldquo;TTR;yahoo&rdquo;).
</p>


<h3>Value</h3>

<p>called for side-effect
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.identifier">add.identifier</a></code>, <code><a href="#topic+instrument_attr">instrument_attr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
update_instruments.TTR("GS")
getInstrument("GS")$defined.by #TTR
add.defined.by("GS", "gsee", "demo")
add.defined.by("GS", "gsee;demo") #same

## End(Not run)
</code></pre>

<hr>
<h2 id='add.identifier'>Add an identifier to an <code>instrument</code></h2><span id='topic+add.identifier'></span>

<h3>Description</h3>

<p>Add an identifier to an <code><a href="#topic+instrument">instrument</a></code> unless the instrument 
already has that identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.identifier(primary_id, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.identifier_+3A_primary_id">primary_id</code></td>
<td>
<p>primary_id of an <code><a href="#topic+instrument">instrument</a></code></p>
</td></tr>
<tr><td><code id="add.identifier_+3A_...">...</code></td>
<td>
<p>identifiers passed as regular named arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>called for side-effect
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+instrument_attr">instrument_attr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stock("XXX", currency("USD"))
add.identifier("XXX", yahoo="^XXX") 
getInstrument("^XXX")
add.identifier("^XXX", "x3")
all.equal(getInstrument("x3"), getInstrument("XXX")) #TRUE

## End(Not run)
</code></pre>

<hr>
<h2 id='all.equal.instrument'>instrument all.equal method</h2><span id='topic+all.equal.instrument'></span>

<h3>Description</h3>

<p>This is most useful for seeing the difference between two <code>instrument</code> 
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'equal.instrument'
all(target, current, char.n = 2, collapse = ";",
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all.equal.instrument_+3A_char.n">char.n</code></td>
<td>
<p>If length of a character vector is <code>char.n</code> or less it 
will be treated as a single element. A negative value for <code>char.n</code> will
be treated as if it were positive <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="all.equal.instrument_+3A_collapse">collapse</code></td>
<td>
<p>Only used if a character vector is of length less than 
<code>char.n</code>.  Unless <code>collapse</code> is <code>NULL</code>, it will be used in a 
call to <code><a href="base.html#topic+paste">paste</a></code>.  If <code>collapse</code> is <code>NULL</code>, each element 
of the character vector will be compared separately.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>ALPHA code. Subject to change
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getInstrument">getInstrument</a></code>, <code><a href="#topic+instrument.table">instrument.table</a></code>,
<code><a href="#topic+buildHierarchy">buildHierarchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
currency("USD")
stock("SPY", "USD", validExchanges=c("SMART", "ARCA", "BATS", "BEX"))
stock("DIA", "USD", validExchanges=c("SMART", "ARCA", "ISLAND"), 
     ExtraField="something")

all.equal(getInstrument("SPY"), getInstrument("DIA"))
all.equal(getInstrument("SPY"), getInstrument("DIA"), char.n=5)
all.equal(getInstrument("SPY"), getInstrument("DIA"), char.n=5, collapse=NULL)

all.equal(getInstrument("DIA"), getInstrument("USD"))

## End(Not run)
</code></pre>

<hr>
<h2 id='build_series_symbols'>construct a series of symbols based on root symbol and suffix letters</h2><span id='topic+build_series_symbols'></span>

<h3>Description</h3>

<p>The columns needed by this version of the function are <code>primary_id</code>
and <code>month_cycle</code>. <code>primary_id</code> should match the <code>primary_id</code>
of the instrument describing the root contract.
<code>month_cycle</code> should contain a comma delimited string describing the
month sequence to use, e.g. <code>"F,G,H,J,K,M,N,Q,U,V,X,Z"</code> for all months
using the standard futures letters, or <code>"H,M,U,Z"</code> for quarters, or
<code>"Mar,Jun,Sep,Dec"</code> for quarters as three-letter month abbreviations, etc.
The correct values will vary based on your data source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_series_symbols(roots, yearlist = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_series_symbols_+3A_roots">roots</code></td>
<td>
<p>data.frame containing at least columns <code>primary_id</code> and <code>month_cycle</code>, see Details</p>
</td></tr>
<tr><td><code id="build_series_symbols_+3A_yearlist">yearlist</code></td>
<td>
<p>vector of year suffixes to be applied, see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO add more flexibility in input formats for <code>roots</code>
</p>


<h3>Author(s)</h3>

<p>Brian G. Peterson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.instruments">load.instruments</a></code>
</p>

<hr>
<h2 id='build_spread_symbols'>build symbols for exchange guaranteed (calendar) spreads</h2><span id='topic+build_spread_symbols'></span>

<h3>Description</h3>

<p>The columns needed by this version of the function are <code>primary_id</code>,
<code>month_cycle</code>, and code <code>contracts_ahead</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_spread_symbols(data = NULL, file = NULL, outputfile = NULL,
  start_date = Sys.Date())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_spread_symbols_+3A_data">data</code></td>
<td>
<p>data.frame containing at least columns <code>primary_id</code>, <code>month_cycle</code>, amd <code>contracts_ahead</code>, see Details</p>
</td></tr>
<tr><td><code id="build_spread_symbols_+3A_file">file</code></td>
<td>
<p>if not NULL, will read input data from the file named by this argument, in the same folrmat as <code>data</code>, above</p>
</td></tr>
<tr><td><code id="build_spread_symbols_+3A_outputfile">outputfile</code></td>
<td>
<p>if not NULL, will write out put to this file as a CSV</p>
</td></tr>
<tr><td><code id="build_spread_symbols_+3A_start_date">start_date</code></td>
<td>
<p>date to start building from, of type <code>Date</code> or an ISO-8601 date string, defaults to <code><a href="base.html#topic+Sys.Date">Sys.Date</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>primary_id</code> should match the <code>primary_id</code>
of the instrument describing the root contract.
</p>
<p><code>month_cycle</code> should contain a comma delimited string describing the
month sequence to use, e.g. <code>"F,G,H,J,K,M,N,Q,U,V,X,Z"</code> for all months
using the standard futures letters, or <code>"H,M,U,Z"</code> for quarters, or
<code>"Mar,Jun,Sep,Dec"</code> for quarters as three-letter month abbreviations, etc.
The correct values will vary based on your data source.
</p>
<p><code>contracts_ahead</code> should contain a comma-delimited string describing
the cycle on which the guaranteed calendar spreads are to be consructed,
e.g. '1' for one-month spreads, '1,3' for one and three month spreads,
'1,6,12' for 1, 6, and 12 month spreads, etc.  
For quarterly symbols, the correct <code>contracts_ahead</code> may be 
something like '1,2,3' for quarterly, bi-annual, and annual spreads.
</p>
<p><code>active_months</code> is a numeric field indicating how many months including  
the month of the <code>start_date</code> the contract is available to trade.  
This number will be used as the upper limit for symbol generation.
</p>
<p>If <code>type</code> is also specified, it should be a specific instrument type, 
e.g. 'future_series','option_series','guaranteed_spread' or 'calendar_spread'
</p>
<p>One of <code>data</code> or <code>file</code> must be populated for input data.
</p>


<h3>Author(s)</h3>

<p>Ilya Kipnis &lt;Ilya.Kipnis&lt;at&gt;gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.instruments">load.instruments</a></code>
<code><a href="#topic+build_series_symbols">build_series_symbols</a></code>
</p>

<hr>
<h2 id='buildHierarchy'>Construct a hierarchy of instruments useful for aggregation</h2><span id='topic+buildHierarchy'></span>

<h3>Description</h3>

<p>Construct a hierarchy of instruments useful for aggregation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildHierarchy(primary_ids, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildHierarchy_+3A_primary_ids">primary_ids</code></td>
<td>
<p>A character vector of <code>instrument</code> primary_ids to be 
included in the hierarchy list</p>
</td></tr>
<tr><td><code id="buildHierarchy_+3A_...">...</code></td>
<td>
<p>character names of instrument attributes in top-down order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Constructs a data.frame that contains the list of assets in the first 
column and the category or factor for grouping at each level in the following 
columns
</p>


<h3>Author(s)</h3>

<p>Peter Carl, Alexis Petit, Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+instrument.table">instrument.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# rm_instruments(keep.currencies=FALSE)
## Define some stocks
update_instruments.TTR(c("XOM", "IBM", "CVX", "WMT", "GE"), exchange="NYSE")

buildHierarchy(ls_instruments(), "type")
buildHierarchy(ls_stocks(), c("Name", "Sector"))
buildHierarchy(ls_stocks(), "Industry", "MarketCap")

## End(Not run)
</code></pre>

<hr>
<h2 id='buildRatio'>construct price ratios of 2 instruments</h2><span id='topic+buildRatio'></span>

<h3>Description</h3>

<p>Calculates time series of ratio of 2 instruments using available data. 
Returned object will be ratios calculated using Bids, Asks, and Mids, or Opens, Closes, and Adjusteds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRatio(x, env = .GlobalEnv, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildRatio_+3A_x">x</code></td>
<td>
<p>vector of instrument names. e.g. c(&quot;SPY&quot;,&quot;DIA&quot;)</p>
</td></tr>
<tr><td><code id="buildRatio_+3A_env">env</code></td>
<td>
<p>environment where xts data is stored</p>
</td></tr>
<tr><td><code id="buildRatio_+3A_silent">silent</code></td>
<td>
<p>silence warnings?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> should be a vector of 2 instrument names. An attempt will be made to <code>get</code> the data
for both instruments.  If there are no xts data stored under either of the names, it will try to 
return prebuilt data with a call to <code><a href="#topic+.get_rate">.get_rate</a></code>.
</p>
<p>If the data are not of the same frequency, or are not of the same type (OHLC, BBO, etc.)
An attempt will be made to make them compatible.  Preference is given to the first leg.
</p>
<p>If the data in <code>x[1]</code> is daily or slower and the data in <code>x[2]</code> is intraday
(e.g. if you give it daily OHLC and intraday Bid Ask Mid, it will use all of 
the OHLC columns of <code>x[1]</code> and only the the End of Day Mid price of the BAM object.
</p>
<p>If the data in <code>x[1]</code> is intraday, and the data in <code>x[2]</code> is daily or slower,
for each day, the previous closing value of <code>x[2]</code> will be filled forward with <code>na.locf</code>
</p>


<h3>Value</h3>

<p>An xts object with columns of
Bid, Ask, Mid
OR
Open, Close, Adjusted
OR
Price
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+redenominate">redenominate</a></code>
<code><a href="#topic+buildSpread">buildSpread</a></code>
<code><a href="#topic+fn_SpreadBuilder">fn_SpreadBuilder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
syms &lt;- c("SPY","DIA")
getSymbols(syms)
rat &lt;- buildRatio(syms)
summary(rat)

## End(Not run)
</code></pre>

<hr>
<h2 id='buildSpread'>Construct a price/level series for pre-defined multi-leg spread instrument</h2><span id='topic+buildSpread'></span><span id='topic+buildBasket'></span>

<h3>Description</h3>

<p>Build price series for spreads, butterflies, or other synthetic instruments, 
using metadata of a previously defined synthetic instrument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildSpread(spread_id, Dates = NULL, onelot = TRUE, prefer = NULL,
  auto.assign = TRUE, env = .GlobalEnv)

buildBasket(spread_id, Dates = NULL, onelot = TRUE, prefer = NULL,
  auto.assign = TRUE, env = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildSpread_+3A_spread_id">spread_id</code></td>
<td>
<p>The name of the <code>instrument</code> that contains members and 
memberratio</p>
</td></tr>
<tr><td><code id="buildSpread_+3A_dates">Dates</code></td>
<td>
<p>Date range on which to subset.  Also, if a member's data is not 
available via <code><a href="base.html#topic+get">get</a></code> <code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> will be 
called, and the values of the <code>from</code> and <code>to</code> arguments will be 
determined using <code><a href="xts.html#topic+.parseISO8601">.parseISO8601</a></code> on <code>Dates</code>.</p>
</td></tr>
<tr><td><code id="buildSpread_+3A_onelot">onelot</code></td>
<td>
<p>Should the series be divided by the first leg's ratio?</p>
</td></tr>
<tr><td><code id="buildSpread_+3A_prefer">prefer</code></td>
<td>
<p>Price column to use to build structure.</p>
</td></tr>
<tr><td><code id="buildSpread_+3A_auto.assign">auto.assign</code></td>
<td>
<p>Assign the spread? If FALSE, the xts object will be 
returned.</p>
</td></tr>
<tr><td><code id="buildSpread_+3A_env">env</code></td>
<td>
<p>Environment holding data for members as well as where spread data
will be assigned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spread and all legs must be defined instruments.
</p>
<p>This function can build multileg spreads such as calendars, butterflies, 
condors, etc. However, the returned series will be univariate. It does not 
return multiple columns (e.g. &lsquo;Bid&rsquo;, &lsquo;Ask&rsquo;, &lsquo;Mid&rsquo;) like 
<code><a href="#topic+fn_SpreadBuilder">fn_SpreadBuilder</a></code> does.
</p>
<p><code>buildBasket</code> is an alias
</p>
<p>TODO: allow for multiplier (divisor) that is a vector.
</p>


<h3>Value</h3>

<p>If <code>auto.assign</code> is FALSE, a univariate xts object. 
Otherwise, the xts object will be assigned to <code>spread_id</code> and the 
<code>spread_id</code> will be returned.
</p>


<h3>Note</h3>

<p>this could also be used to build a basket or a strip by using only 
positive values in memberratio
</p>


<h3>Author(s)</h3>

<p>Brian Peterson, Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fn_SpreadBuilder">fn_SpreadBuilder</a></code>
<code><a href="#topic+spread">spread</a></code> for instructions on defining the spread
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
currency("USD")
stock("SPY","USD",1)
stock("DIA","USD",1)
getSymbols(c("SPY","DIA")) 

spread("SPYDIA", "USD", c("SPY","DIA"),c(1,-1)) #define it.
buildSpread('SPYDIA') #build it.
head(SPYDIA)


## End(Not run)
</code></pre>

<hr>
<h2 id='C2M'>Month-to-Code and Code-to-Month</h2><span id='topic+C2M'></span><span id='topic+M2C'></span>

<h3>Description</h3>

<p>Convert month code (used for futures contracts) 
to abbreviated month name, or convert abbreviated month name to month code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C2M(code)

M2C(month)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C2M_+3A_code">code</code></td>
<td>
<p>Month code: F, G, H, J, K, M, N , Q, U, V, X, or Z</p>
</td></tr>
<tr><td><code id="C2M_+3A_month">month</code></td>
<td>
<p>Abbreviated month: jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, or dec</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corresponding code or month.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MC2N">MC2N</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C2M()
C2M("M")
C2M()[6]
M2C()
M2C("Sep")
M2C()[9]
</code></pre>

<hr>
<h2 id='CompareInstrumentFiles'>Compare Instrument Files</h2><span id='topic+CompareInstrumentFiles'></span>

<h3>Description</h3>

<p>Compare the .instrument environments of two files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareInstrumentFiles(file1, file2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CompareInstrumentFiles_+3A_file1">file1</code></td>
<td>
<p>A file containing an instrument environment</p>
</td></tr>
<tr><td><code id="CompareInstrumentFiles_+3A_file2">file2</code></td>
<td>
<p>Another file containing an instrument environment.  If not 
provided, <code>file1</code> will be compared against the currently loaded 
instrument environment.</p>
</td></tr>
<tr><td><code id="CompareInstrumentFiles_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+all.equal.instrument">all.equal.instrument</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will load two instrument files (created by 
<code><a href="#topic+saveInstruments">saveInstruments</a></code>) and find the differences between them.  In 
addition to returning a list of difference that are found, it will produce 
messages indicating the number of instruments that were added, the number of 
instruments that were removed, and the number of instruments that are 
different.
</p>


<h3>Value</h3>

<p>A list that contains the names of all instruments that were added,
the names of all instruments that were removed, and the changes to all
instruments that were updated (per <code><a href="#topic+all.equal.instrument">all.equal.instrument</a></code>).
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveInstruments">saveInstruments</a></code>, <code><a href="#topic+all.equal.instrument">all.equal.instrument</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#backup current .instrument environment
bak &lt;- as.list(FinancialInstrument:::.instrument, all.names=TRUE) 
old.wd &lt;- getwd()
tmpdir &lt;- tempdir()
setwd(tmpdir)
rm_instruments(keep=FALSE)
# create some instruments and save
stock(c("SPY", "DIA", "GLD"), currency("USD"))
saveInstruments("MyInstruments1")
# make some changes
rm_stocks("GLD")
stock("QQQ", "USD")
instrument_attr("SPY", "description", "S&amp;P ETF")
saveInstruments("MyInstruments2")
CompareInstrumentFiles("MyInstruments1", "MyInstruments2")
#Clean up
setwd(old.wd)
reloadInstruments(bak)

## End(Not run)
</code></pre>

<hr>
<h2 id='currencies'>currency metadata to be used by <code><a href="#topic+load.instruments">load.instruments</a></code></h2><span id='topic+currencies'></span>

<h3>Description</h3>

<p>currency metadata to be used by <code><a href="#topic+load.instruments">load.instruments</a></code>
</p>

<hr>
<h2 id='exchange_rate'>constructor for spot exchange rate instruments</h2><span id='topic+exchange_rate'></span>

<h3>Description</h3>

<p>Currency symbols (like any symbol) may be any combination of alphanumeric 
characters, but the FX market has a convention that says that the first 
currency in a currency pair is the 'target'  and the second currency in the 
symbol pair is the currency the rate ticks in.  So 'EURUSD' can be read as 
'USD per 1 EUR'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exchange_rate(primary_id = NULL, currency = NULL, counter_currency = NULL,
  tick_size = 0.01, identifiers = NULL, assign_i = TRUE,
  overwrite = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exchange_rate_+3A_primary_id">primary_id</code></td>
<td>
<p>string identifier, usually expressed as a currency pair 
'USDYEN' or 'EURGBP'</p>
</td></tr>
<tr><td><code id="exchange_rate_+3A_currency">currency</code></td>
<td>
<p>string identifying the currency the exchange rate ticks in</p>
</td></tr>
<tr><td><code id="exchange_rate_+3A_counter_currency">counter_currency</code></td>
<td>
<p>string identifying the currency which the rate uses 
as the base 'per 1' multiplier</p>
</td></tr>
<tr><td><code id="exchange_rate_+3A_tick_size">tick_size</code></td>
<td>
<p>minimum price change</p>
</td></tr>
<tr><td><code id="exchange_rate_+3A_identifiers">identifiers</code></td>
<td>
<p>named list of any other identifiers that should also be 
stored for this instrument</p>
</td></tr>
<tr><td><code id="exchange_rate_+3A_assign_i">assign_i</code></td>
<td>
<p>TRUE/FALSE. Should the instrument be assigned in the 
<code>.instrument</code> environment? (Default TRUE)</p>
</td></tr>
<tr><td><code id="exchange_rate_+3A_overwrite">overwrite</code></td>
<td>
<p><code>TRUE</code> by default.  If <code>FALSE</code>, an error will
be thrown if there is already an instrument defined with the same 
<code>primary_id</code>.</p>
</td></tr>
<tr><td><code id="exchange_rate_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>FinancialInstrument</code> the <code>currency</code> of the instrument should 
be the currency that the spot rate ticks in, so it will typically be the 
second currency listed in the symbol.
</p>
<p>Thanks to Garrett See for helping sort out the inconsistencies in different 
naming and calculating conventions.
</p>


<h3>References</h3>

<p>http://financial-dictionary.thefreedictionary.com/Base+Currency
</p>

<hr>
<h2 id='expires'>extract the correct expires value from an <code>instrument</code></h2><span id='topic+expires'></span>

<h3>Description</h3>

<p>Currently, there are methods for <code>instrument</code>, <code>spread</code>,
<code>character</code>, and <code>xts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expires(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expires_+3A_x">x</code></td>
<td>
<p>instrument or name of instrument</p>
</td></tr>
<tr><td><code id="expires_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Will return either the last expiration date before a given <code>Date</code>, or 
the first expiration date after a given <code>Date</code> 
(if <code>expired==FALSE</code>).
</p>
<p>If an <code><a href="#topic+instrument">instrument</a></code> contains a value for expires that does not
include a day (e.g. &quot;2012-03&quot;), or if the expires value is estimated from
a <code>future_series</code> primary_id, it will be assumed that the 
<code>instrument</code> expires on the first of the month (i.e. if the expires
value of an instrument were &quot;2012-03&quot;, or if there were no expires value
but the suffix_id were &quot;H12&quot;, the value returned would be &quot;2012-03-01&quot;).
Note that most non-energy future_series expire after the first of the month 
indicated by their suffix_id and most energy products expire in the month
prior to their suffix_id month.
</p>


<h3>Value</h3>

<p>an expiration <code>Date</code>
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expires.instrument">expires.instrument</a></code>, <code><a href="#topic+expires.character">expires.character</a></code>, 
<code><a href="#topic+sort_ids">sort_ids</a></code>
</p>
<p><code><a href="#topic+getInstrument">getInstrument</a></code> and <code><a href="#topic+buildHierarchy">buildHierarchy</a></code> to see actual 
values stored in <code>instrument</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
instr &lt;- instrument("FOO_U1", currency=currency("USD"), multiplier=1,
                    expires=c("2001-09-01", "2011-09-01", "2021-09-01"), 
                    assign_i=FALSE)
#Last value of expires that's not after Sys.Date
expires(instr) 
# First value of expires that hasn't already passed.
expires(instr, expired=FALSE)
# last value that's not after 2011-01-01
expires(instr, Date="2011-01-01") 
# first value that's not before 2011-01-01
expires(instr, Date="2011-01-01", expired=FALSE) 

## expires.character
expires("FOO_U1") # warning that FOO_U1 is not defined
instrument("FOO_U1", currency=currency("USD"), multiplier=1,
           expires=c("2001-09-01", "2011-09-01", "2021-09-01"), 
           assign_i=TRUE)
expires("FOO_U1")

## End(Not run)
</code></pre>

<hr>
<h2 id='expires.character'>character expires extraction method</h2><span id='topic+expires.character'></span>

<h3>Description</h3>

<p>if no <code>instrument</code> can be found by the id of <code>x</code>, or if the 
<code>instrument</code> does not have an <code>expires</code> attribute, an attempt
will be made to infer the year and month of expiration using <code>parse_id</code>
in which case the returned value will be a string of the format 
&ldquo;YYYY-MM&rdquo;.  Presently, <code>Date</code> and <code>expired</code> will be ignored 
if <code>x</code> is not the name of an instrument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'character'
expires(x, Date, expired = TRUE, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expires.character_+3A_date">Date</code></td>
<td>
<p>Can be a Date or character string.  When <code>expires</code> is a 
vector, the retuned value will be one of the two values of <code>expires</code> 
that are closest to <code>Date</code>. (which one will be determined by the value 
of <code>expired</code>).</p>
</td></tr>
<tr><td><code id="expires.character_+3A_expired">expired</code></td>
<td>
<p>TRUE/FALSE. This determines which date will be used when
<code>expires</code> is a vector.  If <code>expired</code> is <code>TRUE</code> the date 
returned will be the last one before <code>Date</code>.  If <code>expired</code> is 
<code>FALSE</code> the first one after <code>Date</code> will be returned.</p>
</td></tr>
<tr><td><code id="expires.character_+3A_silent">silent</code></td>
<td>
<p>silence warnings?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expires.instrument">expires.instrument</a></code>
</p>

<hr>
<h2 id='expires.instrument'>instrument expires extraction method</h2><span id='topic+expires.instrument'></span>

<h3>Description</h3>

<p>Returns either the last expiration date before <code>Date</code>, or the 
first expiration date after <code>Date</code> (if <code>expired==FALSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'instrument'
expires(x, Date, expired = TRUE, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expires.instrument_+3A_date">Date</code></td>
<td>
<p>Can be a Date or character string.  When <code>expires</code> is a 
vector, the retuned value will be one of the two values of <code>expires</code> 
that are closest to <code>Date</code>. (which one will be determined by the value 
of <code>expired</code>)</p>
</td></tr>
<tr><td><code id="expires.instrument_+3A_expired">expired</code></td>
<td>
<p>TRUE/FALSE. This determines which date will be used when
<code>expires</code> is a vector.  If <code>expired</code> is <code>TRUE</code> the date 
returned will be the last one before <code>Date</code>.  If <code>expired</code> is 
<code>FALSE</code> the first one after <code>Date</code> will be returned. Note that
if <code>expires</code> is a single value, <code>expired</code> will be ignored.</p>
</td></tr>
<tr><td><code id="expires.instrument_+3A_silent">silent</code></td>
<td>
<p>silence warnings?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expires">expires</a></code>
</p>

<hr>
<h2 id='expires.spread'>spread expires extraction method</h2><span id='topic+expires.spread'></span>

<h3>Description</h3>

<p><code>x$expires</code> will be returned if it is not <code>NULL</code>.  Otherwise, the 
(character representation of the) exiration date of the first-to-expire of 
the <code>members</code> will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spread'
expires(x, Date, expired = TRUE, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expires.spread_+3A_date">Date</code></td>
<td>
<p>Can be a Date or character string.  When <code>expires</code> is a 
vector, the retuned value will be one of the two values of <code>expires</code> 
that are closest to <code>Date</code>. (which one will be determined by the value 
of <code>expired</code>).</p>
</td></tr>
<tr><td><code id="expires.spread_+3A_expired">expired</code></td>
<td>
<p>TRUE/FALSE. This determines which date will be used when
<code>expires</code> is a vector.  If <code>expired</code> is <code>TRUE</code> the date 
returned will be the last one before <code>Date</code>.  If <code>expired</code> is 
<code>FALSE</code> the first one after <code>Date</code> will be returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expires.instrument">expires.instrument</a></code>
</p>

<hr>
<h2 id='expires.xts'>xts expires extraction method</h2><span id='topic+expires.xts'></span>

<h3>Description</h3>

<p>determines (or estimates) the expiration from an xts object by either
finding the last row that is not <code>NA</code> or by passing the name/symbol
of the xts object to <code><a href="#topic+expires.character">expires.character</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
expires(x, Date, expired = TRUE, silent = FALSE,
  src = c("data", "instrument"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expires.xts_+3A_src">src</code></td>
<td>
<p>either &ldquo;data&rdquo; or &ldquo;instrument&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>src</code> is &ldquo;data&rdquo;, the returned value will be the 
index of the last price that is not <code>NA</code> (price is determined by 
<code>quantmod:::getPrice</code>.  <code>getPrice</code> arguments <code>symbol</code> and 
<code>prefer</code> can be passed through dots.)
</p>
<p>If <code>src</code> is &ldquo;instrument&rdquo; the symbol of the xts object will
be passed to <code><a href="#topic+expires.character">expires.character</a></code>
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expires.instrument">expires.instrument</a></code>, <code><a href="#topic+expires">expires</a></code>
</p>

<hr>
<h2 id='find.instrument'>Find the primary_ids of instruments that contain certain strings</h2><span id='topic+find.instrument'></span>

<h3>Description</h3>

<p>Uses regular expression matching to find <code><a href="#topic+instrument">instrument</a></code>s
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.instrument(text, where = "anywhere", Symbols = ls_instruments(),
  ignore.case = TRUE, exclude = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.instrument_+3A_text">text</code></td>
<td>
<p>character string containing a regular expression.  This is used 
by <code><a href="base.html#topic+grep">grep</a></code> (see also) as the <code>pattern</code> argument.</p>
</td></tr>
<tr><td><code id="find.instrument_+3A_where">where</code></td>
<td>
<p>if &ldquo;anywhere&rdquo; all levels/attributes of the instruments
will be searched.  Otherwise, <code>where</code> can be used to specify in which
levels/attributes to look. (e.g. <code>c("name", "description")</code> would only
look for <code>text</code> in those 2 places.</p>
</td></tr>
<tr><td><code id="find.instrument_+3A_symbols">Symbols</code></td>
<td>
<p>the character ids of instruments to be searched. All are 
are searched by default.</p>
</td></tr>
<tr><td><code id="find.instrument_+3A_ignore.case">ignore.case</code></td>
<td>
<p>passed to <code><a href="base.html#topic+grep">grep</a></code>; if <code>FALSE</code>, the pattern
matching is case sensitive and if <code>TRUE</code>, case is ignored during 
matching.</p>
</td></tr>
<tr><td><code id="find.instrument_+3A_exclude">exclude</code></td>
<td>
<p>character vector of names of levels/attributes that should not
be searched.</p>
</td></tr>
<tr><td><code id="find.instrument_+3A_...">...</code></td>
<td>
<p>other arguments to pass through to <code><a href="base.html#topic+grep">grep</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of primary_ids of instruments that contain the 
sought after <code>text</code>.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildHierarchy">buildHierarchy</a></code>, <code><a href="#topic+instrument.table">instrument.table</a></code>, 
<code><a href="base.html#topic+regex">regex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
instruments.bak &lt;- as.list(FinancialInstrument:::.instrument, all.names=TRUE)
rm_instruments(keep.currencies=FALSE)
currency("USD")
stock("SPY", "USD", description="S&amp;P 500 ETF")
stock("DIA", "USD", description="DJIA ETF")
stock(c("AA", "AXP", "BA", "BAC", "CAT"), "USD", members.of='DJIA')
stock("BMW", currency("EUR"))
find.instrument("ETF")
find.instrument("DJIA") 
find.instrument("DJIA", "members.of")
find.instrument("USD")
find.instrument("EUR")
find.instrument("EUR", Symbols=ls_stocks())
find.instrument("USD", "type")

## Can be combined with buildHierachy
buildHierarchy(find.instrument("ETF"), "type", "description")

## Cleanup. restore previous instrument environment
rm_instruments(); rm_currencies()
loadInstruments(instruments.bak)

## End(Not run)
</code></pre>

<hr>
<h2 id='FindCommonInstrumentAttributes'>Find attributes that more than one instrument have in common</h2><span id='topic+FindCommonInstrumentAttributes'></span>

<h3>Description</h3>

<p>Find attributes that more than one instrument have in common
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindCommonInstrumentAttributes(Symbols, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindCommonInstrumentAttributes_+3A_symbols">Symbols</code></td>
<td>
<p>character vector of primary_ids of instruments</p>
</td></tr>
<tr><td><code id="FindCommonInstrumentAttributes_+3A_...">...</code></td>
<td>
<p>arguments to pass to 
<code><a href="#topic+getInstrument">getInstrument</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of names of attributes that all <code>Symbols</code>' 
instruments have in common
</p>


<h3>Note</h3>

<p>I really do not like the name of this function, so if it survives, its
name may change
</p>


<h3>Author(s)</h3>

<p>gsee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ibak &lt;- as.list(FinancialInstrument:::.instrument, all.names=TRUE)
Symbols &lt;- c("SPY", "AAPL")
define_stocks(Symbols, addIBslot=FALSE)
update_instruments.SPDR("SPY")
update_instruments.TTR("AAPL", exchange="NASDAQ")
FindCommonInstrumentAttributes(Symbols)
FindCommonInstrumentAttributes(c(Symbols, "USD"))
reloadInstruments(ibak)

## End(Not run)
</code></pre>

<hr>
<h2 id='fn_SpreadBuilder'>Calculate prices of a spread from 2 instruments.</h2><span id='topic+fn_SpreadBuilder'></span>

<h3>Description</h3>

<p>Given 2 products, calculate spread values for as many columns as practicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fn_SpreadBuilder(prod1, prod2, ratio = 1, currency = "USD", from = NULL,
  to = NULL, session_times = NULL, notional = TRUE,
  unique_method = c("make.index.unique", "duplicated", "least.liq",
  "price.change"), silent = FALSE, auto.assign = TRUE, env = .GlobalEnv,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fn_SpreadBuilder_+3A_prod1">prod1</code></td>
<td>
<p>chr name of instrument that will be the 1st leg of a 2 leg 
spread (Can also be xts data for first product)</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_prod2">prod2</code></td>
<td>
<p>chr name of instrument that will be the 2nd leg of a 2 leg 
spread (Can also be xts data for second product)</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_ratio">ratio</code></td>
<td>
<p>Hedge ratio. Can be a single number, or a vector of same length 
as data.</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_currency">currency</code></td>
<td>
<p>chr name of currency denomination of the spread</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_from">from</code></td>
<td>
<p>from Date to pass through to getSymbols if needed.</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_to">to</code></td>
<td>
<p>to Date to pass through to getSymbols if needed.</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_session_times">session_times</code></td>
<td>
<p>ISO-8601 time subset for the session time, in GMT, in 
the format 'T08:00/T14:59'</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_notional">notional</code></td>
<td>
<p>TRUE/FALSE. Should the prices be multiplied by contract 
multipliers before calculating the spread?</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_unique_method">unique_method</code></td>
<td>
<p>method for making the time series unique</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_silent">silent</code></td>
<td>
<p>silence warnings? (FALSE by default)</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_auto.assign">auto.assign</code></td>
<td>
<p>If <code>TRUE</code> (the default) the constructed spread will 
be stored in symbol created with <code><a href="#topic+make_spread_id">make_spread_id</a></code>. instrument 
metadata will also be created and stored with the same primary_id.</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_env">env</code></td>
<td>
<p>If <code>prod1</code> and <code>prod1</code> are character, this is where to 
<code>get</code> the data.  Also, if <code>auto.assign</code> is <code>TRUE</code> this is 
the environment in which to store the data (.GlobalEnv by default)</p>
</td></tr>
<tr><td><code id="fn_SpreadBuilder_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code>getSymbols</code> and/or 
<code><a href="#topic+make_spread_id">make_spread_id</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prod1</code> and <code>prod2</code> can be the names of instruments, or the xts 
objects themselves. Alternatively, <code>prod2</code> can be omitted, and a vector 
of 2 instrument names can be given to <code>prod1</code>. See the last example for 
this usage.
</p>
<p>If <code>prod1</code> and <code>prod2</code> are names (not xts data), it will try to get 
data for <code>prod1</code> and <code>prod2</code> from <code>env</code> (.GlobalEnv by 
default).  If it cannot find the data, it will get it with a call to 
getSymbols. Prices are multiplied by multipliers and exchange rates to get 
notional values in the currency specified.  The second leg's notional values 
are multiplied by <code>ratio</code>.  Then the difference is taken between the 
notionals of leg1 and the new values for leg2.
</p>
<p>&lsquo;make.index.unique&rsquo; uses the xts function <code>make.index.unique</code> 
&lsquo;least.liq&rsquo; subsets the spread time series, by using the timestamps 
of the leg that has the fewest rows.
&lsquo;duplicated&rsquo; removes any duplicate indexes.
&lsquo;price.change&rsquo; only return rows where there was a price change in the 
Bid, Mid or Ask Price of the spread.
</p>


<h3>Value</h3>

<p>an xts object with
Bid, Ask, Mid columns, 
or Open, Close, Adjusted columns, 
or Open, Close columns.
or Price column.
</p>


<h3>Note</h3>

<p>requires quantmod
</p>


<h3>Author(s)</h3>

<p>Lance Levenson, Brian Peterson, Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildSpread">buildSpread</a></code>
<code><a href="#topic+synthetic.instrument">synthetic.instrument</a></code>
<code><a href="#topic+formatSpreadPrice">formatSpreadPrice</a></code>
<code><a href="#topic+buildRatio">buildRatio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
currency("USD")
stock("SPY", "USD")
stock("DIA", "USD")
getSymbols(c("SPY","DIA"))

#can call with names of instrument/xts ojects
fSB &lt;- fn_SpreadBuilder("SPY","DIA") 
fSB2 &lt;- fn_SpreadBuilder(SPY,DIA) # or you can pass xts objects

#assuming you first somehow calculated the ratio to be a constant 1.1
fSB3 &lt;- fn_SpreadBuilder("SPY","DIA",1.1) 
head(fSB)

# Call fn_SpreadBuilder with vector of 2 instrument names
# in 1 arg instead of using both prod1 and prod2.
fSB4 &lt;- fn_SpreadBuilder(c("SPY","DIA"))
#download data and plot the closing values of a spread in one line
chartSeries(Cl(fn_SpreadBuilder(getSymbols(c("SPY","DIA")),auto.assign=FALSE)))

## End(Not run)
</code></pre>

<hr>
<h2 id='format_id'>format an id</h2><span id='topic+format_id'></span>

<h3>Description</h3>

<p>convert the primary_id or suffix_id of an <code>instrument</code> to a different format.
Primarily intended for <code><a href="#topic+future_series">future_series</a></code> instruments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_id(id, format = NULL, parse = c("id", "suffix"), sep = "_", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_id_+3A_id">id</code></td>
<td>
<p>character. the id to be reformatted. Can be either a primary_id or a suffix_id</p>
</td></tr>
<tr><td><code id="format_id_+3A_format">format</code></td>
<td>
<p>character string indicating how the id should be formatted. See Details.</p>
</td></tr>
<tr><td><code id="format_id_+3A_parse">parse</code></td>
<td>
<p>character name of parsing method to use:  &quot;id&quot; or &quot;suffix&quot;</p>
</td></tr>
<tr><td><code id="format_id_+3A_sep">sep</code></td>
<td>
<p>character that will separate root_id and suffix_id of output if calling with <code>parse="id"</code></p>
</td></tr>
<tr><td><code id="format_id_+3A_...">...</code></td>
<td>
<p>parameters to pass to the parsing function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formats for the suffix_id include 
'CY', 'CYY', and 'CYYYY' where C is the month code and Y is numeric.
'MMMY', 'MMMYY', 'MMMYYYY' where MMM is an uppercase month abbreviation.
'1xCY', '1xCYY', '1xCYYYY' for single-stock-futures.
</p>
<p>There are currently only 2 formats available for <code><a href="#topic+option_series">option_series</a></code>: 'opt2' and 'opt4'
where opt2 uses a 2 digit year and opt4 uses a 4 digit year.
</p>


<h3>Value</h3>

<p>character id of the appropriate format
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_id">parse_id</a></code>, <code><a href="#topic+parse_suffix">parse_suffix</a></code>,
<code><a href="#topic+M2C">M2C</a></code>, <code><a href="#topic+month_cycle2numeric">month_cycle2numeric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_id('U1', format='MMMYY', parse='suffix')
format_id('ES_JUN2011', format='CYY', parse='id')
format_id("SPY_20110826P129","opt2")
#several at once
id3 &lt;- c('VX_aug1','ES_U1', 'VX_U11')
format_id(id3,'MMMYY')
format_id(id3,'CYY')
format_id(id3,'CY',sep="")
</code></pre>

<hr>
<h2 id='formatSpreadPrice'>format the price of a synthetic instrument</h2><span id='topic+formatSpreadPrice'></span>

<h3>Description</h3>

<p>Divides the notional spread price by the spread multiplier and rounds prices 
to the nearest <code>tick_size</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatSpreadPrice(x, multiplier = 1, tick_size = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatSpreadPrice_+3A_x">x</code></td>
<td>
<p>xts price series</p>
</td></tr>
<tr><td><code id="formatSpreadPrice_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric multiplier (e.g. 1000 for crack spread to get 
from $ to $/bbl)</p>
</td></tr>
<tr><td><code id="formatSpreadPrice_+3A_tick_size">tick_size</code></td>
<td>
<p>minimum price change of the spread</p>
</td></tr>
</table>


<h3>Value</h3>

<p>price series of same length as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildSpread">buildSpread</a></code>, <code><a href="#topic+fn_SpreadBuilder">fn_SpreadBuilder</a></code>
</p>

<hr>
<h2 id='future_series'>Constructors for series contracts</h2><span id='topic+future_series'></span><span id='topic+option_series'></span><span id='topic+bond_series'></span>

<h3>Description</h3>

<p>Constructors for series contracts on instruments such as options and futures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_series(primary_id, root_id = NULL, suffix_id = NULL,
  first_traded = NULL, expires = NULL, identifiers = NULL,
  assign_i = TRUE, overwrite = TRUE, ...)

option_series(primary_id, root_id = NULL, suffix_id = NULL,
  first_traded = NULL, expires = NULL, callput = c("call", "put"),
  strike = NULL, identifiers = NULL, assign_i = TRUE, overwrite = TRUE,
  ...)

bond_series(primary_id, suffix_id, ..., first_traded = NULL,
  maturity = NULL, identifiers = NULL, payment_schedule = NULL,
  assign_i = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="future_series_+3A_primary_id">primary_id</code></td>
<td>
<p>String describing the unique ID for the instrument. May be 
a vector for <code>future_series</code> and <code>option_series</code></p>
</td></tr>
<tr><td><code id="future_series_+3A_root_id">root_id</code></td>
<td>
<p>String product code or underlying_id, usually something like 
'ES' or 'CL' for futures, or the underlying stock symbol (maybe preceded 
with a dot) for equity options.</p>
</td></tr>
<tr><td><code id="future_series_+3A_suffix_id">suffix_id</code></td>
<td>
<p>String suffix that should be associated with the series, 
usually something like 'Z9' or 'Mar10' denoting expiration and year.</p>
</td></tr>
<tr><td><code id="future_series_+3A_first_traded">first_traded</code></td>
<td>
<p>String coercible to Date for first trading day.</p>
</td></tr>
<tr><td><code id="future_series_+3A_expires">expires</code></td>
<td>
<p>String coercible to Date for expiration date</p>
</td></tr>
<tr><td><code id="future_series_+3A_identifiers">identifiers</code></td>
<td>
<p>Named list of any other identifiers that should also be 
stored for this instrument.</p>
</td></tr>
<tr><td><code id="future_series_+3A_assign_i">assign_i</code></td>
<td>
<p>TRUE/FALSE. Should the instrument be assigned in the 
<code>.instrument</code> environment?</p>
</td></tr>
<tr><td><code id="future_series_+3A_overwrite">overwrite</code></td>
<td>
<p>TRUE/FALSE. If FALSE, only <code>first_traded</code> and 
<code>expires</code> will be updated.</p>
</td></tr>
<tr><td><code id="future_series_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="future_series_+3A_callput">callput</code></td>
<td>
<p>Right of option; call or put</p>
</td></tr>
<tr><td><code id="future_series_+3A_strike">strike</code></td>
<td>
<p>Strike price of option</p>
</td></tr>
<tr><td><code id="future_series_+3A_maturity">maturity</code></td>
<td>
<p>String coercible to Date for maturity date of bond series.</p>
</td></tr>
<tr><td><code id="future_series_+3A_payment_schedule">payment_schedule</code></td>
<td>
<p>Not currently being implemented</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The root <code>instrument</code> (e.g. the <code>future</code> or <code>option</code>) must be
defined first.
</p>
<p>In custom parameters for these series contracts, we have often found it
useful to store attributes such as local roll-on and roll-off dates
(rolling not on the <code>first_listed</code> or <code>expires</code>.
</p>
<p>For <code>future_series</code> and <code>option_series</code> you may either provide a 
<code>primary_id</code> (or vector of <code>primary_id</code>s), 
OR both a <code>root_id</code> and <code>suffix_id</code>.
</p>
<p>Note that the code for <code>bond</code> and <code>bond_series</code> has not been 
updated recently and may not support all the features supported for
<code>option_series</code> and <code>future_series</code>.  Patches welcome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
currency("USD")
future("ES","USD",multiplier=50, tick_size=0.25)
future_series('ES_U1')
future_series(root_id='ES',suffix_id='Z11')
stock('SPY','USD')
option('.SPY','USD',multiplier=100,underlying_id='SPY')
#can use either .SPY or SPY for the root_id. 
#it will find the one that is option specs.
option_series('SPY_110917C125', expires='2011-09-16')
option_series(root_id='SPY',suffix_id='111022P125')
option_series(root_id='.SPY',suffix_id='111119C130')
#multiple series instruments at once.
future_series(c("ES_H12","ES_M12"))
option_series(c("SPY_110917C115","SPY_110917P115"))

## End(Not run)
</code></pre>

<hr>
<h2 id='getInstrument'>Primary accessor function for getting objects of class 'instrument'</h2><span id='topic+getInstrument'></span>

<h3>Description</h3>

<p>This function will search the <code>.instrument</code> environment for objects of
class <code>type</code>, using first the <code>primary_id</code> and then any 
<code>identifiers</code> to locate the instrument.  Finally, it will try adding 1 
and then 2 dots to the beginning of the <code>primary_id</code> to see if an 
instrument was stored there to avoid naming conflicts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInstrument(x, Dates = NULL, silent = FALSE, type = "instrument")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getInstrument_+3A_x">x</code></td>
<td>
<p>String identifier of instrument to retrieve</p>
</td></tr>
<tr><td><code id="getInstrument_+3A_dates">Dates</code></td>
<td>
<p>date range to retrieve 'as of', may not currently be implemented</p>
</td></tr>
<tr><td><code id="getInstrument_+3A_silent">silent</code></td>
<td>
<p>if TRUE, will not warn on failure, default FALSE</p>
</td></tr>
<tr><td><code id="getInstrument_+3A_type">type</code></td>
<td>
<p>class of object to look for. See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+future">future</a></code> and <code><a href="#topic+option">option</a></code> objects may have a primary_id 
that begins with 1 or 2 dots (in order to avoid naming conflics).  For 
example, the root specs for options (or futures) on the stock with ticker 
&quot;SPY&quot; may be stored with a primary_id of &quot;SPY&quot;, &quot;.SPY&quot;, or &quot;..SPY&quot;.  
<code>getInstrument</code> will try using each possible <code>primary_id</code>
until it finds an instrument of the appropriate <code>type</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
option('..VX', multiplier=100, 
  underlying_id=future('.VX',multiplier=1000, 
    underlying_id=synthetic('VIX', currency("USD"))))

getInstrument("VIX")
getInstrument('VX') #returns the future
getInstrument("VX",type='option')
getInstrument('..VX') #finds the option

## End(Not run)
</code></pre>

<hr>
<h2 id='getSymbols.FI'>getSymbols method for loading data from split files</h2><span id='topic+getSymbols.FI'></span>

<h3>Description</h3>

<p>This function should probably get folded back into getSymbols.rda in 
quantmod.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSymbols.FI(Symbols, from = getOption("getSymbols.FI.from", "2010-01-01"),
  to = getOption("getSymbols.FI.to", Sys.Date()), ...,
  dir = getOption("getSymbols.FI.dir", ""),
  return.class = getOption("getSymbols.FI.return.class", "xts"),
  extension = getOption("getSymbols.FI.extension", "rda"),
  split_method = getOption("getSymbols.FI.split_method", c("days", "common")),
  use_identifier = getOption("getSymbols.FI.use_identifier", NA),
  date_format = getOption("getSymbols.FI.date_format"),
  verbose = getOption("getSymbols.FI.verbose", TRUE),
  days_to_omit = getOption("getSymbols.FI.days_to_omit", c("Saturday",
  "Sunday")), indexTZ = getOption("getSymbols.FI.indexTZ", NA))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSymbols.FI_+3A_symbols">Symbols</code></td>
<td>
<p>a character vector specifying the names of each symbol to be 
loaded</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_from">from</code></td>
<td>
<p>Retrieve data no earlier than this date. Default '2010-01-01'.</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_to">to</code></td>
<td>
<p>Retrieve data through this date. Default Sys.Date().</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_dir">dir</code></td>
<td>
<p>if not specified in getSymbolLookup, directory string to use.
default &quot;&quot;</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_return.class">return.class</code></td>
<td>
<p>only &quot;xts&quot; is currently supported</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_extension">extension</code></td>
<td>
<p>file extension, default &quot;rda&quot;</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_split_method">split_method</code></td>
<td>
<p>string specifying the method used to split the files, 
currently &lsquo;days&rsquo; or &lsquo;common&rsquo;, see 
<code><a href="#topic+setSymbolLookup.FI">setSymbolLookup.FI</a></code></p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_use_identifier">use_identifier</code></td>
<td>
<p>optional. identifier used to construct the 
<code>primary_id</code> of the instrument. If you use this, you must have 
previously defined the <code><a href="#topic+instrument">instrument</a></code></p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_date_format">date_format</code></td>
<td>
<p>format as per the <code><a href="base.html#topic+strptime">strptime</a></code>, see Details</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_days_to_omit">days_to_omit</code></td>
<td>
<p>character vector of names of weekdays that should not be 
loaded.  Default is <code>c("Saturday", "Sunday")</code>.  Use <code>NULL</code> to 
attempt to load data for all days of the week.</p>
</td></tr>
<tr><td><code id="getSymbols.FI_+3A_indextz">indexTZ</code></td>
<td>
<p>valid TZ string. (e.g. &ldquo;America/Chicago&rdquo; or 
&ldquo;America/New_York&rdquo;) See <code><a href="xts.html#topic+indexTZ">indexTZ</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meant to be called internally by <code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> .
</p>
<p>The symbol lookup table will most likely be loaded by 
<code><a href="#topic+setSymbolLookup.FI">setSymbolLookup.FI</a></code>
</p>
<p>If date_format is NULL (the Default), we will assume an ISO date as changed 
by <code><a href="base.html#topic+make.names">make.names</a></code>, for example, 2010-12-01 would be assumed to be a 
file containing 2010.12.01
</p>
<p>If <code>indexTZ</code> is provided, the data will be converted to that timezone
</p>
<p>If auto.assign is FALSE, <code>Symbols</code> should be of length 1.  Otherwise, 
<code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> will give you an error that says 
&ldquo;must use auto.assign=TRUE for multiple Symbols requests&rdquo;
However, if you were to call <code>getSymbols.FI</code> directly (which is 
<em>NOT</em> recommended) with <code>auto.assign=FALSE</code> and more than one 
Symbol, a list would be returned.
</p>
<p>Argument matching for this function is as follows.  If the user provides a 
value for an argument, that value will be used.  If the user did not provide
a value for an argument, but there is a value for that argument for the 
given <code>Symbol</code> in the Symbol Lookup Table (see 
<code><a href="#topic+setSymbolLookup.FI">setSymbolLookup.FI</a></code>), that value will be used.  Otherwise, 
the formal defaults will be used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveSymbols.days">saveSymbols.days</a></code>
<code><a href="#topic+instrument">instrument</a></code>
<code><a href="#topic+setSymbolLookup.FI">setSymbolLookup.FI</a></code>
<code><a href="#topic+loadInstruments">loadInstruments</a></code>
<code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getSymbols("SPY", src='yahoo')
dir.create("tmpdata")
saveSymbols.common("SPY", base_dir="tmpdata")
rm("SPY")
getSymbols("SPY", src='FI', dir="tmpdata", split_method='common')
unlink("tmpdata/SPY", recursive=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='instrument'>instrument class constructors</h2><span id='topic+instrument'></span><span id='topic+stock'></span><span id='topic+bond'></span><span id='topic+future'></span><span id='topic+option'></span><span id='topic+currency'></span><span id='topic+fund'></span>

<h3>Description</h3>

<p>All 'currency' instruments must be defined before instruments of other types 
may be defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instrument(primary_id, ..., currency, multiplier, tick_size = NULL,
  identifiers = NULL, type = NULL, assign_i = FALSE, overwrite = TRUE)

stock(primary_id, currency = NULL, multiplier = 1, tick_size = 0.01,
  identifiers = NULL, assign_i = TRUE, overwrite = TRUE, ...)

fund(primary_id, currency = NULL, multiplier = 1, tick_size = 0.01,
  identifiers = NULL, assign_i = TRUE, overwrite = TRUE, ...)

future(primary_id, currency, multiplier, tick_size = NULL,
  identifiers = NULL, assign_i = TRUE, overwrite = TRUE, ...,
  underlying_id = NULL)

option(primary_id, currency, multiplier, tick_size = NULL,
  identifiers = NULL, assign_i = TRUE, overwrite = TRUE, ...,
  underlying_id = NULL)

currency(primary_id, identifiers = NULL, assign_i = TRUE, ...)

bond(primary_id, currency, multiplier, tick_size = NULL, identifiers = NULL,
  assign_i = TRUE, overwrite = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="instrument_+3A_primary_id">primary_id</code></td>
<td>
<p>String describing the unique ID for the instrument. Most 
of the wrappers allow this to be a vector.</p>
</td></tr>
<tr><td><code id="instrument_+3A_...">...</code></td>
<td>
<p>Any other passthru parameters, including</p>
</td></tr>
<tr><td><code id="instrument_+3A_currency">currency</code></td>
<td>
<p>String describing the currency ID of an object of type 
<code><a href="#topic+currency">currency</a></code></p>
</td></tr>
<tr><td><code id="instrument_+3A_multiplier">multiplier</code></td>
<td>
<p>Numeric multiplier to apply to the price in the instrument 
to get to notional value.</p>
</td></tr>
<tr><td><code id="instrument_+3A_tick_size">tick_size</code></td>
<td>
<p>The tick increment of the instrument price in it's 
trading venue, as numeric quantity (e.g. 1/8 is .125)</p>
</td></tr>
<tr><td><code id="instrument_+3A_identifiers">identifiers</code></td>
<td>
<p>Named list of any other identifiers that should also be 
stored for this instrument</p>
</td></tr>
<tr><td><code id="instrument_+3A_type">type</code></td>
<td>
<p>instrument type to be appended to the class definition, typically 
not set by user</p>
</td></tr>
<tr><td><code id="instrument_+3A_assign_i">assign_i</code></td>
<td>
<p>TRUE/FALSE. Should the instrument be assigned to the 
<code>.instrument</code> environment?  Default is FALSE for <code>instrument</code>, 
TRUE for wrappers.</p>
</td></tr>
<tr><td><code id="instrument_+3A_overwrite">overwrite</code></td>
<td>
<p>TRUE/FALSE. Should existing instruments with the same
primary_id be overwritten? Default is TRUE. If FALSE, an error will be 
thrown and the instrument will not be created.</p>
</td></tr>
<tr><td><code id="instrument_+3A_underlying_id">underlying_id</code></td>
<td>
<p>For derivatives, the identifier of the instrument that 
this one is derived from, may be <code>NULL</code> for cash settled instruments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In ... you may pass any other arbitrary instrument fields that will be used 
to create 'custom' fields.  S3 classes in <span class="rlang"><b>R</b></span> are basically lists with a class 
attribute.  We use this to our advantage to allow us to set arbitrary fields.
</p>
<p><code>identifiers</code> should be a named list to specify other identifiers beyond 
the <code>primary_id</code>.  Please note that whenever possible, these should 
still be unique.  Perhaps Bloomberg, Reuters-X.RIC, CUSIP, etc.
<code><a href="#topic+getInstrument">getInstrument</a></code> will return the first (and only the first) match 
that it finds, starting with the primary_id, and then searching the 
primary_ids of all instruments for each of the <code>identifiers</code>.  Note that
when a large number of instruments are defined, it is faster to find 
instruments by <code>primary_id</code> than by <code>identifiers</code> because it looks
for <code>primary_id</code>s first.
</p>
<p>The <code>primary_id</code> will be coerced within reason to a valid <span class="rlang"><b>R</b></span> variable 
name by using <code><a href="base.html#topic+make.names">make.names</a></code>. We also remove any leading '1' digit 
(a simple workaround to account for issues with the Reuters API).  If you are
defining an instrument that is not a <code>currency</code>, with a primary_id that
already belongs to a <code>currency</code>, a new primary_id will be create using
<code>make.names</code>.  For example, <code>stock("USD", currency("USD"))</code>, would
create a stock with a primary_id of &ldquo;USD.1&rdquo; instead of overwritting
the <code>currency</code>.
</p>
<p>Please use some care to choose your primary identifiers so that R won't 
complain.  If you have better regular expression code, we'd be happy to 
include it.
</p>
<p>Identifiers will also try to be discovered as regular named arguments passed 
in via <code>...</code>.  We currently match any of the following: 
<code>"CUSIP","SEDOL","ISIN","OSI","Bloomberg","Reuters","X.RIC","CQG","TT","Yahoo","Google"</code>
Others may be specified using a named list of identifiers, as described above.
</p>
<p><code>assign_i</code> will use <code><a href="base.html#topic+assign">assign</a></code> to place the constructed 
instrument class object into the <code>.instrument</code> environment.  Most of the 
special type-specific constructors will use <code>assign_i=TRUE</code> internally. 
Calling with <code>assign_i=FALSE</code>, or not specifying it, will return an 
object and will <em>not</em> store it.  Use this option ether to wrap calls to 
<code>instrument</code> prior to further processing (and presumably assignment) or 
to test your parameters before assignment.
</p>
<p>If <code>overwrite=FALSE</code> is used, an error will be thrown if any 
<code>primary_id</code>s are already in use.
</p>
<p>As of version 0.10.0, the .instrument environment is located at the top level
of the package. i.e. <code>.instrument</code>.
</p>
<p><code>future</code> and <code>option</code> are used to define the contract specs of a 
series of instruments.  The <code>primary_id</code> for these can begin with 1 or 
2 dots if you need to avoid overwriting another instrument.
For example, if you have a <code>stock</code> with &lsquo;SPY&rsquo; as the 
<code>primary_id</code>, you could use &lsquo;.SPY&rsquo; as the <code>primary_id</code> of 
the <code>option</code> specs, and &lsquo;..SPY&rsquo; as the <code>primary_id</code> of the 
single stock <code>future</code> specs. (or vice versa)
</p>
<p>You can (optionally) provide a <code>src</code> argument in which case, it will be 
used in a call to <code><a href="quantmod.html#topic+setSymbolLookup">setSymbolLookup</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+currency">currency</a></code>,
<code><a href="#topic+exchange_rate">exchange_rate</a></code>,
<code><a href="#topic+option_series">option_series</a></code>,
<code><a href="#topic+future_series">future_series</a></code>,
<code><a href="#topic+spread">spread</a></code>,
<code><a href="#topic+load.instruments">load.instruments</a></code>
</p>

<hr>
<h2 id='instrument_attr'>Add or change an attribute of an instrument</h2><span id='topic+instrument_attr'></span>

<h3>Description</h3>

<p>This function will add or overwrite the data stored in the specified slot of 
the specified instrument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instrument_attr(primary_id, attr, value, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="instrument_attr_+3A_primary_id">primary_id</code></td>
<td>
<p>primary_id of the instrument that will be updated</p>
</td></tr>
<tr><td><code id="instrument_attr_+3A_attr">attr</code></td>
<td>
<p>Name of the slot that will be added or changed</p>
</td></tr>
<tr><td><code id="instrument_attr_+3A_value">value</code></td>
<td>
<p>What to assign to the <code>attr</code> slot of the <code>primary_id</code> 
instrument</p>
</td></tr>
<tr><td><code id="instrument_attr_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>getInstrument</code>. For example,
<code>type</code> could be provided to allow for <code>primary_id</code> to be an
identifier that is shared by more that one instrument (of different types)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>attr</code> you are trying to change is the &ldquo;primary_id,&rdquo; the 
instrument will be renamed. (A copy of the instrument will be stored by the 
name of <code>value</code> and the old instrument will be removed.)
If the <code>attr</code> you are changing is &ldquo;type&rdquo;, the instrument will be 
reclassed with that type. If <code>attr</code> is &ldquo;src&rdquo;, <code>value</code> will 
be used in a call to <code>setSymbolLookup</code>.  Other checks are in place to 
make sure that &ldquo;currency&rdquo; remains a <code><a href="#topic+currency">currency</a></code> object and 
that &ldquo;multiplier&rdquo; and &ldquo;tick_size&rdquo; can only be changed to 
reasonable values.
</p>
<p>If <code>attr</code> is &ldquo;identifiers&rdquo; and <code>value</code> is <code>NULL</code>, 
<code>identifiers</code> will be set to <code>list()</code>.  If <code>value</code> is not a 
list, <code><a href="#topic+add.identifier">add.identifier</a></code> will be called with <code>value</code>.
<code>add.identifier</code> will convert <code>value</code> to a list and append it to
the current <code>identifiers</code>
</p>


<h3>Value</h3>

<p>called for side-effect
</p>


<h3>Note</h3>

<p>You can remove an attribute/level from an instrument by calling this 
function with <code>value=NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
currency("USD")
stock("SPY","USD")
instrument_attr("USD","description","U.S. Dollar")
instrument_attr("SPY", "description", "An ETF")
getInstrument("USD")
getInstrument("SPY")

#Call with value=NULL to remove an attribute
instrument_attr("SPY", "description", NULL)
getInstrument("SPY")

instrument_attr("SPY","primary_id","SPX") #move/rename it
instrument_attr("SPX","type","synthetic") #re-class
instrument_attr("SPX","src",list(src='yahoo',name='^GSPC')) #setSymbolLookup
getSymbols("SPX") #knows where to look because the last line setSymbolLookup
getInstrument("SPX")

## End(Not run)
</code></pre>

<hr>
<h2 id='instrument.auto'>Create an instrument based on name alone</h2><span id='topic+instrument.auto'></span>

<h3>Description</h3>

<p>Given a name, this function will attempt to create
an instrument of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instrument.auto(primary_id, currency = NULL, multiplier = 1,
  silent = FALSE, default_type = "unknown", root = NULL,
  assign_i = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="instrument.auto_+3A_primary_id">primary_id</code></td>
<td>
<p>charater primary identifier of instrument to be created</p>
</td></tr>
<tr><td><code id="instrument.auto_+3A_currency">currency</code></td>
<td>
<p>character name of currency that instrument will be 
denominated it. Default=&ldquo;USD&rdquo;</p>
</td></tr>
<tr><td><code id="instrument.auto_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric product multiplier</p>
</td></tr>
<tr><td><code id="instrument.auto_+3A_silent">silent</code></td>
<td>
<p>TRUE/FALSE. silence warnings?</p>
</td></tr>
<tr><td><code id="instrument.auto_+3A_default_type">default_type</code></td>
<td>
<p>What type of instrument to make if it is not clear from 
the primary_id. (&quot;stock&quot;, &quot;future&quot;, etc.) Default is NULL.</p>
</td></tr>
<tr><td><code id="instrument.auto_+3A_root">root</code></td>
<td>
<p>character string to pass to <code><a href="#topic+parse_id">parse_id</a></code> to be used as 
the root_id for easier/more accurate parsing.</p>
</td></tr>
<tr><td><code id="instrument.auto_+3A_assign_i">assign_i</code></td>
<td>
<p>TRUE/FALSE. Should the <code>instrument</code> be assigned in the 
<code>.instrument</code> environment?</p>
</td></tr>
<tr><td><code id="instrument.auto_+3A_...">...</code></td>
<td>
<p>other passthrough parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>currency</code> is not already defined, it will be defined (unless it is 
not 3 uppercase characters).  The default value for <code>currency</code> is 
&ldquo;USD&rdquo;.  If you do not provide a value for <code>currency</code>, 
&ldquo;USD&rdquo; will be defined and used to create the instrument.
</p>
<p>If <code>primary_id</code> is 6 uppercase letters and <code>default_type</code> is not 
provided, it will be assumed that it is the primary_id of an 
<code><a href="#topic+exchange_rate">exchange_rate</a></code>, in which case, the 1st and 2nd half of 
<code>primary_id</code> will be defined as <code><a href="#topic+currency">currency</a></code>s if not 
the names of already defined <code><a href="#topic+instrument">instrument</a></code>s.
If the <code>primary_id</code> begins with a &ldquo;^&rdquo; it will be assumed that it 
is a yahoo symbol and that the instrument is an index (synthetic), and the 
&lsquo;src&rsquo; will be set to &ldquo;yahoo&rdquo;. 
(see <code>setSymbolLookup</code>)
</p>
<p>If it is not clear from the <code>primary_id</code> what type of instrument to 
create, an instrument of type <code>default_type</code> will be created (which is 
'NULL' by default).  This will happen when <code>primary_id</code> is that of a 
<code><a href="#topic+stock">stock</a></code>, <code><a href="#topic+future">future</a></code>, <code><a href="#topic+option">option</a></code>, or 
<code><a href="#topic+bond">bond</a></code>.  This may also happen if <code>primary_id</code> is that of a 
<code><a href="#topic+future_series">future_series</a></code> or <code><a href="#topic+option_series">option_series</a></code> but the 
corresponding <code>future</code> or <code>option</code> cannot be found.  In this case, 
the instrument type would be <code>default_type</code>, but a lot of things would 
be filled in as if it were a valid series instrument (e.g. &lsquo;expires&rsquo;, 
&lsquo;strike&rsquo;, &lsquo;suffix_id&rsquo;, etc.)
</p>


<h3>Value</h3>

<p>Primarily called for its side-effect, but will return the name of the 
instrument that was created
</p>


<h3>Note</h3>

<p>This is not intended to be used to create instruments of type 
<code>stock</code>, <code>future</code>, <code>option</code>,
or <code>bond</code> although it may be updated in the future.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
instrument.auto("CL_H1.U1")
getInstrument("CL_H1.U1") #guaranteed_spread

instrument.auto("ES_H1.YM_H1")
getInstrument("ES_H1.YM_H1") #synthetic

currency(c("USD","EUR"))
instrument.auto("EURUSD")
getInstrument("EURUSD") #made an exchange_rate

instrument.auto("VX_H11") #no root future defined yet!
getInstrument("VX_H11") #couldn't find future, didnt make future_series
future("VX","USD",1000,underlying_id=synthetic("SPX","USD")) #make the root 
instrument.auto("VX_H11") #and try again
getInstrument("VX_H11") #made a future_series

## End(Not run)
</code></pre>

<hr>
<h2 id='instrument.table'>Create data.frame with attributes of all instruments</h2><span id='topic+instrument.table'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="#topic+buildHierarchy">buildHierarchy</a></code>, that defaults to returning all attributes.
By default it looks for the instrument with the most attribute levels, and uses those attributes
for columns.  If you would prefer to use the attribute levels of a given instrument to build the columns, 
use <code>attrs.of</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instrument.table(symbols = NULL, exclude = NULL, attrs.of = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="instrument.table_+3A_symbols">symbols</code></td>
<td>
<p>A vector of instrument names to include</p>
</td></tr>
<tr><td><code id="instrument.table_+3A_exclude">exclude</code></td>
<td>
<p>A vector of names of attributes that should not be included in the returned data.frame</p>
</td></tr>
<tr><td><code id="instrument.table_+3A_attrs.of">attrs.of</code></td>
<td>
<p>name of a FinancialInstrument instrument. Returned data.frame columns will be the attributes of instrument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if there are some attributes that you do not want to be included in the returned data.frame, 
specify them with <code>exclude</code>.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildHierarchy">buildHierarchy</a></code>, <code><a href="#topic+instrument">instrument</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
currency('USD')
stock('GM','USD',exchange='NYSE')
stock('XOM','USD',description='Exxon Mobil')
instrument.table()
#Usually, currencies will not have as many attribute levels
#as other instruments, so you may want to exclude them from the table.
it &lt;- instrument.table(exclude="USD|GM", attrs.of = "XOM") #columns created based on XOM instrument
#it &lt;- instrument.table(exclude=c('USD','GM'), attrs.of = "XOM") #same thing
it &lt;- instrument.table(exclude='tick_size|description|exchange')

## End(Not run)
</code></pre>

<hr>
<h2 id='is.currency'>class test for object supposedly of type 'currency'</h2><span id='topic+is.currency'></span>

<h3>Description</h3>

<p>class test for object supposedly of type 'currency'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.currency(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.currency_+3A_x">x</code></td>
<td>
<p>object to test for type</p>
</td></tr>
</table>

<hr>
<h2 id='is.currency.name'>check each element of a character vector to see if it is either the 
primary_id or an identifier of a <code><a href="#topic+currency">currency</a></code></h2><span id='topic+is.currency.name'></span>

<h3>Description</h3>

<p>check each element of a character vector to see if it is either the 
primary_id or an identifier of a <code><a href="#topic+currency">currency</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.currency.name(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.currency.name_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>

<hr>
<h2 id='is.instrument'>class test for object supposedly of type 'instrument'</h2><span id='topic+is.instrument'></span>

<h3>Description</h3>

<p>class test for object supposedly of type 'instrument'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.instrument(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.instrument_+3A_x">x</code></td>
<td>
<p>object to test for type</p>
</td></tr>
</table>

<hr>
<h2 id='is.instrument.name'>check each element of a character vector to see if it is either the 
primary_id or an identifier of an <code><a href="#topic+instrument">instrument</a></code></h2><span id='topic+is.instrument.name'></span>

<h3>Description</h3>

<p>check each element of a character vector to see if it is either the 
primary_id or an identifier of an <code><a href="#topic+instrument">instrument</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.instrument.name(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.instrument.name_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>

<hr>
<h2 id='load.instruments'>load instrument metadata into the .instrument environment</h2><span id='topic+load.instruments'></span>

<h3>Description</h3>

<p>This function will load instrument metadata (data about the data)
either from a file specified by the <code>file</code> argument or
from a <code>data.frame</code> specified by the <code>metadata</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.instruments(file = NULL, ..., metadata = NULL, id_col = 1,
  default_type = "stock", identifier_cols = NULL, overwrite = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load.instruments_+3A_file">file</code></td>
<td>
<p>string identifying file to load, default NULL, see Details</p>
</td></tr>
<tr><td><code id="load.instruments_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="load.instruments_+3A_metadata">metadata</code></td>
<td>
<p>optional, data.frame containing metadata, default NULL, see Details</p>
</td></tr>
<tr><td><code id="load.instruments_+3A_id_col">id_col</code></td>
<td>
<p>numeric column containing id if primary_id isn't defined, default 1</p>
</td></tr>
<tr><td><code id="load.instruments_+3A_default_type">default_type</code></td>
<td>
<p>character string to use as instrument type fallback, see Details</p>
</td></tr>
<tr><td><code id="load.instruments_+3A_identifier_cols">identifier_cols</code></td>
<td>
<p>character vector of field names to be passed as identifiers, see Details</p>
</td></tr>
<tr><td><code id="load.instruments_+3A_overwrite">overwrite</code></td>
<td>
<p>TRUE/FALSE. See <code><a href="#topic+instrument">instrument</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will attempt to make reasonable assumptions about what you're trying to do, but this isn't magic.
</p>
<p>You will typically need to specify the <code>type</code> of instrument to be loaded, failure to do so will generate a Warning and <code>default_type</code> will be used.
</p>
<p>You will need to specify a <code>primary_id</code>, or define a <code>id_col</code> that contains the data to be used as the primary_id of the instrument.
</p>
<p>You will need to specify a <code>currency</code>, unless the instrument <code>type</code> is 'currency'
</p>
<p>Use the <code>identifier_cols</code> argument to specify which fields (if any) in the CSV are to be passed to <code><a href="#topic+instrument">instrument</a></code> as the <code>identifiers</code> argument
</p>
<p>Typically, columns will exist for <code>multiplier</code> and <code>tick_size</code>.
</p>
<p>Any other columns necessary to define the specified instrument type will also be required to avoid fatal Errors.
</p>
<p>Additional columns will be processed, either as additional identifiers for recognized identifier names, or as custom fields.  See <code><a href="#topic+instrument">instrument</a></code> for more information on custom fields.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadInstruments">loadInstruments</a></code>,
<code><a href="#topic+instrument">instrument</a></code>, 
<code><a href="#topic+setSymbolLookup.FI">setSymbolLookup.FI</a></code>, 
<code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code>, 
<code><a href="#topic+getSymbols.FI">getSymbols.FI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
load.instruments(system.file('data/currencies.csv.gz',package='FinancialInstrument'))
load.instruments(system.file('data/root_contracts.csv.gz',package='FinancialInstrument'))
load.instruments(system.file('data/future_series.csv.gz',package='FinancialInstrument'))


## End(Not run)
</code></pre>

<hr>
<h2 id='ls_by_currency'>shows or removes instruments of given currency denomination(s)</h2><span id='topic+ls_by_currency'></span><span id='topic+rm_by_currency'></span><span id='topic+ls_USD'></span><span id='topic+ls_AUD'></span><span id='topic+ls_GBP'></span><span id='topic+ls_CAD'></span><span id='topic+ls_EUR'></span><span id='topic+ls_JPY'></span><span id='topic+ls_CHF'></span><span id='topic+ls_HKD'></span><span id='topic+ls_SEK'></span><span id='topic+ls_NZD'></span>

<h3>Description</h3>

<p>ls_ functions get names of instruments denominated in a given currency (or
currencies) rm_ functions remove instruments of a given currency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_by_currency(currency, pattern = NULL, match = TRUE,
  show.currencies = FALSE)

rm_by_currency(x, currency, keep.currencies = TRUE)

ls_USD(pattern = NULL, match = TRUE, show.currencies = FALSE)

ls_AUD(pattern = NULL, match = TRUE, show.currencies = FALSE)

ls_GBP(pattern = NULL, match = TRUE, show.currencies = FALSE)

ls_CAD(pattern = NULL, match = TRUE, show.currencies = FALSE)

ls_EUR(pattern = NULL, match = TRUE, show.currencies = FALSE)

ls_JPY(pattern = NULL, match = TRUE, show.currencies = FALSE)

ls_CHF(pattern = NULL, match = TRUE, show.currencies = FALSE)

ls_HKD(pattern = NULL, match = TRUE, show.currencies = FALSE)

ls_SEK(pattern = NULL, match = TRUE, show.currencies = FALSE)

ls_NZD(pattern = NULL, match = TRUE, show.currencies = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls_by_currency_+3A_currency">currency</code></td>
<td>
<p>chr vector of names of currency</p>
</td></tr>
<tr><td><code id="ls_by_currency_+3A_pattern">pattern</code></td>
<td>
<p>an optional regular expression.  Only names matching
&lsquo;pattern&rsquo; are returned.</p>
</td></tr>
<tr><td><code id="ls_by_currency_+3A_match">match</code></td>
<td>
<p>exact match?</p>
</td></tr>
<tr><td><code id="ls_by_currency_+3A_show.currencies">show.currencies</code></td>
<td>
<p>include names of currency instruments in the returned
names?</p>
</td></tr>
<tr><td><code id="ls_by_currency_+3A_x">x</code></td>
<td>
<p>what to remove. chr vector.</p>
</td></tr>
<tr><td><code id="ls_by_currency_+3A_keep.currencies">keep.currencies</code></td>
<td>
<p>Do not delete currency instruments when deleting
multiple instruments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ls_ functions return vector of instrument names rm_ functions return
invisible / called for side-effect.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p>ls_instruments, ls_currencies, rm_instruments, rm_currencies,
twsInstrument, instrument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#First create instruments
currency(c('USD','CAD','GBP')
stock(c('CM','CNQ'),'CAD')
stock(c('BET','BARC'),'GBP')
stock(c('SPY','DIA'),'USD')

#now the examples
ls_by_currency(c('CAD','GBP'))

ls_USD()
ls_CAD()

#2 ways to remove all instruments of a currency
rm_instruments(ls_USD()) 
#rm_instruments(ls_GBP(),keep.currencies=FALSE)
rm_by_currency( ,'CAD') 
#rm_by_currency( ,'CAD', keep.currencies=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='ls_by_expiry'>list or remove instruments by expiration date</h2><span id='topic+ls_by_expiry'></span><span id='topic+rm_by_expiry'></span>

<h3>Description</h3>

<p>show names of or remove instruments that expire on a given date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_by_expiry(expiry, pattern = NULL, match = TRUE)

rm_by_expiry(x, expiry)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls_by_expiry_+3A_expiry">expiry</code></td>
<td>
<p>expiration date that should correspond to the &lsquo;expires&rsquo;
field of an instrument</p>
</td></tr>
<tr><td><code id="ls_by_expiry_+3A_pattern">pattern</code></td>
<td>
<p>an optional regular expression.  Only names matching
&lsquo;pattern&rsquo; are returned.</p>
</td></tr>
<tr><td><code id="ls_by_expiry_+3A_match">match</code></td>
<td>
<p>exact match of pattern?</p>
</td></tr>
<tr><td><code id="ls_by_expiry_+3A_x">x</code></td>
<td>
<p>what to remove</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ls_by_expiry</code> will find instruments that have a field named either
&ldquo;expiry&rdquo; or &ldquo;expires&rdquo; with a value that matches <code>expiry</code>.
</p>


<h3>Value</h3>

<p><code>ls_by_expiry</code> gives a vector of names of instruments that
expire on the given expiry. <code>rm_by_expiry</code> is called for its
side-effect.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ls_instruments">ls_instruments</a></code>, <code><a href="#topic+ls_options">ls_options</a></code>, <code><a href="#topic+ls_calls">ls_calls</a></code>, 
<code><a href="#topic+ls_puts">ls_puts</a></code>, <code><a href="#topic+ls_futures">ls_futures</a></code>, <code><a href="#topic+ls_derivatives">ls_derivatives</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls_by_expiry('20110917')
ls_by_expiry('20110917',ls_options())

## End(Not run)
</code></pre>

<hr>
<h2 id='ls_expiries'>show unique expiration dates of instruments</h2><span id='topic+ls_expiries'></span><span id='topic+ls_expires'></span>

<h3>Description</h3>

<p>show unique expiration dates of instruments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_expiries(pattern = NULL, match = TRUE, underlying_id = NULL,
  type = "derivative")

ls_expires(pattern = NULL, match = TRUE, underlying_id = NULL,
  type = "derivative")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls_expiries_+3A_pattern">pattern</code></td>
<td>
<p>optional regular expression.</p>
</td></tr>
<tr><td><code id="ls_expiries_+3A_match">match</code></td>
<td>
<p>exact match?</p>
</td></tr>
<tr><td><code id="ls_expiries_+3A_underlying_id">underlying_id</code></td>
<td>
<p>chr name of underlying or vector of underlying_ids. If
NULL, all underlyings will be used</p>
</td></tr>
<tr><td><code id="ls_expiries_+3A_type">type</code></td>
<td>
<p>chr string name of class that instruments to be returned must
inherit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ls_expires</code> is an alias. (plural of expires?)
</p>
<p>type is currently only implemented for &lsquo;derivative&rsquo;, &lsquo;future&rsquo;,
&lsquo;option&rsquo;, &lsquo;call&rsquo; and &lsquo;put&rsquo; internally, a call is made
to the appropriate ls_ function.
</p>


<h3>Value</h3>

<p>named chr vector with length of unique expiration dates of
derivatives of class <code>type</code> and having an underlying_id of
<code>underlying_id</code> if given.
</p>


<h3>Note</h3>

<p>This should be updated to deal with dates instead of character strings
</p>


<h3>Author(s)</h3>

<p>Garrett
</p>


<h3>See Also</h3>

<p>ls_instruments_by for things like e.g.
ls_instruments_by('expires','20110916'), ls_instruments, ls_derivatives,
ls_options, ls_calls, buildHierarchy, instrument.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
option_series.yahoo('SPY')
option_series.yahoo('DIA',NULL)
ls_expiries()


## End(Not run)
</code></pre>

<hr>
<h2 id='ls_instruments'>List or Remove instrument objects</h2><span id='topic+ls_instruments'></span><span id='topic+ls_stocks'></span><span id='topic+ls_options'></span><span id='topic+ls_option_series'></span><span id='topic+ls_futures'></span><span id='topic+ls_future_series'></span><span id='topic+ls_currencies'></span><span id='topic+ls_non_currencies'></span><span id='topic+ls_exchange_rates'></span><span id='topic+ls_FX'></span><span id='topic+ls_bonds'></span><span id='topic+ls_funds'></span><span id='topic+ls_spreads'></span><span id='topic+ls_guaranteed_spreads'></span><span id='topic+ls_synthetics'></span><span id='topic+ls_derivatives'></span><span id='topic+ls_non_derivatives'></span><span id='topic+ls_calls'></span><span id='topic+ls_puts'></span><span id='topic+rm_instruments'></span><span id='topic+rm_stocks'></span><span id='topic+rm_options'></span><span id='topic+rm_option_series'></span><span id='topic+rm_futures'></span><span id='topic+rm_future_series'></span><span id='topic+rm_currencies'></span><span id='topic+rm_exchange_rates'></span><span id='topic+rm_FX'></span><span id='topic+rm_bonds'></span><span id='topic+rm_funds'></span><span id='topic+rm_spreads'></span><span id='topic+rm_synthetics'></span><span id='topic+rm_derivatives'></span><span id='topic+rm_non_derivatives'></span><span id='topic+ls_ICS'></span><span id='topic+ls_ICS_roots'></span>

<h3>Description</h3>

<p>display the names of or delete instruments, stocks, options, futures,
currencies, bonds, funds, spreads, guaranteed_spreads, synthetics,
derivatives, or non-derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_instruments(pattern = NULL, match = TRUE, verbose = TRUE)

ls_stocks(pattern = NULL, match = TRUE)

ls_options(pattern = NULL, match = TRUE, include.series = TRUE)

ls_option_series(pattern = NULL, match = TRUE)

ls_futures(pattern = NULL, match = TRUE, include.series = TRUE)

ls_future_series(pattern = NULL, match = TRUE)

ls_currencies(pattern = NULL, match = TRUE, includeFX = FALSE)

ls_non_currencies(pattern = NULL, match = TRUE, includeFX = TRUE)

ls_exchange_rates(pattern = NULL, match = TRUE)

ls_FX(pattern = NULL, match = TRUE)

ls_bonds(pattern = NULL, match = TRUE)

ls_funds(pattern = NULL, match = TRUE)

ls_spreads(pattern = NULL, match = TRUE)

ls_guaranteed_spreads(pattern = NULL, match = TRUE)

ls_synthetics(pattern = NULL, match = TRUE)

ls_ICS(pattern = NULL, match = TRUE)

ls_ICS_roots(pattern = NULL, match = TRUE)

ls_derivatives(pattern = NULL, match = TRUE)

ls_non_derivatives(pattern = NULL, match = TRUE)

ls_calls(pattern = NULL, match = TRUE)

ls_puts(pattern = NULL, match = TRUE)

rm_instruments(x, keep.currencies = TRUE)

rm_stocks(x)

rm_options(x)

rm_option_series(x)

rm_futures(x)

rm_future_series(x)

rm_currencies(x)

rm_exchange_rates(x)

rm_FX(x)

rm_bonds(x)

rm_funds(x)

rm_spreads(x)

rm_synthetics(x)

rm_derivatives(x)

rm_non_derivatives(x, keep.currencies = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls_instruments_+3A_pattern">pattern</code></td>
<td>
<p>an optional regular expression.  Only names matching
&lsquo;pattern&rsquo; are returned.</p>
</td></tr>
<tr><td><code id="ls_instruments_+3A_match">match</code></td>
<td>
<p>return only exact matches?</p>
</td></tr>
<tr><td><code id="ls_instruments_+3A_verbose">verbose</code></td>
<td>
<p>be verbose?</p>
</td></tr>
<tr><td><code id="ls_instruments_+3A_include.series">include.series</code></td>
<td>
<p>should future_series or option_series instruments be
included.</p>
</td></tr>
<tr><td><code id="ls_instruments_+3A_includefx">includeFX</code></td>
<td>
<p>should exchange_rates be included in ls_non_currencies
results</p>
</td></tr>
<tr><td><code id="ls_instruments_+3A_x">x</code></td>
<td>
<p>what to remove. if not supplied all instruments of relevent class
will be removed.  For <code>ls_defined.by</code> x is the string describing how the
instrument was defined.</p>
</td></tr>
<tr><td><code id="ls_instruments_+3A_keep.currencies">keep.currencies</code></td>
<td>
<p>If TRUE, currencies will not be deleted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ls functions return the names of all the instruments of the class implied by
the function name. rm functions remove the instruments of the class implied
by the function name
</p>
<p>rm_instruments and rm_non_derivatives will not delete currencies unless the
keep.currencies argument is FALSE.
</p>
<p>For the rm functions, x can be a vector of instrument names, or nothing.  If
<code>x</code> is missing, all instruments of the relevant type will be removed.
</p>
<p>It can be useful to nest these functions to get things like futures
denominated in USD.
</p>


<h3>Value</h3>

<p>ls functions return vector of character strings corresponding to
instruments of requested type rm functions are called for side-effect
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p>ls_instruments_by, ls_by_currency, ls_by_expiry, ls, rm,
instrument, stock, future, option, currency, FinancialInstrument::sort_ids
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#rm_instruments(keep.currencies=FALSE) #remove everything from .instrument

# First, create some instruments
currency(c("USD", "EUR", "JPY"))
#stocks
stock(c("S", "SE", "SEE", "SPY"), 'USD')
synthetic("SPX", "USD", src=list(src='yahoo', name='^GSPC'))
#derivatives
option('.SPY', 'USD', multiplier=100, underlying_id='SPY')
option_series(root_id="SPY", expires='2011-06-18', callput='put', strike=130)
option_series(root_id="SPY", expires='2011-09-17', callput='put', strike=130)
option_series(root_id="SPY", expires='2011-06-18', callput='call', strike=130)
future('ES', 'USD', multiplier=50, expires='2011-09-16', underlying_id="SPX")
option('.ES','USD',multiplier=1, expires='2011-06',strike=1350, right='C', underlying_id='ES')

# Now, the examples
ls_instruments() #all instruments
ls_instruments("SE") #only the one stock
ls_instruments("S", match=FALSE) #anything with "S" in name

ls_currencies()
ls_stocks() 
ls_options() 
ls_futures() 
ls_derivatives()
ls_puts()
ls_non_derivatives()
#ls_by_expiry('20110618',ls_puts()) #put options that expire on Jun 18th, 2011
#ls_puts(ls_by_expiry('20110618')) #same thing

rm_options('SPY_110618C130')
rm_futures()
ls_instruments()
#rm_instruments('EUR') #Incorrect
rm_instruments('EUR', keep.currencies=FALSE) #remove the currency
rm_currencies('JPY') #or remove currency like this
ls_currencies()
ls_instruments()

rm_instruments() #remove all but currencies
rm_currencies()

option_series.yahoo('DIA')
ls_instruments_by('underlying_id','DIA') #underlying_id must exactly match 'DIA'
ls_derivatives('DIA',match=FALSE) #primary_ids that contain 'DIA'
rm_instruments()

## End(Not run)
</code></pre>

<hr>
<h2 id='ls_instruments_by'>Subset names of instruments</h2><span id='topic+ls_instruments_by'></span>

<h3>Description</h3>

<p>list names of instruments that have an attribute that matches some value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_instruments_by(what, value, in.slot = NULL, pattern = NULL,
  match = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls_instruments_by_+3A_what">what</code></td>
<td>
<p>What attribute? (e.g. &ldquo;currency&rdquo;, &ldquo;type&rdquo;, 
&ldquo;strike&rdquo;, etc.)</p>
</td></tr>
<tr><td><code id="ls_instruments_by_+3A_value">value</code></td>
<td>
<p>What value must the attribute have? (e.g. &ldquo;EUR&rdquo;,
&ldquo;option&rdquo;, 100, etc.).  If missing or <code>NULL</code>, the names of all
instruments that have a <code>what</code> slot will be returned</p>
</td></tr>
<tr><td><code id="ls_instruments_by_+3A_in.slot">in.slot</code></td>
<td>
<p>If the attribute you are looking for is stored inside another
slot, this is the name of that slot. (usually &quot;IB&quot;)</p>
</td></tr>
<tr><td><code id="ls_instruments_by_+3A_pattern">pattern</code></td>
<td>
<p>only return instruments with <code>pattern</code> in the name</p>
</td></tr>
<tr><td><code id="ls_instruments_by_+3A_match">match</code></td>
<td>
<p>should pattern match names exactly?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>list instruments that have a given attribute level with a given value.
</p>


<h3>Value</h3>

<p>chr vector of instrument names
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p>buildHierarchy, instrument.table, ls_instruments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
stock(c("GOOG","INTC"),currency("USD"))
synthetic("SnP","USD",src=list(name='^GSPC',src='yahoo'))
ls_instruments_by('type','stock')
ls_instruments_by("name",NULL,in.slot='src')
ls_instruments_by('src',NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='ls_strikes'>show strike prices of defined options</h2><span id='topic+ls_strikes'></span>

<h3>Description</h3>

<p>list the strike prices of previously defined options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_strikes(pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls_strikes_+3A_pattern">pattern</code></td>
<td>
<p>an optional regular expression. Only names matching 'pattern'
are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no option names are supplied, the strike prices of all defined options
will be returned
</p>


<h3>Value</h3>

<p>vector of strike prices
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p>ls_options, ls_calls, ls_puts ls_instruments_by ls_underlyings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
option_series.yahoo('SPY')
ls_strikes(ls_options('SPY'))

## End(Not run)
</code></pre>

<hr>
<h2 id='ls_underlyings'>show names of underlyings</h2><span id='topic+ls_underlyings'></span>

<h3>Description</h3>

<p>shows names that are stored in the <code>underlying_id</code> slot of derivative
instruments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_underlyings(pattern = NULL, match = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls_underlyings_+3A_pattern">pattern</code></td>
<td>
<p>an optional regular expression.  Only names matching
&lsquo;pattern&rsquo; are returned.</p>
</td></tr>
<tr><td><code id="ls_underlyings_+3A_match">match</code></td>
<td>
<p>require exact match?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>first calls <code>ls_derivatives</code>, then looks for unique
<code>underlying_id</code>s. If no derivatives have been defined, nothing will be
returned.
</p>


<h3>Value</h3>

<p>chr vector of names of unique <code>underlying_id</code>s
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p>ls_instruments_by, ls_derivatives, ls_options, ls_futures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls_underlyings()

## End(Not run)
</code></pre>

<hr>
<h2 id='make_spread_id'>Construct a primary_id for a <code>spread</code> <code>instrument</code> from the 
primary_ids of its members</h2><span id='topic+make_spread_id'></span>

<h3>Description</h3>

<p>Construct a primary_id for a <code>spread</code> <code>instrument</code> from the 
primary_ids of its members
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_spread_id(x, root = NULL, format = NULL, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_spread_id_+3A_x">x</code></td>
<td>
<p>character vector of member primary_ids</p>
</td></tr>
<tr><td><code id="make_spread_id_+3A_root">root</code></td>
<td>
<p>Optional character string of root_id to use.</p>
</td></tr>
<tr><td><code id="make_spread_id_+3A_format">format</code></td>
<td>
<p>String indicating how to format the suffix_ids of the spread.
If <code>NULL</code> (the default), or <code>FALSE</code>, no formatting will be done.  
See <code><a href="#topic+format_id">format_id</a></code> for other accepted values for <code>format</code></p>
</td></tr>
<tr><td><code id="make_spread_id_+3A_sep">sep</code></td>
<td>
<p>character string to separate root_id and suffix_id</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string that can be used as a primary_id for a 
<code><a href="#topic+spread">spread</a></code> instrument
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread">spread</a></code>, <code><a href="#topic+build_spread_symbols">build_spread_symbols</a></code>,  
<code><a href="#topic+build_series_symbols">build_series_symbols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ids &lt;- c('VX_aug1','VX_U11')
make_spread_id(ids, format='CY')
make_spread_id(ids, format=FALSE)
make_spread_id(c("VIX_JAN11","VIX_FEB11"),root='VX',format='CY')
</code></pre>

<hr>
<h2 id='month_cycle2numeric'>coerce month_cycle to a numeric vector</h2><span id='topic+month_cycle2numeric'></span><span id='topic+MC2N'></span>

<h3>Description</h3>

<p>This will convert month codes or month names to numeric months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>month_cycle2numeric(...)

MC2N(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="month_cycle2numeric_+3A_...">...</code></td>
<td>
<p>the expiration months of a <code><a href="#topic+future">future</a></code>. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input can be a vector, comma-delimited string, or multiple strings. 
All inputs should be similar.
Do not mix month names, codes and numbers in the same call.
</p>
<p><code>MC2N</code> is an alias
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+M2C">M2C</a></code>, <code><a href="#topic+C2M">C2M</a></code>, <code><a href="#topic+next.future_id">next.future_id</a></code>
<code><a href="#topic+future">future</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MC2N("H,M,U,Z") # from single string
MC2N(c("H","M","U","Z")) # from single vector
MC2N("h", "M", "u", "Z") # from multiple strings
MC2N(c("F","G"), "H", c("X","Z")) # from multiple vectors
month_cycle2numeric("Mar,jun,SEP,dEc") 
month_cycle2numeric("Mar", "jun", "SEP", "dEc")
MC2N("March,june,sep,decem")
MC2N("March, june, sep, decem") #spaces between commas are ok
month_cycle2numeric("3,6,9,12")
month_cycle2numeric(seq(3,12,3))
</code></pre>

<hr>
<h2 id='next.future_id'>Get the primary_id of the next-to-expire (previously expiring) future_series instrument</h2><span id='topic+next.future_id'></span><span id='topic+prev.future_id'></span>

<h3>Description</h3>

<p>Using <code><a href="#topic+parse_id">parse_id</a></code>, this will figure out where in the <code>month_cycle</code> that <code>id</code>
belongs.  Then, it will use the next (previous) month in <code>month_cycle</code> to construct the id of the
next-to-expire contract.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next.future_id(id, month_cycle = seq(3, 12, 3), root = NULL,
  format = NULL)

prev.future_id(id, month_cycle = seq(3, 12, 3), root = NULL,
  format = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="next.future_id_+3A_id">id</code></td>
<td>
<p>character string primary_id of a future_series instrument</p>
</td></tr>
<tr><td><code id="next.future_id_+3A_month_cycle">month_cycle</code></td>
<td>
<p>months in which contracts expire. numeric or month codes. See Details.</p>
</td></tr>
<tr><td><code id="next.future_id_+3A_root">root</code></td>
<td>
<p>root_id. usually only used if there is no underscore in the <code>id</code>. See Details.</p>
</td></tr>
<tr><td><code id="next.future_id_+3A_format">format</code></td>
<td>
<p>how you would like the returned id to be formatted. If NULL, it will match the format of <code>id</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>month_cycle</code> can be a numeric vector (corresponding to the months in which contracts expire),
or it can be a vector of month codes, a vector of month abbreviations, or a comma-delimited
string of month codes or abbreviations, in which case an attempt will be made to convert it to a numeric vector.
by passing it through <code><a href="#topic+month_cycle2numeric">month_cycle2numeric</a></code>
</p>
<p><code>root</code> is primarily used when you have an id that does not have an underscore, in which case, providing <code>root</code>
will make splitting the id into primary_id and suffix_id easier and more accurate.  <code>root</code> can also be used if you want
the returned id to be on a different <code>future</code> than the id you passed in (when used this way, <code>format</code> should also be used).
</p>
<p>By default, (when called with <code>format=NULL</code>) the returned id will be of the same format as the <code>id</code> that was passed in.  
The format of the returned id can be specified with the <code>format</code> argument.  See <code><a href="#topic+format_id">format_id</a></code> for supported values of <code>format</code>
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_id">format_id</a></code> for supported values of <code>format</code>.
<code><a href="#topic+month_cycle2numeric">month_cycle2numeric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>next.future_id("ES_Z1","H,M,U,Z", format=NULL) 
next.future_id("VIXAUG11", 1:12, root='VIX', format=NULL)
next.future_id("YM_Q11", seq(3,12,3)) #gives a warning about 'Q' not being part of month_cycle
</code></pre>

<hr>
<h2 id='Notionalize'>Convert price series to/from notional value</h2><span id='topic+Notionalize'></span><span id='topic+Denotionalize'></span>

<h3>Description</h3>

<p><code>Notionalize</code> multiplies all prices by the contract multiplier
<code>Denotionalize</code> divides all prices by the contract multiplier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Notionalize(x, name, env = .GlobalEnv)

Denotionalize(x, name, env = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Notionalize_+3A_x">x</code></td>
<td>
<p>an xts object, or an object that is coercible to xts</p>
</td></tr>
<tr><td><code id="Notionalize_+3A_name">name</code></td>
<td>
<p>primary_id of the instrument that has the multiplier;
usually the same as the name of <code>x</code></p>
</td></tr>
<tr><td><code id="Notionalize_+3A_env">env</code></td>
<td>
<p>environment. where to find <code>x</code> if only its name is provided</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mulitplier is only applied to columns with prices.  A column is 
considered to be a price column if its name contains &ldquo;Open&rdquo;, 
&ldquo;High&rdquo;, &ldquo;Low&rdquo;, &ldquo;Close&rdquo;, &ldquo;Bid&rdquo;, &ldquo;Ask&rdquo;, 
&ldquo;Trade&rdquo;, &ldquo;Mid&rdquo;, or &ldquo;Price&rdquo; and does not contain
&ldquo;Size&rdquo;, &ldquo;Sz&rdquo;, &ldquo;Volume&rdquo;, &ldquo;Qty&rdquo;, 
&ldquo;Quantity&rdquo;, &ldquo;OpInt&rdquo;, &ldquo;OpenInterest&rdquo; 
(not case-sensitive)
</p>


<h3>Value</h3>

<p>an object of the same class as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
source("http://tinyurl.com/download-tblox")
getSymbols("CL", src='tblox')
define_futures.tblox()
tail(Notionalize(CL, "CL"))
tail(Denotionalize(Notionalize(CL), "CL"))

## End(Not run)
</code></pre>

<hr>
<h2 id='option_series.yahoo'>constructor for series of options using yahoo data</h2><span id='topic+option_series.yahoo'></span>

<h3>Description</h3>

<p>Defines a chain or several chains of options by looking up necessary info 
from yahoo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>option_series.yahoo(symbol, Exp, currency = "USD", multiplier = 100,
  first_traded = NULL, tick_size = NULL, overwrite = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="option_series.yahoo_+3A_symbol">symbol</code></td>
<td>
<p>character vector of ticker symbols of the underlying 
instruments (Currently, should only be stock tickers)</p>
</td></tr>
<tr><td><code id="option_series.yahoo_+3A_exp">Exp</code></td>
<td>
<p>Expiration date or dates to be passed to getOptionChain</p>
</td></tr>
<tr><td><code id="option_series.yahoo_+3A_currency">currency</code></td>
<td>
<p>currency of underlying and options</p>
</td></tr>
<tr><td><code id="option_series.yahoo_+3A_multiplier">multiplier</code></td>
<td>
<p>contract multiplier. Usually 100 for stock options</p>
</td></tr>
<tr><td><code id="option_series.yahoo_+3A_first_traded">first_traded</code></td>
<td>
<p>first date that contracts are tradeable. Probably not 
applicable if defining several chains.</p>
</td></tr>
<tr><td><code id="option_series.yahoo_+3A_tick_size">tick_size</code></td>
<td>
<p>minimum price change of options.</p>
</td></tr>
<tr><td><code id="option_series.yahoo_+3A_overwrite">overwrite</code></td>
<td>
<p>if an instrument already exists, should it be overwritten?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>Exp</code> is missing it will define only the nearby options. 
If <code>Exp</code> is NULL it will define all options
</p>
<p>If <code>first_traded</code> and/or <code>tick_size</code> should not be the same for all 
options being defined, they should be left NULL and defined outside of this 
function.
</p>


<h3>Value</h3>

<p>Called for side-effect. The instrument that is created and stored 
will inherit option_series, option, and instrument classes.
</p>


<h3>Note</h3>

<p>Has only been tested with stock options.
The options' currency should be the same as the underlying's.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>References</h3>

<p>Yahoo <a href="https://finance.yahoo.com">https://finance.yahoo.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+option_series">option_series</a></code>, <code><a href="#topic+option">option</a></code>, 
<code><a href="#topic+instrument">instrument</a></code>, <code><a href="quantmod.html#topic+getOptionChain">getOptionChain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
option_series.yahoo('SPY') #only nearby calls and puts
option_series.yahoo('DIA', Exp=NULL) #all chains
ls_instruments()

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_id'>Parse a primary_id</h2><span id='topic+parse_id'></span>

<h3>Description</h3>

<p>Extract/infer descriptive information about an instrument from its name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_id(x, silent = TRUE, root = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_id_+3A_x">x</code></td>
<td>
<p>the id to be parsed (e.g. &lsquo;ES_U11&rsquo;, &lsquo;SPY_111217C130&rsquo;)</p>
</td></tr>
<tr><td><code id="parse_id_+3A_silent">silent</code></td>
<td>
<p>silence warnings?</p>
</td></tr>
<tr><td><code id="parse_id_+3A_root">root</code></td>
<td>
<p>character name of instrument root_id.  Optionally provide this to make parsing easier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily intended to be used on the names of <code><a href="#topic+future_series">future_series</a></code> 
and <code><a href="#topic+option_series">option_series</a></code> instruments, and it will work best if the id has an 
underscore in it that separates the root_id from the suffix_id.  (However, it should be able 
to handle most ids even if the underscore is missing). 
After splitting <code>x</code> into a root_id and suffix_id, the suffix_id is 
passed to <code><a href="#topic+parse_suffix">parse_suffix</a></code> (see also) for further processing.
</p>
<p>TODO: add support for bond_series.
</p>


<h3>Value</h3>

<p>a list of class &lsquo;id.list&rsquo; containing &lsquo;root&rsquo; and &lsquo;suffix&rsquo; as well as 
what is returned from <code><a href="#topic+parse_suffix">parse_suffix</a></code> (type, month, year, strike, right, cm, cc, format)
</p>


<h3>Note</h3>

<p>this function will identify <code>x</code> as an <code><a href="#topic+exchange_rate">exchange_rate</a></code> only if it is 
6 characters long and made up of 2 previously defined <code><a href="#topic+currency">currency</a></code> instruments.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_suffix">parse_suffix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_id("ES_Z11")
parse_id("CLZ1")
parse_id("SPY_111217C130")
</code></pre>

<hr>
<h2 id='parse_suffix'>parse a suffix_id</h2><span id='topic+parse_suffix'></span>

<h3>Description</h3>

<p>extract information from the suffix_id of an instrument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_suffix(x, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_suffix_+3A_x">x</code></td>
<td>
<p>the suffix_id to be parsed</p>
</td></tr>
<tr><td><code id="parse_suffix_+3A_silent">silent</code></td>
<td>
<p>silence warnings? (warning will usually be about inferring a 4 digit year from a 1 or 2 digit year)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These would be recognized as a Sep 2011 outright futures contract: 
U1, U11, SEP1, SEP11, U2011, Sep2011, SEP2011
</p>
<p>These would be recognized as a call with a strike of 122.5 that expires Sep 17, 2011:
110917C122.5, 20110917C122.5, 110917C00122500, 20110917C00122500
</p>
<p>These would be recognized as Sep 2011 single stock futures:
1CU1, 1CU11, 1CSEP11, 1DU1 (dividend protected)
</p>
<p>These would be recognized as Adjusted futures:
cm.30 (30 day constant maturity future),
cc.OI (continuous contract rolled when Open Interest rolls),
cc.Vol (continuous contract roll when Volumn rolls),
cc.Exp.1 (continuous contract rolled 1 day before Expiration)
</p>
<p>Synthetics and spreads:
</p>
<p>SPY.DIA &ndash;&gt; type == synthetic;
</p>
<p>U1.Z1 or U11.Z11 &ndash;&gt; type == &quot;calendar&quot;, &quot;spread&quot;; month == 'SEP', year == 2011
</p>
<p>U1.0302 &ndash;&gt; type == &quot;ICS&quot;, &quot;spread&quot;; month == 'SEP', year == 2011
</p>
<p>110917C125.110917P125 &ndash;&gt; type == option_spread, spread
</p>


<h3>Value</h3>

<p>an object of class &lsquo;suffix.list&rsquo; which is a list containing &lsquo;type&rsquo; of instrument, 
&lsquo;month&rsquo; of expiration, &lsquo;year&rsquo; of expiration, &lsquo;strike&rsquo; price of option, 
&lsquo;right&rsquo; of option (&ldquo;C&rdquo; or &ldquo;P&rdquo;), &lsquo;cm&rsquo; (maturity in days of a constant maturity contract),
&lsquo;cc&rsquo; (method for calculating a continuous contract), &lsquo;format&rsquo; (string that indicates the format of the unparsed id).
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_id">parse_id</a></code>, <code><a href="#topic+format_id">format_id</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_suffix("U11")
parse_suffix("110917C125")
</code></pre>

<hr>
<h2 id='print.id.list'>id.list class print method</h2><span id='topic+print.id.list'></span>

<h3>Description</h3>

<p>id.list class print method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'id.list'
print(x, ...)
</code></pre>

<hr>
<h2 id='print.instrument'>instrument class print method</h2><span id='topic+print.instrument'></span>

<h3>Description</h3>

<p>instrument class print method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'instrument'
print(x, ...)
</code></pre>


<h3>Author(s)</h3>

<p>Joshua Ulrich, Garrett See
</p>

<hr>
<h2 id='print.suffix.list'>suffix.list class print method</h2><span id='topic+print.suffix.list'></span>

<h3>Description</h3>

<p>suffix.list class print method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'suffix.list'
print(x, ...)
</code></pre>

<hr>
<h2 id='redenominate'>Redenominate (change the base of) an instrument</h2><span id='topic+redenominate'></span>

<h3>Description</h3>

<p>Redenominate (change the base of) an instrument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redenominate(x, new_base = "USD", old_base = NULL, EOD_time = "15:00:00",
  env = .GlobalEnv, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redenominate_+3A_x">x</code></td>
<td>
<p>can be either an xts object or the name of an instrument.</p>
</td></tr>
<tr><td><code id="redenominate_+3A_new_base">new_base</code></td>
<td>
<p>change the denomination to this; usually a currency.</p>
</td></tr>
<tr><td><code id="redenominate_+3A_old_base">old_base</code></td>
<td>
<p>what is the current denomination?</p>
</td></tr>
<tr><td><code id="redenominate_+3A_eod_time">EOD_time</code></td>
<td>
<p>If data need to be converted to daily, this is the time of day to take the observation.</p>
</td></tr>
<tr><td><code id="redenominate_+3A_env">env</code></td>
<td>
<p>environment that holds the data</p>
</td></tr>
<tr><td><code id="redenominate_+3A_silent">silent</code></td>
<td>
<p>silence warnings?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>old_base</code> is not provided, <code>x</code> must be the name of an 
instrument (or an object with the name of a defined instrument) so that the
currency attribute of the instrument can be used.  Otherwise, <code>old_base</code>
must be provided.
</p>
<p>If you want to convert to JPY something that is denominated in EUR,
you must have data for the EURJPY (or JPYEUR) exchange rate. If you don't have
data for EURJPY, but you do have data for EURUSD and USDJPY, 
you could <code>redenominate</code> to USD, then <code>redenominate</code> to EUR, 
but this function is not yet smart enough to do that for you.
</p>
<p>See the help for buildRatio also.
</p>


<h3>Value</h3>

<p>xts object, with as many columns as practicable, that represents the value of an instrument in a different currency (base).
</p>


<h3>Note</h3>

<p>this does not yet define any instruments or assign anything.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildRatio">buildRatio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(quantmod)
EURUSD &lt;- getSymbols("EURUSD=x",src='yahoo',auto.assign=FALSE)
GLD &lt;- getSymbols("GLD", src='yahoo', auto.assign=FALSE)
GLD.EUR &lt;- redenominate(GLD,"EUR","USD") #can call with xts object

currency("USD")
stock("GLD","USD")
GLD.EUR &lt;- redenominate('GLD','EUR') #can also call with instrument name

## End(Not run)
</code></pre>

<hr>
<h2 id='root_contracts'>future metadata to be used by <code><a href="#topic+load.instruments">load.instruments</a></code></h2><span id='topic+root_contracts'></span>

<h3>Description</h3>

<p>future metadata to be used by <code><a href="#topic+load.instruments">load.instruments</a></code>
</p>

<hr>
<h2 id='saveInstruments'>Save and Load all instrument definitions</h2><span id='topic+saveInstruments'></span><span id='topic+loadInstruments'></span><span id='topic+reloadInstruments'></span>

<h3>Description</h3>

<p>Saves (loads) the .instrument environment to (from) disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveInstruments(file_name = "MyInstruments", dir = "", compress = "gzip")

loadInstruments(file_name = "MyInstruments", dir = "")

reloadInstruments(file_name = "MyInstruments", dir = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveInstruments_+3A_file_name">file_name</code></td>
<td>
<p>name of file. e.g. &ldquo;MyInstruments.RData&rdquo;.
As an experimental feature, a <code>list</code> or <code>environment</code> can be passed 
to <code>file_name</code>.</p>
</td></tr>
<tr><td><code id="saveInstruments_+3A_dir">dir</code></td>
<td>
<p>Directory of file (defaults to current working directory. ie. &quot;&quot;)</p>
</td></tr>
<tr><td><code id="saveInstruments_+3A_compress">compress</code></td>
<td>
<p>argument passed to <code><a href="base.html#topic+save">save</a></code>, default is &quot;gzip&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After you have defined some instruments, you can use <code>saveInstruments</code>
to save the entire .instrument environment to disk.
</p>
<p><code>loadInstruments</code> will read a file that contains instruments and add 
those instrument definitions to your .instrument environment.  
<code>reloadInstruments</code> will remove all instruments in the current 
.instrument environment before loading instruments from disk.
</p>
<p>The <code>file_name</code> should have a file extension of &ldquo;RData&rdquo;, 
&ldquo;rda&rdquo;, &ldquo;R&rdquo;, or &ldquo;txt&rdquo;.  If the <code>file_name</code> does not
end with one of those, &ldquo;.RData&rdquo; will be appended to the 
<code>file_name</code>
</p>
<p>If the file extension is &ldquo;R&rdquo; or &ldquo;txt&rdquo;, <code>saveInstruments</code>
will create a text file of <span class="rlang"><b>R</b></span> code that can be <code><a href="base.html#topic+source">source</a></code>d to 
load instruments back into the .instrument environment.
</p>


<h3>Value</h3>

<p>Called for side-effect
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p>save, load load.instrument define_stocks, define_futures,
define_options (option_series.yahoo)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stock("SPY", currency("USD"), 1)
tmpdir &lt;- tempdir()
saveInstruments("MyInstruments.RData", dir=tmpdir)
rm_instruments(keep.currencies=FALSE)
loadInstruments("MyInstruments.RData", dir=tmpdir)
# write .R file that can be sourced
saveInstruments("MyInstruments.R", dir=tmpdir)
rm_instruments(keep.currencies=FALSE)
loadInstruments("MyInstruments.R", dir=tmpdir)
#source(file=paste(tmpdir, "MyInstruments.R", sep="/")) # same
unlink(tmpdir, recursive=TRUE)     

## End(Not run)
</code></pre>

<hr>
<h2 id='saveSymbols.days'>Save data to disk</h2><span id='topic+saveSymbols.days'></span><span id='topic+saveSymbols.common'></span>

<h3>Description</h3>

<p>Save data to disk the way that <code>getSymbols.FI</code> 
expects it to be saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveSymbols.days(Symbols, base_dir = "", extension = "rda",
  env = .GlobalEnv)

saveSymbols.common(Symbols, base_dir = "", extension = "rda",
  env = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveSymbols.days_+3A_symbols">Symbols</code></td>
<td>
<p>character vector of names of objects to be saved</p>
</td></tr>
<tr><td><code id="saveSymbols.days_+3A_base_dir">base_dir</code></td>
<td>
<p>character.  directory in which to store data.</p>
</td></tr>
<tr><td><code id="saveSymbols.days_+3A_extension">extension</code></td>
<td>
<p>file extension (&ldquo;rda&rdquo;)</p>
</td></tr>
<tr><td><code id="saveSymbols.days_+3A_env">env</code></td>
<td>
<p>environment that holds the data to be saved (.GlobalEnv by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If they do not already exist, subdirectories will be created for each of the 
<code>Symbols</code>.  <code>saveSymbols.common</code> will save a single &lsquo;rda&rsquo; 
file for each of the <code>Symbols</code> in that symbol's subdirectory.
<code>saveSymbols.days</code> will split the data up into days and save a separate 
&lsquo;rda&rsquo; file for each day in that symbol's subdirectory.
</p>


<h3>Value</h3>

<p>called for side-effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getSymbols.FI">getSymbols.FI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getSymbols("SPY", src='yahoo')
dir.create("tmpdata")
saveSymbols.common("SPY", base_dir="tmpdata")
rm("SPY")
getSymbols("SPY", src='FI', dir="tmpdata", split_method='common')
unlink("tmpdata/SPY", recursive=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='setSymbolLookup.FI'>set quantmod-style SymbolLookup for instruments</h2><span id='topic+setSymbolLookup.FI'></span>

<h3>Description</h3>

<p>This function exists to tell <code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> where to look for your repository of market data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSymbolLookup.FI(base_dir, Symbols, ..., split_method = c("days", "common"),
  storage_method = "rda", use_identifier = "primary_id",
  extension = "rda", src = "FI")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setSymbolLookup.FI_+3A_base_dir">base_dir</code></td>
<td>
<p>string specifying the base directory where data is stored, see Details</p>
</td></tr>
<tr><td><code id="setSymbolLookup.FI_+3A_symbols">Symbols</code></td>
<td>
<p>character vector of names of instruments for which to <code>setSymbolLookup</code></p>
</td></tr>
<tr><td><code id="setSymbolLookup.FI_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="setSymbolLookup.FI_+3A_split_method">split_method</code></td>
<td>
<p>string specifying the method files are split, currently &lsquo;days&rsquo; or &lsquo;common&rsquo;, see Details</p>
</td></tr>
<tr><td><code id="setSymbolLookup.FI_+3A_storage_method">storage_method</code></td>
<td>
<p>currently only &lsquo;rda&rsquo;, but we will eventually support &lsquo;indexing&rsquo; at least, and maybe others</p>
</td></tr>
<tr><td><code id="setSymbolLookup.FI_+3A_use_identifier">use_identifier</code></td>
<td>
<p>string identifying which column should be use to construct the <code>primary_id</code> of the instrument, default 'primary_id'</p>
</td></tr>
<tr><td><code id="setSymbolLookup.FI_+3A_extension">extension</code></td>
<td>
<p>file extension, default &quot;rda&quot;</p>
</td></tr>
<tr><td><code id="setSymbolLookup.FI_+3A_src">src</code></td>
<td>
<p>which <code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> sub-type to use, default <code><a href="#topic+getSymbols.FI">getSymbols.FI</a></code> by setting 'FI'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>base_dir</code> parameter <em>must</em> be set or the function will fail.  
This will vary by your local environment and operating system.  For mixed-OS environments,
we recommend doing some OS-detection and setting the network share to your data to a common 
location by operating system.  For example, all Windows machines may use &ldquo;M:/&rdquo; 
and all *nix-style (linux, Mac) machines may use &ldquo;/mnt/mktdata/&rdquo;.
</p>
<p>The <code>split_method</code> currently allows either &lsquo;days&rsquo; or &lsquo;common&rsquo;, and expects the 
file or files to be in sub-directories named for the symbol.  In high frequency data, it is standard practice to split
the data by days, which is why that option is the default.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getSymbols.FI">getSymbols.FI</a></code>,
<code><a href="#topic+instrument_attr">instrument_attr</a></code>,
<code><a href="#topic+load.instruments">load.instruments</a></code>, <code><a href="#topic+loadInstruments">loadInstruments</a></code>,
<code><a href="quantmod.html#topic+setSymbolLookup">setSymbolLookup</a></code>
</p>

<hr>
<h2 id='sort_ids'>sort primary_ids of instruments</h2><span id='topic+sort_ids'></span>

<h3>Description</h3>

<p>Primarily intended for use on the primary_ids of <code><a href="#topic+future_series">future_series</a></code> instruments.
This will sort ids by expiration.  All ids that do not contain month and year information 
will be sorted alphabetically (separately) and appended to the end of the other sorted ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_ids(ids, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_ids_+3A_ids">ids</code></td>
<td>
<p>character vector of ids</p>
</td></tr>
<tr><td><code id="sort_ids_+3A_...">...</code></td>
<td>
<p>arguments to pass through to <code><a href="#topic+parse_id">parse_id</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an instrument is defined, and has a date in its &lsquo;expires&rsquo; field, that date will be
used as the expiration date.  Otherwise, it is assumed that the contract expires
on the first day of its expiration month.  This means that if some products are defined
and other products that expire in the same month are not defined, the ones that are
not defined will come first in the vector of sorted ids.
</p>


<h3>Value</h3>

<p>sorted character vector of the same length as <code>ids</code>
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_id">parse_id</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ids &lt;- c("ES_U11",'GLD','SPY',"YM_Jun11",'DIA','VX_V10')
sort_ids(ids)

## End(Not run)
</code></pre>

<hr>
<h2 id='sort.instrument'>instrument class sort method</h2><span id='topic+sort.instrument'></span>

<h3>Description</h3>

<p>instrument class sort method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'instrument'
sort(x, decreasing = FALSE, na.last = NA, ...)
</code></pre>


<h3>Author(s)</h3>

<p>Garrett See
</p>

<hr>
<h2 id='synthetic'>synthetic instrument constructors</h2><span id='topic+synthetic'></span><span id='topic+synthetic.instrument'></span><span id='topic+spread'></span><span id='topic+guaranteed_spread'></span><span id='topic+butterfly'></span><span id='topic+ICS_root'></span><span id='topic+ICS'></span>

<h3>Description</h3>

<p>define spreads, guaranteed_spreads, butterflies, and other synthetic instruments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthetic(primary_id = NULL, currency = NULL, multiplier = 1,
  identifiers = NULL, assign_i = TRUE, overwrite = TRUE, ...,
  members = NULL, type = "synthetic")

synthetic.instrument(primary_id, currency, members, memberratio, ...,
  multiplier = 1, tick_size = NULL, identifiers = NULL, assign_i = TRUE,
  type = c("synthetic.instrument", "synthetic"))

spread(primary_id = NULL, currency = NULL, members, memberratio,
  tick_size = NULL, ..., multiplier = 1, identifiers = NULL,
  assign_i = TRUE)

butterfly(primary_id = NULL, currency = NULL, members, tick_size = NULL,
  identifiers = NULL, assign_i = TRUE, ...)

guaranteed_spread(primary_id = NULL, currency = NULL, root_id = NULL,
  suffix_id = NULL, members = NULL, memberratio = c(1, -1), ...,
  multiplier = NULL, identifiers = NULL, assign_i = TRUE,
  tick_size = NULL)

ICS_root(primary_id, currency = NULL, members, multiplier = NULL,
  identifiers = NULL, assign_i = TRUE, overwrite = TRUE,
  tick_size = NULL, ...)

ICS(primary_id, assign_i = TRUE, identifiers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="synthetic_+3A_primary_id">primary_id</code></td>
<td>
<p>chr string of primary identifier of instrument to be defined.</p>
</td></tr>
<tr><td><code id="synthetic_+3A_currency">currency</code></td>
<td>
<p>chr string name of currency denomination</p>
</td></tr>
<tr><td><code id="synthetic_+3A_multiplier">multiplier</code></td>
<td>
<p>multiplier of the spread (1 / divisor for price weighted baskets)</p>
</td></tr>
<tr><td><code id="synthetic_+3A_identifiers">identifiers</code></td>
<td>
<p>identifiers</p>
</td></tr>
<tr><td><code id="synthetic_+3A_assign_i">assign_i</code></td>
<td>
<p>TRUE/FALSE. Should the instrument be assigned in the <code>.instrument</code> environment?</p>
</td></tr>
<tr><td><code id="synthetic_+3A_overwrite">overwrite</code></td>
<td>
<p>if FALSE and an instrument with the same <code>primary_id</code>
is already defined, an error will be thrown and no instruments will be 
created.</p>
</td></tr>
<tr><td><code id="synthetic_+3A_...">...</code></td>
<td>
<p>any other passthrough parameters</p>
</td></tr>
<tr><td><code id="synthetic_+3A_members">members</code></td>
<td>
<p>vector of primary_ids of member instruments</p>
</td></tr>
<tr><td><code id="synthetic_+3A_type">type</code></td>
<td>
<p>type of instrument; wrappers do not require this.</p>
</td></tr>
<tr><td><code id="synthetic_+3A_memberratio">memberratio</code></td>
<td>
<p>vector of weights for each leg. negative numbers for selling.</p>
</td></tr>
<tr><td><code id="synthetic_+3A_tick_size">tick_size</code></td>
<td>
<p>minimum price change of the spread</p>
</td></tr>
<tr><td><code id="synthetic_+3A_root_id">root_id</code></td>
<td>
<p>instrument identifier for the root contract, default NULL</p>
</td></tr>
<tr><td><code id="synthetic_+3A_suffix_id">suffix_id</code></td>
<td>
<p>identifiers for the member contract suffixes, default NULL, 
will be split as <code>members</code>, see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple derivatives like <code><a href="#topic+option">option</a></code> or <code><a href="#topic+future">future</a></code> contracts typically have one underlying instrument.  
While properties like strike and expiration vary for these derivative contracts or series, the underlying is well understood.
</p>
<p>More complex derivatives are typically modeled as baskets of underlying products, and are typically traded over-the-counter or as proprietary in-house products.
</p>
<p>The general <code>synthetic</code> function is intended to be extended to support these arbitrary baskets of assets.
</p>
<p><code>spread</code> <code>guaranteed_spread</code> and <code>butterfly</code> are wrappers for <code>synthetic.instrument</code>. <code>synthetic.instrument</code> will make a call to synthetic to create the final instrument.
</p>
<p>The <code>suffix_id</code> parameter of wrapper functions such as  <code>guaranteed_spread</code> is presumed to 
be a string describing the <code>members</code>. 
It will be <code><a href="base.html#topic+strsplit">strsplit</a></code> using the regex &quot;[-;:_,\.]&quot; to create the <code>members</code> vector,
and potentially combined with a <code>root_id</code>.
</p>
<p>Most wrappers will build <code>primary_id</code> if it is NULL, either by combining <code>root_id</code> and <code>suffix_id</code>, or
by passing <code>members</code> in a call to <code><a href="#topic+make_spread_id">make_spread_id</a></code>
</p>
<p><code>ICS</code> will build an Intercommodity Spread.  Although the expiration date and ratio may change, 
the members of a given ICS will not change.  Therefore, <code>ICS_root</code> can be used to hold the 
members of an Intercommodity Spread.  If an <code>ICS_root</code> has not been defined, then <code>members</code>
will be a required argument for <code>ICS</code>
</p>
<p>We welcome assistance from others to model more complex OTC derivatives such as swap products.
</p>


<h3>Value</h3>

<p>called for side effect. stores an instrument in .instrument environment
</p>


<h3>Author(s)</h3>

<p>Brian Peterson, Garrett See
</p>


<h3>See Also</h3>

<p>instrument, future, option_series.yahoo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
stock('SPY','USD',1)
stock('DIA','USD',1)
spread('SPY.DIA','USD',c('SPY','DIA'),c(1,-1))

## End(Not run)
</code></pre>

<hr>
<h2 id='to_secBATV'>Convert tick data to one-second data</h2><span id='topic+to_secBATV'></span><span id='topic+alltick2sec'></span>

<h3>Description</h3>

<p>This is like taking a snapshot of the market at the end of every second, 
except the volume over the second is summed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_secBATV(x)

alltick2sec(getdir = "~/TRTH/tick/", savedir = "~/TRTH/sec/",
  Symbols = list.files(getdir), overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_secBATV_+3A_x">x</code></td>
<td>
<p>the xts series to convert to 1 minute BATV</p>
</td></tr>
<tr><td><code id="to_secBATV_+3A_getdir">getdir</code></td>
<td>
<p>Directory that contains tick data</p>
</td></tr>
<tr><td><code id="to_secBATV_+3A_savedir">savedir</code></td>
<td>
<p>Directory in which to save converted data</p>
</td></tr>
<tr><td><code id="to_secBATV_+3A_symbols">Symbols</code></td>
<td>
<p>String names of instruments to convert</p>
</td></tr>
<tr><td><code id="to_secBATV_+3A_overwrite">overwrite</code></td>
<td>
<p>TRUE/FALSE. If file already exists in savedir, should it be 
overwritten?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From tick data with columns: &ldquo;Price&rdquo;, &ldquo;Volume&rdquo;, 
&ldquo;Bid.Price&rdquo;, &ldquo;Bid.Size&rdquo;, &ldquo;Ask.Price&rdquo;, &ldquo;Ask.Size&rdquo;, 
to data of one second frequency with columns &ldquo;Bid.Price&rdquo;, 
&ldquo;Bid.Size&rdquo;, &ldquo;Ask.Price&rdquo;, &ldquo;Ask.Size&rdquo;,
&ldquo;Trade.Price&rdquo;, and &ldquo;Volume&rdquo;
</p>
<p>The primary purpose of these functions is to reduce the amount of data on 
disk so that it will take less time to load the data into memory.
</p>
<p>If there are no trades or bid/ask price updates in a given second, we will 
not make a row for that timestamp.  If there were no trades, but the bid or 
ask price changed, then we _will_ have a row but the Volume and Trade.Price 
will be NA.
</p>
<p>If there are multiple trades in the same second, Volume will be the sum of 
the volume, but only the last trade price in that second will be printed. 
Similarly, if there is a trade, and then later in the same second, there is 
a bid/ask update, the last Bid/Ask Price/Size will be used.
</p>
<p><code>alltick2sec</code> is used to convert the data of several files from tick to 
one second frequency data.
</p>


<h3>Value</h3>

<p><code>to_secBATV</code> returns an xts object of one second frequency.
<code>alltick2sec</code> returns a list of files that were converted.
</p>


<h3>Note</h3>

<p><code>to_secBATV</code> is used by the TRTH_BackFill.R script in the 
inst/parser directory of the FinancialInstrument package.  These functions
are specific to to data created by that script and are not intended for
more general use.
</p>


<h3>Author(s)</h3>

<p>gsee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getSymbols("CLU1")
system.time(xsec &lt;- to_secBATV(CLU1))
convert.log &lt;- alltick2sec()

## End(Not run)
</code></pre>

<hr>
<h2 id='update_instruments.instrument'>Update instruments with metadata from another instrument.</h2><span id='topic+update_instruments.instrument'></span>

<h3>Description</h3>

<p>Update instruments with metadata from another instrument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_instruments.instrument(Symbols, source_id, create.new = FALSE,
  ignore = "identifiers", assign_i = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_instruments.instrument_+3A_symbols">Symbols</code></td>
<td>
<p>charcter vector of primary_ids or other instrument identifiers.
of instruments to be updated.  Alternatively, <code>Symbols</code> can be an
<code>instrument</code> or list of <code>instrument</code>s.</p>
</td></tr>
<tr><td><code id="update_instruments.instrument_+3A_source_id">source_id</code></td>
<td>
<p>The primary_id (or other identifier) of an instrument, or
an instrument.  The <code>source_id</code> instrument will be used to update the
metadata of <code>Symbols</code>' instruments.</p>
</td></tr>
<tr><td><code id="update_instruments.instrument_+3A_create.new">create.new</code></td>
<td>
<p>If FALSE (Default), only attributes that exist but have 
empty values will be updated.  If TRUE, new attributes will be created if
<code>source_id</code> has them, but the <code>Symbols</code> do not.</p>
</td></tr>
<tr><td><code id="update_instruments.instrument_+3A_ignore">ignore</code></td>
<td>
<p>vector of names of instrument attributes that should not be
copied to the updated instruments.</p>
</td></tr>
<tr><td><code id="update_instruments.instrument_+3A_assign_i">assign_i</code></td>
<td>
<p>TRUE/FALSE. If TRUE, the updated instruments will be assigned
back into the instrument environment.  If FALSE, a list of updated 
instruments will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, only attributes that have a value of <code>""</code> will be given a 
new value.
</p>
<p>If <code>create.new</code> is <code>TRUE</code>, then if there are attributes in
<code>source_id</code> that are not in the <code>Symbols</code>' instrument, those 
attributes will be copied to the updated instruments unless they are in 
<code>ignore</code>.
</p>


<h3>Value</h3>

<p>if <code>isTRUE(assign_i)</code> a vector of primary_ids of the instruments
that were upated.  Otherwise, a list of updated instrument objects.
</p>


<h3>Note</h3>

<p>one way to overwrite attributes of one instrument with those of another
is to first set equal to <code>""</code> those attributes that you want to 
overwrite, then use <code>update_instruments.instrument</code> to copy the 
attributes.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update_instruments.yahoo">update_instruments.yahoo</a></code>, 
<code><a href="#topic+all.equal.instrument">all.equal.instrument</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#rm_instruments()
currency("USD")
synthetic("SPX", "USD", identifiers=list(yahoo="GSPC"),
          tick_size=0.01,
         liquidHours="T08:30:00/T15:00:00", 
         extraField='something else', 
         assign_i=TRUE)
stock("SPY", "USD", liquidHours="", assign_i=TRUE)
all.equal(getInstrument("SPX"), getInstrument("SPY"))
getInstrument("SPY")
## update SPY metadata based on the metadata of SPX
## Only attributes that == "" are updated by default
update_instruments.instrument("SPY", "SPX", assign_i=FALSE) #liquidHours
update_instruments.instrument("SPY", "SPX", create.new=TRUE,
                              ignore=c("identifiers", "type"), 
                              assign_i=FALSE)
# Although you probably do NOT want to, this will
# copy everything new -- including identifiers and type!
update_instruments.instrument("SPY", "SPX", create.new=TRUE, ignore=NULL, 
                              assign_i=FALSE) 

## End(Not run)
</code></pre>

<hr>
<h2 id='update_instruments.iShares'>update iShares and SPDR ETF metadata</h2><span id='topic+update_instruments.iShares'></span><span id='topic+update_instruments.SPDR'></span>

<h3>Description</h3>

<p>This will update previously defined iShares or SPDR ETF <code>instrument</code>s. 
Both functions will add attributes for &ldquo;Name&rdquo;, and &ldquo;FundFamily&rdquo;
(&ldquo;iShares&rdquo; or &ldquo;SPDR&rdquo;). <code>update_instruments.iShares</code> will 
also add an attribute for &ldquo;MgmtFees&rdquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_instruments.iShares(Symbols, silent = FALSE)

update_instruments.SPDR(Symbols, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_instruments.iShares_+3A_symbols">Symbols</code></td>
<td>
<p>character vector of iShares ETF ticker symbols.  If not 
specified, <code>unique(c(ls_funds(), ls_stocks()))</code> will be used.</p>
</td></tr>
<tr><td><code id="update_instruments.iShares_+3A_silent">silent</code></td>
<td>
<p>silence the warning that no iShares are defined?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>called for side-effect
</p>


<h3>Note</h3>

<p><code>update_instruments.SPDR</code> will probably NOT work on Windows 
because in the call to <code>download.file</code> it uses <code>method=curl</code> 
since it has to download from an https URL scheme.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>References</h3>

<p><a href="http://us.ishares.com/home.htm">http://us.ishares.com/home.htm</a>, 
<a href="https://www.spdrs.com/">https://www.spdrs.com/</a>
</p>


<h3>See Also</h3>

<p><code>update_instruments.yahoo</code>, <code>update_instruments.TTR</code>,
<code>twsInstrument:::update_instruments.IB</code>, 
<code>update_instruments.instrument</code>, 
<code><a href="#topic+update_instruments.morningstar">update_instruments.morningstar</a></code>,
<code><a href="#topic+update_instruments.masterDATA">update_instruments.masterDATA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stock("IWC", currency("USD"))
update_instruments.iShares("IWC")
getInstrument("IWC")

Symbols &lt;- stock(c("SPY", "JNK"), currency("USD"))
update_instruments.SPDR(Symbols)
buildHierarchy(c("SPY", "JNK"), "Name")

## End(Not run)
</code></pre>

<hr>
<h2 id='update_instruments.masterDATA'>Update instrument metadata for ETFs</h2><span id='topic+update_instruments.masterDATA'></span><span id='topic+update_instruments.md'></span>

<h3>Description</h3>

<p>Uses the masterDATA.com list of ETFs and ETNs to update previously defined
instruments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_instruments.masterDATA(Symbols, silent = FALSE)

update_instruments.md(Symbols, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_instruments.masterDATA_+3A_symbols">Symbols</code></td>
<td>
<p>character vector of Symbols of ETFs</p>
</td></tr>
<tr><td><code id="update_instruments.masterDATA_+3A_silent">silent</code></td>
<td>
<p>silence warnings?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>update_instruments.md</code> is an alias.
</p>
<p>MasterDATA classifies each ETF into one of six Fund.Types.  From their
website:
</p>
<p>US Equity ETF: All constituents trade on a US exchange. Both ProShares and 
Rydex sponsor ETFs with the objective of achieving the performance (or a 
multiple of the performance) of several major US stock indexes. These ETFs 
currently are included in this category despite the fact that their 
constituent lists are generally not limited to US stocks.
</p>
<p>Global Equity ETF: One or more of the constituents do not trade on a US 
Exchange.
</p>
<p>Fixed Income ETF:  The constituent list contains government and / or 
corporate debt instruments. ETFs with this classification will not be 
considered for inclusion in MasterDATA's index / ETF compilation list.
</p>
<p>Commodity Based ETF:  This classification of ETF has no constituents but is 
structured to reflect the valuation of a commodity such as gold, silver, oil 
or interest rates. ETFs with this classification will not be considered for 
inclusion in MasterDATA's index / ETF compilation list.
</p>
<p>Exchange Traded Notes: A type of unsecured, unsubordinated debt security that 
was first issued by Barclays Bank PLC. The purpose of ETNs is to create a 
type of security that combines both the aspects of bonds and exchange traded 
funds (ETF). Similar to ETFs, ETNs are traded on a major exchange.
</p>


<h3>Value</h3>

<p>called for side-effect. Each ETF that is updated will be given 
instrument attributes of &ldquo;Name&rdquo; and &ldquo;Fund.Type&rdquo;
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>References</h3>

<p><a href="http://masterDATA.com">http://masterDATA.com</a> 
(<a href="http://www.masterdata.com/helpfiles/ETF_List_Downloads/AllTypes.csv">http://www.masterdata.com/helpfiles/ETF_List_Downloads/AllTypes.csv</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update_instruments.yahoo">update_instruments.yahoo</a></code>, 
<code><a href="#topic+update_instruments.instrument">update_instruments.instrument</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stock(s &lt;- c("SPY", "DIA"), currency("USD"))
update_instruments.masterDATA(s)
buildHierarchy(s, "Name", "Fund.Type", "defined.by")

## End(Not run)
</code></pre>

<hr>
<h2 id='update_instruments.morningstar'>Update instrument metadata for ETFs</h2><span id='topic+update_instruments.morningstar'></span><span id='topic+update_instruments.ms'></span>

<h3>Description</h3>

<p>Currently, this only updates ETFs.  It will add &ldquo;msName&rdquo; and
&ldquo;msCategory&rdquo; attributes to the instruments. (ms for morningstar)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_instruments.morningstar(Symbols, silent = FALSE)

update_instruments.ms(Symbols, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_instruments.morningstar_+3A_symbols">Symbols</code></td>
<td>
<p>character vector of Symbols of ETFs</p>
</td></tr>
<tr><td><code id="update_instruments.morningstar_+3A_silent">silent</code></td>
<td>
<p>silence warnings?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>called for side-effect.
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>References</h3>

<p><a href="http://www.morningstar.com">http://www.morningstar.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update_instruments.yahoo">update_instruments.yahoo</a></code>, 
<code><a href="#topic+update_instruments.TTR">update_instruments.TTR</a></code>
<code><a href="#topic+update_instruments.iShares">update_instruments.iShares</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## backup .instrument environment
ibak &lt;- as.list(FinancialInstrument:::.instrument) 
rm_instruments()
stock(s &lt;- c("SPY", "USO", "LQD"), currency("USD"))
update_instruments.morningstar(s)
instrument.table(s)
## cleanup and restore instrument environment
rm_instruments(keep.currencies=FALSE)
loadInstruments(ibak)

## End(Not run)
</code></pre>

<hr>
<h2 id='update_instruments.yahoo'>updates instrument metadata with data from yahoo</h2><span id='topic+update_instruments.yahoo'></span><span id='topic+update_instruments.TTR'></span>

<h3>Description</h3>

<p>Adds/updates information in instrument with data downloaded from yahoo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_instruments.yahoo(Symbols = c("stocks", "all"), verbose = FALSE)

update_instruments.TTR(Symbols = c("stocks", "all"), exchange = c("AMEX",
  "NASDAQ", "NYSE"), silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_instruments.yahoo_+3A_symbols">Symbols</code></td>
<td>
<p>can be a vector of instrument names, or, can be &lsquo;all&rsquo;
or &lsquo;stocks&rsquo; or, for update_instruments.TTR, can be NULL in which case
all stocks found with <code>stockSymbols</code> will be defined</p>
</td></tr>
<tr><td><code id="update_instruments.yahoo_+3A_verbose">verbose</code></td>
<td>
<p>be verbose?</p>
</td></tr>
<tr><td><code id="update_instruments.yahoo_+3A_exchange">exchange</code></td>
<td>
<p>character vector of names of exchanges. Used in &lsquo;TTR&rsquo;
method. Can be &ldquo;AMEX&rdquo;, &ldquo;NASDAQ&rdquo;, or &ldquo;NYSE&rdquo;</p>
</td></tr>
<tr><td><code id="update_instruments.yahoo_+3A_silent">silent</code></td>
<td>
<p>silence warnings?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although these functions are intended to update the metadata of
previously defined instruments, <code>update_instruments.TTR</code> will
define the stocks if they do not already exist.
</p>
<p><code>update_instruments.TTR</code> is only to be used on U.S. stocks denominated in USD.
</p>


<h3>Value</h3>

<p>called for side-effect
</p>


<h3>Author(s)</h3>

<p>Garrett See
</p>


<h3>References</h3>

<p>Yahoo! Finance <a href="finance.yahoo.com">finance.yahoo.com</a> YahooQuote
<a href="http://dirk.eddelbuettel.com/code/yahooquote.html">http://dirk.eddelbuettel.com/code/yahooquote.html</a> 
gummy-stuff.org <a href="www.gummy-stuff.org/Yahoo-data.htm">www.gummy-stuff.org/Yahoo-data.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update_instruments.instrument">update_instruments.instrument</a></code>, 
<code><a href="#topic+update_instruments.morningstar">update_instruments.morningstar</a></code>,
<code><a href="#topic+update_instruments.masterDATA">update_instruments.masterDATA</a></code>,
<code><a href="TTR.html#topic+stockSymbols">stockSymbols</a></code>, <code><a href="#topic+stock">stock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 	
	stock('GS',currency('USD'))
 update_instruments.yahoo('GS')
	getInstrument('GS')
 update_instruments.TTR('GS')
 getInstrument('GS')

## End(Not run)
</code></pre>

<hr>
<h2 id='volep'>generate endpoints for volume bars</h2><span id='topic+volep'></span>

<h3>Description</h3>

<p>generate endpoints for volume bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volep(x, units)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volep_+3A_x">x</code></td>
<td>
<p>time series containing 'Volume' column</p>
</td></tr>
<tr><td><code id="volep_+3A_units">units</code></td>
<td>
<p>volume sum to mark for bars</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua Ulrich
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
