<!DOCTYPE html><html><head><title>Help for package BAT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BAT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accuracy'><p>Scaled mean squared error of accumulation curves.</p></a></li>
<li><a href='#aic'><p>Akaike Information Criterion.</p></a></li>
<li><a href='#alpha'><p>Alpha diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</p></a></li>
<li><a href='#alpha.accum'><p>Alpha diversity accumulation curves (observed and estimated).</p></a></li>
<li><a href='#alpha.estimate'><p>Alpha diversity estimates.</p></a></li>
<li><a href='#arrabida'><p>Sample data of spiders in Arrabida (Portugal)</p></a></li>
<li><a href='#beta'><p>Beta diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</p></a></li>
<li><a href='#beta.accum'><p>Beta diversity accumulation curves.</p></a></li>
<li><a href='#beta.evenness'><p>Beta diversity evenness (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</p></a></li>
<li><a href='#beta.multi'><p>Beta diversity among multiple communities.</p></a></li>
<li><a href='#contribution'><p>Contribution of species or individuals to total phylogenetic/functional diversity.</p></a></li>
<li><a href='#coverage'><p>Coverage of datasets.</p></a></li>
<li><a href='#cwd'><p>Community Weighted Dispersion.</p></a></li>
<li><a href='#cwe'><p>Community Weighted Evenness.</p></a></li>
<li><a href='#cwm'><p>Community Weighted Mean.</p></a></li>
<li><a href='#dispersion'><p>Phylogenetic/functional dispersion of species or individuals.</p></a></li>
<li><a href='#dummy'><p>Dummify variables.</p></a></li>
<li><a href='#evenness'><p>Taxonomic/phylogenetic/functional evenness of species or individuals.</p></a></li>
<li><a href='#evenness.contribution'><p>Contribution of each species or individual to the total taxonomic/phylogenetic/functional evenness.</p></a></li>
<li><a href='#fill'><p>Filling missing data.</p></a></li>
<li><a href='#functree'><p>Functional tree for 338 species of spiders</p></a></li>
<li><a href='#gamma'><p>Gamma diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</p></a></li>
<li><a href='#gdm'><p>General dynamic model of oceanic island biogeography (GDM).</p></a></li>
<li><a href='#geres'><p>Sample data of spiders in Geres (Portugal)</p></a></li>
<li><a href='#gower'><p>Gower distance.</p></a></li>
<li><a href='#guadiana'><p>Sample data of spiders in Guadiana (Portugal)</p></a></li>
<li><a href='#hill'><p>Hill numbers.</p></a></li>
<li><a href='#hull.alpha'><p>Alpha diversity using convex hull hypervolumes.</p></a></li>
<li><a href='#hull.beta'><p>Beta diversity partitioning using convex hull hypervolumes.</p></a></li>
<li><a href='#hull.build'><p>Build convex hull hypervolumes.</p></a></li>
<li><a href='#hull.contribution'><p>Contribution of each observation to a convex hull hypervolume.</p></a></li>
<li><a href='#hull.gamma'><p>Gamma diversity using convex hull hypervolumes.</p></a></li>
<li><a href='#hull.sad'><p>Species-abundance distribution (SAD) using convex hulls.</p></a></li>
<li><a href='#hyper.build'><p>Build hyperspace.</p></a></li>
<li><a href='#hyper.quality'><p>Quality of hyperspace.</p></a></li>
<li><a href='#iaor'><p>Interspecific abundance-occupancy relationship (IAOR).</p></a></li>
<li><a href='#kernel.alpha'><p>Alpha diversity using kernel density hypervolumes.</p></a></li>
<li><a href='#kernel.beta'><p>Beta diversity partitioning using kernel density hypervolumes.</p></a></li>
<li><a href='#kernel.beta.evenness'><p>Functional beta diversity evenness using kernel density hypervolumes.</p></a></li>
<li><a href='#kernel.build'><p>Build kernel hypervolumes.</p></a></li>
<li><a href='#kernel.contribution'><p>Contribution of each observation to the kernel density hypervolume.</p></a></li>
<li><a href='#kernel.dispersion'><p>Functional dispersion of kernel density hypervolumes.</p></a></li>
<li><a href='#kernel.evenness'><p>Functional evenness of kernel density hypervolumes.</p></a></li>
<li><a href='#kernel.evenness.contribution'><p>Contribution of each observation to the evenness of a kernel density hypervolume.</p></a></li>
<li><a href='#kernel.gamma'><p>Gamma diversity using kernel density hypervolumes.</p></a></li>
<li><a href='#kernel.hotspots'><p>Hotspots in hypervolumes.</p></a></li>
<li><a href='#kernel.originality'><p>Functional originality of observations in kernel density hypervolumes.</p></a></li>
<li><a href='#kernel.sad'><p>Species-abundance distribution (SAD) using kernel density hypervolumes.</p></a></li>
<li><a href='#kernel.similarity'><p>Pairwise similarity among kernel density hypervolumes.</p></a></li>
<li><a href='#linnean'><p>Create Linnean tree.</p></a></li>
<li><a href='#mixture'><p>Mixture model.</p></a></li>
<li><a href='#optim.alpha'><p>Optimization of alpha diversity sampling protocols.</p></a></li>
<li><a href='#optim.alpha.stats'><p>Efficiency statistics for alpha-sampling.</p></a></li>
<li><a href='#optim.beta'><p>Optimization of beta diversity sampling protocols.</p></a></li>
<li><a href='#optim.beta.stats'><p>Efficiency statistics for beta-sampling.</p></a></li>
<li><a href='#optim.spatial'><p>Optimization of spatial sampling.</p></a></li>
<li><a href='#originality'><p>Phylogenetic/functional originality of species or individuals.</p></a></li>
<li><a href='#phylotree'><p>Taxonomic tree for 338 species of spiders (surrogate for phylogeny)</p></a></li>
<li><a href='#r2'><p>Model R2.</p></a></li>
<li><a href='#rao'><p>Rao quadratic entropy.</p></a></li>
<li><a href='#raster.alpha'><p>Maps of alpha diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</p></a></li>
<li><a href='#raster.beta'><p>Maps of beta diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</p></a></li>
<li><a href='#raster.dispersion'><p>Maps of phylogenetic/functional dispersion of species or individuals.</p></a></li>
<li><a href='#raster.evenness'><p>Maps of phylogenetic/functional evenness of species or individuals.</p></a></li>
<li><a href='#sad'><p>Species-abundance distribution (SAD).</p></a></li>
<li><a href='#sar'><p>Species-area relationship (SAR).</p></a></li>
<li><a href='#ses'><p>Standard Effect Size.</p></a></li>
<li><a href='#sim.plot'><p>Plots of simulated species spatial distributions.</p></a></li>
<li><a href='#sim.sad'><p>Simulation of species abundance distributions (SAD).</p></a></li>
<li><a href='#sim.sample'><p>Simulation of sampling from artificial communities.</p></a></li>
<li><a href='#sim.spatial'><p>Simulation of species spatial distributions.</p></a></li>
<li><a href='#sim.tree'><p>Simulation of phylogenetic or functional tree.</p></a></li>
<li><a href='#slope'><p>Slope of accumulation curves.</p></a></li>
<li><a href='#standard'><p>Standardize variables.</p></a></li>
<li><a href='#tree.build'><p>Build functional tree.</p></a></li>
<li><a href='#tree.quality'><p>Quality of tree.</p></a></li>
<li><a href='#tree.zero'><p>Convert negative branches of tree.</p></a></li>
<li><a href='#uniqueness'><p>Phylogenetic/functional uniqueness of species.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Biodiversity Assessment Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>2.9.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes algorithms to assess alpha and beta diversity
    in all their dimensions (taxonomic, phylogenetic and functional).
    It allows performing a number of analyses based on species
    identities/abundances, phylogenetic/functional distances, trees,
    convex-hulls or kernel density n-dimensional hypervolumes
    depicting species relationships.
    Cardoso et al. (2015) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12310">doi:10.1111/2041-210X.12310</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, geometry, graphics, hypervolume, MASS, methods, nls2,
parallel, phytools, stats, terra, utils, vegan</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-16 16:58:08 UTC; ungol</td>
</tr>
<tr>
<td>Author:</td>
<td>Pedro Cardoso [aut, cre],
  Stefano Mammola [aut],
  Francois Rigal [aut],
  Jose Carvalho [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pedro Cardoso &lt;pmcardoso@fc.ul.pt&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-17 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='accuracy'>Scaled mean squared error of accumulation curves.</h2><span id='topic+accuracy'></span>

<h3>Description</h3>

<p>Accuracy (scaled mean squared error) of accumulation curves compared with a known true diversity value (target).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accuracy(accum, target = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy_+3A_accum">accum</code></td>
<td>
<p>A matrix resulting from the alpha.accum or beta.accum functions (sampling units x diversity values).</p>
</td></tr>
<tr><td><code id="accuracy_+3A_target">target</code></td>
<td>
<p>The true known diversity value, with which the curve will be compared. If not specified, default is the diversity observed with all sampling units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Among multiple measures of accuracy (Walther &amp; Moore 2005) the SMSE presents several advantages, as it is (Cardoso et al. 2014):
(i) scaled to true diversity, so that similar absolute differences are weighted according to how much they represent of the real value;
(ii) scaled to the number of sampling units, so that values are independent of sample size;
(iii) squared, so that small, mostly meaningless fluctuations around the true value are down-weighted; and
(iv) independent of positive or negative deviation from the real value, as such differentiation is usually not necessary.
For alpha diversity accuracy may also be weighted according to how good the data is predicted to be. The weight of each point in the curve is proportional to its sampling intensity (i.e. n/Sobs).
</p>


<h3>Value</h3>

<p>Accuracy values (both raw and weighted) for all observed and estimated curves.
</p>


<h3>References</h3>

<p>Cardoso, P., Rigal, F., Borges, P.A.V. &amp; Carvalho, J.C. (2014) A new frontier in biodiversity inventory: a proposal for estimators of phylogenetic and functional diversity. Methods in Ecology and Evolution, 5: 452-461.
</p>
<p>Walther, B.A. &amp; Moore, J.L. (2005) The concepts of bias, precision and accuracy, and their use in testing the performance of species richness estimators, with a literature reviewof estimator performance. Ecography, 28, 815-829.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm1 &lt;- matrix(c(2,2,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,0,2,2), nrow = 4, ncol = 5, byrow = TRUE)
comm2 &lt;- matrix(c(1,1,0,0,0,0,2,1,0,0,0,0,2,1,0,0,0,0,2,1), nrow = 4, ncol = 5, byrow = TRUE)
tree &lt;- hclust(dist(c(1:5), method="euclidean"), method="average")
acc.alpha = alpha.accum(comm1)
accuracy(acc.alpha)
accuracy(acc.alpha, 10)
acc.beta = beta.accum(comm1, comm2, tree)
accuracy(acc.beta)
accuracy(acc.beta, c(1,1,0))
</code></pre>

<hr>
<h2 id='aic'>Akaike Information Criterion.</h2><span id='topic+aic'></span>

<h3>Description</h3>

<p>Calculates the Akaike Information Criterion (AIC) of any model based on observed and estimated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic(obs, est = NULL, param = 0, correct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic_+3A_obs">obs</code></td>
<td>
<p>Either a model or a vector with observed values.</p>
</td></tr>
<tr><td><code id="aic_+3A_est">est</code></td>
<td>
<p>A vector with estimated values. Only used if obs is not a model.</p>
</td></tr>
<tr><td><code id="aic_+3A_param">param</code></td>
<td>
<p>Number of parameters in the model. If obs is a model param will be ignored and the number of parameters will be calculated from the model.</p>
</td></tr>
<tr><td><code id="aic_+3A_correct">correct</code></td>
<td>
<p>Boolean indicating whether the corrected version of AIC (AICc) should be calculated, mostly for models with few observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful for models or functions that do not provide logLik values.
</p>


<h3>Value</h3>

<p>The AIC or AICc value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs = c(1,4,5,6)
est = c(0,1,4,7)

#example using values
aic(obs, est)
aic(obs, est, param = 1)
aic(obs, est, param = 1, correct = TRUE)

#example using model
mod = lm(obs ~ est)
aic(mod)
extractAIC(mod)[2]
aic(mod, correct = TRUE)

</code></pre>

<hr>
<h2 id='alpha'>Alpha diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</h2><span id='topic+alpha'></span>

<h3>Description</h3>

<p>Observed richness with possible rarefaction, multiple sites simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha(comm, tree, raref = 0, runs = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="alpha_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="alpha_+3A_raref">raref</code></td>
<td>
<p>An integer specifying the number of individuals for rarefaction (individual based).
If raref &lt; 1 no rarefaction is made.
If raref = 1 rarefaction is made by the minimum abundance among all sites.
If raref &gt; 1 rarefaction is made by the abundance indicated.
If not specified, default is 0.</p>
</td></tr>
<tr><td><code id="alpha_+3A_runs">runs</code></td>
<td>
<p>Number of resampling runs for rarefaction. If not specified, default is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TD is equivalent to species richness. Calculations of PD and FD are based on Faith (1992) and Petchey &amp; Gaston (2002, 2006), which measure PD and FD of a community as the total branch length of a tree linking all species represented in such community.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric). The path to the root of the tree is always included in calculations of PD and FD.
The number and order of species in comm must be the same as in tree.
The rarefaction option is useful to compare communities with much different numbers of individuals sampled, which might bias diversity comparisons (Gotelli &amp; Colwell 2001)
</p>


<h3>Value</h3>

<p>A matrix of sites x diversity values (either &quot;Richness&quot; OR &quot;Mean, Median, Min, LowerCL, UpperCL and Max&quot;).
</p>


<h3>References</h3>

<p>Faith, D.P. (1992) Conservation evaluation and phylogenetic diversity. Biological Conservation, 61, 1-10.
</p>
<p>Gotelli, N.J. &amp; Colwell, R.K. (2001) Quantifying biodiversity: procedures and pitfalls in the measurement and comparison of species richness. Ecology Letters, 4, 379-391.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2002) Functional diversity (FD), species richness and community composition. Ecology Letters, 5, 402-411.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2006) Functional diversity: back to basics and looking forward. Ecology Letters, 9, 741-758.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(0,0,1,1,0,0,2,1,0,0), nrow = 2, ncol = 5, byrow = TRUE)
trait = 1:5
tree &lt;- tree.build(trait)
plot(tree, "u")
alpha(comm)
alpha(comm, raref = 0)
alpha(comm, tree)
alpha(comm, tree, 2, 100)
</code></pre>

<hr>
<h2 id='alpha.accum'>Alpha diversity accumulation curves (observed and estimated).</h2><span id='topic+alpha.accum'></span>

<h3>Description</h3>

<p>Estimation of alpha diversity of a single site with accumulation of sampling units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.accum(
  comm,
  tree,
  func = "nonparametric",
  target = -2,
  runs = 100,
  prog = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha.accum_+3A_comm">comm</code></td>
<td>
<p>A sampling units x species matrix, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="alpha.accum_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="alpha.accum_+3A_func">func</code></td>
<td>
<p>The class of estimators to be used:
If func is partial match of &quot;curve&quot;, TD, PD or FD are based on extrapolating the accumulation curve of observed diversity.
If func is partial match of &quot;nonparametric&quot;, TD, PD or FD are based on non-parametric estimators.
If func is partial match of &quot;completeness&quot;, PD or FD estimates are based on the completeness of TD (requires a tree to be used).
If not specified, default is &quot;nonparametric.</p>
</td></tr>
<tr><td><code id="alpha.accum_+3A_target">target</code></td>
<td>
<p>True diversity value to calculate the accuracy of curves (scaled mean squared error). If not specified do not calculate accuracy (default), -1 uses the total observed diversity as true diversity and any other value is the true known diversity.</p>
</td></tr>
<tr><td><code id="alpha.accum_+3A_runs">runs</code></td>
<td>
<p>Number of random permutations to be made to the sampling order. If not specified, default is 100.</p>
</td></tr>
<tr><td><code id="alpha.accum_+3A_prog">prog</code></td>
<td>
<p>Present a text progress bar in the R console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observed diversity often is an underestimation of true diversity. Several approaches have been devised to estimate species richness (TD) from incomplete sampling.
These include: (1) fitting asymptotic functions to randomised accumulation curves (Soberon &amp; Llorente 1993; Flather 1996; Cardoso et al. in prep.)
(2) the use of non-parametric estimators based on the incidence or abundance of rare species (Heltshe &amp; Forrester 1983; Chao 1984, 1987; Colwell &amp; Coddington 1994).
A correction to non-parametric estimators has also been recently proposed, based on the proportion of singleton or unique species
(species represented by a single individual or in a single sampling unit respectively; Lopez et al. 2012).
Cardoso et al. (2014) have proposed a way of adapting these approaches to estimate PD and FD, also adding a third possible approach for
these dimensions of diversity: (3) correct PD and FD values based on the completeness of TD, where completeness equals the proportion of estimated true diversity that was observed.
Calculations of PD and FD are based on Faith (1992) and Petchey &amp; Gaston (2002, 2006), which measure PD and FD of a community as the total branch length of a tree linking all species represented in such community.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric). The path to the root of the tree is always included in calculations of PD and FD.
The number and order of species in comm must be the same as in tree.
</p>


<h3>Value</h3>

<p>A matrix of sampling units x diversity values (sampling units, individuals, observed and estimated diversity).
The values provided by this function are:
</p>
<p>Sampl - Number of sampling units;
</p>
<p>Ind - Number of individuals;
</p>
<p>Obs - Observed diversity;
</p>
<p>S1 - Singletons;
</p>
<p>S2 - Doubletons;
</p>
<p>Q1 - Uniques;
</p>
<p>Q2 - Duplicates;
</p>
<p>Jack1ab - First order jackknife estimator for abundance data;
</p>
<p>Jack1in - First order jackknife estimator for incidence data;
</p>
<p>Jack2ab - Second order jackknife estimator for abundance data;
</p>
<p>Jack2in - Second order jackknife estimator for incidence data;
</p>
<p>Chao1 - Chao estimator for abundance data;
</p>
<p>Chao2 - Chao estimator for incidence data;
</p>
<p>Clench - Clench or Michaelis-Menten curve;
</p>
<p>Exponential - Exponential curve;
</p>
<p>Rational - Rational function;
</p>
<p>Weibull - Weibull curve;
</p>
<p>The P-corrected version of all non-parametric estimators is also provided.
</p>
<p>Accuracy - if accuracy is to be calculated a list is returned instead, with the second element being the scaled mean squared error of each estimator.
</p>


<h3>References</h3>

<p>Cardoso, P., Rigal, F., Borges, P.A.V. &amp; Carvalho, J.C. (2014) A new frontier in biodiversity inventory: a proposal for estimators of phylogenetic and functional diversity. Methods in Ecology and Evolution, 5: 452-461.
</p>
<p>Chao, A. (1984) Nonparametric estimation of the number of classes in a population. Scandinavian Journal of Statistics, 11, 265-270.
</p>
<p>Chao, A. (1987) Estimating the population size for capture-recapture data with unequal catchability. Biometrics 43, 783-791.
</p>
<p>Colwell, R.K. &amp; Coddington, J.A. (1994) Estimating terrestrial biodiversity through extrapolation. Phil. Trans. Roy. Soc. London B 345, 101-118.
</p>
<p>Faith, D.P. (1992) Conservation evaluation and phylogenetic diversity. Biological Conservation, 61, 1-10.
</p>
<p>Flather, C. (1996) Fitting species-accumulation functions and assessing regional land use impacts on avian diversity. Journal of Biogeography, 23, 155-168.
</p>
<p>Heltshe, J. &amp; Forrester, N.E. (1983) Estimating species richness using the jackknife procedure. Biometrics, 39, 1-11.
</p>
<p>Lopez, L.C.S., Fracasso, M.P.A., Mesquita, D.O., Palma, A.R.T. &amp; Riul, P. (2012) The relationship between percentage of singletons and sampling effort: a new approach to reduce the bias of richness estimates. Ecological Indicators, 14, 164-169.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2002) Functional diversity (FD), species richness and community composition. Ecology Letters, 5, 402-411.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2006) Functional diversity: back to basics and looking forward. Ecology Letters, 9, 741-758.
</p>
<p>Soberon, M.J. &amp; Llorente, J. (1993) The use of species accumulation functions for the prediction of species richness. Conservation Biology, 7, 480-488.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,1,0,0,0,0,2,1,0,0,0,0,2,1,0,0,0,0,2,1), nrow = 4, ncol = 5, byrow = TRUE)
tree &lt;- hclust(dist(c(1:5), method="euclidean"), method="average")
alpha.accum(comm)
alpha.accum(comm, func = "nonparametric")
alpha.accum(comm, tree, "completeness")
alpha.accum(comm, tree, "curve", runs = 1000)
alpha.accum(comm, target = -1)
</code></pre>

<hr>
<h2 id='alpha.estimate'>Alpha diversity estimates.</h2><span id='topic+alpha.estimate'></span>

<h3>Description</h3>

<p>Estimation of alpha diversity of multiple sites simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.estimate(comm, tree, func = "nonparametric")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha.estimate_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundances or number of incidences.</p>
</td></tr>
<tr><td><code id="alpha.estimate_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="alpha.estimate_+3A_func">func</code></td>
<td>
<p>The class of estimators to be used:
If func is partial match of &quot;nonparametric&quot;, TD, PD or FD are based on non-parametric estimators.
If func is partial match of &quot;completeness&quot;, PD or FD estimates are based on the completeness of TD (requires a tree to be used).
If not specified, default is &quot;nonparametric&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observed diversity often is an underestimation of true diversity.
Non-parametric estimators based on the incidence or abundance of rare species have been proposed to overcome the problem of undersampling (Heltshe &amp; Forrester 1983; Chao 1984, 1987; Colwell &amp; Coddington 1994).
A correction to non-parametric estimators has also been recently proposed, based on the proportion (P) of singleton or unique species
(species represented by a single individual or in a single sampling unit respectively; Lopez et al. 2012).
Cardoso et al. (2014) have proposed a way of adapting non-parametric species richness estimators to PD and FD. They have also proposed correcting PD and FD values based on the completeness of TD, where completeness equals the proportion of estimated true diversity that was observed.
Calculations of PD and FD are based on Faith (1992) and Petchey &amp; Gaston (2002, 2006), which measure PD and FD of a community as the total branch length of a tree linking all species represented in such community.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric). The path to the root of the tree is always included in calculations of PD and FD.
The number and order of species in comm must be the same as in tree.
</p>


<h3>Value</h3>

<p>A matrix of sites x diversity values (individuals, observed and estimated diversity).
The values provided by this function are:
</p>
<p>Ind - Number of individuals;
</p>
<p>Obs - Observed diversity;
</p>
<p>S1 - Singletons;
</p>
<p>S2 - Doubletons;
</p>
<p>Jack1ab - First order jackknife estimator for abundance data;
</p>
<p>Jack2ab - Second order jackknife estimator for abundance data;
</p>
<p>Chao1 - Chao estimator for abundance data.
</p>
<p>The P-corrected version of all estimators is also provided.
</p>


<h3>References</h3>

<p>Cardoso, P., Rigal, F., Borges, P.A.V. &amp; Carvalho, J.C. (2014) A new frontier in biodiversity inventory: a proposal for estimators of phylogenetic and functional diversity. Methods in Ecology and Evolution, 5: 452-461.
</p>
<p>Chao, A. (1984) Nonparametric estimation of the number of classes in a population. Scandinavian Journal of Statistics, 11, 265-270.
</p>
<p>Chao, A. (1987) Estimating the population size for capture-recapture data with unequal catchability. Biometrics 43, 783-791.
</p>
<p>Colwell, R.K. &amp; Coddington, J.A. (1994) Estimating terrestrial biodiversity through extrapolation. Phil. Trans. Roy. Soc. London B 345, 101-118.
</p>
<p>Faith, D.P. (1992) Conservation evaluation and phylogenetic diversity. Biological Conservation, 61, 1-10.
</p>
<p>Heltshe, J. &amp; Forrester, N.E. (1983) Estimating species richness using the jackknife procedure. Biometrics, 39, 1-11.
</p>
<p>Lopez, L.C.S., Fracasso, M.P.A., Mesquita, D.O., Palma, A.R.T. &amp; Riul, P. (2012) The relationship between percentage of singletons and sampling effort: a new approach to reduce the bias of richness estimates. Ecological Indicators, 14, 164-169.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2002) Functional diversity (FD), species richness and community composition. Ecology Letters, 5, 402-411.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2006) Functional diversity: back to basics and looking forward. Ecology Letters, 9, 741-758.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,1,0,0,0,0,2,1,0,0,0,0,2,1,0,0,0,0,2,1), nrow = 4, ncol = 5, byrow = TRUE)
tree &lt;- hclust(dist(c(1:5), method="euclidean"), method="average")
alpha.estimate(comm)
alpha.estimate(comm, tree)
alpha.estimate(comm, tree, func = "completeness")
</code></pre>

<hr>
<h2 id='arrabida'>Sample data of spiders in Arrabida (Portugal)</h2><span id='topic+arrabida'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of 338 spider species in each of 320 sampling units. Details are described in:
Cardoso, P., Gaspar, C., Pereira, L.C., Silva, I., Henriques, S.S., Silva, R.R. &amp; Sousa, P. (2008) Assessing spider species richness and composition in Mediterranean cork oak forests. Acta Oecologica, 33: 114-127.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(arrabida)
</code></pre>


<h3>Format</h3>

<p>A data frame with 320 sampling units (rows) and 338 species (variables).
</p>

<hr>
<h2 id='beta'>Beta diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</h2><span id='topic+beta'></span>

<h3>Description</h3>

<p>Beta diversity with possible rarefaction, multiple sites simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta(
  comm,
  tree,
  func = "jaccard",
  abund = TRUE,
  raref = 0,
  runs = 100,
  comp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="beta_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="beta_+3A_func">func</code></td>
<td>
<p>Partial match indicating whether the Jaccard or Soerensen family of beta diversity measures should be used.  If not specified, default is Jaccard.</p>
</td></tr>
<tr><td><code id="beta_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used or converted to incidence before analysis.</p>
</td></tr>
<tr><td><code id="beta_+3A_raref">raref</code></td>
<td>
<p>An integer specifying the number of individuals for rarefaction (individual based).
If raref &lt; 1 no rarefaction is made.
If raref = 1 rarefaction is made by the minimum abundance among all sites.
If raref &gt; 1 rarefaction is made by the abundance indicated.
If not specified, default is 0.</p>
</td></tr>
<tr><td><code id="beta_+3A_runs">runs</code></td>
<td>
<p>Number of resampling runs for rarefaction. If not specified, default is 100.</p>
</td></tr>
<tr><td><code id="beta_+3A_comp">comp</code></td>
<td>
<p>Boolean indicating whether beta diversity components (shared and unique fractions) should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta diversity measures used here follow the partitioning framework independently developed by Podani &amp; Schmera (2011) and Carvalho et al. (2012)
and later expanded to PD and FD by Cardoso et al. (2014), where Btotal = Brepl + Brich.
Btotal = total beta diversity, reflecting both species replacement and loss/gain;
Brepl = beta diversity explained by replacement of species alone; Brich = beta diversity explained by species loss/gain (richness differences) alone.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric). The path to the root of the tree is always included in calculations of PD and FD.
The number and order of species in comm must be the same as in tree.
The rarefaction option is useful to compare communities with much different numbers of individuals sampled, which might bias diversity comparisons (Gotelli &amp; Colwell 2001).
</p>


<h3>Value</h3>

<p>Three distance matrices between sites, one per each of the three beta diversity measures (either &quot;Obs&quot; OR &quot;Mean, Median, Min, LowerCL, UpperCL and Max&quot;).
</p>


<h3>References</h3>

<p>Cardoso, P., Rigal, F., Carvalho, J.C., Fortelius, M., Borges, P.A.V., Podani, J. &amp; Schmera, D. (2014) Partitioning taxon, phylogenetic and functional beta diversity into replacement and richness difference components. Journal of Biogeography, 41, 749-761.
</p>
<p>Carvalho, J.C., Cardoso, P. &amp; Gomes, P. (2012) Determining the relative roles of species replacement and species richness differences in generating beta-diversity patterns. Global Ecology and Biogeography, 21, 760-771.
</p>
<p>Gotelli, N.J. &amp; Colwell, R.K. (2001) Quantifying biodiversity: procedures and pitfalls in the measurement and comparison of species richness. Ecology Letters, 4, 379-391.
</p>
<p>Podani, J. &amp; Schmera, D. (2011) A new conceptual and methodological framework for exploring and explaining pattern in presence-absence data. Oikos, 120, 1625-1638.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(2,2,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,1,2,2), nrow = 4, ncol = 5, byrow = TRUE)
tree &lt;- hclust(dist(c(1:5), method="euclidean"), method="average")
beta(comm)
beta(comm, abund = FALSE, comp = TRUE)
beta(comm, tree)
beta(comm, raref = 1)
beta(comm, tree, "s", abund = FALSE, raref = 2)
</code></pre>

<hr>
<h2 id='beta.accum'>Beta diversity accumulation curves.</h2><span id='topic+beta.accum'></span>

<h3>Description</h3>

<p>Beta diversity between two sites with accumulation of sampling units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.accum(
  comm1,
  comm2,
  tree,
  func = "jaccard",
  abund = TRUE,
  runs = 100,
  prog = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.accum_+3A_comm1">comm1</code></td>
<td>
<p>A sampling units x species matrix for the first site, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="beta.accum_+3A_comm2">comm2</code></td>
<td>
<p>A sampling units x species matrix for the second site, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="beta.accum_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="beta.accum_+3A_func">func</code></td>
<td>
<p>Partial match indicating whether the Jaccard or Soerensen family of beta diversity measures should be used. If not specified, default is jaccard.</p>
</td></tr>
<tr><td><code id="beta.accum_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used or converted to incidence before analysis.</p>
</td></tr>
<tr><td><code id="beta.accum_+3A_runs">runs</code></td>
<td>
<p>Number of random permutations to be made to the sampling order. If not specified, default is 100.</p>
</td></tr>
<tr><td><code id="beta.accum_+3A_prog">prog</code></td>
<td>
<p>Present a text progress bar in the R console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As widely recognized for species richness, beta diversity is also biased when communities are undersampled.
Beta diversity accumulation curves have been proposed by Cardoso et al. (2009) to test if beta diversity has approached an asymptote when comparing two undersampled sites.
The beta diversity measures used here follow the partitioning framework independently developed by Podani &amp; Schmera (2011) and Carvalho et al. (2012)
and later expanded to PD and FD by Cardoso et al. (2014), where Btotal = Brepl + Brich.
Btotal = total beta diversity, reflecting both species replacement and loss/gain;
Brepl = beta diversity explained by replacement of species alone;
Brich = beta diversity explained by species loss/gain (richness differences) alone.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric). The path to the root of the tree is always included in calculations of PD and FD.
The number and order of species in comm1 and comm2 must be the same as in tree. Also, the number of sampling units should be similar in both sites.
</p>


<h3>Value</h3>

<p>Three matrices of sampling units x diversity values, one per each of the three beta diversity measures (sampling units, individuals and observed diversity).
</p>


<h3>References</h3>

<p>Cardoso, P., Borges, P.A.V. &amp; Veech, J.A. (2009) Testing the performance of beta diversity measures based on incidence data: the robustness to undersampling. Diversity and Distributions, 15, 1081-1090.
</p>
<p>Cardoso, P., Rigal, F., Carvalho, J.C., Fortelius, M., Borges, P.A.V., Podani, J. &amp; Schmera, D. (2014) Partitioning taxon, phylogenetic and functional beta diversity into replacement and richness difference components. Journal of Biogeography, 41, 749-761.
</p>
<p>Carvalho, J.C., Cardoso, P. &amp; Gomes, P. (2012) Determining the relative roles of species replacement and species richness differences in generating beta-diversity patterns. Global Ecology and Biogeography, 21, 760-771.
</p>
<p>Podani, J. &amp; Schmera, D. (2011) A new conceptual and methodological framework for exploring and explaining pattern in presence-absence data. Oikos, 120, 1625-1638.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm1 &lt;- matrix(c(2,2,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,0,2,2), nrow = 4, byrow = TRUE)
comm2 &lt;- matrix(c(1,1,0,0,0,0,2,1,0,0,0,0,2,1,0,0,0,0,2,1), nrow = 4, byrow = TRUE)
tree &lt;- hclust(dist(c(1:5), method="euclidean"), method="average")
beta.accum(comm1, comm2)
beta.accum(comm1, comm2, func = "Soerensen")
beta.accum(comm1, comm2, tree)
beta.accum(comm1, comm2, abund = FALSE)
beta.accum(comm1, comm2, tree,, FALSE)
</code></pre>

<hr>
<h2 id='beta.evenness'>Beta diversity evenness (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</h2><span id='topic+beta.evenness'></span>

<h3>Description</h3>

<p>Difference of evenness between pairs of sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.evenness(
  comm,
  tree,
  distance,
  method = "expected",
  func = "camargo",
  abund = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.evenness_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="beta.evenness_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="beta.evenness_+3A_distance">distance</code></td>
<td>
<p>A dist or matrix object representing the phylogenetic or functional distance between species. If both tree and distance are missing, taxonomic evenness is calculated.</p>
</td></tr>
<tr><td><code id="beta.evenness_+3A_method">method</code></td>
<td>
<p>Calculate evenness using &quot;expected&quot; values (default) or values based on &quot;contribution&quot; of species to the tree.</p>
</td></tr>
<tr><td><code id="beta.evenness_+3A_func">func</code></td>
<td>
<p>Calculate evenness using &quot;Camargo&quot; (default) or &quot;Bulla&quot; index.</p>
</td></tr>
<tr><td><code id="beta.evenness_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether evenness should be calculated using abundance data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This measure is simply the pairwise difference of evenness calculated based on the index of Camargo (1993) or Bulla (1994) using the values of both species abundances and edge lengths in the tree (if PD/FD).
</p>
<p>If no tree or distance is provided the result is the original index.
</p>


<h3>Value</h3>

<p>Distance matrix between sites.
</p>


<h3>References</h3>

<p>Bulla, L. (1994) An index of evenness and its associated diversity measure. Oikos, 70: 167-171.
</p>
<p>Camargo, J.A. (1993) Must dominance increase with the number of subordinate species in competitive interactions? Journal of Theoretical Biology, 161: 537-542.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,2,0,0,0,1,1,0,0,0,0,2,2,0,0,1,1,1,1,100), nrow = 4, byrow = TRUE)
distance &lt;- dist(c(1:5), method = "euclidean")
tree &lt;- hclust(distance, method = "average")
beta.evenness(comm)
beta.evenness(comm, tree)
beta.evenness(comm, tree, method = "contribution")
beta.evenness(comm, tree, abund = FALSE)
</code></pre>

<hr>
<h2 id='beta.multi'>Beta diversity among multiple communities.</h2><span id='topic+beta.multi'></span>

<h3>Description</h3>

<p>Beta diversity with possible rarefaction - multiple sites measure calculated as the average or variance of all pairwise values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.multi(comm, tree, func = "jaccard", abund = TRUE, raref = 0, runs = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.multi_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="beta.multi_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="beta.multi_+3A_func">func</code></td>
<td>
<p>Indicates whether the Jaccard or Soerensen family of beta diversity measures should be used. If not specified, default is jaccard.</p>
</td></tr>
<tr><td><code id="beta.multi_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used (TRUE) or converted to incidence (FALSE) before analysis.</p>
</td></tr>
<tr><td><code id="beta.multi_+3A_raref">raref</code></td>
<td>
<p>An integer specifying the number of individuals for rarefaction (individual based).
If raref &lt; 1 no rarefaction is made.
If raref = 1 rarefaction is made by the minimum abundance among all sites.
If raref &gt; 1 rarefaction is made by the abundance indicated.
If not specified, default is 0.</p>
</td></tr>
<tr><td><code id="beta.multi_+3A_runs">runs</code></td>
<td>
<p>Number of resampling runs for rarefaction. If not specified, default is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beta diversity of multiple sites simultaneously is calculated as either the average or the variance among all pairwise comparisons (Legendre, 2014).
The beta diversity measures used here follow the partitioning framework independently developed by Podani &amp; Schmera (2011) and Carvalho et al. (2012)
and later expanded to PD and FD by Cardoso et al. (2014), where Btotal = Brepl + Brich.
Btotal = total beta diversity, reflecting both species replacement and loss/gain;
Brepl = beta diversity explained by replacement of species alone;
Brich = beta diversity explained by species loss/gain (richness differences) alone.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric). The path to the root of the tree is always included in calculations of PD and FD.
The number and order of species in comm must be the same as in tree.
</p>


<h3>Value</h3>

<p>A matrix of beta measures x diversity values (average and variance).
</p>


<h3>References</h3>

<p>Cardoso, P., Rigal, F., Carvalho, J.C., Fortelius, M., Borges, P.A.V., Podani, J. &amp; Schmera, D. (2014) Partitioning taxon, phylogenetic and functional beta diversity into replacement and richness difference components. Journal of Biogeography, 41, 749-761.
</p>
<p>Carvalho, J.C., Cardoso, P. &amp; Gomes, P. (2012) Determining the relative roles of species replacement and species richness differences in generating beta-diversity patterns. Global Ecology and Biogeography, 21, 760-771.
</p>
<p>Legendre, P. (2014) Interpreting the replacement and richness difference components of beta diversity. Global Ecology and Biogeography, 23: 1324-1334.
</p>
<p>Podani, J. &amp; Schmera, D. (2011) A new conceptual and methodological framework for exploring and explaining pattern in presence-absence data. Oikos, 120, 1625-1638.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(2,2,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,0,2,2), nrow = 4, ncol = 5, byrow = TRUE)
tree &lt;- hclust(dist(c(1:5), method="euclidean"), method="average")
beta.multi(comm)
beta.multi(comm, func = "Soerensen")
beta.multi(comm, tree)
beta.multi(comm, raref = 1)
beta.multi(comm, tree, "s", FALSE, raref = 2)
</code></pre>

<hr>
<h2 id='contribution'>Contribution of species or individuals to total phylogenetic/functional diversity.</h2><span id='topic+contribution'></span>

<h3>Description</h3>

<p>Contribution of each species or individual to the total PD or FD of a number of communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contribution(comm, tree, abund = FALSE, relative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contribution_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data. If missing, the contribution of all species to the full tree is calculated.</p>
</td></tr>
<tr><td><code id="contribution_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="contribution_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether contribution should be weighted by abundance of each species.</p>
</td></tr>
<tr><td><code id="contribution_+3A_relative">relative</code></td>
<td>
<p>A boolean (T/F) indicating whether contribution should be relative to total PD or FD (proportional contribution per individual or species). If FALSE, the sum of contributions for each site is equal to total PD/FD, if TRUE it is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contribution is equivalent to the evolutionary distinctiveness index (ED) of Isaac et al. (2007) if done by species and to the abundance weighted evolutionary distinctiveness (AED) of Cadotte et al. (2010) if done by individual.
</p>


<h3>Value</h3>

<p>A matrix of sites x species values (or values per species if no comm is given).
</p>


<h3>References</h3>

<p>Isaac, N.J.B., Turvey, S.T., Collen, B., Waterman, C. &amp; Baillie, J.E.M. (2007) Mammals on the EDGE: conservation priorities based on threat and phylogeny. PLoS One, 2: e296.
</p>
<p>Cadotte, M.W., Davies, T.J., Regetz, J., Kembel, S.W., Cleland, E. &amp; Oakley, T.H. (2010) Phylogenetic diversity metrics for ecological communities: integrating species richness, abundance and evolutionary history. Ecology Letters, 13: 96-105.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,2,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,1,0,1), nrow = 4, byrow = TRUE)
tree = tree.build(1:5)

contribution(comm, tree)
contribution(comm, tree, TRUE)
contribution(comm, tree, relative = TRUE)
</code></pre>

<hr>
<h2 id='coverage'>Coverage of datasets.</h2><span id='topic+coverage'></span>

<h3>Description</h3>

<p>Coverage is a measure of completeness of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage(comm, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_+3A_comm">comm</code></td>
<td>
<p>A matrix of sites x species with abundance values.</p>
</td></tr>
<tr><td><code id="coverage_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculated as the estimated proportion of individuals that belong to the species (or phylogenetic, or functional diversity) already collected (Chao and Jost 2012).
</p>


<h3>Value</h3>

<p>A vector with coverage values per site.
</p>


<h3>References</h3>

<p>Chao, A. &amp; Jost, L. (2012). Coverage-based rarefaction and extrapolation: standardizing samples by completeness rather than size. Ecology, 93: 2533-2547.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(2,1,0,0,100,1,2,0,0,3,1,2,4,0,0,0,0,0,2,2), nrow = 4, ncol = 5, byrow = TRUE)
tree &lt;- hclust(dist(c(1:5), method="euclidean"), method="average")
coverage(comm)
coverage(comm, tree)
</code></pre>

<hr>
<h2 id='cwd'>Community Weighted Dispersion.</h2><span id='topic+cwd'></span>

<h3>Description</h3>

<p>Standard deviation value of each of a series of traits in multiple communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwd(comm, trait, abund = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cwd_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with incidence or abundance data about the species in the community.</p>
</td></tr>
<tr><td><code id="cwd_+3A_trait">trait</code></td>
<td>
<p>A species x traits matrix, with trait values for each species in comm.</p>
</td></tr>
<tr><td><code id="cwd_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used (TRUE) or converted to incidence (FALSE) before analysis. If not specified, default is TRUE.</p>
</td></tr>
<tr><td><code id="cwd_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NA values before calculating cwd.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Community weighted dispersion is used to compare communities in terms of their dispersion of trait values around a mean, reflecting individual trait variability or diversity.
</p>


<h3>Value</h3>

<p>A sites x trait matrix with sd value per site and trait.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(2,5,0,0,0,1,1,0,0,0,0,1,2,0,0,0,0,0,10,1), nrow = 4, ncol = 5, byrow = TRUE)
rownames(comm) = c("Site1","Site2","Site3","Site4")
colnames(comm) = c("Sp1","Sp2","Sp3","Sp4","Sp5")
trait &lt;- matrix(c(1,1,0,0,0,0,2,1,0,0,0,0,2,1,0,0,0,0,2,1), nrow = 5, ncol = 4, byrow = TRUE)
rownames(trait) = colnames(comm)
colnames(trait) = c("Trait1","Trait2","Trait3","Trait4")
cwd(comm, trait)
cwd(comm, trait, FALSE)
</code></pre>

<hr>
<h2 id='cwe'>Community Weighted Evenness.</h2><span id='topic+cwe'></span>

<h3>Description</h3>

<p>Evenness value of each of a series of traits in multiple communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwe(comm, trait, func = "camargo", abund = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cwe_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with incidence or abundance data about the species in the community.</p>
</td></tr>
<tr><td><code id="cwe_+3A_trait">trait</code></td>
<td>
<p>A species x traits matrix, with trait values for each species in comm.</p>
</td></tr>
<tr><td><code id="cwe_+3A_func">func</code></td>
<td>
<p>Calculate evenness using Camargo (1993; default) or Bulla (1994) index.</p>
</td></tr>
<tr><td><code id="cwe_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used (TRUE) or converted to incidence (FALSE) before analysis. If not specified, default is TRUE.</p>
</td></tr>
<tr><td><code id="cwe_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NA values before calculating cwe.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Community weighted evenness is used to compare communities in terms of their evenness of trait values, reflecting trait abundance and distances between values.
</p>


<h3>Value</h3>

<p>A sites x trait matrix with evenness value per site and trait.
</p>


<h3>References</h3>

<p>Bulla, L. (1994) An index of evenness and its associated diversity measure. Oikos, 70: 167-171.
</p>
<p>Camargo, J.A. (1993) Must dominance increase with the number of subordinate species in competitive interactions? Journal of Theoretical Biology, 161: 537-542.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,1,1,1,0,1,1,0,0,0,0,1,2,0,0,0,0,0,10,1), nrow = 4, ncol = 5, byrow = TRUE)
rownames(comm) = c("Site1","Site2","Site3","Site4")
colnames(comm) = c("Sp1","Sp2","Sp3","Sp4","Sp5")
trait &lt;- matrix(c(4,1,3,4,2,2,2,1,3,3,2,0,1,4,0,0,5,5,2,1), nrow = 5, ncol = 4, byrow = TRUE)
rownames(trait) = colnames(comm)
colnames(trait) = c("Trait1","Trait2","Trait3","Trait4")
cwe(comm, trait)
cwe(comm, trait, abund = FALSE)
cwe(comm, trait, "bulla")
</code></pre>

<hr>
<h2 id='cwm'>Community Weighted Mean.</h2><span id='topic+cwm'></span>

<h3>Description</h3>

<p>Average value of each of a series of traits in multiple communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwm(comm, trait, abund = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cwm_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with incidence or abundance data about the species in the community.</p>
</td></tr>
<tr><td><code id="cwm_+3A_trait">trait</code></td>
<td>
<p>A species x traits matrix, with trait values for each species in comm.</p>
</td></tr>
<tr><td><code id="cwm_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used (TRUE) or converted to incidence (FALSE) before analysis. If not specified, default is TRUE.</p>
</td></tr>
<tr><td><code id="cwm_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NA values before calculating cwm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Community weighted mean is used to compare communities in terms of their &quot;typical&quot; trait values.
</p>


<h3>Value</h3>

<p>A sites x trait matrix with mean value per site and trait.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(2,5,0,0,0,1,1,0,0,0,0,1,2,0,0,0,0,0,10,1), nrow = 4, ncol = 5, byrow = TRUE)
rownames(comm) = c("Site1","Site2","Site3","Site4")
colnames(comm) = c("Sp1","Sp2","Sp3","Sp4","Sp5")
trait &lt;- data.frame(Trait1 = c(1,0,0,2,0), Trait2 = c(rep("A",2), rep("B",3)))
rownames(trait) = colnames(comm)
cwm(comm, trait)
cwm(comm, trait, FALSE)
</code></pre>

<hr>
<h2 id='dispersion'>Phylogenetic/functional dispersion of species or individuals.</h2><span id='topic+dispersion'></span>

<h3>Description</h3>

<p>Average dissimilarity between any two species or individuals randomly chosen in a community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersion(
  comm,
  tree,
  distance,
  func = "originality",
  abund = TRUE,
  relative = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersion_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data. If missing, the dispersion using the full tree or distance matrix is calculated.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_distance">distance</code></td>
<td>
<p>A dist object representing the phylogenetic or functional distance between species.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_func">func</code></td>
<td>
<p>Calculate dispersion using originality (default), uniqueness or contribution.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether dispersion should be calculated using individuals (T) or species (F).</p>
</td></tr>
<tr><td><code id="dispersion_+3A_relative">relative</code></td>
<td>
<p>A boolean (T/F) indicating whether dispersion should be relative to the maximum distance between any two species in the tree or distance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If abundance data is used and a tree is given, dispersion is the quadratic entropy of Rao (1982).
If abundance data is not used but a tree is given, dispersion is the phylogenetic dispersion measure of Webb et al. (2002).
</p>


<h3>Value</h3>

<p>A vector of values per site (or a single value if no comm is given).
</p>


<h3>References</h3>

<p>Rao, C.R. (1982) Diversity and dissimilarity coefficients: a unified approach. Theoretical Population Biology, 21: 24-43.
</p>
<p>Webb, C.O., Ackerly, D.D., McPeek, M.A. &amp; Donoghue, M.J. (2002) Phylogenies and community ecology. Annual Review of Ecology and Systematics, 33: 475-505.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,2,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,1,1,1), nrow = 4, byrow = TRUE)
distance &lt;- dist(c(1:5), method="euclidean")
tree &lt;- hclust(distance, method="average")
dispersion(tree = tree)
dispersion(distance = distance)
dispersion(comm, tree)
dispersion(comm, tree, abund = FALSE)
dispersion(comm, tree, abund = FALSE, relative = FALSE)
</code></pre>

<hr>
<h2 id='dummy'>Dummify variables.</h2><span id='topic+dummy'></span>

<h3>Description</h3>

<p>Convert factor variables to dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy(trait, convert = NULL, weight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_+3A_trait">trait</code></td>
<td>
<p>A species x traits matrix or data.frame.</p>
</td></tr>
<tr><td><code id="dummy_+3A_convert">convert</code></td>
<td>
<p>A vector of column numbers, usually categorical variables, to be converted to dummy variables.</p>
</td></tr>
<tr><td><code id="dummy_+3A_weight">weight</code></td>
<td>
<p>Indicates whether weights of variables should be returned (TRUE/FALSE) or a vector with weights per variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If convert is given the algorithm will convert these column numbers to dummy variables. Otherwise it will convert all columns with factors or characters.
</p>


<h3>Value</h3>

<p>A matrix with variables converted or, if weight == TRUE or a vector, a list also with weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trait = data.frame(length = c(2,4,6,3,1), wing = c("A", "B", "A", "A", "B"))
dummy(trait)
dummy(trait, weight = TRUE)
dummy(trait, convert = 2, weight = c(0.9, 0.1))
</code></pre>

<hr>
<h2 id='evenness'>Taxonomic/phylogenetic/functional evenness of species or individuals.</h2><span id='topic+evenness'></span>

<h3>Description</h3>

<p>Regularity of abundances and distances (if PD/FD) between species in a community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evenness(
  comm,
  tree,
  distance,
  method = "expected",
  func = "camargo",
  abund = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evenness_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data. If missing, the evenness using the full tree or distance matrix is calculated.</p>
</td></tr>
<tr><td><code id="evenness_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="evenness_+3A_distance">distance</code></td>
<td>
<p>A dist or matrix object representing the phylogenetic or functional distance between species. If both tree and distance are missing, taxonomic evenness is calculated.</p>
</td></tr>
<tr><td><code id="evenness_+3A_method">method</code></td>
<td>
<p>Calculate evenness using &quot;expected&quot; values (default) or values based on &quot;contribution&quot; of species to the tree.</p>
</td></tr>
<tr><td><code id="evenness_+3A_func">func</code></td>
<td>
<p>Calculate evenness using &quot;Camargo&quot; (default) or &quot;Bulla&quot; index.</p>
</td></tr>
<tr><td><code id="evenness_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether evenness should be calculated using abundance data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evenness is calculated based on the index of Camargo (1993) or Bulla (1994) using the values of both species abundances and edge lengths in the tree (if PD/FD).
</p>
<p>If no tree or distance is provided the result is the original index.
</p>
<p>If any site has &lt; 2 species its value will be NA.
</p>


<h3>Value</h3>

<p>A vector of values per site (or a single value if no comm is given).
</p>


<h3>References</h3>

<p>Bulla, L. (1994) An index of evenness and its associated diversity measure. Oikos, 70: 167-171.
</p>
<p>Camargo, J.A. (1993) Must dominance increase with the number of subordinate species in competitive interactions? Journal of Theoretical Biology, 161: 537-542.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,2,0,0,0,1,1,0,0,0,0,2,2,0,0,1,1,1,1,100), nrow = 4, byrow = TRUE)
distance &lt;- dist(c(1:5), method = "euclidean")
tree &lt;- hclust(distance, method = "average")
evenness(comm)
evenness(tree = tree, func = "bulla")
evenness(comm, tree)
evenness(comm, tree, method = "contribution")
evenness(comm, tree, abund = FALSE)
</code></pre>

<hr>
<h2 id='evenness.contribution'>Contribution of each species or individual to the total taxonomic/phylogenetic/functional evenness.</h2><span id='topic+evenness.contribution'></span>

<h3>Description</h3>

<p>Contribution of each observation to the regularity of abundances and distances (if PD/FD) between species in a community (or individuals in a species).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evenness.contribution(
  comm,
  tree,
  distance,
  method = "expected",
  func = "camargo",
  abund = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evenness.contribution_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data. If missing, the evenness using the full tree or distance matrix is calculated.</p>
</td></tr>
<tr><td><code id="evenness.contribution_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="evenness.contribution_+3A_distance">distance</code></td>
<td>
<p>A dist or matrix object representing the phylogenetic or functional distance between species. If both tree and distance are missing, taxonomic evenness is calculated.</p>
</td></tr>
<tr><td><code id="evenness.contribution_+3A_method">method</code></td>
<td>
<p>Calculate evenness using &quot;expected&quot; values (default) or values based on &quot;contribution&quot; of species to the tree.</p>
</td></tr>
<tr><td><code id="evenness.contribution_+3A_func">func</code></td>
<td>
<p>Calculate evenness using &quot;Camargo&quot; (1993; default) or &quot;Bulla&quot; (1994) index.</p>
</td></tr>
<tr><td><code id="evenness.contribution_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether evenness should be calculated using abundance data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contribution to evenness is calculated using a leave-one-out approach, whereby the contribution of a single observation is the total evenness minus the evenness calculated without that observation. Evenness is based on the index of Camargo (1993) or Bulla (1994) using the values of both species abundances and edge lengths in the tree (if PD/FD).
Note that the contribution of a species or individual can be negative, if the removal of an observation increases the total evenness.
</p>
<p>If no tree or distance is provided the result is calculated for taxonomic evenness using the original index.
</p>


<h3>Value</h3>

<p>A matrix of sites x species (or a vector if no comm is given).
</p>


<h3>References</h3>

<p>Bulla, L. (1994) An index of evenness and its associated diversity measure. Oikos, 70: 167-171.
</p>
<p>Camargo, J.A. (1993) Must dominance increase with the number of subordinate species in competitive interactions? Journal of Theoretical Biology, 161: 537-542.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,2,0,5,5,1,1,0,0,0,0,2,2,0,0,1,1,1,1,100), nrow = 4, byrow = TRUE)
distance &lt;- dist(c(1:5), method = "euclidean")
tree &lt;- hclust(distance, method = "average")
evenness.contribution(comm)
evenness.contribution(tree = tree, func = "bulla")
evenness.contribution(comm, tree)
evenness.contribution(comm, tree, method = "contribution")
evenness.contribution(comm, tree, abund = FALSE)
</code></pre>

<hr>
<h2 id='fill'>Filling missing data.</h2><span id='topic+fill'></span>

<h3>Description</h3>

<p>Estimation of missing trait values (NA) based on different methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill(trait, method = "regression", group = NULL, weight = NULL, step = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_+3A_trait">trait</code></td>
<td>
<p>A species x traits matrix (a species or individual for each row and traits as columns).</p>
</td></tr>
<tr><td><code id="fill_+3A_method">method</code></td>
<td>
<p>Method for imputing missing data. One of &quot;mean&quot; (mean value of the trait), &quot;median&quot; (median value of the trait), &quot;similar&quot; (input from closest species), &quot;regression&quot; (linear regression), &quot;w_regression&quot; (regression weighted by species distance), or &quot;PCA&quot; (Principal Component Analysis).</p>
</td></tr>
<tr><td><code id="fill_+3A_group">group</code></td>
<td>
<p>A vector (string of characters, factorial, etc.) whose values indicate which species belong to the same group as the missing and should be used in the estimation of missing data. If NULL all species will be used.</p>
</td></tr>
<tr><td><code id="fill_+3A_weight">weight</code></td>
<td>
<p>A hclust, phylo or dist object to calculate the distance between species and use as weights.
Note that the order of tip labels in trees or of species in the distance matrix should be the same as the order of species in trait.</p>
</td></tr>
<tr><td><code id="fill_+3A_step">step</code></td>
<td>
<p>A boolean (T/F) indicating if a stepwise regression model based on AIC should be performed. Ignored is regression is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inputs missing data in the trait matrix based on different methods (see Taugourdeau et al. 2014; Johnson et al. 2021 for comparisons among the performance of different methods). 
The simplest approach is the average imputation (&quot;mean&quot; or &quot;median&quot;), calculating the mean/median of the values for that trait based on all the observations that are non-missing. It has the advantage of keeping the same mean and the same sample size, but many disadvantages. 
The &quot;similar&quot; method inputs a systematically chosen value from the closest species who has similar values on other variables.
The default method is linear regression (&quot;regression&quot;), where the predicted value is obtained by regressing the missing variable on other variables. This preserves relationships among variables involved in the imputation model, but not variability around predicted values (i.e., may lead to extrapolations).
The &quot;w_regression&quot; takes into account the relative distance among species in the imputation of missing traits, based on the phylogenetic or functional distance between missing and non-missing species.
The &quot;PCA&quot; method performs PCA with incomplete data sensu Podani et al. (2021).
Note that for PCA and regressions methods the performance of the prediction increases as the number of collinear traits increase.
</p>


<h3>Value</h3>

<p>A trait matrix with missing data (NA) filled with predicted values.
If method = &quot;PCA&quot; the function returns the standard output of a principal component analysis as a list with:
Eigenvalues
Positive eigenvalues
Positive eigenvalues as percent
Square root of eigenvalues
Eigenvectors
Component scores
Variable scores
Object scores in a biplot
Variable scores in a biplot
</p>


<h3>References</h3>

<p>Johnson, T.F., Isaac, N.J., Paviolo, A. &amp; Gonzalez-Suarez, M. (2021). Handling missing values in trait data. Global Ecology and Biogeography, 30: 51-62.
</p>
<p>Podani, J., Kalapos, T., Barta, B. &amp; Schmera, D. (2021). Principal component analysis of incomplete data. A simple solution to an old problem. Ecological Informatics, 101235.
</p>
<p>Taugourdeau, S., Villerd, J., Plantureux, S., Huguenin-Elie, O. &amp; Amiaud, B. (2014). Filling the gap in functional trait databases: use of ecological hypotheses to replace missing data. Ecology and Evolution, 4: 944-958.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
trait &lt;- iris[,-5]
group &lt;- iris[,5]

#Generating some random missing data
for (i in 1:10)
trait[sample(nrow(trait), 1), sample(ncol(trait), 1)] &lt;- NA

#Estimating the missing data with different methods
fill(trait, "mean")
fill(trait, "mean", group)
fill(trait, "median")
fill(trait, "median", group)
fill(trait, "similar")
fill(trait, "similar", group)
fill(trait, "regression", step = FALSE)
fill(trait, "regression", group, step = TRUE)
fill(trait, "w_regression", step = TRUE)
fill(trait, "w_regression", weight = dist(trait), step = TRUE)
fill(trait, "PCA")

## End(Not run)
</code></pre>

<hr>
<h2 id='functree'>Functional tree for 338 species of spiders</h2><span id='topic+functree'></span>

<h3>Description</h3>

<p>A dataset representing the functional tree for 338 species of spiders captured in Portugal.
For each species were recorded: average size, type of web, type of hunting, stenophagy, vertical stratification in vegetation and circadial activity. Details are described in:
Cardoso, P., Pekar, S., Jocque, R. &amp; Coddington, J.A. (2011) Global patterns of guild composition and functional diversity of spiders. PLoS One, 6: e21710.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(functree)
</code></pre>


<h3>Format</h3>

<p>An hclust object with 338 species.
</p>

<hr>
<h2 id='gamma'>Gamma diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</h2><span id='topic+gamma'></span>

<h3>Description</h3>

<p>Observed richness among multiple sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma(comm, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="gamma_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TD is equivalent to species richness. Calculations of PD and FD are based on Faith (1992) and Petchey &amp; Gaston (2002, 2006), which measure PD and FD of a community as the total branch length of a tree linking all species represented in such community.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric). The path to the root of the tree is always included in calculations of PD and FD.
The number and order of species in comm must be the same as in tree.
</p>


<h3>Value</h3>

<p>A single value of gamma.
</p>


<h3>References</h3>

<p>Faith, D.P. (1992) Conservation evaluation and phylogenetic diversity. Biological Conservation, 61, 1-10.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2002) Functional diversity (FD), species richness and community composition. Ecology Letters, 5, 402-411.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2006) Functional diversity: back to basics and looking forward. Ecology Letters, 9, 741-758.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(0,0,1,1,0,0,2,1,0,0), nrow = 2, ncol = 5, byrow = TRUE)
trait = 1:5
tree &lt;- hclust(dist(c(1:5), method = "euclidean"), method = "average")
alpha(comm)
gamma(comm)
gamma(comm, trait)
gamma(comm, tree)
</code></pre>

<hr>
<h2 id='gdm'>General dynamic model of oceanic island biogeography (GDM).</h2><span id='topic+gdm'></span>

<h3>Description</h3>

<p>Fits and compares several of the most supported models for the GDM (using TD, PD or FD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdm(comm, tree, area, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdm_+3A_comm">comm</code></td>
<td>
<p>Either a vector with the diversity values per island, or an island x species matrix.</p>
</td></tr>
<tr><td><code id="gdm_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree (used only to fit the PD or FD GDM, requires comm to be a sites x species matrix).</p>
</td></tr>
<tr><td><code id="gdm_+3A_area">area</code></td>
<td>
<p>A vector with the area of islands.</p>
</td></tr>
<tr><td><code id="gdm_+3A_time">time</code></td>
<td>
<p>A vector with the age of islands. If not given, the species-area relationship is returned instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general dynamic model of oceanic island biogeography was proposed to account for diversity patterns within and across oceanic archipelagos as a function of area and age of the islands (Whittaker et al. 2008).
Several different equations have been found to describe the GDM, extending the different SAR models with the addition of a polynomial term using island age and its square (TT2), depicting the island ontogeny.
The first to be proposed was an extension of the exponential model (Whittaker et al. 2008), the power model extensions following shortly after (Fattorini 2009; Steinbauer et al. 2013), as was the linear model (Cardoso et al. 2020).
The relationships for PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric).
</p>


<h3>Value</h3>

<p>A matrix with the different model parameters and explanatory power.
</p>


<h3>References</h3>

<p>Cardoso, P., Branco, V.V., Borges, P.A.V., Carvalho, J.C., Rigal, F., Gabriel, R., Mammola, S., Cascalho, J. &amp; Correia, L. (2020) Automated discovery of relationships, models and principles in ecology. Frontiers in Ecology and Evolution, 8: 530135.
</p>
<p>Fattorini, S. (2009) On the general dynamic model of oceanic island biogeography. Journal of Biogeography, 36: 1100-1110.
</p>
<p>Steinbauer, M.J, Klara, D., Field, R., Reineking, B. &amp; Beierkuhnlein, C. (2013) Re-evaluating the general dynamic theory of oceanic island biogeography. Frontiers of Biogeography, 5: 185-194.
</p>
<p>Whittaker, R.J., Triantis, K.A. &amp; Ladle, R.J. (2008) A general dynamic theory of oceanic island biogeography. Journal of Biogeography, 35: 977-994.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>div &lt;- c(1,3,5,8,10)
comm &lt;- matrix(c(2,0,0,0,3,1,0,0,2,4,5,0,1,3,2,5,1,1,1,1), nrow = 5, ncol = 4, byrow = TRUE)
tree &lt;- hclust(dist(c(1:4), method="euclidean"), method="average")
area &lt;- c(10,40,80,160,160)
time &lt;- c(1,2,3,4,5)
gdm(div,,area,time)
gdm(comm,tree,area,time)
gdm(div,,area)
</code></pre>

<hr>
<h2 id='geres'>Sample data of spiders in Geres (Portugal)</h2><span id='topic+geres'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of 338 spider species in each of 320 sampling units. Details are described in:
Cardoso, P., Scharff, N., Gaspar, C., Henriques, S.S., Carvalho, R., Castro, P.H., Schmidt, J.B., Silva, I., Szuts, T., Castro, A. &amp; Crespo, L.C. (2008) Rapid biodiversity assessment of spiders (Araneae) using semi-quantitative sampling: a case study in a Mediterranean forest. Insect Conservation and Diversity, 1: 71-84.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geres)
</code></pre>


<h3>Format</h3>

<p>A data frame with 320 sampling untis (rows) and 338 species (variables).
</p>

<hr>
<h2 id='gower'>Gower distance.</h2><span id='topic+gower'></span>

<h3>Description</h3>

<p>Calculates Gower distances between observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gower(trait, convert = NULL, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gower_+3A_trait">trait</code></td>
<td>
<p>A species x traits matrix or data.frame.</p>
</td></tr>
<tr><td><code id="gower_+3A_convert">convert</code></td>
<td>
<p>A vector of column numbers, usually categorical variables, to be converted to dummy variables.</p>
</td></tr>
<tr><td><code id="gower_+3A_weight">weight</code></td>
<td>
<p>A vector of column numbers with weights for each variable. Its length must be equal to the number of columns in trait.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gower distance allows continuous, ordinal, categorical or binary variables, with possible weighting (Pavoine et al. 2009).
NAs are allowed as long as each pair of species has at least one trait value in common.
If convert is given the algorithm will convert these column numbers to dummy variables. Otherwise it will convert all columns with factors or characters as values.
</p>


<h3>Value</h3>

<p>A dist object with pairwise distances between species.
</p>


<h3>References</h3>

<p>Pavoine et al. (2009) On the challenge of treating various types of variables: application for improving the measurement of functional diversity. Oikos, 118: 391-402.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trait = data.frame(body = c(NA,2,3,4,4), beak = c(1,1,1,1,2))
gower(trait)
gower(trait, weight = c(1, 0))
</code></pre>

<hr>
<h2 id='guadiana'>Sample data of spiders in Guadiana (Portugal)</h2><span id='topic+guadiana'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of 338 spider species in each of 320 sampling units. Details are described in:
Cardoso, P., Henriques, S.S., Gaspar, C., Crespo, L.C., Carvalho, R., Schmidt, J.B., Sousa, P. &amp; Szuts, T. (2009) Species richness and composition assessment of spiders in a Mediterranean scrubland. Journal of Insect Conservation, 13: 45-55.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(guadiana)
</code></pre>


<h3>Format</h3>

<p>A data frame with 192 sampling units (rows) and 338 species (variables).
</p>

<hr>
<h2 id='hill'>Hill numbers.</h2><span id='topic+hill'></span>

<h3>Description</h3>

<p>Hill numbers with possible rarefaction, multiple sites simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hill(comm, q = 0, raref = 0, runs = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hill_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with abundance data.</p>
</td></tr>
<tr><td><code id="hill_+3A_q">q</code></td>
<td>
<p>Hill number order: q(0) = species richness, q(1) ~ Shannon diversity, q(2) ~ Simpson diversity, and so on...</p>
</td></tr>
<tr><td><code id="hill_+3A_raref">raref</code></td>
<td>
<p>An integer specifying the number of individuals for rarefaction (individual based).
If raref &lt; 1 no rarefaction is made.
If raref = 1 rarefaction is made by the minimum abundance among all sites.
If raref &gt; 1 rarefaction is made by the abundance indicated.
If not specified, default is 0.</p>
</td></tr>
<tr><td><code id="hill_+3A_runs">runs</code></td>
<td>
<p>Number of resampling runs for rarefaction. If not specified, default is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hill numbers are based on the number of equally abundant species  that would match the current diversity.
Depending on the single parameter they give more or less weight to rare species (Jost 2002).
</p>


<h3>Value</h3>

<p>A matrix of sites x diversity values (either &quot;Hill q&quot; OR &quot;Mean, Median, Min, LowerCL, UpperCL and Max&quot;).
</p>


<h3>References</h3>

<p>Hill, M.O. (1973). Diversity and evenness: a unifying notation and its consequences. Ecology, 54: 427-432.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(0,0,1,1,0,0,100,1,0,0), nrow = 2, ncol = 5, byrow = TRUE)
hill(comm)
hill(comm, q = 1)
hill(comm, q = 4, 1)
</code></pre>

<hr>
<h2 id='hull.alpha'>Alpha diversity using convex hull hypervolumes.</h2><span id='topic+hull.alpha'></span>

<h3>Description</h3>

<p>Estimation of functional richness of one or multiple sites, based on convex hull hypervolumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hull.alpha(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hull.alpha_+3A_comm">comm</code></td>
<td>
<p>A 'convhulln' object or list, preferably built with function hull.build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the functional richness (alpha FD) of one or more communities using convex hull hypervolumes.
Functional richness is expressed as the total volume of the convex hull.
</p>


<h3>Value</h3>

<p>One value or a vector of alpha diversity values for each site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm = rbind(c(1,3,0,5,3), c(3,2,5,0,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = hull.build(comm[1,], trait)
hull.alpha(hv)
hvlist = hull.build(comm, trait, axes = 2)
hull.alpha(hvlist)
</code></pre>

<hr>
<h2 id='hull.beta'>Beta diversity partitioning using convex hull hypervolumes.</h2><span id='topic+hull.beta'></span>

<h3>Description</h3>

<p>Pairwise beta diversity partitioning into replacement and net difference in amplitude components of convex hulls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hull.beta(comm, func = "jaccard", comp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hull.beta_+3A_comm">comm</code></td>
<td>
<p>A list of 'convhulln' objects, preferably built with function hull.build.</p>
</td></tr>
<tr><td><code id="hull.beta_+3A_func">func</code></td>
<td>
<p>Partial match indicating whether the Jaccard (default) or Soerensen family of beta diversity measures should be used.</p>
</td></tr>
<tr><td><code id="hull.beta_+3A_comp">comp</code></td>
<td>
<p>Boolean indicating whether beta diversity components (shared and unique fractions) should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a pairwise decomposition of the overall differentiation among kernel hypervolumes into two components: the replacement (shifts) of space between hypervolumes and net differences between the amount of space enclosed by each hypervolume.
The beta diversity measures used here follow the FD partitioning framework where Btotal = Breplacement + Brichness. Beta diversity ranges from 0 (when hypervolumes are identical) to 1 (when hypervolumes are fully dissimilar).
See Carvalho &amp; Cardoso (2020) and Mammola &amp; Cardoso (2020) for the full formulas of beta diversity used here.
</p>


<h3>Value</h3>

<p>Three pairwise distance matrices, one per each of the three beta diversity components.
</p>


<h3>References</h3>

<p>Carvalho, J.C. &amp; Cardoso, P. (2020) Decomposing the causes for niche differentiation between species using hypervolumes. Frontiers in Ecology and Evolution. https://doi.org/10.3389/fevo.2020.00243
</p>
<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution. https://doi.org/10.1111/2041-210X.13424
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- rbind(c(1,1,1,1,1), c(1,1,1,1,1), c(0,0,1,1,1),c(0,0,1,1,1))
colnames(comm) = c("SpA","SpB","SpC","SpD", "SpE")
rownames(comm) = c("Site 1","Site 2","Site 3","Site 4")

trait &lt;- cbind(c(2.2,4.4,6.1,8.3,3),c(0.5,1,0.5,0.4,4))
colnames(trait) = c("Trait 1","Trait 2")
rownames(trait) = colnames(comm)

hvlist = hull.build(comm, trait)
hull.beta(hvlist)
hvlist = hull.build(comm, trait, axes = 2)
hull.beta(hvlist, comp = TRUE)
</code></pre>

<hr>
<h2 id='hull.build'>Build convex hull hypervolumes.</h2><span id='topic+hull.build'></span>

<h3>Description</h3>

<p>Builds convex hull hypervolumes for each community from incidence and trait data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hull.build(
  comm,
  trait,
  distance = "gower",
  weight = NULL,
  axes = 0,
  convert = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hull.build_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, data.frame or vector, with incidence data about the species in the community.</p>
</td></tr>
<tr><td><code id="hull.build_+3A_trait">trait</code></td>
<td>
<p>A species x traits or axes matrix or data.frame (often from hyper.build) or, alternatively, a dist object.</p>
</td></tr>
<tr><td><code id="hull.build_+3A_distance">distance</code></td>
<td>
<p>One of &quot;gower&quot; or &quot;euclidean&quot;. Not used if trait is a dist object.</p>
</td></tr>
<tr><td><code id="hull.build_+3A_weight">weight</code></td>
<td>
<p>A vector of column numbers with weights for each variable. Its length must be equal to the number of columns in trait. Only used if axes &gt; 0 and if trait is not a dist object.</p>
</td></tr>
<tr><td><code id="hull.build_+3A_axes">axes</code></td>
<td>
<p>If 0, no transformation of data is done.
If 0 &lt; axes &lt;= 1 a PCoA is done with Gower/euclidean distances and as many axes as needed to achieve this proportion of variance explained are selected.
If axes &gt; 1 these many axes are selected.</p>
</td></tr>
<tr><td><code id="hull.build_+3A_convert">convert</code></td>
<td>
<p>A vector of column numbers, usually categorical variables, to be converted to dummy variables. Only used if axes &gt; 0 and if trait is not a dist object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hypervolumes can be constructed with the given data or data can be transformed using PCoA after traits are dummyfied (if needed) and standardized (always).
Beware that if transformations are required, all communities to be compared should be built simultaneously to guarantee comparability. In such case, one might want to first run hyper.build and use the resulting data in different runs of hull.build.
See function hyper.build for more details.
</p>


<h3>Value</h3>

<p>A 'convhulln' object or a list, representing the hypervolumes of each community.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm = rbind(c(1,3,0,5,3), c(3,2,5,0,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = hull.build(comm[1,], trait)
plot(hv)
hvlist = hull.build(comm, trait)
plot(hvlist[[2]])
hvlist = hull.build(comm, trait, axes = 2, weight = c(1,2))
plot(hvlist[[1]])
</code></pre>

<hr>
<h2 id='hull.contribution'>Contribution of each observation to a convex hull hypervolume.</h2><span id='topic+hull.contribution'></span>

<h3>Description</h3>

<p>Contribution of each species or individual to the total volume of one or more convex hulls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hull.contribution(comm, relative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hull.contribution_+3A_comm">comm</code></td>
<td>
<p>A 'convhulln' object or list, preferably built with function hull.build.</p>
</td></tr>
<tr><td><code id="hull.contribution_+3A_relative">relative</code></td>
<td>
<p>A boolean (T/F) indicating whether contribution should be relative to total PD or FD (proportional contribution per individual or species). If FALSE, the sum of contributions for each site is equal to total PD/FD, if TRUE it is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contribution of each observation (species or individual) to the total volume of a convex hull, calculated as the difference in volume between the total convex hull and a second hypervolume lacking this specific observation (i.e., leave-one-out approach; Mammola &amp; Cardoso, 2020).
</p>


<h3>Value</h3>

<p>A vector or matrix with the contribution values of each species or individual for each site.
</p>


<h3>References</h3>

<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution. https://doi.org/10.1111/2041-210X.13424
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm = rbind(c(1,3,0,5,3), c(3,2,5,1,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = hull.build(comm[1,], trait)
hull.contribution(hv)
hvlist = hull.build(comm, trait, axes = 2)
hull.contribution(hvlist, relative = TRUE)
</code></pre>

<hr>
<h2 id='hull.gamma'>Gamma diversity using convex hull hypervolumes.</h2><span id='topic+hull.gamma'></span>

<h3>Description</h3>

<p>Estimation of functional richness of multiple sites, based on convex hull hypervolumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hull.gamma(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hull.gamma_+3A_comm">comm</code></td>
<td>
<p>A 'convhulln' object or list, preferably built with function hull.build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the functional richness (gamma FD) of multiple communities using convex hull hypervolumes.
Functional richness is expressed as the total volume of the convex hull.
</p>


<h3>Value</h3>

<p>A single value of gamma.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm = rbind(c(1,3,0,5,3), c(3,2,5,0,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = hull.build(comm[1,], trait)
hull.alpha(hv)
hull.gamma(hv)
hvlist = hull.build(comm, trait, axes = 2)
hull.alpha(hvlist)
hull.gamma(hvlist)
</code></pre>

<hr>
<h2 id='hull.sad'>Species-abundance distribution (SAD) using convex hulls.</h2><span id='topic+hull.sad'></span>

<h3>Description</h3>

<p>Fits the SAD to community abundance data using convex hulls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hull.sad(comm, octaves = TRUE, scale = FALSE, raref = 0, runs = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hull.sad_+3A_comm">comm</code></td>
<td>
<p>A 'convhulln' object or list, preferably built with function hull.build.</p>
</td></tr>
<tr><td><code id="hull.sad_+3A_octaves">octaves</code></td>
<td>
<p>a boolean indicating whether octaves should be calculated.</p>
</td></tr>
<tr><td><code id="hull.sad_+3A_scale">scale</code></td>
<td>
<p>scale y-axis to sum 1.</p>
</td></tr>
<tr><td><code id="hull.sad_+3A_raref">raref</code></td>
<td>
<p>An integer specifying the number of individuals for rarefaction (individual based).
If raref &lt; 1 no rarefaction is made.
If raref = 1 rarefaction is made by the minimum abundance among all sites.
If raref &gt; 1 rarefaction is made by the abundance indicated.
If not specified, default is 0.</p>
</td></tr>
<tr><td><code id="hull.sad_+3A_runs">runs</code></td>
<td>
<p>Number of resampling runs for rarefaction. If not specified, default is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Species Abundance Distribution describes the commonness and rarity in ecological systems. It was recently expanded to accomodate phylegenetic and functional differences between species (Matthews et al., subm.). Classes defined as n = 1, 2-3, 4-7, 8-15, .... Rarefaction allows comparison of sites with different total abundances.
</p>


<h3>Value</h3>

<p>A vector or matrix with the different values per class per community.
</p>


<h3>References</h3>

<p>Matthews et al. (subm.) Phylogenetic and functional dimensions of the species abundance distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm = rbind(c(1,3,0,5,3), c(3,2,5,1,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = hull.build(comm, trait)
hull.sad(hv, scale = TRUE)
hull.sad(hv, octaves = FALSE)
hull.sad(hv, raref = TRUE)
</code></pre>

<hr>
<h2 id='hyper.build'>Build hyperspace.</h2><span id='topic+hyper.build'></span>

<h3>Description</h3>

<p>Builds hyperspace by transforming trait or distance data to use with either hull.build or kernel.build.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper.build(trait, distance = "gower", weight = NULL, axes = 1, convert = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyper.build_+3A_trait">trait</code></td>
<td>
<p>A species x traits matrix or data.frame or, alternatively, a dist object.</p>
</td></tr>
<tr><td><code id="hyper.build_+3A_distance">distance</code></td>
<td>
<p>One of &quot;gower&quot; or &quot;euclidean&quot;. Not used if trait is a dist object.</p>
</td></tr>
<tr><td><code id="hyper.build_+3A_weight">weight</code></td>
<td>
<p>A vector of column numbers with weights for each variable. Its length must be equal to the number of columns in trait. Only used if axes &gt; 0 and if trait is not a dist object.</p>
</td></tr>
<tr><td><code id="hyper.build_+3A_axes">axes</code></td>
<td>
<p>If 0, no transformation of data is done.
If 0 &lt; axes &lt;= 1 a PCoA is done with Gower/euclidean distances and as many axes as needed to achieve this proportion of variance explained are selected.
If axes &gt; 1 these many axes are selected.</p>
</td></tr>
<tr><td><code id="hyper.build_+3A_convert">convert</code></td>
<td>
<p>A vector of column numbers, usually categorical variables, to be converted to dummy variables. Only used if axes &gt; 0 and if trait is not a dist object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hyperspace can be constructed with the given data or data can be transformed using PCoA after traits are dummyfied (if needed) and standardized (always).
Gower distance (Pavoine et al. 2009) allows continuous, ordinal, categorical or binary variables, with possible weighting.
NAs are allowed as long as each pair of species has at least one trait value in common.
If convert is given the algorithm will convert these column numbers to dummy variables. Otherwise it will convert all columns with factors or characters as values.
Note that each community should have at least 3 species and more species than traits or axes (if axes &gt; 0) to build convex hull hypervolumes.
Transformation of traits is recommended if (Carvalho &amp; Cardoso, 2020):
1) Some traits are not continuous;
2) Some traits are correlated; or
3) There are less species than traits + 1, in which case the number of axes should be smaller.
</p>


<h3>Value</h3>

<p>A matrix with the coordinates of each species in hyperspace.
</p>


<h3>References</h3>

<p>Carvalho, J.C. &amp; Cardoso, P. (2020) Decomposing the causes for niche differentiation between species using hypervolumes. Frontiers in Ecology and Evolution, 8: 243.
</p>
<p>Pavoine et al. (2009) On the challenge of treating various types of variables: application for improving the measurement of functional diversity. Oikos, 118: 391-402.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = c("SpA", "SpB", "SpC", "SpD", "SpE")

hs = hyper.build(trait, weight = c(1,2), axes = 2)
plot(hs)
</code></pre>

<hr>
<h2 id='hyper.quality'>Quality of hyperspace.</h2><span id='topic+hyper.quality'></span>

<h3>Description</h3>

<p>Assess the quality of a functional hyperspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper.quality(distance, hyper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyper.quality_+3A_distance">distance</code></td>
<td>
<p>A dist object representing the initial distances between species.</p>
</td></tr>
<tr><td><code id="hyper.quality_+3A_hyper">hyper</code></td>
<td>
<p>A matrix with coordinates data from function hyper.build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used for any representation using hyperspaces, including convex hull and kernel-density hypervolumes. The algorithm calculates the inverse of the squared deviation between initial and euclidean distances (Maire et al. 2015) after standardization of all values between 0 and 1 for simplicity of interpretation. A value of 1 corresponds to maximum quality of the functional representation. A value of 0 corresponds to the expected value for an hyperspace where all distances between species are 1.
</p>


<h3>Value</h3>

<p>A single value of quality.
</p>


<h3>References</h3>

<p>Maire et al. (2015) How many dimensions are needed to accurately assess functional diversity? A pragmatic approach for assessing the quality of functional spaces. Global Ecology and Biogeography, 24: 728:740.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trait = data.frame(body = c(1,2,3,4,4), beak = c(1,1,1,1,2))
distance = gower(trait)

hyper = hyper.build(trait, axes = 2)
hyper.quality(distance, hyper)

hyper = hyper.build(trait, axes = 0)
hyper.quality(distance, hyper)
</code></pre>

<hr>
<h2 id='iaor'>Interspecific abundance-occupancy relationship (IAOR).</h2><span id='topic+iaor'></span>

<h3>Description</h3>

<p>Fits and compares several of the most supported models for the IAOR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iaor(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iaor_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix with abundance values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locally abundant species tend to be widespread while locally rare species tend to be narrowly distributed.
That is, for a given species assemblage, there is a positive interspecific abundance-occupancy relationship (Brown 1984).
This function compares some of the most commonly used and theoretically or empirically suported models (Nachman 1981; He &amp; Gaston 2000; Cardoso et al. 2020).
</p>


<h3>Value</h3>

<p>A matrix with the different model parameters and explanatory power.
</p>


<h3>References</h3>

<p>Brown, J.H. (1984) On the relationship between abundance and distribution of species. American Naturalist, 124: 255-279.
</p>
<p>Cardoso, P., Branco, V.V., Borges, P.A.V., Carvalho, J.C., Rigal, F., Gabriel, R., Mammola, S., Cascalho, J. &amp; Correia, L. (2020) Automated discovery of relationships, models and principles in ecology. Frontiers in Ecology and Evolution, 8: 530135.
</p>
<p>He, F.L. &amp; Gaston, K.J. (2000) Estimating species abundance from occurrence. American Naturalist, 156: 553-559.
</p>
<p>Nachman, G. (1981) A mathematical model of the functional relationship between density and spatial distribution of a population. Journal of Animal Ecology, 50: 453-460.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(4,3,2,1,5,4,3,2,3,2,1,0,6,3,0,0,0,0,0,0), nrow = 5, ncol = 4, byrow = TRUE)
iaor(comm)
</code></pre>

<hr>
<h2 id='kernel.alpha'>Alpha diversity using kernel density hypervolumes.</h2><span id='topic+kernel.alpha'></span>

<h3>Description</h3>

<p>Estimation of functional richness of one or multiple sites, based on n-dimensional hypervolumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.alpha(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.alpha_+3A_comm">comm</code></td>
<td>
<p>A 'Hypervolume' or 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the functional richness (alpha FD) of one or more communities using kernel density hypervolumes, as implemented in Blonder et al. (2014, 2018).
Functional richness is expressed as the total volume of the n-dimensional hypervolume (Mammola &amp; Cardoso, 2020). Note that the hypervolume is dimensionless, and that only hypervolumes with the same number of dimensions can be compared in terms of functional richness.
Given that the density and positions of stochastic points in the hypervolume are probabilistic, the functional richness of the trait space will intimately depend on the quality of input hypervolumes (details in Mammola &amp; Cardoso, 2020).
</p>


<h3>Value</h3>

<p>A value or vector of alpha diversity values for each site.
</p>


<h3>References</h3>

<p>Blonder, B., Lamanna, C., Violle, C. &amp; Enquist, B.J. (2014) The n-dimensional hypervolume. Global Ecology and Biogeography, 23: 595-609.
</p>
<p>Blonder, B., Morrow, C.B., Maitner, B., Harris, D.J., Lamanna, C., Violle, C., ... &amp; Kerkhoff, A.J. (2018) New approaches for delineating n-dimensional hypervolumes. Methods in Ecology and Evolution, 9: 305-319.
</p>
<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution, 11: 986-995.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(1,3,0,5,3), c(3,2,5,0,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
kernel.alpha(hv)
hvlist = kernel.build(comm, trait, axes = 0.8)
kernel.alpha(hvlist)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.beta'>Beta diversity partitioning using kernel density hypervolumes.</h2><span id='topic+kernel.beta'></span>

<h3>Description</h3>

<p>Pairwise beta diversity partitioning into replacement and net difference in amplitude components of n-dimensional hypervolumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.beta(comm, func = "jaccard", comp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.beta_+3A_comm">comm</code></td>
<td>
<p>A 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
<tr><td><code id="kernel.beta_+3A_func">func</code></td>
<td>
<p>Partial match indicating whether the Jaccard or Soerensen family of beta diversity measures should be used.  If not specified, default is Jaccard.</p>
</td></tr>
<tr><td><code id="kernel.beta_+3A_comp">comp</code></td>
<td>
<p>Boolean indicating whether beta diversity components (shared and unique fractions) should be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a pairwise decomposition of the overall differentiation among kernel hypervolumes into two components: the replacement (shifts) of space between hypervolumes and net differences between the amount of space enclosed by each hypervolume.
The beta diversity measures used here follow the FD partitioning framework developed by Carvalho &amp; Cardoso (2020), where Btotal = Breplacement + Brichness. Beta diversity ranges from 0 (when hypervolumes are identical) to 1 (when hypervolumes are fully dissimilar).
See Carvalho &amp; Cardoso (2020) and Mammola &amp; Cardoso (2020) for the full formulas of beta diversity used here.
</p>


<h3>Value</h3>

<p>Three pairwise distance matrices, one per each of the three beta diversity components. If comp = TRUE also three distance matrices with beta diversity components.
</p>


<h3>References</h3>

<p>Carvalho, J.C. &amp; Cardoso, P. (2020) Decomposing the causes for niche differentiation between species using hypervolumes. Frontiers in Ecology and Evolution, 8: 243.
</p>
<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution, 11: 986-995.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm &lt;- rbind(c(1,1,1,1,1), c(1,1,1,1,1), c(0,0,1,1,1),c(0,0,1,1,1))
colnames(comm) = c("SpA","SpB","SpC","SpD", "SpE")
rownames(comm) = c("Site 1","Site 2","Site 3","Site 4")

trait &lt;- cbind(c(2.2,4.4,6.1,8.3,3),c(0.5,1,0.5,0.4,4),c(0.7,1.2,0.5,0.4,5),c(0.7,2.2,0.5,0.3,6))
colnames(trait) = c("Trait 1","Trait 2","Trait 3","Trait 4")
rownames(trait) = colnames(comm)

hvlist = kernel.build(comm, trait)
kernel.beta(hvlist)
hvlist = kernel.build(comm, trait, axes = 0.9)
kernel.beta(hvlist, comp = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.beta.evenness'>Functional beta diversity evenness using kernel density hypervolumes.</h2><span id='topic+kernel.beta.evenness'></span>

<h3>Description</h3>

<p>Difference of evenness between pairs of sites, measuring the regularity of stochastic points distribution within the total functional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.beta.evenness(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.beta.evenness_+3A_comm">comm</code></td>
<td>
<p>A 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This measure is simply the pairwise difference of evenness calculated based on the functional evenness (Mason et al., 2005) of a n-dimensional hypervolume, namely the regularity of stochastic points distribution within the total trait space (Mammola &amp; Cardoso, 2020).
Evenness is calculated as the overlap between the observed hypervolume and a theoretical hypervolume where traits and abundances are evenly distributed within the range of their values (Carmona et al., 2016, 2019).
</p>


<h3>Value</h3>

<p>Distance matrix between sites.
</p>


<h3>References</h3>

<p>Carmona, C.P., de Bello, F., Mason, N.W.H. &amp; Leps, J. (2016) Traits without borders: integrating functional diversity across scales. Trends in Ecology and Evolution, 31: 382-394.
</p>
<p>Carmona, C.P., de Bello, F., Mason, N.W.H. &amp; Leps, J. (2019) Trait probability density (TPD): measuring functional diversity across scales based on TPD with R. Ecology, 100: e02876.
</p>
<p>Mason, N.W.H., Mouillot, D., Lee, W.G. &amp; Wilson, J.B. (2005) Functional richness, functional evenness and functional divergence: the primary components of functional diversity. Oikos, 111: 112-118.
</p>
<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution, 11: 986-995.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm &lt;- rbind(c(1,1,1,1,1), c(1,1,1,1,1), c(0,0,1,1,1),c(0,0,1,1,1))
colnames(comm) = c("SpA","SpB","SpC","SpD", "SpE")
rownames(comm) = c("Site 1","Site 2","Site 3","Site 4")

trait &lt;- cbind(c(2.2,4.4,6.1,8.3,3),c(0.5,1,0.5,0.4,4),c(0.7,1.2,0.5,0.4,5),c(0.7,2.2,0.5,0.3,6))
colnames(trait) = c("Trait 1","Trait 2","Trait 3","Trait 4")
rownames(trait) = colnames(comm)

hvlist = kernel.build(comm, trait)
kernel.beta.evenness(hvlist)
hvlist = kernel.build(comm, trait, axes = 0.9)
kernel.beta.evenness(hvlist)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.build'>Build kernel hypervolumes.</h2><span id='topic+kernel.build'></span>

<h3>Description</h3>

<p>Builds kernel density hypervolumes from trait data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.build(
  comm,
  trait,
  distance = "gower",
  method.hv = "gaussian",
  abund = TRUE,
  weight = NULL,
  axes = 0,
  convert = NULL,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.build_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, data.frame or vector, with incidence or abundance data about the species in the community.</p>
</td></tr>
<tr><td><code id="kernel.build_+3A_trait">trait</code></td>
<td>
<p>A species x traits or axes matrix or data.frame (often from hyper.build) or, alternatively, a dist object.</p>
</td></tr>
<tr><td><code id="kernel.build_+3A_distance">distance</code></td>
<td>
<p>One of &quot;gower&quot; or &quot;euclidean&quot;. Not used if trait is a dist object.</p>
</td></tr>
<tr><td><code id="kernel.build_+3A_method.hv">method.hv</code></td>
<td>
<p>Method for constructing the 'Hypervolume' object. One of &quot;gaussian&quot; (Gaussian kernel density estimation, default), &quot;box&quot; (box kernel density estimation), or &quot;svm&quot; (one-class support vector machine). See respective functions of the hypervolume R package for details.</p>
</td></tr>
<tr><td><code id="kernel.build_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used as weights in hypervolume construction. Only works if method.hv = &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="kernel.build_+3A_weight">weight</code></td>
<td>
<p>A vector of column numbers with weights for each variable. Its length must be equal to the number of columns in trait. Only used if axes &gt; 0 and if trait is not a dist object.</p>
</td></tr>
<tr><td><code id="kernel.build_+3A_axes">axes</code></td>
<td>
<p>If 0, no transformation of data is done.
If 0 &lt; axes &lt;= 1 a PCoA is done with Gower/euclidean distances and as many axes as needed to achieve this proportion of variance explained are selected.
If axes &gt; 1 these many axes are selected.</p>
</td></tr>
<tr><td><code id="kernel.build_+3A_convert">convert</code></td>
<td>
<p>A vector of column numbers, usually categorical variables, to be converted to dummy variables. Only used if axes &gt; 0 and if trait is not a dist object.</p>
</td></tr>
<tr><td><code id="kernel.build_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used in parallel processing. If = 0 all available cores are used. Beware that multicore for Windows is not optimized yet and it often takes longer than single core.</p>
</td></tr>
<tr><td><code id="kernel.build_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to hypervolume::hypervolume</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hypervolumes can be constructed with the given data or data can be transformed using PCoA after traits are dummyfied (if needed) and standardized (always).
Beware that if transformations are required, all communities to be compared should be built simultaneously to guarantee comparability. In such case, one might want to first run hyper.build and use the resulting data in different runs of kernel.build.
See function hyper.build for more details.
</p>


<h3>Value</h3>

<p>A 'Hypervolume' or 'HypervolumeList', representing the hypervolumes of each community.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(1,1,0,5,1), c(3,2,5,0,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site1", "Site2")

trait = data.frame(body = c(1,2,3,1,2), beak = c(1,2,3,2,1))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
plot(hv)
hvlist = kernel.build(comm, trait, abund = FALSE, cores = 2)
plot(hvlist)
hvlist = kernel.build(comm, trait, method.hv = "box", weight = c(1,2), axes = 2)
plot(hvlist)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.contribution'>Contribution of each observation to the kernel density hypervolume.</h2><span id='topic+kernel.contribution'></span>

<h3>Description</h3>

<p>Contribution of each species or individual to the total volume of one or more kernel hypervolumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.contribution(comm, func = "neighbor", relative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.contribution_+3A_comm">comm</code></td>
<td>
<p>A 'Hypervolume' or 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
<tr><td><code id="kernel.contribution_+3A_func">func</code></td>
<td>
<p>Calculate contribution using either closest &quot;neighbor&quot; or leave &quot;one out&quot; approach.</p>
</td></tr>
<tr><td><code id="kernel.contribution_+3A_relative">relative</code></td>
<td>
<p>A boolean (T/F) indicating whether contribution should be relative to total FD (proportional contribution per individual or species). If FALSE, the sum of contributions for each site is equal to total FD, if TRUE it is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contribution is a measure of functional rarity (sensu Violle et al., 2017; Carmona et al., 2017) that allows to map the contribution of each observation to the richness components of FD (Mammola &amp; Cardoso, 2020).
If using func = &quot;neighbor&quot;, each random point will be attributed to the closest species. The contribution of each species will be proportional to the number of its points. The sum of contributions of all species is equal to total richness.
Note that the contribution of a species or individual can be negative if leave-one-out approach is taken, if the removal of an observation increases the total volume (see Figure 2d in Mammola &amp; Cardoso 2020).  
This might happen, although not always, in cases when the presence of a given species decreases the average distance between all the species in the community, i.e., when a given species is close to the &quot;average&quot; species of that community, making that community less diverse in some sense (Mammola &amp; Cardoso, 2020).
</p>


<h3>Value</h3>

<p>A matrix with the contribution values of each species or individual for each site.
</p>


<h3>References</h3>

<p>Carmona, C.P., de Bello, F., Sasaki, T., Uchida, K. &amp; Partel, M. (2017) Towards a common toolbox for rarity: A response to Violle et al. Trends in Ecology and Evolution, 32(12): 889-891.
</p>
<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution, 11: 986-995.
</p>
<p>Violle, C., Thuiller, W., Mouquet, N., Munoz, F., Kraft, N.J.B., Cadotte, M.W., ... &amp; Mouillot, D. (2017) Functional rarity: The ecology of outliers. Trends in Ecology and Evolution, 32: 356-367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(1,3,0,5,3), c(3,2,5,1,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
kernel.contribution(hv)
hvlist = kernel.build(comm, trait, axes = 2)
kernel.contribution(hvlist)
kernel.contribution(hvlist, relative = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.dispersion'>Functional dispersion of kernel density hypervolumes.</h2><span id='topic+kernel.dispersion'></span>

<h3>Description</h3>

<p>Average distance to centroid or dissimilarity between random points within the boundaries of the kernel density hypervolume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.dispersion(comm, func = "dissimilarity", frac = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.dispersion_+3A_comm">comm</code></td>
<td>
<p>A 'Hypervolume' or 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
<tr><td><code id="kernel.dispersion_+3A_func">func</code></td>
<td>
<p>Function for calculating dispersion. One of 'divergence', 'dissimilarity' or 'regression'.</p>
</td></tr>
<tr><td><code id="kernel.dispersion_+3A_frac">frac</code></td>
<td>
<p>A value between 0.01 and 1, indicating the fraction of random points to be used. Default is 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates dispersion either: i) as the average distance between stochastic points within the kernel density hypervolume and the centroid of these points (divergence; Laliberte &amp; Legendre, 2010; see also Carmona et al., 2019); ii) as the average distance between all points (dissimilarity, see also function BAT::dispersion); or iii) as the average distance between stochastic points within the kernel density hypervolume and a regression line fitted through the points.
The number of stochastic points is controlled by the 'frac' parameter (increase this number for less deviation in the estimation).
</p>


<h3>Value</h3>

<p>A value or vector of dispersion values for each site.
</p>


<h3>References</h3>

<p>Carmona, C.P., de Bello, F., Mason, N.W.H. &amp; Leps, J. (2019) Trait probability density (TPD): measuring functional diversity across scales based on TPD with R. Ecology, 100: e02876.
</p>
<p>Laliberte, E. &amp; Legendre, P. (2010) A distance-based framework for measuring functional diversity from multiple traits. Ecology 91: 299-305.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(1,3,0,5,3), c(3,2,5,1,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
kernel.dispersion(hv)
hvlist = kernel.build(comm, trait, axes = 2)
kernel.dispersion(hvlist)
kernel.dispersion(hvlist, func = "divergence")

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.evenness'>Functional evenness of kernel density hypervolumes.</h2><span id='topic+kernel.evenness'></span>

<h3>Description</h3>

<p>Functional evenness of a community, measuring the regularity of stochastic points distribution within the total functional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.evenness(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.evenness_+3A_comm">comm</code></td>
<td>
<p>A 'Hypervolume' or 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function measures the functional evenness (Mason et al., 2005) of a n-dimensional hypervolume, namely the regularity of stochastic points distribution within the total trait space (Mammola &amp; Cardoso, 2020).
Evenness is calculated as the overlap between the observed hypervolume and a theoretical hypervolume where traits and abundances are evenly distributed within the range of their values (Carmona et al., 2016, 2019).
</p>


<h3>Value</h3>

<p>A value or vector of evenness values for each site.
</p>


<h3>References</h3>

<p>Carmona, C.P., de Bello, F., Mason, N.W.H. &amp; Leps, J. (2016) Traits without borders: integrating functional diversity across scales. Trends in Ecology and Evolution, 31: 382-394.
</p>
<p>Carmona, C.P., de Bello, F., Mason, N.W.H. &amp; Leps, J. (2019) Trait probability density (TPD): measuring functional diversity across scales based on TPD with R. Ecology, 100: e02876.
</p>
<p>Mason, N.W.H., Mouillot, D., Lee, W.G. &amp; Wilson, J.B. (2005) Functional richness, functional evenness and functional divergence: the primary components of functional diversity. Oikos, 111: 112-118.
</p>
<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution, 11: 986-995.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(100,3,0,5,3), c(3,2,5,1,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
kernel.evenness(hv)
hv = kernel.build(comm[1,], trait, abund = FALSE)
kernel.evenness(hv)
hvlist = kernel.build(comm, trait, axes = 2)
kernel.evenness(hvlist)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.evenness.contribution'>Contribution of each observation to the evenness of a kernel density hypervolume.</h2><span id='topic+kernel.evenness.contribution'></span>

<h3>Description</h3>

<p>Contribution of each species or individual to the evenness of one or more kernel hypervolumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.evenness.contribution(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.evenness.contribution_+3A_comm">comm</code></td>
<td>
<p>A 'Hypervolume' or 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contribution of each observation (species or individual) to the total evenness of a kernel hypervolume. Contribution to evenness is calculated as the difference in evenness between the total hypervolume and a second hypervolume lacking this specific observation (i.e., leave-one-out approach; Mammola &amp; Cardoso, 2020). 
Note that the contribution of a species or individual can be negative, if the removal of an observation increases the total evenness.
</p>


<h3>Value</h3>

<p>A vector or matrix with the contribution values of each species or individual for each community or species respectively.
</p>


<h3>References</h3>

<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution, 11: 986-995.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(100,3,0,5,3), c(3,2,5,1,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
kernel.evenness.contribution(hv)
hvlist = kernel.build(comm, trait)
kernel.evenness.contribution(hvlist)
hvlist = kernel.build(comm, trait, axes = 0.8)
kernel.evenness.contribution(hvlist)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.gamma'>Gamma diversity using kernel density hypervolumes.</h2><span id='topic+kernel.gamma'></span>

<h3>Description</h3>

<p>Estimation of functional richness of multiple sites, based on n-dimensional hypervolumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.gamma(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.gamma_+3A_comm">comm</code></td>
<td>
<p>A 'Hypervolume' or 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the functional richness (gamma FD) of multiple communities using kernel density hypervolumes, as implemented in Blonder et al. (2014, 2018).
Functional richness is expressed as the total volume of the n-dimensional hypervolume (Mammola &amp; Cardoso, 2020). Note that the hypervolume is dimensionless, and that only hypervolumes with the same number of dimensions can be compared in terms of functional richness.
Given that the density and positions of stochastic points in the hypervolume are probabilistic, the functional richness of the trait space will intimately depend on the quality of input hypervolumes (details in Mammola &amp; Cardoso, 2020).
</p>


<h3>Value</h3>

<p>A single value of gamma.
</p>


<h3>References</h3>

<p>Blonder, B., Lamanna, C., Violle, C. &amp; Enquist, B.J. (2014) The n-dimensional hypervolume. Global Ecology and Biogeography, 23: 595-609.
</p>
<p>Blonder, B., Morrow, C.B., Maitner, B., Harris, D.J., Lamanna, C., Violle, C., ... &amp; Kerkhoff, A.J. (2018) New approaches for delineating n-dimensional hypervolumes. Methods in Ecology and Evolution, 9: 305-319.
</p>
<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution, 11: 986-995.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(1,3,2,2,2), c(0,0,0,2,2))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,5), beak = c(1,2,3,4,5))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
kernel.alpha(hv)
kernel.gamma(hv)
hvlist = kernel.build(comm, trait)
kernel.alpha(hvlist)
kernel.gamma(hvlist)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.hotspots'>Hotspots in hypervolumes.</h2><span id='topic+kernel.hotspots'></span>

<h3>Description</h3>

<p>Identify hotspots in kernel density hypervolumes based on minimum volume needed to cover a given proportion of random points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.hotspots(comm, prop = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.hotspots_+3A_comm">comm</code></td>
<td>
<p>A 'Hypervolume' or 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
<tr><td><code id="kernel.hotspots_+3A_prop">prop</code></td>
<td>
<p>Proportion of random points to be included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the hotspots of one or more communities using kernel density hypervolumes as in Carmona et al. (2021).
</p>


<h3>Value</h3>

<p>A 'Hypervolume' or 'HypervolumeList' with the hotspots of each site.
</p>


<h3>References</h3>

<p>Carmona, C.P., et al. (2021) Erosion of global functional diversity across the tree of life. Science Advances, 7: eabf2675. DOI: 10.1126/sciadv.abf2675
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(1,3,0,5,3), c(3,2,5,0,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
plot(hv)
kernel.alpha(hv)

hot = kernel.hotspots(hv, 0.5)
plot(hot)
kernel.alpha(hot)

hvlist = kernel.build(comm, trait)
hot = kernel.hotspots(hvlist, 0.1)
kernel.alpha(hot)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.originality'>Functional originality of observations in kernel density hypervolumes.</h2><span id='topic+kernel.originality'></span>

<h3>Description</h3>

<p>Average dissimilarity between a species or individual and a sample of random points within the boundaries of the n-dimensional hypervolume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.originality(comm, frac = 0.1, relative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.originality_+3A_comm">comm</code></td>
<td>
<p>A 'Hypervolume' or 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
<tr><td><code id="kernel.originality_+3A_frac">frac</code></td>
<td>
<p>A value between 0.01 and 1, indicating the fraction of random points to be used in the estimation of originality. Default is 0.1.</p>
</td></tr>
<tr><td><code id="kernel.originality_+3A_relative">relative</code></td>
<td>
<p>A boolean (T/F) indicating whether originality should be relative to the most original species in the community.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A measure of the originality (sensu Pavoine et al., 2005) of each observation (species or individuals) used to construct the n-dimensional hypervolume. In a probabilistic hypervolume, originality is calculated as the average distance between each observation to a sample of stochastic points within the boundaries of the n-dimensional hypervolume (Mammola &amp; Cardoso, 2020).
Originality is a measure of functional rarity (sensu Violle et al., 2017; Carmona et al., 2017) that allows to map the contribution of each observation to the divergence components of FD (Mammola &amp; Cardoso, 2020).
The number of sample points to be used in the estimation of the originality is controlled by the frac parameter. Increase frac for less deviation in the estimation, but mind that computation time also increases.
</p>


<h3>Value</h3>

<p>A vector or matrix with the originality values of each species or individual in each site.
</p>


<h3>References</h3>

<p>Carmona, C.P., de Bello, F., Sasaki, T., Uchida, K. &amp; Partel, M. (2017) Towards a common toolbox for rarity: A response to Violle et al. Trends in Ecology and Evolution, 32: 889-891.
</p>
<p>Mammola, S. &amp; Cardoso, P. (2020) Functional diversity metrics using kernel density n-dimensional hypervolumes. Methods in Ecology and Evolution, 11: 986-995.
</p>
<p>Pavoine, S., Ollier, S. &amp; Dufour, A.-B. (2005) Is the originality of a species measurable? Ecology Letters, 8: 579-586.
</p>
<p>Violle, C., Thuiller, W., Mouquet, N., Munoz, F., Kraft, N.J.B., Cadotte, M.W., ... &amp; Mouillot, D. (2017) Functional rarity: the ecology of outliers. Trends in Ecology and Evolution, 32: 356-367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(1,3,0,5,3), c(3,2,5,1,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = kernel.build(comm[1,], trait)
kernel.originality(hv)
hvlist = kernel.build(comm, trait)
kernel.originality(hvlist)
kernel.originality(hvlist, relative = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.sad'>Species-abundance distribution (SAD) using kernel density hypervolumes.</h2><span id='topic+kernel.sad'></span>

<h3>Description</h3>

<p>Fits the SAD to community abundance data based on n-dimensional hypervolumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.sad(comm, octaves = TRUE, scale = FALSE, raref = 0, runs = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.sad_+3A_comm">comm</code></td>
<td>
<p>A 'Hypervolume' or 'HypervolumeList' object necessarily built using function kernel.build.</p>
</td></tr>
<tr><td><code id="kernel.sad_+3A_octaves">octaves</code></td>
<td>
<p>a boolean indicating whether octaves should be calculated.</p>
</td></tr>
<tr><td><code id="kernel.sad_+3A_scale">scale</code></td>
<td>
<p>scale y-axis to sum 1.</p>
</td></tr>
<tr><td><code id="kernel.sad_+3A_raref">raref</code></td>
<td>
<p>An integer specifying the number of individuals for rarefaction (individual based).
If raref &lt; 1 no rarefaction is made.
If raref = 1 rarefaction is made by the minimum abundance among all sites.
If raref &gt; 1 rarefaction is made by the abundance indicated.
If not specified, default is 0.</p>
</td></tr>
<tr><td><code id="kernel.sad_+3A_runs">runs</code></td>
<td>
<p>Number of resampling runs for rarefaction. If not specified, default is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Species Abundance Distribution describes the commonness and rarity in ecological systems. It was recently expanded to accomodate phylegenetic and functional differences between species (Matthews et al., subm.). Classes defined as n = 1, 2-3, 4-7, 8-15, .... Rarefaction allows comparison of sites with different total abundances.
</p>


<h3>Value</h3>

<p>A vector or matrix with the different values per class per community.
</p>


<h3>References</h3>

<p>Matthews et al. (subm.) Phylogenetic and functional dimensions of the species abundance distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm = rbind(c(1,3,0,5,3), c(3,2,5,1,0))
colnames(comm) = c("SpA", "SpB", "SpC", "SpD", "SpE")
rownames(comm) = c("Site 1", "Site 2")

trait = data.frame(body = c(1,2,3,4,4), beak = c(1,5,4,1,2))
rownames(trait) = colnames(comm)

hv = kernel.build(comm, trait)
kernel.sad(hv, scale = TRUE)
kernel.sad(hv, octaves = FALSE)
kernel.sad(hv, raref = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel.similarity'>Pairwise similarity among kernel density hypervolumes.</h2><span id='topic+kernel.similarity'></span>

<h3>Description</h3>

<p>Calculate pairwise distance metrics (centroid and minimum distance) and similarity indices (Intersection, Jaccard, Soerensen-Dice) among n-dimensional hypervolumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.similarity(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.similarity_+3A_comm">comm</code></td>
<td>
<p>A 'HypervolumeList' object, preferably built using function kernel.build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a pairwise comparison between kernel density hypervolumes of multiple species or communities, based on the distance and similarity metrics implemented in hypervolume R package (Blonder et al., 2014, 2018).
See Mammola (2019) for a description of the different indices, and a comparison between their performance. Note that computation time largely depends on the number of 'Hypervolume' objects in the list, and scales almost exponentially with the number of hypervolume axes.
</p>


<h3>Value</h3>

<p>Five pairwise distance matrices, one per each of the distance and similarity indices (in order: distance between centroids, minimum distance, Jaccard overlap, Soerensen-Dice overlap, and Intersection among hypervolumes).
</p>


<h3>References</h3>

<p>Blonder, B., Lamanna, C., Violle, C. &amp; Enquist, B.J. (2014) The n-dimensional hypervolume. Global Ecology and Biogeography, 23: 595-609.
</p>
<p>Blonder, B., Morrow, C.B., Maitner, B., Harris, D.J., Lamanna, C., Violle, C., ... &amp; Kerkhoff, A.J. (2018) New approaches for delineating n-dimensional hypervolumes. Methods in Ecology and Evolution, 9: 305-319.
</p>
<p>Mammola, S. (2019) Assessing similarity of n-dimensional hypervolumes: Which metric to use?. Journal of Biogeography, 46: 2012-2023.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comm &lt;- rbind(c(1,1,1,1,1), c(1,1,1,1,1), c(0,0,1,1,1),c(0,0,1,1,1))
colnames(comm) = c("SpA","SpB","SpC","SpD", "SpE")
rownames(comm) = c("Site 1","Site 2","Site 3","Site 4")

trait &lt;- cbind(c(2.2,4.4,6.1,8.3,3),c(0.5,1,0.5,0.4,4),c(0.7,1.2,0.5,0.4,5),c(0.7,2.2,0.5,0.3,6))
colnames(trait) = c("Trait 1","Trait 2","Trait 3","Trait 4")
rownames(trait) = colnames(comm)

hvlist = kernel.build(comm, trait)
kernel.similarity(hvlist)
hvlist = kernel.build(comm, trait, axes = 0.9)
kernel.similarity(hvlist)

## End(Not run)
</code></pre>

<hr>
<h2 id='linnean'>Create Linnean tree.</h2><span id='topic+linnean'></span>

<h3>Description</h3>

<p>Creates a Linnean tree from taxonomic hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linnean(taxa, distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linnean_+3A_taxa">taxa</code></td>
<td>
<p>A taxonomic matrix with columns ordered according to linnean hierarchy starting with the highest.</p>
</td></tr>
<tr><td><code id="linnean_+3A_distance">distance</code></td>
<td>
<p>A vector with distances between levels starting with the highest. If not provided distances will be evenly distributed from 1 to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An hclust with all species.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>family &lt;- c("Nemesiidae", "Nemesiidae", "Zodariidae", "Zodariidae")
genus &lt;- c("Iberesia", "Nemesia", "Zodarion", "Zodarion")
species &lt;- c("Imachadoi", "Nungoliant", "Zatlanticum", "Zlusitanicum")
taxa &lt;- cbind(family, genus, species)
par(mfrow = c(1, 2))
plot(linnean(taxa))
plot(linnean(taxa, c(2, 0.5, 0.3)))
</code></pre>

<hr>
<h2 id='mixture'>Mixture model.</h2><span id='topic+mixture'></span>

<h3>Description</h3>

<p>Mixture model by Hilario et al. subm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture(
  comm,
  tree,
  q = 0,
  precision = 0.1,
  replace = TRUE,
  alpha = 0.05,
  param = TRUE,
  runs = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixture_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with abundance data.</p>
</td></tr>
<tr><td><code id="mixture_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree. Will only be used if q = 0, in which case phylogenetic or functional richness are calculated instead of species richness.</p>
</td></tr>
<tr><td><code id="mixture_+3A_q">q</code></td>
<td>
<p>Hill number order: q(0) = species richness, q(1) ~ Shannon diversity, q(2) ~ Simpson diversity.</p>
</td></tr>
<tr><td><code id="mixture_+3A_precision">precision</code></td>
<td>
<p>Precision of the proportion of each habitat type to be tested.</p>
</td></tr>
<tr><td><code id="mixture_+3A_replace">replace</code></td>
<td>
<p>Boolean indicating whether simulations should be with or without (default) replacement.</p>
</td></tr>
<tr><td><code id="mixture_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for significance level.</p>
</td></tr>
<tr><td><code id="mixture_+3A_param">param</code></td>
<td>
<p>Value is calculated with parametric or non-parametric method. The later is preferable when distribution of estimated values is not normally distributed.</p>
</td></tr>
<tr><td><code id="mixture_+3A_runs">runs</code></td>
<td>
<p>Number of runs for the bootstrap providing confidence limits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tool to assess biodiversity in landscapes containing varying proportions of n environments.
</p>


<h3>Value</h3>

<p>A matrix with expected diversity at each proportion of different habitats in a landscape.
</p>


<h3>Author(s)</h3>

<p>Renato Hilario &amp; Pedro Cardoso
</p>


<h3>References</h3>

<p>Chao et al. (2019) Proportional mixture of two rarefaction/extrapolation curves to forecast biodiversity changes under landscape transformation. Ecology Letters, 22: 1913-1922. https://doi.org/10.1111/ele.13322
</p>
<p>Hilario et al. (subm.) Function ‘mixture’: A new tool to quantify biodiversity change under landscape transformation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(20,20,20,20,20,9,1,0,0,0,1,1,1,1,1), nrow = 3, ncol = 5, byrow = TRUE)
tree = hclust(dist(1:5))

hill(comm)
alpha(comm, tree)

mixture(comm, runs = 10)
mixture(comm, tree, replace = TRUE, runs = 10)
</code></pre>

<hr>
<h2 id='optim.alpha'>Optimization of alpha diversity sampling protocols.</h2><span id='topic+optim.alpha'></span>

<h3>Description</h3>

<p>Optimization of alpha diversity sampling protocols when different methods and multiple samples per method are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.alpha(comm, tree, methods, base, seq = FALSE, runs = 1000, prog = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.alpha_+3A_comm">comm</code></td>
<td>
<p>A samples x species x sites array, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="optim.alpha_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="optim.alpha_+3A_methods">methods</code></td>
<td>
<p>A data.frame with the method names (1st column), number of samples per method (2nd column), base cost per method (3rd column, those costs that are fixed once a method is decided), and sample cost per method (those costs that add with each sample of the method, 4th column). If the last two columns are not provided base = 0 and sample = 1. The order of methods must be the same as in comm and the sum of the samples must be the same as nrow(comm).</p>
</td></tr>
<tr><td><code id="optim.alpha_+3A_base">base</code></td>
<td>
<p>A vector defining a base protocol from which to build upon (complementarity analysis) (length must be equal to number of methods).</p>
</td></tr>
<tr><td><code id="optim.alpha_+3A_seq">seq</code></td>
<td>
<p>By default all combinations will be tested. If TRUE, a sequential approach will be taken, where methods are added based on the previous step. The method added will be the one providing the highest efficiency as quantified by the slope of the accumulation curve.</p>
</td></tr>
<tr><td><code id="optim.alpha_+3A_runs">runs</code></td>
<td>
<p>Number of random permutations to be made to the sample order. Default is 1000.</p>
</td></tr>
<tr><td><code id="optim.alpha_+3A_prog">prog</code></td>
<td>
<p>Present a text progress bar in the R console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often a combination of methods allows sampling maximum plot diversity with minimum effort, as it allows sampling different sub-communities, contrary to using single methods.
Cardoso (2009) proposed a way to optimize the number of samples per method when the target is to maximize sampled alpha diversity. It is applied here for TD, PD and FD, and for one or multiple sites simultaneously.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric).
</p>


<h3>Value</h3>

<p>A matrix of samples x methods (values being optimum number of samples per method). The last column is the average alpha diversity value, rescaled to 0-1 if made for several sites, where 1 is the true diversity of each site.
</p>


<h3>References</h3>

<p>Cardoso, P. (2009) Standardization and optimization of arthropod inventories - the case of Iberian spiders. Biodiversity and Conservation, 18, 3949-3962.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm1 &lt;- matrix(c(1,1,0,2,4,0,0,1,2,0,0,3), nrow = 4, ncol = 3, byrow = TRUE)
comm2 &lt;- matrix(c(2,2,0,3,1,0,0,0,5,0,0,2), nrow = 4, ncol = 3, byrow = TRUE)
comm &lt;- array(c(comm1, comm2), c(4,3,2))
colnames(comm) &lt;- c("Sp1","Sp2","Sp3")

methods &lt;- data.frame(method = c("Met1","Met2","Met3"),
           nSamples = c(1,2,1), fixcost = c(1,1,2), varCost = c(1,1,1))
tree &lt;- hclust(dist(c(1:3), method="euclidean"), method="average")
tree$labels &lt;- colnames(comm)

## Not run: 
  optim.alpha(comm,,methods)
  optim.alpha(comm,,methods, seq = TRUE)
  optim.alpha(comm, tree, methods)
  optim.alpha(comm,, methods = methods, seq = TRUE, base = c(0,1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='optim.alpha.stats'>Efficiency statistics for alpha-sampling.</h2><span id='topic+optim.alpha.stats'></span>

<h3>Description</h3>

<p>Average alpha diversity observed with a given number of samples per method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.alpha.stats(comm, tree, methods, samples, runs = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.alpha.stats_+3A_comm">comm</code></td>
<td>
<p>A samples x species x sites array, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="optim.alpha.stats_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="optim.alpha.stats_+3A_methods">methods</code></td>
<td>
<p>A data.frame with the method names (1st column) and number of samples per method (2nd column). The order of methods must be the same as in comm and the sum of the samples must be the same as nrow(comm).</p>
</td></tr>
<tr><td><code id="optim.alpha.stats_+3A_samples">samples</code></td>
<td>
<p>A vector with the number of samples per method to test.</p>
</td></tr>
<tr><td><code id="optim.alpha.stats_+3A_runs">runs</code></td>
<td>
<p>Number of random permutations to be made to the sample order. Default is 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different combinations of samples per method allow sampling different sub-communities.
This function allows knowing the average TD, PD or FD values for a given combination, for one or multiple sites simultaneously.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric).
</p>


<h3>Value</h3>

<p>A single average alpha diversity value. Rescaled to 0-1 if made for several sites, where 1 is the true diversity of each site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm1 &lt;- matrix(c(1,1,0,2,4,0,0,1,2,0,0,3), nrow = 4, ncol = 3, byrow = TRUE)
comm2 &lt;- matrix(c(2,2,0,3,1,0,0,0,5,0,0,2), nrow = 4, ncol = 3, byrow = TRUE)
comm &lt;- array(c(comm1, comm2), c(4,3,2))
colnames(comm) &lt;- c("Sp1","Sp2","Sp3")

tree &lt;- hclust(dist(c(1:3), method="euclidean"), method="average")
tree$labels &lt;- colnames(comm)

methods &lt;- data.frame(method = c("Met1","Met2","Met3"), nSamples = c(1,2,1))

optim.alpha.stats(comm,, methods, c(0,0,1))
optim.alpha.stats(comm, tree, methods, c(0,1,1), runs = 100)
</code></pre>

<hr>
<h2 id='optim.beta'>Optimization of beta diversity sampling protocols.</h2><span id='topic+optim.beta'></span>

<h3>Description</h3>

<p>Optimization of beta diversity sampling protocols when different methods and multiple samples per method are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.beta(
  comm,
  tree,
  methods,
  base,
  seq = FALSE,
  abund = TRUE,
  runs = 1000,
  prog = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.beta_+3A_comm">comm</code></td>
<td>
<p>A samples x species x sites array, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="optim.beta_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="optim.beta_+3A_methods">methods</code></td>
<td>
<p>A data.frame with the method names (1st column), number of samples per method (2nd column), base cost per method (3rd column, those costs that are fixed once a method is decided), and sample cost per method (those costs that add with each sample of the method, 4th column). If the last two columns are not provided base = 0 and sample = 1. The order of methods must be the same as in comm and the sum of the samples must be the same as nrow(comm).</p>
</td></tr>
<tr><td><code id="optim.beta_+3A_base">base</code></td>
<td>
<p>Allows defining a base mandatory protocol from which to build upon (complementarity analysis). It should be a vector with length = number of methods.</p>
</td></tr>
<tr><td><code id="optim.beta_+3A_seq">seq</code></td>
<td>
<p>By default all combinations will be tested. If TRUE, a sequential approach will be taken, where methods are added based on the previous step. The method added will be the one providing the highest efficiency as quantified by the slope of the accumulation curve.</p>
</td></tr>
<tr><td><code id="optim.beta_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used (TRUE) or converted to incidence (FALSE) before analysis.</p>
</td></tr>
<tr><td><code id="optim.beta_+3A_runs">runs</code></td>
<td>
<p>Number of random permutations to be made to the sample order. Default is 1000.</p>
</td></tr>
<tr><td><code id="optim.beta_+3A_prog">prog</code></td>
<td>
<p>Present a text progress bar in the R console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often, comparing differences between sites or the same site along time (i.e. measure beta diversity) it is not necessary to sample exhaustively. A minimum combination of samples targeting different sub-communities (that may behave differently) may be enough to perceive such differences, for example, for monitoring purposes.
Cardoso et al. (in prep.) introduce and differentiate the concepts of alpha-sampling and beta-sampling. While alpha-sampling optimization implies maximizing local diversity sampled (Cardoso 2009), beta-sampling optimization implies minimizing differences in beta diversity values between partially and completely sampled communities.
This function uses as beta diversity measures the Btotal, Brepl and Brich partitioning framework (Carvalho et al. 2012) and respective generalizations to PD and FD (Cardoso et al. 2014).
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric).
</p>


<h3>Value</h3>

<p>A matrix of samples x methods (values being optimum number of samples per method). The last column is precision = (1 - average absolute difference from real beta).
</p>


<h3>References</h3>

<p>Cardoso, P. (2009) Standardization and optimization of arthropod inventories - the case of Iberian spiders. Biodiversity and Conservation, 18, 3949-3962.
</p>
<p>Cardoso, P., Rigal, F., Carvalho, J.C., Fortelius, M., Borges, P.A.V., Podani, J. &amp; Schmera, D. (2014) Partitioning taxon, phylogenetic and functional beta diversity into replacement and richness difference components. Journal of Biogeography, 41, 749-761.
</p>
<p>Cardoso, P., et al. (in prep.) Optimal inventorying and monitoring of taxon, phylogenetic and functional diversity.
</p>
<p>Carvalho, J.C., Cardoso, P. &amp; Gomes, P. (2012) Determining the relative roles of species replacement and species richness differences in generating beta-diversity patterns. Global Ecology and Biogeography, 21, 760-771.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm1 &lt;- matrix(c(1,1,0,2,4,0,0,1,2,0,0,3), nrow = 4, ncol = 3, byrow = TRUE)
comm2 &lt;- matrix(c(2,2,0,3,1,0,0,0,5,0,0,2), nrow = 4, ncol = 3, byrow = TRUE)
comm3 &lt;- matrix(c(2,0,0,3,1,0,0,0,5,0,0,2), nrow = 4, ncol = 3, byrow = TRUE)
comm &lt;- array(c(comm1, comm2, comm3), c(4,3,3))
colnames(comm) &lt;- c("sp1","sp2","sp3")

methods &lt;- data.frame(method = c("Met1","Met2","Met3"),
           nSamples = c(1,2,1), fixcost = c(1,1,2), varCost = c(1,1,1))
tree &lt;- hclust(dist(c(1:3), method="euclidean"), method="average")
tree$labels &lt;- colnames(comm)

## Not run: 
  optim.beta(comm,,methods)
  optim.beta(comm,,methods, seq = TRUE)
  optim.beta(comm, tree, methods)
  optim.alpha(comm,, methods = methods, seq = TRUE, base = c(0,1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='optim.beta.stats'>Efficiency statistics for beta-sampling.</h2><span id='topic+optim.beta.stats'></span>

<h3>Description</h3>

<p>Average absolute difference between sampled and real beta diversity when using a given number of samples per method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.beta.stats(comm, tree, methods, samples, abund = TRUE, runs = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.beta.stats_+3A_comm">comm</code></td>
<td>
<p>A samples x species x sites array, with either abundance or incidence data.</p>
</td></tr>
<tr><td><code id="optim.beta.stats_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="optim.beta.stats_+3A_methods">methods</code></td>
<td>
<p>A data.frame with the method names (1st column) and number of samples per method (2nd column). The order of methods must be the same as in comm and the sum of the samples must be the same as nrow(comm).</p>
</td></tr>
<tr><td><code id="optim.beta.stats_+3A_samples">samples</code></td>
<td>
<p>A vector with the number of samples per method to test.</p>
</td></tr>
<tr><td><code id="optim.beta.stats_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used (TRUE) or converted to incidence (FALSE) before analysis.</p>
</td></tr>
<tr><td><code id="optim.beta.stats_+3A_runs">runs</code></td>
<td>
<p>Number of random permutations to be made to the sample order. Default is 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different combinations of samples per method allow sampling different sub-communities.
This function allows knowing the average absolute difference between sampled and real beta diversity for a given combination, for one or multiple sites simultaneously.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric).
</p>


<h3>Value</h3>

<p>A single precision value = (1 - average absolute beta diversity difference value).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm1 &lt;- matrix(c(1,1,0,2,4,0,0,1,2,0,0,3), nrow = 4, ncol = 3, byrow = TRUE)
comm2 &lt;- matrix(c(2,2,0,3,1,0,0,0,5,0,0,2), nrow = 4, ncol = 3, byrow = TRUE)
comm3 &lt;- matrix(c(2,0,0,3,1,0,0,0,5,0,0,2), nrow = 4, ncol = 3, byrow = TRUE)
comm &lt;- array(c(comm1, comm2, comm3), c(4,3,3))
colnames(comm) &lt;- c("sp1","sp2","sp3")

tree &lt;- hclust(dist(c(1:3), method="euclidean"), method="average")
tree$labels &lt;- colnames(comm)

methods &lt;- data.frame(method = c("Met1","Met2","Met3"), nSamples = c(1,2,1))

optim.beta.stats(comm,,methods, c(1,2,1)) #a complete sample will have 0 difference
optim.beta.stats(comm, tree, methods = methods, samples = c(0,1,1), runs = 100)
</code></pre>

<hr>
<h2 id='optim.spatial'>Optimization of spatial sampling.</h2><span id='topic+optim.spatial'></span>

<h3>Description</h3>

<p>Optimization of sampling site distribution in space based on environmental (or other) variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.spatial(layers, n, latlong = TRUE, clusterMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.spatial_+3A_layers">layers</code></td>
<td>
<p>A SpatRaster object from package terra.</p>
</td></tr>
<tr><td><code id="optim.spatial_+3A_n">n</code></td>
<td>
<p>The number of intended sampling sites (clusters).</p>
</td></tr>
<tr><td><code id="optim.spatial_+3A_latlong">latlong</code></td>
<td>
<p>Boolean indicating whether latitude and longitude should be taken into account when clustering.</p>
</td></tr>
<tr><td><code id="optim.spatial_+3A_clustermap">clusterMap</code></td>
<td>
<p>Boolean indicating whether to build a new raster with clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optimizing the selection of sampling sites often requires maximizing the environmental diversity covered by them.
One possible solution to this problem, here adopted, is performing a k-means clustering using environmental data and choosing the sites closest to the multidimensional environmental centroid of each cluster for sampling (Jimenez-Valverde &amp; Lobo 2004)
</p>


<h3>Value</h3>

<p>Either a matrix of cells x clusters (also indicating distance to centroid, longitude and latitude of each cell) or a list with such matrix plus the clusterMap.
</p>


<h3>References</h3>

<p>Jimenez-Valverde, A., &amp; Lobo, J. M. (2004) Un metodo sencillo para seleccionar puntos de muestreo con el objetivo de inventariar taxones hiperdiversos: el caso practico de las familias Araneidae y Thomisidae (Araneae) en la comunidad de Madrid, Espana. Ecologia, 18: 297-305.
</p>

<hr>
<h2 id='originality'>Phylogenetic/functional originality of species or individuals.</h2><span id='topic+originality'></span>

<h3>Description</h3>

<p>Average dissimilarity between a species or individual and all others in a community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>originality(comm, tree, distance, abund = FALSE, relative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="originality_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data. If missing, the originality using the full tree or distance matrix is calculated.</p>
</td></tr>
<tr><td><code id="originality_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="originality_+3A_distance">distance</code></td>
<td>
<p>A dist object representing the phylogenetic or functional distance between species.</p>
</td></tr>
<tr><td><code id="originality_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether originality should be calculated per individual (T) or species (F).</p>
</td></tr>
<tr><td><code id="originality_+3A_relative">relative</code></td>
<td>
<p>A boolean (T/F) indicating whether originality should be relative to the maximum distance between any two species in the tree or distance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the originality measure of Pavoine et al. (2005) without replacement.
</p>


<h3>Value</h3>

<p>A matrix of sites x species values.
</p>


<h3>References</h3>

<p>Pavoine, S., Ollier, S. &amp; Dufour, A.-B. (2005) Is the originality of a species measurable? Ecology Letters, 8: 579-586.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,2,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,1,1,1), nrow = 4, byrow = TRUE)
distance &lt;- dist(c(1:5), method="euclidean")
tree = hclust(distance)

originality(tree = tree)
originality(distance = distance)
originality(comm, tree)
originality(comm, tree, abund = TRUE)
originality(comm, tree, relative = TRUE)
</code></pre>

<hr>
<h2 id='phylotree'>Taxonomic tree for 338 species of spiders (surrogate for phylogeny)</h2><span id='topic+phylotree'></span>

<h3>Description</h3>

<p>A dataset representing an approximation to the phylogenetic tree for 338 species of spiders captured in Portugal.
The tree is based on the linnean hierarchy, with different suborders separated by 1 unit, families by 0.75, genera by 0.5 and species by 0.25.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(phylotree)
</code></pre>


<h3>Format</h3>

<p>An hclust object with 338 species.
</p>

<hr>
<h2 id='r2'>Model R2.</h2><span id='topic+r2'></span>

<h3>Description</h3>

<p>Calculates R2 from the summed squared differences between observed and estimated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2(obs, est = NULL, param = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2_+3A_obs">obs</code></td>
<td>
<p>Either a model or a vector with observed values.</p>
</td></tr>
<tr><td><code id="r2_+3A_est">est</code></td>
<td>
<p>A vector with estimated values. Only used if obs is not a model.</p>
</td></tr>
<tr><td><code id="r2_+3A_param">param</code></td>
<td>
<p>Number of parameters in the model to calculate the adjusted R2 if &gt; 0. If obs is a model param will be ignored and the number of parameters will be calculated from the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful for models or functions that do not provide r2 values.
</p>


<h3>Value</h3>

<p>The r2 value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs = c(1,4,5,6)
est = c(0,1,4,7)

#example using values
r2(obs, est)
r2(obs, est, param = 1)

#example using model
mod = lm(obs ~ est)
r2(mod)
summary(mod)$r.squared
r2(mod, param = 1)
summary(mod)$adj.r.squared

</code></pre>

<hr>
<h2 id='rao'>Rao quadratic entropy.</h2><span id='topic+rao'></span>

<h3>Description</h3>

<p>Rao quadratic entropy for Phylogenetic or Functional richness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rao(comm, tree, distance, raref = 0, runs = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rao_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with abundance data.</p>
</td></tr>
<tr><td><code id="rao_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD).</p>
</td></tr>
<tr><td><code id="rao_+3A_distance">distance</code></td>
<td>
<p>A dist object representing the phylogenetic or functional distance between species or alternatively a species x traits matrix or data.frame to calculate distances.</p>
</td></tr>
<tr><td><code id="rao_+3A_raref">raref</code></td>
<td>
<p>An integer specifying the number of individuals for rarefaction (individual based).
If raref &lt; 1 no rarefaction is made.
If raref = 1 rarefaction is made by the minimum abundance among all sites.
If raref &gt; 1 rarefaction is made by the abundance indicated.
If not specified, default is 0.</p>
</td></tr>
<tr><td><code id="rao_+3A_runs">runs</code></td>
<td>
<p>Number of resampling runs for rarefaction. If not specified, default is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rao quadratic entropy (Rao, 1982) measures diversity based on the abundance of species and the dissimilarity between them.
</p>


<h3>Value</h3>

<p>A matrix of sites x diversity values (either &quot;Rao&quot; OR &quot;Mean, Median, Min, LowerCL, UpperCL and Max&quot;).
</p>


<h3>References</h3>

<p>Rao, C.R. (1982). Diversity and dissimilarity coefficients: a unified approach. Theoretical Population Biology, 21: 24-43.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,1,1,1,1,0,100,1,2,0), nrow = 2, ncol = 5, byrow = TRUE)
distance = dist(1:5)
rao(comm)
rao(comm, , distance)
rao(comm, hclust(distance), raref = 1)
</code></pre>

<hr>
<h2 id='raster.alpha'>Maps of alpha diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</h2><span id='topic+raster.alpha'></span>

<h3>Description</h3>

<p>Observed alpha diversity using rasters of species distributions (presence/absence).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster.alpha(layers, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster.alpha_+3A_layers">layers</code></td>
<td>
<p>A SpatRaster object of species distributions from package terra.</p>
</td></tr>
<tr><td><code id="raster.alpha_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TD is equivalent to species richness. Calculations of PD and FD are based on Faith (1992) and Petchey &amp; Gaston (2002, 2006), which measure PD and FD of a community as the total branch length of a tree linking all species represented in such community.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric). The path to the root of the tree is always included in calculations of PD and FD.
The number and order of species in layers must be the same as in tree.
</p>


<h3>Value</h3>

<p>A SpatRaster object representing richness in space.
</p>


<h3>References</h3>

<p>Faith, D.P. (1992) Conservation evaluation and phylogenetic diversity. Biological Conservation, 61, 1-10.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2002) Functional diversity (FD), species richness and community composition. Ecology Letters, 5, 402-411.
</p>
<p>Petchey, O.L. &amp; Gaston, K.J. (2006) Functional diversity: back to basics and looking forward. Ecology Letters, 9, 741-758.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- terra::rast(matrix(c(NA,1,1,1,1,0,0,0,0), nrow = 3, ncol = 3, byrow = TRUE))
sp2 &lt;- terra::rast(matrix(c(0,0,0,0,1,1,1,1,1), nrow = 3, ncol = 3, byrow = TRUE))
sp3 &lt;- terra::rast(matrix(c(0,0,0,1,1,1,0,0,0), nrow = 3, ncol = 3, byrow = TRUE))
spp &lt;- c(sp1, sp2, sp3)
tree &lt;- hclust(dist(c(1:3), method="euclidean"), method="average")
tree$labels = c("Sp1", "Sp2", "Sp3")
names(spp) = tree$labels
raster.alpha(spp)
raster.alpha(spp, tree)
</code></pre>

<hr>
<h2 id='raster.beta'>Maps of beta diversity (Taxon, Phylogenetic or Functional Diversity - TD, PD, FD).</h2><span id='topic+raster.beta'></span>

<h3>Description</h3>

<p>Observed beta diversity using rasters of species distributions (presence/absence or abundance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster.beta(layers, tree, func = "jaccard", neighbour = 8, abund = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster.beta_+3A_layers">layers</code></td>
<td>
<p>A SpatRaster object of species distributions from package terra.</p>
</td></tr>
<tr><td><code id="raster.beta_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="raster.beta_+3A_func">func</code></td>
<td>
<p>Partial match indicating whether the Jaccard or Soerensen family of beta diversity measures should be used. If not specified, default is Jaccard.</p>
</td></tr>
<tr><td><code id="raster.beta_+3A_neighbour">neighbour</code></td>
<td>
<p>Either 8 (default) or 4 cells considered to calculate beta diversiy of each focal cell.</p>
</td></tr>
<tr><td><code id="raster.beta_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether abundance data should be used (TRUE) or converted to incidence (FALSE) before analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta diversity measures used here follow the partitioning framework independently developed by Podani &amp; Schmera (2011) and Carvalho et al. (2012)
and later expanded to PD and FD by Cardoso et al. (2014), where Btotal = Brepl + Brich.
Btotal = total beta diversity, reflecting both species replacement and loss/gain;
Brepl = beta diversity explained by replacement of species alone; Brich = beta diversity explained by species loss/gain (richness differences) alone.
PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric). The path to the root of the tree is always included in calculations of PD and FD.
The number and order of species in layers must be the same as in tree.
</p>


<h3>Value</h3>

<p>A SpatRaster object with three layers representing Btotal, Brepl and Brich in space.
</p>


<h3>References</h3>

<p>Cardoso, P., Rigal, F., Carvalho, J.C., Fortelius, M., Borges, P.A.V., Podani, J. &amp; Schmera, D. (2014) Partitioning taxon, phylogenetic and functional beta diversity into replacement and richness difference components. Journal of Biogeography, 41, 749-761.
</p>
<p>Carvalho, J.C., Cardoso, P. &amp; Gomes, P. (2012) Determining the relative roles of species replacement and species richness differences in generating beta-diversity patterns. Global Ecology and Biogeography, 21, 760-771.
</p>
<p>Gotelli, N.J. &amp; Colwell, R.K. (2001) Quantifying biodiversity: procedures and pitfalls in the measurement and comparison of species richness. Ecology Letters, 4, 379-391.
</p>
<p>Podani, J. &amp; Schmera, D. (2011) A new conceptual and methodological framework for exploring and explaining pattern in presence-absence data. Oikos, 120, 1625-1638.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- terra::rast(matrix(c(NA,1,1,1,1,0,1,1,0), nrow = 3, ncol = 3, byrow = TRUE))
sp2 &lt;- terra::rast(matrix(c(0,0,0,1,1,1,1,1,1), nrow = 3, ncol = 3, byrow = TRUE))
sp3 &lt;- terra::rast(matrix(c(0,0,0,1,1,1,1,1,0), nrow = 3, ncol = 3, byrow = TRUE))
spp &lt;- c(sp1, sp2, sp3)
tree &lt;- hclust(dist(c(1:3), method="euclidean"), method="average")
tree$labels = c("Sp1", "Sp2", "Sp3")
names(spp) = tree$labels
raster.beta(spp)
raster.beta(spp, tree)
</code></pre>

<hr>
<h2 id='raster.dispersion'>Maps of phylogenetic/functional dispersion of species or individuals.</h2><span id='topic+raster.dispersion'></span>

<h3>Description</h3>

<p>Average dissimilarity between any two species or individuals randomly chosen in a community using rasters of species distributions (presence/absence or abundance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster.dispersion(
  layers,
  tree,
  distance,
  func = "originality",
  abund = FALSE,
  relative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster.dispersion_+3A_layers">layers</code></td>
<td>
<p>A SpatRaster object of species distributions from package terra.</p>
</td></tr>
<tr><td><code id="raster.dispersion_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="raster.dispersion_+3A_distance">distance</code></td>
<td>
<p>A dist object representing the phylogenetic or functional distance between species.</p>
</td></tr>
<tr><td><code id="raster.dispersion_+3A_func">func</code></td>
<td>
<p>Calculate dispersion using originality (default), uniqueness or contribution.</p>
</td></tr>
<tr><td><code id="raster.dispersion_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether dispersion should be calculated using individuals (T) or species (F).</p>
</td></tr>
<tr><td><code id="raster.dispersion_+3A_relative">relative</code></td>
<td>
<p>A boolean (T/F) indicating whether dispersion should be relative to the maximum distance between any two species in the tree or distance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If abundance data is used and a tree is given, dispersion is the quadratic entropy of Rao (1982).
If abundance data is not used but a tree is given, dispersion is the phylogenetic dispersion measure of Webb et al. (2002).
Note that cells with less than two species cannot have dispersion values.
</p>


<h3>Value</h3>

<p>A SpatRaster object representing dispersion in space.
</p>


<h3>References</h3>

<p>Rao, C.R. (1982) Diversity and dissimilarity coefficients: a unified approach. Theoretical Population Biology, 21: 24-43.
</p>
<p>Webb, C.O., Ackerly, D.D., McPeek, M.A. &amp; Donoghue, M.J. (2002) Phylogenies and community ecology. Annual Review of Ecology and Systematics, 33: 475-505.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- terra::rast(matrix(c(NA,1,1,1,1,0,0,0,0), nrow = 3, ncol = 3, byrow = TRUE))
sp2 &lt;- terra::rast(matrix(c(0,0,0,0,1,1,1,1,1), nrow = 3, ncol = 3, byrow = TRUE))
sp3 &lt;- terra::rast(matrix(c(0,0,0,1,1,1,0,0,0), nrow = 3, ncol = 3, byrow = TRUE))
spp &lt;- c(sp1, sp2, sp3)
tree &lt;- hclust(dist(c(1:3), method="euclidean"), method="average")
tree$labels = c("Sp1", "Sp2", "Sp3")
names(spp) = tree$labels
raster.dispersion(spp, tree)
</code></pre>

<hr>
<h2 id='raster.evenness'>Maps of phylogenetic/functional evenness of species or individuals.</h2><span id='topic+raster.evenness'></span>

<h3>Description</h3>

<p>Regularity of distance and abundance between any two species in a community using rasters of species distributions (presence/absence or abundance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster.evenness(
  layers,
  tree,
  distance,
  method = "expected",
  func = "camargo",
  abund = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster.evenness_+3A_layers">layers</code></td>
<td>
<p>A SpatRaster object of species distributions from package terra.</p>
</td></tr>
<tr><td><code id="raster.evenness_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="raster.evenness_+3A_distance">distance</code></td>
<td>
<p>A dist object representing the phylogenetic or functional distance between species.</p>
</td></tr>
<tr><td><code id="raster.evenness_+3A_method">method</code></td>
<td>
<p>Calculate dispersion using &quot;expected&quot; values (default) or values based on &quot;contribution&quot; of species to the tree.</p>
</td></tr>
<tr><td><code id="raster.evenness_+3A_func">func</code></td>
<td>
<p>Calculate dispersion using &quot;Camargo&quot; (1993; default) or &quot;Bulla&quot; (1994) index.</p>
</td></tr>
<tr><td><code id="raster.evenness_+3A_abund">abund</code></td>
<td>
<p>A boolean (T/F) indicating whether evenness should be calculated using abundance data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no tree or distance is provided the result is the original index of Bulla with correction.
Note that cells with less than two species cannot have evenness values.
</p>


<h3>Value</h3>

<p>A SpatRaster object representing evenness in space.
</p>


<h3>References</h3>

<p>Bulla, L. (1994) An index of evenness and its associated diversity measure. Oikos, 70: 167-171.
</p>
<p>Camargo, J.A. (1993) Must dominance increase with the number of subordinate species in competitive interactions? Journal of Theoretical Biology, 161: 537-542.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- terra::rast(matrix(c(NA,1,1,1,1,0,0,0,0), nrow = 3, ncol = 3, byrow = TRUE))
sp2 &lt;- terra::rast(matrix(c(0,0,0,0,1,1,1,1,1), nrow = 3, ncol = 3, byrow = TRUE))
sp3 &lt;- terra::rast(matrix(c(0,0,0,1,1,1,0,0,0), nrow = 3, ncol = 3, byrow = TRUE))
spp &lt;- c(sp1, sp2, sp3)
tree &lt;- hclust(dist(c(1:3), method="euclidean"), method="average")
tree$labels = c("Sp1", "Sp2", "Sp3")
names(spp) = tree$labels
raster.evenness(spp)
raster.evenness(spp, tree)
</code></pre>

<hr>
<h2 id='sad'>Species-abundance distribution (SAD).</h2><span id='topic+sad'></span>

<h3>Description</h3>

<p>Fits the SAD to community abundance data, also using trees and with possible rarefaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sad(comm, tree, octaves = TRUE, scale = FALSE, raref = 0, runs = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sad_+3A_comm">comm</code></td>
<td>
<p>Either a vector with the abundance per species, or a sites x species matrix.</p>
</td></tr>
<tr><td><code id="sad_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="sad_+3A_octaves">octaves</code></td>
<td>
<p>a boolean indicating whether octaves should be calculated.</p>
</td></tr>
<tr><td><code id="sad_+3A_scale">scale</code></td>
<td>
<p>scale y-axis to sum 1.</p>
</td></tr>
<tr><td><code id="sad_+3A_raref">raref</code></td>
<td>
<p>An integer specifying the number of individuals for rarefaction (individual based).
If raref &lt; 1 no rarefaction is made.
If raref = 1 rarefaction is made by the minimum abundance among all sites.
If raref &gt; 1 rarefaction is made by the abundance indicated.
If not specified, default is 0.</p>
</td></tr>
<tr><td><code id="sad_+3A_runs">runs</code></td>
<td>
<p>Number of resampling runs for rarefaction. If not specified, default is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Species Abundance Distribution describes the commonness and rarity in ecological systems. It was recently expanded to accomodate phylegenetic and functional differences between species (Matthews et al., subm.). Classes defined as n = 1, 2-3, 4-7, 8-15, .... Rarefaction allows comparison of sites with different total abundances.
</p>


<h3>Value</h3>

<p>A vector or matrix with the different values per class per community.
</p>


<h3>References</h3>

<p>Matthews et al. (subm.) Phylogenetic and functional dimensions of the species abundance distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm1 &lt;- c(20,1,3,100,30)
comm2 &lt;- c(1,2,12,0,45)
comm &lt;- rbind(comm1, comm2)
tree &lt;- hclust(dist(c(1:5), method="euclidean"), method="average")
sad(comm1)
sad(comm)
sad(comm, octaves = FALSE)
sad(comm, tree, scale = TRUE)
sad(comm, raref = 1)
</code></pre>

<hr>
<h2 id='sar'>Species-area relationship (SAR).</h2><span id='topic+sar'></span>

<h3>Description</h3>

<p>Fits and compares several of the most supported models for the species (or PD, or FD) -area relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar(comm, tree, area)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sar_+3A_comm">comm</code></td>
<td>
<p>Either a vector with the diversity values per site, or a sites x species matrix.</p>
</td></tr>
<tr><td><code id="sar_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree (used only to fit the PD or FD-area relationships, requires comm to be a sites x species matrix).</p>
</td></tr>
<tr><td><code id="sar_+3A_area">area</code></td>
<td>
<p>A vector with the area per site.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Larger areas (often islands) usually carry more species. Several formulas were proposed in the past to describe this relationship (Arrhenius 1920, 1921; Gleason 1922).
Recently, the same approach began to be used for other measures of diversity, namely phylogenetic (PD) and functional (FD) diversity (Whittaker et al. 2014).
The function compares some of the most commonly used and theoretically or empirically suported models.
The relationships for PD and FD are calculated based on a tree (hclust or phylo object, no need to be ultrametric).
</p>


<h3>Value</h3>

<p>A matrix with the different model parameters and explanatory power.
</p>


<h3>References</h3>

<p>Arrhenius, O. (1920) Distribution of the species over the area. Meddelanden fran Vetenskapsakadmiens Nobelinstitut, 4: 1-6.
</p>
<p>Arrhenius, O. (1921) Species and area. Journal of Ecology, 9: 95-99.
</p>
<p>Gleason, H.A. (1922) On the relation between species and area. Ecology, 3: 158-162.
</p>
<p>Whittaker, R.J., Rigal, F., Borges, P.A.V., Cardoso, P., Terzopoulou, S., Casanoves, F., Pla, L., Guilhaumon, F., Ladle, R. &amp; Triantis, K.A. (2014) Functional biogeography of oceanic islands and the scaling of functional diversity in the Azores. Proceedings of the National Academy of Sciences USA, 111: 13709-13714.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>div &lt;- c(1,2,3,4,4)
comm &lt;- matrix(c(2,0,0,0,3,1,0,0,2,4,5,0,1,3,2,5,1,1,1,1), nrow = 5, ncol = 4, byrow = TRUE)
tree &lt;- hclust(dist(c(1:4), method="euclidean"), method="average")
area &lt;- c(10,40,80,160,160)
sar(div,,area)
sar(comm,,area)
sar(comm,tree,area)
</code></pre>

<hr>
<h2 id='ses'>Standard Effect Size.</h2><span id='topic+ses'></span>

<h3>Description</h3>

<p>Calculates the standard effect size from observed and estimated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ses(obs, est, param = TRUE, p = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ses_+3A_obs">obs</code></td>
<td>
<p>A single observed value.</p>
</td></tr>
<tr><td><code id="ses_+3A_est">est</code></td>
<td>
<p>A vector with estimated values.</p>
</td></tr>
<tr><td><code id="ses_+3A_param">param</code></td>
<td>
<p>Value is calculated with parametric or non-parametric method. Because standardized effect sizes may lead to biased conclusions if null values show an asymmetric distribution or deviate from normality, non-parametric effect sizes use probit transformed p-values (Lhotsky et al., 2016).</p>
</td></tr>
<tr><td><code id="ses_+3A_p">p</code></td>
<td>
<p>Boolean indicating whether the p-value should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ses value or a vector with ses and p-value.
</p>


<h3>References</h3>

<p>Lhotsky et al. (2016) Changes in assembly rules along a stress gradient from open dry grasslands to wetlands. Journal of Ecology, 104: 507-517.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>est = rnorm(1000, 500, 100)

ses(100, est)
ses(100, est, param = FALSE)
ses(500, est)
ses(500, est, param = FALSE)
ses(900, est, p = TRUE)
ses(900, est, param = FALSE, p = TRUE)
</code></pre>

<hr>
<h2 id='sim.plot'>Plots of simulated species spatial distributions.</h2><span id='topic+sim.plot'></span>

<h3>Description</h3>

<p>Plots individuals from artificial communities with given SAD and spatial clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.plot(comm, sad = FALSE, s = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.plot_+3A_comm">comm</code></td>
<td>
<p>artificial community data from function sim.spatial.</p>
</td></tr>
<tr><td><code id="sim.plot_+3A_sad">sad</code></td>
<td>
<p>boolean indicating if the SAD plot should also be shown. Default is FALSE.</p>
</td></tr>
<tr><td><code id="sim.plot_+3A_s">s</code></td>
<td>
<p>number of species to plot simultaneously. Default is the number of species in comm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function useful for visualizing the results of sim.spatial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- sim.spatial(1000, 24)
sim.plot(comm)
sim.plot(comm, sad = TRUE)
sim.plot(comm, s = 9)
</code></pre>

<hr>
<h2 id='sim.sad'>Simulation of species abundance distributions (SAD).</h2><span id='topic+sim.sad'></span>

<h3>Description</h3>

<p>Creates artificial communities following given SADs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.sad(n, s, sad = "lognormal", sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.sad_+3A_n">n</code></td>
<td>
<p>total number of individuals.</p>
</td></tr>
<tr><td><code id="sim.sad_+3A_s">s</code></td>
<td>
<p>number of species.</p>
</td></tr>
<tr><td><code id="sim.sad_+3A_sad">sad</code></td>
<td>
<p>The SAD distribution type (lognormal, uniform, broken stick or geometric). Default is lognormal.</p>
</td></tr>
<tr><td><code id="sim.sad_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of lognormal distributions. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Species Abundance Distributions may take a number of forms. A lognormal SAD probably is the most supported by empirical data, but we include other common types useful for testing multiple algorithms including several of the functions in BAT.
</p>


<h3>Value</h3>

<p>A matrix of species x abundance per species.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm1 &lt;- sim.sad(10000, 100)
comm2 &lt;- sim.sad(10000, 100, sd = 2)
comm3 &lt;- sim.sad(10000, 100, sad = "uniform")
par(mfrow=c(1,3))
hist(log(comm1$Freq))
hist(log(comm2$Freq))
hist(log(comm3$Freq))
</code></pre>

<hr>
<h2 id='sim.sample'>Simulation of sampling from artificial communities.</h2><span id='topic+sim.sample'></span>

<h3>Description</h3>

<p>Simulates a sampling process from artificial communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.sample(comm, cells = 100, samples = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.sample_+3A_comm">comm</code></td>
<td>
<p>simulated community data from function sim.spatial.</p>
</td></tr>
<tr><td><code id="sim.sample_+3A_cells">cells</code></td>
<td>
<p>number of cells to divide the simulated space into. Default is 100.</p>
</td></tr>
<tr><td><code id="sim.sample_+3A_samples">samples</code></td>
<td>
<p>number of samples (cells) to randomly extract. Default is the number of cells (the entire community).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The space will be divided in both dimensions by sqrt(cells).
</p>
<p>Function useful for simulating sampling processes from the results of sim.spatial.
</p>
<p>May be used as direct input to other functions (e.g. alpha, alpha.accum, beta, beta.accum) to test the behavior of multiple descriptors and estimators.
</p>


<h3>Value</h3>

<p>A matrix of samples x species (values are abundance per species per sample).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- sim.spatial(1000, 10)
sim.sample(comm)
sim.sample(comm, cells = 10, samples = 5)
</code></pre>

<hr>
<h2 id='sim.spatial'>Simulation of species spatial distributions.</h2><span id='topic+sim.spatial'></span>

<h3>Description</h3>

<p>Creates artificial communities with given SAD and spatial clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.spatial(
  n,
  s,
  sad = "lognormal",
  sd = 1,
  distribution = "aggregated",
  clust = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.spatial_+3A_n">n</code></td>
<td>
<p>total number of individuals.</p>
</td></tr>
<tr><td><code id="sim.spatial_+3A_s">s</code></td>
<td>
<p>number of species.</p>
</td></tr>
<tr><td><code id="sim.spatial_+3A_sad">sad</code></td>
<td>
<p>The SAD distribution type (lognormal, uniform, broken stick or geometric). Default is lognormal.</p>
</td></tr>
<tr><td><code id="sim.spatial_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of lognormal distributions. Default is 1.</p>
</td></tr>
<tr><td><code id="sim.spatial_+3A_distribution">distribution</code></td>
<td>
<p>The spatial distribution of individual species populations (aggregated, random, uniform or gradient). Default is aggregated.</p>
</td></tr>
<tr><td><code id="sim.spatial_+3A_clust">clust</code></td>
<td>
<p>The clustering parameter if distribution is either aggregated or gradient (higher values create more clustered populations). Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial distribution of individuals of given species may take a number of forms.
Competitive exclusion may cause overdispersion, specific habitat needs or cooperation may cause aggregation and environmental gradients may cause abundance gradients.
</p>


<h3>Value</h3>

<p>A matrix of individuals x (species, x coords and y coords).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(3 ,3))
comm = sim.spatial(100, 9, distribution = "uniform")
for(i in 1:9){
	sp &lt;- comm[comm[1] == paste("Sp", i, sep = ""), ]
	plot(sp$x, sp$y, main = paste("Sp", i), xlim = c(0,1), ylim = c(0,1))
}
</code></pre>

<hr>
<h2 id='sim.tree'>Simulation of phylogenetic or functional tree.</h2><span id='topic+sim.tree'></span>

<h3>Description</h3>

<p>Simulates a random tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.tree(s, m = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.tree_+3A_s">s</code></td>
<td>
<p>number of species.</p>
</td></tr>
<tr><td><code id="sim.tree_+3A_m">m</code></td>
<td>
<p>a structural parameter defining the average difference between species. Default is 100. Lower numbers create trees dominated by increasingly similar species, higher numbers by increasingly dissimilar species.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very simple tree based on random genes/traits.
</p>


<h3>Value</h3>

<p>An hclust object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- sim.tree(10)
plot(as.dendrogram(tree))
tree &lt;- sim.tree(100,10)
plot(as.dendrogram(tree))
tree &lt;- sim.tree(100,1000)
plot(as.dendrogram(tree))
</code></pre>

<hr>
<h2 id='slope'>Slope of accumulation curves.</h2><span id='topic+slope'></span>

<h3>Description</h3>

<p>This is similar to the first derivative of the curves at each of its points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope(accum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slope_+3A_accum">accum</code></td>
<td>
<p>A matrix resulting from the alpha.accum or beta.accum functions (sampling units x diversity values).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Slope is the expected gain in diversity when sampling a new individual. The slope of an accumulation curve, of either observed or estimated diversity, allows verifying if the asymptote has been reached (Cardoso et al. 2011).
This is an indication of either the completeness of the inventory (low final slopes of the observed curve indicate high completeness) or reliability of the estimators (stability of the slope around a value of 0 along the curve indicates reliability).
</p>


<h3>Value</h3>

<p>A matrix of sampling units x slope values.
</p>


<h3>References</h3>

<p>Cardoso, P., Pekar, S., Jocque, R. &amp; Coddington, J.A. (2011) Global patterns of guild composition and functional diversity of spiders. PLoS One, 6, e21710.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm1 &lt;- matrix(c(2,2,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,0,2,2), nrow = 4, ncol = 5, byrow = TRUE)
comm2 &lt;- matrix(c(1,1,0,0,0,0,2,1,0,0,0,0,2,1,0,0,0,0,2,1), nrow = 4, ncol = 5, byrow = TRUE)
tree &lt;- hclust(dist(c(1:5), method="euclidean"), method="average")
acc.alpha = alpha.accum(comm1)
slope(acc.alpha)
acc.beta = beta.accum(comm1, comm2, tree)
slope(acc.beta)
</code></pre>

<hr>
<h2 id='standard'>Standardize variables.</h2><span id='topic+standard'></span>

<h3>Description</h3>

<p>Standardize (or normalize) variables in different ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard(trait, method = "standard", convert = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standard_+3A_trait">trait</code></td>
<td>
<p>A species x traits matrix or data.frame.</p>
</td></tr>
<tr><td><code id="standard_+3A_method">method</code></td>
<td>
<p>One of &quot;standard&quot; (standardize to mean = 0 and sd = 1, i.e., use z-score), &quot;range&quot; (rescale with range 0-1), or &quot;rank&quot; (rescale with range 0-1 after ranking).</p>
</td></tr>
<tr><td><code id="standard_+3A_convert">convert</code></td>
<td>
<p>A vector of column numbers to be standardized. If NULL all will be standardized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standardizing values allows to directly compare variables of interest with inherently different ranges, avoiding artificial distortions of distances between observations.
</p>


<h3>Value</h3>

<p>A matrix with variables standardized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trait = data.frame(body = c(20,40,60,30,10), beak = c(NA,4,6,3,1))
standard(trait)
standard(trait, method = "range")
standard(trait, method = "rank")
</code></pre>

<hr>
<h2 id='tree.build'>Build functional tree.</h2><span id='topic+tree.build'></span>

<h3>Description</h3>

<p>Builds a functional tree from trait or distance data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.build(
  trait,
  distance = "gower",
  func = "nj",
  fs = 0,
  convert = NULL,
  weight = NULL,
  root = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.build_+3A_trait">trait</code></td>
<td>
<p>A species x traits matrix or data.frame or, alternatively, a dist object.</p>
</td></tr>
<tr><td><code id="tree.build_+3A_distance">distance</code></td>
<td>
<p>One of &quot;gower&quot; or &quot;euclidean&quot;. Not used if trait is already a dist object.</p>
</td></tr>
<tr><td><code id="tree.build_+3A_func">func</code></td>
<td>
<p>One of &quot;upgma&quot;, &quot;mst&quot;, &quot;nj&quot;, &quot;bionj&quot; or &quot;best&quot;.</p>
</td></tr>
<tr><td><code id="tree.build_+3A_fs">fs</code></td>
<td>
<p>Only used for func = &quot;nj&quot; OR &quot;bionj&quot;. Argument s of the agglomerative criterion: it is coerced as an integer and must at least equal to one.</p>
</td></tr>
<tr><td><code id="tree.build_+3A_convert">convert</code></td>
<td>
<p>A vector of column numbers, usually categorical variables, to be converted to dummy variables.  Not used if trait is already a dist object.</p>
</td></tr>
<tr><td><code id="tree.build_+3A_weight">weight</code></td>
<td>
<p>A vector of column numbers with weights for each variable. Its length must be equal to the number of columns in trait. Not used if trait is already a dist object.</p>
</td></tr>
<tr><td><code id="tree.build_+3A_root">root</code></td>
<td>
<p>A numeric or character specifying the functional outgroup to root the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree will be built using one of four algorithms after traits are dummyfied (if needed) and standardized (always):
If func = &quot;upgma&quot; uses average linkage clustering (UPGMA, Cardoso et al. 2014).
If func = &quot;mst&quot; uses minimum spanning trees, equivalent to single linkage clustering (Gower &amp; Ross 1969).
If func = &quot;nj&quot; uses the original neighbor-joining algorithm of Saitou &amp; Nei (1987).
If func = &quot;bionj&quot; uses the modified neighbor-joining algorithm of Gascuel (1997).
Any of the neighbor-joining options is usually preferred as they keep distances between species better than UPGMA or MST (Cardoso et al. subm.).
If func = &quot;best&quot;, chooses the best of the options above based on maximum tree.quality values.
If NJ trees are built, the root will be set at the node closest to the midpoint between the two most dissimilar species in the tree or, if root not NULL, at the node provided in parameter root (Podani et al. 2000).
Gower distance (Pavoine et al. 2009) allows continuous, ordinal, categorical or binary variables, with possible weighting.
NAs are allowed as long as each pair of species has at least one trait value in common. For fs &gt; 0 even if this condition is not met the Q* criterion by Criscuolo &amp; Gascuel (2008) is used to fill missing data.
If convert is given the algorithm will convert these column numbers to dummy variables. Otherwise it will convert all columns with factors or characters as values.
</p>


<h3>Value</h3>

<p>A phylo object representing a functional tree.
</p>


<h3>References</h3>

<p>Cardoso et al. (2014) Partitioning taxon, phylogenetic and functional beta diversity into replacement and richness difference components. Journal of Biogeography, 41: 749-761.
</p>
<p>Cardoso et al. (subm.) Using neighbor-joining trees for functional diversity analyses.
</p>
<p>Criscuolo &amp; Gascuel (2008) Fast NJ-like algorithms to deal with incomplete distance matrices. BMC Bioinformatics, 9: 166.
</p>
<p>Gascuel (1997) BIONJ: an improved version of the NJ algorithm based on a simple model of sequence data. Molecular Biology and Evolution, 14: 685–695.
</p>
<p>Gower &amp; Ross (1969) Minimum spanning trees and single linkage cluster analysis. Journal of the Royal Statistical Society, 18: 54-64.
</p>
<p>Pavoine et al. (2009) On the challenge of treating various types of variables: application for improving the measurement of functional diversity. Oikos, 118: 391-402.
</p>
<p>Podani et al. (2000) Additive trees in the analysis of community data. Community Ecology, 1, 33–41.
</p>
<p>Saitou &amp; Nei (1987) The neighbor-joining method: a new method for reconstructing phylogenetic trees. Molecular Biology and Evolution, 4, 406–425.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trait = data.frame(body = c(NA,2,3,4,4), beak = c(1,1,1,1,2))
plot(tree.build(trait))
plot(tree.build(trait, func = "bionj", fs = 1, weight = c(1, 0)), "u")
plot(tree.build(trait, func = "best", root = 4))
</code></pre>

<hr>
<h2 id='tree.quality'>Quality of tree.</h2><span id='topic+tree.quality'></span>

<h3>Description</h3>

<p>Assess the quality of a functional tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.quality(distance, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.quality_+3A_distance">distance</code></td>
<td>
<p>A dist object representing the initial distances between species.</p>
</td></tr>
<tr><td><code id="tree.quality_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm calculates the inverse of mean squared deviation between initial and cophenetic distances (Maire et al. 2015) after standardization of all values between 0 and 1 for simplicity of interpretation.
A value of 1 corresponds to maximum quality of the functional representation. A value of 0 corresponds to the expected value for a star tree, where all pairwise distances are 1.
</p>


<h3>Value</h3>

<p>A single value of quality.
</p>


<h3>References</h3>

<p>Maire et al. (2015) How many dimensions are needed to accurately assess functional diversity? A pragmatic approach for assessing the quality of functional spaces. Global Ecology and Biogeography, 24: 728:740.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trait = data.frame(body = c(1,2,3,4,4), beak = c(1,1,1,1,2))
distance = gower(trait)

tree = tree.build(trait)
tree.quality(distance, tree)

tree = tree.build(trait, func = "bionj")
tree.quality(distance, tree)

tree = tree.build(trait, func = "upgma")
tree.quality(distance, tree)

tree = tree.build(trait, func = "mst")
tree.quality(distance, tree)

tree = tree.build(trait, func = "best")

distance1 = distance
distance1[] = 1
tree = hclust(distance1)
tree.quality(distance, tree)
</code></pre>

<hr>
<h2 id='tree.zero'>Convert negative branches of tree.</h2><span id='topic+tree.zero'></span>

<h3>Description</h3>

<p>Converts negative branch lengths of any tree to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.zero(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.zero_+3A_tree">tree</code></td>
<td>
<p>A phylo object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts branches with negative values to zero while shortening only the two branches immediately below it by the same absolute amount to ensure the tree remains with tips at same distances and there are no polytomies.
</p>


<h3>Value</h3>

<p>A phylo object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1,2))
tree &lt;- ape::read.tree(text='(((A:3, B:3):1,
(G:6, (H:5, I:5):1):-2):3, ((C:1, D:1):2, (E:4, F:4):-1):4);')
plot(tree)

tree = tree.zero(tree)
plot(tree)
</code></pre>

<hr>
<h2 id='uniqueness'>Phylogenetic/functional uniqueness of species.</h2><span id='topic+uniqueness'></span>

<h3>Description</h3>

<p>Dissimilarity between each species and the single closest in a community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniqueness(comm, tree, distance, relative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniqueness_+3A_comm">comm</code></td>
<td>
<p>A sites x species matrix, with either abundance or incidence data. If missing, the uniqueness using the full tree or distance matrix is calculated.</p>
</td></tr>
<tr><td><code id="uniqueness_+3A_tree">tree</code></td>
<td>
<p>A phylo or hclust object (used only for PD or FD) or alternatively a species x traits matrix or data.frame to build a functional tree.</p>
</td></tr>
<tr><td><code id="uniqueness_+3A_distance">distance</code></td>
<td>
<p>A dist object representing the phylogenetic or functional distance between species.</p>
</td></tr>
<tr><td><code id="uniqueness_+3A_relative">relative</code></td>
<td>
<p>A boolean (T/F) indicating whether uniqueness should be relative to the maximum distance between any two species in the tree or distance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is equivalent to the originality measure of Mouillot et al. (2013).
</p>


<h3>Value</h3>

<p>A matrix of sites x species values.
</p>


<h3>References</h3>

<p>Mouillot, D., Graham, N.A., Villeger, S., Mason, N.W. &amp; Bellwood, D.R. (2013) A functional approach reveals community responses to disturbances. Trends in Ecology and Evolution, 28: 167-177.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm &lt;- matrix(c(1,2,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,1,0,1), nrow = 4, byrow = TRUE)
distance &lt;- dist(c(1:5), method="euclidean")
tree &lt;- hclust(distance, method="average")

uniqueness(tree = tree)
uniqueness(distance = distance)
uniqueness(comm, tree)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
