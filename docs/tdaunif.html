<!DOCTYPE html><html><head><title>Help for package tdaunif</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tdaunif}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arch-spirals'><p>Sample (with noise) from archimedean spirals and swiss rolls</p></a></li>
<li><a href='#circles'><p>Sample (with noise) from circles</p></a></li>
<li><a href='#disks'><p>Sample (with noise) from disk</p></a></li>
<li><a href='#ellipses'><p>Sample (with noise) from ellipses</p></a></li>
<li><a href='#klein-bottles'><p>Sample (with noise) from Klein bottles</p></a></li>
<li><a href='#lemniscates'><p>Sample (with noise) from lemniscates (figure eights)</p></a></li>
<li><a href='#noise'><p>Add noise to a sample</p></a></li>
<li><a href='#real-projective-planes'><p>Sample (with noise) from real projective planes</p></a></li>
<li><a href='#rejection-samplers'><p>Custom uniform rejection samplers</p></a></li>
<li><a href='#sphere'><p>Sample (with noise) from a sphere</p></a></li>
<li><a href='#stratified-samplers'><p>Stratified sample of any unit dimensional space</p></a></li>
<li><a href='#tdaunif'><p><strong>tdaunif</strong>: Uniform manifold samplers for topological data analysis</p></a></li>
<li><a href='#tori'><p>Sample (with noise) from tori</p></a></li>
<li><a href='#trefoil'><p>Sample (with noise) from trefoil knot</p></a></li>
<li><a href='#triangles'><p>Sample (with noise) from planar triangles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Uniform Manifold Samplers for Topological Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Uniform random samples from simple manifolds, sometimes with noise,
    are commonly used to test topological data analytic (TDA) tools.
    This package includes samplers powered by two techniques: analytic
    volume-preserving parameterizations, as employed by Arvo (1995)
    &lt;<a href="https://doi.org/10.1145%2F218380.218500">doi:10.1145/218380.218500</a>&gt;, and rejection sampling, as employed by
    Diaconis, Holmes, and Shahshahani (2013) &lt;<a href="https://doi.org/10.1214%2F12-IMSCOLL1006">doi:10.1214/12-IMSCOLL1006</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, vdiffr (&ge; 0.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tdaverse.github.io/tdaunif/">https://tdaverse.github.io/tdaunif/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tdaverse/tdaunif/issues">https://github.com/tdaverse/tdaunif/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-09 20:29:41 UTC; jasoncorybrunson</td>
</tr>
<tr>
<td>Author:</td>
<td>Jason Cory Brunson [aut, cre],
  Brandon Demkowicz [aut],
  Sanmati Choudhary [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jason Cory Brunson &lt;cornelioid@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-10 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='arch-spirals'>Sample (with noise) from archimedean spirals and swiss rolls</h2><span id='topic+arch-spirals'></span><span id='topic+sample_arch_spiral'></span><span id='topic+sample_swiss_roll'></span>

<h3>Description</h3>

<p>These functions generate uniform samples from archimedean
spirals in 2-dimensional space or from swiss rolls in 3-dimensional space,
optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_arch_spiral(n, ar = 1, arms = 1L, min_wrap = 0, max_wrap = 1, sd = 0)

sample_swiss_roll(
  n,
  ar = 1,
  arms = 1L,
  min_wrap = 0,
  max_wrap = 1,
  width = 2 * pi,
  sd = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arch-spirals_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="arch-spirals_+3A_ar">ar</code></td>
<td>
<p>Aspect ratio of spiral (ratio of width/height)</p>
</td></tr>
<tr><td><code id="arch-spirals_+3A_arms">arms</code></td>
<td>
<p>Number of spiral arms.</p>
</td></tr>
<tr><td><code id="arch-spirals_+3A_min_wrap">min_wrap</code></td>
<td>
<p>The wrap of the spiral from which sampling begins.</p>
</td></tr>
<tr><td><code id="arch-spirals_+3A_max_wrap">max_wrap</code></td>
<td>
<p>The wrap of the spiral at which sampling ends.</p>
</td></tr>
<tr><td><code id="arch-spirals_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
<tr><td><code id="arch-spirals_+3A_width">width</code></td>
<td>
<p>Width of the swiss roll (with respect to the radius of the
spiral at one wrap).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The archimedean spiral starts at the origin and wraps around itself such that
radial distances between all the spiral branches are equal. The specific
parameterization was taken from Koeller (2002). The uniform sample is
generated through a rejection sampling process as described by Diaconis,
Holmes, and Shahshahani (2013).
</p>
<p>The swiss roll sampler is patterned after one in
<a href="https://lvdmaaten.github.io/drtoolbox/">drtoolbox</a> and extended from the
archimedean spiral sampler.
</p>


<h3>References</h3>

<p>Koeller, J. (2002). Spirals. Retrieved July 18, 2019, from
<a href="http://www.mathematische-basteleien.de/spiral.htm">http://www.mathematische-basteleien.de/spiral.htm</a>
</p>
<p>P Diaconis, S Holmes, and M Shahshahani (2013) Sampling from a Manifold.
<em>Advances in Modern Statistical Theory and Applications: A Festschrift in
honor of Morris L. Eaton</em>, 102&ndash;125. doi: <a href="https://doi.org/10.1214/12-IMSCOLL1006">10.1214/12-IMSCOLL1006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(77151L)

#Uniformly sampled archimedean spiral in 2-space, with 1 wrap
x &lt;- sample_arch_spiral(360, min_wrap = 0, max_wrap = 1)
plot(x, asp = 1, pch = 19, cex = .5)

#Uniformly sampled archimedean spiral in 2-space, with 1 wrap 
#and aspect ratio of 2:1
x &lt;- sample_arch_spiral(360, ar = 2, min_wrap = 0, max_wrap = 1)
plot(x, asp = 1, pch = 19, cex = .5)

#Uniformly sampled archimedean spiral in 2-space, with 1 wrap 
#and aspect ratio of 1:2
x &lt;- sample_arch_spiral(360, ar = 0.5, min_wrap = 0, max_wrap = 1)
plot(x, asp = 1, pch = 19, cex = .5)

#Uniformly sampled archimedean spiral in 2-space, with 5 wraps
x &lt;- sample_arch_spiral(360, min_wrap = 0, max_wrap = 5)
plot(x, asp = 1, pch = 19, cex = .5)

#Uniformly sampled archimedean spiral in 2-space, with 5 wraps and starting from
#2 wraps
x &lt;- sample_arch_spiral(360, min_wrap = 2, max_wrap = 5)
plot(x, asp = 1, pch = 19, cex = .5)

#Uniformly sampled archimedean spiral, from 1 to 2 wraps, with 3 arms
x &lt;- sample_arch_spiral(360, arms = 3, min_wrap = 1, max_wrap = 2)
plot(x, asp = 1, pch = 19, cex = .5)

#Uniformly sampled archimedean spiral in 2-space, with 1 wrap and noise with a
#standard deviation of 0.1
x &lt;- sample_arch_spiral(360, min_wrap = 0, max_wrap = 1, sd = 0.1)
plot(x, asp = 1, pch = 19, cex = .5)

#Uniformly sampled swiss roll in 3-space, from 0 to 1 wraps and width 2*pi
x &lt;- sample_swiss_roll(720, width = 2*pi)
pairs(x, asp = 1, pch = 19, cex = .5)
pca &lt;- prcomp(x)
plot(x %*% pca$rotation, asp = 1, pch = 19, cex = .5)

#Uniformly sampled swiss roll in 3-space, from 0 to 1 wraps and width 2*pi
x &lt;- sample_swiss_roll(720, ar = 2, width = 2*pi)
pairs(x, asp = 1, pch = 19, cex = .5)
pca &lt;- prcomp(x)
plot(x %*% pca$rotation, asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='circles'>Sample (with noise) from circles</h2><span id='topic+circles'></span><span id='topic+sample_circle'></span><span id='topic+sample_circles_interlocked'></span>

<h3>Description</h3>

<p>These functions generate uniform and stratified samples from
configurations of circles of radius 1 in 2- or 3-dimensional space,
optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_circle(n, bins = 1L, sd = 0)

sample_circles_interlocked(n, bins = 1L, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circles_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="circles_+3A_bins">bins</code></td>
<td>
<p>Number of intervals to stratify by. Default set to 1, which
generates a uniform sample.</p>
</td></tr>
<tr><td><code id="circles_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>sample_circle()</code> uses the usual sinusoidal parameterization
from the unit interval to the unit circle.
</p>
<p>The function <code>sample_circles_interlocked()</code> effectively samples from a pair
of circles and rotates them in 3-dimensional space so that they are
interlocked (perpendicular to each other).
</p>
<p>Both functions are length-preserving and admit stratification. If <code>bins = 2</code>,
the stratification for the latter function will simply be between the two
interlocked circles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(14312L)

# circle in 2-space
x &lt;- sample_circle(120, sd = .1)
plot(x, asp = 1, pch = 19, cex = .5)

# interlocked circles in 3-space
x &lt;- sample_circles_interlocked(120, sd = .1)
pairs(x, asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='disks'>Sample (with noise) from disk</h2><span id='topic+disks'></span><span id='topic+sample_disk'></span>

<h3>Description</h3>

<p>These functions generate uniform samples from a disk in
2-dimensional space, optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_disk(n, bins = 1L, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disks_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="disks_+3A_bins">bins</code></td>
<td>
<p>Number of intervals per dimension to stratify by. Default set to
1, which generates a uniform sample.</p>
</td></tr>
<tr><td><code id="disks_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sample is generated by an area-preserving parameterization of
the disk. This parameterization was derived through the method for sampling
2-manifolds as described by Arvo (2001).
</p>


<h3>References</h3>

<p>J Arvo (2001) Stratified Sampling of 2-Manifolds. <em>SIGRAPH 2001 (State of the
Art in Monte Carlo Ray Tracing for Realistic Image Synthesis)</em>, Course Notes,
Vol. 29. <a href="https://www.cs.princeton.edu/courses/archive/fall04/cos526/papers/course29sig01.pdf">https://www.cs.princeton.edu/courses/archive/fall04/cos526/papers/course29sig01.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(99812L)

# Uniformly sampled unit disk in 2-space
x &lt;- sample_disk(1800, sd = 0)
plot(x, asp = 1, pch = 19, cex = .5)

# Uniformly sampled unit disk in 2-space with Gaussian noise
x &lt;- sample_disk(1800, sd = .1)
plot(x, asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='ellipses'>Sample (with noise) from ellipses</h2><span id='topic+ellipses'></span><span id='topic+sample_ellipse'></span><span id='topic+sample_cylinder_elliptical'></span>

<h3>Description</h3>

<p>These functions generate uniform samples from configurations of
ellipses of major or minor radius 1 in 2- or 3-dimensional space,
optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_ellipse(n, ar = 1, sd = 0)

sample_cylinder_elliptical(n, ar = 1, width = 1, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipses_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_ar">ar</code></td>
<td>
<p>Aspect ratio for an ellipse (ratio of major and minor radii).</p>
</td></tr>
<tr><td><code id="ellipses_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_width">width</code></td>
<td>
<p>Width of the cylinder (with respect to the fixed radius of the
ellipse).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>sample_ellipse()</code> uses the usual sinusoidal parameterization
from the unit interval to an ellipse with radii 1 and <code>1/ar</code>. The uniform
sample is generated through a rejection sampling process as described by
Diaconis, Holmes, and Shahshahani (2013).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(97205L)

# ellipses in 2-space
x &lt;- sample_ellipse(120, ar = 6)
plot(x, asp = 1, pch = 19, cex = .5)
x &lt;- sample_ellipse(120, ar = 1/6)
plot(x, asp = 1, pch = 19, cex = .5)

# ellipses in 2-space
x &lt;- sample_ellipse(120, ar = 6, sd = .1/6)
plot(x, asp = 1, pch = 19, cex = .5)
x &lt;- sample_ellipse(120, ar = 1/6, sd = .1)
plot(x, asp = 1, pch = 19, cex = .5)

# cylinders in 3-space
x &lt;- sample_cylinder_elliptical(120, ar = 1)
pairs(x, asp = 1, pch = 19, cex = .5)
x &lt;- sample_cylinder_elliptical(120, ar = 3, width = 2*pi)
pairs(x, asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='klein-bottles'>Sample (with noise) from Klein bottles</h2><span id='topic+klein-bottles'></span><span id='topic+sample_klein_tube'></span><span id='topic+sample_klein_flat'></span>

<h3>Description</h3>

<p>These functions generate uniform samples from Klein bottles in
4-dimensional space, optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_klein_tube(n, ar = 2, sd = 0)

sample_klein_flat(n, ar = 1, bump = 0.1, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="klein-bottles_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="klein-bottles_+3A_ar">ar</code></td>
<td>
<p>Aspect ratio for Möbius tube Klein bottle (ratio of major and minor
radii) or flat torus-based Klein bottle (ratio of scale factors).</p>
</td></tr>
<tr><td><code id="klein-bottles_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
<tr><td><code id="klein-bottles_+3A_bump">bump</code></td>
<td>
<p>Bump constant for the flat torus-based Klein bottle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>sample_klein_tube()</code> uses the Möbius tube parameterization
documented at the <a href="https://mathcurve.com/surfaces.gb/klein/klein.shtml">Encyclopédie des Formes Mathématiques Remarquables</a>.
</p>
<p>The function <code>sample_klein_flat()</code> uses a flat parameterization based on that
of the torus, as presented on
<a href="https://en.wikipedia.org/wiki/Klein_bottle#4-D_non-intersecting">Wikipedia</a>.
</p>
<p>Both uniform samples are generated through a rejection sampling process as
described by Diaconis, Holmes, and Shahshahani (2013).
</p>


<h3>References</h3>

<p>P Diaconis, S Holmes, and M Shahshahani (2013) Sampling from a Manifold.
<em>Advances in Modern Statistical Theory and Applications: A Festschrift in
honor of Morris L. Eaton</em>, 102&ndash;125. doi: <a href="https://doi.org/10.1214/12-IMSCOLL1006">10.1214/12-IMSCOLL1006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(834L)

# Klein bottle tube embedding in 4-space
x &lt;- sample_klein_tube(120, sd = .05)
pairs(x, asp = 1, pch = 19, cex = .5)

# Klein bottle flat torus-based embedding in 4-space
x &lt;- sample_klein_flat(120, sd = .05)
pairs(x, asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='lemniscates'>Sample (with noise) from lemniscates (figure eights)</h2><span id='topic+lemniscates'></span><span id='topic+sample_lemniscate_gerono'></span>

<h3>Description</h3>

<p>These functions generate uniform samples from lemniscates
(figure eights) in 2-dimensional space, optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_lemniscate_gerono(n, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lemniscates_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="lemniscates_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use a simple parameterization from the unit circle
to the lemniscate of Gerono, as presented on
<a href="https://en.wikipedia.org/wiki/Lemniscate_of_Gerono">Wikipedia</a>. The
uniform sample is generated through a rejection sampling process as
described by Diaconis, Holmes, and Shahshahani (2013).
</p>


<h3>References</h3>

<p>P Diaconis, S Holmes, and M Shahshahani (2013) Sampling from a Manifold.
<em>Advances in Modern Statistical Theory and Applications: A Festschrift in
honor of Morris L. Eaton</em>, 102&ndash;125. doi: <a href="https://doi.org/10.1214/12-IMSCOLL1006">10.1214/12-IMSCOLL1006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12051L)

# Uniformly sampled figure eight in 2-space
x &lt;- sample_lemniscate_gerono(720)
plot(x, asp = 1, pch = 19, cex = .5)

# Naively sampled figure eight, for comparison
theta &lt;- runif(n = 720, min = 0, max = 2*pi)
x_naive &lt;- cbind(x = cos(theta), y &lt;- cos(theta) * sin(theta))
plot(x_naive, asp = 1, pch = 19, cex = .5)

# Uniformly sampled figure eight in 2-space with Gaussian noise
x &lt;- sample_lemniscate_gerono(720, 0.1)
plot(x, asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='noise'>Add noise to a sample</h2><span id='topic+noise'></span><span id='topic+add_noise'></span>

<h3>Description</h3>

<p>This function adds Gaussian noise to coordinate data contained
in a matrix. It is called by samplers to introduce noise when <code>sd</code> is
passed a positive value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_noise(x, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noise_+3A_x">x</code></td>
<td>
<p>A matrix of row coordinates.</p>
</td></tr>
<tr><td><code id="noise_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
</table>

<hr>
<h2 id='real-projective-planes'>Sample (with noise) from real projective planes</h2><span id='topic+real-projective-planes'></span><span id='topic+sample_projective_plane'></span>

<h3>Description</h3>

<p>These functions generate uniform samples from real projective
planes in 4-dimensional space, optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_projective_plane(n, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="real-projective-planes_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="real-projective-planes_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The real projective plane only embeds into a Euclidean space of
dimension at least 4. This embedding is adapted from
<a href="https://en.wikipedia.org/wiki/Real_projective_plane#Embedding_into_4-dimensional_space">Wikipedia</a>.
The uniform sample is generated through a rejection sampling process as
described by Diaconis, Holmes, and Shahshahani (2013).
</p>


<h3>References</h3>

<p>P Diaconis, S Holmes, and M Shahshahani (2013) Sampling from a Manifold.
<em>Advances in Modern Statistical Theory and Applications: A Festschrift in
honor of Morris L. Eaton</em>, 102&ndash;125. doi: <a href="https://doi.org/10.1214/12-IMSCOLL1006">10.1214/12-IMSCOLL1006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(22764L)

# real projective plane embedding in 4-space
x &lt;- sample_projective_plane(120)
pairs(x, asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='rejection-samplers'>Custom uniform rejection samplers</h2><span id='topic+rejection-samplers'></span><span id='topic+make_rejection_sampler'></span>

<h3>Description</h3>

<p>These functions create rejection samplers, and uniform manifold
samplers based on them, using user-provided parameterization and Jacobian
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_rejection_sampler(
  parameterization,
  jacobian,
  min_params,
  max_params,
  max_jacobian
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rejection-samplers_+3A_parameterization">parameterization</code></td>
<td>
<p>A function that takes parameter vector arguments and
returns a matrix of coordinates.</p>
</td></tr>
<tr><td><code id="rejection-samplers_+3A_jacobian">jacobian</code></td>
<td>
<p>A function that takes parameter vector arguments and returns
a vector of Jacobian determinants.</p>
</td></tr>
<tr><td><code id="rejection-samplers_+3A_min_params">min_params</code>, <code id="rejection-samplers_+3A_max_params">max_params</code></td>
<td>
<p>(Optionally named) vectors of minimum and
maximum values of the parameters, used for uniform sampling.</p>
</td></tr>
<tr><td><code id="rejection-samplers_+3A_max_jacobian">max_jacobian</code></td>
<td>
<p>An (ideally sharp) upper bound on the Jacobian
determinant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rejection sampling technique of Diaconis, Holmes, and
Shahshahani (2013) uses a parameterized embedding from a parameter space to
a coordinate space and relies on a formula for its jacobian determinant.
The <code>parameterization</code> must be a function that takes vector arguments of
equal length and returns a coordinate matrix of the same number of rows.
The <code>jacobian</code> must be a function that takes the same arguments and returns
a scalar value. The parameters must range from their respective minima
<code>min_params</code> to their respective maxima <code>max_params</code>. <code>max_jacobian</code> must
be provided, though it may be larger than the theoretical maximum of the
jacobian determinant.
</p>


<h3>References</h3>

<p>P Diaconis, S Holmes, and M Shahshahani (2013) Sampling from a Manifold.
<em>Advances in Modern Statistical Theory and Applications: A Festschrift in
honor of Morris L. Eaton</em>, 102&ndash;125. doi: <a href="https://doi.org/10.1214/12-IMSCOLL1006">10.1214/12-IMSCOLL1006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(47569L)

# parameterization and Jacobian for Klein bottle tube embedding
klein_parameterization &lt;- function(theta, phi) {
  cbind(
    w = (1 + .5 * cos(theta)) * cos(phi),
    x = (1 + .5 * cos(theta)) * sin(phi),
    y = .5 * sin(theta) * cos(phi/2),
    z = .5 * sin(theta) * sin(phi/2)
  )
}
klein_jacobian &lt;- function(theta, phi) {
  unname(.5 * sqrt((1 + .5 * cos(theta)) ^ 2 + (.5 * .5 * sin(theta)) ^ 2))
}
# custom sampler based on these functions
klein_sampler &lt;- make_rejection_sampler(
  klein_parameterization,
  klein_jacobian,
  max_params = c(theta = 2*pi, phi = 2*pi),
  max_jacobian = klein_jacobian(cbind(theta = 0))
)
# compare custom sampler to `sample_klein_tube()`
pairs(klein_sampler(n = 360), asp = 1, pch = 19, cex = .5)
pairs(sample_klein_tube(n = 360, ar = 2), asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='sphere'>Sample (with noise) from a sphere</h2><span id='topic+sphere'></span><span id='topic+sample_2hemisphere'></span><span id='topic+sample_2sphere'></span><span id='topic+sample_sphere'></span>

<h3>Description</h3>

<p>These functions generate uniform samples from a sphere of radius
1 and dimension 2 in 3-space, or in arbitrary dimension in
1-higher-dimensional space, optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_2hemisphere(n, bins = 1L, sd = 0)

sample_2sphere(n, bins = 1L, sd = 0)

sample_sphere(n, dim = 1, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphere_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="sphere_+3A_bins">bins</code></td>
<td>
<p>Number of intervals per dimension to stratify by. Default set to
1, which generates a uniform sample.</p>
</td></tr>
<tr><td><code id="sphere_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
<tr><td><code id="sphere_+3A_dim">dim</code></td>
<td>
<p>Dimension of the sphere.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>sample_sphere()</code> is adapted from <code>sphereUnif()</code> in the <strong>TDA</strong>
package. It uses <code><a href="stats.html#topic+Normal">stats::rnorm()</a></code> to sample from a multivariate Gaussian and
normalizes the resulting coordinates.
</p>
<p>The function <code>sample_2hemisphere()</code> uses an area-preserving parameterization
of the upper hemisphere, and <code>sample_2sphere()</code> uses two of these samples,
one reflected over the horizontal plane, to produce a sample from a sphere.
The parameterization was derived through the method for sampling 2-manifolds
as described by Arvo (2001).
</p>


<h3>References</h3>

<p>J Arvo (2001) Stratified Sampling of 2-Manifolds. <em>SIGRAPH 2001 (State of the
Art in Monte Carlo Ray Tracing for Realistic Image Synthesis)</em>, Course Notes,
Vol. 29. <a href="https://www.cs.princeton.edu/courses/archive/fall04/cos526/papers/course29sig01.pdf">https://www.cs.princeton.edu/courses/archive/fall04/cos526/papers/course29sig01.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(50253L)

# 1-sphere in 2-space
x &lt;- sample_sphere(120, dim = 1, sd = .1)
pairs(x, asp = 1, pch = 19, cex = .5)

# 2-sphere in 3-space
x &lt;- sample_sphere(120, dim = 2, sd = .1)
pairs(x, asp = 1, pch = 19, cex = .5)

# 3-sphere in 4-space
x &lt;- sample_sphere(120, dim = 3, sd = .1)
pairs(x, asp = 1, pch = 19, cex = .5)

# 4-sphere in 5-space
x &lt;- sample_sphere(120, dim = 4, sd = .1)
pairs(x, asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='stratified-samplers'>Stratified sample of any unit dimensional space</h2><span id='topic+stratified-samplers'></span><span id='topic+sample_strat_segment'></span><span id='topic+sample_strat_square'></span><span id='topic+sample_strat_cube'></span><span id='topic+sample_stratify'></span>

<h3>Description</h3>

<p>These functions generate stratified samples of any dimension
including the unit line segment in 1-dimensional space, the unit square in
2-space, the unit cube in 3-space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_strat_segment(n, bins)

sample_strat_square(n, bins)

sample_strat_cube(n, bins)

sample_stratify(n, bins, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratified-samplers_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="stratified-samplers_+3A_bins">bins</code></td>
<td>
<p>Number of intervals per dimension for the stratification.</p>
</td></tr>
<tr><td><code id="stratified-samplers_+3A_dim">dim</code></td>
<td>
<p>Dimensional space of sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(Details.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(28522L)

#Stratified sample in 1-dimension with 10 intervals
values &lt;- sample_strat_segment(13, 10)
x &lt;- cbind(values, rep(0, 13))
plot(x, asp = 1, pch = 19, cex = .5, xlab = 'x', ylab = '')
segments(x0 = seq(0, 1, .1), y0 = -1, y1 = 1)

#Stratified sample of a unit square with 100 cells
x &lt;- sample_strat_square(110, 10)
plot(x, asp = 1, pch = 19, cex = .5, xlab = 'x', ylab = 'y')
segments(x0 = seq(0, 1, .1), y0 = 0, y1 = 1)
segments(y0 = seq(0, 1, .1), x0 = 0, x1 = 1)

#Stratified sample of a unit cube with 27 cells
x &lt;- sample_strat_cube(27, 3)
#Bird's eye view of the cube
plot(x[, c(1, 2)], asp = 1, pch = 19, cex = .5, xlab = 'x', ylab = 'y')
segments(x0 = seq(0, 1, 1/3), y0 = 0, y1 = 1)
segments(y0 = seq(0, 1, 1/3), x0 = 0, x1 = 1)
#Side view of the cube
plot(x[,c(2,3)], asp = 1, pch = 19, cex = .5, xlab = 'y', ylab = 'z')
segments(x0 = seq(0,1,1/3),y0 = 0, y1 = 1)
segments(y0 = seq(0,1,1/3),x0 = 0, x1 = 1)

#All of the same illustrations, but only using sample_stratify()

#Stratified sample in 1-dimension with 10 intervals
values &lt;- sample_stratify(13,10,1)
x &lt;- cbind(values,rep(0,13))
plot(x, asp = 1, pch = 19, cex = .5, xlab = 'x', ylab = '')
segments(x0 = seq(0,1,.1),y0 = -1, y1 = 1)

#Stratified sample of a unit square with 100 cells
x &lt;- sample_stratify(110,10, 2)
plot(x, asp = 1, pch = 19, cex = .5, xlab = 'x', ylab = 'y')
segments(x0 = seq(0,1,.1),y0 = 0, y1 = 1)
segments(y0 = seq(0,1,.1),x0 = 0, x1 = 1)

#Stratified sample of a unit cube with 27 cells
x &lt;- sample_stratify(27,3, 3)
#Bird's eye view of the cube
plot(x[,c(1,2)], asp = 1, pch = 19, cex = .5, xlab = 'x', ylab = 'y')
segments(x0 = seq(0,1,1/3),y0 = 0, y1 = 1)
segments(y0 = seq(0,1,1/3),x0 = 0, x1 = 1)
#Side view of the cube
plot(x[,c(2,3)], asp = 1, pch = 19, cex = .5, xlab = 'y', ylab = 'z')
segments(x0 = seq(0,1,1/3),y0 = 0, y1 = 1)
segments(y0 = seq(0,1,1/3),x0 = 0, x1 = 1)

#Stratified sample of a unit 4-cube with 81 cells
x &lt;- sample_stratify(81, 3, 4)
#One view of the cube
plot(x[,c(1,2)], asp = 1, pch = 19, cex = .5, xlab = 'x', ylab = 'y')
segments(x0 = seq(0,1,1/3),y0 = 0, y1 = 1)
segments(y0 = seq(0,1,1/3),x0 = 0, x1 = 1)
#Another view of the cube
plot(x[,c(2,3)], asp = 1, pch = 19, cex = .5, xlab = 'y', ylab = 'z')
segments(x0 = seq(0,1,1/3),y0 = 0, y1 = 1)
segments(y0 = seq(0,1,1/3),x0 = 0, x1 = 1)
</code></pre>

<hr>
<h2 id='tdaunif'><strong>tdaunif</strong>: Uniform manifold samplers for topological data analysis</h2><span id='topic+tdaunif'></span><span id='topic+tdaunif-package'></span>

<h3>Description</h3>

<p>Generate uniform random samples from embedded manifolds,
optionally with noise.
</p>


<h3>Details</h3>

<p>This package assembles functions that generate samples of points uniformly
from the surfaces of embedded manifolds. An <em>embedding</em> is a one-to-one
continuous map <code class="reqn">f:M\to X</code> from a manifold <code class="reqn">M</code> to a Euclidean
coordinate space <code class="reqn">X</code>, and each function relies on a <em>parameterization</em> of
<code class="reqn">M</code> given by a continuous bijective function <code class="reqn">p:S\to f(M)</code> that may
identify some points of <code class="reqn">s</code> (boundary or interior) to produce the
topology of <code class="reqn">M</code>. (This means that the inverse of <code class="reqn">p</code> may not be
continuous.)
</p>
<p>Sampling points <code class="reqn">P</code> uniformly from <code class="reqn">S</code> and mapping the sample to
<code class="reqn">f(M)</code> may produce a non-uniform sample <code class="reqn">p(P)</code> due to differences in
the local sampling rate per unit interior (length, area, volume, etc.),
quantified as the Jacobian (higher-order derivative) of <code class="reqn">p</code>. <strong>tdaunif</strong>
uses two techniques to correct for this:
</p>

<ul>
<li><p> The more numerical (brute-force) technique is to compute the Jacobian on
the parameter space and oversample locally at a rate proportional to the
Jacobian. This oversampling is done via rejection sampling as illustrated by
Diaconis, Holmes, and Shahshahani (2013).
</p>
</li>
<li><p> The more analytic technique is to invert the Jacobian symbolically in order
to define an interior-preserving parameterization <code class="reqn">q:S\to f(M)</code>, as
illustrated for 2-manifolds by Arvo (2001). Sampling <code class="reqn">P</code> uniformly on
<code class="reqn">S</code> then produces a uniform sample <code class="reqn">q(P)</code> on <code class="reqn">f(M)</code>. The
interior-preserving map also enables stratified sampling on the manifold via
stratification of the parameter space.
</p>
</li></ul>

<p>Multivariate Gaussian noise in the coordinate space can be added to any
sample.
</p>


<h3>Author(s)</h3>

<p>Jason Cory Brunson
</p>
<p>Brandon Demkowicz
</p>
<p>Sanmati Choudhary
</p>


<h3>References</h3>

<p>J Arvo (2001) Stratified Sampling of 2-Manifolds. <em>SIGRAPH 2001 (State of the
Art in Monte Carlo Ray Tracing for Realistic Image Synthesis)</em>, Course Notes,
Vol. 29. <a href="https://www.cs.princeton.edu/courses/archive/fall04/cos526/papers/course29sig01.pdf">https://www.cs.princeton.edu/courses/archive/fall04/cos526/papers/course29sig01.pdf</a>
</p>
<p>P Diaconis, S Holmes, and M Shahshahani (2013) Sampling from a Manifold.
<em>Advances in Modern Statistical Theory and Applications: A Festschrift in
honor of Morris L. Eaton</em>, 102&ndash;125. doi: <a href="https://doi.org/10.1214/12-IMSCOLL1006">10.1214/12-IMSCOLL1006</a>
</p>

<hr>
<h2 id='tori'>Sample (with noise) from tori</h2><span id='topic+tori'></span><span id='topic+sample_torus_tube'></span><span id='topic+sample_tori_interlocked'></span><span id='topic+sample_torus_flat'></span>

<h3>Description</h3>

<p>These functions generate uniform samples from configurations of
tori of primary radius 1 in 3-dimensional space, optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_torus_tube(n, ar = 2, sd = 0)

sample_tori_interlocked(n, ar = 2, sd = 0)

sample_torus_flat(n, ar = 1, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tori_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="tori_+3A_ar">ar</code></td>
<td>
<p>Aspect ratio for tube torus (ratio of major and minor radii) or
flat torus (ratio of scale factors).</p>
</td></tr>
<tr><td><code id="tori_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>sample_torus_tube()</code> uses the tubular parameterization into
3-dimensional space documented at
<a href="https://mathworld.wolfram.com/Torus.html">MathWorld</a>.
</p>
<p>The function <code>sample_torus_flat()</code> uses a flat parameterization (having zero
Gaussian curvature) into 4-dimensional space, as presented on
<a href="https://en.wikipedia.org/wiki/Torus#Flat_torus">Wikipedia</a>.
</p>
<p>The function <code>sample_tori_interlocked()</code> samples from two tubular tori
interlocked in the same way as <code><a href="#topic+sample_circles_interlocked">sample_circles_interlocked()</a></code>.
</p>
<p>All uniform samples are generated through a rejection sampling process as
described by Diaconis, Holmes, and Shahshahani (2013).
</p>


<h3>References</h3>

<p>P Diaconis, S Holmes, and M Shahshahani (2013) Sampling from a Manifold.
<em>Advances in Modern Statistical Theory and Applications: A Festschrift in
honor of Morris L. Eaton</em>, 102&ndash;125. doi: <a href="https://doi.org/10.1214/12-IMSCOLL1006">10.1214/12-IMSCOLL1006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(33183L)

# torus tube embedding in 3-space
x &lt;- sample_torus_tube(120, sd = .05)
pairs(x, asp = 1, pch = 19, cex = .5)

# torus flat embedding in 4-space
x &lt;- sample_torus_flat(120, sd = .05)
pairs(x, asp = 1, pch = 19, cex = .5)

# interlocked tubular tori in 3-space
x &lt;- sample_tori_interlocked(360, ar = 6, sd = .01)
pairs(x, asp = 1, pch = 19, cex = .5)
</code></pre>

<hr>
<h2 id='trefoil'>Sample (with noise) from trefoil knot</h2><span id='topic+trefoil'></span><span id='topic+sample_trefoil'></span>

<h3>Description</h3>

<p>These functions generate uniform samples from trefoil knot in
3-dimensional space, optionally with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_trefoil(n, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trefoil_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="trefoil_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trefoil knot is the simplest nontrivial knot and contains three
unique crossings in three dimensional space. This uniform sample is
generated by rejection sampling. This process allows for simulation of
random samples from the trefoil knot distribution, by using random samples
from a more convenient distribution. It applies rejection/acceptance
criterion such that the samples that are accepted are to be distributed as
if they were from the target distribution. The uniform sample is generated
through a rejection sampling process as described by Diaconis, Holmes, and
Shahshahani (2013).
</p>


<h3>References</h3>

<p>P Diaconis, S Holmes, and M Shahshahani (2013) Sampling from a Manifold.
<em>Advances in Modern Statistical Theory and Applications: A Festschrift in
honor of Morris L. Eaton</em>, 102&ndash;125. doi: <a href="https://doi.org/10.1214/12-IMSCOLL1006">10.1214/12-IMSCOLL1006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(73398L)

# Uniformly sampled trefoil knot in 3-space
x &lt;- sample_trefoil(180)
pairs(x, asp = 1, pch = 19, cex = .5, col = "#00000077")

# Uniformly sampled trefoil knot in 3-space, with Gaussian noise
x &lt;- sample_trefoil(180, sd = .1)
pairs(x, asp = 1, pch = 19, cex = .5, col = "#00000077")
</code></pre>

<hr>
<h2 id='triangles'>Sample (with noise) from planar triangles</h2><span id='topic+triangles'></span><span id='topic+sample_triangle_planar'></span>

<h3>Description</h3>

<p>This function generates uniform and stratified samples from
configurations of planar triangles in 2-dimensional space, optionally with
noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_triangle_planar(n, triangle, bins = 1, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangles_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="triangles_+3A_triangle">triangle</code></td>
<td>
<p>The (x,y) coordinates of the vertices of a triangle,
formatted in a 2x3 matrix</p>
</td></tr>
<tr><td><code id="triangles_+3A_bins">bins</code></td>
<td>
<p>Number of intervals per dimension to stratify by. Default set to
1, which generates a uniform sample.</p>
</td></tr>
<tr><td><code id="triangles_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of (independent multivariate) Gaussian noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sample is generated by an area-preserving parameterization of
the planar triangle. This parameterization was derived through the method
for sampling 2-manifolds as described by Arvo (2001).
</p>


<h3>References</h3>

<p>J Arvo (2001) Stratified Sampling of 2-Manifolds. <em>SIGRAPH 2001 (State of the
Art in Monte Carlo Ray Tracing for Realistic Image Synthesis)</em>, Course Notes,
Vol. 29. <a href="https://www.cs.princeton.edu/courses/archive/fall04/cos526/papers/course29sig01.pdf">https://www.cs.princeton.edu/courses/archive/fall04/cos526/papers/course29sig01.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23004L)

#Uniformly sampled equilateral planar triangle in 2-space
equilateral_triangle &lt;- cbind(c(0,0), c(0.5,sqrt(3)/2), c(1,0))
x &lt;-  sample_triangle_planar(10000, equilateral_triangle)
plot(x, asp = 1, pch = 19, cex = .25)

#Stratified sample of equilateral planar triangle in 2-space with 100 bins
equilateral_triangle &lt;- cbind(c(0,0), c(0.5,sqrt(3)/2), c(1,0))
x &lt;-  sample_triangle_planar(10000, equilateral_triangle, bins = 100)
plot(x, asp = 1, pch = 19, cex = .25)

#Uniformly sampled equilateral planar triangle in 2-space with Gaussian noise
equilateral_triangle &lt;- cbind(c(0,0), c(0.5,sqrt(3)/2), c(1,0))
x &lt;-  sample_triangle_planar(10000, equilateral_triangle, sd = .1)
plot(x, asp = 1, pch = 19, cex = .25)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
