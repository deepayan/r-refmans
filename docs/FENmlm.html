<!DOCTYPE html><html><head><title>Help for package FENmlm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FENmlm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC.femlm'><p>Aikake's an information criterion</p></a></li>
<li><a href='#BIC.femlm'><p>Bayesian information criterion</p></a></li>
<li><a href='#coef.femlm'><p>Extracts the coefficients from a femlm fit</p></a></li>
<li><a href='#confint.femlm'><p>Confidence interval for parameters estimated with femlm</p></a></li>
<li><a href='#diagnostic'><p>Collinearity diagnostics for femlm objects</p></a></li>
<li><a href='#femlm'><p>Fixed effects maximum likelihood models</p></a></li>
<li><a href='#FENmlm-package'><p>Fixed Effects Nonlinear Maximum Likelihood Models</p></a></li>
<li><a href='#fitted.femlm'><p>Extracts fitted values from a femlm fit</p></a></li>
<li><a href='#formula.femlm'><p>Extract the formula of a femlm fit</p></a></li>
<li><a href='#getFE'><p>Extract the Fixed-Effects from a <code>femlm</code> estimation.</p></a></li>
<li><a href='#logLik.femlm'><p>Extracts the log-likelihood</p></a></li>
<li><a href='#model.matrix.femlm'><p>Design matrix of a femlm model</p></a></li>
<li><a href='#nobs.femlm'><p>Extract the number of observations form a femlm object</p></a></li>
<li><a href='#obs2remove'><p>Finds observations to be removed from ML estimation with factors/clusters</p></a></li>
<li><a href='#plot.femlm.allClusters'><p>Displaying the most notable fixed-effects</p></a></li>
<li><a href='#predict.femlm'><p>Predict method for femlm fits</p></a></li>
<li><a href='#print.femlm'><p>A print facility for <code>femlm</code> objects. It can compute different types of standard errors.</p></a></li>
<li><a href='#print.femlm.obs2remove'><p>Print method for femlm.obs2remove objects</p></a></li>
<li><a href='#res2table'><p>Facility to display the results of multiple <code>femlm</code> estimations.</p></a></li>
<li><a href='#res2tex'><p>Facility to export the results of multiple <code>femlm</code> estimations in a Latex table.</p></a></li>
<li><a href='#resid.femlm'><p>Extracts residuals from a femlm object</p></a></li>
<li><a href='#summary.femlm'><p>Summary of a <code>femlm</code> object. Computes different types of standard errors.</p></a></li>
<li><a href='#summary.femlm.allClusters'><p>Summary method for cluster coefficients</p></a></li>
<li><a href='#trade'><p>Trade data sample</p></a></li>
<li><a href='#update.femlm'><p>Updates a femlm estimation</p></a></li>
<li><a href='#vcov.femlm'><p>Extract the variance/covariance of a femlm fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fixed Effects Nonlinear Maximum Likelihood Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.4</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, utils, parallel, Formula, MASS, numDeriv,
Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10)</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient estimation of maximum likelihood models with multiple fixed-effects. Standard-errors can easily and flexibly be clustered and estimations exported.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Laurent Berge [aut, cre]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 06:59:50 UTC; lrberge</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laurent Berge &lt;laurent.berge@u-bordeaux.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC.femlm'>Aikake's an information criterion</h2><span id='topic+AIC.femlm'></span>

<h3>Description</h3>

<p>This function computes the AIC (Aikake's, an information criterion) from a <code><a href="#topic+femlm">femlm</a></code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="AIC.femlm_+3A_...">...</code></td>
<td>
<p>Optionally, more fitted objects.</p>
</td></tr>
<tr><td><code id="AIC.femlm_+3A_k">k</code></td>
<td>
<p>A numeric, the penalty per parameter to be used; the default k = 2 is the classical AIC (i.e. <code>AIC=-2*LL+k*nparams</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AIC is computed as:
</p>
<p style="text-align: center;"><code class="reqn">AIC = -2\times LogLikelihood + k\times nbParams</code>
</p>

<p>with k the penalty parameter.
</p>
<p>You can have more information on this crtierion on <code><a href="stats.html#topic+AIC">AIC</a></code>.
</p>


<h3>Value</h3>

<p>It return a numeric vector, with length the same as the number of objects taken as arguments.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+AIC.femlm">AIC.femlm</a></code>, <code><a href="#topic+logLik.femlm">logLik.femlm</a></code>, <code><a href="#topic+nobs.femlm">nobs.femlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two fitted models with different expl. variables:
res1 = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)
res2 = femlm(Sepal.Length ~ Petal.Width | Species, iris)

AIC(res1, res2)
BIC(res1, res2)


</code></pre>

<hr>
<h2 id='BIC.femlm'>Bayesian information criterion</h2><span id='topic+BIC.femlm'></span>

<h3>Description</h3>

<p>This function computes the BIC (Bayesian information criterion) from a <code><a href="#topic+femlm">femlm</a></code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="BIC.femlm_+3A_...">...</code></td>
<td>
<p>Optionally, more fitted objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BIC is computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">BIC = -2\times LogLikelihood + \log(nobs)\times nbParams</code>
</p>

<p>with k the penalty parameter.
</p>
<p>You can have more information on this crtierion on <code><a href="stats.html#topic+AIC">AIC</a></code>.
</p>


<h3>Value</h3>

<p>It return a numeric vector, with length the same as the number of objects taken as arguments.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+AIC.femlm">AIC.femlm</a></code>, <code><a href="#topic+logLik.femlm">logLik.femlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two fitted models with different expl. variables:
res1 = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)
res2 = femlm(Sepal.Length ~ Petal.Width | Species, iris)

AIC(res1, res2)
BIC(res1, res2)

</code></pre>

<hr>
<h2 id='coef.femlm'>Extracts the coefficients from a femlm fit</h2><span id='topic+coef.femlm'></span><span id='topic+coefficients.femlm'></span>

<h3>Description</h3>

<p>This function extracts the coefficients obtained from a model estimated with <code><a href="#topic+femlm">femlm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
coef(object, ...)

## S3 method for class 'femlm'
coefficients(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="coef.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficients are the ones that have been found to maximize the log-likelihood of the specified model. More information can be found on <code><a href="#topic+femlm">femlm</a></code> help page.
</p>
<p>Note that if the model has been estimated with clusters, to obtain the cluster coefficients, you need to use the function <code><a href="#topic+getFE">getFE</a></code>.
</p>


<h3>Value</h3>

<p>This function returns a named numeric vector.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+summary.femlm">summary.femlm</a></code>, <code><a href="#topic+confint.femlm">confint.femlm</a></code>, <code><a href="#topic+vcov.femlm">vcov.femlm</a></code>, <code><a href="#topic+res2table">res2table</a></code>, <code><a href="#topic+res2tex">res2tex</a></code>, <code><a href="#topic+getFE">getFE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, clustering by "Species"
res = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)

# the coefficients of the variables:
coef(res)

# the cluster coefficients:
getFE(res)


</code></pre>

<hr>
<h2 id='confint.femlm'>Confidence interval for parameters estimated with femlm</h2><span id='topic+confint.femlm'></span>

<h3>Description</h3>

<p>This function computes the confidence interval of parameter estimates obtained from a model estimated with <code><a href="#topic+femlm">femlm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
confint(object, parm, level = 0.95, se = c("standard",
  "white", "cluster", "twoway", "threeway", "fourway"), cluster,
  dof_correction = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="confint.femlm_+3A_parm">parm</code></td>
<td>
<p>The parameters for which to compute the confidence interval (either an integer vector OR a character vector with the parameter name). If missing, all parameters are used.</p>
</td></tr>
<tr><td><code id="confint.femlm_+3A_level">level</code></td>
<td>
<p>The confidence level. Default is 0.95.</p>
</td></tr>
<tr><td><code id="confint.femlm_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo; (default), &ldquo;White&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;?</p>
</td></tr>
<tr><td><code id="confint.femlm_+3A_cluster">cluster</code></td>
<td>
<p>A list of vectors. Used only if <code>se="cluster"</code>, &ldquo;se=twoway&rdquo;, &ldquo;se=threeway&rdquo; or &ldquo;se=fourway&rdquo;. The vectors should give the cluster of each observation. Note that if the estimation was run using <code>cluster</code>, the standard error is automatically clustered along the cluster given in <code><a href="#topic+femlm">femlm</a></code>. For one-way clustering, this argument can directly be a vector (instead of a list). If the estimation has been done with cluster variables, you can give a character vector of the dimensions over which to cluster the SE.</p>
</td></tr>
<tr><td><code id="confint.femlm_+3A_dof_correction">dof_correction</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Should there be a degree of freedom correction to the standard errors of the coefficients?</p>
</td></tr>
<tr><td><code id="confint.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with two columns giving respectively the lower and upper bound of the confidence interval. There is as many rows as parameters.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load trade data
data(trade)

# We estimate the effect of distance on trade (with 3 cluster effects)
est_pois = femlm(Euros ~ log(dist_km) + log(Year) | Origin + Destination +
                 Product, trade)

# confidence interval with "normal" VCOV
confint(est_pois)

# confidence interval with "clustered" VCOV (w.r.t. the Origin factor)
confint(est_pois, se = "cluster")


</code></pre>

<hr>
<h2 id='diagnostic'>Collinearity diagnostics for femlm objects</h2><span id='topic+diagnostic'></span>

<h3>Description</h3>

<p>In some occasions, the optimization algorithm of <code><a href="#topic+femlm">femlm</a></code> may fail to converge, or the variance-covariance matrix may not be available. The most common reason of why this happens is colllinearity among variables. This function helps to find out which variable is problematic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic_+3A_x">x</code></td>
<td>
<p>A <code>femlm</code> object obtained from function <code><a href="#topic+femlm">femlm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests: 1) collinearity with the cluster variables, 2) perfect multi-collinearity between the variables, and 3) identification issues when there are non-linear in parameters parts.
</p>


<h3>Value</h3>

<p>It returns a text message with the identified diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creating an example data base:
cluster_1 = sample(3, 100, TRUE)
cluster_2 = sample(20, 100, TRUE)
x = rnorm(100, cluster_1)**2
y = rnorm(100, cluster_2)**2
z = rnorm(100, 3)**2
dep = rpois(100, x*y*z)
base = data.frame(cluster_1, cluster_2, x, y, z, dep)

# creating collinearity problems:
base$v1 = base$v2 = base$v3 = base$v4 = 0
base$v1[base$cluster_1 == 1] = 1
base$v2[base$cluster_1 == 2] = 1
base$v3[base$cluster_1 == 3] = 1
base$v4[base$cluster_2 == 1] = 1

# Estimations:

# Collinearity with the cluster variables:
res_1 = femlm(dep ~ log(x) + v1 + v2 + v4 | cluster_1 + cluster_2, base)
diagnostic(res_1)
# =&gt; collinearity with cluster identified, we drop v1 and v2
res_1bis = femlm(dep ~ log(x) + v4 | cluster_1 + cluster_2, base)
diagnostic(res_1bis)

# Multi-Collinearity:
res_2 =  femlm(dep ~ log(x) + v1 + v2 + v3 + v4, base)
diagnostic(res_2)

# In non-linear part:
res_3 = femlm(dep ~ log(z), base, NL.fml = ~log(a*x + b*y),
              NL.start = list(a=1, b=1), lower = list(a=0, b=0))
diagnostic(res_3)


</code></pre>

<hr>
<h2 id='femlm'>Fixed effects maximum likelihood models</h2><span id='topic+femlm'></span>

<h3>Description</h3>

<p>This function estimates maximum likelihood models (e.g., Poisson or Logit) and is efficient to handle any number of fixed effects (i.e. cluster variables). It further allows for nonlinear in parameters right hand sides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>femlm(fml, data, family = c("poisson", "negbin", "logit", "gaussian"),
  NL.fml, cluster, na.rm = FALSE, useAcc = TRUE, NL.start, lower,
  upper, env, NL.start.init, offset, nl.gradient, linear.start = 0,
  jacobian.method = c("simple", "Richardson"), useHessian = TRUE,
  opt.control = list(), cores = 1, verbose = 0, theta.init,
  precision.cluster, itermax.cluster = 10000, itermax.deriv = 5000,
  showWarning = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="femlm_+3A_fml">fml</code></td>
<td>
<p>A formula. This formula gives the linear formula to be estimated (it is similar to a <code>lm</code> formula), for example: <code>fml = z~x+y</code>. To include cluster variables, you can 1) either insert them in this formula using a pipe (e.g. <code>fml = z~x+y|cluster1+cluster2</code>), or 2) either use the argment <code>cluster</code>. To include a non-linear in parameters element, you must use the argment <code>NL.fml</code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_data">data</code></td>
<td>
<p>A data.frame containing the necessary variables to run the model. The variables of the non-linear right hand side of the formula are identified with this <code>data.frame</code> names. Note that no <code>NA</code> is allowed in the variables to be used in the estimation. Can also be a matrix.</p>
</td></tr>
<tr><td><code id="femlm_+3A_family">family</code></td>
<td>
<p>Character scalar. It should provide the family. The possible values are &quot;poisson&quot; (Poisson model with log-link, the default), &quot;negbin&quot; (Negative Binomial model with log-link), &quot;logit&quot; (LOGIT model with log-link), &quot;gaussian&quot; (Gaussian model).</p>
</td></tr>
<tr><td><code id="femlm_+3A_nl.fml">NL.fml</code></td>
<td>
<p>A formula. If provided, this formula represents the non-linear part of the right hand side (RHS). Note that contrary to the <code>fml</code> argument, the coefficients must explicitely appear in this formula. For instance, it can be <code>~a*log(b*x + c*x^3)</code>, where <code>a</code>, <code>b</code>, and <code>c</code> are the coefficients to be estimated. Note that only the RHS of the formula is to be provided, and NOT the left hand side.</p>
</td></tr>
<tr><td><code id="femlm_+3A_cluster">cluster</code></td>
<td>
<p>Character vector. The name/s of a/some variable/s within the dataset to be used as clusters. These variables should contain the identifier of each observation (e.g., think of it as a panel identifier).</p>
</td></tr>
<tr><td><code id="femlm_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If the variables necessary for the estimation contain NAs and <code>na.rm = TRUE</code>, then all observations containing NA are removed prior to estimation and a warning message is raised detailing the number of observations removed.</p>
</td></tr>
<tr><td><code id="femlm_+3A_useacc">useAcc</code></td>
<td>
<p>Default is <code>TRUE</code>. Whether an acceleration algorithm (Irons and Tuck iterations) should be used to otbain the cluster coefficients when there are two or more clusters.</p>
</td></tr>
<tr><td><code id="femlm_+3A_nl.start">NL.start</code></td>
<td>
<p>(For NL models only) A list of starting values for the non-linear parameters. ALL the parameters are to be named and given a staring value. Example: <code>NL.start=list(a=1,b=5,c=0)</code>. Though, there is an exception: if all parameters are to be given the same starting value, you can use the argument <code>NL.start.init</code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_lower">lower</code></td>
<td>
<p>(For NL models only) A list. The lower bound for each of the non-linear parameters that requires one. Example: <code>lower=list(b=0,c=0)</code>. Beware, if the estimated parameter is at his lower bound, then asymptotic theory cannot be applied and the standard-error of the parameter cannot be estimated because the gradient will not be null. In other words, when at its upper/lower bound, the parameter is considered as 'fixed'.</p>
</td></tr>
<tr><td><code id="femlm_+3A_upper">upper</code></td>
<td>
<p>(For NL models only) A list. The upper bound for each of the non-linear parameters that requires one. Example: <code>upper=list(a=10,c=50)</code>. Beware, if the estimated parameter is at his upper bound, then asymptotic theory cannot be applied and the standard-error of the parameter cannot be estimated because the gradient will not be null. In other words, when at its upper/lower bound, the parameter is considered as 'fixed'.</p>
</td></tr>
<tr><td><code id="femlm_+3A_env">env</code></td>
<td>
<p>(For NL models only) An environment. You can provide an environement in which the non-linear part will be evaluated. (May be useful for some particular non-linear functions.)</p>
</td></tr>
<tr><td><code id="femlm_+3A_nl.start.init">NL.start.init</code></td>
<td>
<p>(For NL models only) Numeric scalar. If the argument <code>NL.start</code> is not provided, or only partially filled (i.e. there remain non-linear parameters with no starting value), then the starting value of all remaining non-linear parameters is set to <code>NL.start.init</code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_offset">offset</code></td>
<td>
<p>A formula. An offset can be added to the estimation. It should be a formula of the form (for example) ~0.5*x**2. This offset is linearily added to the elements of the main formula 'fml'. Note that when using the argument 'NL.fml', you can directly add the offset there.</p>
</td></tr>
<tr><td><code id="femlm_+3A_nl.gradient">nl.gradient</code></td>
<td>
<p>(For NL models only) A formula. The user can prodide a function that computes the gradient of the non-linear part. The formula should be of the form <code>~f0(a1,x1,a2,a2)</code>. The important point is that it should be able to be evaluated by: <code>eval(nl.gradient[[2]], env)</code> where <code>env</code> is the working environment of the algorithm (which contains all variables and parameters). The function should return a list or a data.frame whose names are the non-linear parameters.</p>
</td></tr>
<tr><td><code id="femlm_+3A_linear.start">linear.start</code></td>
<td>
<p>Numeric named vector. The starting values of the linear part.</p>
</td></tr>
<tr><td><code id="femlm_+3A_jacobian.method">jacobian.method</code></td>
<td>
<p>Character scalar. Provides the method used to numerically compute the jacobian of the non-linear part. Can be either <code>"simple"</code> or <code>"Richardson"</code>. Default is <code>"simple"</code>. See the help of <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> for more information.</p>
</td></tr>
<tr><td><code id="femlm_+3A_usehessian">useHessian</code></td>
<td>
<p>Logical. Should the Hessian be computed in the optimization stage? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_opt.control">opt.control</code></td>
<td>
<p>List of elements to be passed to the optimization method <code><a href="stats.html#topic+nlminb">nlminb</a></code>. See the help page of <code><a href="stats.html#topic+nlminb">nlminb</a></code> for more information.</p>
</td></tr>
<tr><td><code id="femlm_+3A_cores">cores</code></td>
<td>
<p>Integer, default is 1. Number of threads to be used (accelerates the algorithm via the use of openMP routines). This is particularly efficient for the negative binomial and logit models, less so for the Gaussian and Poisson likelihoods (unless for very large datasets).</p>
</td></tr>
<tr><td><code id="femlm_+3A_verbose">verbose</code></td>
<td>
<p>Integer, default is 0. It represents the level of information that should be reported during the optimisation process. If <code>verbose=0</code>: nothing is reported. If <code>verbose=1</code>: the value of the coefficients and the likelihood are reported. If <code>verbose=2</code>: <code>1</code> + information on the computing tiime of the null model, the cluster coefficients and the hessian are reported.</p>
</td></tr>
<tr><td><code id="femlm_+3A_theta.init">theta.init</code></td>
<td>
<p>Positive numeric scalar. The starting value of the dispersion parameter if <code>family="negbin"</code>. By default, the algorithm uses as a starting value the theta obtained from the model with only the intercept.</p>
</td></tr>
<tr><td><code id="femlm_+3A_precision.cluster">precision.cluster</code></td>
<td>
<p>Precision used to obtain the fixed-effects (ie cluster coefficients). Defaults to <code>1e-5</code>. It corresponds to the maximum absolute difference allowed between two iterations. Argument <code>precision.cluster</code> cannot be lower than <code>10000*.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_itermax.cluster">itermax.cluster</code></td>
<td>
<p>Maximum number of iterations in the step obtaining the fixed-effects (only in use for 2+ clusters). Default is 10000.</p>
</td></tr>
<tr><td><code id="femlm_+3A_itermax.deriv">itermax.deriv</code></td>
<td>
<p>Maximum number of iterations in the step obtaining the derivative of the fixed-effects (only in use for 2+ clusters). Default is 5000.</p>
</td></tr>
<tr><td><code id="femlm_+3A_showwarning">showWarning</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether warnings should be displayed (concerns warnings relating to: convergence state, collinearity issues and observation removal due to only 0/1 outcomes or presence of NA values).</p>
</td></tr>
<tr><td><code id="femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates maximum likelihood models where the conditional expectations are as follows:
</p>
<p>Gaussian likelihood:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=X\beta</code>
</p>

<p>Poisson and Negative Binomial likelihoods:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=\exp(X\beta)</code>
</p>

<p>where in the Negative Binomial there is the parameter <code class="reqn">\theta</code> used to model the variance as <code class="reqn">\mu+\mu^2/\theta</code>, with <code class="reqn">\mu</code> the conditional expectation.
Logit likelihood:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=\frac{\exp(X\beta)}{1+\exp(X\beta)}</code>
</p>

<p>When there are one or more clusters, the conditional expectation can be written as:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X) = h(X\beta+\sum_{k}\sum_{m}\gamma_{m}^{k}\times C_{im}^{k}),</code>
</p>

<p>where <code class="reqn">h(.)</code> is the function corresponding to the likelihood function as shown before. <code class="reqn">C^k</code> is the matrix associated to cluster <code class="reqn">k</code> such that <code class="reqn">C^k_{im}</code> is equal to 1 if observation <code class="reqn">i</code> is of category <code class="reqn">m</code> in cluster <code class="reqn">k</code> and 0 otherwise.
</p>
<p>When there are non linear in parameters functions, we can schematically split the set of regressors in two:
</p>
<p style="text-align: center;"><code class="reqn">f(X,\beta)=X^1\beta^1 + g(X^2,\beta^2)</code>
</p>

<p>with first a linear term and then a non linear part expressed by the function g. That is, we add a non-linear term to the linear terms (which are <code class="reqn">X*beta</code> and the cluster coefficients). It is always better (more efficient) to put into the argument <code>NL.fml</code> only the non-linear in parameter terms, and add all linear terms in the <code>fml</code> argument.
</p>
<p>To estimate only a non-linear formula without even the intercept, you must exclude the intercept from the linear formula by using, e.g., <code>fml = z~0</code>.
</p>
<p>The over-dispersion parameter of the Negative Binomial family, theta, is capped at 10,000. If theta reaches this high value, it means that there is no overdispersion.
</p>


<h3>Value</h3>

<p>An <code>femlm</code> object.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>The named vector of coefficients.</p>
</td></tr>
<tr><td><code>coeftable</code></td>
<td>
<p>The table of the coefficients with their standard errors, z-values and p-values.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The loglikelihood.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code>nparams</code></td>
<td>
<p>The number of parameters of the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr>
<tr><td><code>fml</code></td>
<td>
<p>The linear formula of the call.</p>
</td></tr>
<tr><td><code>ll_null</code></td>
<td>
<p>Log-likelihood of the null model (i.e. with the intercept only).</p>
</td></tr>
<tr><td><code>pseudo_r2</code></td>
<td>
<p>The adjusted pseudo R2.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>The convergence message from the optimization procedures.</p>
</td></tr>
<tr><td><code>sq.cor</code></td>
<td>
<p>Squared correlation between the dependent variable and the expected predictor (i.e. fitted.values) obtained by the estimation.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian of the parameters.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values are the expected value of the dependent variable for the fitted model: that is <code class="reqn">E(Y|X)</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>The variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The standard-error of the parameters.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>The matrix of the scores (first derivative for each observation).</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The ML family that was used for the estimation.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The difference between the dependent variable and the expected predictor.</p>
</td></tr>
<tr><td><code>sumFE</code></td>
<td>
<p>The sum of the fixed-effects for each observation.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>The offset formula.</p>
</td></tr>
<tr><td><code>NL.fml</code></td>
<td>
<p>The nonlinear formula of the call.</p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p>Whether the coefficients were upper or lower bounded. &ndash; This can only be the case when a non-linear formula is included and the arguments 'lower' or 'upper' are provided.</p>
</td></tr>
<tr><td><code>isBounded</code></td>
<td>
<p>The logical vector that gives for each coefficient whether it was bounded or not. This can only be the case when a non-linear formula is included and the arguments 'lower' or 'upper' are provided.</p>
</td></tr>
<tr><td><code>clusterNames</code></td>
<td>
<p>The names of each cluster.</p>
</td></tr>
<tr><td><code>id_dummies</code></td>
<td>
<p>The list (of length the number of clusters) of the cluster identifiers for each observation.</p>
</td></tr>
<tr><td><code>clusterSize</code></td>
<td>
<p>The size of each cluster.</p>
</td></tr>
<tr><td><code>obsRemoved</code></td>
<td>
<p>In the case there were clusters and some observations were removed because of only 0/1 outcome within a cluster, it gives the row numbers of the observations that were removed.</p>
</td></tr>
<tr><td><code>clusterRemoved</code></td>
<td>
<p>In the case there were clusters and some observations were removed because of only 0/1 outcome within a cluster, it gives the list (for each cluster) of the clustr identifiers that were removed.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>In the case of a negative binomial estimation: the overdispersion parameter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>References</h3>

<p>Berge, Laurent, 2018, &quot;Efficient estimation of maximum likelihood models with multiple fixed-effects: the R package FENmlm.&quot; CREA Discussion Papers, 13 (<a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf">https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf</a>).
</p>
<p>For models with multiple fixed-effects:
</p>
<p>Gaure, Simen, 2013, &quot;OLS with multiple high dimensional category variables&quot;, Computational Statistics &amp; Data Analysis 66 pp. 8&ndash;18
</p>
<p>On the unconditionnal Negative Binomial model:
</p>
<p>Allison, Paul D and Waterman, Richard P, 2002, &quot;Fixed-Effects Negative Binomial Regression Models&quot;, Sociological Methodology 32(1) pp. 247&ndash;265
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+summary.femlm">summary.femlm</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+getFE">getFE</a></code> to extract the cluster coefficients, and the functions <code><a href="#topic+res2table">res2table</a></code> and <code><a href="#topic+res2tex">res2tex</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Linear examples
#

# Load trade data
data(trade)

# We estimate the effect of distance on trade =&gt; we account for 3 cluster effects
# 1) Poisson estimation
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)
# alternative formulation giving the same results:
# est_pois = femlm(Euros ~ log(dist_km), trade, cluster = c("Origin", "Destination", "Product"))

# 2) Log-Log Gaussian estimation (with same clusters)
est_gaus = update(est_pois, log(Euros+1) ~ ., family="gaussian")

# 3) Negative Binomial estimation
est_nb = update(est_pois, family="negbin")

# Comparison of the results using the function res2table
res2table(est_pois, est_gaus, est_nb)
# Now using two way clustered standard-errors
res2table(est_pois, est_gaus, est_nb, se = "twoway")

# Comparing different types of standard errors
sum_white = summary(est_pois, se = "white")
sum_oneway = summary(est_pois, se = "cluster")
sum_twoway = summary(est_pois, se = "twoway")
sum_threeway = summary(est_pois, se = "threeway")

res2table(sum_white, sum_oneway, sum_twoway, sum_threeway)


#
# Example of Equivalences
#
## Not run: 
# equivalence with glm poisson
est_glm &lt;- glm(Euros ~ log(dist_km) + factor(Origin) +
            factor(Destination) + factor(Product), trade, family = poisson)

# coefficient estimates + Standard-error
summary(est_glm)$coefficients["log(dist_km)", ]
est_pois$coeftable

# equivalence with lm
est_lm &lt;- lm(log(Euros+1) ~ log(dist_km) + factor(Origin) +
            factor(Destination) + factor(Product), trade)

# coefficient estimates + Standard-error
summary(est_lm)$coefficients["log(dist_km)", ]
summary(est_gaus, dof_correction = TRUE)$coeftable

## End(Not run)


#
# Non-linear examples
#

# Generating data for a simple example
n = 100
x = rnorm(n, 1, 5)**2
y = rnorm(n, -1, 5)**2
z1 = rpois(n, x*y) + rpois(n, 2)
base = data.frame(x, y, z1)

# Estimating a 'linear' relation:
est1_L = femlm(z1 ~ log(x) + log(y), base)
# Estimating the same 'linear' relation using a 'non-linear' call
est1_NL = femlm(z1 ~ 1, base, NL.fml = ~a*log(x)+b*log(y), NL.start = list(a=0, b=0))
# we compare the estimates with the function res2table (they are identical)
res2table(est1_L, est1_NL)

# Now generating a non-linear relation (E(z2) = x + y + 1):
z2 = rpois(n, x + y) + rpois(n, 1)
base$z2 = z2

# Estimation using this non-linear form
est2_NL = femlm(z2~0, base, NL.fml = ~log(a*x + b*y),
               NL.start = list(a=1, b=2), lower = list(a=0, b=0))
# we can't estimate this relation linearily
# =&gt; closest we can do:
est2_L = femlm(z2~log(x)+log(y), base)

# Difference between the two models:
res2table(est2_L, est2_NL)

# Plotting the fits:
plot(x, z2, pch = 18)
points(x, fitted(est2_L), col = 2, pch = 1)
points(x, fitted(est2_NL), col = 4, pch = 2)


# Using a custom Jacobian for the function log(a*x + b*y)
myGrad = function(a,x,b,y){
	s = a*x+b*y
	data.frame(a = x/s, b = y/s)
}

est2_NL_grad = femlm(z2~0, base, NL.fml = ~log(a*x + b*y),
                     NL.start = list(a=1,b=2), nl.gradient = ~myGrad(a,x,b,y))


</code></pre>

<hr>
<h2 id='FENmlm-package'>Fixed Effects Nonlinear Maximum Likelihood Models</h2><span id='topic+FENmlm'></span><span id='topic+FENmlm-package'></span>

<h3>Description</h3>

<p>Efficient estimation of multiple fixed-effects maximum likelihood models with, possibly, non-linear in parameters right hand sides. Standard-errors can easily be clustered. It also includes tools to seamlessly export (to Latex) the results of various estimations.
</p>


<h3>Details</h3>

<p>This package efficiently estimates maximum likelihood models with multiple fixed-effect (i.e. large factor variables).
</p>
<p>The core function is <code><a href="#topic+femlm">femlm</a></code> which estimates maximum likelihood models with, possibly, non-linear in parameters right hand sides. The ML families available are: poisson, negative binomial, logit and Gaussian.
</p>
<p>Several features are also included such as the possibility to easily compute different types of standard-errors (including multi-way clustering).
</p>
<p>It is possible to compare the results of severeal estimations by using the function <code><a href="#topic+res2table">res2table</a></code>, and to export them to Latex using <code><a href="#topic+res2tex">res2tex</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Laurent Berge <a href="mailto:laurent.berge@u-bordeaux.fr">laurent.berge@u-bordeaux.fr</a>
</p>


<h3>References</h3>

<p>Berg\'e, Laurent, 2018, &quot;Efficient estimation of maximum likelihood models with multiple fixed-effects: the R package FENmlm.&quot; CREA Discussion Papers, 13 (<a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf">https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf</a>).
</p>

<hr>
<h2 id='fitted.femlm'>Extracts fitted values from a femlm fit</h2><span id='topic+fitted.femlm'></span><span id='topic+fitted.values.femlm'></span>

<h3>Description</h3>

<p>This function extracts the fitted values from a model estimated with <code><a href="#topic+femlm">femlm</a></code>. The fitted values that are returned are the <em>expected predictor</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
fitted(object, type = c("response", "link"), ...)

## S3 method for class 'values.femlm'
fitted(object, type = c("response", "link"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="fitted.femlm_+3A_type">type</code></td>
<td>
<p>Character either equal to <code>"response"</code> (default) or <code>"link"</code>. If <code>type="response"</code>, then the output is at the level of the response variable, i.e. it is the expected predictor <code class="reqn">E(Y|X)</code>. If <code>"link"</code>, then the output is at the level of the explanatory variables, i.e. the linear predictor <code class="reqn">X\cdot \beta</code>.</p>
</td></tr>
<tr><td><code id="fitted.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the <em>expected predictor</em> of a <code><a href="#topic+femlm">femlm</a></code> fit. The likelihood functions are detailed in <code><a href="#topic+femlm">femlm</a></code> help page.
</p>


<h3>Value</h3>

<p>It returns a numeric vector of length the number of observations used to estimate the model.
</p>
<p>If <code>type = "response"</code>, the value returned is the expected predictor, i.e. the expected value of the dependent variable for the fitted model: <code class="reqn">E(Y|X)</code>.
If <code>type = "link"</code>, the value returned is the linear predictor of the fitted model, that is <code class="reqn">X\cdot \beta</code> (remind that <code class="reqn">E(Y|X) = f(X\cdot \beta)</code>).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+resid.femlm">resid.femlm</a></code>, <code><a href="#topic+predict.femlm">predict.femlm</a></code>, <code><a href="#topic+summary.femlm">summary.femlm</a></code>, <code><a href="#topic+vcov.femlm">vcov.femlm</a></code>, <code><a href="#topic+getFE">getFE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, clustering by "Species"
res_poisson = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
                    Petal.Width | Species, iris)

# we extract the fitted values
y_fitted_poisson = fitted(res_poisson)

# Same estimation but in OLS (Gaussian family)
res_gaussian = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
                    Petal.Width | Species, iris, family = "gaussian")

y_fitted_gaussian = fitted(res_gaussian)

# comparison of the fit for the two families
plot(iris$Sepal.Length, y_fitted_poisson)
points(iris$Sepal.Length, y_fitted_gaussian, col = 2, pch = 2)


</code></pre>

<hr>
<h2 id='formula.femlm'>Extract the formula of a femlm fit</h2><span id='topic+formula.femlm'></span>

<h3>Description</h3>

<p>This function extracts the formula from a <code><a href="#topic+femlm">femlm</a></code> estimation. If the estimation was done with fixed-effects, they are added in the formula after a pipe (&ldquo;|&rdquo;). If the estimation was done with a non linear in parameters part, then this will be added in the formula in between <code>I()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
formula(x, type = c("full", "linear", "NL"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.femlm_+3A_x">x</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="formula.femlm_+3A_type">type</code></td>
<td>
<p>A character scalar. Default is <code>type = "full"</code> which gives back a formula containing the linear part of the model along with the clusters (if any) and the non-linear in parameters part (if any). If <code>type = "linear"</code> then only the linear formula is returned. If <code>type = "NL"</code> then only the non linear in parameters part is returned.</p>
</td></tr>
<tr><td><code id="formula.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a formula.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+model.matrix.femlm">model.matrix.femlm</a></code>, <code><a href="#topic+update.femlm">update.femlm</a></code>, <code><a href="#topic+summary.femlm">summary.femlm</a></code>, <code><a href="#topic+vcov.femlm">vcov.femlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, clustering by "Species"
res = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)

# formula with the cluster variable
formula(res)
# linear part without the cluster variable
formula(res, "linear")


</code></pre>

<hr>
<h2 id='getFE'>Extract the Fixed-Effects from a <code>femlm</code> estimation.</h2><span id='topic+getFE'></span>

<h3>Description</h3>

<p>This function retrives the fixed effects from a femlm estimation. It is useful only when there are more than one cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFE(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFE_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+femlm">femlm</a></code> object.
</p>
<p>If the cluster coefficients not regular, then several reference points need to be set, leading to the coefficients to be NOT interpretable. If this is the case, then a warning is raised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containig the vectors of the fixed effects.
</p>
<p>If there is more than 1 cluster, then the attribute &ldquo;References&rdquo; is created. This is a vector of length the number of clusters, each element contains the number of fixed-effects set as references. By construction, the elements of the first clusters are never set as references. In the presence of regular clusters, there should be Q-1 references (with Q the number of clusters).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.femlm.allClusters">plot.femlm.allClusters</a></code>. See also the main estimation function <code><a href="#topic+femlm">femlm</a></code>. Use <code><a href="#topic+summary.femlm">summary.femlm</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+getFE">getFE</a></code> to extract the cluster coefficients, and the functions <code><a href="#topic+res2table">res2table</a></code> and <code><a href="#topic+res2tex">res2tex</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(trade)

# We estimate the effect of distance on trade =&gt; we account for 3 cluster effects
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# obtaining the cluster coefficients
fe_trade = getFE(est_pois)

# plotting them
plot(fe_trade)

# plotting only the Products fixed-effects &amp; showing more of them
plot(fe_trade$Product, n=8)

</code></pre>

<hr>
<h2 id='logLik.femlm'>Extracts the log-likelihood</h2><span id='topic+logLik.femlm'></span>

<h3>Description</h3>

<p>This function extracts the log-likelihood from a <code><a href="#topic+femlm">femlm</a></code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="logLik.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the log-likelihood based on the model fit. You can have more information on the likelihoods in the details of the function <code><a href="#topic+femlm">femlm</a></code>.
</p>


<h3>Value</h3>

<p>It returns a numeric scalar.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+AIC.femlm">AIC.femlm</a></code>, <code><a href="#topic+BIC.femlm">BIC.femlm</a></code>, <code><a href="#topic+nobs.femlm">nobs.femlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, clustering by "Species"
res = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)

nobs(res)
logLik(res)


</code></pre>

<hr>
<h2 id='model.matrix.femlm'>Design matrix of a femlm model</h2><span id='topic+model.matrix.femlm'></span>

<h3>Description</h3>

<p>This function creates a design matrix of the linear part of a <code><a href="#topic+femlm">femlm</a></code> estimation. Note that it is only the linear part and the cluster variables (which can be considered as factors) are excluded from the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
model.matrix(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="model.matrix.femlm_+3A_data">data</code></td>
<td>
<p>If missing (default) then the original data is obtained by evaluating the <code>call</code>. Otherwise, it should be a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="model.matrix.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a design matrix.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+formula.femlm">formula.femlm</a></code>, <code><a href="#topic+update.femlm">update.femlm</a></code>, <code><a href="#topic+summary.femlm">summary.femlm</a></code>, <code><a href="#topic+vcov.femlm">vcov.femlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, clustering by "Species"
res = femlm(Sepal.Length ~ Sepal.Width*Petal.Length +
            Petal.Width | Species, iris)

head(model.matrix(res))



</code></pre>

<hr>
<h2 id='nobs.femlm'>Extract the number of observations form a femlm object</h2><span id='topic+nobs.femlm'></span>

<h3>Description</h3>

<p>This function simply extracts the number of obsrvations used to estimate a <code><a href="#topic+femlm">femlm</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="nobs.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an interger.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>. Use <code><a href="#topic+summary.femlm">summary.femlm</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+getFE">getFE</a></code> to extract the cluster coefficients, and the functions <code><a href="#topic+res2table">res2table</a></code> and <code><a href="#topic+res2tex">res2tex</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, clustering by "Species"
res = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)

nobs(res)
logLik(res)


</code></pre>

<hr>
<h2 id='obs2remove'>Finds observations to be removed from ML estimation with factors/clusters</h2><span id='topic+obs2remove'></span>

<h3>Description</h3>

<p>For Poisson, Negative Binomial or Logit estimations with fixed-effects, when the dependent variable is only equal to 0 (or 1 for Logit) for one cluster value this leads to a perfect fit for that cluster value by setting its associated cluster coefficient to <code>-Inf</code>. Thus these observations need to be removed before estimation. This function gives the observations to be removed. Not that by default the function <code><a href="#topic+femlm">femlm</a></code> drops them before performing the estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obs2remove(fml, data, family = c("poisson", "negbin", "logit"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obs2remove_+3A_fml">fml</code></td>
<td>
<p>A formula contaning the dependent variable and the clusters. It can be of the type: <code>y ~ cluster_1 + cluster_2</code> or <code>y ~ x1 | cluster_1 + cluster_1</code> (in which case variables before the pipe are ignored).</p>
</td></tr>
<tr><td><code id="obs2remove_+3A_data">data</code></td>
<td>
<p>A data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="obs2remove_+3A_family">family</code></td>
<td>
<p>Character scalar: either &ldquo;poisson&rdquo; (default), &ldquo;negbin&rdquo; or &ldquo;logit&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an integer vector of observations to be removed. If no observations are to be removed, an empty integer vector is returned. In both cases, it is of class <code>femlm.obs2remove</code>.
The vector has an attribut <code>cluster</code> which is a list giving the IDs of the clusters that have been removed, for each cluster dimension.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
# v6: Petal.Length with only 0 values for 'setosa'
base$v6 = base$Petal.Length
base$v6[base$Species == "setosa"] = 0

(x = obs2remove(v6 ~ Species, base))
attr(x, "cluster")

# The two results are identical:
res_1 = femlm(v6 ~ Petal.Width | Species, base)
# =&gt; warning + obsRemoved is created

res_2 = femlm(v6 ~ Petal.Width | Species, base[-x, ])
# =&gt; no warning because observations are removed before

res2table(res_1, res_2)

all(res_1$obsRemoved == x)

</code></pre>

<hr>
<h2 id='plot.femlm.allClusters'>Displaying the most notable fixed-effects</h2><span id='topic+plot.femlm.allClusters'></span>

<h3>Description</h3>

<p>This function plots the 5 fixed-effects with the highest and lowest values, for each of the clusters. It takes as an argument the fixed-effects obtained from the function <code><a href="#topic+getFE">getFE</a></code> after and estimation using <code><a href="#topic+femlm">femlm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm.allClusters'
plot(x, n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.femlm.allClusters_+3A_x">x</code></td>
<td>
<p>An object obtained from the function <code><a href="#topic+getFE">getFE</a></code>.</p>
</td></tr>
<tr><td><code id="plot.femlm.allClusters_+3A_n">n</code></td>
<td>
<p>The number of fixed-effects to be drawn. Defaults to 5.</p>
</td></tr>
<tr><td><code id="plot.femlm.allClusters_+3A_...">...</code></td>
<td>
<p>Not currently used.
</p>
<p>Note that the fixed-effect coefficients might NOT be interpretable. This function is useful only for fully regular panels.
</p>
<p>If the data are not regular in the cluster coefficients, this means that several &lsquo;reference points&rsquo; are set to obtain the fixed-effects, thereby impeding their interpretation. In this case a warning is raised.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getFE">getFE</a></code> to extract clouster coefficients. See also the main estimation function <code><a href="#topic+femlm">femlm</a></code>. Use <code><a href="#topic+summary.femlm">summary.femlm</a></code> to see the results with the appropriate standard-errors, the functions <code><a href="#topic+res2table">res2table</a></code> and <code><a href="#topic+res2tex">res2tex</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(trade)

# We estimate the effect of distance on trade
# =&gt; we account for 3 cluster effects
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# obtaining the cluster coefficients
fe_trade = getFE(est_pois)

# plotting them
plot(fe_trade)


</code></pre>

<hr>
<h2 id='predict.femlm'>Predict method for femlm fits</h2><span id='topic+predict.femlm'></span>

<h3>Description</h3>

<p>This function obtains prediction from a fitted model estimated with <code><a href="#topic+femlm">femlm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
predict(object, newdata, type = c("response", "link"),
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="predict.femlm_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame containing the variables used to make the prediction. If not provided, the fitted expected (or linear if <code>type = "link"</code>) predictors are returned.</p>
</td></tr>
<tr><td><code id="predict.femlm_+3A_type">type</code></td>
<td>
<p>Character either equal to <code>"response"</code> (default) or <code>"link"</code>. If <code>type="response"</code>, then the output is at the level of the response variable, i.e. it is the expected predictor <code class="reqn">E(Y|X)</code>. If <code>"link"</code>, then the output is at the level of the explanatory variables, i.e. the linear predictor <code class="reqn">X\cdot \beta</code>.</p>
</td></tr>
<tr><td><code id="predict.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a numeric vector of length equal to the number of observations in argument <code>newdata</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+update.femlm">update.femlm</a></code>, <code><a href="#topic+summary.femlm">summary.femlm</a></code>, <code><a href="#topic+vcov.femlm">vcov.femlm</a></code>, <code><a href="#topic+getFE">getFE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Estimation on iris data
res = femlm(Sepal.Length ~ Petal.Length | Species, iris)

# what would be the prediction if the data was all setosa?
newdata = data.frame(Petal.Length = iris$Petal.Length, Species = "setosa")
pred_setosa = predict(res, newdata = newdata)

# Let's look at it graphically
plot(c(1, 7), c(3, 11), type = "n", xlab = "Petal.Length",
     ylab = "Sepal.Length")

newdata = iris[order(iris$Petal.Length), ]
newdata$Species = "setosa"
lines(newdata$Petal.Length, predict(res, newdata))

# versicolor
newdata$Species = "versicolor"
lines(newdata$Petal.Length, predict(res, newdata), col=2)

# virginica
newdata$Species = "virginica"
lines(newdata$Petal.Length, predict(res, newdata), col=3)

# The original data
points(iris$Petal.Length, iris$Sepal.Length, col = iris$Species, pch = 18)
legend("topleft", lty = 1, col = 1:3, legend = levels(iris$Species))

</code></pre>

<hr>
<h2 id='print.femlm'>A print facility for <code>femlm</code> objects. It can compute different types of standard errors.</h2><span id='topic+print.femlm'></span>

<h3>Description</h3>

<p>This function is very similar to usual <code>summary</code> functions as it provides the table of coefficients along with other information on the fit of the estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
print(x, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.femlm_+3A_x">x</code></td>
<td>
<p>A femlm object. Obtained using <code><a href="#topic+femlm">femlm</a></code>.</p>
</td></tr>
<tr><td><code id="print.femlm_+3A_n">n</code></td>
<td>
<p>Integer, number of coefficients to display. By default, all estimated coefficients are displayed.</p>
</td></tr>
<tr><td><code id="print.femlm_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+vcov.femlm">vcov.femlm</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>. Use <code><a href="#topic+summary.femlm">summary.femlm</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+getFE">getFE</a></code> to extract the cluster coefficients, and the functions <code><a href="#topic+res2table">res2table</a></code> and <code><a href="#topic+res2tex">res2tex</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load trade data
data(trade)

# We estimate the effect of distance on trade =&gt; we account for 3 cluster effects
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# displaying the results
print(est_pois)

# with other type of standard error:
print(est_pois, se = "c")


</code></pre>

<hr>
<h2 id='print.femlm.obs2remove'>Print method for femlm.obs2remove objects</h2><span id='topic+print.femlm.obs2remove'></span>

<h3>Description</h3>

<p>This function show synthetizes the information of function <code><a href="#topic+obs2remove">obs2remove</a></code>. It reports the number of observations to be removed as well as the number of clusters removed per cluster dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm.obs2remove'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.femlm.obs2remove_+3A_x">x</code></td>
<td>
<p>A <code>femlm.obs2remove</code> object obtained from function <code><a href="#topic+obs2remove">obs2remove</a></code>.</p>
</td></tr>
<tr><td><code id="print.femlm.obs2remove_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>base = iris
# v6: Petal.Length with only 0 values for 'setosa'
base$v6 = base$Petal.Length
base$v6[base$Species == "setosa"] = 0

(x = obs2remove(v6 ~ Species, base))
attr(x, "cluster")

</code></pre>

<hr>
<h2 id='res2table'>Facility to display the results of multiple <code>femlm</code> estimations.</h2><span id='topic+res2table'></span>

<h3>Description</h3>

<p>This function aggregates the results of multiple estimations and display them in the form of only one table whose rownames are the variables and the columns contain the coefficients and standard-errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res2table(..., se = c("standard", "white", "cluster", "twoway",
  "threeway", "fourway"), cluster, depvar, drop, order, digits = 4,
  pseudo = TRUE, convergence, signifCode = c(`***` = 0.01, `**` = 0.05,
  `*` = 0.1), subtitles, keepFactors = FALSE, family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="res2table_+3A_...">...</code></td>
<td>
<p>Used to capture different <code><a href="#topic+femlm">femlm</a></code> objects. Note that any other type of element is discarded. Note that you can give a list of <code><a href="#topic+femlm">femlm</a></code> objects.</p>
</td></tr>
<tr><td><code id="res2table_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo; (default), &ldquo;White&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;?</p>
</td></tr>
<tr><td><code id="res2table_+3A_cluster">cluster</code></td>
<td>
<p>A list of vectors. Used only if <code>se="cluster"</code>, &ldquo;se=twoway&rdquo;, &ldquo;se=threeway&rdquo; or &ldquo;se=fourway&rdquo;. The vectors should give the cluster of each observation. Note that if the estimation was run using <code>cluster</code>, the standard error is automatically clustered along the cluster given in <code><a href="#topic+femlm">femlm</a></code>. For one-way clustering, this argument can directly be a vector (instead of a list). If the estimation has been done with cluster variables, you can give a character vector of the dimensions over which to cluster the SE.</p>
</td></tr>
<tr><td><code id="res2table_+3A_depvar">depvar</code></td>
<td>
<p>Logical, default is missing. Whether a first line containing the dependent variables should be shown. By default, the dependent variables are shown only if they differ across models.</p>
</td></tr>
<tr><td><code id="res2table_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a regular expression (see <code><a href="base.html#topic+regex">regex</a></code> help for more info). There can be more than one regular expression. Each variable satisfying the regular expression will be discarded.</p>
</td></tr>
<tr><td><code id="res2table_+3A_order">order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be ordered in a certain way. This should be a regular expression (see <code><a href="base.html#topic+regex">regex</a></code> help for more info). There can be more than one regular expression. The variables satisfying the first regular expression will be placed first, then the order follows the sequence of regular expressions.</p>
</td></tr>
<tr><td><code id="res2table_+3A_digits">digits</code></td>
<td>
<p>Integer, default is 4. The number of digits to be displayed.</p>
</td></tr>
<tr><td><code id="res2table_+3A_pseudo">pseudo</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Should the pseudo R2 be displayed?</p>
</td></tr>
<tr><td><code id="res2table_+3A_convergence">convergence</code></td>
<td>
<p>Logical, default is missing. Should the convergence state of the algorithm be displayed? By default, convergence information is displayed if at least one model did not converge.</p>
</td></tr>
<tr><td><code id="res2table_+3A_signifcode">signifCode</code></td>
<td>
<p>Named numeric vector, used to provide the significance codes with respect to the p-value of the coefficients. Default is <code>c("***"=0.01, "**"=0.05, "*"=0.10)</code>.</p>
</td></tr>
<tr><td><code id="res2table_+3A_subtitles">subtitles</code></td>
<td>
<p>Character vector of the same lenght as the number of models to be displayed. If provided, subtitles are added underneath the dependent variable name.</p>
</td></tr>
<tr><td><code id="res2table_+3A_keepfactors">keepFactors</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. By default, when factor variables are contained in the estimation, they are printed as if they were a cluster variable. Put to <code>TRUE</code> to display all the coefficients of the factor variables.</p>
</td></tr>
<tr><td><code id="res2table_+3A_family">family</code></td>
<td>
<p>A logical, default is missing. Whether to display the families of the models. By default this line is displayed when at least two models are from different families.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame containing the formatted results.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation function <code><a href="#topic+femlm">femlm</a></code>. Use <code><a href="#topic+summary.femlm">summary.femlm</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+getFE">getFE</a></code> to extract the cluster coefficients, and the functions <code><a href="#topic+res2table">res2table</a></code> and <code><a href="#topic+res2tex">res2tex</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two fitted models with different expl. variables:
res1 = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)
# estimation without clusters
res2 = update(res1, . ~ Sepal.Width | 0)

# We export the two results in one Latex table:
res2table(res1, res2)

# With clustered standard-errors + showing the dependent variable
res2table(res1, res2, se = "cluster", cluster = iris$Species, depvar = TRUE)

# Changing the model names + the order of the variables
# + dropping the intercept.
res2table(model_1 = res1, res2,
          order = c("Width", "Petal"), drop = "Int",
          signifCode = c("**" = 0, "*" = 0.2, "n.s."=1))



</code></pre>

<hr>
<h2 id='res2tex'>Facility to export the results of multiple <code>femlm</code> estimations in a Latex table.</h2><span id='topic+res2tex'></span>

<h3>Description</h3>

<p>This function aggregates the results of multiple estimations and display them in the form of  one Latex table whose rownames are the variables and the columns contain the coefficients and standard-errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res2tex(..., se = c("standard", "white", "cluster", "twoway", "threeway",
  "fourway"), cluster, digits = 4, pseudo = TRUE, title,
  sdBelow = TRUE, drop, order, dict, file, replace = FALSE,
  convergence, signifCode = c(`***` = 0.01, `**` = 0.05, `*` = 0.1),
  label, aic = FALSE, sqCor = FALSE, subtitles,
  showClusterSize = FALSE, bic = TRUE, loglik = TRUE,
  yesNoCluster = c("Yes", "No"), keepFactors = FALSE, family,
  powerBelow = -5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="res2tex_+3A_...">...</code></td>
<td>
<p>Used to capture different <code><a href="#topic+femlm">femlm</a></code> objects. Note that any other type of element is discarded. Note that you can give a list of <code><a href="#topic+femlm">femlm</a></code> objects.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo; (default), &ldquo;White&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;?</p>
</td></tr>
<tr><td><code id="res2tex_+3A_cluster">cluster</code></td>
<td>
<p>A list of vectors. Used only if <code>se="cluster"</code>, &ldquo;se=twoway&rdquo;, &ldquo;se=threeway&rdquo; or &ldquo;se=fourway&rdquo;. The vectors should give the cluster of each observation. Note that if the estimation was run using <code>cluster</code>, the standard error is automatically clustered along the cluster given in <code><a href="#topic+femlm">femlm</a></code>. For one-way clustering, this argument can directly be a vector (instead of a list). If the estimation has been done with cluster variables, you can give a character vector of the dimensions over which to cluster the SE.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_digits">digits</code></td>
<td>
<p>Integer, default is 4. The number of digits to be displayed.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_pseudo">pseudo</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Should the pseudo R2 be displayed?</p>
</td></tr>
<tr><td><code id="res2tex_+3A_title">title</code></td>
<td>
<p>Character scalar. The title of the Latex table.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_sdbelow">sdBelow</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Should the standard-errors be displayed below the coefficients?</p>
</td></tr>
<tr><td><code id="res2tex_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a regular expression (see <code><a href="base.html#topic+regex">regex</a></code> help for more info). There can be more than one regular expression. Each variable satisfying the regular expression will be discarded.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_order">order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be ordered in a certain way. This should be a regular expression (see <code><a href="base.html#topic+regex">regex</a></code> help for more info). There can be more than one regular expression. The variables satisfying the first regular expression will be placed first, then the order follows the sequence of regular expressions.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_dict">dict</code></td>
<td>
<p>A named character vector. If provided, it changes the original variable names to the ones contained in the <code>dict</code>. Example: I want to change my variable named &quot;a&quot; to &quot;$log(a)$&quot; and &quot;b3&quot; to &quot;$bonus^3$&quot;, then I used <code>dict=c(a="$log(a)$",b3="$bonus^3$")</code>.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_file">file</code></td>
<td>
<p>A character scalar. If provided, the Latex table will be saved in a file whose path is <code>file</code>.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_replace">replace</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only used if option <code>file</code> is used. Should the Latex table be written in a new file that replaces any existing file?</p>
</td></tr>
<tr><td><code id="res2tex_+3A_convergence">convergence</code></td>
<td>
<p>Logical, default is missing. Should the convergence state of the algorithm be displayed? By default, convergence information is displayed if at least one model did not converge.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_signifcode">signifCode</code></td>
<td>
<p>Named numeric vector, used to provide the significance codes with respect to the p-value of the coefficients. Default is <code>c("***"=0.01, "**"=0.05, "*"=0.10)</code>.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_label">label</code></td>
<td>
<p>Character scalar. The label of the Latex table.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_aic">aic</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Should the AIC be displayed?</p>
</td></tr>
<tr><td><code id="res2tex_+3A_sqcor">sqCor</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Should the squared correlation be displayed?</p>
</td></tr>
<tr><td><code id="res2tex_+3A_subtitles">subtitles</code></td>
<td>
<p>Character vector of the same lenght as the number of models to be displayed. If provided, subtitles are added underneath the dependent variable name.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_showclustersize">showClusterSize</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> and clusters were used in the models, then the number &quot;individuals&quot; of per cluster is also displayed.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_bic">bic</code></td>
<td>
<p>Logical, default is <code>TRUE</code>.Should the BIC be reported?</p>
</td></tr>
<tr><td><code id="res2tex_+3A_loglik">loglik</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Should the log-likelihood be reported?</p>
</td></tr>
<tr><td><code id="res2tex_+3A_yesnocluster">yesNoCluster</code></td>
<td>
<p>A character vector of lenght 2. Default is <code>c("Yes", "No")</code>. This is the message displayed when a given cluster is (or is not) included in a regression.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_keepfactors">keepFactors</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. By default, when factor variables are contained in the estimation, they are printed as if they were a cluster variable. Put to <code>TRUE</code> to display all the coefficients of the factor variables.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_family">family</code></td>
<td>
<p>A logical, default is missing. Whether to display the families of the models. By default this line is displayed when at least two models are from different families.</p>
</td></tr>
<tr><td><code id="res2tex_+3A_powerbelow">powerBelow</code></td>
<td>
<p>Integer, default is -5. A coefficient whose value is below <code>10**(powerBelow+1)</code> is written with a power in Latex. For example <code>0.0000456</code> would be written <code>4.56$\times 10^{-5}$</code> by default. Setting <code>powerBelow = -6</code> would lead to <code>0.00004</code> in Latex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There is nothing returned, the result is only displayed on the console or saved in a file.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation function <code><a href="#topic+femlm">femlm</a></code>. Use <code><a href="#topic+summary.femlm">summary.femlm</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+getFE">getFE</a></code> to extract the cluster coefficients, and the functions <code><a href="#topic+res2table">res2table</a></code> and <code><a href="#topic+res2tex">res2tex</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two fitted models with different expl. variables:
res1 = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)
res2 = femlm(Sepal.Length ~ Petal.Width | Species, iris)

# We export the three results in one Latex table,
# with clustered standard-errors:
res2tex(res1, res2, se = "cluster")

# Changing the names &amp; significance codes
res2tex(res1, res2, dict = c(Sepal.Length = "The sepal length", Sepal.Width = "SW"),
        signifCode = c("**" = 0.1, "*" = 0.2, "n.s."=1))

</code></pre>

<hr>
<h2 id='resid.femlm'>Extracts residuals from a femlm object</h2><span id='topic+resid.femlm'></span><span id='topic+residuals.femlm'></span>

<h3>Description</h3>

<p>This function extracts residuals from a fitted model estimated with <code><a href="#topic+femlm">femlm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
resid(object, ...)

## S3 method for class 'femlm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="resid.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The residuals returned are the difference between the dependent variable and the expected predictor.
</p>


<h3>Value</h3>

<p>It returns a numeric vector of the length the number of observations used for the estimation.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+fitted.femlm">fitted.femlm</a></code>, <code><a href="#topic+predict.femlm">predict.femlm</a></code>, <code><a href="#topic+summary.femlm">summary.femlm</a></code>, <code><a href="#topic+vcov.femlm">vcov.femlm</a></code>, <code><a href="#topic+getFE">getFE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, clustering by "Species"
res_poisson = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
                    Petal.Width | Species, iris)

# we plot the residuals
plot(resid(res_poisson))

</code></pre>

<hr>
<h2 id='summary.femlm'>Summary of a <code>femlm</code> object. Computes different types of standard errors.</h2><span id='topic+summary.femlm'></span>

<h3>Description</h3>

<p>This function is similar to <code>print.femlm</code>. It provides the table of coefficients along with other information on the fit of the estimation. It can compute different types of standard errors. The new variance covariance matrix is an object returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
summary(object, se = c("standard", "white", "cluster",
  "twoway", "threeway", "fourway"), cluster, dof_correction = FALSE,
  forceCovariance = FALSE, keepBounded = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.femlm_+3A_object">object</code></td>
<td>
<p>A femlm object. Obtained using <code><a href="#topic+femlm">femlm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.femlm_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo; (default), &ldquo;White&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;?</p>
</td></tr>
<tr><td><code id="summary.femlm_+3A_cluster">cluster</code></td>
<td>
<p>A list of vectors. Used only if <code>se="cluster"</code>, &ldquo;se=twoway&rdquo;, &ldquo;se=threeway&rdquo; or &ldquo;se=fourway&rdquo;. The vectors should give the cluster of each observation. Note that if the estimation was run using <code>cluster</code>, the standard error is automatically clustered along the cluster given in <code><a href="#topic+femlm">femlm</a></code>. For one-way clustering, this argument can directly be a vector (instead of a list). If the estimation has been done with cluster variables, you can give a character vector of the dimensions over which to cluster the SE.</p>
</td></tr>
<tr><td><code id="summary.femlm_+3A_dof_correction">dof_correction</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Should there be a degree of freedom correction to the standard errors of the coefficients?</p>
</td></tr>
<tr><td><code id="summary.femlm_+3A_forcecovariance">forceCovariance</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. In the peculiar case where the obtained Hessian is not invertible (usually because of collinearity of some variables), use this option force the covariance matrix, by using a generalized inverse of the Hessian. This can be useful to spot where possible problems come from.</p>
</td></tr>
<tr><td><code id="summary.femlm_+3A_keepbounded">keepBounded</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then the bounded coefficients (if any) are treated as unrestricted coefficients and their S.E. is computed (otherwise it is not).</p>
</td></tr>
<tr><td><code id="summary.femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code>femlm</code> object with:
</p>
<table>
<tr><td><code>cov.scaled</code></td>
<td>
<p>The new variance-covariance matrix (computed according to the argument <code>se</code>).</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The new standard-errors (computed according to the argument <code>se</code>).</p>
</td></tr>
<tr><td><code>coeftable</code></td>
<td>
<p>The table of coefficients with the new standard errors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation function <code><a href="#topic+femlm">femlm</a></code>. Use <code><a href="#topic+getFE">getFE</a></code> to extract the cluster coefficients, and the functions <code><a href="#topic+res2table">res2table</a></code> and <code><a href="#topic+res2tex">res2tex</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load trade data
data(trade)

# We estimate the effect of distance on trade (with 3 cluster effects)
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# Comparing different types of standard errors
sum_white = summary(est_pois, se = "white")
sum_oneway = summary(est_pois, se = "cluster")
sum_twoway = summary(est_pois, se = "twoway")
sum_threeway = summary(est_pois, se = "threeway")

res2table(sum_white, sum_oneway, sum_twoway, sum_threeway)

# Alternative ways to cluster the SE:
## Not run: 
# two-way clustering: Destination and Product
summary(est_pois, se = "twoway", cluster = c("Destination", "Product"))
summary(est_pois, se = "twoway", cluster = list(trade$Destination, trade$Product))

## End(Not run)


</code></pre>

<hr>
<h2 id='summary.femlm.allClusters'>Summary method for cluster coefficients</h2><span id='topic+summary.femlm.allClusters'></span>

<h3>Description</h3>

<p>This function summarizes the main characteristics of the cluster coefficients. It shows the number of fixed-effects that have been set as references and the first elements of the fixed-effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm.allClusters'
summary(object, n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.femlm.allClusters_+3A_object">object</code></td>
<td>
<p>An object returned by the function <code><a href="#topic+getFE">getFE</a></code>.</p>
</td></tr>
<tr><td><code id="summary.femlm.allClusters_+3A_n">n</code></td>
<td>
<p>Positive integer, defaults to 5. The <code>n</code> first fixed-effects for each cluster are reported.</p>
</td></tr>
<tr><td><code id="summary.femlm.allClusters_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It prints the number of fixed-effect coefficients per cluster, as well as the number of fixed-effects used as references for each cluster, and the mean and variance of the cluster coefficients. Finally it reports the first 5 elements of each cluster.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+getFE">getFE</a></code>, <code><a href="#topic+plot.femlm.allClusters">plot.femlm.allClusters</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(trade)

# We estimate the effect of distance on trade
# =&gt; we account for 3 cluster effects
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# obtaining the cluster coefficients
fe_trade = getFE(est_pois)

# printing some summary information on the cluster coefficients:
fe_trade


</code></pre>

<hr>
<h2 id='trade'>Trade data sample</h2><span id='topic+trade'></span>

<h3>Description</h3>

<p>This data reports trade information between countries of the European Union (EU15).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(trade)
</code></pre>


<h3>Format</h3>

<p><code>trade</code> is a data frame with 38,325 observations and 6 variables named <code>Destination</code>, <code>Origin</code>, <code>Product</code>, <code>Year</code>, <code>dist_km</code> and <code>Euros</code>.
</p>

<ul>
<li><p>Origin: 2-digits codes of the countries of origin of the trade flow.
</p>
</li>
<li><p>Destination: 2-digits codes of the countries of destination of the trade flow.
</p>
</li>
<li><p>Products: Number representing the product categories (from 1 to 20).
</p>
</li>
<li><p>Year: Years from 2007 to 2016
</p>
</li>
<li><p>dist_km: Geographic distance in km between the centers of the countries of origin and destination.
</p>
</li>
<li><p>Euros: The total amount of trade flow in million euros for the specific year/product category/origin-destination country pair.
</p>
</li></ul>


<h3>Source</h3>

<p>This data has been extrated from Eurostat on October 2017.
</p>

<hr>
<h2 id='update.femlm'>Updates a femlm estimation</h2><span id='topic+update.femlm'></span>

<h3>Description</h3>

<p>Updates and re-estimates a <code><a href="#topic+femlm">femlm</a></code> model. This function updates the formulas and use previous starting values to estimate a new <code><a href="#topic+femlm">femlm</a></code> model. The data is obtained from the original <code>call</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
update(object, fml.update, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.femlm_+3A_object">object</code></td>
<td>
<p>An object of class <code>femlm</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="update.femlm_+3A_fml.update">fml.update</code></td>
<td>
<p>Changes to be made to the original argument <code>fml</code>. See more information on <code><a href="stats.html#topic+update.formula">update.formula</a></code>. You can add/withdraw both variables and clusters. E.g. <code>. ~ . + x2 | . + z2</code> would add the variable <code>x2</code> and the cluster <code>z2</code> to the former estimation.</p>
</td></tr>
<tr><td><code id="update.femlm_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function <code><a href="#topic+femlm">femlm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code><a href="#topic+femlm">femlm</a></code> object (see details in <code><a href="#topic+femlm">femlm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+predict.femlm">predict.femlm</a></code>, <code><a href="#topic+summary.femlm">summary.femlm</a></code>, <code><a href="#topic+vcov.femlm">vcov.femlm</a></code>, <code><a href="#topic+getFE">getFE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example using trade data
data(trade)

# main estimation
est_pois &lt;- femlm(Euros ~ log(dist_km) | Origin + Destination, trade)

# we add the variable log(Year)
est_2 &lt;- update(est_pois, . ~ . + log(Year))

# we add another cluster: "Product"
est_3 &lt;- update(est_2, . ~ . | . + Product)

# we remove the cluster "Origin" and the variable log(dist_km)
est_4 &lt;- update(est_3, . ~ . - log(dist_km) | . - Origin)

# Quick look at the 4 estimations
res2table(est_pois, est_2, est_3, est_4)

</code></pre>

<hr>
<h2 id='vcov.femlm'>Extract the variance/covariance of a femlm fit</h2><span id='topic+vcov.femlm'></span>

<h3>Description</h3>

<p>This function extracts the variance-covariance of estimated parameters from a model estimated with <code><a href="#topic+femlm">femlm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'femlm'
vcov(object, se = c("standard", "white", "cluster",
  "twoway", "threeway", "fourway"), cluster, dof_correction = FALSE,
  forceCovariance = FALSE, keepBounded = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.femlm_+3A_object">object</code></td>
<td>
<p>A femlm object. Obtained using <code><a href="#topic+femlm">femlm</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.femlm_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo; (default), &ldquo;White&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;?</p>
</td></tr>
<tr><td><code id="vcov.femlm_+3A_cluster">cluster</code></td>
<td>
<p>A list of vectors. Used only if <code>se="cluster"</code>, &ldquo;se=twoway&rdquo;, &ldquo;se=threeway&rdquo; or &ldquo;se=fourway&rdquo;. The vectors should give the cluster of each observation. Note that if the estimation was run using <code>cluster</code>, the standard error is automatically clustered along the cluster given in <code><a href="#topic+femlm">femlm</a></code>. For one-way clustering, this argument can directly be a vector (instead of a list). If the estimation has been done with cluster variables, you can give a character vector of the dimensions over which to cluster the SE.</p>
</td></tr>
<tr><td><code id="vcov.femlm_+3A_dof_correction">dof_correction</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Should there be a degree of freedom correction to the standard errors of the coefficients?</p>
</td></tr>
<tr><td><code id="vcov.femlm_+3A_forcecovariance">forceCovariance</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. In the peculiar case where the obtained Hessian is not invertible (usually because of collinearity of some variables), use this option force the covariance matrix, by using a generalized inverse of the Hessian. This can be useful to spot where possible problems come from.</p>
</td></tr>
<tr><td><code id="vcov.femlm_+3A_keepbounded">keepBounded</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then the bounded coefficients (if any) are treated as unrestricted coefficients and their S.E. is computed (otherwise it is not).</p>
</td></tr>
<tr><td><code id="vcov.femlm_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+summary.femlm">summary.femlm</a></code>.
</p>
<p>The computation of the VCOV matrix is first done in <code><a href="#topic+summary.femlm">summary.femlm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code class="reqn">N\times N</code> square matrix where <code class="reqn">N</code> is the number of variables of the fitted model.
This matrix has an attribute &ldquo;type&rdquo; specifying how this variance/covariance matrix has been commputed (i.e. was it created using White correction, or was it clustered along a specific factor, etc).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+summary.femlm">summary.femlm</a></code>, <code><a href="#topic+confint.femlm">confint.femlm</a></code>, <code><a href="#topic+resid.femlm">resid.femlm</a></code>, <code><a href="#topic+predict.femlm">predict.femlm</a></code>, <code><a href="#topic+getFE">getFE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load trade data
data(trade)

# We estimate the effect of distance on trade (with 3 fixed-effects)
est_pois = femlm(Euros ~ log(dist_km) + log(Year) | Origin + Destination +
                 Product, trade)

# "normal" VCOV
vcov(est_pois)

# "white" VCOV
vcov(est_pois, se = "white")

# "clustered" VCOV (with respect to the Origin factor)
vcov(est_pois, se = "cluster")

# "clustered" VCOV (with respect to the Product factor)
vcov(est_pois, se = "cluster", cluster = trade$Product)
# another way to make the same request:
vcov(est_pois, se = "cluster", cluster = "Product")

# Another estimation without cluster:
est_pois_simple = femlm(Euros ~ log(dist_km) + log(Year), trade)

# We can still get the clustered VCOV,
# but we need to give the cluster-vector:
vcov(est_pois_simple, se = "cluster", cluster = trade$Product)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
