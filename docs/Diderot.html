<!DOCTYPE html><html><head><title>Help for package Diderot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Diderot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Diderot-package'>
<p>Bibliographic Network Analysis Package</p></a></li>
<li><a href='#build_graph'>
<p>Builds a citation graph.</p></a></li>
<li><a href='#compute_BC_ranking'>
<p>Function to compute the Betweenness Centrality ranking.</p></a></li>
<li><a href='#compute_citation_ranking'>
<p>Function to compute the citation ranking.</p></a></li>
<li><a href='#compute_custom_modularity'>
<p>Function to compute the custom modularity of a citation graph over a time window.</p></a></li>
<li><a href='#compute_Ji'>
<p>Function to compute the evolution of the Ji metric for a term (e.g. publication title) present in the reference list of a bibliographic dataset.</p></a></li>
<li><a href='#compute_Ji_ranking'>
<p>Function to compute the Ji metric ranking for publications in a citation graph.</p></a></li>
<li><a href='#compute_modularity'>
<p>Function to compute citation graph modularity over a time window.</p></a></li>
<li><a href='#create_bibliography'>
<p>Function to create a bibliographic dataset</p></a></li>
<li><a href='#get_date_from_doi'><p>Function to retrieve publication date based on Digital Object Identifier (DOI)</p></a></li>
<li><a href='#get_reference_title'>
<p>Function to extract the publication title from a reference using Freecite</p></a></li>
<li><a href='#heterocitation'><p>Function to calculate the heterocitation between two corpora</p></a></li>
<li><a href='#heterocitation_authors'>
<p>This function computes heterocitation metrics for authors</p></a></li>
<li><a href='#load_graph'>
<p>Function to load a citation graph</p></a></li>
<li><a href='#MC_baseline_distribution'><p>Function to compute baseline heterocitation values for the graph under study with random permutation of corpus attributions</p></a></li>
<li><a href='#nb_refs'>
<p>Function to calculate the number of citations in a bibliographic database</p></a></li>
<li><a href='#plot_authors_count'>
<p>Function to plot authors count timeseries</p></a></li>
<li><a href='#plot_heterocitation_timeseries'>
<p>Function to plot the heterocitation share and heterocitation balance timeseries</p></a></li>
<li><a href='#plot_modularity_timeseries'>
<p>Function to plot graph modularity timeseries</p></a></li>
<li><a href='#plot_publication_curve'>
<p>Function to plot publication count timeseries</p></a></li>
<li><a href='#precompute_heterocitation'>
<p>This function precomputes heterocitation values for each node/publication of a graph.</p></a></li>
<li><a href='#save_graph'>
<p>Function to save a graph</p></a></li>
<li><a href='#significance_Dx'><p>Function to evaluate the significance of the heterocitation balance value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bibliographic Network Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.13</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-04-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Vincenot</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Vincenot &lt;christian@vincenot.biz&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1), foreach, graphics, igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringi, RCurl, splitstackshape, data.table, utils, stats,
parallel, doParallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables the user to build a citation network/graph from bibliographic data and, based on modularity and heterocitation metrics, assess the degree of awareness/cross-fertilization between two corpora/communities. This toolset is optimized for Scopus data. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-19 10:47:31 UTC; kashim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-19 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Diderot-package'>
Bibliographic Network Analysis Package
</h2><span id='topic+Diderot-package'></span><span id='topic+Diderot'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: center;">
   <img src="../help/figures/Diderot.png" width="30%" alt="Figure: Diderot.png" />
    </td>
</tr>
<tr>
 <td style="text-align: center;">
   <em><b>Denis Diderot</b> (1713-1784), French philosopher and co-founder of the modern encyclopedia.</em>
</td>
</tr>

</table>

<p>This package allows to detect and quantify the unification or separation of two bibliographic corpora through the creation of citation networks. This tool can be used to study the spread of concepts across scientific disciplines, or the fusion/fission of scientific communities.  
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Diderot</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.13</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-04-17</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>A typical flow of use of the package includes the following points.
</p>
<p>First, literature metadata, including references, from the two fields of studies to analyze are downloaded from Scopus (or built manually). This data is imported to create a bibliographic dataset using <code><a href="#topic+create_bibliography">create_bibliography</a></code>.
</p>
<p>Second, a graph is created with a call to <code><a href="#topic+build_graph">build_graph</a></code> to reproduce the citation network in the bibliographic dataset.
</p>
<p>Finally, statistical analysis can be performed on the graph to assess the fusion/fission state of the two corpora/communities. Heterocitation indices (i.e. share and balance) show how much publications or authors cite papers from the other corpus (see <code><a href="#topic+heterocitation">heterocitation</a></code> and <code><a href="#topic+heterocitation_authors">heterocitation_authors</a></code> respectively). Such analysis shall always be preceded by a call to <code><a href="#topic+precompute_heterocitation">precompute_heterocitation</a></code> to perform initial calculations. These metrics are completed by traditional as well as custom modularity metrics (see <code><a href="#topic+compute_modularity">compute_modularity</a></code> and <code><a href="#topic+compute_custom_modularity">compute_custom_modularity</a></code> respectively) that translate how much the communities are separated. Publications that foster mutual awareness and cross-fertilization between the corpora/communities can be identified using the usual betweeness centrality metric (see <code><a href="#topic+compute_BC_ranking">compute_BC_ranking</a></code>) and the Ji index (see <code><a href="#topic+compute_Ji_ranking">compute_Ji_ranking</a></code>).
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot
</p>
<p>Maintainer: Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+igraph-package">igraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Two corpora on individual-based modelling (IBM) and agent-based modelling (ABM)
  # were downloaded from Scopus. The structure of each corpus is as follows:
  tt&lt;-read.csv("IBMmerged.csv", stringsAsFactors=FALSE)
  str(tt,strict.width="cut")
  ### 'data.frame':  3184 obs. of  9 variables:
  ### $ Authors        : chr  "Chen J., Marathe A., Marathe M." "Van Dijk D., Sl"..
  ### $ Title          : chr  "Coevolution of epidemics, social networks, and in"..
  ### $ Year           : int  2010 2010 2010 2010 2010 2010 2010 2010 2010 2010 ...
  ### $ DOI            : chr  "10.1007/978-3-642-12079-4_28" "10.1016/j.procs.20"..
  ### $ Link           : chr  "http://www.scopus.com/inward/record.url?eid=2-s2."..
  ### $ Abstract       : chr  "This research shows how a limited supply of antiv"..
  ### $ Author.Keywords: chr  "Antiviral; Behavioral economics; Epidemic; Microe"..
  ### $ Index.Keywords : chr  "Antiviral; Behavioral economics; Epidemic; Microe"..
  ### $ References     : chr  "(2009) Centre Approves Restricted Retail Sale of "..
  
  # Define the name of corpora (labels) and specific keywords to identify relevant
  # publications (keys).
  labels&lt;-c("IBM","ABM")
  keys&lt;-c("individual-based model|individual based model", 
          "agent-based model|agent based model")
  
  # Build the IBM-ABM bibliographical dataset from Scopus exports
  db&lt;-create_bibliography(corpora_files=c("IBMmerged.csv","ABMmerged.csv"), 
                          labels=labels, keywords=keys)
  ### [1] "File IBMmerged.csv contains 3184 records"
  ### [1] "File ABMmerged.csv contains 9641 records"
  
  # Build and save citation graph
  gr&lt;-build_graph(db=db,small.year.mismatch=T,fine.check.nb.authors=2,
                  attrs=c("Corpus","Year","Authors", "DOI"))
  ### [1] "Graph built! Execution time: 1200.22 seconds."
  save_graph(gr, "graph.graphml")
  
  # Compute and plot modularity
  compute_modularity(gr_sx, 1987, 2018)
  ###[1] 0.3164805
  plot_modularity_timeseries(gr_sx, 1987, 2018, window=1000)
  
  # Compute and plot publication heterocitation
  gr_sx&lt;-precompute_heterocitation(gr,labels=labels,infLimitYear=1987, supLimitYear=2018)
  ###[1] "Summary of the nodes considered for computation (1987-2017)"
  ###[1] "-----------------------------------------------------------"
  ###[1] "IBM     ABM     IBM|ABM"
  ###[1] "1928     5378     153"
  ###[1]
  ###[1] "Edges summary"
  ###[1] "-------------"
  ###[1] "IBM-&gt;IBM/IBM-&gt;Other 5583/1086 =&gt; Prop 0.163"
  ###[1] "ABM-&gt;ABM/ABM-&gt;Other 16946/2665 =&gt; Prop 0.136"
  ###[1] "General Same/Diff 22529/3751 =&gt; Prop 0.143"
  ###[1]
  ###[1] "Heterocitation metrics"
  ###[1] "----------------------"
  ###[1] "Sx ALL /  IBM  /  ABM"
  ###[1] "0.127 / 0.137 / 0.124"
  ###[1] "Dx ALL /  IBM  /  ABM"
  ###[1] "-0.652 / -0.803 / -0.598"
  heterocitation(gr_sx, labels=labels, 1987, 2005)
  ###[1] "Sx ALL /  ABM  /  IBM"
  ###[1] "0.047 / 0.214 / 0.007"
  ###[1] "Dx ALL /  ABM  /  IBM"
  ###[1] "-0.927 / -0.690 / -0.982"
  plot_heterocitation_timeseries(gr_sx, labels=labels, mini=-1, maxi=-1, cesure=2005)

  # Compute author heterocitation
  hetA&lt;-heterocitation_authors(gr_sx, 1987, 2018, pub_threshold=4)
  head(hetA[order(hetA$avgDx,decreasing=T),c(1)], n=10)
  ### [1] "Ashlock D." "Evora J." "Hernandez J.J." "Hernandez M." "Gooch K.J."          
  ### [6] "Reinhardt J.W." "Ng K." "Kazanci C." "Senior A.M." "Ariel G." 
  
  # Try to figure which publication are most impactful in terms of cross-fertilization
  jir&lt;-compute_Ji_ranking(gr_sx, labels=labels, 1987, 2018)
  head(jir[,c(2,7)],n=3)
  ###         Title                                                                           Ji
  ### 758     A standard protocol for describing individual-based and agent-based models      200
  ### 4437    Pattern-oriented modeling of agent-based complex systems: Lessons from ecology  134
  ### 33      The ODD protocol: A review and first update                                     120

## End(Not run)
</code></pre>

<hr>
<h2 id='build_graph'>
Builds a citation graph. 
</h2><span id='topic+build_graph'></span><span id='topic+Citation+20Graph+20Building'></span>

<h3>Description</h3>

<p>Builds a citation graph based on a database of bibliographic records generated with create_bibliography. This process is automatically parallelized on multicore hardware. By default, matching between title and references is done based on the full title, publication year, and three first authors. Publication attributes present in the dataframe can be copied to graph nodes using the attrs argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_graph(db, title = "Cite Me As", year = "Year", authors = "Authors", 
            ref = "Cited References", set.title.as.name = F, attrs = NULL, 
            verbose = F, makeCluster.type = "PSOCK", nb.cores=NA, 
            fine.check.threshold = 1000, fine.check.nb.authors = 3, 
            small.year.mismatch = T, debug = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_graph_+3A_db">db</code></td>
<td>
<p>Bibliographic database created with created_bibliography.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_title">title</code></td>
<td>
<p>Name of the data frame column in which publication titles are listed.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_year">year</code></td>
<td>
<p>Name of the data frame column in which publication years are listed.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_authors">authors</code></td>
<td>
<p>Name of the data frame column in which publication authors are listed.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_ref">ref</code></td>
<td>
<p>Name of the data frame column in which publication references are listed.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_set.title.as.name">set.title.as.name</code></td>
<td>
<p>Set graph vertex ID to publication title</p>
</td></tr>
<tr><td><code id="build_graph_+3A_attrs">attrs</code></td>
<td>
<p>Attributes of the bibliographic database (i.e. data frame column names, such as &quot;Authors&quot;&quot;, &quot;Year&quot;) to be set as vertex attributes.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity flag triggering a more detailed output during graph building.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_makecluster.type">makeCluster.type</code></td>
<td>
<p>Type of cluster to be used to parallelize the graph building process. For more options, see <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> in the doParallel library.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_nb.cores">nb.cores</code></td>
<td>
<p>Number of cores to be used for parallel computation.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_fine.check.threshold">fine.check.threshold</code></td>
<td>
<p>Title length under which citation matching is further confirmed based on publication year. This value can be reduced to increase performance on large bibliographic databases. By default, publication year check is always performed.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_fine.check.nb.authors">fine.check.nb.authors</code></td>
<td>
<p>Maximum number of authors to check against for citation matching. This value can be reduced to increase performance on large bibliographic databases. Default value is three authors.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_small.year.mismatch">small.year.mismatch</code></td>
<td>
<p>Flag indicating whether small year mismatches (+- 1 year) should be tolerated. It is recommended to keep this this flag to TRUE to accomodate usual inconsistencies in bibliographic databases.</p>
</td></tr>
<tr><td><code id="build_graph_+3A_debug">debug</code></td>
<td>
<p>Debug flag allowing the user to browse function calls upon execution error. For more details, see <code><a href="utils.html#topic+recover">recover</a></code> in the utils library.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a graph object.</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_bibliography">create_bibliography</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

</code></pre>

<hr>
<h2 id='compute_BC_ranking'>
Function to compute the Betweenness Centrality ranking.
</h2><span id='topic+compute_BC_ranking'></span><span id='topic+Betweenness+20Centrality'></span>

<h3>Description</h3>

<p>This function computes the Betweenness Centrality (BC) for each graph node (i.e. publication). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_BC_ranking(gr, labels, write_to_graph = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_BC_ranking_+3A_gr">gr</code></td>
<td>
<p>Citation graph</p>
</td></tr>
<tr><td><code id="compute_BC_ranking_+3A_labels">labels</code></td>
<td>
<p>Labels (i.e. names) of the two corpora featured in the graph.</p>
</td></tr>
<tr><td><code id="compute_BC_ranking_+3A_write_to_graph">write_to_graph</code></td>
<td>
<p>Flag to indicate whether to write results to the graph (i.e. save BC values as node attributes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If write_to_graph is FALSE, returns a list of entries (authors, title, year, corpus, BC) sorted by decreasing BC. Else, returns the graph given as input to which BC values are added as node attributes.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_citation_ranking">compute_citation_ranking</a></code>, <code><a href="#topic+compute_Ji_ranking">compute_Ji_ranking</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Compute BC
compute_BC_ranking(gr, labels)

</code></pre>

<hr>
<h2 id='compute_citation_ranking'>
Function to compute the citation ranking.
</h2><span id='topic+compute_citation_ranking'></span><span id='topic+Citation+20Ranking'></span>

<h3>Description</h3>

<p>This function computes the citation count for each graph node (i.e. publication). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_citation_ranking(gr, labels, write_to_graph = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_citation_ranking_+3A_gr">gr</code></td>
<td>
<p>Citation graph</p>
</td></tr>
<tr><td><code id="compute_citation_ranking_+3A_labels">labels</code></td>
<td>
<p>Labels (i.e. names) of the two corpora featured in the graph.</p>
</td></tr>
<tr><td><code id="compute_citation_ranking_+3A_write_to_graph">write_to_graph</code></td>
<td>
<p>Flag to indicate whether to write results to the graph (i.e. save citation count values as node attributes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If write_to_graph is FALSE, returns a list of entries (authors, title, year, corpus, citations) sorted by decreasing citation count. Else, returns the graph given as input to which citation count values are added as node attributes.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_BC_ranking">compute_BC_ranking</a></code>, <code><a href="#topic+compute_Ji_ranking">compute_Ji_ranking</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Compute Citation Ranking
compute_citation_ranking(gr, labels)
</code></pre>

<hr>
<h2 id='compute_custom_modularity'>
Function to compute the custom modularity of a citation graph over a time window.
</h2><span id='topic+compute_custom_modularity'></span><span id='topic+Custom+20Modularity'></span>

<h3>Description</h3>

<p>This function computes custom modularity of the citation graph. Custom modularity here stands for Newman's modularity computed over the subgraph comprising
nodes that belong to a single corpus only and are within the time window, as well as direct outgoing neighbors of the former nodes (whatever their year tag). Basically, 
the citation graph considered thus includes publications within the time window as well as older papers that they cite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_custom_modularity(gr, infLimitYear, supLimitYear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_custom_modularity_+3A_gr">gr</code></td>
<td>
<p>Citation graph</p>
</td></tr>
<tr><td><code id="compute_custom_modularity_+3A_inflimityear">infLimitYear</code></td>
<td>
<p>Start year of the time window considered (included)</p>
</td></tr>
<tr><td><code id="compute_custom_modularity_+3A_suplimityear">supLimitYear</code></td>
<td>
<p>End year of the time window considered (*excluded*)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the custom modularity value of the subgraph restricted to the interval [infLimitYear;supLimitYear[.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_modularity">compute_modularity</a></code>, <code><a href="#topic+plot_modularity_timeseries">plot_modularity_timeseries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Compute Custom Modularity
compute_custom_modularity(gr, 1990, 2018)
</code></pre>

<hr>
<h2 id='compute_Ji'>
Function to compute the evolution of the Ji metric for a term (e.g. publication title) present in the reference list of a bibliographic dataset.
</h2><span id='topic+compute_Ji'></span><span id='topic+Ji+20Metric'></span>

<h3>Description</h3>

<p>This function computes the Ji metric for a given term from a bibliographic dataset and returns its annual evolution within the timeframe specified. This metric indicates how much the term (e.g. publication title, software name) is cited simulteaneously in the references of both corpora and is thus important for cross-fertilization between the two communities. This function is run on the bibliographic dataset (created with <code><a href="#topic+create_bibliography">create_bibliography</a></code>) and is thus useful before graph creation or when the term to be searched is not the title of a node in the resulting graph. For instance, if the user knows that a publication (or, e.g. software or scientific database referenced only through a URL or grey literature) is cited and may have an impact on cross-fertilization between the two communities (the literature of which is represented by the two corpora) but does not have its own entry in the bibliographic database and would therefore not be featured as a node in the graph created by <code><a href="#topic+build_graph">build_graph</a></code>, the <code><a href="#topic+compute_Ji">compute_Ji</a></code> function can be used to assess its importance.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_Ji(db, pubtitle, labels, from = -1, to = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_Ji_+3A_db">db</code></td>
<td>
<p>Bibliographic database created with created_bibliography.</p>
</td></tr>
<tr><td><code id="compute_Ji_+3A_pubtitle">pubtitle</code></td>
<td>
<p>Publication title, or more generally term to be searched (e.g. software name).</p>
</td></tr>
<tr><td><code id="compute_Ji_+3A_labels">labels</code></td>
<td>
<p>Labels (i.e. names) of the two corpora featured in the graph.</p>
</td></tr>
<tr><td><code id="compute_Ji_+3A_from">from</code></td>
<td>
<p>Start year of the time window considered (included)</p>
</td></tr>
<tr><td><code id="compute_Ji_+3A_to">to</code></td>
<td>
<p>End year of the time window considered (*excluded*)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing year and Ji metric value.</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_bibliography">create_bibliography</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Compute Ji
compute_Ji(db, "Title1", labels, from=1990, to=2018)

</code></pre>

<hr>
<h2 id='compute_Ji_ranking'>
Function to compute the Ji metric ranking for publications in a citation graph.
</h2><span id='topic+compute_Ji_ranking'></span><span id='topic+Ji+20Ranking'></span>

<h3>Description</h3>

<p>This function computes the Ji metric for each graph node (i.e. publication). This metric indicates how much a publication is cited simulteaneously by both corpora and is thus important for cross-fertilization between the two communities. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_Ji_ranking(gr, labels, infLimitYear, supLimitYear, write_to_graph=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_Ji_ranking_+3A_gr">gr</code></td>
<td>
<p>Citation graph</p>
</td></tr>
<tr><td><code id="compute_Ji_ranking_+3A_labels">labels</code></td>
<td>
<p>Labels (i.e. names) of the two corpora featured in the graph.</p>
</td></tr>
<tr><td><code id="compute_Ji_ranking_+3A_inflimityear">infLimitYear</code></td>
<td>
<p>Start year of the time window considered (included)</p>
</td></tr>
<tr><td><code id="compute_Ji_ranking_+3A_suplimityear">supLimitYear</code></td>
<td>
<p>End year of the time window considered (*excluded*)</p>
</td></tr>
<tr><td><code id="compute_Ji_ranking_+3A_write_to_graph">write_to_graph</code></td>
<td>
<p>Flag to indicate whether to write results to the graph (i.e. save Ji values as node attributes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If write_to_graph is FALSE, returns a list of entries (authors, title, year, corpus, citations from corpus 1, citation from corpus 2, Ji) sorted by decreasing Ji. Else, returns the graph given as input to which Ji are added as node attributes.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_graph">build_graph</a></code>, <code><a href="#topic+precompute_heterocitation">precompute_heterocitation</a></code>, <code><a href="#topic+compute_Ji">compute_Ji</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Compute Ji ranking
compute_Ji_ranking(gr, labels, 1990, 2018)
</code></pre>

<hr>
<h2 id='compute_modularity'>
Function to compute citation graph modularity over a time window.
</h2><span id='topic+compute_modularity'></span><span id='topic+modularity'></span>

<h3>Description</h3>

<p>This function computes Newman's modularity of the citation graph restricted to a given time window and ignoring nodes belonging to both corpora simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_modularity(gr, infLimitYear, supLimitYear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_modularity_+3A_gr">gr</code></td>
<td>
<p>Citation graph</p>
</td></tr>
<tr><td><code id="compute_modularity_+3A_inflimityear">infLimitYear</code></td>
<td>
<p>Start year of the time window considered (included)</p>
</td></tr>
<tr><td><code id="compute_modularity_+3A_suplimityear">supLimitYear</code></td>
<td>
<p>End year of the time window considered (*excluded*)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Newman's modularity value of the subgraph restricted to the interval [infLimitYear;supLimitYear[.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_custom_modularity">compute_custom_modularity</a></code>, <code><a href="#topic+plot_modularity_timeseries">plot_modularity_timeseries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Compute Modularity
compute_modularity(gr, 1990, 2018)
</code></pre>

<hr>
<h2 id='create_bibliography'>
Function to create a bibliographic dataset
</h2><span id='topic+create_bibliography'></span><span id='topic+Bibliographic+20Network+20Creation'></span><span id='topic+Citation+20Graph+20Creation'></span>

<h3>Description</h3>

<p>This function creates a bibliographic dataset based on two external corpus files, each representing the bibliography of a given domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_bibliography(corpora_files, labels, keywords, retrieve_pubdates = F, 
                    clean_refs = F, encoding = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_bibliography_+3A_corpora_files">corpora_files</code></td>
<td>
<p>Vector containing the pathes to two corpus files (e.g. Scopus exports). The CSV files should contain for each record at least Authors (comma separated), Publication Title, Publication Year, and References (semicolon separated). The inclusion of DOI (for date checking; see the retrieve_pubdates option) as well as Abstract, Author.Keywords, and Index.Keywords (for the in-depth identification of publications belonging to both corpora) are strongly recommended.</p>
</td></tr>
<tr><td><code id="create_bibliography_+3A_labels">labels</code></td>
<td>
<p>Labels (i.e. names) given to the two corpora to be analyzed.</p>
</td></tr>
<tr><td><code id="create_bibliography_+3A_keywords">keywords</code></td>
<td>
<p>Keywords identifying the two corpora</p>
</td></tr>
<tr><td><code id="create_bibliography_+3A_retrieve_pubdates">retrieve_pubdates</code></td>
<td>
<p>Flag indicating whether to confirm publication dates by retrieving them (see <code><a href="#topic+get_date_from_doi">get_date_from_doi</a></code>)</p>
</td></tr>
<tr><td><code id="create_bibliography_+3A_clean_refs">clean_refs</code></td>
<td>
<p>Attempt to clean references and keep titles only. NOT RECOMMENDED, especially if <code><a href="#topic+build_graph">build_graph</a></code> should be used subsequently.</p>
</td></tr>
<tr><td><code id="create_bibliography_+3A_encoding">encoding</code></td>
<td>
<p>Character encoding used in the input files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing a bibliographic dataset usable by Diderot and including all references from both corpora.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_graph">build_graph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  # Two corpora on individual-based modelling (IBM) and agent-based modelling (ABM)
  # were downloaded from Scopus. The structure of each corpus is as follows:
  tt&lt;-read.csv("IBMmerged.csv", stringsAsFactors=FALSE)
  str(tt,strict.width="cut")
  ### 'data.frame':  3184 obs. of  9 variables:
  ### $ Authors        : chr  "Chen J., Marathe A., Marathe M." "Van Dijk D., Sl"..
  ### $ Title          : chr  "Coevolution of epidemics, social networks, and in"..
  ### $ Year           : int  2010 2010 2010 2010 2010 2010 2010 2010 2010 2010 ...
  ### $ DOI            : chr  "10.1007/978-3-642-12079-4_28" "10.1016/j.procs.20"..
  ### $ Link           : chr  "http://www.scopus.com/inward/record.url?eid=2-s2."..
  ### $ Abstract       : chr  "This research shows how a limited supply of antiv"..
  ### $ Author.Keywords: chr  "Antiviral; Behavioral economics; Epidemic; Microe"..
  ### $ Index.Keywords : chr  "Antiviral; Behavioral economics; Epidemic; Microe"..
  ### $ References     : chr  "(2009) Centre Approves Restricted Retail Sale of "..
  
  # Define the name of corpora (labels) and specific keywords to identify relevant
  # publications (keys).
  labels&lt;-c("IBM","ABM")
  keys&lt;-c("individual-based model|individual based model", 
          "agent-based model|agent based model")
  
  # Build the IBM-ABM bibliographical dataset from Scopus exports
  db&lt;-create_bibliography(corpora_files=c("IBMmerged.csv","ABMmerged.csv"), 
                          labels=labels, keywords=keys)
  ### [1] "File IBMmerged.csv contains 3184 records"
  ### [1] "File ABMmerged.csv contains 9641 records"
  
  # Processed output. Note the field name changes (for standardization with ISI Web 
  # of Knowledge format) and addition of the "Corpus" field (with identification of
  # joint "IBM | ABM" publications based on keywords).
  str(db, strict.width="cut")
  ### 'data.frame':  12504 obs. of  10 variables:
  ### $ Authors         : chr  "Chen J., Marathe A., Marathe M." "Van Dijk D., Sloot "..
  ### $ Cite Me As      : chr  "Coevolution of epidemics, social networks, and indivi"..
  ### $ Year            : int  2010 2010 2010 2010 2010 2010 2010 2010 2010 2010 ...
  ### $ DOI             : chr  "10.1007/978-3-642-12079-4_28" "10.1016/j.procs.2010.0"..
  ### $ Link            : chr  "http://www.scopus.com/inward/record.url?eid=2-s2.0-78"..
  ### $ Abstract        : chr  "This research shows how a limited supply of antiviral"..
  ### $ Author.Keywords : chr  "Antiviral; Behavioral economics; Epidemic; Microecono"..
  ### $ Index.Keywords  : chr  "Antiviral; Behavioral economics; Epidemic; Microecono"..
  ### $ Cited References: chr  "(2009) Centre Approves Restricted Retail Sale of Tami"..
  ### $ Corpus          : chr  "IBM" "IBM | ABM" "IBM | ABM" "IBM" ...

## End(Not run)
</code></pre>

<hr>
<h2 id='get_date_from_doi'>Function to retrieve publication date based on Digital Object Identifier (DOI)</h2><span id='topic+get_date_from_doi'></span>

<h3>Description</h3>

<p>This function retrieves precise publication date by querying the Digital Object Identifier (DOI) web server. Alternatively, if extract_date_from_doi is set to TRUE, the function will first try to extract a publication year from the publication DOI string. If <code><a href="#topic+create_bibliography">create_bibliography</a></code> is called with retrieve_pubdates = TRUE, it calls <code><a href="#topic+get_date_from_doi">get_date_from_doi</a></code> for each record to confirm publication dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_date_from_doi(doi, extract_date_from_doi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_date_from_doi_+3A_doi">doi</code></td>
<td>
<p>Character string representing the Digital Object Identifier (DOI) of the publication</p>
</td></tr>
<tr><td><code id="get_date_from_doi_+3A_extract_date_from_doi">extract_date_from_doi</code></td>
<td>
<p>Flag indicating whether to try to simply extract publication year from the DOI string before restorting to online queries to the DOI server</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a date in YYYY-MM-DD format or YYYY-MM format if extract_date_from_doi is set to TRUE.</p>


<h3>Note</h3>

<p>Scopus records already contain the year of publication of scientific papers indexed. However, in some cases these are inaccurate and can be verified by comparing them with the date retrieved by this function. Note that </p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_bibliography">create_bibliography</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Query publication date from DOI server
get_date_from_doi(doi="10.1016/j.procs.2010.04.250",extract_date_from_doi=TRUE)

## End(Not run)
# Extract date from DOI string
get_date_from_doi(doi="10.1016/j.procs.2010.04.250",extract_date_from_doi=TRUE)
</code></pre>

<hr>
<h2 id='get_reference_title'>
Function to extract the publication title from a reference using Freecite
</h2><span id='topic+get_reference_title'></span>

<h3>Description</h3>

<p>Function to extract the publication title from a reference using an online query to Freecite
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_reference_title(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_reference_title_+3A_str">str</code></td>
<td>
<p>Character string representing a reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character string of the publication title
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>

<hr>
<h2 id='heterocitation'>Function to calculate the heterocitation between two corpora</h2><span id='topic+heterocitation'></span><span id='topic+Hetero-Citation'></span>

<h3>Description</h3>

<p>This function calculates the heterocitation share and heterocitation balance between two corpora A and B in the time window specified. The heterocitation share (Sx) of a publication belonging to corpus A is defined as the percentage of citations to publications belonging to corpus B (or A|B) in its reference list. The global heterocitation share for corpus A is calculated as the average heterocitation share of the publications that corpus A contains (e.g. a value of 0.2 for corpus A indicates that, on average, publications in corpus A cite only 20% of papers from corpus B). The heterocitation balance metric (Dx), on the other hand, takes into consideration the respective sizes of corpus A and B to discern how much the heterocitation share deviates from values expected in the case of well-mixedness (i.e. if A and B originated from a unique community; e.g. a value of -50% for corpus A indicates that, on average, publications in corpus A cite papers from corpus B half less frequently than expected, which suggests a lack of mutual awareness between the corpora and related communities).   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heterocitation(gr, labels, infLimitYear, supLimitYear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heterocitation_+3A_gr">gr</code></td>
<td>
<p>Citation graph priorly preprocessed with <code><a href="#topic+precompute_heterocitation">precompute_heterocitation</a></code></p>
</td></tr>
<tr><td><code id="heterocitation_+3A_labels">labels</code></td>
<td>
<p>Labels (i.e. names) of the two corpora featured in the graph.</p>
</td></tr>
<tr><td><code id="heterocitation_+3A_inflimityear">infLimitYear</code></td>
<td>
<p>Start year of the time window considered (included)</p>
</td></tr>
<tr><td><code id="heterocitation_+3A_suplimityear">supLimitYear</code></td>
<td>
<p>End year of the time window considered (*excluded*)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numerical vector containing, in this order, the heterocitation share (Sx) for corpus A, B and global, and the heterocitation balance (Dx) for A, B and global.</p>


<h3>Note</h3>

<p><code><a href="#topic+precompute_heterocitation">precompute_heterocitation</a></code> should be called before running this function. 
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precompute_heterocitation">precompute_heterocitation</a></code>, <code><a href="#topic+plot_heterocitation_timeseries">plot_heterocitation_timeseries</a></code>, <code><a href="#topic+heterocitation_authors">heterocitation_authors</a></code>, <code><a href="#topic+MC_baseline_distribution">MC_baseline_distribution</a></code>, <code><a href="#topic+significance_Dx">significance_Dx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Heterocitation
gr&lt;-precompute_heterocitation(gr,labels, 1990, 2018)
heterocitation(gr,labels, 1990, 2018)
 
</code></pre>

<hr>
<h2 id='heterocitation_authors'>
This function computes heterocitation metrics for authors
</h2><span id='topic+heterocitation_authors'></span><span id='topic+Author+20Heterocitation'></span><span id='topic+Author+20Hetero-citation'></span>

<h3>Description</h3>

<p>This function computes heterocitation metrics for authors. The heterocitation share (Sx) and heterocitation balance (Dx) of an author are calculated as the average of these metrics for papers published by this author within the given time window. See the man page of <code><a href="#topic+heterocitation">heterocitation</a></code> for definitions of heterocitation metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heterocitation_authors(gr, infLimitYear, supLimitYear, pub_threshold = 0, 
                       remove_orphans = F, remove_citations_to_joint_papers = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heterocitation_authors_+3A_gr">gr</code></td>
<td>
<p>Citation graph priorly preprocessed with <code><a href="#topic+precompute_heterocitation">precompute_heterocitation</a></code></p>
</td></tr>
<tr><td><code id="heterocitation_authors_+3A_inflimityear">infLimitYear</code></td>
<td>
<p>Start year of the time window considered (included)</p>
</td></tr>
<tr><td><code id="heterocitation_authors_+3A_suplimityear">supLimitYear</code></td>
<td>
<p>End year of the time window considered (*excluded*)</p>
</td></tr>
<tr><td><code id="heterocitation_authors_+3A_pub_threshold">pub_threshold</code></td>
<td>
<p>Minimum number of publications for authors to be considered.</p>
</td></tr>
<tr><td><code id="heterocitation_authors_+3A_remove_orphans">remove_orphans</code></td>
<td>
<p>Do not consider publications that do not cite any other paper in the dataset (i.e. orphan nodes in the citation network)</p>
</td></tr>
<tr><td><code id="heterocitation_authors_+3A_remove_citations_to_joint_papers">remove_citations_to_joint_papers</code></td>
<td>
<p>Do not consider publications belonging to both corpora in the authors' average corpus calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame containing author name (&quot;Authors&quot;), number of publications (&quot;NbPubs&quot;), list of publication years (&quot;Years&quot;), list of publications corpora (&quot;Corpus&quot;), list of publication heterocitation share (&quot;Sx&quot;), list of publication heterocitation balance (&quot;Dx&quot;), average heterocitation share (&quot;avgSx&quot;), average heterocitation balance (&quot;avgDx&quot;), average corpus value of publications (&quot;avgCorpus&quot;), regression coefficient of the heterocitation share evolution (&quot;coeffSx&quot;), regression coefficient of the heterocitation balance evolution (&quot;coeffDx&quot;), regression coefficient of the evolution of the corpus value of publications (&quot;coeffCorpus&quot;).   
</p>


<h3>Note</h3>

<p><code><a href="#topic+precompute_heterocitation">precompute_heterocitation</a></code> should be called before running this function. 
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precompute_heterocitation">precompute_heterocitation</a></code>, <code><a href="#topic+heterocitation">heterocitation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Heterocitation
gr&lt;-precompute_heterocitation(gr,labels, 1990, 2018)

# Author heterocitation
heterocitation_authors(gr, 1990, 2018)

</code></pre>

<hr>
<h2 id='load_graph'>
Function to load a citation graph
</h2><span id='topic+load_graph'></span><span id='topic+Citation+20Graph+20Loading'></span>

<h3>Description</h3>

<p>This function loads a citation graph saved on the filesystem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_graph(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_graph_+3A_filename">filename</code></td>
<td>

<p>File to load
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a graph object.
</p>


<h3>Note</h3>

<p>This function basically supports only graph previously saved with Diderot's save_graph. However, as the file is actually a graphml file handled by igraph, advanced users may use this function on appropriate graphs created elsewhere, as long as they respect Diderot's structure (presence of a &quot;Corpus&quot;&quot; field, etc).
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save_graph">save_graph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

## Not run: 
save_graph(gr, "Saved.graphml")

# Load saved graph
gr&lt;-load_graph("Saved.graphml")

## End(Not run)
</code></pre>

<hr>
<h2 id='MC_baseline_distribution'>Function to compute baseline heterocitation values for the graph under study with random permutation of corpus attributions</h2><span id='topic+MC_baseline_distribution'></span>

<h3>Description</h3>

<p>This function performs Monte Carlo runs with random permutations of corpus tags in the graph provided and computes the heterocitation balance on the new graphs. Permutation is repeated over several iterations (set through the &quot;rep&quot; argument) and provides a baseline Dx values for the graph topology considered. This can then be compared with the Dx value obtained for the original graph to evaluate whether it could merely be the result of chance (see <code><a href="#topic+significance_Dx">significance_Dx</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC_baseline_distribution(gr, labels, infYearLimit, supYearLimit, rep = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC_baseline_distribution_+3A_gr">gr</code></td>
<td>
<p>Graph file (created with build_graph)</p>
</td></tr>
<tr><td><code id="MC_baseline_distribution_+3A_labels">labels</code></td>
<td>
<p>List of the names of the two corpora studied (e.g. c(&quot;Computer Science&quot;, &quot;Mathematics&quot;)), present in the &quot;Corpus&quot; attribute</p>
</td></tr>
<tr><td><code id="MC_baseline_distribution_+3A_infyearlimit">infYearLimit</code></td>
<td>
<p>Minimum year considered in this study</p>
</td></tr>
<tr><td><code id="MC_baseline_distribution_+3A_supyearlimit">supYearLimit</code></td>
<td>
<p>Maximum year considered in this study</p>
</td></tr>
<tr><td><code id="MC_baseline_distribution_+3A_rep">rep</code></td>
<td>
<p>Number of Monte Carlo iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function currently plots the histograms of distribution of Dx values generated through random permutations of corpus tags among the records.
Returns a list containing:
</p>
<table>
<tr><td><code>Dx1</code></td>
<td>
<p>Dx value for corpus 1 per iteration</p>
</td></tr>
<tr><td><code>Dx1</code></td>
<td>
<p>Dx value for corpus 2 per iteration</p>
</td></tr>
<tr><td><code>DxALL</code></td>
<td>
<p>Global Dx value per iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+significance_Dx">significance_Dx</a></code>, <code><a href="#topic+heterocitation">heterocitation</a></code>
</p>

<hr>
<h2 id='nb_refs'>
Function to calculate the number of citations in a bibliographic database
</h2><span id='topic+nb_refs'></span>

<h3>Description</h3>

<p>This function output the number of records and citations in a bibliographic database, and returns the latter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb_refs(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb_refs_+3A_db">db</code></td>
<td>
<p>Bibliographic database</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the number of citations in the bibliographic database</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# NB refs
nb_refs(db)

</code></pre>

<hr>
<h2 id='plot_authors_count'>
Function to plot authors count timeseries
</h2><span id='topic+plot_authors_count'></span>

<h3>Description</h3>

<p>This function plots and returns the annual number of new authors and cumulative number of authors in the bibliographic database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_authors_count(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_authors_count_+3A_db">db</code></td>
<td>
<p>Bibliographic database created with created_bibliography.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing year, annual number of new authors (i.e. not seen before), and cumulative number of authors.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_citation_ranking">compute_citation_ranking</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Plot authors count
## Not run: plot_authors_count(db)

</code></pre>

<hr>
<h2 id='plot_heterocitation_timeseries'>
Function to plot the heterocitation share and heterocitation balance timeseries
</h2><span id='topic+plot_heterocitation_timeseries'></span><span id='topic+Heterocitation+20Timeseries'></span><span id='topic+Hetero-citation+20Timeseries'></span>

<h3>Description</h3>

<p>This function plots and returns annual heterocitation share and heterocitation balance values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_heterocitation_timeseries(gr_arg, labels, mini = -1, maxi = -1, cesure = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_heterocitation_timeseries_+3A_gr_arg">gr_arg</code></td>
<td>
<p>Citation graph</p>
</td></tr>
<tr><td><code id="plot_heterocitation_timeseries_+3A_labels">labels</code></td>
<td>
<p>Labels (i.e. names) of the two corpora featured in the graph.</p>
</td></tr>
<tr><td><code id="plot_heterocitation_timeseries_+3A_mini">mini</code></td>
<td>
<p>Start year of the time window</p>
</td></tr>
<tr><td><code id="plot_heterocitation_timeseries_+3A_maxi">maxi</code></td>
<td>
<p>End year of the time window</p>
</td></tr>
<tr><td><code id="plot_heterocitation_timeseries_+3A_cesure">cesure</code></td>
<td>
<p>Year before which values should be cumulated. Default value is -1, which indicates that each year in the time window should be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with year and annual values for heterocitation share (sx1, sx2 and sxall for corpus A and B and global resp.) and heterocitation balance (dx1, dx2 and dxall for corpus A and B and global resp.).
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precompute_heterocitation">precompute_heterocitation</a></code>, <code><a href="#topic+heterocitation">heterocitation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Heterocitation timeseries
gr&lt;-precompute_heterocitation(gr,labels, 1990, 2018)
plot_heterocitation_timeseries(gr, labels, 1990, 2018)

</code></pre>

<hr>
<h2 id='plot_modularity_timeseries'>
Function to plot graph modularity timeseries
</h2><span id='topic+plot_modularity_timeseries'></span><span id='topic+Modularity+20Timeseries'></span>

<h3>Description</h3>

<p>This function plots and returns annual graph modularity values for predefined corpora (representing communities). See <code><a href="#topic+compute_modularity">compute_modularity</a></code> for details on modularity calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_modularity_timeseries(gr_arg, mini = -1, maxi = -1, cesure = -1, window = 1, 
                           modularity_function = "normal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_modularity_timeseries_+3A_gr_arg">gr_arg</code></td>
<td>
<p>Citation graph</p>
</td></tr>
<tr><td><code id="plot_modularity_timeseries_+3A_mini">mini</code></td>
<td>
<p>Start year of the time window</p>
</td></tr>
<tr><td><code id="plot_modularity_timeseries_+3A_maxi">maxi</code></td>
<td>
<p>End year of the time window</p>
</td></tr>
<tr><td><code id="plot_modularity_timeseries_+3A_cesure">cesure</code></td>
<td>
<p>Year before which values should be cumulated. Default value is -1, which indicates that each year in the time window should be plotted.</p>
</td></tr>
<tr><td><code id="plot_modularity_timeseries_+3A_window">window</code></td>
<td>
<p>The temporal sliding window size over which modularity should be computed.</p>
</td></tr>
<tr><td><code id="plot_modularity_timeseries_+3A_modularity_function">modularity_function</code></td>
<td>
<p>Modularity function to be used for the calculation: &quot;custom&quot; indicates that <code><a href="#topic+compute_custom_modularity">compute_custom_modularity</a></code> will be used, whereas &quot;normal&quot; indicates that <code><a href="#topic+compute_modularity">compute_modularity</a></code> will be used.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a dataframe containing year and annual modularity value.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_modularity">compute_modularity</a></code>, <code><a href="#topic+compute_custom_modularity">compute_custom_modularity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Compute Modularity timeseries
plot_modularity_timeseries(gr, 1990, 2018)

</code></pre>

<hr>
<h2 id='plot_publication_curve'>
Function to plot publication count timeseries
</h2><span id='topic+plot_publication_curve'></span><span id='topic+Publication+20Timeseries'></span>

<h3>Description</h3>

<p>This function plots and returns the annual number of publications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_publication_curve(gr, labels, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_publication_curve_+3A_gr">gr</code></td>
<td>
<p>Citation graph</p>
</td></tr>
<tr><td><code id="plot_publication_curve_+3A_labels">labels</code></td>
<td>
<p>Labels (i.e. names) of the two corpora featured in the graph.</p>
</td></tr>
<tr><td><code id="plot_publication_curve_+3A_k">k</code></td>
<td>
<p>Text font size (multiplier of cex values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing year and annual publication count for each corpus and both together.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_citation_ranking">compute_citation_ranking</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

# Publication curve
plot_publication_curve(gr,labels)

</code></pre>

<hr>
<h2 id='precompute_heterocitation'>
This function precomputes heterocitation values for each node/publication of a graph.
</h2><span id='topic+precompute_heterocitation'></span>

<h3>Description</h3>

<p>This function computes heterocitation values for each publication and stores them as node attributes in the graph. The heterocitation share of a publication belonging to corpus A is defined as the percentage of citations to publications belonging to corpus B (or A|B) in its reference list (e.g. a value of 0.2 for a publication in corpus A indicates that the publication cites only 20% of papers from corpus B). The heterocitation balance metric, on the other hand, takes into consideration the respective sizes of corpus A and B to discern how much the heterocitation share deviates from values expected in the case of well-mixedness (i.e. if A and B originated from a unique community; e.g. a value of -30% for a publication in corpus A indicates that it cites papers from corpus B 30% less frequently than expected).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precompute_heterocitation(gr, labels, infLimitYear, supLimitYear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precompute_heterocitation_+3A_gr">gr</code></td>
<td>
<p>Citation graph</p>
</td></tr>
<tr><td><code id="precompute_heterocitation_+3A_labels">labels</code></td>
<td>
<p>Labels (i.e. names) of the two corpora featured in the graph.</p>
</td></tr>
<tr><td><code id="precompute_heterocitation_+3A_inflimityear">infLimitYear</code></td>
<td>
<p>Start year of the time window considered (included)</p>
</td></tr>
<tr><td><code id="precompute_heterocitation_+3A_suplimityear">supLimitYear</code></td>
<td>
<p>End year of the time window considered (*excluded*)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the graph gr with added node attributes Sx and Dx representing the heterocitation share and heterocitation balance respectively.</p>


<h3>Note</h3>

<p>Corpus-wide heterocitation values can be computed using <code><a href="#topic+heterocitation">heterocitation</a></code>.
</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heterocitation">heterocitation</a></code>, <code><a href="#topic+plot_heterocitation_timeseries">plot_heterocitation_timeseries</a></code>, <code><a href="#topic+compute_Ji_ranking">compute_Ji_ranking</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

gr&lt;-precompute_heterocitation(gr,labels, 1990, 2018)

</code></pre>

<hr>
<h2 id='save_graph'>
Function to save a graph
</h2><span id='topic+save_graph'></span><span id='topic+Graph+20Saving'></span>

<h3>Description</h3>

<p>This function saves a graph produced with Diderot. The resulting structure is actually a graphml file and can thus be exported to third party software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_graph(gr, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_graph_+3A_gr">gr</code></td>
<td>
<p>Graph object to save.</p>
</td></tr>
<tr><td><code id="save_graph_+3A_filename">filename</code></td>
<td>
<p>File to save the graph to.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_graph">load_graph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

labels&lt;-c("Corpus1","Corpus2")

# Build a bibliographical dataset from Scopus exports
db&lt;-create_bibliography(corpora_files=c(tempfi1,tempfi2), 
                        labels=labels, keywords=NA)


# Build graph
gr&lt;-build_graph(db=db,small.year.mismatch=TRUE, attrs=c("Corpus","Year","Authors"), nb.cores=1)

## Not run: save_graph(gr, "Saved.graphml")
</code></pre>

<hr>
<h2 id='significance_Dx'>Function to evaluate the significance of the heterocitation balance value</h2><span id='topic+significance_Dx'></span><span id='topic+Heterocitation+20Significance'></span>

<h3>Description</h3>

<p>This function assesses to what extent the heterocitation balance (Dx value) calculated for a graph departs from baseline situation. The latter typically represents Dx values to be expected by chance, i.e. through random permutation of corpus assignation at the node/vertex level (see <code><a href="#topic+MC_baseline_distribution">MC_baseline_distribution</a></code>). A Shapiro-Wilk test is first executed on the control distribution (using <code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code>) and if the normality hypothesis is not rejected, a one-sample t test (see <code><a href="stats.html#topic+t.test">t.test</a></code>) is used to test whether value is significantly different from the control distribution. The strength of this difference is additionally assessed through Glass' delta, an estimator of effect size (Glass, McGraw, and Smith, 1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>significance_Dx(value, control, normality_threshold=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="significance_Dx_+3A_value">value</code></td>
<td>
<p>Heterocitation balance (Dx) calculated for the citation network studied</p>
</td></tr>
<tr><td><code id="significance_Dx_+3A_control">control</code></td>
<td>
<p>Baseline distribution of Dx values in control experiments</p>
</td></tr>
<tr><td><code id="significance_Dx_+3A_normality_threshold">normality_threshold</code></td>
<td>
<p>P value threshold under which the hypothesis of normality is rejected in the preliminary Shapiro-Wilk test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the p-value obtained in a one-sample t test comparing value and the control distribution (with null hypothesis being that value could come from the control distribution) or NA if the control distribution is not normal based on a Shapiro-Wilk normality test, and Glass' estimator of effect size.</p>


<h3>Author(s)</h3>

<p>Christian Vincenot (christian@vincenot.biz)
</p>


<h3>References</h3>

<p>Glass, G. V., McGraw, B., &amp; Smith, M. L. (1981). Meta-analysis in social research. Beverly Hills: Sage Publications.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+significance_Dx">significance_Dx</a></code>, <code><a href="#topic+heterocitation">heterocitation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Heterocitation in our graph
heterocitation(gr_sx, labels=labels, 1987, 2005)
### [1] "Sx ALL /  ABM  /  IBM"
### [1] "0.047 / 0.214 / 0.007"
### [1] "Dx ALL /  ABM  /  IBM"
### [1] "-0.927 / -0.690 / -0.982"


# Generate a baseline distribution for Dx values obtained through chance
# Here, we run 200 iterations of node corpus permutations
baseline&lt;-MC_baseline_distribution(gr_sx, labels, 1987, 2018, 200)

# Assess whether our observed Dx is possibly due to chance
significance_Dx(-0.927, baseline[["Dx ALL"]])
### [1] "Distribution is normal. Performing t-test."
###
###   One Sample t-test
###
### data:  value - control
### t = -323.0017, df = 319, p-value &lt; 2.2e-16
### alternative hypothesis: true mean is not equal to 0
### 95 percent confidence interval:
###  -0.9159834 -0.9048923
### sample estimates:
###  mean of x 
### -0.9104379 
###
### [1] "Glass' effect size: -18.0563442219448"

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
