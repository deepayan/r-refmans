<!DOCTYPE html><html><head><title>Help for package hero</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hero}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjacent'><p>Determine adjacent points</p></a></li>
<li><a href='#as.starray'><p>Convert array to <code>starray</code></p></a></li>
<li><a href='#as.sts'><p>Convert object to <code>sts</code> class</p></a></li>
<li><a href='#assemble'><p>Assemble spline ingredients for sandwich smooth</p></a></li>
<li><a href='#border.grid'><p>Construct border for grid</p></a></li>
<li><a href='#bspline'><p>B-spline specification</p></a></li>
<li><a href='#circulate'><p>Circulate values of a vector</p></a></li>
<li><a href='#connect'><p>Connect <code>hero_radsplines</code></p></a></li>
<li><a href='#create.prepared_list'><p>Manually create a <code>prepared_list</code></p></a></li>
<li><a href='#default.evalargs'><p>Construct default <code>evalargs</code></p></a></li>
<li><a href='#default.splines'><p>Construct default splines</p></a></li>
<li><a href='#diffpen'><p>P-spline difference penalty</p></a></li>
<li><a href='#enhance'><p>Enhance penalty value</p></a></li>
<li><a href='#enhance.grid'><p>Enhance penalty value using grid search</p></a></li>
<li><a href='#enlarge'><p>Enlarge spatial domain</p></a></li>
<li><a href='#generate.data2d'><p>Generate 2d data</p></a></li>
<li><a href='#generate.data3d'><p>Generate 3d data</p></a></li>
<li><a href='#hero'><p>Construct a hero sandwich smoother</p></a></li>
<li><a href='#knot.design'><p>Design knot/breakpoint spacing</p></a></li>
<li><a href='#kronecker.seq'><p>A sequence of kronecker products</p></a></li>
<li><a href='#loglambda2gcv'><p>Determine GCV statistic</p></a></li>
<li><a href='#ludata'><p>Data for f1 function from Lu et al. (2012)</p></a></li>
<li><a href='#plot.hero_adjacent'><p>Plot a <code>hero_adjacent</code> object</p></a></li>
<li><a href='#plot.hero_bspline'><p>Plot a <code>hero_bspline</code> object</p></a></li>
<li><a href='#plot.hero_enlarge'><p>Plot a <code>hero_enlarge</code> object</p></a></li>
<li><a href='#plot.hero_matrix'><p>Plot a <code>hero</code> object</p></a></li>
<li><a href='#plot.hero_radspline'><p>Plot a <code>hero_radspline</code></p></a></li>
<li><a href='#poly2SpatialPolygons'><p>Convert simple polygon to a <code>SpatialPolygons</code> object</p></a></li>
<li><a href='#precompute'><p>Precompute objects</p></a></li>
<li><a href='#predict.hero'><p>Predict method for <code>hero</code> object</p></a></li>
<li><a href='#predict.hero_bspline'><p>Predict method for <code>hero_bspline</code> object</p></a></li>
<li><a href='#predict.hero_radspline'><p>Predict method for a <code>hero_radspline</code></p></a></li>
<li><a href='#prepare'><p>Prepare data for sandwich smooth</p></a></li>
<li><a href='#prepare_sequential'><p>Sequentially prepare data for sandwich smooth</p></a></li>
<li><a href='#prepare.array'><p>Prepare data array for sandwich smooth</p></a></li>
<li><a href='#prepare.list'><p>Prepare data array for sandwich smooth</p></a></li>
<li><a href='#prepare.matrix'><p>Prepare data matrix for sandwich smooth</p></a></li>
<li><a href='#prepare.numeric'><p>Prepare data vector for sandwich smooth</p></a></li>
<li><a href='#prepare.starray'><p>Prepare <code>starray</code> for sandwich smooth</p></a></li>
<li><a href='#prepare.sts'><p>Prepare <code>starray</code> for sandwich smooth</p></a></li>
<li><a href='#radspline'><p>Radial basis spline specification</p></a></li>
<li><a href='#rh'><p>Rotated H-transform</p></a></li>
<li><a href='#rh.seq'><p>Apply <code>rh</code> sequentially</p></a></li>
<li><a href='#spdiffpen'><p>Spatial difference penalty</p></a></li>
<li><a href='#tasmax'><p>Computer-generated temperature data</p></a></li>
<li><a href='#wrfg_cgcm3_tasmax'><p>Computer-generated temperature data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatio-Temporal (Hero) Sandwich Smoother</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua French</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua French &lt;joshua.french@ucdenver.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the sandwich smoother proposed in Fast Bivariate Penalized Splines by Xiao et al. (2012) &lt;<a href="https://doi.org/10.1111%2Frssb.12007">doi:10.1111/rssb.12007</a>&gt;.    A hero is a specific type of sandwich.  Dictionary.com (2018) <a href="https://www.dictionary.com">https://www.dictionary.com</a> describes a hero as: a large sandwich, usually consisting of a small loaf of bread or long roll cut in half lengthwise and containing a variety of ingredients, as meat, cheese, lettuce, and tomatoes. Also implements the spatio-temporal sandwich smoother of French and Kokoszka (2021) &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2020.100413">doi:10.1016/j.spasta.2020.100413</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, splines, optimx, pbapply, sf, sp, fields</td>
</tr>
<tr>
<td>Suggests:</td>
<td>autoimage, devtools, fda, igraph, testthat, future.apply,
Rmpi</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-15 18:48:54 UTC; frencjos</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-15 21:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjacent'>Determine adjacent points</h2><span id='topic+adjacent'></span>

<h3>Description</h3>

<p><code>adjacent</code> attempts to find the point(s) adjacent
(closest) to each point.  The data are implicitly assumed
to be on a grid, otherwise this function isn't very
useful. Distances between each point and other points in
<code>coords</code> are computed and then rounded using the
<code><a href="base.html#topic+round">round</a></code> function. Let <code>k</code> denote
the minimum distance between a reference point and all
other points.  A point is adjacent to the reference point
if (after rounding), it's distance from the reference
point matches the minimum distance <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacent(coords, longlat = FALSE, digits = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacent_+3A_coords">coords</code></td>
<td>
<p>A two-dimensional matrix-like object with
non-NULL dimensions.</p>
</td></tr>
<tr><td><code id="adjacent_+3A_longlat">longlat</code></td>
<td>
<p>A logical value indicating whether Great
Circle distances should be used (<code>TRUE</code>) or
Euclidean distances (<code>FALSE</code>).  The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="adjacent_+3A_digits">digits</code></td>
<td>
<p>The number of digits to use when applying
<code><a href="base.html#topic+round">round</a></code> to the distances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>digits</code> is the number of digits used by
<code><a href="base.html#topic+round">round</a></code> in the rounding process.
</p>


<h3>Value</h3>

<p>A <code>hero_adjacent</code> object.  This is simply a
list with elements <code>nbrs</code> and <code>coords</code>.
<code>nbrs</code> is a list specifying the adjacent points
for each point.  <code>coords</code> is simply the original
<code>coords</code> supplied to the function and is retained
for plotting purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># basic coordinates
coords = expand.grid(1:4, 1:4)
# plot coordinates to see relationships
plot(coords, type = "n")
text(coords)
a = adjacent(coords, digits = 1)
plot(a)
</code></pre>

<hr>
<h2 id='as.starray'>Convert array to <code>starray</code></h2><span id='topic+as.starray'></span><span id='topic+starray'></span><span id='topic+as_starray'></span>

<h3>Description</h3>

<p>Convert a three-dimensional spatio-temporal array into
an <code>starray</code> object.  The first two dimensions are
assumed to relate to gridded spatial positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.starray(x)

starray(x)

as_starray(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.starray_+3A_x">x</code></td>
<td>
<p>A three-dimensional array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>starray</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>star = as.starray(tasmax)
class(star)
</code></pre>

<hr>
<h2 id='as.sts'>Convert object to <code>sts</code> class</h2><span id='topic+as.sts'></span><span id='topic+sts'></span><span id='topic+as_sts'></span>

<h3>Description</h3>

<p>Convert a numeric three-dimensional <code>array</code> or
two-dimensional matrix-like object to an
<code>sts</code> (spatial time series) object.  If <code>x</code> is
a three-dimensional array, the first two dimensions are
assumed to relate to gridded spatial positions.  If
<code>x</code> has only two dimensions, each row is a time
series for a specific location.  Each column is a
realization of a geostatistical process at a specific
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sts(x)

sts(x)

as_sts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sts_+3A_x">x</code></td>
<td>
<p>A matrix-like object with 2 dimensions or an
array with 3 dimensions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method has been tested with objects of class
<code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="base.html#topic+data.frame">data.frame</a></code>,
<code><a href="base.html#topic+array">array</a></code>, and
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.  It should be
possible for <code>x</code> to have a different class as long
as the object has a loaded <code><a href="base.html#topic+as.matrix">as.matrix</a></code>
method, which is used in this function.
</p>


<h3>Value</h3>

<p>An <code>sts</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 3d array to sts
sts = as.sts(tasmax)
class(sts)

# extract a subset of tasmax to produce an sts
x = matrix(c(tasmax[50:60, 50:60, ]), ncol = 30)
sts = as.sts(x)
class(sts)

sts = as.sts(as.array(x))
class(sts)

sts = as.sts(Matrix::Matrix(x))
class(sts)

sts = as.sts(as.data.frame(x))
class(sts)
</code></pre>

<hr>
<h2 id='assemble'>Assemble spline ingredients for sandwich smooth</h2><span id='topic+assemble'></span><span id='topic+assemble.hero_bspline'></span><span id='topic+assemble.hero_radspline'></span><span id='topic+assemble.list'></span>

<h3>Description</h3>

<p>Assemble computations from a spline-related object
<code>x</code> in order to implement the sandwich smoother.
This is essentially an internal function, but could be
useful for performing a manual implementation of the
sandwich smoother.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assemble(object, ...)

## S3 method for class 'hero_bspline'
assemble(object, x, m = 2, sparse = TRUE, ...)

## S3 method for class 'hero_radspline'
assemble(object, x, m = 2, sparse = TRUE, spdiffpen = TRUE, digits = 1, ...)

## S3 method for class 'list'
assemble(object, x, m = 2, sparse = TRUE, spdiffpen = TRUE, digits = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assemble_+3A_object">object</code></td>
<td>
<p>A spline-related object (e.g, a
<code>hero_bspline</code> from the <code><a href="#topic+bspline">bspline</a></code>
function), or a list of spline-related objects.</p>
</td></tr>
<tr><td><code id="assemble_+3A_...">...</code></td>
<td>
<p>Not implemented</p>
</td></tr>
<tr><td><code id="assemble_+3A_x">x</code></td>
<td>
<p>Values at which to evaluate the basis functions.
This
should be a numeric vector if <code>object</code> is a
<code>hero_bspline</code>.  This should be a numeric matrix of
coordinates if <code>object</code> is a <code>hero_radspline</code>.
If <code>object</code> is a list comprised of
<code>hero_bspline</code> and <code>hero_radspline</code> objects,
then <code>x</code> should be a list where each element of the
list corresponds to the appropriate <code>x</code> argument
for each element.</p>
</td></tr>
<tr><td><code id="assemble_+3A_m">m</code></td>
<td>
<p>A positive integer indicating order of the difference penalty.</p>
</td></tr>
<tr><td><code id="assemble_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="assemble_+3A_spdiffpen">spdiffpen</code></td>
<td>
<p>A logical value indicating whether
<code><a href="#topic+spdiffpen">spdiffpen</a></code> should be used to compute the
difference penalty.  The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="assemble_+3A_digits">digits</code></td>
<td>
<p>The number of digits to use when applying
<code><a href="base.html#topic+round">round</a></code> to the distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the necessary components
(ingredients)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct b-spline
object1 = bspline(nbasis = 10)
# sequence to evaluate
x1 = seq(0, 1, len = 11)
# assemble b-spline information
spline1 = assemble(object1, x1)

# assemble radial spline information
border = border.grid(lon, lat)
object2 = radspline(nknots = 16, border)
x2 = cbind(c(lon), c(lat))
spline2 = assemble(object2, x = x2)

# assemble for list of splines
object = list(object1, object2)
x = list(x1, x2)
splines = assemble(object, x)
</code></pre>

<hr>
<h2 id='border.grid'>Construct border for grid</h2><span id='topic+border.grid'></span><span id='topic+border_grid'></span><span id='topic+borderGrid'></span><span id='topic+BorderGrid'></span>

<h3>Description</h3>

<p><code>border.grid</code> determines the border for
data on a grid.  <code>x</code> and <code>y</code> must define a
regular or irregular grid.  See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>border.grid(x, y, proj4string)

border_grid(x, y, proj4string)

borderGrid(x, y, proj4string)

BorderGrid(x, y, proj4string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="border.grid_+3A_x">x</code></td>
<td>
<p>A vector or matrix of x coordinates.  See
Details.</p>
</td></tr>
<tr><td><code id="border.grid_+3A_y">y</code></td>
<td>
<p>A vector or matrix of y coordinates.  See
Details.</p>
</td></tr>
<tr><td><code id="border.grid_+3A_proj4string">proj4string</code></td>
<td>
<p>A projection string of class
<code><a href="sp.html#topic+CRS-class">CRS-class</a></code>.  If not provided, then
default values are used.  This should be changed with
caution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A regular grid is defined by ascending numeric vectors
<code>x</code> and <code>y</code>.  A vector <code>x</code> is ascending if
<code>x[i] &lt; x[j]</code> for <code>i &lt; j</code>.
</p>
<p>An irregular grid is defind by ascending matrices.
A matrix <code>x</code> is ascending if <code>x[i, j] &lt; x[i, l]</code>
for <code>j &lt; l</code> and if <code>x[i, j] &lt; x[k, j]</code>
and <code>j &lt; k</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create x and y defining square border
x = seq(min(lon), max(lon), length = 60)
y = seq(min(lat), max(lat), length = 80)
border = border.grid(x, y)
sp::plot(border)

# use lon and lat to define border of an irregular grid
border2 = border.grid(lon, lat)
sp::plot(border2)
</code></pre>

<hr>
<h2 id='bspline'>B-spline specification</h2><span id='topic+bspline'></span>

<h3>Description</h3>

<p><code>bspline</code> helps define the parameters necessary for
constructing a B-spline but doesn't evaluate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bspline(rangeval = 0:1, nbasis, nknots, norder = 4, extend = FALSE, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bspline_+3A_rangeval">rangeval</code></td>
<td>
<p>A numeric vector of length 2 defining the
interval over which the functional data object can be
evaulated.  The default value is <code>0:1</code>.</p>
</td></tr>
<tr><td><code id="bspline_+3A_nbasis">nbasis</code></td>
<td>
<p>An integer specifying the number of
basis functions to construct.  This is closely linked to
the number of knots (<code>nknots</code>), and
<code>nknots = nbasis - norder</code>.</p>
</td></tr>
<tr><td><code id="bspline_+3A_nknots">nknots</code></td>
<td>
<p>The number of *interior* knots.  See Details.</p>
</td></tr>
<tr><td><code id="bspline_+3A_norder">norder</code></td>
<td>
<p>An integer specifying the order of the B-splines, which is one higher than their degree.  The default is 4, which corresponds to cubic splines.</p>
</td></tr>
<tr><td><code id="bspline_+3A_extend">extend</code></td>
<td>
<p>Should the knots stop at the endpoints specified by <code>rangeval</code>?  Default is <code>FALSE</code>. See Details.</p>
</td></tr>
<tr><td><code id="bspline_+3A_knots">knots</code></td>
<td>
<p>A numeric vector with all knots (interior
and exterior), including potentially replicated
endpoints.  See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The knots are assumed to be equidistant and non-repeating
(except possibly at the endpoints).
</p>
<p>The number of knots (<code>nknots</code>) and the number of
basis function (<code>nbasis</code>) are linked by the relation
<code>nknots = nbasis - norder</code>.
</p>
<p>If <code>extend = TRUE</code>,  the interior knots are
augmented by replicating the <code>rangeval</code> endpoints
<code>norder</code> times.  Otherwise, the interior knots are
augmented by <code>norder</code> knots at each end
corresponding to the spacing of the interior knots.
</p>
<p>The knot placement mimics the behavior of
<code><a href="fda.html#topic+create.bspline.basis">create.bspline.basis</a></code> when <code>extend
= FALSE</code>. Note that the number of breaks specified by
<code>breaks</code> in <code><a href="fda.html#topic+create.bspline.basis">create.bspline.basis</a></code>
corresponds to the number of interior knots plus 2 (the
interior knots plus the two endpoints).
</p>
<p>If <code>knots</code> is specified, the function does minimial
argument checking.  This is provided (mostly) for
testing purposes, though it can be used by individuals
who want more customizability of knots locations than
the equidistant spacing provided by default.
</p>


<h3>Value</h3>

<p>An object of class <code>hero_bspline</code>.  It is a
list specifying the necessary B-spline parameters.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knot.design">knot.design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bspline(nbasis = 10)
</code></pre>

<hr>
<h2 id='circulate'>Circulate values of a vector</h2><span id='topic+circulate'></span>

<h3>Description</h3>

<p>The first <code>n</code> values of <code>x</code> are circulated
from the front of <code>x</code> to the back of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circulate(x, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulate_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="circulate_+3A_n">n</code></td>
<td>
<p>The number of values to circulate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The circulated vector
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circulate(1:10, n = 2)
circulate(as.list(1:10), n = 2)
</code></pre>

<hr>
<h2 id='connect'>Connect <code>hero_radsplines</code></h2><span id='topic+connect'></span>

<h3>Description</h3>

<p><code>connect</code> joins multiple <code>hero_radspline</code>
objects into a single <code>hero_radspline</code>.
The <code>e</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connect_+3A_...">...</code></td>
<td>
<p>A sequence of <code>hero_radspline</code> objects from the
<code><a href="#topic+radspline">radspline</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combined <code>hero_radspline</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radspline">radspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>border = border.grid(lon, lat)
s1 = radspline(nknots = 36, border = border)
plot(s1)
s2 = radspline(nknots = 36 * 4, border = border,
               width = 6)
plot(s2)
par(mfrow = c(1, 2))
plot(s1)
plot(s2)
par(mfrow = c(1, 1))
s = connect(s1, s2)
plot(s)
</code></pre>

<hr>
<h2 id='create.prepared_list'>Manually create a <code>prepared_list</code></h2><span id='topic+create.prepared_list'></span>

<h3>Description</h3>

<p><code>create.prepared_list</code> creates a
<code>prepared_list</code> manually.  Typically, one would
simply use the <code><a href="#topic+prepare.list">prepare.list</a></code>, but there are
situations where the <code>data</code> argument would be too
large to read into memory. <br /> This function assumes that
the user has used the <code><a href="#topic+assemble">assemble</a></code> function to
construct a list of the relevant <code>assembled_splines</code>
and manually computed <code>Ytilde</code> for a number of
relevant <code>data</code> observations and stored them in a
list. The user should also manually compute the sum of
the squared <code>data</code> for each <code>data</code> observation.
The user must also specify the dimensions of each data
set (which are assumed to be the same) as a vector and
provide the relevant set of values at which each
<code>data</code> object is observed.  See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.prepared_list(assembled, x, Ytilde, sum_ysq, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.prepared_list_+3A_assembled">assembled</code></td>
<td>
<p>A list of <code>assembled_splines</code>.  See
Examples.</p>
</td></tr>
<tr><td><code id="create.prepared_list_+3A_x">x</code></td>
<td>
<p>The list of arguments at which to evaluate each
of the splines used to construct <code>assembled</code>.</p>
</td></tr>
<tr><td><code id="create.prepared_list_+3A_ytilde">Ytilde</code></td>
<td>
<p>A list of <code>prepared_*</code> objects.</p>
</td></tr>
<tr><td><code id="create.prepared_list_+3A_sum_ysq">sum_ysq</code></td>
<td>
<p>A vector with the sum of squared <code>data</code>
objects used to construct <code>Ytilde</code>.</p>
</td></tr>
<tr><td><code id="create.prepared_list_+3A_n">n</code></td>
<td>
<p>The dimensions of the <code>data</code> objects used
to construct <code>Ytilde</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A prepared list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate and prepare 3d data
set.seed(9)
dat = generate.data3d()

# list giving the locations to evaluate the basis functions
x = dat$x
# construct a set of basic B-splines for each dimension
splines = default.splines(x)

# construct assembled splines from splines list
a = assemble(splines, x)

# imagine there are 4 data obsevations we want to smooth
# but that they can't be loaded into memory
Ytilde = vector("list", 4)
sum_ysq = numeric(4)

# prepare each data set manually
# notice the use of the assembled arguments so that
# the splines are not "assembled" again for each data set
for(i in seq_along(Ytilde)) {
    data = generate.data3d()$data3d
    Ytilde[[i]] = prepare(data, x = x, splines = splines,
                          assembled = a)
    sum_ysq[i] = sum(data^2)
}
n = dim(data)
p = create.prepared_list(assembled = a, x = x,
                         Ytilde = Ytilde, sum_ysq = sum_ysq,
                         n = n)
</code></pre>

<hr>
<h2 id='default.evalargs'>Construct default <code>evalargs</code></h2><span id='topic+default.evalargs'></span>

<h3>Description</h3>

<p>Create a default <code>evalargs</code> object based on
<code>data</code>.  This is just a list of sequences.
If <code>ni = dim(data)[i]</code>, then the sequence for
dimension i is <code>seq(0, 1, len = ni)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default.evalargs(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.evalargs_+3A_data">data</code></td>
<td>
<p>A matrix or array-like object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of equidistance sequences between 0 and 1
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = array(rnorm(10 * 11 * 12), dim = 10:12)
default.evalargs(a)
</code></pre>

<hr>
<h2 id='default.splines'>Construct default splines</h2><span id='topic+default.splines'></span>

<h3>Description</h3>

<p>Construct a list of <code>hero_bsplines</code> using the
default values suggested by Ruppert, Wand, and Carroll
(2003).  Specifically, if
<code>r = range(evalargs[[i]])</code> and
<code>l = length(evalargs[[i]])</code>, then Ruppert, Wand,
and Carroll (2003) suggest
<code>nknots = min(ceiling(l/4), 35)</code> and the function
returns the <code>hero_bspline</code> for that dimension as
<code>bspline(r, nknots = nknots)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default.splines(evalargs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.splines_+3A_evalargs">evalargs</code></td>
<td>
<p>A list of equidistant sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>hero_bsplines</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Ruppert, D., Wand, M. P., &amp; Carroll, R. J. (2003).
Semiparametric Regression. Cambridge University Press.
&lt;doi:10.1017/CBO9780511755453&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 = seq(0, 1, len = 10)
s2 = seq(0, 1, len = 20)
default.splines(list(s1, s2))
</code></pre>

<hr>
<h2 id='diffpen'>P-spline difference penalty</h2><span id='topic+diffpen'></span>

<h3>Description</h3>

<p>P-spline difference penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffpen(x, m = 2, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffpen_+3A_x">x</code></td>
<td>
<p>A <code>hero_bspline</code> object produced by <code><a href="#topic+bspline">bspline</a></code>.</p>
</td></tr>
<tr><td><code id="diffpen_+3A_m">m</code></td>
<td>
<p>A positive integer indicating order of the difference penalty.</p>
</td></tr>
<tr><td><code id="diffpen_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="Matrix.html#topic+sparseMatrix-class">sparseMatrix-class</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b = bspline(nbasis = 10)
diffpen(b)
</code></pre>

<hr>
<h2 id='enhance'>Enhance penalty value</h2><span id='topic+enhance'></span>

<h3>Description</h3>

<p><code>enhance</code> enhances the sandwich smoother by choosing
the optimal penalty value that minimizes the GCV
statistic.    The <code><a href="optimx.html#topic+optimx">optimx</a></code> function
is used to do the optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enhance(
  obj,
  par = rep(0, length(obj$n)),
  lower = rep(-20, length(par)),
  upper = rep(20, length(par)),
  method = "L-BFGS-B",
  control = list(),
  prepare = TRUE,
  loggcv = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enhance_+3A_obj">obj</code></td>
<td>
<p>A <code>prepared_*</code> object from a
<code><a href="#topic+prepare">prepare</a></code> function.</p>
</td></tr>
<tr><td><code id="enhance_+3A_par">par</code></td>
<td>
<p>a vector of initial values for the parameters 
for which optimal values are to be found. Names on the elements
of this vector are preserved and used in the results data frame.</p>
</td></tr>
<tr><td><code id="enhance_+3A_lower">lower</code>, <code id="enhance_+3A_upper">upper</code></td>
<td>
<p>Bounds on the variables for methods such as <code>"L-BFGS-B"</code> that can
handle box (or bounds) constraints.</p>
</td></tr>
<tr><td><code id="enhance_+3A_method">method</code></td>
<td>
<p>The method to be used for optimization. The
default is <code>L-BFGS-B</code>, which allows for
constraints on the parameters to optimize.  See
<code><a href="optimx.html#topic+optimx">optimx</a></code> for all available methods.</p>
</td></tr>
<tr><td><code id="enhance_+3A_control">control</code></td>
<td>
<p>A list of control parameters. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="enhance_+3A_prepare">prepare</code></td>
<td>
<p>A logical value.  The default is <code>TRUE</code>,
indicating that a <code>prepared_data</code> object should be
returned.  If <code>FALSE</code>, then the results of the
call to the <code><a href="optimx.html#topic+optimx">optimx</a></code> function is
returned.</p>
</td></tr>
<tr><td><code id="enhance_+3A_loggcv">loggcv</code></td>
<td>
<p>A logical value indicating whether the log
of the GCV statistic should be used.  Useful for very large
data sets.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="enhance_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to to the
<code><a href="optimx.html#topic+optimx">optimx</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, the <code><a href="#topic+loglambda2gcv">loglambda2gcv</a></code> is  used as
the objective function for the
<code><a href="optimx.html#topic+optimx">optimx</a></code> function. Many different
optimization methods are available.  The default is
<code>L-BFGS-B</code>, which allows for constraints on the
parameters to optimize.  Another excellent choice is the
<code>nlminb</code> algorithm, which also allows for parameter
constraints.
</p>


<h3>Value</h3>

<p>By default, a <code>prepared_data</code> object with
the optimal <code>loglambda</code> values that minimize the
GCV, along with an additional component,
<code>results</code>, that contains the optimization results.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create b-splines
x1 = bspline(nbasis = 10)
x2 = bspline(nbasis = 12)

# observed data locations
evalarg1 = seq(0, 1, len = 60)
evalarg2 = seq(0, 1, len = 80)

# construct "true" data
mu = matrix(0, nrow = 60, ncol = 80)
for(i in seq_len(60)) {
   for(j in seq_len(80)) {
      mu[i, j] =  sin(2*pi*(evalarg1[i]-.5)^3)*cos(4*pi*evalarg2[j])
   }
}
# construct noisy data
data = mu + rnorm(60 * 80)

obj = prepare(data, list(evalarg1, evalarg2), list(x1, x2))
enhance(obj)
</code></pre>

<hr>
<h2 id='enhance.grid'>Enhance penalty value using grid search</h2><span id='topic+enhance.grid'></span>

<h3>Description</h3>

<p><code>enhance.grid</code> enhances the sandwich smoother by
choosing a optimal penalty value to lower the GCV
statistic.  A grid search algorithm is utilized based on
the each row of <code>par</code>.  The penalty values (assumed
to be on the log scale) are passed to the
<code><a href="#topic+loglambda2gcv">loglambda2gcv</a></code> function.  If <code>prepare</code>
is <code>TRUE</code>, then <code>obj</code> is returned with the
penalty values that minimize the GCV statistic during the
grid search.  Otherwise, the complete results of the grid
search are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enhance.grid(obj, par, prepare = TRUE, loggcv = FALSE, ..., cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enhance.grid_+3A_obj">obj</code></td>
<td>
<p>A <code>prepared_*</code> object from a
<code><a href="#topic+prepare">prepare</a></code> function.</p>
</td></tr>
<tr><td><code id="enhance.grid_+3A_par">par</code></td>
<td>
<p>A matrix-like object (i.e.,
<code>!is.null(dim(par)))</code>).  Each row contains a set
of parameter values for which the GCV statistic should
be computed.  The number of columns of <code>par</code>
should match the dimensionality of <code>obj</code>, i.e,
should equal <code>length(obj)$n</code>.  If missing, the
default choices are a row of -20s, a row of 0s, and a
row of 20s.</p>
</td></tr>
<tr><td><code id="enhance.grid_+3A_prepare">prepare</code></td>
<td>
<p>A logical value.  The default is <code>TRUE</code>,
indicating that a <code>prepared_data</code> object should be
returned.  If <code>FALSE</code>, then the results of the
call to the <code><a href="optimx.html#topic+optimx">optimx</a></code> function is
returned.</p>
</td></tr>
<tr><td><code id="enhance.grid_+3A_loggcv">loggcv</code></td>
<td>
<p>A logical value indicating whether the log
of the GCV statistic should be used.  Useful for very large
data sets.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="enhance.grid_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to to the
<code><a href="#topic+loglambda2gcv">loglambda2gcv</a></code> function.</p>
</td></tr>
<tr><td><code id="enhance.grid_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a <code>prepared_*</code> object with the
optimal <code>loglambda</code> values that minimize the GCV,
along with an additional component, <code>results</code>,
that contains the optimization results. Otherwise, the
complete results of the grid search.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create b-splines
b1 = bspline(nbasis = 10)
b2 = bspline(nbasis = 12)

# observed data locations
x1 = seq(0, 1, len = 60)
x2 = seq(0, 1, len = 80)

# construct "true" data
mu = matrix(0, nrow = 60, ncol = 80)
for(i in seq_len(60)) {
   for(j in seq_len(80)) {
      mu[i, j] =  sin(2*pi*(x1[i]-.5)^3)*cos(4*pi*x2[j])
   }
}
# construct noisy data
data = mu + rnorm(60 * 80)

obj = prepare(data, list(x1, x2), list(b1, b2))
enhance.grid(obj, prepare = FALSE)
</code></pre>

<hr>
<h2 id='enlarge'>Enlarge spatial domain</h2><span id='topic+enlarge'></span>

<h3>Description</h3>

<p>Enlarge the spatial domain of a
<code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code> object.  If
<code>width</code> isn't specified, then 10% of the maximum
distance between the points specified by the bounding
box is used. The
<code><a href="sf.html#topic+st_buffer">st_buffer</a></code> function is used to enlarge
<code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enlarge(x, width, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enlarge_+3A_x">x</code></td>
<td>
<p>A <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code> object
defining the border(s) of the spatial domain.</p>
</td></tr>
<tr><td><code id="enlarge_+3A_width">width</code></td>
<td>
<p>The width to enlarge the study area.
Distance from original geometry to include in the new
geometry. Negative values are allowed.</p>
</td></tr>
<tr><td><code id="enlarge_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to
<code><a href="sf.html#topic+st_buffer">st_buffer</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>hero_enlarge</code>.  This is
simply a list with <code>eborder</code> (the enlarged
border), <code>border</code> (the border of the original
coordinates), and the width of the enlargement.
<code>eborder</code> and <code>border</code> are
<code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># enlarge regular grid
# create x and y defining square border
x = seq(min(lon), max(lon), length = 60)
y = seq(min(lat), max(lat), length = 80)
border = border.grid(x, y)
e = enlarge(border)
plot(e)

# create x and y defininging an irregular grid
border2 = border.grid(lon, lat)
e2 = enlarge(border2)
plot(e2)
</code></pre>

<hr>
<h2 id='generate.data2d'>Generate 2d data</h2><span id='topic+generate.data2d'></span><span id='topic+generate_data2d'></span><span id='topic+generateData2d'></span><span id='topic+GenerateData2d'></span>

<h3>Description</h3>

<p>Generate two-dimensional data related to the f1 function
of Lu et al. (2012) (code from author).  Define <code>n =
c(60, 80)</code>.  Then <code>x[[i]] = (1:n[i])/n[i] -
1/2/n[i]</code>.  These are the observed data locations. For
<code>i</code> and <code>j</code> spanning the full length of each
element of <code>x</code>, <code>mu2d[i, j] = sin(2 * pi *
(x[[1]][i] - .5) ^ 3) * cos(4 * pi * x[[2]][j])</code>.  Lastly,
<code>data2d = mu2d + rnorm(prod(n))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.data2d()

generate_data2d()

generateData2d()

GenerateData2d()
</code></pre>


<h3>Value</h3>

<p>A list with components <code>x</code>, <code>mu2d</code>, and
<code>data2d</code>.  <code>x</code> is a list of sequences with
length 60 and 80.  <code>mu2d</code> and <code>data2d</code> are
matrices of size 60 by 80.
</p>


<h3>Author(s)</h3>

<p>Joshua French.  Based off code by Luo Xiao (see
References).
</p>


<h3>References</h3>

<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat = generate.data2d()
</code></pre>

<hr>
<h2 id='generate.data3d'>Generate 3d data</h2><span id='topic+generate.data3d'></span><span id='topic+generate_data3d'></span><span id='topic+generateData3d'></span><span id='topic+GenerateData3d'></span>

<h3>Description</h3>

<p>Generate data related to Section 7.2 of Lu et al. (2012)
(code from author).  Define <code>n = c(128,
  128, 24)</code>.  Then <code>x[[i]] = (1:n[i])/n[i] -
  1/2/n[i]</code>.  These are the observed data locations. For
<code>i</code>, <code>j</code>, <code>k</code> spanning the full length
of each element of <code>x</code>, <code>mu3d[i, j, k] =
  x[[1]][i]^2 + x[[2]][j]^2 + x[[3]][k]^2</code>.  Lastly,
<code>data3d = mu3d + 0.5 * rnorm(n[1] * n[2] * n[3])</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.data3d()

generate_data3d()

generateData3d()

GenerateData3d()
</code></pre>


<h3>Value</h3>

<p>A list with components <code>x</code>, <code>mu3d</code>, and
<code>data3d</code>.  <code>x</code> is a list of sequences with
length 128, 128, and 24.  <code>mu3d</code> and <code>data3d</code>
are arrays of size 128 by 128 by 24.
</p>


<h3>Author(s)</h3>

<p>Joshua French.  Based off code by Luo Xiao (see
References).
</p>


<h3>References</h3>

<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat = generate.data3d()
</code></pre>

<hr>
<h2 id='hero'>Construct a hero sandwich smoother</h2><span id='topic+hero'></span><span id='topic+hero.prepared_array'></span><span id='topic+hero.prepared_list'></span><span id='topic+hero.prepared_matrix'></span><span id='topic+hero.prepared_numeric'></span><span id='topic+hero.prepared_sequential'></span><span id='topic+hero.prepared_starray'></span><span id='topic+hero.prepared_sts'></span>

<h3>Description</h3>

<p><code>hero</code> constructs a hero sandwich smoother based off
off a prepared data object coming from the
<code><a href="#topic+prepare">prepare</a></code> function.  <br />
Subclasses are added (e.g., <code>hero_numeric</code>,
<code>hero_matrix</code>, <code>hero_array</code>, etc.) are added to
the returned object for plotting purposes.
<br />
A list is returned (and the data locations are not) for
<code>hero.prepared_list</code>.  Each element of the list
contains the coefficients and fitted values (if <code>fitted</code> is
TRUE) for the respective data observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hero(x, ...)

## S3 method for class 'prepared_array'
hero(x, ...)

## S3 method for class 'prepared_list'
hero(x, ..., fitted = FALSE)

## S3 method for class 'prepared_matrix'
hero(x, ...)

## S3 method for class 'prepared_numeric'
hero(x, ...)

## S3 method for class 'prepared_sequential'
hero(
  x,
  ...,
  export_list,
  export_fun = base::saveRDS,
  package = "base",
  call_args = list()
)

## S3 method for class 'prepared_starray'
hero(x, ...)

## S3 method for class 'prepared_sts'
hero(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hero_+3A_x">x</code></td>
<td>
<p>Data prepared via the <code><a href="#topic+prepare">prepare</a></code>
function.</p>
</td></tr>
<tr><td><code id="hero_+3A_...">...</code></td>
<td>
<p>Mostly not implemented.  <code>hero.prepared_list</code> takes
the <code>fitted</code> argument, specifying whether the <code>fitted</code>
values should be returned.</p>
</td></tr>
<tr><td><code id="hero_+3A_fitted">fitted</code></td>
<td>
<p>A logical value indicating whether the fitted values should be
computed. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hero_+3A_export_list">export_list</code></td>
<td>
<p>A vector or list whose elements tell <code>export_fun</code>
what files to export. The length must match the number of observations,
i.e., the number of elements in <code>x$Ytilde</code></p>
</td></tr>
<tr><td><code id="hero_+3A_export_fun">export_fun</code></td>
<td>
<p>A function that will write the results for each observation
to file using the names in <code>export_list</code>. Must only have the arguments
<code>object</code>, which is what will be saved and computed internally, and
<code>file</code>, which is the name of the file that will be saved. <code>file</code>
will be one of the elements of <code>export_list</code>.</p>
</td></tr>
<tr><td><code id="hero_+3A_package">package</code></td>
<td>
<p>A character string indicating the approach to use for the
computations. The choices are <code>"base"</code>, <code>"parallel"</code>,
<code>"pbapply"</code>, <code>"future.apply"</code>, or <code>"Rmpi"</code>. The default is
<code>"base"</code>. If <code>package == "base"</code>, then <code><a href="base.html#topic+mapply">mapply</a></code>
is used. If <code>package == "parallel"</code>, then
<code><a href="parallel.html#topic+mcmapply">mcmapply</a></code> is used. If <code>package == "pbapply"</code>,
then <code><a href="pbapply.html#topic+pblapply">pblapply</a></code> is used. If codepackage ==
&quot;future.apply&quot;, then <code><a href="future.apply.html#topic+future_mapply">future_mapply</a></code> is used. If
codepackage == &quot;Rmpi&quot;, then <code><a href="Rmpi.html#topic+mpi.applyLB">mpi.applyLB</a></code> is used.</p>
</td></tr>
<tr><td><code id="hero_+3A_call_args">call_args</code></td>
<td>
<p>A named list providing relevant arguments to
<code><a href="parallel.html#topic+mcmapply">mcmapply</a></code>, <code><a href="pbapply.html#topic+pblapply">pblapply</a></code>,
<code><a href="future.apply.html#topic+future_mapply">future_mapply</a></code>, or
<code><a href="Rmpi.html#topic+mpi.applyLB">mpi.applyLB</a></code>, depending on the <code>package</code> choice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>hero</code> object with the smoothed data
(<code>fitted</code>), the estimated coefficients for the
basis functions (<code>coefficients</code>), and the
locations of the original data (<code>x</code>).
</p>


<h3>Author(s)</h3>

<p>Joshua French.
</p>


<h3>References</h3>

<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>
<p>French, Joshua P., and Piotr S. Kokoszka. &quot;A sandwich
smoother for spatio-temporal functional data.&quot; Spatial
Statistics 42 (2021): 100413.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create b-splines
x1 = bspline(nbasis = 10)
x2 = bspline(nbasis = 12)

# observed data locations
evalarg1 = seq(0, 1, len = 60)
evalarg2 = seq(0, 1, len = 80)

# construct "true" data
mu = matrix(0, nrow = 60, ncol = 80)
for(i in seq_len(60)) {
   for(j in seq_len(80)) {
      mu[i, j] =  sin(2*pi*(evalarg1[i]-.5)^3)*cos(4*pi*evalarg2[j])
   }
}
# construct noisy data
data = mu + rnorm(60 * 80)

obj = prepare(data, list(evalarg1, evalarg2), list(x1, x2))
obj = enhance(obj)
sandmod = hero(obj)
plot(sandmod)
</code></pre>

<hr>
<h2 id='knot.design'>Design knot/breakpoint spacing</h2><span id='topic+knot.design'></span><span id='topic+knot_design'></span><span id='topic+knotDesign'></span><span id='topic+KnotDesign'></span>

<h3>Description</h3>

<p>See Details of <code><a href="#topic+bspline">bspline</a></code> for additional
information about arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knot.design(
  rangeval = 0:1,
  nbasis,
  nknots,
  norder = 4,
  extend = FALSE,
  interior = FALSE
)

knot_design(
  rangeval = 0:1,
  nbasis,
  nknots,
  norder = 4,
  extend = FALSE,
  interior = FALSE
)

knotDesign(
  rangeval = 0:1,
  nbasis,
  nknots,
  norder = 4,
  extend = FALSE,
  interior = FALSE
)

KnotDesign(
  rangeval = 0:1,
  nbasis,
  nknots,
  norder = 4,
  extend = FALSE,
  interior = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knot.design_+3A_rangeval">rangeval</code></td>
<td>
<p>A numeric vector of length 2 defining the
interval over which the functional data object can be
evaulated.  The default value is <code>0:1</code>.</p>
</td></tr>
<tr><td><code id="knot.design_+3A_nbasis">nbasis</code></td>
<td>
<p>An integer specifying the number of
basis functions to construct.  This is closely linked to
the number of knots (<code>nknots</code>), and
<code>nknots = nbasis - norder</code>.</p>
</td></tr>
<tr><td><code id="knot.design_+3A_nknots">nknots</code></td>
<td>
<p>The number of *interior* knots.  See Details.</p>
</td></tr>
<tr><td><code id="knot.design_+3A_norder">norder</code></td>
<td>
<p>An integer specifying the order of the B-splines, which is one higher than their degree.  The default is 4, which corresponds to cubic splines.</p>
</td></tr>
<tr><td><code id="knot.design_+3A_extend">extend</code></td>
<td>
<p>Should the knots stop at the endpoints specified by <code>rangeval</code>?  Default is <code>FALSE</code>. See Details.</p>
</td></tr>
<tr><td><code id="knot.design_+3A_interior">interior</code></td>
<td>
<p>A logical value specifying whether only interior knots should be returned.  Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ascending sequence of univarite knot locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("fda", quietly = TRUE)) {
b = fda::create.bspline.basis(nbasis = 10)
# interior knots only
bknots = b$params
# should match
knots = knot.design(nbasis = 10, interior = TRUE)
all.equal(bknots, knots)
}
</code></pre>

<hr>
<h2 id='kronecker.seq'>A sequence of kronecker products</h2><span id='topic+kronecker.seq'></span><span id='topic+kronecker_seq'></span><span id='topic+kroneckerSeq'></span><span id='topic+KroneckerSeq'></span>

<h3>Description</h3>

<p>A sequence of kronecker products
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kronecker.seq(X, FUN = "*", make.dimnames = FALSE, ...)

kronecker_seq(X, FUN = "*", make.dimnames = FALSE, ...)

kroneckerSeq(X, FUN = "*", make.dimnames = FALSE, ...)

KroneckerSeq(X, FUN = "*", make.dimnames = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kronecker.seq_+3A_x">X</code></td>
<td>
<p>A list of numeric matrices or arrays</p>
</td></tr>
<tr><td><code id="kronecker.seq_+3A_fun">FUN</code></td>
<td>
<p>a function; it may be a quoted string.</p>
</td></tr>
<tr><td><code id="kronecker.seq_+3A_make.dimnames">make.dimnames</code></td>
<td>
<p>Provide dimnames that are the product of the
dimnames of <code>X</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code id="kronecker.seq_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 = matrix(rnorm(16), nrow = 4)
x2 = matrix(rnorm(25), nrow = 5)
x3 = matrix(rnorm(36), nrow = 6)
x4 = matrix(rnorm(49), nrow = 7)
p1 = x1 %x% x2 %x% x3 %x% x4
p2 = kronecker.seq(list(x1, x2, x3, x4))
all.equal(p1, p2)
</code></pre>

<hr>
<h2 id='loglambda2gcv'>Determine GCV statistic</h2><span id='topic+loglambda2gcv'></span>

<h3>Description</h3>

<p><code>loglambda2gcv</code> uses a vector of penalty values
to evaluate the GCV statistic for a
<code>prepared_response</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglambda2gcv(loglambda, obj, loggcv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglambda2gcv_+3A_loglambda">loglambda</code></td>
<td>
<p>A vector of penalty values (assumed to
be on a natural logarithmic scale) for computing the GCV.</p>
</td></tr>
<tr><td><code id="loglambda2gcv_+3A_obj">obj</code></td>
<td>
<p>A <code>prepared_*</code> object from a
<code><a href="#topic+prepare">prepare</a></code> function.</p>
</td></tr>
<tr><td><code id="loglambda2gcv_+3A_loggcv">loggcv</code></td>
<td>
<p>A logical value indicating whether the log of the
GCV statistic should be returned.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Though this function can be used by the user, it is
basically an internal function used to find the
value of <code>loglambda</code> minimizing the GCV statistic.
</p>


<h3>Value</h3>

<p>The scalar GCV statistic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare">prepare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 = 10
b1 = bspline(nbasis = 10)
x1 = seq(0, 1, len = n1)
n2 = 20
x2 = seq(0, 1, len = n2)
b2 = bspline(nbasis = 12)
# construct "true" data
mu = matrix(0, nrow = n1, ncol = n2)
for(i in seq_len(n1)) {
   for(j in seq_len(n2)) {
      mu[i, j] =  sin(2*pi*(x1[i]-.5)^3)*cos(4*pi*x2[j])
   }
}
image(mu)
# construct noisy data
data = mu + rnorm(n1 * n2)
x = list(x1, x2)
splines = list(b1, b2)
obj = prepare(data, x, splines)
loglambda2gcv(c(0, 0), obj)
</code></pre>

<hr>
<h2 id='ludata'>Data for f1 function from Lu et al. (2012)</h2><span id='topic+ludata'></span><span id='topic+x'></span><span id='topic+z'></span><span id='topic+lutruef1'></span><span id='topic+lunoisyf1'></span>

<h3>Description</h3>

<p>Data related to the f1 function in
Lu et al. (2012).  Define <code>n1 = 60</code> and
<code>x = seq_len(n1)/n1 - 1/2/n1</code>.  Similarly,
define <code>n2 = 80</code> and
<code>z = seq_len(n2)/n2 - 1/2/n2</code>.  The f1 function is defined as
<code>sin(2 * pi * (x[i] - .5) ^ 3) * cos(4 * pi * z[j])</code>,
where <code>i in seq_along(x)</code> and
<code>j in seq_along(z)</code>.  The result of this function
is stored in <code>lutruef1</code>.  Using <code>set.seed(3)</code>
and adding <code>rnorm(60 * 80)</code> to <code>lutruef1</code>
results in <code>lunoisyf1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ludata)
</code></pre>


<h3>Format</h3>

<p>The sequences <code>x</code> and <code>z</code>, the
<code>lutruef1</code> data matrix with 60 rows and 80 columns,
and the <code>lunoisyf1</code> data matrix with 60 rows and 80
columns.
</p>

<hr>
<h2 id='plot.hero_adjacent'>Plot a <code>hero_adjacent</code> object</h2><span id='topic+plot.hero_adjacent'></span>

<h3>Description</h3>

<p>Plot a <code>hero_adjacent</code> object.  <code>x$nbrs</code> is
used to construct a
<code><a href="Matrix.html#topic+sparseMatrix-class">sparseMatrix-class</a></code> object.  The
default behavior is to plot the sparse matrix using the
<code><a href="graphics.html#topic+image">image</a></code> function.  However, if the
igraph package is installed, a graph is made using
<code><a href="igraph.html#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix</a></code> and
then plotted using <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hero_adjacent'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hero_adjacent_+3A_x">x</code></td>
<td>
<p>A <code>hero_adjacent</code> object</p>
</td></tr>
<tr><td><code id="plot.hero_adjacent_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="graphics.html#topic+image">image</a></code>, or if the igraph package
is installed, <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>coords = expand.grid(1:4, 1:4)
a = adjacent(coords, digits = 1)
plot(a)
</code></pre>

<hr>
<h2 id='plot.hero_bspline'>Plot a <code>hero_bspline</code> object</h2><span id='topic+plot.hero_bspline'></span>

<h3>Description</h3>

<p>Plots basis functions specified by results of <code><a href="#topic+bspline">bspline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hero_bspline'
plot(x, nderiv = 0L, type = "l", kcol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hero_bspline_+3A_x">x</code></td>
<td>
<p>An object of class <code>hero_bspline</code> to be plotted.</p>
</td></tr>
<tr><td><code id="plot.hero_bspline_+3A_nderiv">nderiv</code></td>
<td>
<p>An integer value specifying the derivative order of the B-splines.  The default is 0.</p>
</td></tr>
<tr><td><code id="plot.hero_bspline_+3A_type">type</code></td>
<td>
<p>character string (length 1 vector) or vector of 1-character
strings indicating the type of plot for each
column of <code>y</code>, see <code><a href="graphics.html#topic+plot">plot</a></code> for all possible
<code>type</code>s.  The first character of <code>type</code>
defines the first plot, the second character the second, etc.
Characters in <code>type</code> are cycled through; e.g., <code>"pl"</code>
alternately plots points and lines.</p>
</td></tr>
<tr><td><code id="plot.hero_bspline_+3A_kcol">kcol</code></td>
<td>
<p>Color for vertical lines drawn at interior knots.  Default is <code>NULL</code>, meaning no lines are drawn.</p>
</td></tr>
<tr><td><code id="plot.hero_bspline_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to <code><a href="graphics.html#topic+matplot">matplot</a></code> function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bspline">bspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = bspline(nbasis = 10, extend = FALSE)
plot(x)
plot(x, nderiv = 1)
plot(x, kcol = "grey") # plot vertical lines at knots

# extend knots passed rangeval
x2 = bspline(nbasis = 10, extend = TRUE)
plot(x2, kcol = "grey")

# compare to plot.fd
if (requireNamespace("fda", quietly = TRUE)) {
   x3 = fda::create.bspline.basis(nbasis = 10)
   par(mfrow = c(2, 1))
   plot(x, kcol = "grey")
   title("plot.hero_bspline")
}
plot(x3)
title("plot.fd")
</code></pre>

<hr>
<h2 id='plot.hero_enlarge'>Plot a <code>hero_enlarge</code> object</h2><span id='topic+plot.hero_enlarge'></span>

<h3>Description</h3>

<p>Plot the enlarged and original border defined be a
set of coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hero_enlarge'
plot(x, ..., blist = list(col = "grey"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hero_enlarge_+3A_x">x</code></td>
<td>
<p>An object of class <code>hero_enlarge</code>.</p>
</td></tr>
<tr><td><code id="plot.hero_enlarge_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to the
plotting method for <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code>
for <code>x$eborder</code></p>
</td></tr>
<tr><td><code id="plot.hero_enlarge_+3A_blist">blist</code></td>
<td>
<p>A list of additional graphical parameters
passed to the plotting method for <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code>
for <code>x$border</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b = border.grid(lon, lat)
e = enlarge(b)
plot(e)
</code></pre>

<hr>
<h2 id='plot.hero_matrix'>Plot a <code>hero</code> object</h2><span id='topic+plot.hero_matrix'></span><span id='topic+plot.hero_numeric'></span>

<h3>Description</h3>

<p>Plot the smoothed data produced by the
<code><a href="#topic+hero">hero</a></code>
function.  The behavior of the function changes depending
on the subclass of the <code>hero</code> object.  See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hero_matrix'
plot(x, xlab = "", ylab = "", ...)

## S3 method for class 'hero_numeric'
plot(x, xlab = "", ylab = "", type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hero_matrix_+3A_x">x</code></td>
<td>
<p>An object of class <code>hero</code>.</p>
</td></tr>
<tr><td><code id="plot.hero_matrix_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plot.hero_matrix_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="plot.hero_matrix_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to the
relevant plotting function.  See Details.</p>
</td></tr>
<tr><td><code id="plot.hero_matrix_+3A_type">type</code></td>
<td>
<p>The plot type (when <code>x</code> is of subclass
<code>hero_numeric</code>).  Default is <code>type = "l"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> has subclass <code>hero_numeric</code>, then
the traditional <code><a href="graphics.html#topic+plot">plot</a></code> function
is used to plot the smoothed data, with <code>type = "l"</code>.
</p>
<p>If <code>x</code> has subclass <code>hero_matrix</code>, then
<code><a href="graphics.html#topic+image">image</a></code> is used to plot the
smoothed data, or if the autoimage package is installed,
<code><a href="autoimage.html#topic+autoimage">autoimage</a></code> is used to
plot the smoothed data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hero">hero</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create b-splines
x1 = bspline(nbasis = 10)
x2 = bspline(nbasis = 12)

# observed data locations
evalarg1 = seq(0, 1, len = 60)
evalarg2 = seq(0, 1, len = 80)

# construct "true" data
mu = matrix(0, nrow = 60, ncol = 80)
for(i in seq_len(60)) {
   for(j in seq_len(80)) {
      mu[i, j] =  sin(2*pi*(evalarg1[i]-.5)^3)*cos(4*pi*evalarg2[j])
   }
}
# construct noisy data
data = mu + rnorm(60 * 80)

obj = prepare(data, list(evalarg1, evalarg2), list(x1, x2))
obj = enhance(obj)
sandmod = hero(obj)
plot(sandmod)
</code></pre>

<hr>
<h2 id='plot.hero_radspline'>Plot a <code>hero_radspline</code></h2><span id='topic+plot.hero_radspline'></span>

<h3>Description</h3>

<p>Plot a <code>hero_radspline</code> to compare the knots to the
observed data locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hero_radspline'
plot(
  x,
  blist = list(col = "grey"),
  glist = list(col = seq_along(x$grid) + 1, pch = seq_along(x$grid)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hero_radspline_+3A_x">x</code></td>
<td>
<p>A <code>hero_radspline</code> object.</p>
</td></tr>
<tr><td><code id="plot.hero_radspline_+3A_blist">blist</code></td>
<td>
<p>A list to pass the plot method associated
with <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code> when
plotting <code>x$border</code>.  The default is a
grey-colored polygon.</p>
</td></tr>
<tr><td><code id="plot.hero_radspline_+3A_glist">glist</code></td>
<td>
<p>A list to pass the plot method associated
with <code><a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a></code> when
plotting each element of the list <code>x$grid</code>.  A
basic color scheme and point style is automatically
chosen if none is supplied.</p>
</td></tr>
<tr><td><code id="plot.hero_radspline_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass the plot method
associated with <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code>
when plotting <code>x$eborder</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the default plotting styles for <code>x$grid</code> are to
be changed, the user can either choose a single
color/style that is replicated for each element of
<code>x$grid</code> or supply a vector which has length
matching <code>length{x$grid}</code>.  See Examples.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radspline">radspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>border = border.grid(lon, lat)
r = radspline(nknots = c(36, 36 * 4), border = border)
# default color scheme
plot(r)
# change color and point styles of points,
# and background of original domain
plot(r, blist = list(col = "yellow"),
        glist = list(col = c("blue", "orange"),
                     pch =  3:4))
</code></pre>

<hr>
<h2 id='poly2SpatialPolygons'>Convert simple polygon to a <code>SpatialPolygons</code> object</h2><span id='topic+poly2SpatialPolygons'></span>

<h3>Description</h3>

<p>This function takes a simple polygon and attempts to
convert it to a <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> object.
This list is assumed to have components <code>x</code> and
<code>y</code> that define the boundary of the polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly2SpatialPolygons(x, ID = "border")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly2SpatialPolygons_+3A_x">x</code></td>
<td>
<p>A list with components <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="poly2SpatialPolygons_+3A_id">ID</code></td>
<td>
<p>The name of the resulting polygon.  Default is
<code>"border"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> object
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>angle = seq(0, 2 * pi, len = 100)
poly = list(x = cos(angle), y = sin(angle))
plot(poly, type = "l", asp = 1)
sppoly = poly2SpatialPolygons(poly)
library(sp)
plot(sppoly, axes = TRUE, asp = 1)
</code></pre>

<hr>
<h2 id='precompute'>Precompute objects</h2><span id='topic+precompute'></span>

<h3>Description</h3>

<p>This function is an internal function to compute
objects needed for fast implementation of the sandwich
smoother.  It is meant to be an internal function,
so use this at your own risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precompute(B, P, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precompute_+3A_b">B</code></td>
<td>
<p>A matrix of basis functions</p>
</td></tr>
<tr><td><code id="precompute_+3A_p">P</code></td>
<td>
<p>A penalty matrix</p>
</td></tr>
<tr><td><code id="precompute_+3A_m">m</code></td>
<td>
<p>Difference order of P-spline</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of needed objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>object = bspline(nbasis = 10)
# sequence to evaluate
evalarg = seq(0, 1, len = 11)
# penalty matrix
D = diffpen(object)
P = Matrix::crossprod(D)
B = predict(object, evalarg)
stuff = precompute(B, P, m = 2)
</code></pre>

<hr>
<h2 id='predict.hero'>Predict method for <code>hero</code> object</h2><span id='topic+predict.hero'></span>

<h3>Description</h3>

<p>Predict new values based on object produced by the
<code><a href="#topic+hero">hero</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hero'
predict(object, newB, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hero_+3A_object">object</code></td>
<td>
<p>A <code>hero_bspline</code> object created by
<code><a href="#topic+bspline">bspline</a></code></p>
</td></tr>
<tr><td><code id="predict.hero_+3A_newb">newB</code></td>
<td>
<p>A vector or list containing the evaluated
basis functions for the observations for
which predictions are desired.</p>
</td></tr>
<tr><td><code id="predict.hero_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the appropriate size
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create b-splines
x1 = bspline(nbasis = 10)
x2 = bspline(nbasis = 12)

# observed data locations
evalarg1 = seq(0, 1, len = 60)
evalarg2 = seq(0, 1, len = 80)

# construct "true" data
mu = matrix(0, nrow = 60, ncol = 80)
for(i in seq_len(60)) {
   for(j in seq_len(80)) {
      mu[i, j] =  sin(2*pi*(evalarg1[i]-.5)^3)*cos(4*pi*evalarg2[j])
   }
}
# construct noisy data
data = mu + rnorm(60 * 80)

obj = prepare(data, list(evalarg1, evalarg2), list(x1, x2))
obj = enhance(obj)
sandmod = hero(obj)
plot(sandmod)
newb1 = predict(x1, newx = seq(0, 1, len = 100))
newb2 = predict(x2, newx = seq(0, 1, len = 100))
newB = list(newb1, newb2)
p = predict(sandmod, newB = list(newb1, newb2))
</code></pre>

<hr>
<h2 id='predict.hero_bspline'>Predict method for <code>hero_bspline</code> object</h2><span id='topic+predict.hero_bspline'></span>

<h3>Description</h3>

<p>Predicted values based on object created by
<code><a href="#topic+bspline">bspline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hero_bspline'
predict(object, newx, nderiv = 0L, sparse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hero_bspline_+3A_object">object</code></td>
<td>
<p>A <code>hero_bspline</code> object created by
<code><a href="#topic+bspline">bspline</a></code></p>
</td></tr>
<tr><td><code id="predict.hero_bspline_+3A_newx">newx</code></td>
<td>
<p>A numeric vector of values at which to
evaluate the B-spline functions or derivatives.</p>
</td></tr>
<tr><td><code id="predict.hero_bspline_+3A_nderiv">nderiv</code></td>
<td>
<p>An integer value specifying the derivative order of the B-splines.  The default is 0.</p>
</td></tr>
<tr><td><code id="predict.hero_bspline_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="predict.hero_bspline_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n \times k</code> matrix (or
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object if
<code>sparse = TRUE</code>), where <code class="reqn">n</code> is the number of
values in <code>newx</code> and <code class="reqn">k</code> is the number of
basis functions in <code>object</code>.  Each row gives the
predicted values of the basis functions for the
appropriate value of <code>newx</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspline">bspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b = bspline(nbasis = 10)
p = predict(b, newx = seq(0, 1, len = 101))
</code></pre>

<hr>
<h2 id='predict.hero_radspline'>Predict method for a <code>hero_radspline</code></h2><span id='topic+predict.hero_radspline'></span>

<h3>Description</h3>

<p>Predicted values based on object created by
<code><a href="#topic+radspline">radspline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hero_radspline'
predict(object, newx, sparse = TRUE, longlat = FALSE, join = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hero_radspline_+3A_object">object</code></td>
<td>
<p>A <code>hero_radspline</code> object created by
<code><a href="#topic+radspline">radspline</a></code>.</p>
</td></tr>
<tr><td><code id="predict.hero_radspline_+3A_newx">newx</code></td>
<td>
<p>A numeric matrix at which to evaluate the
radial basis splines functions.</p>
</td></tr>
<tr><td><code id="predict.hero_radspline_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="predict.hero_radspline_+3A_longlat">longlat</code></td>
<td>
<p>Use Euclidean (<code>FALSE</code>) or Great Circle
(WGS84 ellipsoid) distance (<code>TRUE</code>).  Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.hero_radspline_+3A_join">join</code></td>
<td>
<p>A logical value.  <code>TRUE</code>, the default,
indicates that the predictions from each set of radial
basis functions should be joined column-wise.  Otherwise,
a list with the predictions from each set of basis functions
is returned.</p>
</td></tr>
<tr><td><code id="predict.hero_radspline_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n \times k</code> matrix (or
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object if
<code>sparse = TRUE</code>), where <code class="reqn">n</code> is the number of
rows in <code>newx</code> and <code class="reqn">k</code> is the number of
basis functions in <code>object</code>.  Each row gives the
predicted values of each <code>newx</code> value evaluated
at each of the basis functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radspline">radspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>border = border.grid(lon, lat)
r = radspline(nknots = c(36, 36 * 4), border = border)
newx = cbind(c(lon), c(lat))
p = predict(r, newx)
</code></pre>

<hr>
<h2 id='prepare'>Prepare data for sandwich smooth</h2><span id='topic+prepare'></span>

<h3>Description</h3>

<p>A generic function to prepare various types of data.  See
the functions linked in See Also.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_+3A_data">data</code></td>
<td>
<p>The data to prepare</p>
</td></tr>
<tr><td><code id="prepare_+3A_...">...</code></td>
<td>
<p>Not implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A prepared object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.numeric">prepare.numeric</a></code>,
<code><a href="#topic+prepare.matrix">prepare.matrix</a></code>,
<code><a href="#topic+prepare.array">prepare.array</a></code>,
<code><a href="#topic+prepare.sts">prepare.sts</a></code>,
<code><a href="#topic+prepare.starray">prepare.starray</a></code>
</p>

<hr>
<h2 id='prepare_sequential'>Sequentially prepare data for sandwich smooth</h2><span id='topic+prepare_sequential'></span>

<h3>Description</h3>

<p>Sequentially prepare each observation for smoothing. It is assumed that each
observation resides in its own file and that <code>do.call(import_fun,
list(import_list[i]))</code> will import the data associated with observation
<code>i</code> into memory. The <code>import_fun</code> argument should be a function
after the style of <code><a href="base.html#topic+readRDS">readRDS</a></code>, where the object can be
assigned a name once it is read in. The <code>import_fun</code> argument should NOT
be like <code><a href="base.html#topic+load">load</a></code>, where the object loaded has a preassigned
name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_sequential(
  import_list,
  import_fun = base::readRDS,
  x,
  splines,
  assembled,
  package = "base",
  call_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_sequential_+3A_import_list">import_list</code></td>
<td>
<p>A vector or list whose elements tell <code>import_fun</code>
which files to import.</p>
</td></tr>
<tr><td><code id="prepare_sequential_+3A_import_fun">import_fun</code></td>
<td>
<p>A function that will read each observation into memory
based on the elements of <code>import_list</code>.</p>
</td></tr>
<tr><td><code id="prepare_sequential_+3A_x">x</code></td>
<td>
<p>The list of arguments at which to evaluate each
of the splines used to construct <code>assembled</code>.</p>
</td></tr>
<tr><td><code id="prepare_sequential_+3A_splines">splines</code></td>
<td>
<p>A list of spline-related objects. Each element of
<code>splines</code> corresponds to the set of splines for the corresponding
element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="prepare_sequential_+3A_assembled">assembled</code></td>
<td>
<p>A list of <code>assembled_splines</code>.  See
Examples.</p>
</td></tr>
<tr><td><code id="prepare_sequential_+3A_package">package</code></td>
<td>
<p>A character string indicating the package to use for the
computations. The choices are <code>"base"</code>, <code>"parallel"</code>,
<code>"pbapply"</code>, <code>"future.apply"</code>, and <code>"Rmpi"</code>. The default is
<code>"base"</code>, in which case a standard <code>for</code> loop is used. If
<code>package == "parallel"</code>, then <code><a href="parallel.html#topic+mclapply">mclapply</a></code> is
used, which is only appropriate when <code>mc.cores</code> is integer-valued or
<code>NULL</code>. If <code>package == "pbapply"</code>, then
<code><a href="pbapply.html#topic+pblapply">pblapply</a></code> is used, which automatically provides a
progress bar. If <code>package == "future.apply"</code>, then
<code><a href="future.apply.html#topic+future_lapply">future_lapply</a></code> is used. If <code>package ==
"Rmpi"</code>, then <code><a href="Rmpi.html#topic+mpi.applyLB">mpi.applyLB</a></code> is used.</p>
</td></tr>
<tr><td><code id="prepare_sequential_+3A_call_args">call_args</code></td>
<td>
<p>A named list providing relevant arguments to the
<code><a href="parallel.html#topic+mclapply">mclapply</a></code>, <code><a href="pbapply.html#topic+pblapply">pblapply</a></code>,
<code><a href="future.apply.html#topic+future_lapply">future_lapply</a></code>, or
<code><a href="Rmpi.html#topic+mpi.applyLB">mpi.applyLB</a></code> depending on the value of <code>package</code>.</p>
</td></tr>
<tr><td><code id="prepare_sequential_+3A_...">...</code></td>
<td>
<p>Not implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>prepared_sequential</code> object
</p>


<h3>Author(s)</h3>

<p>Joshua P. French
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare">prepare</a></code>, <code><a href="parallel.html#topic+mclapply">mclapply</a></code>,
<code><a href="pbapply.html#topic+pblapply">pblapply</a></code>, <code><a href="future.apply.html#topic+future_lapply">future_lapply</a></code>,
<code><a href="Rmpi.html#topic+mpi.applyLB">mpi.applyLB</a></code>
</p>

<hr>
<h2 id='prepare.array'>Prepare data array for sandwich smooth</h2><span id='topic+prepare.array'></span>

<h3>Description</h3>

<p><code>prepare.array</code> prepares a data matrix for the
sandwich smooth.  The dimensionality of <code>data</code> and
the length of <code>x</code> must match.  Specifically,
<code>length(dim(data))</code> must equal
<code>length(x)</code>.     The dimensionality of
<code>data</code> and  the length of <code>splines</code> must match.
Specifically, <code>length(dim(data))</code> must equal
<code>length(splines)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
prepare(data, x, splines, m = 2, sparse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.array_+3A_data">data</code></td>
<td>
<p>A data array</p>
</td></tr>
<tr><td><code id="prepare.array_+3A_x">x</code></td>
<td>
<p>A list of univariate, equidistant
sequences.  These should correspond to where the data
are observed.  Equidistant spacing between 0 and 1 is
assumed if not supplied.  See Details.</p>
</td></tr>
<tr><td><code id="prepare.array_+3A_splines">splines</code></td>
<td>
<p>A list of spline-related objects, e.g.,
produced by <code><a href="#topic+bspline">bspline</a></code>.  Splines are
automatically created if not supplied.  See Details.</p>
</td></tr>
<tr><td><code id="prepare.array_+3A_m">m</code></td>
<td>
<p>A positive integer indicating order of the difference penalty.</p>
</td></tr>
<tr><td><code id="prepare.array_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="prepare.array_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a typical sandwich smooth, for data with <code class="reqn">d</code>
dimensions, <code>Y[i1, i2, ...,id]</code> is assumed to be
observed at position <code>x[[1]][i1]</code>,
<code>x[[2]][i2]</code>, ..., <code>x[[d]][id]</code>.
Consequently, <code>dim(data)[i]</code> should equal
<code>length(x[[i]])</code> for all <code>i</code> in
<code>seq_len(d)</code>.
</p>
<p>If <code>x</code> is not supplied, then
<code><a href="#topic+default.evalargs">default.evalargs</a></code> is used to create it
automatically.
</p>
<p>If <code>splines</code> is not supplied, then a B-spline basis
is automatically created for each dimension using
<code><a href="#topic+default.splines">default.splines</a></code>.
</p>


<h3>Value</h3>

<p>A <code>prepared_array</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French.  Based off code by Luo Xiao (see
References).
</p>


<h3>References</h3>

<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspline">bspline</a></code>,
<code><a href="#topic+default.evalargs">default.evalargs</a></code>,
<code><a href="#topic+default.splines">default.splines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate and prepare 3d data
set.seed(9)
dat = generate.data3d()
obj = prepare(dat$data3d, x = dat$x)
</code></pre>

<hr>
<h2 id='prepare.list'>Prepare data array for sandwich smooth</h2><span id='topic+prepare.list'></span>

<h3>Description</h3>

<p><code>prepare.list</code> prepares a list of data for the
sandwich smooth.  The class of each element of
the list must be identical.
The dimensionality of <code>data[[i]]</code> and
the length of <code>x</code> must match.  Specifically,
<code>length(dim(data[[i]]))</code> must equal
<code>length(x)</code>.     The dimensionality of
<code>data[[i]]</code> and  the length of <code>splines</code> must match.
Specifically, <code>length(dim(data[[i]]))</code> must equal
<code>length(splines)</code>.      Note: If the splines
are preassembled, these can be passed using the argument
<code>assembled</code> so that this computation is not reperformed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
prepare(data, x, splines, m = 2, sparse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.list_+3A_data">data</code></td>
<td>
<p>A list of <code>numeric</code>, <code>matrix</code>, or
<code>array</code> objects.</p>
</td></tr>
<tr><td><code id="prepare.list_+3A_x">x</code></td>
<td>
<p>A list of values at which to evaluate the basis
functions.  See Examples and Details.</p>
</td></tr>
<tr><td><code id="prepare.list_+3A_splines">splines</code></td>
<td>
<p>A list of spline objects
(<code>hero_bspline</code> and <code>hero_radspline</code>).  See
Examples and Details.</p>
</td></tr>
<tr><td><code id="prepare.list_+3A_m">m</code></td>
<td>
<p>A positive integer indicating order of the difference penalty.</p>
</td></tr>
<tr><td><code id="prepare.list_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="prepare.list_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies the functions
<code><a href="#topic+prepare.numeric">prepare.numeric</a></code>,
<code><a href="#topic+prepare.matrix">prepare.matrix</a></code>, and
<code><a href="#topic+prepare.array">prepare.array</a></code> to each element of the list,
so relevant restrictions in the arguments may be
found there.
</p>


<h3>Value</h3>

<p>A <code>prepared_list</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French.
</p>


<h3>References</h3>

<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.numeric">prepare.numeric</a></code>, <code><a href="#topic+prepare.matrix">prepare.matrix</a></code>,
<code><a href="#topic+prepare.array">prepare.array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate and prepare 3d data
set.seed(9)
dat = lapply(1:3, function (i) generate.data3d())
x = dat[[1]]$x
data = lapply(dat, getElement, name = "data3d")
obj = prepare(data, x = x)
h = hero(obj)
</code></pre>

<hr>
<h2 id='prepare.matrix'>Prepare data matrix for sandwich smooth</h2><span id='topic+prepare.matrix'></span>

<h3>Description</h3>

<p><code>prepare.matrix</code> prepares a data matrix for the
sandwich smooth.  The dimensionality of <code>data</code> and
the length of <code>x</code> must match.  Specifically,
<code>length(dim(data))</code> must equal
<code>length(x)</code>.     The dimensionality of
<code>data</code> and the length of <code>splines</code> must match.
Specifically, <code>length(dim(data))</code> must equal
<code>length(splines)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
prepare(
  data,
  x,
  splines,
  m = 2,
  sparse = TRUE,
  spdiffpen = TRUE,
  digits = 1,
  sts = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.matrix_+3A_data">data</code></td>
<td>
<p>A data matrix.</p>
</td></tr>
<tr><td><code id="prepare.matrix_+3A_x">x</code></td>
<td>
<p>A list of values at which to evaluate the basis
functions.  See Examples and Details.</p>
</td></tr>
<tr><td><code id="prepare.matrix_+3A_splines">splines</code></td>
<td>
<p>A list of spline objects
(<code>hero_bspline</code> and <code>hero_radspline</code>).  See
Examples and Details.</p>
</td></tr>
<tr><td><code id="prepare.matrix_+3A_m">m</code></td>
<td>
<p>A positive integer indicating order of the difference penalty.</p>
</td></tr>
<tr><td><code id="prepare.matrix_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="prepare.matrix_+3A_spdiffpen">spdiffpen</code></td>
<td>
<p>A logical value indicating whether
<code><a href="#topic+spdiffpen">spdiffpen</a></code> should be used to compute the
difference penalty.  The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="prepare.matrix_+3A_digits">digits</code></td>
<td>
<p>The number of digits to use when applying
<code><a href="base.html#topic+round">round</a></code> to the distances.</p>
</td></tr>
<tr><td><code id="prepare.matrix_+3A_sts">sts</code></td>
<td>
<p>A logical value indicating whether <code>data</code>
is a spatial time series, in which each row of
<code>data</code> corresponds to a distinct spatial location
and each column corresponds to a distinct time.</p>
</td></tr>
<tr><td><code id="prepare.matrix_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a typical sandwich smooth (<code>sts = FALSE</code>),
for two-dimensional data, <code>data[i, j]</code> is assumed
to be observed at position <code>x[[1]][i]</code>,
<code>x[[2]][j]</code>.  If the data are a spatial time series,
then the first dimension is assumed to refer to space,
and the second dimension to time.  In that case,
<code>data[i, j]</code> is assumed
to be observed at location <code>x[[1]][i, ]</code> and time
<code>x[[2]][j]</code>.
</p>
<p>If <code>sts = TRUE</code>, then <code>x[[1]]</code> should be a
matrix of spatial coordinates, with each row
corresponding to a location, and <code>x[[2]]</code> should
be a vector with the observation times.
</p>
<p>If <code>x</code> is not supplied, then
<code><a href="#topic+default.evalargs">default.evalargs</a></code> is used to create it
automatically.  This is only valid when
<code>sts = FALSE</code>.
</p>
<p>If <code>splines</code> is not supplied, then a B-spline basis
is automatically created for each dimension using
<code><a href="#topic+default.splines">default.splines</a></code>.  This is only valid when
<code>sts = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>prepared_matrix</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French.  Based off code by Luo Xiao (see
References).
</p>


<h3>References</h3>

<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspline">bspline</a></code>, <code><a href="#topic+radspline">radspline</a></code>,
<code><a href="#topic+diffpen">diffpen</a></code>, <code><a href="#topic+spdiffpen">spdiffpen</a></code>,
<code><a href="#topic+default.evalargs">default.evalargs</a></code>,
<code><a href="#topic+default.splines">default.splines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare Lu et al. (2012) noisy f1 data
data(ludata)
obj = prepare(lunoisyf1, x = list(x, z))
h = hero(obj)

# precompute some stuff
splines = default.splines(list(x, z))
l = assemble(splines, x = list(x, z))
obj2 = prepare(lunoisyf1, x = list(x, z),
               splines = splines, assembled = l)
h2 = hero(obj2)
all.equal(h, h2)
</code></pre>

<hr>
<h2 id='prepare.numeric'>Prepare data vector for sandwich smooth</h2><span id='topic+prepare.numeric'></span>

<h3>Description</h3>

<p><code>prepare.vector</code> prepares a data vector for the
sandwich smooth.  Unlike the other <code>prepare.*</code>
functions, <code>x</code> and <code>splines</code> do not
need to be lists since the data are 1-dimensional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
prepare(data, x, splines, m = 2, sparse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.numeric_+3A_data">data</code></td>
<td>
<p>A numeric data vector</p>
</td></tr>
<tr><td><code id="prepare.numeric_+3A_x">x</code></td>
<td>
<p>A sequence of equidistant values
corresponding to where the data
are observed.  Equidistant spacing between 0 and 1 is
assumed if not supplied.  See Details.</p>
</td></tr>
<tr><td><code id="prepare.numeric_+3A_splines">splines</code></td>
<td>
<p>A spline-related object, e.g.,
produced by <code><a href="#topic+bspline">bspline</a></code>.  A spline is
automatically created if not supplied.  See Details.</p>
</td></tr>
<tr><td><code id="prepare.numeric_+3A_m">m</code></td>
<td>
<p>A positive integer indicating order of the difference penalty.</p>
</td></tr>
<tr><td><code id="prepare.numeric_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="prepare.numeric_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is not supplied and <code>n</code> is
the <code>length(data)</code>, then the function automatically
sets <code>x = seq(0, 1, length = n)</code>.
</p>
<p>If <code>splines</code> is not supplied, and <code>n</code> is the
<code>length(data)</code>, then the function automatically sets
<code>splines = bspline(range(x), nknots = min(ceiling(n/4), 35))</code>.
</p>


<h3>Value</h3>

<p>A <code>prepared_numeric</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French.  Based off code by Luo Xiao (see
References).
</p>


<h3>References</h3>

<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>
<p>Ruppert, D., Wand, M. P., &amp; Carroll, R. J. (2003).
Semiparametric Regression. Cambridge University Press.
&lt;doi:10.1017/CBO9780511755453&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspline">bspline</a></code>,
<code><a href="#topic+default.evalargs">default.evalargs</a></code>,
<code><a href="#topic+default.splines">default.splines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data
n = 160
x = seq(0, 4 * pi, len = n)
# "true" data
mu = sin(x)
# plot true data
plot(x, mu, type = "l")
# construct noisy data
set.seed(4)
data = mu + rnorm(n)

# construct spline
splines = bspline(c(0, 4 * pi), nknots = 20)
# prepare/enhance data
obj = prepare(data, x, splines)
obj = enhance(obj)
sandmod = hero(obj)
plot(sandmod, ylim = range(data), lty = 2)
lines(x, data, col = "lightgrey")
lines(x, mu)
legend("bottomleft",
       legend = c("smoothed", "true", "observed"),
       lty = c(2, 1, 1),
       col = c("black", "black", "grey"))
</code></pre>

<hr>
<h2 id='prepare.starray'>Prepare <code>starray</code> for sandwich smooth</h2><span id='topic+prepare.starray'></span>

<h3>Description</h3>

<p><code>prepare.starray</code> prepares a spatio-temporal
array for the sandwich smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'starray'
prepare(data, x, y, times, rs, bs, m = 2, sparse = TRUE, spdiffpen = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.starray_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+starray">starray</a></code></p>
</td></tr>
<tr><td><code id="prepare.starray_+3A_x">x</code></td>
<td>
<p>A vector or matrix of x coordinates.  See
Details.</p>
</td></tr>
<tr><td><code id="prepare.starray_+3A_y">y</code></td>
<td>
<p>A vector or matrix of y coordinates.  See
Details.</p>
</td></tr>
<tr><td><code id="prepare.starray_+3A_times">times</code></td>
<td>
<p>The vector of times at which the data were observed.</p>
</td></tr>
<tr><td><code id="prepare.starray_+3A_rs">rs</code></td>
<td>
<p>A <code>hero_radspline</code> produced by the <code><a href="#topic+radspline">radspline</a></code> or
<code><a href="#topic+connect">connect</a></code> functions.</p>
</td></tr>
<tr><td><code id="prepare.starray_+3A_bs">bs</code></td>
<td>
<p>A <code>hero_bspline</code> produced by the <code><a href="#topic+bspline">bspline</a></code> function.</p>
</td></tr>
<tr><td><code id="prepare.starray_+3A_m">m</code></td>
<td>
<p>A positive integer indicating order of the difference penalty.</p>
</td></tr>
<tr><td><code id="prepare.starray_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="prepare.starray_+3A_spdiffpen">spdiffpen</code></td>
<td>
<p>A logical value indicating whether
<code><a href="#topic+spdiffpen">spdiffpen</a></code> should be used to compute the
difference penalty.  The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="prepare.starray_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>prepared_starray</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French.  Based off code by Luo Xiao (see
References).
</p>


<h3>References</h3>

<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspline">bspline</a></code>, <code><a href="#topic+radspline">radspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct basis functions
border = border.grid(lon, lat)
rs = radspline(nknots = 36, poverlap = 3,
               border = border, longlat = TRUE)
bs = bspline(c(1, 30), nbasis = 6)
data = starray(tasmax)
p = prepare(data, x = lon, y = lat, times = 1:30,
            rs = rs, bs = bs)
</code></pre>

<hr>
<h2 id='prepare.sts'>Prepare <code>starray</code> for sandwich smooth</h2><span id='topic+prepare.sts'></span>

<h3>Description</h3>

<p><code>prepare.starray</code> prepares a spatio-temporal
array for the sandwich smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sts'
prepare(
  data,
  coords,
  times,
  rs,
  bs,
  m = 2,
  sparse = TRUE,
  spdiffpen = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.sts_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+starray">starray</a></code></p>
</td></tr>
<tr><td><code id="prepare.sts_+3A_coords">coords</code></td>
<td>
<p>A two-dimensional matrix-like object with
non-NULL dimensions.</p>
</td></tr>
<tr><td><code id="prepare.sts_+3A_times">times</code></td>
<td>
<p>The vector of times at which the data were observed.</p>
</td></tr>
<tr><td><code id="prepare.sts_+3A_rs">rs</code></td>
<td>
<p>A <code>hero_radspline</code> produced by the <code><a href="#topic+radspline">radspline</a></code> or
<code><a href="#topic+connect">connect</a></code> functions.</p>
</td></tr>
<tr><td><code id="prepare.sts_+3A_bs">bs</code></td>
<td>
<p>A <code>hero_bspline</code> produced by the <code><a href="#topic+bspline">bspline</a></code> function.</p>
</td></tr>
<tr><td><code id="prepare.sts_+3A_m">m</code></td>
<td>
<p>A positive integer indicating order of the difference penalty.</p>
</td></tr>
<tr><td><code id="prepare.sts_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="prepare.sts_+3A_spdiffpen">spdiffpen</code></td>
<td>
<p>A logical value indicating whether
<code><a href="#topic+spdiffpen">spdiffpen</a></code> should be used to compute the
difference penalty.  The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="prepare.sts_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>prepared_sts</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French.  Based off code by Luo Xiao (see
References).
</p>


<h3>References</h3>

<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspline">bspline</a></code>, <code><a href="#topic+radspline">radspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct basis functions
border = border.grid(lon, lat)
rs = radspline(nknots = 36, poverlap = 3,
               border = border, longlat = TRUE)
bs = bspline(c(1, 30), nbasis = 6)
splines = list(rs, bs)
data = as.sts(tasmax)
p = prepare(data, coords = cbind(c(lon), c(lat)),
            times = 1:30, rs = rs, bs = bs)
</code></pre>

<hr>
<h2 id='radspline'>Radial basis spline specification</h2><span id='topic+radspline'></span>

<h3>Description</h3>

<p><code>radspline</code> specifies a set of radial basis splines.
<code>nknots</code> is the approximate number of knots to
sample in the (usually) enlarged study area.  If
<code>eborder</code> is not provided, then <code>eborder</code> is
automatically constructed by enlarging the <code>border</code>
object using the <code><a href="#topic+enlarge">enlarge</a></code> function and
<code>width</code>. See Details for additional information
about sampling the knot locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radspline(
  nknots,
  border,
  poverlap = 2,
  k = 2,
  width,
  type = "hexagonal",
  longlat = FALSE,
  eborder,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radspline_+3A_nknots">nknots</code></td>
<td>
<p>The approximate number of knots locations.
Can be a vector of positive integers for successive
samplings. See Details.</p>
</td></tr>
<tr><td><code id="radspline_+3A_border">border</code></td>
<td>
<p>A <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code>
object.  If <code>eborder</code> is not supplied, this will
be used to determine the sampling region for the knots.
See Details.</p>
</td></tr>
<tr><td><code id="radspline_+3A_poverlap">poverlap</code></td>
<td>
<p>The proportional amount of overlap (&gt;=1)
beyond the nearest neighbor knots.  Default is 2.</p>
</td></tr>
<tr><td><code id="radspline_+3A_k">k</code></td>
<td>
<p>The order of the Wendland covariance function.</p>
</td></tr>
<tr><td><code id="radspline_+3A_width">width</code></td>
<td>
<p>The width for the border enlargement.</p>
</td></tr>
<tr><td><code id="radspline_+3A_type">type</code></td>
<td>
<p>The sampling type for
<code><a href="sp.html#topic+spsample">spsample</a></code>.  The default is
<code>"hexagonal"</code>.</p>
</td></tr>
<tr><td><code id="radspline_+3A_longlat">longlat</code></td>
<td>
<p>A logical value indicating whether Great
Circle distances should be used (<code>TRUE</code>) or
Euclidean distances (<code>FALSE</code>).  The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="radspline_+3A_eborder">eborder</code></td>
<td>
<p>A <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></code>
object.  The enlarged border from which the knots will
be selected.  If not supplied, this is automatically
computed using <code>border</code> and <code>width</code>.</p>
</td></tr>
<tr><td><code id="radspline_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="sp.html#topic+spsample">spsample</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="sp.html#topic+spsample">spsample</a></code> function is used to
&quot;automatically&quot; select the knot locations within
<code>eborder</code>.  <code>nknots</code> corresponds to the
<code>n</code> argument in that function.  A hexagonal sampling
scheme is used by default, but other options are
available.
</p>
<p>Great circle distance IS NOT used in sampling from the
regular grid.  This is computationally expensive, so it
has not been implemented.  Great circle distance is only
used  when the constructed <code>hero_radspline</code> is
evaluated (and <code>longlat = TRUE</code>).
</p>


<h3>Value</h3>

<p>A <code>hero_radspline</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>border = border.grid(lon, lat)
r = radspline(nknots = c(36, 36 * 4), border = border)
# default color scheme
plot(r)
# change color and point styles of points,
# and background of original domain
plot(r, blist = list(col = "yellow"),
        glist = list(col = c("blue", "orange"),
                     pch =  3:4))
</code></pre>

<hr>
<h2 id='rh'>Rotated H-transform</h2><span id='topic+rh'></span>

<h3>Description</h3>

<p>A rotation of the H-transform of the array <code>a</code> by a
matrix <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rh(x, a, transpose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rh_+3A_x">x</code></td>
<td>
<p>A matrix-like object.  See Details.</p>
</td></tr>
<tr><td><code id="rh_+3A_a">a</code></td>
<td>
<p>An d-dimensional array</p>
</td></tr>
<tr><td><code id="rh_+3A_transpose">transpose</code></td>
<td>
<p>A logical value.  The Default is
<code>FALSE</code>.  If <code>TRUE</code>, then the transpose of
<code>A</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> should be matrix-like.  This function has been
tested when <code>x</code> is a <code>matrix</code> object or a
<code><a href="Matrix.html#topic+Matrix">Matrix</a></code>.
</p>
<p>Assuming <code>a</code> is of size <code class="reqn">c_1 \times c_2 \times
\dots \times c_d</code>, then <code>x</code> is of size <code class="reqn">r \times
c_1</code>.
</p>


<h3>Value</h3>

<p>A rotated, h-transformed array
</p>


<h3>Author(s)</h3>

<p>Joshua French.  Based off code by Luo Xiao (see
References).
</p>


<h3>References</h3>

<p>Currie, I. D., Durban, M. and Eilers, P. H.
(2006), Generalized linear array models with applications
to multidimensional smoothing. Journal of the Royal
Statistical Society: Series B (Statistical Methodology),
68: 259-280. &lt;doi:10.1111/j.1467-9868.2006.00543.x&gt;
</p>
<p>Xiao, L. , Li, Y. and Ruppert, D. (2013),
Fast bivariate P-splines: the sandwich smoother. J. R.
Stat. Soc. B, 75: 577-599. &lt;doi:10.1111/rssb.12007&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim = c(10:12)
# construct random array
a = array(rnorm(prod(dim)), dim = dim)
# construct random matrix
x = matrix(rnorm(15 * dim[1]), nrow = 15)
rhxa = rh(x, a)
</code></pre>

<hr>
<h2 id='rh.seq'>Apply <code>rh</code> sequentially</h2><span id='topic+rh.seq'></span><span id='topic+rh_seq'></span><span id='topic+rhSeq'></span><span id='topic+RhSeq'></span>

<h3>Description</h3>

<p><code>rh.seq</code> sequentially applies the <code><a href="#topic+rh">rh</a></code>
function to <code>a</code>.  Specifically, if the length of
<code>x</code> is <code>d</code>, then <code>rh.seq(x, a)</code> is
equivalent to <code>rh(x[[d]], rh(x[[d - 1]], ..., rh(x[[2]], rh(x[[1]], a))..))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rh.seq(x, a, transpose = FALSE)

rh_seq(x, a, transpose = FALSE)

rhSeq(x, a, transpose = FALSE)

RhSeq(x, a, transpose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rh.seq_+3A_x">x</code></td>
<td>
<p>A list of matrix-like objects</p>
</td></tr>
<tr><td><code id="rh.seq_+3A_a">a</code></td>
<td>
<p>A matrix-like object (with dimensions)</p>
</td></tr>
<tr><td><code id="rh.seq_+3A_transpose">transpose</code></td>
<td>
<p>A logical value.  The Default is
<code>FALSE</code>.  If <code>TRUE</code>, then the transpose of
<code>A</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> or <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate x, a
x = list(matrix(rnorm(100), nrow = 10),
         matrix(rnorm(100), nrow = 10))
a = matrix(rnorm(100), nrow = 10)

# three equivalent forms
rhs1 = rh.seq(x, a)
rhs2 = rh(x[[2]], rh(x[[1]], a))
rhs3 = x[[1]] %*% a %*% t(x[[2]])

# check equality
all.equal(rhs1, rhs2)
all.equal(rhs1, rhs3)
</code></pre>

<hr>
<h2 id='spdiffpen'>Spatial difference penalty</h2><span id='topic+spdiffpen'></span>

<h3>Description</h3>

<p><code>spdiffpen</code> computes the <code>m</code>th order spatial
difference penalty for a set of coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdiffpen(coords, m = 1, sparse = TRUE, longlat = FALSE, digits = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spdiffpen_+3A_coords">coords</code></td>
<td>
<p>A two-dimensional matrix-like object with
non-NULL dimensions.</p>
</td></tr>
<tr><td><code id="spdiffpen_+3A_m">m</code></td>
<td>
<p>A positive integer indicating order of the difference penalty.</p>
</td></tr>
<tr><td><code id="spdiffpen_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicating if the result
should be a sparse version of the
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code>.</p>
</td></tr>
<tr><td><code id="spdiffpen_+3A_longlat">longlat</code></td>
<td>
<p>A logical value indicating whether Great
Circle distances should be used (<code>TRUE</code>) or
Euclidean distances (<code>FALSE</code>).  The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spdiffpen_+3A_digits">digits</code></td>
<td>
<p>The number of digits to use when applying
<code><a href="base.html#topic+round">round</a></code> to the distances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+adjacent">adjacent</a></code> is used to determine the
first-order neighbors of each point in <code>coords</code>. The
difference penalties are then successively determined
from that.
</p>
<p>If <code>sparse = TRUE</code>, a
<code><a href="Matrix.html#topic+sparseMatrix-class">sparseMatrix-class</a></code> Matrix is
returned when the penalty matrix is relatively sparse
(typically, at least half the entries are zero).
Otherwise, something of the more general
<code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> is returned.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="Matrix.html#topic+sparseMatrix-class">sparseMatrix-class</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords = expand.grid(1:4, 1:4)
# first order difference penalty
d1 = spdiffpen(coords, digits = 1)
# second order difference penalty
d2 = spdiffpen(coords, m = 2, digits = 1)
# third order difference penalty
d3 = spdiffpen(coords, m = 3, digits = 1)
</code></pre>

<hr>
<h2 id='tasmax'>Computer-generated temperature data</h2><span id='topic+tasmax'></span><span id='topic+lon'></span><span id='topic+lat'></span>

<h3>Description</h3>

<p>The maximum daily surface air temperature
(C) for the time period January 1, 1971 through January
30, 1971 for the ECP2-GFDL computer generated data made
available through the North American Regional Climate
Change Assessment Program (NARCCAP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tasmax)
</code></pre>


<h3>Format</h3>

<p>Matrices <code>lon</code> and <code>lat</code> and array
<code>tasmax</code>.
</p>


<h3>References</h3>

<p>Mearns, L.O., et al., 2007, updated 2014. The
North American Regional Climate Change Assessment Program
dataset, National Center for Atmospheric Research Earth
System Grid data portal, Boulder, CO. Data downloaded
2018-06-13. &lt;doi:10.5065/D6RN35ST&gt;.
</p>
<p>Mearns, L. O., W. J. Gutowski, R. Jones, L.-Y. Leung, S.
McGinnis, A. M. B. Nunes, and Y. Qian. &quot;A regional
climate change assessment program for North America.&quot;
EOS, Vol. 90, No. 36, 8 September 2009, pp. 311-312.
&lt;doi:10.1029/2009EO360002&gt;.
</p>

<hr>
<h2 id='wrfg_cgcm3_tasmax'>Computer-generated temperature data</h2><span id='topic+wrfg_cgcm3_tasmax'></span><span id='topic+wrfg_lon'></span><span id='topic+wrfg_lat'></span>

<h3>Description</h3>

<p>The maximum daily surface air temperature
(C) of land locations for the time period
January 1, 2041 through January
30, 1941 for the WRFG-CGCM3 computer generated data made
available through the North American Regional Climate
Change Assessment Program (NARCCAP).  The non-land
locations are specified as NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wrfg_cgcm3_tasmax)
</code></pre>


<h3>Format</h3>

<p>Matrices <code>wrfg_lon</code> and <code>wrfg_lat</code> and array
<code>wrfg_cgcm3_tasmax</code>.
</p>


<h3>References</h3>

<p>Mearns, L.O., et al., 2007, updated 2014. The
North American Regional Climate Change Assessment Program
dataset, National Center for Atmospheric Research Earth
System Grid data portal, Boulder, CO. Data downloaded
2018-06-13. &lt;doi:10.5065/D6RN35ST&gt;.
</p>
<p>Mearns, L. O., W. J. Gutowski, R. Jones, L.-Y. Leung, S.
McGinnis, A. M. B. Nunes, and Y. Qian. &quot;A regional
climate change assessment program for North America.&quot;
EOS, Vol. 90, No. 36, 8 September 2009, pp. 311-312.
&lt;doi:10.1029/2009EO360002&gt;.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
