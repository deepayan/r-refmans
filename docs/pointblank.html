<!DOCTYPE html><html lang="en"><head><title>Help for package pointblank</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pointblank}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#action_levels'><p>Set action levels: failure thresholds and functions to invoke</p></a></li>
<li><a href='#activate_steps'><p>Activate one or more of an <em>agent</em>'s validation steps</p></a></li>
<li><a href='#affix_date'><p>Put the current date into a file name</p></a></li>
<li><a href='#affix_datetime'><p>Put the current datetime into a file name</p></a></li>
<li><a href='#all_passed'><p>Did all of the validations fully <em>pass</em>?</p></a></li>
<li><a href='#col_count_match'><p>Does the column count match that of a different table?</p></a></li>
<li><a href='#col_exists'><p>Do one or more columns actually exist?</p></a></li>
<li><a href='#col_is_character'><p>Do the columns contain character/string data?</p></a></li>
<li><a href='#col_is_date'><p>Do the columns contain R <code>Date</code> objects?</p></a></li>
<li><a href='#col_is_factor'><p>Do the columns contain R <code>factor</code> objects?</p></a></li>
<li><a href='#col_is_integer'><p>Do the columns contain integer values?</p></a></li>
<li><a href='#col_is_logical'><p>Do the columns contain logical values?</p></a></li>
<li><a href='#col_is_numeric'><p>Do the columns contain numeric values?</p></a></li>
<li><a href='#col_is_posix'><p>Do the columns contain <code>POSIXct</code> dates?</p></a></li>
<li><a href='#col_schema'><p>Generate a table column schema manually or with a reference table</p></a></li>
<li><a href='#col_schema_match'><p>Do columns in the table (and their types) match a predefined schema?</p></a></li>
<li><a href='#col_vals_between'><p>Do column data lie between two specified values or data in other columns?</p></a></li>
<li><a href='#col_vals_decreasing'><p>Are column data decreasing by row?</p></a></li>
<li><a href='#col_vals_equal'><p>Are column data equal to a fixed value or data in another column?</p></a></li>
<li><a href='#col_vals_expr'><p>Do column data agree with a predicate expression?</p></a></li>
<li><a href='#col_vals_gt'><p>Are column data greater than a fixed value or data in another column?</p></a></li>
<li><a href='#col_vals_gte'><p>Are column data greater than or equal to a fixed value or data in another</p>
column?</a></li>
<li><a href='#col_vals_in_set'><p>Are column data part of a specified set of values?</p></a></li>
<li><a href='#col_vals_increasing'><p>Are column data increasing by row?</p></a></li>
<li><a href='#col_vals_lt'><p>Are column data less than a fixed value or data in another column?</p></a></li>
<li><a href='#col_vals_lte'><p>Are column data less than or equal to a fixed value or data in another</p>
column?</a></li>
<li><a href='#col_vals_make_set'><p>Is a set of values entirely accounted for in a column of values?</p></a></li>
<li><a href='#col_vals_make_subset'><p>Is a set of values a subset of a column of values?</p></a></li>
<li><a href='#col_vals_not_between'><p>Do column data lie outside of two specified values or data in other columns?</p></a></li>
<li><a href='#col_vals_not_equal'><p>Are column data not equal to a fixed value or data in another column?</p></a></li>
<li><a href='#col_vals_not_in_set'><p>Are data not part of a specified set of values?</p></a></li>
<li><a href='#col_vals_not_null'><p>Are column data not <code>NULL</code>/<code>NA</code>?</p></a></li>
<li><a href='#col_vals_null'><p>Are column data <code>NULL</code>/<code>NA</code>?</p></a></li>
<li><a href='#col_vals_regex'><p>Do strings in column data match a regex pattern?</p></a></li>
<li><a href='#col_vals_within_spec'><p>Do values in column data fit within a specification?</p></a></li>
<li><a href='#conjointly'><p>Perform multiple rowwise validations for joint validity</p></a></li>
<li><a href='#create_agent'><p>Create a <strong>pointblank</strong> <em>agent</em> object</p></a></li>
<li><a href='#create_informant'><p>Create a <strong>pointblank</strong> <em>informant</em> object</p></a></li>
<li><a href='#create_multiagent'><p>Create a <strong>pointblank</strong> <em>multiagent</em> object</p></a></li>
<li><a href='#db_tbl'><p>Get a table from a database</p></a></li>
<li><a href='#deactivate_steps'><p>Deactivate one or more of an <em>agent</em>'s validation steps</p></a></li>
<li><a href='#draft_validation'><p>Draft a starter <strong>pointblank</strong> validation .R/.Rmd file with a data table</p></a></li>
<li><a href='#email_blast'><p>Conditionally send email during interrogation</p></a></li>
<li><a href='#email_create'><p>Create an email object from a <strong>pointblank</strong> <em>agent</em></p></a></li>
<li><a href='#export_report'><p>Export an <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or table scan to HTML</p></a></li>
<li><a href='#file_tbl'><p>Get a table from a local or remote file</p></a></li>
<li><a href='#from_github'><p>Specify a file for download from GitHub</p></a></li>
<li><a href='#game_revenue'><p>A table with game revenue data</p></a></li>
<li><a href='#game_revenue_info'><p>A table with metadata for the <code>game_revenue</code> dataset</p></a></li>
<li><a href='#get_agent_report'><p>Get a summary report from an agent</p></a></li>
<li><a href='#get_agent_x_list'><p>Get the agent's <strong>x-list</strong></p></a></li>
<li><a href='#get_data_extracts'><p>Collect data extracts from a validation step</p></a></li>
<li><a href='#get_informant_report'><p>Get a table information report from an <em>informant</em> object</p></a></li>
<li><a href='#get_multiagent_report'><p>Get a summary report using multiple agents</p></a></li>
<li><a href='#get_sundered_data'><p>Sunder the data, splitting it into 'pass' and 'fail' pieces</p></a></li>
<li><a href='#get_tt_param'><p>Get a parameter value from a summary table</p></a></li>
<li><a href='#has_columns'><p>Determine if one or more columns exist in a table</p></a></li>
<li><a href='#incorporate'><p>Given an <em>informant</em> object, update and incorporate table snippets</p></a></li>
<li><a href='#info_columns'><p>Add information that focuses on aspects of a data table's columns</p></a></li>
<li><a href='#info_columns_from_tbl'><p>Add column information from another data table</p></a></li>
<li><a href='#info_section'><p>Add information that focuses on some key aspect of the data table</p></a></li>
<li><a href='#info_snippet'><p>Generate a useful text 'snippet' from the target table</p></a></li>
<li><a href='#info_tabular'><p>Add information that focuses on aspects of the data table as a whole</p></a></li>
<li><a href='#interrogate'><p>Given an agent that has a validation plan, perform an interrogation</p></a></li>
<li><a href='#log4r_step'><p>Enable logging of failure conditions at the validation step level</p></a></li>
<li><a href='#print.action_levels'><p>Print the <code>action_levels</code> object</p></a></li>
<li><a href='#print.ptblank_agent'><p>Print the <code>ptblank_agent</code> object</p></a></li>
<li><a href='#print.ptblank_informant'><p>Print the <code>ptblank_informant</code> object</p></a></li>
<li><a href='#print.ptblank_multiagent'><p>Print the <code>ptblank_multiagent</code> object</p></a></li>
<li><a href='#print.ptblank_multiagent_report.long'><p>Print the <code>ptblank_multiagent_report.long</code> object</p></a></li>
<li><a href='#print.ptblank_tbl_scan'><p>Print the <code>ptblank_tbl_scan</code> object</p></a></li>
<li><a href='#print.read_fn'><p>Print the a table-prep formula</p></a></li>
<li><a href='#print.tbl_store'><p>Print the <code>tbl_store</code> object</p></a></li>
<li><a href='#print.x_list_i'><p>Print a single-step x-list to the console</p></a></li>
<li><a href='#print.x_list_n'><p>Print an x-list comprising all validation steps to the console</p></a></li>
<li><a href='#read_disk_multiagent'><p>Read <strong>pointblank</strong> <em>agents</em> stored on disk as a <em>multiagent</em></p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remove_steps'><p>Remove one or more of an <em>agent</em>'s validation steps</p></a></li>
<li><a href='#row_count_match'><p>Does the row count match that of a different table?</p></a></li>
<li><a href='#rows_complete'><p>Are row data complete?</p></a></li>
<li><a href='#rows_distinct'><p>Are row data distinct?</p></a></li>
<li><a href='#scan_data'><p>Thoroughly scan a table to better understand it</p></a></li>
<li><a href='#serially'><p>Run several tests and a final validation in a serial manner</p></a></li>
<li><a href='#set_tbl'><p>Set a data table to an <em>agent</em> or an <em>informant</em></p></a></li>
<li><a href='#small_table'><p>A small table that is useful for testing</p></a></li>
<li><a href='#small_table_sqlite'><p>An SQLite version of the <code>small_table</code> dataset</p></a></li>
<li><a href='#snip_highest'><p>A <code>fn</code> for <code>info_snippet()</code>: get the highest value from a column</p></a></li>
<li><a href='#snip_list'><p>A <code>fn</code> for <code>info_snippet()</code>: get a list of column categories</p></a></li>
<li><a href='#snip_lowest'><p>A <code>fn</code> for <code>info_snippet()</code>: get the lowest value from a column</p></a></li>
<li><a href='#snip_stats'><p>A <code>fn</code> for <code>info_snippet()</code>: get an inline statistical summary</p></a></li>
<li><a href='#specially'><p>Perform a specialized validation with a user-defined function</p></a></li>
<li><a href='#specifications'><p>A table containing data pertaining to various specifications</p></a></li>
<li><a href='#stock_msg_body'><p>Provide simple email message body components: body</p></a></li>
<li><a href='#stock_msg_footer'><p>Provide simple email message body components: footer</p></a></li>
<li><a href='#stop_if_not'><p>A specialized version of <code>stopifnot()</code> for <strong>pointblank</strong>: <code>stop_if_not()</code></p></a></li>
<li><a href='#tbl_get'><p>Obtain a materialized table via a table store</p></a></li>
<li><a href='#tbl_match'><p>Does the target table match a comparison table?</p></a></li>
<li><a href='#tbl_source'><p>Obtain a table-prep formula from a table store</p></a></li>
<li><a href='#tbl_store'><p>Define a store of tables with table-prep formulas: a table store</p></a></li>
<li><a href='#tt_string_info'><p>Table Transformer: obtain a summary table for string columns</p></a></li>
<li><a href='#tt_summary_stats'><p>Table Transformer: obtain a summary stats table for numeric columns</p></a></li>
<li><a href='#tt_tbl_colnames'><p>Table Transformer: get a table's column names</p></a></li>
<li><a href='#tt_tbl_dims'><p>Table Transformer: get the dimensions of a table</p></a></li>
<li><a href='#tt_time_shift'><p>Table Transformer: shift the times of a table</p></a></li>
<li><a href='#tt_time_slice'><p>Table Transformer: slice a table with a slice point on a time column</p></a></li>
<li><a href='#validate_rmd'><p>Perform <strong>pointblank</strong> validation testing within R Markdown documents</p></a></li>
<li><a href='#write_testthat_file'><p>Transform a <strong>pointblank</strong> agent to a <strong>testthat</strong> test file</p></a></li>
<li><a href='#x_read_disk'><p>Read an <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or table scan from disk</p></a></li>
<li><a href='#x_write_disk'><p>Write an <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or table scan to disk</p></a></li>
<li><a href='#yaml_agent_interrogate'><p>Get an <em>agent</em> from <strong>pointblank</strong> YAML and <code>interrogate()</code></p></a></li>
<li><a href='#yaml_agent_show_exprs'><p>Display validation expressions using <strong>pointblank</strong> YAML</p></a></li>
<li><a href='#yaml_agent_string'><p>Display <strong>pointblank</strong> YAML using an agent or a YAML file</p></a></li>
<li><a href='#yaml_exec'><p>Execute all agent and informant YAML tasks</p></a></li>
<li><a href='#yaml_informant_incorporate'><p>Get an <em>informant</em> from <strong>pointblank</strong> YAML and <code>incorporate()</code></p></a></li>
<li><a href='#yaml_read_agent'><p>Read a <strong>pointblank</strong> YAML file to create an <em>agent</em> object</p></a></li>
<li><a href='#yaml_read_informant'><p>Read a <strong>pointblank</strong> YAML file to create an <em>informant</em> object</p></a></li>
<li><a href='#yaml_write'><p>Write <strong>pointblank</strong> objects to YAML files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.12.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Validation and Organization of Metadata for Local and
Remote Tables</td>
</tr>
<tr>
<td>Description:</td>
<td>Validate data in data frames, 'tibble' objects, 'Spark'
    'DataFrames', and database tables. Validation pipelines can be made using
    easily-readable, consecutive validation steps. Upon execution of the
    validation plan, several reporting options are available. User-defined
    thresholds for failure rates allow for the determination of appropriate
    reporting actions. Many other workflows are available including an
    information management workflow, where the aim is to record, collect, and
    generate useful information on data tables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rstudio.github.io/pointblank/">https://rstudio.github.io/pointblank/</a>,
<a href="https://github.com/rstudio/pointblank">https://github.com/rstudio/pointblank</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/pointblank/issues">https://github.com/rstudio/pointblank/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>base64enc (&ge; 0.1-3), blastula (&ge; 0.3.3), cli (&ge; 3.6.0), DBI
(&ge; 1.1.0), digest (&ge; 0.6.27), dplyr (&ge; 1.0.10), dbplyr (&ge;
2.3.0), fs (&ge; 1.6.0), glue (&ge; 1.6.2), gt (&ge; 0.9.0),
htmltools (&ge; 0.5.4), knitr (&ge; 1.42), rlang (&ge; 1.0.3),
magrittr, scales (&ge; 1.2.1), testthat (&ge; 3.1.6), tibble (&ge;
3.1.8), tidyr (&ge; 1.3.0), tidyselect (&ge; 1.2.0), yaml (&ge;
2.3.7)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>arrow, bigrquery, data.table, duckdb, ggforce, ggplot2,
jsonlite, log4r, lubridate, RSQLite, RMySQL, RPostgres, readr,
rmarkdown, sparklyr, dittodb, odbc</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-23 00:32:58 UTC; riannone</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Iannone <a href="https://orcid.org/0000-0003-3925-190X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mauricio Vargas <a href="https://orcid.org/0000-0003-1017-7574"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  June Choe <a href="https://orcid.org/0000-0002-0701-921X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard Iannone &lt;rich@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-23 03:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code style="white-space: pre;">&#8288;magrittr::[\%&gt;\%][magrittr::\%&gt;\%]&#8288;</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='action_levels'>Set action levels: failure thresholds and functions to invoke</h2><span id='topic+action_levels'></span><span id='topic+warn_on_fail'></span><span id='topic+stop_on_fail'></span>

<h3>Description</h3>

<p>The <code>action_levels()</code> function works with the <code>actions</code> argument that is
present in the <code><a href="#topic+create_agent">create_agent()</a></code> function and in every validation step
function (which also has an <code>actions</code> argument). With it, we can provide
threshold <em>failure</em> values for any combination of <code>warn</code>, <code>stop</code>, or <code>notify</code>
failure states.
</p>
<p>We can react to any entering of a state by supplying corresponding functions
to the <code>fns</code> argument. They will undergo evaluation at the time when the
matching state is entered. If provided to <code><a href="#topic+create_agent">create_agent()</a></code> then the policies
will be applied to every validation step, acting as a default for the
validation as a whole.
</p>
<p>Calls of <code>action_levels()</code> could also be applied directly to any validation
step and this will act as an override if set also in <code><a href="#topic+create_agent">create_agent()</a></code>. Usage
of <code>action_levels()</code> is required to have any useful side effects (i.e.,
warnings, throwing errors) in the case of validation functions operating
directly on data (e.g., <code>mtcars %&gt;% col_vals_lt("mpg", 35)</code>). There are two
helper functions that are convenient when using validation functions directly
on data (the <code>agent</code>-less workflow): <code>warn_on_fail()</code> and <code>stop_on_fail()</code>.
These helpers either warn or stop (default failure threshold for each is set
to <code>1</code>), and, they do so with informative warning or error messages. The
<code>stop_on_fail()</code> helper is applied by default when using validation functions
directly on data (more information on this is provided in <em>Details</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>action_levels(warn_at = NULL, stop_at = NULL, notify_at = NULL, fns = NULL)

warn_on_fail(warn_at = 1)

stop_on_fail(stop_at = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="action_levels_+3A_warn_at">warn_at</code></td>
<td>
<p><em>Threshold value for the 'warn' failure state</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Either the threshold number or the threshold fraction of <em>failing</em> test
units that result in entering the <code>warn</code> failure state.</p>
</td></tr>
<tr><td><code id="action_levels_+3A_stop_at">stop_at</code></td>
<td>
<p><em>Threshold value for the 'stop' failure state</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Either the threshold number or the threshold fraction of <em>failing</em> test
units that result in entering the <code>stop</code> failure state.</p>
</td></tr>
<tr><td><code id="action_levels_+3A_notify_at">notify_at</code></td>
<td>
<p><em>Threshold value for the 'notify' failure state</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Either the threshold number or the threshold fraction of <em>failing</em> test
units that result in entering the <code>notify</code> failure state.</p>
</td></tr>
<tr><td><code id="action_levels_+3A_fns">fns</code></td>
<td>
<p><em>Functions to execute when entering failure states</em>
</p>
<p><code>list</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A named list of functions that is to be paired with the appropriate failure
states. The syntax for this list involves using failure state names from
the set of <code>warn</code>, <code>stop</code>, and <code>notify</code>. The functions corresponding to the
failure states are provided as formulas (e.g.,
<code>list(warn = ~ warning("Too many failures."))</code>. A series of expressions for
each named state can be used by enclosing the set of statements with <code>{ }</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of the <code>action_levels()</code> call in <code>actions</code> will be interpreted
slightly differently if using an <em>agent</em> or using validation functions
directly on a data table. For convenience, when working directly on data, any
values supplied to <code>warn_at</code> or <code>stop_at</code> will be automatically given a stock
<code>warning()</code> or <code>stop()</code> function. For example using
<code>small_table %&gt;% col_is_integer("date")</code> will provide a detailed stop message
by default, indicating the reason for the failure. If you were to supply the
<code>fns</code> for <code>stop</code> or <code>warn</code> manually then the stock functions would be
overridden. Furthermore, if <code>actions</code> is NULL in this workflow (the default),
<strong>pointblank</strong> will use a <code>stop_at</code> value of <code>1</code> (providing a detailed,
context-specific error message if there are any <em>failing</em> units). We can
absolutely suppress this automatic stopping behavior at each validation
step by setting <code>active = FALSE</code>. In this interactive data case, there is no
stock function given for <code>notify_at</code>. The <code>notify</code> failure state is less
commonly used in this workflow as it is in the <em>agent</em>-based one.
</p>
<p>When using an <em>agent</em>, we often opt to not use any functions in <code>fns</code> as the
<code>warn</code>, <code>stop</code>, and <code>notify</code> failure states will be reported on when using
<code>create_agent_report()</code> (and, usually that's sufficient). Instead, using the
<code>end_fns</code> argument is a better choice since that scheme provides useful data
on the entire interrogation, allowing for finer control on side effects and
reducing potential for duplicating any side effects.
</p>


<h3>Value</h3>

<p>An <code>action_levels</code> object.
</p>


<h3>Defining threshold values</h3>

<p>Any threshold values supplied for the <code>warn_at</code>, <code>stop_at</code>, or <code>notify_at</code>
arguments correspond to the <code>warn</code>, <code>stop</code>, and <code>notify</code> failure states,
respectively. A threshold value can either relates to an absolute number of
test units or a fraction-of-total test units that are <em>failing</em>. Exceeding
the threshold means entering one or more of the <code>warn</code>, <code>stop</code>, or <code>notify</code>
failure states.
</p>
<p>If a threshold value is a decimal value between <code>0</code> and <code>1</code> then it's a
proportional failure threshold (e.g., <code>0.15</code> indicates that if 15 percent of
the test units are found to be <em>failing</em>, then the designated failure state
is entered). Absolute values starting from <code>1</code> can be used instead, and this
constitutes an absolute failure threshold (e.g., <code>10</code> means that if 10 of the
test units are found to be <em>failing</em>, the failure state is entered).
</p>


<h3>Examples</h3>

<p>For these examples, we will use the included <code>small_table</code> dataset.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>Create an <code>action_levels</code> object with fractional values for the <code>warn</code>,
<code>stop</code>, and <code>notify</code> states.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 0.2,
    stop_at = 0.8,
    notify_at = 0.5
  )
</pre></div>
<p>A summary of settings for the <code>al</code> object is shown by printing it.
</p>
<p>Create a pointblank agent and apply the <code>al</code> object to <code>actions</code>. Add two
validation steps and interrogate the <code>small_table</code>.
</p>
<div class="sourceCode r"><pre>agent_1 &lt;-
  create_agent(
    tbl = small_table,
    actions = al
  ) %&gt;%
  col_vals_gt(
    columns = a, value = 2
  ) %&gt;%
  col_vals_lt(
    columns = d, value = 20000
  ) %&gt;%
  interrogate()
</pre></div>
<p>The report from the agent will show that the <code>warn</code> state has been entered
for the first validation step but not the second one. We can confirm this in
the console by inspecting the <code>warn</code> component in the agent's x-list.
</p>
<div class="sourceCode r"><pre>x_list &lt;- get_agent_x_list(agent = agent_1)

x_list$warn
</pre></div>
<div class="sourceCode"><pre>## [1]  TRUE FALSE
</pre></div>
<p>Applying the <code>action_levels</code> object to the agent means that all validation
steps will inherit these settings but we can override this by applying
another such object to the validation step instead (this time using the
<code>warn_on_fail()</code> shorthand).
</p>
<div class="sourceCode r"><pre>agent_2 &lt;-
  create_agent(
    tbl = small_table,
    actions = al
  ) %&gt;%
  col_vals_gt(
    columns = a, value = 2,
    actions = warn_on_fail(warn_at = 0.5)
  ) %&gt;%
  col_vals_lt(
    columns = d, value = 20000
  ) %&gt;%
  interrogate()
</pre></div>
<p>In this case, the first validation step has a less stringent failure
threshold for the <code>warn</code> state and it's high enough that the condition is not
entered. This can be confirmed in the console through inspection of the
x-list <code>warn</code> component.
</p>
<div class="sourceCode r"><pre>x_list &lt;- get_agent_x_list(agent = agent_2)

x_list$warn
</pre></div>
<div class="sourceCode"><pre>## [1] FALSE FALSE
</pre></div>
<p>In the context of using validation functions directly on data (i.e., no
involvement of an agent) we want to trigger warnings and raise errors. The
following will yield a warning if it is executed (returning the <code>small_table</code>
data).
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_gt(
    columns = a, value = 2,
    actions = warn_on_fail(warn_at = 2)
  )
</pre></div>
<pre>## # A tibble: 13 × 8
##    date_time           date           a b           c      d e    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-…     3  3423. TRUE 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-…     8 10000. TRUE 
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-…     3  2343. TRUE 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-…    NA  3892. FALSE
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-…     7   284. TRUE 
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-…     4  3291. TRUE 
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-…     3   843. TRUE 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-…     2  1036. FALSE
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE
## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-…     7   834. TRUE 
## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-…     8   108. FALSE
## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-…    NA  2230. TRUE 
## # … with 1 more variable: f &lt;chr&gt;
## Warning message:
## Exceedance of failed test units where values in `a` should have been &gt;
## `2`.
## The `col_vals_gt()` validation failed beyond the absolute threshold
## level (2).
## * failure level (4) &gt;= failure threshold (2)</pre>
<p>With the same pipeline, not supplying anything for <code>actions</code> (it's <code>NULL</code> by
default) will have the same effect as using <code>stop_on_fail(stop_at = 1)</code>.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_gt(columns = a, value = 2)
</pre></div>
<div class="sourceCode"><pre>## Error: Exceedance of failed test units where values in `a` should have
## been &gt; `2`.
## The `col_vals_gt()` validation failed beyond the absolute threshold
## level (1).
## * failure level (4) &gt;= failure threshold (1)
</pre></div>
<p>Here's the equivalent set of statements:
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_gt(
    columns = a, value = 2,
    actions = stop_on_fail(stop_at = 1)
  )
</pre></div>
<div class="sourceCode"><pre>## Error: Exceedance of failed test units where values in `a` should have
## been &gt; `2`.
## The `col_vals_gt()` validation failed beyond the absolute threshold
## level (1).
## * failure level (4) &gt;= failure threshold (1)
</pre></div>
<p>This is because the <code>stop_on_fail()</code> call is auto-injected in the default
case (when operating on data) for your convenience. Behind the scenes a
'secret agent' uses 'covert actions': all so you can type less.
</p>


<h3>Function ID</h3>

<p>1-5
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='activate_steps'>Activate one or more of an <em>agent</em>'s validation steps</h2><span id='topic+activate_steps'></span>

<h3>Description</h3>

<p>If certain validation steps need to be activated after the creation of the
validation plan for an <em>agent</em>, use the <code>activate_steps()</code> function. This is
equivalent to using the <code>active = TRUE</code> for the selected validation steps
(<code>active</code> is an argument in all validation functions). This will replace any
function that may have been defined for the <code>active</code> argument during creation
of the targeted validation steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate_steps(agent, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activate_steps_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function.</p>
</td></tr>
<tr><td><code id="activate_steps_+3A_i">i</code></td>
<td>
<p><em>A validation step number</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The validation step number, which is assigned to each validation step in
the order of definition. If <code>NULL</code> (the default) then step activation won't
occur by index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_agent</code> object.
</p>


<h3>Function ID</h3>

<p>9-5
</p>


<h3>See Also</h3>

<p>For the opposite behavior, use the <code><a href="#topic+deactivate_steps">deactivate_steps()</a></code> function.
</p>
<p>Other Object Ops: 
<code><a href="#topic+deactivate_steps">deactivate_steps</a>()</code>,
<code><a href="#topic+export_report">export_report</a>()</code>,
<code><a href="#topic+remove_steps">remove_steps</a>()</code>,
<code><a href="#topic+set_tbl">set_tbl</a>()</code>,
<code><a href="#topic+x_read_disk">x_read_disk</a>()</code>,
<code><a href="#topic+x_write_disk">x_write_disk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an agent that has the
# `small_table` object as the
# target table, add a few inactive
# validation steps, and then use
# `interrogate()`
agent_1 &lt;- 
  create_agent(
    tbl = small_table,
    tbl_name = "small_table",
    label = "An example."
  ) %&gt;%
  col_exists(
    columns = date,
    active = FALSE
  ) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}",
    active = FALSE
  ) %&gt;%
  interrogate()

# In the above, the data is
# not actually interrogated
# because the `active` setting
# was `FALSE` in all steps; we
# can selectively change this
# with `activate_steps()`
agent_2 &lt;-
  agent_1 %&gt;%
  activate_steps(i = 1) %&gt;%
  interrogate()

</code></pre>

<hr>
<h2 id='affix_date'>Put the current date into a file name</h2><span id='topic+affix_date'></span>

<h3>Description</h3>

<p>This function helps to affix the current date to a filename. This is useful
when writing <em>agent</em> and/or <em>informant</em> objects to disk as part of a
continuous process. The date can be in terms of UTC time or the local system
time. The date can be affixed either to the end of the filename (before the
file extension) or at the beginning with a customizable delimiter.
</p>
<p>The <code><a href="#topic+x_write_disk">x_write_disk()</a></code>, <code><a href="#topic+yaml_write">yaml_write()</a></code> functions allow for the writing of
<strong>pointblank</strong> objects to disk. Furthermore the <code><a href="#topic+log4r_step">log4r_step()</a></code> function has
the <code>append_to</code> argument that accepts filenames, and, it's reasonable that a
series of log files could be differentiated by a date component in the naming
scheme. The modification of the filename string takes effect immediately but
not at the time of writing a file to disk. In most cases, especially when
using <code>affix_date()</code> with the aforementioned file-writing functions, the file
timestamps should approximate the time components affixed to the filenames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affix_date(
  filename,
  position = c("end", "start"),
  format = "%Y-%m-%d",
  delimiter = "_",
  utc_time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="affix_date_+3A_filename">filename</code></td>
<td>
<p>The filename to modify.</p>
</td></tr>
<tr><td><code id="affix_date_+3A_position">position</code></td>
<td>
<p>Where to place the formatted date. This could either be at
the <code>"end"</code> of the filename (the default) or at the <code>"start"</code>.</p>
</td></tr>
<tr><td><code id="affix_date_+3A_format">format</code></td>
<td>
<p>A <code><a href="base.html#topic+strptime">base::strptime()</a></code> format string for formatting the date. By
default, this is <code>"%Y-%m-%d"</code> which expresses the date according to the ISO
8601 standard (as <code>YYYY-MM-DD</code>). Refer to the documentation on
<code><a href="base.html#topic+strptime">base::strptime()</a></code> for conversion specifications if planning to use a
different format string.</p>
</td></tr>
<tr><td><code id="affix_date_+3A_delimiter">delimiter</code></td>
<td>
<p>The delimiter characters to use for separating the date
string from the original file name.</p>
</td></tr>
<tr><td><code id="affix_date_+3A_utc_time">utc_time</code></td>
<td>
<p>An option for whether to use the current UTC time to
establish the date (the default, with <code>TRUE</code>), or, use the system's local
time (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>



<h4>The basics of creating a filename with the current date</h4>

<p>Taking the generic <code>"pb_file"</code> name for a file, we add the current date to it
as a suffix.
</p>
<div class="sourceCode r"><pre>affix_date(filename = "pb_file")
</pre></div>
<div class="sourceCode"><pre>## [1] "pb_file_2022-04-01"
</pre></div>
<p>File extensions won't get in the way:
</p>
<div class="sourceCode r"><pre>affix_date(filename = "pb_file.rds")
</pre></div>
<div class="sourceCode"><pre>## [1] "pb_file_2022-04-01.rds"
</pre></div>
<p>The date can be used as a prefix.
</p>
<div class="sourceCode r"><pre>affix_date(
  filename = "pb_file",
  position = "start"
)
</pre></div>
<div class="sourceCode"><pre>## [1] "2022-04-01_pb_file"
</pre></div>
<p>The date pattern can be changed and so can the delimiter.
</p>
<div class="sourceCode r"><pre>affix_date(
  filename = "pb_file.yml",
  format = "%Y%m%d",
  delimiter = "-"
)
</pre></div>
<div class="sourceCode"><pre>## [1] "pb_file-20220401.yml"
</pre></div>



<h4>Using a date-based filename in a <strong>pointblank</strong> workflow</h4>

<p>We can use a file-naming convention involving dates when writing output files
immediately after interrogating. This is just one example (any workflow
involving a <code>filename</code> argument is applicable). It's really advantageous to
use date-based filenames when interrogating directly from YAML in a scheduled
process.
</p>
<div class="sourceCode r"><pre>yaml_agent_interrogate(
  filename = system.file(
    "yaml", "agent-small_table.yml",
    package = "pointblank"
  )
) %&gt;% 
  x_write_disk(
    filename = affix_date(
      filename = "small_table_agent.rds",
      delimiter = "-"
    ),
    keep_tbl = TRUE,
    keep_extracts = TRUE
  )
</pre></div>
<p>In the above, we used the written-to-disk agent (The
<code>"agent-small_table.yml"</code> YAML file) for an interrogation via
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>. Then, the results were written to disk as an RDS
file. In the <code>filename</code> argument of <code><a href="#topic+x_write_disk">x_write_disk()</a></code>, the <code><a href="#topic+affix_date">affix_date()</a></code>
function was used to ensure that a daily run would produce a file whose name
indicates the day of execution.
</p>



<h3>Function ID</h3>

<p>13-3
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+affix_datetime">affix_datetime()</a></code> function provides the same features except it
produces a datetime string by default.
</p>
<p>Other Utility and Helper Functions: 
<code><a href="#topic+affix_datetime">affix_datetime</a>()</code>,
<code><a href="#topic+col_schema">col_schema</a>()</code>,
<code><a href="#topic+from_github">from_github</a>()</code>,
<code><a href="#topic+has_columns">has_columns</a>()</code>,
<code><a href="#topic+stop_if_not">stop_if_not</a>()</code>
</p>

<hr>
<h2 id='affix_datetime'>Put the current datetime into a file name</h2><span id='topic+affix_datetime'></span>

<h3>Description</h3>

<p>This function helps to affix the current datetime to a filename. This is
useful when writing <em>agent</em> and/or <em>informant</em> objects to disk as part of a
continuous process. The datetime string can be based on the current UTC time
or the local system time. The datetime can be affixed either to the end of
the filename (before the file extension) or at the beginning with a
customizable delimiter. Optionally, the time zone information can be
included. If the datetime is based on the local system time, the user system
time zone is shown with the format <code style="white-space: pre;">&#8288;&lt;time&gt;(+/-)hhmm&#8288;</code>. If using UTC time, then
the <code style="white-space: pre;">&#8288;&lt;time&gt;Z&#8288;</code> format is adopted.
</p>
<p>The <code><a href="#topic+x_write_disk">x_write_disk()</a></code>, <code><a href="#topic+yaml_write">yaml_write()</a></code> functions allow for the writing of
<strong>pointblank</strong> objects to disk. The modification of the filename string takes
effect immediately but not at the time of writing a file to disk. In most
cases, especially when using <code>affix_datetime()</code> with the aforementioned
file-writing functions, the file timestamps should approximate the time
components affixed to the filenames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affix_datetime(
  filename,
  position = c("end", "start"),
  format = "%Y-%m-%d_%H-%M-%S",
  delimiter = "_",
  utc_time = TRUE,
  add_tz = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="affix_datetime_+3A_filename">filename</code></td>
<td>
<p>The filename to modify.</p>
</td></tr>
<tr><td><code id="affix_datetime_+3A_position">position</code></td>
<td>
<p>Where to place the formatted datetime. This could either be
at the <code>"end"</code> of the filename (the default) or at the <code>"start"</code>.</p>
</td></tr>
<tr><td><code id="affix_datetime_+3A_format">format</code></td>
<td>
<p>A <code><a href="base.html#topic+strptime">base::strptime()</a></code> format string for formatting the
datetime. By default, this is <code>"%Y-%m-%dT%H:%M:%S"</code> which expresses the
date according to the ISO 8601 standard. For example, if the current
datetime is <code style="white-space: pre;">&#8288;2020-12-04 13:11:23&#8288;</code>, the formatted string would become
<code>"2020-12-04T13:11:23"</code>. Refer to the documentation on <code><a href="base.html#topic+strptime">base::strptime()</a></code>
for conversion specifications if planning to use a different format string.</p>
</td></tr>
<tr><td><code id="affix_datetime_+3A_delimiter">delimiter</code></td>
<td>
<p>The delimiter characters to use for separating the datetime
string from the original file name.</p>
</td></tr>
<tr><td><code id="affix_datetime_+3A_utc_time">utc_time</code></td>
<td>
<p>An option for whether to use the current UTC time to
establish the datetime (the default, with <code>TRUE</code>), or, use the system's
local time (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="affix_datetime_+3A_add_tz">add_tz</code></td>
<td>
<p>Should the time zone (as an offset from UTC) be provided? If
<code>TRUE</code> then the UTC offset will be either provided as <code style="white-space: pre;">&#8288;&lt;time&gt;Z&#8288;</code> (if
<code>utc_time = TRUE</code>) or <code style="white-space: pre;">&#8288;&lt;time&gt;(+/-)hhmm&#8288;</code>. By default, this is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>



<h4>The basics of creating a filename with the current date and time</h4>

<p>Taking the generic <code>"pb_file"</code> name for a file, we add the current datetime
to it as a suffix.
</p>
<div class="sourceCode r"><pre>affix_datetime(filename = "pb_file")
</pre></div>
<div class="sourceCode"><pre>## [1] "pb_file_2022-04-01_00-32-53"
</pre></div>
<p>File extensions won't get in the way:
</p>
<div class="sourceCode r"><pre>affix_datetime(filename = "pb_file.rds")
</pre></div>
<div class="sourceCode"><pre>## [1] "pb_file_2022-04-01_00-32-53.rds"
</pre></div>
<p>The datetime can be used as a prefix.
</p>
<div class="sourceCode r"><pre>affix_datetime(
  filename = "pb_file",
  position = "start"
)
</pre></div>
<div class="sourceCode"><pre>## [1] "2022-04-01_00-32-53_pb_file"
</pre></div>
<p>The datetime pattern can be changed and so can the delimiter.
</p>
<div class="sourceCode r"><pre>affix_datetime(
  filename = "pb_file.yml",
  format = "%Y%m%d_%H%M%S",
  delimiter = "-"
)
</pre></div>
<div class="sourceCode"><pre>## [1] "pb_file-20220401_003253.yml"
</pre></div>
<p>Time zone information can be included. By default, all datetimes are given in
the UTC time zone.
</p>
<div class="sourceCode r"><pre>affix_datetime(
  filename = "pb_file.yml",
  add_tz = TRUE
)
</pre></div>
<div class="sourceCode"><pre>## [1] "pb_file_2022-04-01_00-32-53Z.yml"
</pre></div>
<p>We can use the system's local time zone with <code>utc_time = FALSE</code>.
</p>
<div class="sourceCode r"><pre>affix_datetime(
  filename = "pb_file.yml",
  utc_time = FALSE,
  add_tz = TRUE
)
</pre></div>
<div class="sourceCode"><pre>## [1] "pb_file_2022-03-31_20-32-53-0400.yml"
</pre></div>



<h4>Using a datetime-based filename in a <strong>pointblank</strong> workflow</h4>

<p>We can use a file-naming convention involving datetimes when writing output
files immediately after interrogating. This is just one example (any workflow
involving a <code>filename</code> argument is applicable). It's really advantageous to
use datetime-based filenames when interrogating directly from YAML in a
scheduled process, especially if multiple validation runs per day are being
executed on the same target table.
</p>
<div class="sourceCode r"><pre>yaml_agent_interrogate(
  filename = system.file(
    "yaml", "agent-small_table.yml",
    package = "pointblank"
  )
) %&gt;% 
  x_write_disk(
    filename = affix_datetime(
      filename = "small_table_agent.rds",
      delimiter = "-"
    ),
    keep_tbl = TRUE,
    keep_extracts = TRUE
  )
</pre></div>
<p>In the above, we used the written-to-disk agent (The
<code>"agent-small_table.yml"</code> YAML file) for an interrogation via
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>. Then, the results were written to disk as an RDS
file. In the <code>filename</code> argument of <code><a href="#topic+x_write_disk">x_write_disk()</a></code>, the <code><a href="#topic+affix_datetime">affix_datetime()</a></code>
function was used to ensure that frequent runs would produce files whose
names indicate the day and time of execution.
</p>



<h3>Function ID</h3>

<p>13-4
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+affix_date">affix_date()</a></code> function provides the same features except it
produces a date string by default.
</p>
<p>Other Utility and Helper Functions: 
<code><a href="#topic+affix_date">affix_date</a>()</code>,
<code><a href="#topic+col_schema">col_schema</a>()</code>,
<code><a href="#topic+from_github">from_github</a>()</code>,
<code><a href="#topic+has_columns">has_columns</a>()</code>,
<code><a href="#topic+stop_if_not">stop_if_not</a>()</code>
</p>

<hr>
<h2 id='all_passed'>Did all of the validations fully <em>pass</em>?</h2><span id='topic+all_passed'></span>

<h3>Description</h3>

<p>Given an agent's validation plan that had undergone interrogation via
<code><a href="#topic+interrogate">interrogate()</a></code>, did every single validation step result in zero <em>failing</em>
test units? Using the <code>all_passed()</code> function will let us know whether that's
<code>TRUE</code> or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_passed(agent, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_passed_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function.</p>
</td></tr>
<tr><td><code id="all_passed_+3A_i">i</code></td>
<td>
<p><em>Validation step numbers</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A vector of validation step numbers. These values are assigned to each
validation step by <strong>pointblank</strong> in the order of definition. If <code>NULL</code>
(the default), all validation steps will be used for the evaluation of
complete <em>passing</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>all_passed()</code> function provides a single logical value based on an
interrogation performed in the <em>agent</em>-based workflow. For very large-scale
validation (where data quality is a known issue, and is perhaps something to
be tamed over time) this function is likely to be less useful since it is
quite stringent (all test units must pass across all validation steps).
</p>
<p>Should there be a requirement for logical values produced from validation, a
more flexible alternative is in using the test (<code style="white-space: pre;">&#8288;test_*()&#8288;</code>) variants of the
validation functions. Each of those produce a single logical value and each
and have a <code>threshold</code> option for failure levels. Another option is to
utilize post-interrogation objects within the <em>agent</em>'s x-list (obtained by
using the <code><a href="#topic+get_agent_x_list">get_agent_x_list()</a></code> function). This allows for many possibilities
in producing a single logical value from an interrogation.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<p>Create a simple table with a column of numerical values.
</p>
<div class="sourceCode r"><pre>tbl &lt;- dplyr::tibble(a = c(4, 5, 7, 8))

tbl
#&gt; # A tibble: 4 x 1
#&gt;       a
#&gt;   &lt;dbl&gt;
#&gt; 1     4
#&gt; 2     5
#&gt; 3     7
#&gt; 4     8
</pre></div>
<p>Validate that values in column <code>a</code> are always greater than 4.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_gt(columns = a, value = 3) %&gt;%
  col_vals_lte(columns = a, value = 10) %&gt;%
  col_vals_increasing(columns = a) %&gt;%
  interrogate()
</pre></div>
<p>Determine if these column validations have all passed by using <code>all_passed()</code>
(they do).
</p>
<div class="sourceCode r"><pre>all_passed(agent = agent)
</pre></div>
<div class="sourceCode"><pre>#&gt; [1] TRUE
</pre></div>


<h3>Function ID</h3>

<p>8-4
</p>


<h3>See Also</h3>

<p>Other Post-interrogation: 
<code><a href="#topic+get_agent_x_list">get_agent_x_list</a>()</code>,
<code><a href="#topic+get_data_extracts">get_data_extracts</a>()</code>,
<code><a href="#topic+get_sundered_data">get_sundered_data</a>()</code>,
<code><a href="#topic+write_testthat_file">write_testthat_file</a>()</code>
</p>

<hr>
<h2 id='col_count_match'>Does the column count match that of a different table?</h2><span id='topic+col_count_match'></span><span id='topic+expect_col_count_match'></span><span id='topic+test_col_count_match'></span>

<h3>Description</h3>

<p>The <code>col_count_match()</code> validation function, the <code>expect_col_count_match()</code>
expectation function, and the <code>test_col_count_match()</code> test function all
check whether the column count in the target table matches that of a
comparison table. The validation function can be used directly on a data
table or with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object)
whereas the expectation and test functions can only be used with a data
table. As a validation step or as an expectation, there is a single test unit
that hinges on whether the column counts for the two tables are the same
(after any <code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_count_match(
  x,
  count,
  preconditions = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_count_match(object, count, preconditions = NULL, threshold = 1)

test_col_count_match(object, count, preconditions = NULL, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_count_match_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_count_match_+3A_count">count</code></td>
<td>
<p><em>The count comparison</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;numeric|integer&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>Either a literal value for the number of columns, or, a table to compare
against the target table in terms of column count values. If supplying a
comparison table, it can either be a table object such as a data frame, a
tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object. Alternatively, a
table-prep formula (<code style="white-space: pre;">&#8288;~ &lt;tbl reading code&gt;&#8288;</code>) or a function (
<code style="white-space: pre;">&#8288;function() &lt;tbl reading code&gt;&#8288;</code>) can be used to lazily read in the
comparison table at interrogation time.</p>
</td></tr>
<tr><td><code id="col_count_match_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_count_match_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_count_match_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_count_match_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_count_match_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_count_match_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_count_match_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_count_match_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that this particular validation requires some operation on the target table
before the column count comparison takes place. Using <code>preconditions</code> can be
useful at times since since we can develop a large validation plan with a
single target table and make minor adjustments to it, as needed, along the
way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed. Alternatively, a function
could instead be supplied.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. Using
<code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices
depending on the situation (the first produces a warning, the other
<code>stop()</code>s).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_count_match()</code> is represented in YAML (under the top-level <code>steps</code> key
as a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_count_match()</code> as
a validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_count_match(
    count = ~ file_tbl(
      file = from_github(
        file = "sj_all_revenue_large.rds",
        repo = "rich-iannone/intendo",
        subdir = "data-large"
        )
      ),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_count_match()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_count_match:
    count: ~ file_tbl(
      file = from_github(
        file = "sj_all_revenue_large.rds",
        repo = "rich-iannone/intendo",
        subdir = "data-large"
        )
      )
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_count_match()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter. Arguments with default
values won't be written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is
acceptable to include them with their default when generating the YAML by
other means). It is also possible to preview the transformation of an agent
to YAML without any writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code>
function.
</p>


<h3>Examples</h3>

<p>Create a simple table with three columns and three rows of values:
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 7, 6),
    b = c(7, 1, 0),
    c = c(1, 1, 1)
  )
  
tbl
#&gt; # A tibble: 3 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7     1
#&gt; 2     7     1     1
#&gt; 3     6     0     1
</pre></div>
<p>Create a second table which is quite different but has the same number of
columns as <code>tbl</code>.
</p>
<div class="sourceCode r"><pre>tbl_2 &lt;-
  dplyr::tibble(
    e = c("a", NA, "a", "c"),
    f = c(2.6, 1.2, 0, NA),
    g = c("f", "g", "h", "i")
  )
  
tbl_2
#&gt; # A tibble: 4 x 3
#&gt;   e         f g    
#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;
#&gt; 1 a       2.6 f    
#&gt; 2 &lt;NA&gt;    1.2 g    
#&gt; 3 a       0   h    
#&gt; 4 c      NA   i
</pre></div>
<p>We'll use these tables with the different function variants.
</p>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the count of columns in the target table (<code>tbl</code>) matches that
of the comparison table (<code>tbl_2</code>).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_count_match(count = tbl_2) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_count_match_1.png" alt="This image was generated from the first code example in the `col_count_match()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter: data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% col_count_match(count = tbl_2)
#&gt; # A tibble: 3 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7     1
#&gt; 2     7     1     1
#&gt; 3     6     0     1
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_count_match(tbl, count = tbl_2)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_col_count_match(count = 3)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-32
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_exists'>Do one or more columns actually exist?</h2><span id='topic+col_exists'></span><span id='topic+expect_col_exists'></span><span id='topic+test_col_exists'></span>

<h3>Description</h3>

<p>The <code>col_exists()</code> validation function, the <code>expect_col_exists()</code> expectation
function, and the <code>test_col_exists()</code> test function all check whether one or
more columns exist in the target table. The only requirement is specification
of the column names. The validation function can be used directly on a data
table or with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object)
whereas the expectation and test functions can only be used with a data
table. Each validation step or expectation will operate over a single test
unit, which is whether the column exists or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_exists(
  x,
  columns = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_exists(object, columns, threshold = 1)

test_col_exists(object, columns, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_exists_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_exists_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_exists_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_exists_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_exists_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_exists_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_exists_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_exists_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_exists_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. Using
<code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices
depending on the situation (the first produces a warning, the other
<code>stop()</code>s).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_exists()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_exists()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_exists(
    columns = a,
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_exists()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_exists:
    columns: c(a)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_exists()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all examples here, we'll use a simple table with two columns: <code>a</code> and
<code>b</code>.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5, 8, 7),
    b = c(7, 1, 0, 0, 0, 3)
  )
  
tbl
#&gt; # A tibble: 6 x 2
#&gt;       a     b
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7
#&gt; 2     7     1
#&gt; 3     6     0
#&gt; 4     5     0
#&gt; 5     8     0
#&gt; 6     7     3
</pre></div>
<p>We'll use this table with the different function variants.
</p>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that column <code>a</code> exists in the <code>tbl</code> table with <code>col_exists()</code>.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_exists(columns = a) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_exists_1.png" alt="This image was generated from the first code example in the `col_exists()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is
passed through but should <code>stop()</code> if there is a single test unit failing.
The behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% col_exists(columns = a)
#&gt; # A tibble: 6 x 2
#&gt;       a     b
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7
#&gt; 2     7     1
#&gt; 3     6     0
#&gt; 4     5     0
#&gt; 5     8     0
#&gt; 6     7     3
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_exists(tbl, columns = a)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_col_exists(columns = a)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-29
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_is_character'>Do the columns contain character/string data?</h2><span id='topic+col_is_character'></span><span id='topic+expect_col_is_character'></span><span id='topic+test_col_is_character'></span>

<h3>Description</h3>

<p>The <code>col_is_character()</code> validation function, the <code>expect_col_is_character()</code>
expectation function, and the <code>test_col_is_character()</code> test function all
check whether one or more columns in a table is of the character type. Like
many of the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions in <strong>pointblank</strong>, the only
requirement is a specification of the column names. The validation function
can be used directly on a data table or with an <em>agent</em> object (technically,
a <code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over a single test unit, which is whether the column is a character-type
column or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_is_character(
  x,
  columns,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_is_character(object, columns, threshold = 1)

test_col_is_character(object, columns, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_is_character_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_is_character_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_character_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_is_character_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_is_character_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_character_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_is_character_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_is_character_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_is_character_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. For the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions, using <code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices depending on the
situation (the first produces a warning, the other will <code>stop()</code>).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_is_character()</code> is represented in YAML (under the top-level <code>steps</code> key
as a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_is_character()</code> as
a validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_is_character(
    columns = a,
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_is_character()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_is_character:
    columns: c(a)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_is_character()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all examples here, we'll use a simple table with a numeric column (<code>a</code>)
and a character column (<code>b</code>).
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5, 8, 7),
    b = LETTERS[1:6]
  )

tbl
#&gt; # A tibble: 6 x 2
#&gt;       a b    
#&gt;   &lt;dbl&gt; &lt;chr&gt;
#&gt; 1     5 A    
#&gt; 2     7 B    
#&gt; 3     6 C    
#&gt; 4     5 D    
#&gt; 5     8 E    
#&gt; 6     7 F
</pre></div>
<p>We'll use this table with the different function variants.
</p>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that column <code>b</code> has the <code>character</code> class.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_is_character(columns = b) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_is_character_1.png" alt="This image was generated from the first code example in the `col_is_character()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  col_is_character(columns = b) %&gt;%
  dplyr::slice(1:5)
#&gt; # A tibble: 5 x 2
#&gt;       a b    
#&gt;   &lt;dbl&gt; &lt;chr&gt;
#&gt; 1     5 A    
#&gt; 2     7 B    
#&gt; 3     6 C    
#&gt; 4     5 D    
#&gt; 5     8 E
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_is_character(tbl, columns = b)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_col_is_character(columns = b)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-22
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_is_date'>Do the columns contain R <code>Date</code> objects?</h2><span id='topic+col_is_date'></span><span id='topic+expect_col_is_date'></span><span id='topic+test_col_is_date'></span>

<h3>Description</h3>

<p>The <code>col_is_date()</code> validation function, the <code>expect_col_is_date()</code>
expectation function, and the <code>test_col_is_date()</code> test function all check
whether one or more columns in a table is of the <strong>R</strong> <code>Date</code> type. Like many
of the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions in <strong>pointblank</strong>, the only requirement is
a specification of the column names. The validation function can be used
directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over a single test unit, which is whether the column is a <code>Date</code>-type column
or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_is_date(
  x,
  columns,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_is_date(object, columns, threshold = 1)

test_col_is_date(object, columns, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_is_date_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_is_date_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_date_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_is_date_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_is_date_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_date_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_is_date_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_is_date_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_is_date_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. For the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions, using <code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices depending on the
situation (the first produces a warning, the other will <code>stop()</code>).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_is_date()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_is_date()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_is_date(
    columns = a,
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_is_date()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_is_date:
    columns: c(a)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_is_date()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package has a <code>date</code> column. The following
examples will validate that that column is of the <code>Date</code> class.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the column <code>date</code> has the <code>Date</code> class.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_is_date(columns = date) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_is_date_1.png" alt="This image was generated from the first code example in the `col_is_date()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_is_date(columns = date) %&gt;%
  dplyr::slice(1:5)
#&gt; # A tibble: 5 x 8
#&gt;   date_time           date           a b             c      d e     f    
#&gt;   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt; 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt; 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt; 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt; 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt; 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_is_date(small_table, columns = date)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;% test_col_is_date(columns = date)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-26
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_is_factor'>Do the columns contain R <code>factor</code> objects?</h2><span id='topic+col_is_factor'></span><span id='topic+expect_col_is_factor'></span><span id='topic+test_col_is_factor'></span>

<h3>Description</h3>

<p>The <code>col_is_factor()</code> validation function, the <code>expect_col_is_factor()</code>
expectation function, and the <code>test_col_is_factor()</code> test function all check
whether one or more columns in a table is of the factor type. Like many of
the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions in <strong>pointblank</strong>, the only requirement is a
specification of the column names. The validation function can be used
directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over a single test unit, which is whether the column is a factor-type column
or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_is_factor(
  x,
  columns,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_is_factor(object, columns, threshold = 1)

test_col_is_factor(object, columns, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_is_factor_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_is_factor_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_factor_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_is_factor_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_is_factor_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_factor_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_is_factor_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_is_factor_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_is_factor_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. For the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions, using <code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices depending on the
situation (the first produces a warning, the other will <code>stop()</code>).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_is_factor()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_is_factor()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_is_factor(
    columns = a,
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_is_factor()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_is_factor:
    columns: c(a)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_is_factor()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>Let's modify the <code>f</code> column in the <code>small_table</code> dataset so that the values
are factors instead of having the <code>character</code> class. The following examples
will validate that the <code>f</code> column was successfully mutated and now consists
of factors.
</p>
<div class="sourceCode r"><pre>tbl &lt;- 
  small_table %&gt;%
  dplyr::mutate(f = factor(f))
  
tbl
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;fct&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the column <code>f</code> in the <code>tbl</code> object is of the <code>factor</code> class.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_is_factor(columns = f) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_is_factor_1.png" alt="This image was generated from the first code example in the `col_is_factor()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  col_is_factor(columns = f) %&gt;%
  dplyr::slice(1:5)
#&gt; # A tibble: 5 x 8
#&gt;   date_time           date           a b             c      d e     f    
#&gt;   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;fct&gt;
#&gt; 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt; 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt; 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt; 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt; 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_is_factor(tbl, f)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_col_is_factor(columns = f)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-28
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_is_integer'>Do the columns contain integer values?</h2><span id='topic+col_is_integer'></span><span id='topic+expect_col_is_integer'></span><span id='topic+test_col_is_integer'></span>

<h3>Description</h3>

<p>The <code>col_is_integer()</code> validation function, the <code>expect_col_is_integer()</code>
expectation function, and the <code>test_col_is_integer()</code> test function all check
whether one or more columns in a table is of the integer type. Like many of
the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions in <strong>pointblank</strong>, the only requirement is a
specification of the column names. The validation function can be used
directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over a single test unit, which is whether the column is an integer-type
column or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_is_integer(
  x,
  columns,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_is_integer(object, columns, threshold = 1)

test_col_is_integer(object, columns, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_is_integer_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_is_integer_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_integer_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_is_integer_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_is_integer_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_integer_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_is_integer_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_is_integer_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_is_integer_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. For the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions, using <code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices depending on the
situation (the first produces a warning, the other will <code>stop()</code>).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_is_integer()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_is_integer()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_is_integer(
    columns = a,
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_is_integer()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_is_integer:
    columns: c(a)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_is_integer()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all examples here, we'll use a simple table with a character column (<code>a</code>)
and a integer column (<code>b</code>).
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = letters[1:6],
    b = 2:7
  )

tbl
#&gt; # A tibble: 6 x 2
#&gt;   a         b
#&gt;   &lt;chr&gt; &lt;int&gt;
#&gt; 1 a         2
#&gt; 2 b         3
#&gt; 3 c         4
#&gt; 4 d         5
#&gt; 5 e         6
#&gt; 6 f         7
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that column <code>b</code> has the <code>integer</code> class.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_is_integer(columns = b) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_is_integer_1.png" alt="This image was generated from the first code example in the `col_is_integer()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% col_is_integer(columns = b)
#&gt; # A tibble: 6 x 2
#&gt;   a         b
#&gt;   &lt;chr&gt; &lt;int&gt;
#&gt; 1 a         2
#&gt; 2 b         3
#&gt; 3 c         4
#&gt; 4 d         5
#&gt; 5 e         6
#&gt; 6 f         7
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_is_integer(tbl, columns = b)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_col_is_integer(columns = b)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-24
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_is_logical'>Do the columns contain logical values?</h2><span id='topic+col_is_logical'></span><span id='topic+expect_col_is_logical'></span><span id='topic+test_col_is_logical'></span>

<h3>Description</h3>

<p>The <code>col_is_logical()</code> validation function, the <code>expect_col_is_logical()</code>
expectation function, and the <code>test_col_is_logical()</code> test function all check
whether one or more columns in a table is of the logical (<code>TRUE</code>/<code>FALSE</code>)
type. Like many of the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions in <strong>pointblank</strong>, the
only requirement is a specification of the column names. The validation
function can be used directly on a data table or with an <em>agent</em> object
(technically, a <code>ptblank_agent</code> object) whereas the expectation and test
functions can only be used with a data table. Each validation step or
expectation will operate over a single test unit, which is whether the column
is an logical-type column or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_is_logical(
  x,
  columns,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_is_logical(object, columns, threshold = 1)

test_col_is_logical(object, columns, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_is_logical_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_is_logical_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_logical_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_is_logical_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_is_logical_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_logical_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_is_logical_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_is_logical_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_is_logical_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. For the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions, using <code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices depending on the
situation (the first produces a warning, the other will <code>stop()</code>).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_is_logical()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_is_logical()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_is_logical(
    columns = a,
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_is_logical()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_is_logical:
    columns: c(a)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_is_logical()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package has an <code>e</code> column which has logical
values. The following examples will validate that that column is of the
<code>logical</code> class.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the column <code>e</code> has the <code>logical</code> class.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_is_logical(columns = e) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_is_logical_1.png" alt="This image was generated from the first code example in the `col_is_logical()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_is_logical(columns = e) %&gt;%
  dplyr::slice(1:5)
#&gt; # A tibble: 5 x 8
#&gt;   date_time           date           a b             c      d e     f    
#&gt;   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt; 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt; 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt; 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt; 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt; 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_is_logical(small_table, columns = e)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;% test_col_is_logical(columns = e)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-25
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_is_numeric'>Do the columns contain numeric values?</h2><span id='topic+col_is_numeric'></span><span id='topic+expect_col_is_numeric'></span><span id='topic+test_col_is_numeric'></span>

<h3>Description</h3>

<p>The <code>col_is_numeric()</code> validation function, the <code>expect_col_is_numeric()</code>
expectation function, and the <code>test_col_is_numeric()</code> test function all check
whether one or more columns in a table is of the numeric type. Like many of
the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions in <strong>pointblank</strong>, the only requirement is a
specification of the column names. The validation function can be used
directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over a single test unit, which is whether the column is a numeric-type column
or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_is_numeric(
  x,
  columns,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_is_numeric(object, columns, threshold = 1)

test_col_is_numeric(object, columns, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_is_numeric_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_is_numeric_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_numeric_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_is_numeric_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_is_numeric_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_numeric_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_is_numeric_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_is_numeric_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_is_numeric_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. For the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions, using <code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices depending on the
situation (the first produces a warning, the other will <code>stop()</code>).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_is_numeric()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_is_numeric()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_is_numeric(
    columns = a,
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_is_numeric()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_is_numeric:
    columns: c(a)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_is_numeric()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package has a <code>d</code> column that is known to be
numeric. The following examples will validate that that column is indeed of
the <code>numeric</code> class.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the column <code>d</code> has the <code>numeric</code> class.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_is_numeric(columns = d) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_is_numeric_1.png" alt="This image was generated from the first code example in the `col_is_numeric()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_is_numeric(columns = d) %&gt;%
  dplyr::slice(1:5)
#&gt; # A tibble: 5 x 8
#&gt;   date_time           date           a b             c      d e     f    
#&gt;   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt; 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt; 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt; 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt; 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt; 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_is_numeric(small_table, columns = d)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;% test_col_is_numeric(columns = d)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-23
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_is_posix'>Do the columns contain <code>POSIXct</code> dates?</h2><span id='topic+col_is_posix'></span><span id='topic+expect_col_is_posix'></span><span id='topic+test_col_is_posix'></span>

<h3>Description</h3>

<p>The <code>col_is_posix()</code> validation function, the <code>expect_col_is_posix()</code>
expectation function, and the <code>test_col_is_posix()</code> test function all check
whether one or more columns in a table is of the R <code>POSIXct</code> date-time type.
Like many of the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions in <strong>pointblank</strong>, the only
requirement is a specification of the column names. The validation function
can be used directly on a data table or with an <em>agent</em> object (technically,
a <code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over a single test unit, which is whether the column is a <code>POSIXct</code>-type
column or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_is_posix(
  x,
  columns,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_is_posix(object, columns, threshold = 1)

test_col_is_posix(object, columns, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_is_posix_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_is_posix_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_posix_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_is_posix_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_is_posix_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_is_posix_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_is_posix_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_is_posix_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_is_posix_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. For the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code>-type functions, using <code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices depending on the
situation (the first produces a warning, the other will <code>stop()</code>).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_is_posix()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_is_posix()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_is_posix(
    columns = a,
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_is_posix()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_is_posix:
    columns: c(a)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_is_posix()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package has a <code>date_time</code> column. The
following examples will validate that that column is of the <code>POSIXct</code> and
<code>POSIXt</code> classes.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the column <code>date_time</code> is indeed a date-time column.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_is_posix(columns = date_time) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_is_posix_1.png" alt="This image was generated from the first code example in the `col_is_posix()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_is_posix(columns = date_time) %&gt;%
  dplyr::slice(1:5)
#&gt; # A tibble: 5 x 8
#&gt;   date_time           date           a b             c      d e     f    
#&gt;   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt; 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt; 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt; 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt; 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt; 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_is_posix(small_table, columns = date_time)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;% test_col_is_posix(columns = date_time)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-27
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_schema'>Generate a table column schema manually or with a reference table</h2><span id='topic+col_schema'></span>

<h3>Description</h3>

<p>A table column schema object, as can be created by <code>col_schema()</code>, is
necessary when using the <code><a href="#topic+col_schema_match">col_schema_match()</a></code> validation function (which
checks whether the table object under study matches a known column schema).
The <code>col_schema</code> object can be made by carefully supplying the column names
and their types as a set of named arguments, or, we could provide a table
object, which could be of the <code>data.frame</code>, <code>tbl_df</code>, <code>tbl_dbi</code>, or
<code>tbl_spark</code> varieties. There's an additional option, which is just for
validating the schema of a <code>tbl_dbi</code> or <code>tbl_spark</code> object: we can validate
the schema based on R column types (e.g., <code>"numeric"</code>, <code>"character"</code>, etc.),
SQL column types (e.g., <code>"double"</code>, <code>"varchar"</code>, etc.), or Spark SQL column
types (<code>"DoubleType"</code>, <code>"StringType"</code>, etc.). This is great if we want to
validate table column schemas both on the server side and when tabular data
is collected and loaded into R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_schema(..., .tbl = NULL, .db_col_types = c("r", "sql"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_schema_+3A_...">...</code></td>
<td>
<p><em>Column-by-column schema definition</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;multiple expressions&gt;&#8288;</code> // <strong>required</strong> (or, use <code>.tbl</code>)
</p>
<p>A set of named arguments where the names refer to column names and
the values are one or more column types.</p>
</td></tr>
<tr><td><code id="col_schema_+3A_.tbl">.tbl</code></td>
<td>
<p><em>A data table for defining a schema</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>optional</strong>
</p>
<p>An option to use a table object to define the schema. If this is provided
then any values provided to <code>...</code> will be ignored. This can either be a
table object, a table-prep formula.This can be a table object such as a
data frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object.
Alternatively, a table-prep formula (<code style="white-space: pre;">&#8288;~ &lt;tbl reading code&gt;&#8288;</code>) or a
function (<code style="white-space: pre;">&#8288;function() &lt;tbl reading code&gt;&#8288;</code>) can be used to lazily read in
the table at interrogation time.</p>
</td></tr>
<tr><td><code id="col_schema_+3A_.db_col_types">.db_col_types</code></td>
<td>
<p><em>Use R column types or database column types?</em>
</p>
<p><code style="white-space: pre;">&#8288;singl-kw:[r|sql]&#8288;</code> // <em>default:</em> <code>"r"</code>
</p>
<p>Determines whether the column types refer to R column types (<code>"r"</code>) or SQL
column types (<code>"sql"</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<p>Create a simple table with two columns: one <code>integer</code> and the other
<code>character</code>.
</p>
<div class="sourceCode r"><pre>tbl &lt;- 
  dplyr::tibble(
    a = 1:5,
    b = letters[1:5]
  )

tbl
#&gt; # A tibble: 5 x 2
#&gt;       a b    
#&gt;   &lt;int&gt; &lt;chr&gt;
#&gt; 1     1 a    
#&gt; 2     2 b    
#&gt; 3     3 c    
#&gt; 4     4 d    
#&gt; 5     5 e
</pre></div>
<p>Create a column schema object that describes the columns and their types (in
the expected order).
</p>
<div class="sourceCode r"><pre>schema_obj &lt;- 
  col_schema(
    a = "integer",
    b = "character"
  )

schema_obj
#&gt; $a
#&gt; [1] "integer"
#&gt; 
#&gt; $b
#&gt; [1] "character"
#&gt; 
#&gt; attr(,"class")
#&gt; [1] "r_type"     "col_schema"
</pre></div>
<p>Validate that the schema object <code>schema_obj</code> exactly defines the column names
and column types of the <code>tbl</code> table.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_schema_match(schema_obj) %&gt;%
  interrogate()
</pre></div>
<p>Determine if this validation step passed by using <code>all_passed()</code>.
</p>
<div class="sourceCode r"><pre>all_passed(agent)
</pre></div>
<div class="sourceCode"><pre>## [1] TRUE
</pre></div>
<p>We can alternatively create a column schema object from a <code>tbl_df</code> object.
</p>
<div class="sourceCode r"><pre>schema_obj &lt;-
  col_schema(
    .tbl = dplyr::tibble(
      a = integer(0),
      b = character(0)
    )
  )
</pre></div>
<p>This should provide the same interrogation results as in the previous
example.
</p>
<div class="sourceCode r"><pre>create_agent(tbl = tbl) %&gt;%
  col_schema_match(schema_obj) %&gt;%
  interrogate() %&gt;%
  all_passed()
</pre></div>
<div class="sourceCode"><pre>## [1] TRUE
</pre></div>


<h3>Function ID</h3>

<p>13-1
</p>


<h3>See Also</h3>

<p>Other Utility and Helper Functions: 
<code><a href="#topic+affix_date">affix_date</a>()</code>,
<code><a href="#topic+affix_datetime">affix_datetime</a>()</code>,
<code><a href="#topic+from_github">from_github</a>()</code>,
<code><a href="#topic+has_columns">has_columns</a>()</code>,
<code><a href="#topic+stop_if_not">stop_if_not</a>()</code>
</p>

<hr>
<h2 id='col_schema_match'>Do columns in the table (and their types) match a predefined schema?</h2><span id='topic+col_schema_match'></span><span id='topic+expect_col_schema_match'></span><span id='topic+test_col_schema_match'></span>

<h3>Description</h3>

<p>The <code>col_schema_match()</code> validation function, the <code>expect_col_schema_match()</code>
expectation function, and the <code>test_col_schema_match()</code> test function all
work in conjunction with a <code>col_schema</code> object (generated through the
<code><a href="#topic+col_schema">col_schema()</a></code> function) to determine whether the expected schema matches
that of the target table. The validation function can be used directly on a
data table or with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object)
whereas the expectation and test functions can only be used with a data
table.
</p>
<p>The validation step or expectation operates over a single test unit, which is
whether the schema matches that of the table (within the constraints enforced
by the <code>complete</code>, <code>in_order</code>, and <code>is_exact</code> options). If the target table
is a <code>tbl_dbi</code> or a <code>tbl_spark</code> object, we can choose to validate the column
schema that is based on R column types (e.g., <code>"numeric"</code>, <code>"character"</code>,
etc.), SQL column types (e.g., <code>"double"</code>, <code>"varchar"</code>, etc.), or Spark SQL
types (e.g,. <code>"DoubleType"</code>, <code>"StringType"</code>, etc.). That option is defined in
the <code><a href="#topic+col_schema">col_schema()</a></code> function (it is the <code>.db_col_types</code> argument).
</p>
<p>There are options to make schema checking less stringent (by default, this
validation operates with highest level of strictness). With the <code>complete</code>
option set to <code>FALSE</code>, we can supply a <code>col_schema</code> object with a partial
inclusion of columns. Using <code>in_order</code> set to <code>FALSE</code> means that there is no
requirement for the columns defined in the <code>schema</code> object to be in the same
order as in the target table. Finally, the <code>is_exact</code> option set to <code>FALSE</code>
means that all column classes/types don't have to be provided for a
particular column. It can even be <code>NULL</code>, skipping the check of the column
type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_schema_match(
  x,
  schema,
  complete = TRUE,
  in_order = TRUE,
  is_exact = TRUE,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_schema_match(
  object,
  schema,
  complete = TRUE,
  in_order = TRUE,
  is_exact = TRUE,
  threshold = 1
)

test_col_schema_match(
  object,
  schema,
  complete = TRUE,
  in_order = TRUE,
  is_exact = TRUE,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_schema_match_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_schema">schema</code></td>
<td>
<p><em>The table schema</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;col_schema&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A table schema of type <code>col_schema</code> which can be generated using the
<code><a href="#topic+col_schema">col_schema()</a></code> function.</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_complete">complete</code></td>
<td>
<p><em>Requirement for columns specified to exist</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A requirement to account for all table columns in the provided <code>schema</code>. By
default, this is <code>TRUE</code> and so that all column names in the target table
must be present in the schema object. This restriction can be relaxed by
using <code>FALSE</code>, where we can provide a subset of table columns in the
schema.</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_in_order">in_order</code></td>
<td>
<p><em>Requirement for columns in a specific order</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A stringent requirement for enforcing the order of columns in the provided
<code>schema</code>. By default, this is <code>TRUE</code> and the order of columns in both the
schema and the target table must match. By setting to <code>FALSE</code>, this strict
order requirement is removed.</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_is_exact">is_exact</code></td>
<td>
<p><em>Requirement for column types to be exactly specified</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>Determines whether the check for column types should be exact or even
performed at all. For example, columns in R data frames may have multiple
classes (e.g., a date-time column can have both the <code>"POSIXct"</code> and the
<code>"POSIXt"</code> classes). If using <code>is_exact == FALSE</code>, the column type in the
user-defined schema for a date-time value can be set as either <code>"POSIXct"</code>
<em>or</em> <code>"POSIXt"</code> and pass validation (with this column, at least). This can
be taken a step further and using <code>NULL</code> for a column type in the
user-defined schema will skip the validation check of a column type. By
default, <code>is_exact</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_schema_match_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. Using
<code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices
depending on the situation (the first produces a warning, the other
<code>stop()</code>s).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_schema_match()</code> is represented in YAML (under the top-level <code>steps</code> key
as a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_schema_match()</code> as
a validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_schema_match(
    schema = col_schema(
      a = "integer",
      b = "character"
    ), 
    complete = FALSE,
    in_order = FALSE,
    is_exact = FALSE,
    actions = action_levels(stop_at = 1),
    label = "The `col_schema_match()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_schema_match:
    schema:
      a: integer
      b: character
    complete: false
    in_order: false
    is_exact: false
    actions:
      stop_count: 1.0
    label: The `col_schema_match()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>schema</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all examples here, we'll use a simple table with two columns: one
<code>integer</code> (<code>a</code>) and the other <code>character</code> (<code>b</code>). The following examples will
validate that the table columns abides match a schema object as created by
<code><a href="#topic+col_schema">col_schema()</a></code>.
</p>
<div class="sourceCode r"><pre>tbl &lt;- 
  dplyr::tibble(
    a = 1:5,
    b = letters[1:5]
  )
  
tbl
#&gt; # A tibble: 5 x 2
#&gt;       a b    
#&gt;   &lt;int&gt; &lt;chr&gt;
#&gt; 1     1 a    
#&gt; 2     2 b    
#&gt; 3     3 c    
#&gt; 4     4 d    
#&gt; 5     5 e
</pre></div>
<p>Create a column schema object with the helper function <code>col_schema()</code> that
describes the columns and their types (in the expected order).
</p>
<div class="sourceCode r"><pre>schema_obj &lt;- 
  col_schema(
    a = "integer",
    b = "character"
  )

schema_obj
#&gt; $a
#&gt; [1] "integer"
#&gt; 
#&gt; $b
#&gt; [1] "character"
#&gt; 
#&gt; attr(,"class")
#&gt; [1] "r_type"     "col_schema"
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the schema object <code>schema_obj</code> exactly defines the column names
and column types. We'll determine if this validation has a failing test unit
(there is a single test unit governed by whether there is a match).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_schema_match(schema = schema_obj) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_schema_match_1.png" alt="This image was generated from the first code example in the `col_schema_match()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% col_schema_match(schema = schema_obj)
#&gt; # A tibble: 5 x 2
#&gt;       a b    
#&gt;   &lt;int&gt; &lt;chr&gt;
#&gt; 1     1 a    
#&gt; 2     2 b    
#&gt; 3     3 c    
#&gt; 4     4 d    
#&gt; 5     5 e
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_schema_match(tbl, scheam = schema_obj)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_col_schema_match(schema = schema_obj)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-30
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_between'>Do column data lie between two specified values or data in other columns?</h2><span id='topic+col_vals_between'></span><span id='topic+expect_col_vals_between'></span><span id='topic+test_col_vals_between'></span>

<h3>Description</h3>

<p>The <code>col_vals_between()</code> validation function, the <code>expect_col_vals_between()</code>
expectation function, and the <code>test_col_vals_between()</code> test function all
check whether column values in a table fall within a range. The range
specified with three arguments: <code>left</code>, <code>right</code>, and <code>inclusive</code>. The <code>left</code>
and <code>right</code> values specify the lower and upper bounds. The bounds can be
specified as single, literal values or as column names given in <code>vars()</code>. The
<code>inclusive</code> argument, as a vector of two logical values relating to <code>left</code>
and <code>right</code>, states whether each bound is inclusive or not. The default is
<code>c(TRUE, TRUE)</code>, where both endpoints are inclusive (i.e., <code style="white-space: pre;">&#8288;[left, right]&#8288;</code>).
For partially-unbounded versions of this function, we can use the
<code><a href="#topic+col_vals_lt">col_vals_lt()</a></code>, <code><a href="#topic+col_vals_lte">col_vals_lte()</a></code>, <code><a href="#topic+col_vals_gt">col_vals_gt()</a></code>, or <code><a href="#topic+col_vals_gte">col_vals_gte()</a></code>
validation functions. The validation function can be used directly on a data
table or with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object)
whereas the expectation and test functions can only be used with a data
table. Each validation step or expectation will operate over the number of
test units that is equal to the number of rows in the table (after any
<code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_between(
  x,
  columns,
  left,
  right,
  inclusive = c(TRUE, TRUE),
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_between(
  object,
  columns,
  left,
  right,
  inclusive = c(TRUE, TRUE),
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_between(
  object,
  columns,
  left,
  right,
  inclusive = c(TRUE, TRUE),
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_between_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_left">left</code></td>
<td>
<p><em>Definition of left bound</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The lower bound for the range. The validation includes this bound
value (if the first element in <code>inclusive</code> is <code>TRUE</code>) in addition to values
greater than <code>left</code>. This can be a single value or a compatible column
given in <code>vars()</code>.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_right">right</code></td>
<td>
<p><em>Definition of right bound</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The upper bound for the range. The validation includes this
bound value (if the second element in <code>inclusive</code> is <code>TRUE</code>) in addition to
values lower than <code>right</code>. This can be a single value or a compatible
column given in <code>vars()</code>.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_inclusive">inclusive</code></td>
<td>
<p><em>Inclusiveness of bounds</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>c(TRUE, TRUE)</code>
</p>
<p>A two-element logical value that indicates whether the <code>left</code> and <code>right</code>
bounds should be inclusive. By default, both bounds are inclusive.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_between_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_between()</code> is represented in YAML (under the top-level <code>steps</code> key
as a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_between()</code> as
a validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_between(
    columns = a,
    left = 1,
    right = 2,
    inclusive = c(TRUE, FALSE),
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_between()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_between:
    columns: c(a)
    left: 1.0
    right: 2.0
    inclusive:
    - true
    - false
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_between()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>,
<code>left</code>, and <code>right</code> arguments require values. Arguments with default values
won't be written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable
to include them with their default when generating the YAML by other means).
It is also possible to preview the transformation of an agent to YAML without
any writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package has a column of numeric values in
<code>c</code> (there are a few NAs in that column). The following examples will
validate the values in that numeric column.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>c</code> are all between <code>1</code> and <code>9</code>. Because there
are <code>NA</code> values, we'll choose to let those pass validation by setting
<code>na_pass = TRUE</code>.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_vals_between(
    columns = c,
    left = 1, right = 9,
    na_pass = TRUE
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_between_1.png" alt="This image was generated from the first code example in the `col_vals_between()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_between(
    columns = c,
    left = 1, right = 9,
    na_pass = TRUE
  ) %&gt;%
  dplyr::pull(c)
#&gt;  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_between(
  small_table, columns = c,
  left = 1, right = 9,
  na_pass = TRUE
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  test_col_vals_between(
    columns = c,
    left = 1, right = 9,
    na_pass = TRUE
  )
#&gt; [1] TRUE
</pre></div>
<p>An additional note on the bounds for this function: they are inclusive by
default (i.e., values of exactly <code>1</code> and <code>9</code> will pass). We can modify the
inclusiveness of the upper and lower bounds with the <code>inclusive</code> option,
which is a length-2 logical vector.
</p>
<p>Testing with the upper bound being non-inclusive, we get <code>FALSE</code> since two
values are <code>9</code> and they now fall outside of the upper (or right) bound.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  test_col_vals_between(
    columns = c, left = 1, right = 9,
    inclusive = c(TRUE, FALSE),
    na_pass = TRUE
  )
#&gt; [1] FALSE
</pre></div>



<h3>Function ID</h3>

<p>2-7
</p>


<h3>See Also</h3>

<p>The analogue to this function: <code><a href="#topic+col_vals_not_between">col_vals_not_between()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_decreasing'>Are column data decreasing by row?</h2><span id='topic+col_vals_decreasing'></span><span id='topic+expect_col_vals_decreasing'></span><span id='topic+test_col_vals_decreasing'></span>

<h3>Description</h3>

<p>The <code>col_vals_decreasing()</code> validation function, the
<code>expect_col_vals_decreasing()</code> expectation function, and the
<code>test_col_vals_decreasing()</code> test function all check whether column values in
a table are decreasing when moving down a table. There are options for
allowing <code>NA</code> values in the target column, allowing stationary phases (where
consecutive values don't change), and even on for allowing increasing
movements up to a certain threshold. The validation function can be used
directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over the number of test units that is equal to the number of rows in the
table (after any <code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_decreasing(
  x,
  columns,
  allow_stationary = FALSE,
  increasing_tol = NULL,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_decreasing(
  object,
  columns,
  allow_stationary = FALSE,
  increasing_tol = NULL,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_decreasing(
  object,
  columns,
  allow_stationary = FALSE,
  increasing_tol = NULL,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_decreasing_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_allow_stationary">allow_stationary</code></td>
<td>
<p><em>Allowance for stationary pauses in values</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>An option to allow pauses in decreasing values. For example if the values
for the test units are <code style="white-space: pre;">&#8288;[85, 82, 82, 80, 77]&#8288;</code> then the third unit (<code>82</code>,
appearing a second time) would be marked with <em>fail</em> when
<code>allow_stationary</code> is <code>FALSE</code>. Using <code>allow_stationary = TRUE</code> will result
in all the test units in <code style="white-space: pre;">&#8288;[85, 82, 82, 80, 77]&#8288;</code> to be marked with <em>pass</em>.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_increasing_tol">increasing_tol</code></td>
<td>
<p><em>Optional tolerance threshold for backtracking</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;numeric&gt;(val&gt;=0)&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional threshold value that allows for movement of numerical values in
the positive direction. By default this is <code>NULL</code> but using a numerical
value with set the absolute threshold of positive travel allowed across
numerical test units. Note that setting a value here also has the effect of
setting <code>allow_stationary</code> to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_decreasing_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_decreasing()</code> is represented in YAML (under the top-level <code>steps</code>
key as a list member), the syntax closely follows the signature of the
validation function. Here is an example of how a complex call of
<code>col_vals_decreasing()</code> as a validation step is expressed in R code and in
the corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_decreasing(
    columns = a,
    allow_stationary = TRUE,
    increasing_tol = 0.5,
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_decreasing()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_decreasing:
    columns: c(a)
    allow_stationary: true
    increasing_tol: 0.5
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_decreasing()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>game_revenue</code> dataset in the package has the column <code>session_start</code>,
which contains date-time values. Let's create a column of difftime values (in
<code>time_left</code>) that describes the time remaining in the month relative to the
session start.
</p>
<div class="sourceCode r"><pre>game_revenue_2 &lt;-
  game_revenue %&gt;%
  dplyr::mutate(
    time_left = 
      lubridate::ymd_hms(
        "2015-02-01 00:00:00"
      ) - session_start
  )

game_revenue_2
#&gt; # A tibble: 2,000 x 12
#&gt;    player_id       session_id  session_start       time                item_type
#&gt;    &lt;chr&gt;           &lt;chr&gt;       &lt;dttm&gt;              &lt;dttm&gt;              &lt;chr&gt;    
#&gt;  1 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:31:27 iap      
#&gt;  2 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:36:57 iap      
#&gt;  3 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:37:45 iap      
#&gt;  4 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:42:33 ad       
#&gt;  5 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 11:55:20 ad       
#&gt;  6 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:08:56 ad       
#&gt;  7 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:14:08 ad       
#&gt;  8 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:21:44 ad       
#&gt;  9 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:24:20 ad       
#&gt; 10 FXWUORGYNJAE271 FXWUORGYNJ~ 2015-01-01 15:17:18 2015-01-01 15:19:36 ad       
#&gt; # i 1,990 more rows
#&gt; # i 7 more variables: item_name &lt;chr&gt;, item_revenue &lt;dbl&gt;,
#&gt; #   session_duration &lt;dbl&gt;, start_day &lt;date&gt;, acquisition &lt;chr&gt;, country &lt;chr&gt;,
#&gt; #   time_left &lt;drtn&gt;
</pre></div>
<p>Let's ensure that the <code>"difftime"</code> values in the new <code>time_left</code> column has
values that are decreasing from top to bottom.
</p>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that all <code>"difftime"</code> values in the column <code>time_left</code> are
decreasing, and, allow for repeating values (<code>allow_stationary</code> will be set
to <code>TRUE</code>).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = game_revenue_2) %&gt;%
  col_vals_decreasing(
    columns = time_left,
    allow_stationary = TRUE
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_decreasing_1.png" alt="This image was generated from the first code example in the `col_vals_decreasing()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>game_revenue_2 %&gt;%
  col_vals_decreasing(
    columns = time_left,
    allow_stationary = TRUE
  ) %&gt;%
  dplyr::select(time_left) %&gt;%
  dplyr::distinct() %&gt;%
  dplyr::count()
#&gt; # A tibble: 1 x 1
#&gt;       n
#&gt;   &lt;int&gt;
#&gt; 1   618
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_decreasing(
  game_revenue_2,
  columns = time_left,
  allow_stationary = TRUE
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>game_revenue_2 %&gt;%
  test_col_vals_decreasing(
    columns = time_left,
    allow_stationary = TRUE
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-14
</p>


<h3>See Also</h3>

<p>The analogous function that moves in the opposite direction:
<code><a href="#topic+col_vals_increasing">col_vals_increasing()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_equal'>Are column data equal to a fixed value or data in another column?</h2><span id='topic+col_vals_equal'></span><span id='topic+expect_col_vals_equal'></span><span id='topic+test_col_vals_equal'></span>

<h3>Description</h3>

<p>The <code>col_vals_equal()</code> validation function, the <code>expect_col_vals_equal()</code>
expectation function, and the <code>test_col_vals_equal()</code> test function all check
whether column values in a table are equal to a specified <code>value</code>. The
<code>value</code> can be specified as a single, literal value or as a column name given
in <code>vars()</code>. The validation function can be used directly on a data table or
with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. Each
validation step or expectation will operate over the number of test units
that is equal to the number of rows in the table (after any <code>preconditions</code>
have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_equal(
  x,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_equal(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_equal(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_equal_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_value">value</code></td>
<td>
<p><em>Value for comparison</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A value used for this test of equality. This can be a single value or a
compatible column given in <code>vars()</code>. Any column values equal to what is
specified here will pass validation.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_equal_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_equal()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_equal()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_equal(
    columns = a,
    value = 1,
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_equal()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_equal:
    columns: c(a)
    value: 1.0
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_equal()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>value</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all of the examples here, we'll use a simple table with three numeric
columns (<code>a</code>, <code>b</code>, and <code>c</code>) and three character columns (<code>d</code>, <code>e</code>, and <code>f</code>).
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 5, 5, 5, 5, 5),
    b = c(1, 1, 1, 2, 2, 2),
    c = c(1, 1, 1, 2, 2, 2),
    d = LETTERS[c(1:3, 5:7)],
    e = LETTERS[c(1:6)],
    f = LETTERS[c(1:6)]
  )
  
tbl
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 A     A     A    
#&gt; 2     5     1     1 B     B     B    
#&gt; 3     5     1     1 C     C     C    
#&gt; 4     5     2     2 E     D     D    
#&gt; 5     5     2     2 F     E     E    
#&gt; 6     5     2     2 G     F     F
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>a</code> are all equal to the value of <code>5</code>. We'll
determine if this validation has any failing test units (there are 6 test
units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_equal(columns = a, value = 5) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_equal_1.png" alt="This image was generated from the first code example in the `col_vals_equal()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  col_vals_equal(columns = a, value = 5) %&gt;%
  dplyr::pull(a)
#&gt; [1] 5 5 5 5 5 5
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_equal(tbl, columns = a, value = 5)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>test_col_vals_equal(tbl, columns = a, value = 5)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-3
</p>


<h3>See Also</h3>

<p>The analogue to this function: <code><a href="#topic+col_vals_not_equal">col_vals_not_equal()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_expr'>Do column data agree with a predicate expression?</h2><span id='topic+col_vals_expr'></span><span id='topic+expect_col_vals_expr'></span><span id='topic+test_col_vals_expr'></span>

<h3>Description</h3>

<p>The <code>col_vals_expr()</code> validation function, the <code>expect_col_vals_expr()</code>
expectation function, and the <code>test_col_vals_expr()</code> test function all check
whether column values in a table agree with a user-defined predicate
expression. The validation function can be used directly on a data table or
with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. Each
validation step or expectation will operate over the number of test units
that is equal to the number of rows in the table (after any <code>preconditions</code>
have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_expr(
  x,
  expr,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_expr(object, expr, preconditions = NULL, threshold = 1)

test_col_vals_expr(object, expr, preconditions = NULL, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_expr_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_expr">expr</code></td>
<td>
<p><em>Predicate expression</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;predicate expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A predicate expression to use for this validation. This can either be in
the form of a call made with the <code>expr()</code> function or as a one-sided <strong>R</strong>
formula (using a leading <code>~</code>).</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_expr_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_expr()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_expr()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_expr(
    expr = ~ a %% 1 == 0,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_expr()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_expr:
    expr: ~a%%1 == 0
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_expr()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>expr</code> argument
requires a value. Arguments with default values won't be written to YAML when
using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with their
default when generating the YAML by other means). It is also possible to
preview the transformation of an agent to YAML without any writing to disk by
using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all of the examples here, we'll use a simple table with three numeric
columns (<code>a</code>, <code>b</code>, and <code>c</code>) and three character columns (<code>d</code>, <code>e</code>, and <code>f</code>).
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(1, 2, 1, 7, 8, 6),
    b = c(0, 0, 0, 1, 1, 1),
    c = c(0.5, 0.3, 0.8, 1.4, 1.9, 1.2),
  )

tbl
#&gt; # A tibble: 6 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     1     0   0.5
#&gt; 2     2     0   0.3
#&gt; 3     1     0   0.8
#&gt; 4     7     1   1.4
#&gt; 5     8     1   1.9
#&gt; 6     6     1   1.2
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>a</code> are integer-like by using the R modulo
operator and expecting <code>0</code>. We'll determine if this validation has any
failing test units (there are 6 test units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_expr(expr = expr(a %% 1 == 0)) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_expr_1.png" alt="This image was generated from the first code example in the `col_vals_expr()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  col_vals_expr(expr = expr(a %% 1 == 0)) %&gt;%
  dplyr::pull(a)
#&gt; [1] 1 2 1 7 8 6
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_expr(tbl, expr = ~ a %% 1 == 0)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>test_col_vals_expr(tbl, expr = ~ a %% 1 == 0)
#&gt; [1] TRUE
</pre></div>



<h4>Variations</h4>

<p>We can do more complex things by taking advantage of the <code>case_when()</code> and
<code>between()</code> functions (available for use in the <strong>pointblank</strong> package).
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  test_col_vals_expr(expr = ~ case_when(
    b == 0 ~ a %&gt;% between(0, 5) &amp; c &lt; 1,
    b == 1 ~ a &gt; 5 &amp; c &gt;= 1
  ))
#&gt; [1] TRUE
</pre></div>
<p>If you only want to test a subset of rows, then the <code>case_when()</code> statement
doesn't need to be exhaustive. Any rows that don't fall into the cases will
be pruned (giving us less test units overall).
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  test_col_vals_expr(expr = ~ case_when(
    b == 1 ~ a &gt; 5 &amp; c &gt;= 1
  ))
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-19
</p>


<h3>See Also</h3>

<p>These reexported functions (from <strong>rlang</strong> and <strong>dplyr</strong>) work
nicely within <code>col_vals_expr()</code> and its variants: <code><a href="rlang.html#topic+expr">rlang::expr()</a></code>,
<code><a href="dplyr.html#topic+between">dplyr::between()</a></code>, and <code><a href="dplyr.html#topic+case_when">dplyr::case_when()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_gt'>Are column data greater than a fixed value or data in another column?</h2><span id='topic+col_vals_gt'></span><span id='topic+expect_col_vals_gt'></span><span id='topic+test_col_vals_gt'></span>

<h3>Description</h3>

<p>The <code>col_vals_gt()</code> validation function, the <code>expect_col_vals_gt()</code>
expectation function, and the <code>test_col_vals_gt()</code> test function all check
whether column values in a table are <em>greater than</em> a specified <code>value</code> (the
exact comparison used in this function is <code>col_val &gt; value</code>). The <code>value</code> can
be specified as a single, literal value or as a column name given in
<code>vars()</code>. The validation function can be used directly on a data table or
with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. Each
validation step or expectation will operate over the number of test units
that is equal to the number of rows in the table (after any <code>preconditions</code>
have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_gt(
  x,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_gt(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_gt(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_gt_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_value">value</code></td>
<td>
<p><em>Value for comparison</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A value used for this comparison. This can be a single value or a
compatible column given in <code>vars()</code>. Any column values greater than what is
specified here will pass validation.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_gt_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an <em>agent</em>
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_gt()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_gt()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_gt(
    columns = a,
    value = 1,
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_gt()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_gt:
    columns: c(a)
    value: 1.0
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_gt()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>value</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all of the examples here, we'll use a simple table with three numeric
columns (<code>a</code>, <code>b</code>, and <code>c</code>) and three character columns (<code>d</code>, <code>e</code>, and <code>f</code>).
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 5, 5, 5, 5, 5),
    b = c(1, 1, 1, 2, 2, 2),
    c = c(1, 1, 1, 2, 3, 4),
    d = LETTERS[a],
    e = LETTERS[b],
    f = LETTERS[c]
  )
  
tbl
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 E     A     A    
#&gt; 2     5     1     1 E     A     A    
#&gt; 3     5     1     1 E     A     A    
#&gt; 4     5     2     2 E     B     B    
#&gt; 5     5     2     3 E     B     C    
#&gt; 6     5     2     4 E     B     D
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>a</code> are all greater than the value of <code>4</code>.
We'll determine if this validation had any failing test units (there are 6
test units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_gt(columns = a, value = 4) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_gt_1.png" alt="This image was generated from the first code example in the `col_vals_gt()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% col_vals_gt(columns = a, value = 4)
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 E     A     A    
#&gt; 2     5     1     1 E     A     A    
#&gt; 3     5     1     1 E     A     A    
#&gt; 4     5     2     2 E     B     B    
#&gt; 5     5     2     3 E     B     C    
#&gt; 6     5     2     4 E     B     D
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_gt(tbl, columns = a, value = 4)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>test_col_vals_gt(tbl, columns = a, value = 4)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-6
</p>


<h3>See Also</h3>

<p>The analogous function with a left-closed bound: <code><a href="#topic+col_vals_gte">col_vals_gte()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_gte'>Are column data greater than or equal to a fixed value or data in another
column?</h2><span id='topic+col_vals_gte'></span><span id='topic+expect_col_vals_gte'></span><span id='topic+test_col_vals_gte'></span>

<h3>Description</h3>

<p>The <code>col_vals_gte()</code> validation function, the <code>expect_col_vals_gte()</code>
expectation function, and the <code>test_col_vals_gte()</code> test function all check
whether column values in a table are <em>greater than or equal to</em> a specified
<code>value</code> (the exact comparison used in this function is <code>col_val &gt;= value</code>).
The <code>value</code> can be specified as a single, literal value or as a column name
given in <code>vars()</code>. The validation function can be used directly on a data
table or with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object)
whereas the expectation and test functions can only be used with a data
table. Each validation step or expectation will operate over the number of
test units that is equal to the number of rows in the table (after any
<code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_gte(
  x,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_gte(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_gte(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_gte_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_value">value</code></td>
<td>
<p><em>Value for comparison</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A value used for this comparison. This can be a single value or a
compatible column given in <code>vars()</code>. Any column values greater than or
equal to what is specified here will pass validation.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_gte_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using <code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good choices depending on the
situation (the first produces a warning when a quarter of the total test
units fails, the other <code>stop()</code>s at the same threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_gte()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_gte()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_gte(
    columns = a,
    value = 1,
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_gte()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_gte:
    columns: c(a)
    value: 1.0
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_gte()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>value</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all of the examples here, we'll use a simple table with three numeric
columns (<code>a</code>, <code>b</code>, and <code>c</code>) and three character columns (<code>d</code>, <code>e</code>, and <code>f</code>).
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
      a = c(5, 5, 5, 5, 5, 5),
      b = c(1, 1, 1, 2, 2, 2),
      c = c(1, 1, 1, 2, 3, 4),
      d = LETTERS[a],
      e = LETTERS[b],
      f = LETTERS[c]
  )
  
tbl
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 E     A     A    
#&gt; 2     5     1     1 E     A     A    
#&gt; 3     5     1     1 E     A     A    
#&gt; 4     5     2     2 E     B     B    
#&gt; 5     5     2     3 E     B     C    
#&gt; 6     5     2     4 E     B     D
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>a</code> are all greater than or equal to the value
of <code>5</code>. We'll determine if this validation has any failing test units (there
are 6 test units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_gte(columns = a, value = 5) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_gte_1.png" alt="This image was generated from the first code example in the `col_vals_gte()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% col_vals_gte(columns = a, value = 5)
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 E     A     A    
#&gt; 2     5     1     1 E     A     A    
#&gt; 3     5     1     1 E     A     A    
#&gt; 4     5     2     2 E     B     B    
#&gt; 5     5     2     3 E     B     C    
#&gt; 6     5     2     4 E     B     D
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_gte(tbl, columns = a, value = 5)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>test_col_vals_gte(tbl, columns = a, value = 5)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-5
</p>


<h3>See Also</h3>

<p>The analogous function with a left-open bound: <code><a href="#topic+col_vals_gt">col_vals_gt()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_in_set'>Are column data part of a specified set of values?</h2><span id='topic+col_vals_in_set'></span><span id='topic+expect_col_vals_in_set'></span><span id='topic+test_col_vals_in_set'></span>

<h3>Description</h3>

<p>The <code>col_vals_in_set()</code> validation function, the <code>expect_col_vals_in_set()</code>
expectation function, and the <code>test_col_vals_in_set()</code> test function all
check whether column values in a table are part of a specified <code>set</code> of
values. The validation function can be used directly on a data table or with
an <em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. Each
validation step or expectation will operate over the number of test units
that is equal to the number of rows in the table (after any <code>preconditions</code>
have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_in_set(
  x,
  columns,
  set,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_in_set(
  object,
  columns,
  set,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_in_set(object, columns, set, preconditions = NULL, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_in_set_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_set">set</code></td>
<td>
<p><em>Set of values</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;integer|numeric|character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A vector of numeric or string-based elements, where column values found
within this <code>set</code> will be considered as passing.</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_in_set_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_in_set()</code> is represented in YAML (under the top-level <code>steps</code> key
as a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_in_set()</code> as
a validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_in_set(
    columns = a,
    set = c(1, 2, 3, 4),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_in_set()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_in_set:
   columns: c(a)
   set:
   - 1.0
   - 2.0
   - 3.0
   - 4.0
   preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
   segments: b ~ c("group_1", "group_2")
   actions:
     warn_fraction: 0.1
     stop_fraction: 0.2
   label: The `col_vals_in_set()` step.
   active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>set</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package will be used to validate that column
values are part of a given set.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>f</code> are all part of the set of values
containing <code>low</code>, <code>mid</code>, and <code>high</code>. We'll determine if this validation has
any failing test units (there are 13 test units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_vals_in_set(
    columns = f, set = c("low", "mid", "high")
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_in_set_1.png" alt="This image was generated from the first code example in the `col_vals_in_set()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_in_set(
    columns = f, set = c("low", "mid", "high")
  ) %&gt;%
  dplyr::pull(f) %&gt;%
  unique()
#&gt; [1] "high" "low"  "mid"
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_in_set(
  small_table,
  columns = f, set = c("low", "mid", "high")
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  test_col_vals_in_set(
    columns = f, set = c("low", "mid", "high")
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-9
</p>


<h3>See Also</h3>

<p>The analogue to this function: <code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_increasing'>Are column data increasing by row?</h2><span id='topic+col_vals_increasing'></span><span id='topic+expect_col_vals_increasing'></span><span id='topic+test_col_vals_increasing'></span>

<h3>Description</h3>

<p>The <code>col_vals_increasing()</code> validation function, the
<code>expect_col_vals_increasing()</code> expectation function, and the
<code>test_col_vals_increasing()</code> test function all check whether column values in
a table are increasing when moving down a table. There are options for
allowing <code>NA</code> values in the target column, allowing stationary phases (where
consecutive values don't change), and even on for allowing decreasing
movements up to a certain threshold. The validation function can be used
directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over the number of test units that is equal to the number of rows in the
table (after any <code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_increasing(
  x,
  columns,
  allow_stationary = FALSE,
  decreasing_tol = NULL,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_increasing(
  object,
  columns,
  allow_stationary = FALSE,
  decreasing_tol = NULL,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_increasing(
  object,
  columns,
  allow_stationary = FALSE,
  decreasing_tol = NULL,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_increasing_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_allow_stationary">allow_stationary</code></td>
<td>
<p><em>Allowance for stationary pauses in values</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>An option to allow pauses in decreasing values. For example if the values
for the test units are <code style="white-space: pre;">&#8288;[80, 82, 82, 85, 88]&#8288;</code> then the third unit (<code>82</code>,
appearing a second time) would be marked with <em>fail</em> when
<code>allow_stationary</code> is <code>FALSE</code>. Using <code>allow_stationary = TRUE</code> will result
in all the test units in <code style="white-space: pre;">&#8288;[80, 82, 82, 85, 88]&#8288;</code> to be marked with <em>pass</em>.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_decreasing_tol">decreasing_tol</code></td>
<td>
<p><em>Optional tolerance threshold for backtracking</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;numeric&gt;(val&gt;=0)&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional threshold value that allows for movement of numerical values in
the negative direction. By default this is <code>NULL</code> but using a numerical
value with set the absolute threshold of negative travel allowed across
numerical test units. Note that setting a value here also has the effect of
setting <code>allow_stationary</code> to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_increasing_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_increasing()</code> is represented in YAML (under the top-level <code>steps</code>
key as a list member), the syntax closely follows the signature of the
validation function. Here is an example of how a complex call of
<code>col_vals_increasing()</code> as a validation step is expressed in R code and in
the corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_increasing(
    columns = a,
    allow_stationary = TRUE,
    decreasing_tol = 0.5,
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_increasing()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_increasing:
    columns: c(a)
    allow_stationary: true
    decreasing_tol: 0.5
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_increasing()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>game_revenue</code> dataset in the package has the column <code>session_start</code>,
which contains date-time values. Let's ensure that this column has values
that are increasing from top to bottom.
</p>
<div class="sourceCode r"><pre>game_revenue
#&gt; # A tibble: 2,000 x 11
#&gt;    player_id       session_id  session_start       time                item_type
#&gt;    &lt;chr&gt;           &lt;chr&gt;       &lt;dttm&gt;              &lt;dttm&gt;              &lt;chr&gt;    
#&gt;  1 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:31:27 iap      
#&gt;  2 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:36:57 iap      
#&gt;  3 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:37:45 iap      
#&gt;  4 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:42:33 ad       
#&gt;  5 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 11:55:20 ad       
#&gt;  6 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:08:56 ad       
#&gt;  7 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:14:08 ad       
#&gt;  8 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:21:44 ad       
#&gt;  9 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:24:20 ad       
#&gt; 10 FXWUORGYNJAE271 FXWUORGYNJ~ 2015-01-01 15:17:18 2015-01-01 15:19:36 ad       
#&gt; # i 1,990 more rows
#&gt; # i 6 more variables: item_name &lt;chr&gt;, item_revenue &lt;dbl&gt;,
#&gt; #   session_duration &lt;dbl&gt;, start_day &lt;date&gt;, acquisition &lt;chr&gt;, country &lt;chr&gt;
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that all date-time values in the column <code>session_start</code> are
increasing, and, allow for repeating values (<code>allow_stationary</code> will be set
to <code>TRUE</code>). We'll determine if this validation has any failing test units
(there are 2000 test units).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = game_revenue) %&gt;%
  col_vals_increasing(
    columns = session_start,
    allow_stationary = TRUE
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_increasing_1.png" alt="This image was generated from the first code example in the `col_vals_increasing()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>game_revenue %&gt;%
  col_vals_increasing(
    columns = session_start,
    allow_stationary = TRUE
  ) %&gt;%
  dplyr::select(session_start) %&gt;%
  dplyr::distinct() %&gt;%
  dplyr::count()
#&gt; # A tibble: 1 x 1
#&gt;       n
#&gt;   &lt;int&gt;
#&gt; 1   618
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_increasing(
  game_revenue,
  columns = session_start,
  allow_stationary = TRUE
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>game_revenue %&gt;%
  test_col_vals_increasing(
    columns = session_start,
    allow_stationary = TRUE
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-13
</p>


<h3>See Also</h3>

<p>The analogous function that moves in the opposite direction:
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_lt'>Are column data less than a fixed value or data in another column?</h2><span id='topic+col_vals_lt'></span><span id='topic+expect_col_vals_lt'></span><span id='topic+test_col_vals_lt'></span>

<h3>Description</h3>

<p>The <code>col_vals_lt()</code> validation function, the <code>expect_col_vals_lt()</code>
expectation function, and the <code>test_col_vals_lt()</code> test function all check
whether column values in a table are <em>less than</em> a specified <code>value</code> (the
exact comparison used in this function is <code>col_val &lt; value</code>). The <code>value</code> can
be specified as a single, literal value or as a column name given in
<code>vars()</code>. The validation function can be used directly on a data table or
with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. Each
validation step or expectation will operate over the number of test units
that is equal to the number of rows in the table (after any <code>preconditions</code>
have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_lt(
  x,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_lt(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_lt(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_lt_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_value">value</code></td>
<td>
<p><em>Value for comparison</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A value used for this comparison. This can be a single value or a
compatible column given in <code>vars()</code>. Any column values less than what is
specified here will pass validation.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_lt_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_lt()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_lt()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_lt(
    columns = a,
    value = 1,
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_lt()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_lt:
    columns: c(a)
    value: 1.0
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_lt()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>value</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all of the examples here, we'll use a simple table with three numeric
columns (<code>a</code>, <code>b</code>, and <code>c</code>) and three character columns (<code>d</code>, <code>e</code>, and <code>f</code>).
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
      a = c(5, 5, 5, 5, 5, 5),
      b = c(1, 1, 1, 2, 2, 2),
      c = c(1, 1, 1, 2, 3, 4),
      d = LETTERS[a],
      e = LETTERS[b],
      f = LETTERS[c]
  )
  
tbl
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 E     A     A    
#&gt; 2     5     1     1 E     A     A    
#&gt; 3     5     1     1 E     A     A    
#&gt; 4     5     2     2 E     B     B    
#&gt; 5     5     2     3 E     B     C    
#&gt; 6     5     2     4 E     B     D
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>c</code> are all less than the value of <code>5</code>. We'll
determine if this validation has any failing test units (there are 6 test
units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_lt(columns = c, value = 5) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_lt_1.png" alt="This image was generated from the first code example in the `col_vals_lt()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  col_vals_lt(columns = c, value = 5) %&gt;%
  dplyr::pull(c)
#&gt; [1] 1 1 1 2 3 4
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_lt(tbl, columns = c, value = 5)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>test_col_vals_lt(tbl, columns = c, value = 5)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-1
</p>


<h3>See Also</h3>

<p>The analogous function with a right-closed bound: <code><a href="#topic+col_vals_lte">col_vals_lte()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_lte'>Are column data less than or equal to a fixed value or data in another
column?</h2><span id='topic+col_vals_lte'></span><span id='topic+expect_col_vals_lte'></span><span id='topic+test_col_vals_lte'></span>

<h3>Description</h3>

<p>The <code>col_vals_lte()</code> validation function, the <code>expect_col_vals_lte()</code>
expectation function, and the <code>test_col_vals_lte()</code> test function all check
whether column values in a table are <em>less than or equal to</em> a specified
<code>value</code> (the exact comparison used in this function is <code>col_val &lt;= value</code>).
The <code>value</code> can be specified as a single, literal value or as a column name
given in <code>vars()</code>. The validation function can be used directly on a data
table or with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object)
whereas the expectation and test functions can only be used with a data
table. Each validation step or expectation will operate over the number of
test units that is equal to the number of rows in the table (after any
<code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_lte(
  x,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_lte(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_lte(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_lte_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_value">value</code></td>
<td>
<p><em>Value for comparison</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A value used for this comparison. This can be a single value or a
compatible column given in <code>vars()</code>. Any column values less than or equal
to what is specified here will pass validation.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_lte_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_lte()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_lte()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_lte(
    columns = a,
    value = 1,
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_lte()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_lte:
    columns: c(a)
    value: 1.0
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_lte()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>value</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all of the examples here, we'll use a simple table with three numeric
columns (<code>a</code>, <code>b</code>, and <code>c</code>) and three character columns (<code>d</code>, <code>e</code>, and <code>f</code>).
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
      a = c(5, 5, 5, 5, 5, 5),
      b = c(1, 1, 1, 2, 2, 2),
      c = c(1, 1, 1, 2, 3, 4),
      d = LETTERS[a],
      e = LETTERS[b],
      f = LETTERS[c]
  )

tbl
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 E     A     A    
#&gt; 2     5     1     1 E     A     A    
#&gt; 3     5     1     1 E     A     A    
#&gt; 4     5     2     2 E     B     B    
#&gt; 5     5     2     3 E     B     C    
#&gt; 6     5     2     4 E     B     D
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>c</code> are all less than or equal to the value of
<code>4</code>. We'll determine if this validation has any failing test units (there are
6 test units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_lte(columns = c, value = 4) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_lte_1.png" alt="This image was generated from the first code example in the `col_vals_lte()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  col_vals_lte(columns = c, value = 4) %&gt;%
  dplyr::pull(c)
#&gt; [1] 1 1 1 2 3 4
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_lte(tbl, columns = c, value = 4)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>test_col_vals_lte(tbl, columns = c, value = 4)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-2
</p>


<h3>See Also</h3>

<p>The analogous function with a right-open bound: <code><a href="#topic+col_vals_lt">col_vals_lt()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_make_set'>Is a set of values entirely accounted for in a column of values?</h2><span id='topic+col_vals_make_set'></span><span id='topic+expect_col_vals_make_set'></span><span id='topic+test_col_vals_make_set'></span>

<h3>Description</h3>

<p>The <code>col_vals_make_set()</code> validation function, the
<code>expect_col_vals_make_set()</code> expectation function, and the
<code>test_col_vals_make_set()</code> test function all check whether <code>set</code> values are
all seen at least once in a table column. A necessary criterion here is that
no <em>additional</em> values (outside those definied in the <code>set</code>) should be seen
(this requirement is relaxed in the <code><a href="#topic+col_vals_make_subset">col_vals_make_subset()</a></code> validation
function and in its expectation and test variants). The validation function
can be used directly on a data table or with an <em>agent</em> object (technically,
a <code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over the number of test units that is equal to the number of elements in the
<code>set</code> plus a test unit reserved for detecting column values outside of the
<code>set</code> (any outside value seen will make this additional test unit fail).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_make_set(
  x,
  columns,
  set,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_make_set(
  object,
  columns,
  set,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_make_set(
  object,
  columns,
  set,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_make_set_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_set">set</code></td>
<td>
<p><em>Set of values</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;integer|numeric|character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A vector of elements that is expected to be equal to the set of unique
values in the target column.</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_make_set_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_make_set()</code> is represented in YAML (under the top-level <code>steps</code> key
as a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_make_set()</code>
as a validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_make_set(
    columns = a,
    set = c(1, 2, 3, 4),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_make_set()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_make_set:
   columns: c(a)
   set:
   - 1.0
   - 2.0
   - 3.0
   - 4.0
   preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
   segments: b ~ c("group_1", "group_2")
   actions:
     warn_fraction: 0.1
     stop_fraction: 0.2
   label: The `col_vals_make_set()` step.
   active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>set</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package will be used to validate that column
values are part of a given set.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>f</code> comprise the values of <code>low</code>, <code>mid</code>, and
<code>high</code>, and, no other values. We'll determine if this validation has any
failing test units (there are 4 test units).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_vals_make_set(
    columns = f, set = c("low", "mid", "high")
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_make_set_1.png" alt="This image was generated from the first code example in the `col_vals_make_set()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_make_set(
    columns = f, set = c("low", "mid", "high")
  ) %&gt;%
  dplyr::pull(f) %&gt;%
  unique()
#&gt; [1] "high" "low"  "mid"
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_make_set(
  small_table,
  columns = f, set = c("low", "mid", "high")
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  test_col_vals_make_set(
    columns = f, set = c("low", "mid", "high")
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-11
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_make_subset'>Is a set of values a subset of a column of values?</h2><span id='topic+col_vals_make_subset'></span><span id='topic+expect_col_vals_make_subset'></span><span id='topic+test_col_vals_make_subset'></span>

<h3>Description</h3>

<p>The <code>col_vals_make_subset()</code> validation function, the
<code>expect_col_vals_make_subset()</code> expectation function, and the
<code>test_col_vals_make_subset()</code> test function all check whether all <code>set</code>
values are seen at least once in a table column. The validation function can
be used directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over the number of test units that is equal to the number of elements in the
<code>set</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_make_subset(
  x,
  columns,
  set,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_make_subset(
  object,
  columns,
  set,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_make_subset(
  object,
  columns,
  set,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_make_subset_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_set">set</code></td>
<td>
<p><em>Set of values</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;integer|numeric|character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A vector of elements that is expected to be a subset of the unique values
in the target column.</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_make_subset_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_make_subset()</code> is represented in YAML (under the top-level <code>steps</code>
key as a list member), the syntax closely follows the signature of the
validation function. Here is an example of how a complex call of
<code>col_vals_make_subset()</code> as a validation step is expressed in R code and in
the corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_make_subset(
    columns = a,
    set = c(1, 2, 3, 4),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_make_subset()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_make_subset:
   columns: c(a)
   set:
   - 1.0
   - 2.0
   - 3.0
   - 4.0
   preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
   segments: b ~ c("group_1", "group_2")
   actions:
     warn_fraction: 0.1
     stop_fraction: 0.2
   label: The `col_vals_make_subset()` step.
   active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>set</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package will be used to validate that column
values are part of a given set.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the distinct set of values in column <code>f</code> contains at least the
subset defined as <code>low</code> and <code>high</code> (the column actually has both of those and
some <code>mid</code> values). We'll determine if this validation has any failing test
units (there are 2 test units, one per element in the <code>set</code>).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_vals_make_subset(
    columns = f, set = c("low", "high")
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_make_subset_1.png" alt="This image was generated from the first code example in the `col_vals_make_subset()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_make_subset(
    columns = f, set = c("low", "high")
  ) %&gt;%
  dplyr::pull(f) %&gt;%
  unique()
#&gt; [1] "high" "low"  "mid"
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_make_subset(
  small_table,
  columns = f, set = c("low", "high")
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  test_col_vals_make_subset(
    columns = f, set = c("low", "high")
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-12
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_not_between'>Do column data lie outside of two specified values or data in other columns?</h2><span id='topic+col_vals_not_between'></span><span id='topic+expect_col_vals_not_between'></span><span id='topic+test_col_vals_not_between'></span>

<h3>Description</h3>

<p>The <code>col_vals_not_between()</code> validation function, the
<code>expect_col_vals_not_between()</code> expectation function, and the
<code>test_col_vals_not_between()</code> test function all check whether column values
in a table <em>do not</em> fall within a range. The range specified with three
arguments: <code>left</code>, <code>right</code>, and <code>inclusive</code>. The <code>left</code> and <code>right</code> values
specify the lower and upper bounds. The bounds can be specified as single,
literal values or as column names given in <code>vars()</code>. The <code>inclusive</code>
argument, as a vector of two logical values relating to <code>left</code> and <code>right</code>,
states whether each bound is inclusive or not. The default is <code>c(TRUE, TRUE)</code>, where both endpoints are inclusive (i.e., <code style="white-space: pre;">&#8288;[left, right]&#8288;</code>). For
partially-unbounded versions of this function, we can use the
<code><a href="#topic+col_vals_lt">col_vals_lt()</a></code>, <code><a href="#topic+col_vals_lte">col_vals_lte()</a></code>, <code><a href="#topic+col_vals_gt">col_vals_gt()</a></code>, or <code><a href="#topic+col_vals_gte">col_vals_gte()</a></code>
validation functions. The validation function can be used directly on a data
table or with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object)
whereas the expectation and test functions can only be used with a data
table. Each validation step or expectation will operate over the number of
test units that is equal to the number of rows in the table (after any
<code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_not_between(
  x,
  columns,
  left,
  right,
  inclusive = c(TRUE, TRUE),
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_not_between(
  object,
  columns,
  left,
  right,
  inclusive = c(TRUE, TRUE),
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_not_between(
  object,
  columns,
  left,
  right,
  inclusive = c(TRUE, TRUE),
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_not_between_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_left">left</code></td>
<td>
<p><em>Definition of left bound</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The lower bound for the range. The validation includes this bound
value (if the first element in <code>inclusive</code> is <code>TRUE</code>) in addition to values
greater than <code>left</code>. This can be a single value or a compatible column
given in <code>vars()</code>.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_right">right</code></td>
<td>
<p><em>Definition of right bound</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The upper bound for the range. The validation includes this
bound value (if the second element in <code>inclusive</code> is <code>TRUE</code>) in addition to
values lower than <code>right</code>. This can be a single value or a compatible
column given in <code>vars()</code>.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_inclusive">inclusive</code></td>
<td>
<p><em>Inclusiveness of bounds</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>c(TRUE, TRUE)</code>
</p>
<p>A two-element logical value that indicates whether the <code>left</code> and <code>right</code>
bounds should be inclusive. By default, both bounds are inclusive.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_not_between_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_not_between()</code> is represented in YAML (under the top-level <code>steps</code>
key as a list member), the syntax closely follows the signature of the
validation function. Here is an example of how a complex call of
<code>col_vals_not_between()</code> as a validation step is expressed in R code and in
the corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_not_between(
    columns = a,
    left = 1,
    right = 2,
    inclusive = c(TRUE, FALSE),
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_not_between()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_not_between:
    columns: c(a)
    left: 1.0
    right: 2.0
    inclusive:
    - true
    - false
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_not_between()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>,
<code>left</code>, and <code>right</code> arguments require values. Arguments with default values
won't be written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable
to include them with their default when generating the YAML by other means).
It is also possible to preview the transformation of an agent to YAML without
any writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package has a column of numeric values in
<code>c</code> (there are a few <code>NA</code>s in that column). The following examples will
validate the values in that numeric column.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>c</code> are all between <code>10</code> and <code>20</code>. Because
there are <code>NA</code> values, we'll choose to let those pass validation by setting
<code>na_pass = TRUE</code>. We'll determine if this validation has any failing test
units (there are 13 test units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_vals_not_between(
    columns = c,
    left = 10, right = 20,
    na_pass = TRUE
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_not_between_1.png" alt="This image was generated from the first code example in the `col_vals_not_between()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_not_between(
    columns = c,
    left = 10, right = 20,
    na_pass = TRUE
  ) %&gt;%
  dplyr::pull(c)
#&gt;  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_not_between(
  small_table, columns = c,
  left = 10, right = 20,
  na_pass = TRUE
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  test_col_vals_not_between(
    columns = c,
    left = 10, right = 20,
    na_pass = TRUE
  )
#&gt; [1] TRUE
</pre></div>
<p>An additional note on the bounds for this function: they are inclusive by
default. We can modify the inclusiveness of the upper and lower bounds with
the <code>inclusive</code> option, which is a length-2 logical vector.
</p>
<p>In changing the lower bound to be <code>9</code> and making it non-inclusive, we get
<code>TRUE</code> since although two values are <code>9</code> and they fall outside of the lower
(or left) bound (and any values 'not between' count as passing test units).
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  test_col_vals_not_between(
    columns = c,
    left = 9, right = 20,
    inclusive = c(FALSE, TRUE),
    na_pass = TRUE
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-8
</p>


<h3>See Also</h3>

<p>The analogue to this function: <code><a href="#topic+col_vals_between">col_vals_between()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_not_equal'>Are column data not equal to a fixed value or data in another column?</h2><span id='topic+col_vals_not_equal'></span><span id='topic+expect_col_vals_not_equal'></span><span id='topic+test_col_vals_not_equal'></span>

<h3>Description</h3>

<p>The <code>col_vals_not_equal()</code> validation function, the
<code>expect_col_vals_not_equal()</code> expectation function, and the
<code>test_col_vals_not_equal()</code> test function all check whether column values in
a table <em>are not</em> equal to a specified <code>value</code>. The validation function can
be used directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over the number of test units that is equal to the number of rows in the
table (after any <code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_not_equal(
  x,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_not_equal(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_not_equal(
  object,
  columns,
  value,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_not_equal_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_value">value</code></td>
<td>
<p><em>Value for comparison</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;value expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A value used for this test of inequality. This can be a single value or a
compatible column given in <code>vars()</code>. Any column values not equal to what is
specified here will pass validation.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_not_equal_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_not_equal()</code> is represented in YAML (under the top-level <code>steps</code>
key as a list member), the syntax closely follows the signature of the
validation function. Here is an example of how a complex call of
<code>col_vals_not_equal()</code> as a validation step is expressed in R code and in the
corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_not_equal(
    columns = a,
    value = 1,
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_not_equal()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_not_equal:
    columns: c(a)
    value: 1.0
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_not_equal()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>value</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all of the examples here, we'll use a simple table with three numeric
columns (<code>a</code>, <code>b</code>, and <code>c</code>) and three character columns (<code>d</code>, <code>e</code>, and <code>f</code>).
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 5, 5, 5, 5, 5),
    b = c(1, 1, 1, 2, 2, 2),
    c = c(1, 1, 1, 2, 2, 2),
    d = LETTERS[c(1:3, 5:7)],
    e = LETTERS[c(1:6)],
    f = LETTERS[c(1:6)]
  )

tbl
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 A     A     A    
#&gt; 2     5     1     1 B     B     B    
#&gt; 3     5     1     1 C     C     C    
#&gt; 4     5     2     2 E     D     D    
#&gt; 5     5     2     2 F     E     E    
#&gt; 6     5     2     2 G     F     F
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>a</code> are all <em>not</em> equal to the value of <code>6</code>.
We'll determine if this validation has any failing test units (there are 6
test units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_not_equal(columns = a, value = 6) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_not_equal_1.png" alt="This image was generated from the first code example in the `col_vals_not_equal()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  col_vals_not_equal(columns = a, value = 6) %&gt;%
  dplyr::pull(a)
#&gt; [1] 5 5 5 5 5 5
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_not_equal(tbl, columns = a, value = 6)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>test_col_vals_not_equal(tbl, columns = a, value = 6)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-4
</p>


<h3>See Also</h3>

<p>The analogue to this function: <code><a href="#topic+col_vals_equal">col_vals_equal()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_not_in_set'>Are data not part of a specified set of values?</h2><span id='topic+col_vals_not_in_set'></span><span id='topic+expect_col_vals_not_in_set'></span><span id='topic+test_col_vals_not_in_set'></span>

<h3>Description</h3>

<p>The <code>col_vals_not_in_set()</code> validation function, the
<code>expect_col_vals_not_in_set()</code> expectation function, and the
<code>test_col_vals_not_in_set()</code> test function all check whether column values in
a table <em>are not part</em> of a specified <code>set</code> of values. The validation
function can be used directly on a data table or with an <em>agent</em> object
(technically, a <code>ptblank_agent</code> object) whereas the expectation and test
functions can only be used with a data table. Each validation step or
expectation will operate over the number of test units that is equal to the
number of rows in the table (after any <code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_not_in_set(
  x,
  columns,
  set,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_not_in_set(
  object,
  columns,
  set,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_not_in_set(
  object,
  columns,
  set,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_not_in_set_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_set">set</code></td>
<td>
<p><em>Set of values</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;integer|numeric|character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A vector of numeric or string-based elements, where column values found
within this <code>set</code> will be considered as failing.</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_not_in_set_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_not_in_set()</code> is represented in YAML (under the top-level <code>steps</code>
key as a list member), the syntax closely follows the signature of the
validation function. Here is an example of how a complex call of
<code>col_vals_not_in_set()</code> as a validation step is expressed in R code and in
the corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_not_in_set(
    columns = a,
    set = c(1, 2, 3, 4),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_not_in_set()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_not_in_set:
   columns: c(a)
   set:
   - 1.0
   - 2.0
   - 3.0
   - 4.0
   preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
   segments: b ~ c("group_1", "group_2")
   actions:
     warn_fraction: 0.1
     stop_fraction: 0.2
   label: The `col_vals_not_in_set()` step.
   active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>set</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package will be used to validate that column
values are not part of a given set.
</p>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that values in column <code>f</code> contain none of the values <code>lows</code>, <code>mids</code>,
and <code>highs</code>. We'll determine if this validation has any failing test units
(there are 13 test units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_vals_not_in_set(
    columns = f, set = c("lows", "mids", "highs")
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_not_in_set_1.png" alt="This image was generated from the first code example in the `col_vals_not_in_set()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode"><pre>small_table %&gt;%
  col_vals_not_in_set(
    columns = f, set = c("lows", "mids", "highs")
  ) %&gt;%
  dplyr::pull(f) %&gt;%
  unique()
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_not_in_set(
  small_table,
  columns = f, set = c("lows", "mids", "highs")
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  test_col_vals_not_in_set(
    columns = f, set = c("lows", "mids", "highs")
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-10
</p>


<h3>See Also</h3>

<p>The analogue to this function: <code><a href="#topic+col_vals_in_set">col_vals_in_set()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_not_null'>Are column data not <code>NULL</code>/<code>NA</code>?</h2><span id='topic+col_vals_not_null'></span><span id='topic+expect_col_vals_not_null'></span><span id='topic+test_col_vals_not_null'></span>

<h3>Description</h3>

<p>The <code>col_vals_not_null()</code> validation function, the
<code>expect_col_vals_not_null()</code> expectation function, and the
<code>test_col_vals_not_null()</code> test function all check whether column values in a
table <em>are not</em> <code>NA</code> values or, in the database context, <em>not</em> <code>NULL</code> values.
The validation function can be used directly on a data table or with an
<em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. Each
validation step or expectation will operate over the number of test units
that is equal to the number of rows in the table (after any <code>preconditions</code>
have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_not_null(
  x,
  columns,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)

test_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_not_null_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_not_null_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_not_null()</code> is represented in YAML (under the top-level <code>steps</code> key
as a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_not_null()</code>
as a validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_not_null(
    columns = a,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_not_null()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_not_null:
    columns: c(a)
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_not_null()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all examples here, we'll use a simple table with four columns: <code>a</code>, <code>b</code>,
<code>c</code>, and <code>d</code>.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c( 5,  7,  6,  5,  8),
    b = c( 7,  1,  0,  0,  0),
    c = c(NA, NA, NA, NA, NA),
    d = c(35, 23, NA, NA, NA)
  )
  
tbl
#&gt; # A tibble: 5 x 4
#&gt;       a     b c         d
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt;
#&gt; 1     5     7 NA       35
#&gt; 2     7     1 NA       23
#&gt; 3     6     0 NA       NA
#&gt; 4     5     0 NA       NA
#&gt; 5     8     0 NA       NA
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that all values in column <code>b</code> are <em>not</em> NA (they would be non-<code>NULL</code>
in a database context, which isn't the case here). We'll determine if this
validation has any failing test units (there are 5 test units, one for each
row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_not_null(columns = b) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_not_null_1.png" alt="This image was generated from the first code example in the `col_vals_not_null()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  col_vals_not_null(columns = b) %&gt;%
  dplyr::pull(b)
#&gt; [1] 7 1 0 0 0
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_not_null(tbl, columns = b)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_col_vals_not_null(columns = b)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-16
</p>


<h3>See Also</h3>

<p>The analogue to this function: <code><a href="#topic+col_vals_null">col_vals_null()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_null'>Are column data <code>NULL</code>/<code>NA</code>?</h2><span id='topic+col_vals_null'></span><span id='topic+expect_col_vals_null'></span><span id='topic+test_col_vals_null'></span>

<h3>Description</h3>

<p>The <code>col_vals_null()</code> validation function, the <code>expect_col_vals_null()</code>
expectation function, and the <code>test_col_vals_null()</code> test function all check
whether column values in a table are <code>NA</code> values or, in the database context,
<code>NULL</code> values. The validation function can be used directly on a data table
or with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. Each
validation step or expectation will operate over the number of test units
that is equal to the number of rows in the table (after any <code>preconditions</code>
have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_null(
  x,
  columns,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_null(object, columns, preconditions = NULL, threshold = 1)

test_col_vals_null(object, columns, preconditions = NULL, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_null_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_null_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_null()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_null()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_null(
    columns = a,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_null()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_null:
    columns: c(a)
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_null()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code>
argument requires a value. Arguments with default values won't be written to
YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with
their default when generating the YAML by other means). It is also possible
to preview the transformation of an agent to YAML without any writing to disk
by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all examples here, we'll use a simple table with four columns: <code>a</code>, <code>b</code>,
<code>c</code>, and <code>d</code>.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c( 5,  7,  6,  5,  8),
    b = c( 7,  1,  0,  0,  0),
    c = c(NA, NA, NA, NA, NA),
    d = c(35, 23, NA, NA, NA)
  )

tbl
#&gt; # A tibble: 5 x 4
#&gt;       a     b c         d
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt;
#&gt; 1     5     7 NA       35
#&gt; 2     7     1 NA       23
#&gt; 3     6     0 NA       NA
#&gt; 4     5     0 NA       NA
#&gt; 5     8     0 NA       NA
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that all values in column <code>c</code> are <code>NA</code> (they would be <code>NULL</code> in a
database context, which isn't the case here). We'll determine if this
validation has any failing test units (there are 5 test units, one for each
row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_null(columns = c) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_null_1.png" alt="This image was generated from the first code example in the `col_vals_null()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  col_vals_null(columns = c) %&gt;%
  dplyr::pull(c)
#&gt; [1] NA NA NA NA NA
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_null(tbl, columns = c)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_col_vals_null(columns = c)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-15
</p>


<h3>See Also</h3>

<p>The analogue to this function: <code><a href="#topic+col_vals_not_null">col_vals_not_null()</a></code>.
</p>
<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_regex'>Do strings in column data match a regex pattern?</h2><span id='topic+col_vals_regex'></span><span id='topic+expect_col_vals_regex'></span><span id='topic+test_col_vals_regex'></span>

<h3>Description</h3>

<p>The <code>col_vals_regex()</code> validation function, the <code>expect_col_vals_regex()</code>
expectation function, and the <code>test_col_vals_regex()</code> test function all check
whether column values in a table correspond to a <code>regex</code> matching expression.
The validation function can be used directly on a data table or with an
<em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. Each
validation step or expectation will operate over the number of test units
that is equal to the number of rows in the table (after any <code>preconditions</code>
have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_regex(
  x,
  columns,
  regex,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_regex(
  object,
  columns,
  regex,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_regex(
  object,
  columns,
  regex,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_regex_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_regex">regex</code></td>
<td>
<p><em>Regex pattern</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A regular expression pattern to test for a match to the target column. Any
regex matches to values in the target <code>columns</code> will pass validation.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_regex_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_regex()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>col_vals_regex()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode"><pre>agent %&gt;% 
  col_vals_regex(
    columns = a,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}",
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_regex()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_regex:
    columns: c(a)
    regex: '[0-9]-[a-z]{3}-[0-9]{3}'
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_regex()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>regex</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package has a character-based <code>b</code> column
with values that adhere to a very particular pattern. The following examples
will validate that that column abides by a regex pattern.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>This is the regex pattern that will be used throughout:
</p>
<div class="sourceCode r"><pre>pattern &lt;- "[0-9]-[a-z]{3}-[0-9]{3}"
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that all values in column <code>b</code> match the regex <code>pattern</code>. We'll
determine if this validation has any failing test units (there are 13 test
units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = small_table) %&gt;%
  col_vals_regex(columns = b, regex = pattern) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_regex_1.png" alt="This image was generated from the first code example in the `col_vals_regex()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_regex(columns = b, regex = pattern) %&gt;%
  dplyr::slice(1:5)
#&gt; # A tibble: 5 x 8
#&gt;   date_time           date           a b             c      d e     f    
#&gt;   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt; 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt; 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt; 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt; 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt; 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_regex(small_table, columns = b, regex = pattern)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>small_table %&gt;% test_col_vals_regex(columns = b, regex = pattern)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-17
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='col_vals_within_spec'>Do values in column data fit within a specification?</h2><span id='topic+col_vals_within_spec'></span><span id='topic+expect_col_vals_within_spec'></span><span id='topic+test_col_vals_within_spec'></span>

<h3>Description</h3>

<p>The <code>col_vals_within_spec()</code> validation function, the
<code>expect_col_vals_within_spec()</code> expectation function, and the
<code>test_col_vals_within_spec()</code> test function all check whether column values
in a table correspond to a specification (<code>spec</code>) type (details of which are
available in the <em>Specifications</em> section). The validation function can be
used directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. Each validation step or expectation will operate
over the number of test units that is equal to the number of rows in the
table (after any <code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_vals_within_spec(
  x,
  columns,
  spec,
  na_pass = FALSE,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_col_vals_within_spec(
  object,
  columns,
  spec,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)

test_col_vals_within_spec(
  object,
  columns,
  spec,
  na_pass = FALSE,
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_vals_within_spec_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the column (or a set of columns) to which this validation should
be applied. See the <em>Column Names</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_spec">spec</code></td>
<td>
<p><em>Specification type</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A specification string for defining the specification type. Examples are
<code>"email"</code>, <code>"url"</code>, and <code>"postal[USA]"</code>. All options are explained in the
<em>Specifications</em> section.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_na_pass">na_pass</code></td>
<td>
<p><em>Allow missing values to pass validation</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should any encountered <code>NA</code> values be considered as passing test units? By
default, this is <code>FALSE</code>. Set to <code>TRUE</code> to give <code>NA</code>s a pass.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="col_vals_within_spec_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Specifications</h3>

<p>A specification type must be used with the <code>spec</code> argument. This is a
character-based keyword that corresponds to the type of data in the specified
<code>columns</code>. The following keywords can be used:
</p>

<ul>
<li> <p><code>"isbn"</code>: The International Standard Book Number (ISBN) is a unique
numerical identifier for books, pamphletes, educational kits, microforms, and
digital/electronic publications. The specification has been formalized in
ISO 2108. This keyword can be used to validate 10- or 13-digit ISBNs.
</p>
</li>
<li> <p><code>"VIN"</code>: A vehicle identification number (VIN) is a unique code (which
includes a serial number) used by the automotive industry to identify
individual motor vehicles, motorcycles, scooters, and mopeds as stipulated
by ISO 3779 and ISO 4030.
</p>
</li>
<li> <p><code>"postal_code[&lt;country_code&gt;]"</code>: A postal code (also known as postcodes,
PIN, or ZIP codes, depending on region) is a series of letters, digits, or
both (sometimes including spaces/punctuation) included in a postal address to
aid in sorting mail. Because the coding varies by country, a country code in
either the 2- (ISO 3166-1 alpha-2) or 3-letter (ISO 3166-1 alpha-3) formats
needs to be supplied along with the keywords (e.g., for postal codes in
Germany, <code>"postal_code[DE]"</code> or <code>"postal_code[DEU]"</code> can be used). The
keyword alias <code>"zip"</code> can be used for US ZIP codes.
</p>
</li>
<li> <p><code>"credit_card"</code>: A credit card number can be validated and this check works
across a large variety of credit type issuers (where card numbers are
allocated in accordance with ISO/IEC 7812). Numbers can be of various lengths
(typically, they are of 14-19 digits) and the key validation performed here
is the usage of the Luhn algorithm.
</p>
</li>
<li> <p><code>"iban[&lt;country_code&gt;]"</code>: The International Bank Account Number (IBAN) is a
system of identifying bank accounts across different countries for the
purpose of improving cross-border transactions. IBAN values are validated
through conversion to integer values and performing a basic mod-97 operation
(as described in ISO 7064) on them. Because the length and coding varies by
country, a country code in either the 2- (ISO 3166-1 alpha-2) or 3-letter
(ISO 3166-1 alpha-3) formats needs to be supplied along with the keywords
(e.g., for IBANs in Germany, <code>"iban[DE]"</code> or <code>"iban[DEU]"</code> can be used).
</p>
</li>
<li> <p><code>"swift"</code>: Business Identifier Codes (also known as SWIFT-BIC, BIC,
or SWIFT code) are defined in a standard format as described by ISO 9362.
These codes are unique identifiers for both financial and non-financial
institutions. SWIFT stands for the Society for Worldwide Interbank Financial
Telecommunication. These numbers are used when transferring money between
banks, especially important for international wire transfers.
</p>
</li>
<li> <p><code>"phone"</code>, <code>"email"</code>, <code>"url"</code>, <code>"ipv4"</code>, <code>"ipv6"</code>, <code>"mac"</code>: Phone numbers,
email addresses, Internet URLs, IPv4 or IPv6 addresses, and MAC addresses can
be validated with their respective keywords. These validations use
regex-based matching to determine validity.
</p>
</li></ul>

<p>Only a single <code>spec</code> value should be provided per function call.
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Missing Values</h3>

<p>This validation function supports special handling of <code>NA</code> values. The
<code>na_pass</code> argument will determine whether an <code>NA</code> value appearing in a test
unit should be counted as a <em>pass</em> or a <em>fail</em>. The default of <code>na_pass = FALSE</code> means that any <code>NA</code>s encountered will accumulate failing test units.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>col_vals_within_spec()</code> is represented in YAML (under the top-level <code>steps</code>
key as a list member), the syntax closely follows the signature of the
validation function. Here is an example of how a complex call of
<code>col_vals_within_spec()</code> as a validation step is expressed in R code and in
the corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  col_vals_within_spec(
    columns = a,
    spec = "email",
    na_pass = TRUE,
    preconditions = ~ . %&gt;% dplyr::filter(b &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `col_vals_within_spec()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- col_vals_within_spec:
    columns: c(a)
    spec: email
    na_pass: true
    preconditions: ~. %&gt;% dplyr::filter(b &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `col_vals_within_spec()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the <code>columns</code> and
<code>spec</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>The <code>specifications</code> dataset in the package has columns of character data
that correspond to each of the specifications that can be tested. The
following examples will validate that the <code>email_addresses</code> column has 5
correct values (this is true if we get a subset of the data: the first five
rows).
</p>
<div class="sourceCode r"><pre>spec_slice &lt;- specifications[1:5, ]

spec_slice
#&gt; # A tibble: 5 x 12
#&gt;   isbn_numbers      vin_numbers       zip_codes credit_card_numbers iban_austria
#&gt;   &lt;chr&gt;             &lt;chr&gt;             &lt;chr&gt;     &lt;chr&gt;               &lt;chr&gt;       
#&gt; 1 978 1 85715 201 2 4UZAANDH85CV12329 99553     340000000000009     AT582774098~
#&gt; 2 978-1-84159-362-3 JM1BL1S59A1134659 36264     378734493671000     AT220332087~
#&gt; 3 978 1 84159 329 6 1GCEK14R3WZ274764 71660     6703444444444449    AT328650112~
#&gt; 4 978 1 85715 202 9 2B7JB21Y0XK524370 85225     6703000000000000003 AT193357281~
#&gt; 5 978 1 85715 198 5 4UZAANDH85CV12329 90309     4035501000000008    AT535755326~
#&gt; # i 7 more variables: swift_numbers &lt;chr&gt;, phone_numbers &lt;chr&gt;,
#&gt; #   email_addresses &lt;chr&gt;, urls &lt;chr&gt;, ipv4_addresses &lt;chr&gt;,
#&gt; #   ipv6_addresses &lt;chr&gt;, mac_addresses &lt;chr&gt;
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that all values in the column <code>email_addresses</code> are correct. We'll
determine if this validation has any failing test units (there are 5 test
units, one for each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = spec_slice) %&gt;%
  col_vals_within_spec(
    columns = email_addresses,
    spec = "email"
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_col_vals_within_spec_1.png" alt="This image was generated from the first code example in the `col_vals_within_spec()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>spec_slice %&gt;%
  col_vals_within_spec(
    columns = email_addresses,
    spec = "email"
  ) %&gt;%
  dplyr::select(email_addresses)
#&gt; # A tibble: 5 x 1
#&gt;   email_addresses                                                          
#&gt;   &lt;chr&gt;                                                                    
#&gt; 1 test@test.com                                                            
#&gt; 2 mail+mail@example.com                                                    
#&gt; 3 mail.email@e.test.com                                                    
#&gt; 4 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@letters-in-local.org
#&gt; 5 01234567890@numbers-in-local.net
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_col_vals_within_spec(
  spec_slice,
  columns = email_addresses,
  spec = "email"
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>spec_slice %&gt;%
  test_col_vals_within_spec(
    columns = email_addresses,
    spec = "email"
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-18
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='conjointly'>Perform multiple rowwise validations for joint validity</h2><span id='topic+conjointly'></span><span id='topic+expect_conjointly'></span><span id='topic+test_conjointly'></span>

<h3>Description</h3>

<p>The <code>conjointly()</code> validation function, the <code>expect_conjointly()</code> expectation
function, and the <code>test_conjointly()</code> test function all check whether test
units at each index (typically each row) all pass multiple validations. We
can use validation functions that validate row units (the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>
series), check for column existence (<code><a href="#topic+col_exists">col_exists()</a></code>), or validate column type
(the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code> series). Because of the imposed constraint on the allowed
validation functions, the ensemble of test units are either comprised rows of
the table (after any common <code>preconditions</code> have been applied) or are single
test units (for those functions that validate columns).
</p>
<p>Each of the functions used in a <code>conjointly()</code> validation step (composed
using multiple validation function calls) ultimately perform a rowwise test
of whether all sub-validations reported a <em>pass</em> for the same test units. In
practice, an example of a joint validation is testing whether values for
column <code>a</code> are greater than a specific value while adjacent values in column
<code>b</code> lie within a specified range. The validation functions to be part of the
conjoint validation are to be supplied as one-sided <strong>R</strong> formulas (using a
leading <code>~</code>, and having a <code>.</code> stand in as the data object). The validation
function can be used directly on a data table or with an <em>agent</em> object
(technically, a <code>ptblank_agent</code> object) whereas the expectation and test
functions can only be used with a data table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conjointly(
  x,
  ...,
  .list = list2(...),
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_conjointly(
  object,
  ...,
  .list = list2(...),
  preconditions = NULL,
  threshold = 1
)

test_conjointly(
  object,
  ...,
  .list = list2(...),
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conjointly_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="conjointly_+3A_...">...</code></td>
<td>
<p><em>Validation expressions</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;validation expressions&gt;&#8288;</code> // <strong>required</strong> (or, use <code>.list</code>)
</p>
<p>A collection one-sided formulas that consist of validation functions that
validate row units (the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code> series), column existence
(<code><a href="#topic+col_exists">col_exists()</a></code>), or column type (the <code style="white-space: pre;">&#8288;col_is_*()&#8288;</code> series). An example of
this is <code style="white-space: pre;">&#8288;~ col_vals_gte(., a, 5.5), ~ col_vals_not_null(., b&#8288;</code>).</p>
</td></tr>
<tr><td><code id="conjointly_+3A_.list">.list</code></td>
<td>
<p><em>Alternative to <code>...</code></em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;list of multiple expressions&gt;&#8288;</code> // <strong>required</strong> (or, use <code>...</code>)
</p>
<p>Allows for the use of a list as an input alternative to <code>...</code>.</p>
</td></tr>
<tr><td><code id="conjointly_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="conjointly_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="conjointly_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="conjointly_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="conjointly_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="conjointly_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="conjointly_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="conjointly_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="conjointly_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>If there are multiple <code>columns</code> specified then the potential number of
validation steps will be <code>m</code> columns multiplied by <code>n</code> segments resolved.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>conjointly()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>conjointly()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  conjointly(
    ~ col_vals_lt(., columns = a, value = 8),
    ~ col_vals_gt(., columns = c, value = vars(a)),
    ~ col_vals_not_null(., columns = b),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2), 
    label = "The `conjointly()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- conjointly:
    fns:
    - ~col_vals_lt(., columns = a, value = 8)
    - ~col_vals_gt(., columns = c, value = vars(a))
    - ~col_vals_not_null(., columns = b)
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `conjointly()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the expressions for
validation steps are necessary. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all examples here, we'll use a simple table with three numeric columns
(<code>a</code>, <code>b</code>, and <code>c</code>). This is a very basic table but it'll be more useful when
explaining things later.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 2, 6),
    b = c(3, 4, 6),
    c = c(9, 8, 7)
  )
  
tbl
#&gt; # A tibble: 3 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     3     9
#&gt; 2     2     4     8
#&gt; 3     6     6     7
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate a number of things on a row-by-row basis using validation functions
of the <code style="white-space: pre;">&#8288;col_vals*&#8288;</code> type (all have the same number of test units): (1) values
in <code>a</code> are less than <code>8</code>, (2) values in <code>c</code> are greater than the adjacent
values in <code>a</code>, and (3) there aren't any NA values in <code>b</code>. We'll determine if
this validation has any failing test units (there are 3 test units, one for
each row).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  conjointly(
    ~ col_vals_lt(., columns = a, value = 8),
    ~ col_vals_gt(., columns = c, value = vars(a)),
    ~ col_vals_not_null(., columns = b)
    ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_conjointly_1.png" alt="This image was generated from the first code example in the `conjointly()` help file." style="width:100%;">


<p>What's going on? Think of there being three parallel validations, each
producing a column of <code>TRUE</code> or <code>FALSE</code> values (<code>pass</code> or <code>fail</code>) and line
them up side-by-side, any rows with any <code>FALSE</code> values results in a conjoint
<code>fail</code> test unit.
</p>



<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  conjointly(
    ~ col_vals_lt(., columns = a, value = 8),
    ~ col_vals_gt(., columns = c, value = vars(a)),
    ~ col_vals_not_null(., columns = b)
  )
#&gt; # A tibble: 3 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     3     9
#&gt; 2     2     4     8
#&gt; 3     6     6     7
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_conjointly(
  tbl,
  ~ col_vals_lt(., columns = a, value = 8),
  ~ col_vals_gt(., columns = c, value = vars(a)),
  ~ col_vals_not_null(., columns = b)
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  test_conjointly(
    ~ col_vals_lt(., columns = a, value = 8),
    ~ col_vals_gt(., columns = c, value = vars(a)),
    ~ col_vals_not_null(., columns = b)
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-34
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='create_agent'>Create a <strong>pointblank</strong> <em>agent</em> object</h2><span id='topic+create_agent'></span>

<h3>Description</h3>

<p>The <code>create_agent()</code> function creates an <em>agent</em> object, which is used in a
<em>data quality reporting</em> workflow. The overall aim of this workflow is to
generate useful reporting information for assessing the level of data quality
for the target table. We can supply as many validation functions as the user
wishes to write, thereby increasing the level of validation coverage for that
table. The <em>agent</em> assigned by the <code>create_agent()</code> call takes validation
functions (e.g., <code><a href="#topic+col_vals_between">col_vals_between()</a></code>, <code><a href="#topic+rows_distinct">rows_distinct()</a></code>, etc.), which
translate to discrete validation steps (each one is numbered and will later
provide its own set of results). This process is known as developing a
<em>validation plan</em>.
</p>
<p>The validation functions, when called on an <em>agent</em>, are merely instructions
up to the point the <code><a href="#topic+interrogate">interrogate()</a></code> function is called. That kicks off the
process of the <em>agent</em> acting on the <em>validation plan</em> and getting results
for each step. Once the interrogation process is complete, we can say that
the <em>agent</em> has intel. Calling the <em>agent</em> itself will result in a reporting
table. This reporting of the interrogation can also be accessed with the
<code><a href="#topic+get_agent_report">get_agent_report()</a></code> function, where there are more reporting options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_agent(
  tbl = NULL,
  tbl_name = NULL,
  label = NULL,
  actions = NULL,
  end_fns = NULL,
  embed_report = FALSE,
  lang = NULL,
  locale = NULL,
  read_fn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_agent_+3A_tbl">tbl</code></td>
<td>
<p><em>Table or expression for reading in one</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;|&lt;tbl reading expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The input table. This can be a data frame, a tibble, a <code>tbl_dbi</code> object, or
a <code>tbl_spark</code> object. Alternatively, an expression can be supplied to serve
as instructions on how to retrieve the target table at interrogation-time.
There are two ways to specify an association to a target table: (1) as a
table-prep formula, which is a right-hand side (RHS) formula expression
(e.g., <code style="white-space: pre;">&#8288;~ { &lt;tbl reading code&gt;}&#8288;</code>), or (2) as a function (e.g.,
<code style="white-space: pre;">&#8288;function() { &lt;tbl reading code&gt;}&#8288;</code>).</p>
</td></tr>
<tr><td><code id="create_agent_+3A_tbl_name">tbl_name</code></td>
<td>
<p><em>A table name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A optional name to assign to the input table object. If no value is
provided, a name will be generated based on whatever information is
available. This table name will be displayed in the header area of the
agent report generated by printing the <em>agent</em> or calling
<code><a href="#topic+get_agent_report">get_agent_report()</a></code>.</p>
</td></tr>
<tr><td><code id="create_agent_+3A_label">label</code></td>
<td>
<p><em>An optional label for the validation plan</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional label for the validation plan. If no value is provided, a label
will be generated based on the current system time. Markdown can be used
here to make the label more visually appealing (it will appear in the
header area of the agent report).</p>
</td></tr>
<tr><td><code id="create_agent_+3A_actions">actions</code></td>
<td>
<p><em>Default thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A option to include a list with threshold levels so that all validation
steps can react accordingly when exceeding the set levels. This is to be
created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function. Should an action levels
list be used for a specific validation step, the default set specified here
will be overridden.</p>
</td></tr>
<tr><td><code id="create_agent_+3A_end_fns">end_fns</code></td>
<td>
<p><em>Functions to execute after interrogation</em>
</p>
<p><code>list</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list of expressions that should be invoked at the end of an
interrogation. Each expression should be in the form of a one-sided R
formula, so overall this construction should be used: <code style="white-space: pre;">&#8288;end_fns = list(~ &lt;R statements&gt;, ~ &lt;R statements&gt;, ...)&#8288;</code>. An example of a function included in
<strong>pointblank</strong> that can be sensibly used here is <code><a href="#topic+email_blast">email_blast()</a></code>, which
sends an email of the validation report (based on a sending condition).</p>
</td></tr>
<tr><td><code id="create_agent_+3A_embed_report">embed_report</code></td>
<td>
<p><em>Embed the validation report into agent object?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>An option to embed a <strong>gt</strong>-based validation report into the
<code>ptblank_agent</code> object. If <code>FALSE</code> then the table object will be not
generated and available with the <em>agent</em> upon returning from the
interrogation.</p>
</td></tr>
<tr><td><code id="create_agent_+3A_lang">lang</code></td>
<td>
<p><em>Reporting language</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use for automatic creation of briefs (short descriptions
for each validation step) and for the <em>agent report</em> (a summary table that
provides the validation plan and the results from the interrogation. By
default, <code>NULL</code> will create English (<code>"en"</code>) text. Other options include
French (<code>"fr"</code>), German (<code>"de"</code>), Italian (<code>"it"</code>), Spanish (<code>"es"</code>),
Portuguese (<code>"pt"</code>), Turkish (<code>"tr"</code>), Chinese (<code>"zh"</code>), Russian (<code>"ru"</code>),
Polish (<code>"pl"</code>), Danish (<code>"da"</code>), Swedish (<code>"sv"</code>), and Dutch (<code>"nl"</code>).</p>
</td></tr>
<tr><td><code id="create_agent_+3A_locale">locale</code></td>
<td>
<p><em>Locale for value formatting within reports</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional locale ID to use for formatting values in the <em>agent report</em>
summary table according the locale's rules. Examples include <code>"en_US"</code> for
English (United States) and <code>"fr_FR"</code> for French (France); more simply,
this can be a language identifier without a country designation, like &quot;es&quot;
for Spanish (Spain, same as <code>"es_ES"</code>).</p>
</td></tr>
<tr><td><code id="create_agent_+3A_read_fn">read_fn</code></td>
<td>
<p><em><a href="base.html#topic+Deprecated">Deprecated</a> Table reading function</em>
</p>
<p><code>function</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The <code>read_fn</code> argument is deprecated. Instead, supply a table-prep formula
or function to <code>tbl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_agent</code> object.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>The Use of an Agent for Validation Is Just One Option of Several</h3>

<p>There are a few validation workflows and using an <em>agent</em> is the one that
provides the most options. It is probably the best choice for assessing the
state of data quality since it yields detailed reporting, has options for
further exploration of root causes, and allows for granular definition of
actions to be taken based on the severity of validation failures (e.g.,
emailing, logging, etc.).
</p>
<p>Different situations, however, call for different validation workflows. You
use validation functions (the same ones you would with an <em>agent</em>) directly
on the data. This acts as a sort of data filter in that the input table will
become output data (without modification), but there may be warnings, errors,
or other side effects that you can define if validation fails. Basically,
instead of this
</p>
<div class="sourceCode r"><pre>create_agent(tbl = small_table) %&gt;% rows_distinct() %&gt;% interrogate()
</pre></div>
<p>you would use this:
</p>
<div class="sourceCode r"><pre>small_table %&gt;% rows_distinct()
</pre></div>
<p>This results in an error (with the default failure threshold settings),
displaying the reason for the error in the console. Notably, the data is not
passed though.
</p>
<p>We can use variants of the validation functions, the <em>test</em> (<code style="white-space: pre;">&#8288;test_*()&#8288;</code>) and
<em>expectation</em> (<code style="white-space: pre;">&#8288;expect_*()&#8288;</code>) versions, directly on the data for different
workflows. The first returns to us a logical value. So this
</p>
<div class="sourceCode r"><pre>small_table %&gt;% test_rows_distinct()
</pre></div>
<p>returns <code>FALSE</code> instead of an error.
</p>
<p>In a unit testing scenario, we can use <em>expectation</em> functions exactly as we
would with <strong>testthat</strong>'s library of <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> functions:
</p>
<div class="sourceCode r"><pre>small_table %&gt;% expect_rows_distinct()
</pre></div>
<p>This test of <code>small_table</code> would be counted as a failure.
</p>


<h3>The Agent Report</h3>

<p>While printing an <em>agent</em> (a <code>ptblank_agent</code> object) will display its
reporting in the Viewer, we can alternatively use the <code><a href="#topic+get_agent_report">get_agent_report()</a></code> to
take advantage of other options (e.g., overriding the language, modifying the
arrangement of report rows, etc.), and to return the report as independent
objects. For example, with the <code>display_table = TRUE</code> option (the default),
<code><a href="#topic+get_agent_report">get_agent_report()</a></code> will return a <code>ptblank_agent_report</code> object. If
<code>display_table</code> is set to <code>FALSE</code>, we'll get a data frame back instead.
</p>
<p>Exporting the report as standalone HTML file can be accomplished by using the
<code><a href="#topic+export_report">export_report()</a></code> function. This function can accept either the
<code>ptblank_agent</code> object or the <code>ptblank_agent_report</code> as input. Each HTML
document written to disk in this way is self-contained and easily viewable in
a web browser.
</p>


<h3>Data Products Obtained from an Agent</h3>

<p>A very detailed list object, known as an x-list, can be obtained by using the
<code><a href="#topic+get_agent_x_list">get_agent_x_list()</a></code> function on the <em>agent</em>. This font of information can be
taken as a whole, or, broken down by the step number (with the <code>i</code> argument).
</p>
<p>Sometimes it is useful to see which rows were the failing ones. By using the
<code><a href="#topic+get_data_extracts">get_data_extracts()</a></code> function on the <em>agent</em>, we either get a list of
tibbles (for those steps that have data extracts) or one tibble if the
validation step is specified with the <code>i</code> argument.
</p>
<p>The target data can be split into pieces that represent the 'pass' and 'fail'
portions with the <code><a href="#topic+get_sundered_data">get_sundered_data()</a></code> function. A primary requirement is an
agent that has had <code><a href="#topic+interrogate">interrogate()</a></code> called on it. In addition, the validation
steps considered for this data splitting need to be those that operate on
values down a column (e.g., the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code> functions or <code><a href="#topic+conjointly">conjointly()</a></code>).
With these in-consideration validation steps, rows with no failing test units
across all validation steps comprise the 'pass' data piece, and rows with at
least one failing test unit across the same series of validations constitute
the 'fail' piece.
</p>
<p>If we just need to know whether all validations completely passed (i.e., all
steps had no failing test units), the <code><a href="#topic+all_passed">all_passed()</a></code> function could be used
on the <em>agent</em>. However, in practice, it's not often the case that all data
validation steps are free from any failing units.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). Here is an
example of how a complex call of <code>create_agent()</code> is expressed in R code and
in the corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>create_agent(
  tbl = ~ small_table,
  tbl_name = "small_table",
  label = "An example.",
  actions = action_levels(
    warn_at = 0.10,
    stop_at = 0.25,
    notify_at = 0.35,
    fns = list(notify = ~ email_blast(
      x,
      to = "joe_public@example.com",
      from = "pb_notif@example.com",
      msg_subject = "Table Validation",
      credentials = blastula::creds_key(
        id = "smtp2go"
      )
    ))
  ), 
  end_fns = list(
    ~ beepr::beep(2),
    ~ Sys.sleep(1)
  ), 
  embed_report = TRUE,
  lang = "fr", 
  locale = "fr_CA"
)
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>type: agent
tbl: ~small_table
tbl_name: small_table
label: An example.
lang: fr
locale: fr_CA
actions:
  warn_fraction: 0.1
  stop_fraction: 0.25
  notify_fraction: 0.35
  fns:
    notify: ~email_blast(x, to = "joe_public@example.com",
      from = "pb_notif@example.com",
      msg_subject = "Table Validation",
      credentials = blastula::creds_key(id = "smtp2go"))
end_fns:
- ~beepr::beep(2)
- ~Sys.sleep(1)
embed_report: true
steps: []
</pre></div>
<p>In practice, this YAML file will be shorter since arguments with default
values won't be written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is
acceptable to include them with their default when generating the YAML by
other means). The only requirement for writing the YAML representation of an
<em>agent</em> is having <code>tbl</code> specified as table-prep formula.
</p>
<p>What typically follows this chunk of YAML is a <code>steps</code> part, and that
corresponds to the addition of validation steps via validation functions.
Help articles for each validation function have a <em>YAML</em> section that
describes how a given validation function is translated to YAML.
</p>
<p>Should you need to preview the transformation of an <em>agent</em> to YAML (without
any committing anything to disk), use the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function. If
you already have a <code>.yml</code> file that holds an <em>agent</em>, you can get a glimpse
of the R expressions that are used to regenerate that agent with
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs()</a></code>.
</p>


<h3>Writing an Agent to Disk</h3>

<p>An <em>agent</em> object can be written to disk with the <code><a href="#topic+x_write_disk">x_write_disk()</a></code> function.
This can be useful for keeping a history of validations and generating views
of data quality over time. Agents are stored in the serialized RDS format and
can be easily retrieved with the <code><a href="#topic+x_read_disk">x_read_disk()</a></code> function.
</p>
<p>It's recommended that table-prep formulas are supplied to the <code>tbl</code>
argument of <code>create_agent()</code>. In this way, when an <em>agent</em> is read from disk
through <code><a href="#topic+x_read_disk">x_read_disk()</a></code>, it can be reused to access the target table (which
may change, hence the need to use an expression for this).
</p>


<h3>Combining Several Agents in a <em>multiagent</em> Object</h3>

<p>Multiple <em>agent</em> objects can be part of a <em>multiagent</em> object, and two
functions can be used for this: <code><a href="#topic+create_multiagent">create_multiagent()</a></code> and
<code><a href="#topic+read_disk_multiagent">read_disk_multiagent()</a></code>. By gathering multiple agents that have performed
interrogations in the past, we can get a <em>multiagent</em> report showing how data
quality evolved over time. This use case is interesting for data quality
monitoring and management, and, the reporting (which can be customized with
<code><a href="#topic+get_multiagent_report">get_multiagent_report()</a></code>) is robust against changes in validation steps for
a given target table.
</p>


<h3>Examples</h3>



<h4>Creating an agent, adding a validation plan, and interrogating</h4>

<p>Let's walk through a data quality analysis of an extremely small table. It's
actually called <code>small_table</code> and we can find it as a dataset in this
package.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>We ought to think about what's tolerable in terms of data quality so let's
designate proportional failure thresholds to the <code>warn</code>, <code>stop</code>, and <code>notify</code>
states using <code><a href="#topic+action_levels">action_levels()</a></code>.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
      warn_at = 0.10,
      stop_at = 0.25,
    notify_at = 0.35
  )
</pre></div>
<p>Now create a pointblank <code>agent</code> object and give it the <code>al</code> object (which
serves as a default for all validation steps which can be overridden). The
static thresholds provided by <code>al</code> will make the reporting a bit more useful.
We also provide a target table and we'll use <code>pointblank::small_table</code>.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = pointblank::small_table,
    tbl_name = "small_table",
    label = "`create_agent()` example.",
    actions = al
  )
</pre></div>
<p>Then, as with any <code>agent</code> object, we can add steps to the validation plan by
using as many validation functions as we want. then, we use <code><a href="#topic+interrogate">interrogate()</a></code>
to actually perform the validations and gather intel.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  agent %&gt;% 
  col_exists(columns = c(date, date_time)) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}"
  ) %&gt;%
  rows_distinct() %&gt;%
  col_vals_gt(columns = d, value = 100) %&gt;%
  col_vals_lte(columns = c, value = 5) %&gt;%
  col_vals_between(
    columns = c,
    left = vars(a), right = vars(d),
    na_pass = TRUE
  ) %&gt;%
  interrogate()
</pre></div>
<p>The <code>agent</code> object can be printed to see the validation report in the
Viewer.
</p>
<div class="sourceCode r"><pre>agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_create_agent_1.png" alt="This image was generated from the first code example in the `create_agent()` help file." style="width:100%;">


<p>If we want to make use of more report display options, we can alternatively
use the <code><a href="#topic+get_agent_report">get_agent_report()</a></code> function.
</p>
<div class="sourceCode r"><pre>report &lt;-
  get_agent_report(
    agent = agent,
    arrange_by = "severity",
    title = "Validation of `small_table`"
  )

report
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_create_agent_2.png" alt="This image was generated from the second code example in the `create_agent()` help file." style="width:100%;">





<h4>Post-interrogation operations</h4>

<p>We can use the <code>agent</code> object with a variety of functions to get at more
of the information collected during interrogation.
</p>
<p>We can see from the validation report that Step 4 (which used the
<code><a href="#topic+rows_distinct">rows_distinct()</a></code> validation function) had two test units, corresponding to
duplicated rows, that failed. We can see those rows with
<code><a href="#topic+get_data_extracts">get_data_extracts()</a></code>.
</p>
<div class="sourceCode r"><pre>agent %&gt;% get_data_extracts(i = 4)
</pre></div>
<pre>## # A tibble: 2 × 8
##   date_time           date           a b            c     d e     f    
##   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
## 1 2016-01-20 04:30:00 2016-01-20     3 5-bce-6…     9  838. FALSE high 
## 2 2016-01-20 04:30:00 2016-01-20     3 5-bce-6…     9  838. FALSE high</pre>
<p>We can get an x-list for the entire validation process (7 steps), or, just
for the 4th step with <code><a href="#topic+get_agent_x_list">get_agent_x_list()</a></code>.
</p>
<div class="sourceCode r"><pre>xl_step_4 &lt;- agent %&gt;% get_agent_x_list(i = 4)
</pre></div>
<p>And then we can peruse the different parts of the list. Let's get the
fraction of test units that failed.
</p>
<div class="sourceCode r"><pre>xl_step_4$f_failed
</pre></div>
<div class="sourceCode"><pre>#&gt; [1] 0.15385
</pre></div>
<p>An x-list not specific to any step will have way more information and a
slightly different structure. See <code>help(get_agent_x_list)</code> for more info.
</p>



<h3>Function ID</h3>

<p>1-2
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='create_informant'>Create a <strong>pointblank</strong> <em>informant</em> object</h2><span id='topic+create_informant'></span>

<h3>Description</h3>

<p>The <code>create_informant()</code> function creates an <em>informant</em> object, which is
used in an <em>information management</em> workflow. The overall aim of this
workflow is to record, collect, and generate useful information on data
tables. We can supply any information that is useful for describing a
particular data table. The <em>informant</em> object created by the
<code>create_informant()</code> function takes information-focused functions:
<code><a href="#topic+info_columns">info_columns()</a></code>, <code><a href="#topic+info_tabular">info_tabular()</a></code>, <code><a href="#topic+info_section">info_section()</a></code>, and <code><a href="#topic+info_snippet">info_snippet()</a></code>.
</p>
<p>The <code style="white-space: pre;">&#8288;info_*()&#8288;</code> series of functions allows for a progressive build up of
information about the target table. The <code><a href="#topic+info_columns">info_columns()</a></code> and <code><a href="#topic+info_tabular">info_tabular()</a></code>
functions facilitate the entry of <em>info text</em> that concerns the table columns
and the table proper; the <code><a href="#topic+info_section">info_section()</a></code> function allows for the creation
of arbitrary sections that can have multiple subsections full of additional
<em>info text</em>. The system allows for dynamic values culled from the target
table by way of <code><a href="#topic+info_snippet">info_snippet()</a></code>, for getting named text extracts from
queries, and the use of <code style="white-space: pre;">&#8288;{&lt;snippet_name&gt;}&#8288;</code> in the <em>info text</em>. To make the
use of <code><a href="#topic+info_snippet">info_snippet()</a></code> more convenient for common queries, a set of
<code style="white-space: pre;">&#8288;snip_*()&#8288;</code> functions are provided in the package (<code><a href="#topic+snip_list">snip_list()</a></code>,
<code><a href="#topic+snip_stats">snip_stats()</a></code>, <code><a href="#topic+snip_lowest">snip_lowest()</a></code>, and <code><a href="#topic+snip_highest">snip_highest()</a></code>) though you are free to
use your own expressions.
</p>
<p>Because snippets need to query the target table to return fragments of <em>info
text</em>, the <code><a href="#topic+incorporate">incorporate()</a></code> function needs to be used to initiate this action.
This is also necessary for the <em>informant</em> to update other metadata elements
such as row and column counts. Once the incorporation process is complete,
snippets and other metadata will be updated. Calling the <em>informant</em> itself
will result in a reporting table. This reporting can also be accessed with
the <code><a href="#topic+get_informant_report">get_informant_report()</a></code> function, where there are more reporting
options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_informant(
  tbl = NULL,
  tbl_name = NULL,
  label = NULL,
  agent = NULL,
  lang = NULL,
  locale = NULL,
  read_fn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_informant_+3A_tbl">tbl</code></td>
<td>
<p><em>Table or expression for reading in one</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;|&lt;tbl reading expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The input table. This can be a data frame, a tibble, a <code>tbl_dbi</code> object, or
a <code>tbl_spark</code> object. Alternatively, an expression can be supplied to serve
as instructions on how to retrieve the target table at incorporation-time.
There are two ways to specify an association to a target table: (1) as a
table-prep formula, which is a right-hand side (RHS) formula expression
(e.g., <code style="white-space: pre;">&#8288;~ { &lt;tbl reading code&gt;}&#8288;</code>), or (2) as a function (e.g.,
<code style="white-space: pre;">&#8288;function() { &lt;tbl reading code&gt;}&#8288;</code>).</p>
</td></tr>
<tr><td><code id="create_informant_+3A_tbl_name">tbl_name</code></td>
<td>
<p><em>A table name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A optional name to assign to the input table object. If no value is
provided, a name will be generated based on whatever information is
available.</p>
</td></tr>
<tr><td><code id="create_informant_+3A_label">label</code></td>
<td>
<p><em>An optional label for the information report</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional label for the information report. If no value is provided, a
label will be generated based on the current system time. Markdown can be
used here to make the label more visually appealing (it will appear in the
header area of the information report).</p>
</td></tr>
<tr><td><code id="create_informant_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A pointblank <em>agent</em> object. The table from this object can be extracted
and used in the new informant instead of supplying a table in <code>tbl</code>.</p>
</td></tr>
<tr><td><code id="create_informant_+3A_lang">lang</code></td>
<td>
<p><em>Reporting language</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use for the information report (a summary table that
provides all of the available information for the table. By default, <code>NULL</code>
will create English (<code>"en"</code>) text. Other options include French (<code>"fr"</code>),
German (<code>"de"</code>), Italian (<code>"it"</code>), Spanish (<code>"es"</code>), Portuguese (<code>"pt"</code>),
Turkish (<code>"tr"</code>), Chinese (<code>"zh"</code>), Russian (<code>"ru"</code>), Polish (<code>"pl"</code>),
Danish (<code>"da"</code>), Swedish (<code>"sv"</code>), and Dutch (<code>"nl"</code>).</p>
</td></tr>
<tr><td><code id="create_informant_+3A_locale">locale</code></td>
<td>
<p><em>Locale for value formatting within reports</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional locale ID to use for formatting values in the information
report according the locale's rules. Examples include <code>"en_US"</code> for English
(United States) and <code>"fr_FR"</code> for French (France); more simply, this can be
a language identifier without a country designation, like &quot;es&quot; for Spanish
(Spain, same as <code>"es_ES"</code>).</p>
</td></tr>
<tr><td><code id="create_informant_+3A_read_fn">read_fn</code></td>
<td>
<p><em><a href="base.html#topic+Deprecated">Deprecated</a> Table reading function</em>
</p>
<p><code>function</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The <code>read_fn</code> argument is deprecated. Instead, supply a table-prep formula
or function to <code>tbl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_informant</code> object.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> informant can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an informant (with
<code><a href="#topic+yaml_read_informant">yaml_read_informant()</a></code>) or perform the 'incorporate' action using the target
table (via <code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code>). Here is an example of how a
complex call of <code>create_informant()</code> is expressed in R code and in the
corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>create_informant(
  tbl = ~ small_table,
  tbl_name = "small_table",
  label = "An example.",
  lang = "fr", 
  locale = "fr_CA"
)
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>type: informant
tbl: ~small_table
tbl_name: small_table
info_label: An example.
lang: fr
locale: fr_CA
table:
  name: small_table
  _columns: 8
  _rows: 13.0
  _type: tbl_df
columns:
  date_time:
    _type: POSIXct, POSIXt
  date:
    _type: Date
  a:
    _type: integer
  b:
    _type: character
  c:
    _type: numeric
  d:
    _type: numeric
  e:
    _type: logical
  f:
    _type: character
</pre></div>
<p>The generated YAML includes some top-level keys where <code>type</code> and <code>tbl</code> are
mandatory, and, two metadata sections: <code>table</code> and <code>columns</code>. Keys that begin
with an underscore character are those that are updated whenever
<code><a href="#topic+incorporate">incorporate()</a></code> is called on an <em>informant</em>. The <code>table</code> metadata section can
have multiple subsections with <em>info text</em>. The <code>columns</code> metadata section
can similarly have have multiple subsections, so long as they are children to
each of the column keys (in the above YAML example, <code>date_time</code> and <code>date</code>
are column keys and they match the table's column names). Additional sections
can be added but they must have key names on the top level that don't
duplicate the default set (i.e., <code>type</code>, <code>table</code>, <code>columns</code>, etc. are treated
as reserved keys).
</p>


<h3>Writing an Informant to Disk</h3>

<p>An <em>informant</em> object can be written to disk with the <code><a href="#topic+x_write_disk">x_write_disk()</a></code>
function. Informants are stored in the serialized RDS format and can be
easily retrieved with the <code><a href="#topic+x_read_disk">x_read_disk()</a></code> function.
</p>
<p>It's recommended that table-prep formulas are supplied to the <code>tbl</code> argument
of <code>create_informant()</code>. In this way, when an <em>informant</em> is read from disk
through <code><a href="#topic+x_read_disk">x_read_disk()</a></code>, it can be reused to access the target table (which
may changed, hence the need to use an expression for this).
</p>


<h3>Examples</h3>

<p>Let's walk through how we can generate some useful information for a really
small table. It's actually called <code>small_table</code> and we can find it as a
dataset in this package.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>Create a pointblank <code>informant</code> object with <code>create_informant()</code> and the
<code>small_table</code> dataset.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = pointblank::small_table,
    tbl_name = "small_table",
    label = "`create_informant()` example."
  )
</pre></div>
<p>This function creates some information without any extra help by profiling
the supplied table object. It adds the <code>COLUMNS</code> section with stubs for each
of the target table's columns. We can use the <code><a href="#topic+info_columns">info_columns()</a></code> or
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl()</a></code> to provide descriptions for each of the columns.
The <code>informant</code> object can be printed to see the information report in the
Viewer.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_create_informant_1.png" alt="This image was generated from the first code example in the `create_informant()` help file." style="width:100%;">


<p>If we want to make use of more report display options, we can alternatively
use the <code><a href="#topic+get_informant_report">get_informant_report()</a></code> function.
</p>
<div class="sourceCode r"><pre>report &lt;- 
  get_informant_report(
    informant,
    title = "Data Dictionary for `small_table`"
  )
  
report
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_create_informant_2.png" alt="This image was generated from the second code example in the `create_informant()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>1-3
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='create_multiagent'>Create a <strong>pointblank</strong> <em>multiagent</em> object</h2><span id='topic+create_multiagent'></span>

<h3>Description</h3>

<p>Multiple <em>agents</em> can be part of a single object called the <em>multiagent</em>.
This can be useful when gathering multiple agents that have performed
interrogations in the past (perhaps saved to disk with <code><a href="#topic+x_write_disk">x_write_disk()</a></code>).
When be part of a <em>multiagent</em>, we can get a report that shows how data
quality evolved over time. This can be of interest when it's important to
monitor data quality and even the evolution of the validation plan itself.
The reporting table, generated by printing a <code>ptblank_multiagent</code> object or
by using the <code><a href="#topic+get_multiagent_report">get_multiagent_report()</a></code> function, is, by default, organized by
the interrogation time and it automatically recognizes which validation steps
are equivalent across interrogations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_multiagent(..., lang = NULL, locale = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_multiagent_+3A_...">...</code></td>
<td>
<p><em>Pointblank agents</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;series of obj:&lt;ptblank_agent&gt;&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>One or more <strong>pointblank</strong> agent objects.</p>
</td></tr>
<tr><td><code id="create_multiagent_+3A_lang">lang</code></td>
<td>
<p><em>Reporting language</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use for any reporting that will be generated from the
<em>multiagent</em>. (e.g., individual <em>agent reports</em>, <em>multiagent reports</em>,
etc.). By default, <code>NULL</code> will create English (<code>"en"</code>) text. Other options
include French (<code>"fr"</code>), German (<code>"de"</code>), Italian (<code>"it"</code>), Spanish
(<code>"es"</code>), Portuguese (<code>"pt"</code>), Turkish (<code>"tr"</code>), Chinese (<code>"zh"</code>), Russian
(<code>"ru"</code>), Polish (<code>"pl"</code>), Danish (<code>"da"</code>), Swedish (<code>"sv"</code>), and Dutch
(<code>"nl"</code>).</p>
</td></tr>
<tr><td><code id="create_multiagent_+3A_locale">locale</code></td>
<td>
<p><em>Locale for value formatting within reports</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional locale ID to use for formatting values in the reporting outputs
according the locale's rules. Examples include <code>"en_US"</code> for English
(United States) and <code>"fr_FR"</code> for French (France); more simply, this can be
a language identifier without a country designation, like &quot;es&quot; for Spanish
(Spain, same as <code>"es_ES"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_multiagent</code> object.
</p>


<h3>Examples</h3>

<p>For the example below, we'll use two different, yet simple tables.
</p>
<p>First, <code>tbl_1</code>:
</p>
<div class="sourceCode r"><pre>tbl_1 &lt;-
  dplyr::tibble(
    a = c(5, 5, 5, 5, 5, 5),
    b = c(1, 1, 1, 2, 2, 2),
    c = c(1, 1, 1, 2, 3, 4),
    d = LETTERS[a],
    e = LETTERS[b],
    f = LETTERS[c]
  )
  
tbl_1
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 E     A     A    
#&gt; 2     5     1     1 E     A     A    
#&gt; 3     5     1     1 E     A     A    
#&gt; 4     5     2     2 E     B     B    
#&gt; 5     5     2     3 E     B     C    
#&gt; 6     5     2     4 E     B     D
</pre></div>
<p>And next, <code>tbl_2</code>:
</p>
<div class="sourceCode r"><pre>tbl_2 &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5, 8, 7),
    b = LETTERS[1:6]
  )

tbl_2
#&gt; # A tibble: 6 x 2
#&gt;       a b    
#&gt;   &lt;dbl&gt; &lt;chr&gt;
#&gt; 1     5 A    
#&gt; 2     7 B    
#&gt; 3     6 C    
#&gt; 4     5 D    
#&gt; 5     8 E    
#&gt; 6     7 F
</pre></div>
<p>Next, we'll create two different agents, each interrogating a different
table.
</p>
<p>First up, is <code>agent_1</code>:
</p>
<div class="sourceCode r"><pre>agent_1 &lt;-
  create_agent(
    tbl = tbl_1,
    tbl_name = "tbl_1",
    label = "Example table 1."
  ) %&gt;%
  col_vals_gt(columns = a, value = 4) %&gt;%
  interrogate()
</pre></div>
<p>Then, <code>agent_2</code>:
</p>
<div class="sourceCode r"><pre>agent_2 &lt;-
  create_agent(
    tbl = tbl_2,
    tbl_name = "tbl_2",
    label = "Example table 2."
  ) %&gt;%
  col_is_character(columns = b) %&gt;%
  interrogate()
</pre></div>
<p>Now, we'll combine the two agents into a <em>multiagent</em> with the
<code>create_multiagent()</code> function. Printing the <code>"ptblank_multiagent"</code> object
displays the multiagent report with its default options (i.e., a 'long'
report view).
</p>
<div class="sourceCode r"><pre>multiagent &lt;- create_multiagent(agent_1, agent_2)
  
multiagent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_create_multiagent_1.png" alt="This image was generated from the first code example in the `create_multiagent()` help file." style="width:100%;">


<p>To take advantage of more display options, we could use the
<code><a href="#topic+get_multiagent_report">get_multiagent_report()</a></code> function. The added functionality there allows for
a 'wide' view of the data (useful for monitoring validations of the same
table over repeated interrogations), the ability to modify the title of the
multiagent report, and a means to export the report to HTML (via
<code><a href="#topic+export_report">export_report()</a></code>).
</p>


<h3>Function ID</h3>

<p>10-1
</p>


<h3>See Also</h3>

<p>Other The multiagent: 
<code><a href="#topic+get_multiagent_report">get_multiagent_report</a>()</code>,
<code><a href="#topic+read_disk_multiagent">read_disk_multiagent</a>()</code>
</p>

<hr>
<h2 id='db_tbl'>Get a table from a database</h2><span id='topic+db_tbl'></span>

<h3>Description</h3>

<p>If your target table is in a database, the <code>db_tbl()</code> function is a handy way
of accessing it. This function simplifies the process of getting a <code>tbl_dbi</code>
object, which usually involves a combination of building a connection to a
database and using the <code>dplyr::tbl()</code> function with the connection and the
table name (or a reference to a table in a schema). You can use <code>db_tbl()</code> as
the basis for obtaining a database table for the <code>tbl</code> parameter in
<code><a href="#topic+create_agent">create_agent()</a></code> or <code><a href="#topic+create_informant">create_informant()</a></code>. Another great option is supplying a
table-prep formula involving <code>db_tbl()</code> to <code><a href="#topic+tbl_store">tbl_store()</a></code> so that you have
access to database tables though single names via a table store.
</p>
<p>The username and password are supplied through environment variable names. If
desired, values for the username and password can be supplied directly by
enclosing such values in <code><a href="base.html#topic+I">I()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_tbl(
  table,
  dbtype,
  dbname = NULL,
  host = NULL,
  port = NULL,
  user = NULL,
  password = NULL,
  bq_project = NULL,
  bq_dataset = NULL,
  bq_billing = bq_project
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="db_tbl_+3A_table">table</code></td>
<td>
<p>The name of the table, or, a reference to a table in a schema
(two-element vector with the names of schema and table). Alternatively,
this can be supplied as a data table to copy into an in-memory database
connection. This only works if: (1) the <code>db</code> is chosen as either <code>"sqlite"</code>
or <code>"duckdb"</code>, (2) the <code>dbname</code> was is set to <code>":memory:"</code>, and (3) the
object supplied to <code>table</code> is a data frame or a tibble object.</p>
</td></tr>
<tr><td><code id="db_tbl_+3A_dbtype">dbtype</code></td>
<td>
<p>Either an appropriate driver function (e.g.,
<code>RPostgres::Postgres()</code>) or a shortname for the database type. Valid names
are: <code>"postgresql"</code>, <code>"postgres"</code>, or <code>"pgsql"</code> (PostgreSQL, using the
<code>RPostgres::Postgres()</code> driver function); <code>"mysql"</code> (MySQL, using
<code>RMySQL::MySQL()</code>); <code>bigquery</code> or <code>bq</code> (BigQuery, using
<code>bigrquery::bigquery()</code>); <code>"duckdb"</code> (DuckDB, using <code>duckdb::duckdb()</code>);
and <code>"sqlite"</code> (SQLite, using <code>RSQLite::SQLite()</code>).</p>
</td></tr>
<tr><td><code id="db_tbl_+3A_dbname">dbname</code></td>
<td>
<p>The database name.</p>
</td></tr>
<tr><td><code id="db_tbl_+3A_host">host</code>, <code id="db_tbl_+3A_port">port</code></td>
<td>
<p>The database host and optional port number.</p>
</td></tr>
<tr><td><code id="db_tbl_+3A_user">user</code>, <code id="db_tbl_+3A_password">password</code></td>
<td>
<p>The environment variables used to access the username
and password for the database. Enclose in <code><a href="base.html#topic+I">I()</a></code> when using literal username
or password values.</p>
</td></tr>
<tr><td><code id="db_tbl_+3A_bq_project">bq_project</code>, <code id="db_tbl_+3A_bq_dataset">bq_dataset</code>, <code id="db_tbl_+3A_bq_billing">bq_billing</code></td>
<td>
<p>If accessing a table from a
<em>BigQuery</em> data source, there's the requirement to provide the table's
associated project (<code>bq_project</code>) and dataset (<code>bq_dataset</code>) names. By
default, the project to be billed will be the same as the one provided for
<code>bq_project</code> but the <code>bq_billing</code> argument can be changed to reflect a
different BigQuery project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tbl_dbi</code> object.
</p>


<h3>Examples</h3>



<h4>Obtaining in-memory database tables</h4>

<p>You can use an in-memory database table and by supplying it with an in-memory
table. This works with the DuckDB database and the key thing is to use
<code>dbname = ":memory"</code> in the <code>db_tbl()</code> call.
</p>
<div class="sourceCode r"><pre>small_table_duckdb &lt;- 
  db_tbl(
    table = small_table,
    dbtype = "duckdb",
    dbname = ":memory:"
  )

small_table_duckdb
</pre></div>
<pre>## # Source:   table&lt;small_table&gt; [?? x 8]
## # Database: duckdb_connection
##    date_time           date           a b         c      d e     f    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bc…     3  3423. TRUE  high 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-eg…     8 10000. TRUE  low  
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kd…     3  2343. TRUE  high 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jd…    NA  3892. FALSE mid  
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ld…     7   284. TRUE  low  
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dh…     4  3291. TRUE  mid  
##  7 2016-01-15 18:46:00 2016-01-15     7 1-kn…     3   843. TRUE  high 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-bo…     2  1036. FALSE low  
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bc…     9   838. FALSE high 
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bc…     9   838. FALSE high 
## # … with more rows</pre>
<p>The in-memory option also works using the SQLite database. The only change
required is setting the <code>dbtype</code> to <code>"sqlite"</code>:
</p>
<div class="sourceCode r"><pre>small_table_sqlite &lt;- 
  db_tbl(
    table = small_table,
    dbtype = "sqlite",
    dbname = ":memory:"
  )

small_table_sqlite
</pre></div>
<pre>## # Source:   table&lt;small_table&gt; [?? x 8]
## # Database: sqlite 3.37.0 [:memory:]
##     date_time  date     a b             c      d     e f    
##         &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;
##  1 1451905200 16804     2 1-bcd-345     3  3423.     1 high 
##  2 1451867520 16804     3 5-egh-163     8 10000.     1 low  
##  3 1452000720 16805     6 8-kdg-938     3  2343.     1 high 
##  4 1452100980 16806     2 5-jdo-903    NA  3892.     0 mid  
##  5 1452342960 16809     8 3-ldm-038     7   284.     1 low  
##  6 1452492900 16811     4 2-dhe-923     4  3291.     1 mid  
##  7 1452883560 16815     7 1-knw-093     3   843.     1 high 
##  8 1453030020 16817     4 5-boe-639     2  1036.     0 low  
##  9 1453264200 16820     3 5-bce-642     9   838.     0 high 
## 10 1453264200 16820     3 5-bce-642     9   838.     0 high 
## # … with more rows</pre>
<p>It's also possible to obtain a table from a remote file and shove it into an
in-memory database. For this, we can use the all-powerful <code><a href="#topic+file_tbl">file_tbl()</a></code> +
<code>db_tbl()</code> combo.
</p>
<div class="sourceCode r"><pre>all_revenue_large_duckdb &lt;-
  db_tbl(
    table = file_tbl(
      file = from_github(
        file = "sj_all_revenue_large.rds",
        repo = "rich-iannone/intendo",
        subdir = "data-large"
      )
    ),
    dbtype = "duckdb",
    dbname = ":memory:"
  )
  
all_revenue_large_duckdb
</pre></div>
<pre>## # Source:   table&lt;sj_all_revenue_large.rds&gt; [?? x 11]
## # Database: duckdb_connection
##    player_id       session_id   session_start       time               
##    &lt;chr&gt;           &lt;chr&gt;        &lt;dttm&gt;              &lt;dttm&gt;             
##  1 IRZKSAOYUJME796 IRZKSAOYUJM… 2015-01-01 00:18:41 2015-01-01 00:18:53
##  2 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:13:07
##  3 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:23:37
##  4 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:24:37
##  5 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:31:01
##  6 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:31:43
##  7 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:36:01
##  8 ECPANOIXLZHF896 ECPANOIXLZH… 2015-01-01 01:31:03 2015-01-01 01:31:27
##  9 ECPANOIXLZHF896 ECPANOIXLZH… 2015-01-01 01:31:03 2015-01-01 01:36:57
## 10 ECPANOIXLZHF896 ECPANOIXLZH… 2015-01-01 01:31:03 2015-01-01 01:37:45
## # … with more rows, and 7 more variables: item_type &lt;chr&gt;,
## #   item_name &lt;chr&gt;, item_revenue &lt;dbl&gt;, session_duration &lt;dbl&gt;,
## #   start_day &lt;date&gt;, acquisition &lt;chr&gt;, country &lt;chr&gt;</pre>
<p>And that's really it.
</p>



<h4>Obtaining remote database tables</h4>

<p>For remote databases, we have to specify quite a few things but it's a
one-step process nonetheless. Here's an example that accesses the <code>rna</code> table
(in the <em>RNA Central</em> public database) using <code>db_tbl()</code>. Here, for the <code>user</code>
and <code>password</code> entries we are using the literal username and password values
(publicly available when visiting the <em>RNA Central</em> website) by enclosing the
values in <code>I()</code>.
</p>
<div class="sourceCode r"><pre>rna_db_tbl &lt;- 
  db_tbl(
    table = "rna",
    dbtype = "postgres",
    dbname = "pfmegrnargs",
    host = "hh-pgsql-public.ebi.ac.uk",
    port = 5432,
    user = I("reader"),
    password = I("NWDMCE5xdipIjRrp")
  )

rna_db_tbl
</pre></div>
<pre>## # Source:   table&lt;rna&gt; [?? x 9]
## # Database: postgres
## #   [reader@hh-pgsql-public.ebi.ac.uk:5432/pfmegrnargs]
##          id upi    timestamp           userstamp crc64   len seq_short
##     &lt;int64&gt; &lt;chr&gt;  &lt;dttm&gt;              &lt;chr&gt;     &lt;chr&gt; &lt;int&gt; &lt;chr&gt;    
##  1 25222431 URS00… 2019-12-02 13:26:46 rnacen    E65C…   521 AGAGTTTG…
##  2 25222432 URS00… 2019-12-02 13:26:46 rnacen    6B91…   520 AGAGTTCG…
##  3 25222433 URS00… 2019-12-02 13:26:46 rnacen    03B8…   257 TACGTAGG…
##  4 25222434 URS00… 2019-12-02 13:26:46 rnacen    E925…   533 AGGGTTTG…
##  5 25222435 URS00… 2019-12-02 13:26:46 rnacen    C2D0…   504 GACGAACG…
##  6 25222436 URS00… 2019-12-02 13:26:46 rnacen    9EF6…   253 TACAGAGG…
##  7 25222437 URS00… 2019-12-02 13:26:46 rnacen    685A…   175 GAGGCAGC…
##  8 25222438 URS00… 2019-12-02 13:26:46 rnacen    4228…   556 AAAACATC…
##  9 25222439 URS00… 2019-12-02 13:26:46 rnacen    B7CC…   515 AGGGTTCG…
## 10 25222440 URS00… 2019-12-02 13:26:46 rnacen    038B…   406 ATTGAACG…
## # … with more rows, and 2 more variables: seq_long &lt;chr&gt;, md5 &lt;chr&gt;</pre>
<p>You'd normally want to use the names of environment variables (envvars) to
more securely access the appropriate username and password values when
connecting to a DB. Here are all the necessary inputs:
</p>
<div class="sourceCode r"><pre>example_db_tbl &lt;- 
  db_tbl(
    table = "&lt;table_name&gt;",
    dbtype = "&lt;database_type_shortname&gt;",
    dbname = "&lt;database_name&gt;",
    host = "&lt;connection_url&gt;",
    port = "&lt;connection_port&gt;",
    user = "&lt;DB_USER_NAME&gt;",
    password = "&lt;DB_PASSWORD&gt;"
  )
</pre></div>
<p>Environment variables can be created by editing the user <code>.Renviron</code> file and
the <code>usethis::edit_r_environ()</code> function makes this pretty easy to do.
</p>



<h4>DB table access and prep via the table store</h4>

<p>Using table-prep formulas in a centralized table store can make it easier to
work with DB tables in <strong>pointblank</strong>. Here's how to generate a table store
with two named entries for table preparations involving the <code><a href="#topic+tbl_store">tbl_store()</a></code> and
<code>db_tbl()</code> functions.
</p>
<div class="sourceCode r"><pre>store &lt;-
  tbl_store(
    small_table_duck ~ db_tbl(
      table = pointblank::small_table,
      dbtype = "duckdb",
      dbname = ":memory:"
    ),
    small_high_duck ~ {{ small_table_duck }} %&gt;%
      dplyr::filter(f == "high")
  )
</pre></div>
<p>Now it's easy to obtain either of these tables via <code><a href="#topic+tbl_get">tbl_get()</a></code>. We can
reference the table in the store by its name (given to the left of the <code>~</code>).
</p>
<div class="sourceCode r"><pre>tbl_get(tbl = "small_table_duck", store = store)
</pre></div>
<pre>## # Source:   table&lt;pointblank::small_table&gt; [?? x 8]
## # Database: duckdb_connection
##    date_time           date           a b           c      d e    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-…     3  3423. TRUE 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-…     8 10000. TRUE 
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-…     3  2343. TRUE 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-…    NA  3892. FALSE
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-…     7   284. TRUE 
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-…     4  3291. TRUE 
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-…     3   843. TRUE 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-…     2  1036. FALSE
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE
## # … with more rows, and 1 more variable: f &lt;chr&gt;</pre>
<p>The second table in the table store is a mutated
version of the first. It's just as easily obtainable via <code><a href="#topic+tbl_get">tbl_get()</a></code>:
</p>
<div class="sourceCode"><pre>tbl_get(tbl = "small_high_duck", store = store)
</pre></div>
<pre>## # Source:   lazy query [?? x 8]
## # Database: duckdb_connection
##   date_time           date           a b             c     d e    
##   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3 3423. TRUE 
## 2 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3 2343. TRUE 
## 3 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE 
## 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE
## 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE
## 6 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE 
## # … with more rows, and 1 more variable: f &lt;chr&gt;</pre>
<p>The table-prep formulas in the <code>store</code> object could also be used in functions
with a <code>tbl</code> argument (like <code><a href="#topic+create_agent">create_agent()</a></code> and <code><a href="#topic+create_informant">create_informant()</a></code>). This
is accomplished most easily with the <code><a href="#topic+tbl_source">tbl_source()</a></code> function.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ tbl_source(
      tbl = "small_table_duck",
      store = tbls
    )
  )
</pre></div>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ tbl_source(
      tbl = "small_high_duck",
      store = tbls
    )
  )
</pre></div>



<h3>Function ID</h3>

<p>1-6
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='deactivate_steps'>Deactivate one or more of an <em>agent</em>'s validation steps</h2><span id='topic+deactivate_steps'></span>

<h3>Description</h3>

<p>Should the deactivation of one or more validation steps be necessary after
creation of the validation plan for an <em>agent</em>, the <code>deactivate_steps()</code>
function will be helpful for that. This has the same effect as using the
<code>active = FALSE</code> option (<code>active</code> is an argument in all validation functions)
for the selected validation steps. Please note that this directly edits the
validation step, wiping out any function that may have been defined for
whether the step should be active or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deactivate_steps(agent, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deactivate_steps_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function.</p>
</td></tr>
<tr><td><code id="deactivate_steps_+3A_i">i</code></td>
<td>
<p><em>A validation step number</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The validation step number, which is assigned to each validation step in
the order of definition. If <code>NULL</code> (the default) then step deactivation
won't occur by index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_agent</code> object.
</p>


<h3>Function ID</h3>

<p>9-6
</p>


<h3>See Also</h3>

<p>For the opposite behavior, use the <code><a href="#topic+activate_steps">activate_steps()</a></code> function.
</p>
<p>Other Object Ops: 
<code><a href="#topic+activate_steps">activate_steps</a>()</code>,
<code><a href="#topic+export_report">export_report</a>()</code>,
<code><a href="#topic+remove_steps">remove_steps</a>()</code>,
<code><a href="#topic+set_tbl">set_tbl</a>()</code>,
<code><a href="#topic+x_read_disk">x_read_disk</a>()</code>,
<code><a href="#topic+x_write_disk">x_write_disk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an agent that has the
# `small_table` object as the
# target table, add a few
# validation steps, and then use
# `interrogate()`
agent_1 &lt;- 
  create_agent(
    tbl = small_table,
    tbl_name = "small_table",
    label = "An example."
  ) %&gt;%
  col_exists(columns = date) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]"
  ) %&gt;%
  interrogate()
  
# The second validation step is
# now being reconsidered and may
# be either phased out or improved
# upon; in the interim period it
# was decided that the step should
# be deactivated for now
agent_2 &lt;-
  agent_1 %&gt;%
  deactivate_steps(i = 2) %&gt;%
  interrogate()

</code></pre>

<hr>
<h2 id='draft_validation'>Draft a starter <strong>pointblank</strong> validation .R/.Rmd file with a data table</h2><span id='topic+draft_validation'></span>

<h3>Description</h3>

<p>Generate a draft validation plan in a new .R or .Rmd file using an input data
table. Using this workflow, the data table will be scanned to learn about its
column data and a set of starter validation steps (constituting a validation
plan) will be written. It's best to use a data extract that contains at least
1000 rows and is relatively free of spurious data.
</p>
<p>Once in the file, it's possible to tweak the validation steps to better fit
the expectations to the particular domain. While column inference is used to
generate reasonable validation plans, it is difficult to infer the acceptable
values without domain expertise. However, using <code>draft_validation()</code> could
get you started on floor 10 of tackling data quality issues and is in any
case better than starting with an empty code editor view.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draft_validation(
  tbl,
  tbl_name = NULL,
  filename = tbl_name,
  path = NULL,
  lang = NULL,
  output_type = c("R", "Rmd"),
  add_comments = TRUE,
  overwrite = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draft_validation_+3A_tbl">tbl</code></td>
<td>
<p><em>A data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The input table. This can be a data frame, tibble, a <code>tbl_dbi</code> object, or a
<code>tbl_spark</code> object.</p>
</td></tr>
<tr><td><code id="draft_validation_+3A_tbl_name">tbl_name</code></td>
<td>
<p><em>A table name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A optional name to assign to the input table object. If no value is
provided, a name will be generated based on whatever information is
available. This table name will be displayed in the header area of the
agent report generated by printing the <em>agent</em> or calling
<code><a href="#topic+get_agent_report">get_agent_report()</a></code>.</p>
</td></tr>
<tr><td><code id="draft_validation_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>tbl_name</code>
</p>
<p>An optional name for the .R or .Rmd file. This should be a name without an
extension. By default, this is taken from the <code>tbl_name</code> but if nothing is
supplied for that, the name will contain the text <code>"draft_validation_"</code>
followed by the current date and time.</p>
</td></tr>
<tr><td><code id="draft_validation_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A path can be specified here if there shouldn't be an attempt to place the
generated file in the working directory.</p>
</td></tr>
<tr><td><code id="draft_validation_+3A_lang">lang</code></td>
<td>
<p><em>Commenting language</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use when creating comments for the automatically- generated
validation steps. By default, <code>NULL</code> will create English (<code>"en"</code>) text.
Other options include French (<code>"fr"</code>), German (<code>"de"</code>), Italian (<code>"it"</code>),
Spanish (<code>"es"</code>), Portuguese (<code>"pt"</code>), Turkish (<code>"tr"</code>), Chinese (<code>"zh"</code>),
Russian (<code>"ru"</code>), Polish (<code>"pl"</code>), Danish (<code>"da"</code>), Swedish (<code>"sv"</code>), and
Dutch (<code>"nl"</code>).</p>
</td></tr>
<tr><td><code id="draft_validation_+3A_output_type">output_type</code></td>
<td>
<p><em>The output file type</em>
</p>
<p><code style="white-space: pre;">&#8288;singl-kw:[R|Rmd]&#8288;</code> // <em>default:</em> <code>"R"</code>
</p>
<p>An option for choosing what type of output should be generated. By default,
this is an .R script (<code>"R"</code>) but this could alternatively be an R Markdown
document (<code>"Rmd"</code>).</p>
</td></tr>
<tr><td><code id="draft_validation_+3A_add_comments">add_comments</code></td>
<td>
<p><em>Add comments to the generated validation plan</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>Should there be comments that explain the features of the validation plan
in the generated document?</p>
</td></tr>
<tr><td><code id="draft_validation_+3A_overwrite">overwrite</code></td>
<td>
<p><em>Overwrite a previous file of the same name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should a file of the same name be overwritten?</p>
</td></tr>
<tr><td><code id="draft_validation_+3A_quiet">quiet</code></td>
<td>
<p><em>Inform (or not) upon file writing</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the function <em>not</em> inform when the file is written?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if the file has been written.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Examples</h3>

<p>Let's draft a validation plan for the <code>dplyr::storms</code> dataset.
</p>
<div class="sourceCode r"><pre>dplyr::storms
#&gt; # A tibble: 19,537 x 13
#&gt;    name   year month   day  hour   lat  long status      category  wind pressure
#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;          &lt;dbl&gt; &lt;int&gt;    &lt;int&gt;
#&gt;  1 Amy    1975     6    27     0  27.5 -79   tropical d~       NA    25     1013
#&gt;  2 Amy    1975     6    27     6  28.5 -79   tropical d~       NA    25     1013
#&gt;  3 Amy    1975     6    27    12  29.5 -79   tropical d~       NA    25     1013
#&gt;  4 Amy    1975     6    27    18  30.5 -79   tropical d~       NA    25     1013
#&gt;  5 Amy    1975     6    28     0  31.5 -78.8 tropical d~       NA    25     1012
#&gt;  6 Amy    1975     6    28     6  32.4 -78.7 tropical d~       NA    25     1012
#&gt;  7 Amy    1975     6    28    12  33.3 -78   tropical d~       NA    25     1011
#&gt;  8 Amy    1975     6    28    18  34   -77   tropical d~       NA    30     1006
#&gt;  9 Amy    1975     6    29     0  34.4 -75.8 tropical s~       NA    35     1004
#&gt; 10 Amy    1975     6    29     6  34   -74.8 tropical s~       NA    40     1002
#&gt; # i 19,527 more rows
#&gt; # i 2 more variables: tropicalstorm_force_diameter &lt;int&gt;,
#&gt; #   hurricane_force_diameter &lt;int&gt;
</pre></div>
<p>The <code>draft_validation()</code> function creates an .R file by default. Using just
the defaults with <code>dplyr::storms</code> will yield the <code>"dplyr__storms.R"</code> file
in the working directory. Here are the contents of the file:
</p>
<div class="sourceCode r"><pre>library(pointblank)

agent &lt;-
  create_agent(
    tbl = ~ dplyr::storms,
    actions = action_levels(
      warn_at = 0.05,
      stop_at = 0.10
    ),
    tbl_name = "dplyr::storms",
    label = "Validation plan generated by `draft_validation()`."
  ) %&gt;%
  # Expect that column `name` is of type: character
  col_is_character(
    columns = name
  ) %&gt;%
  # Expect that column `year` is of type: numeric
  col_is_numeric(
    columns = year
  ) %&gt;%
  # Expect that values in `year` should be between `1975` and `2020`
  col_vals_between(
    columns = year,
    left = 1975,
    right = 2020
  ) %&gt;%
  # Expect that column `month` is of type: numeric
  col_is_numeric(
    columns = month
  ) %&gt;%
  # Expect that values in `month` should be between `1` and `12`
  col_vals_between(
    columns = month,
    left = 1,
    right = 12
  ) %&gt;%
  # Expect that column `day` is of type: integer
  col_is_integer(
    columns = day
  ) %&gt;%
  # Expect that values in `day` should be between `1` and `31`
  col_vals_between(
    columns = day,
    left = 1,
    right = 31
  ) %&gt;%
  # Expect that column `hour` is of type: numeric
  col_is_numeric(
    columns = hour
  ) %&gt;%
  # Expect that values in `hour` should be between `0` and `23`
  col_vals_between(
    columns = hour,
    left = 0,
    right = 23
  ) %&gt;%
  # Expect that column `lat` is of type: numeric
  col_is_numeric(
    columns = lat
  ) %&gt;%
  # Expect that values in `lat` should be between `-90` and `90`
  col_vals_between(
    columns = lat,
    left = -90,
    right = 90
  ) %&gt;%
  # Expect that column `long` is of type: numeric
  col_is_numeric(
    columns = long
  ) %&gt;%
  # Expect that values in `long` should be between `-180` and `180`
  col_vals_between(
    columns = long,
    left = -180,
    right = 180
  ) %&gt;%
  # Expect that column `status` is of type: character
  col_is_character(
    columns = status
  ) %&gt;%
  # Expect that column `category` is of type: factor
  col_is_factor(
    columns = category
  ) %&gt;%
  # Expect that column `wind` is of type: integer
  col_is_integer(
    columns = wind
  ) %&gt;%
  # Expect that values in `wind` should be between `10` and `160`
  col_vals_between(
    columns = wind,
    left = 10,
    right = 160
  ) %&gt;%
  # Expect that column `pressure` is of type: integer
  col_is_integer(
    columns = pressure
  ) %&gt;%
  # Expect that values in `pressure` should be between `882` and `1022`
  col_vals_between(
    columns = pressure,
    left = 882,
    right = 1022
  ) %&gt;%
  # Expect that column `tropicalstorm_force_diameter` is of type: integer
  col_is_integer(
    columns = tropicalstorm_force_diameter
  ) %&gt;%
  # Expect that values in `tropicalstorm_force_diameter` should be between
  # `0` and `870`
  col_vals_between(
    columns = tropicalstorm_force_diameter,
    left = 0,
    right = 870,
    na_pass = TRUE
  ) %&gt;%
  # Expect that column `hurricane_force_diameter` is of type: integer
  col_is_integer(
    columns = hurricane_force_diameter
  ) %&gt;%
  # Expect that values in `hurricane_force_diameter` should be between
  # `0` and `300`
  col_vals_between(
    columns = hurricane_force_diameter,
    left = 0,
    right = 300,
    na_pass = TRUE
  ) %&gt;%
  # Expect entirely distinct rows across all columns
  rows_distinct() %&gt;%
  # Expect that column schemas match
  col_schema_match(
    schema = col_schema(
      name = "character",
      year = "numeric",
      month = "numeric",
      day = "integer",
      hour = "numeric",
      lat = "numeric",
      long = "numeric",
      status = "character",
      category = c("ordered", "factor"),
      wind = "integer",
      pressure = "integer",
      tropicalstorm_force_diameter = "integer",
      hurricane_force_diameter = "integer"
    )
  ) %&gt;%
  interrogate()

agent
</pre></div>
<p>This is runnable as is, and the promise is that the interrogation should
produce no failing test units. After execution, we get the following
validation report:
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_draft_validation_1.png" alt="This image was generated from the first code example in the `draft_validation()` help file." style="width:100%;">


<p>All of the expressions in the resulting file constitute just a rough
approximation of what a validation plan should be for a dataset. Certainly,
the value ranges in the emitted <code><a href="#topic+col_vals_between">col_vals_between()</a></code> may not be realistic for
the <code>wind</code> column and may require some modification (the provided <code>left</code> and
<code>right</code> values are just the limits of the provided data). However, note that
the <code>lat</code> and <code>long</code> (latitude and longitude) columns have acceptable ranges
(providing the limits of valid lat/lon values). This is thanks to
<strong>pointblank</strong>'s column inference routines, which is able to understand what
certain columns contain.
</p>
<p>For an evolving dataset that will experience changes (either in the form of
revised data and addition/deletion of rows or columns), the emitted
validation will serve as a good first step and changes can more easily be
made since there is a foundation to build from.
</p>


<h3>Function ID</h3>

<p>1-11
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='email_blast'>Conditionally send email during interrogation</h2><span id='topic+email_blast'></span>

<h3>Description</h3>

<p>The <code>email_blast()</code> function is useful for sending an email message that
explains the result of a <strong>pointblank</strong> validation. It is powered by the
<strong>blastula</strong> and <strong>glue</strong> packages. This function should be invoked as part
of the <code>end_fns</code> argument of <code><a href="#topic+create_agent">create_agent()</a></code>. It's also possible to invoke
<code>email_blast()</code> as part of the <code>fns</code> argument of the <code><a href="#topic+action_levels">action_levels()</a></code>
function (i.e., to send multiple email messages at the granularity of
different validation steps exceeding failure thresholds).
</p>
<p>To better get a handle on emailing with <code>email_blast()</code>, the analogous
<code><a href="#topic+email_create">email_create()</a></code> function can be used with a <strong>pointblank</strong> agent object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>email_blast(
  x,
  to,
  from,
  credentials = NULL,
  msg_subject = NULL,
  msg_header = NULL,
  msg_body = stock_msg_body(),
  msg_footer = stock_msg_footer(),
  send_condition = ~TRUE %in% x$notify
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="email_blast_+3A_x">x</code></td>
<td>
<p>A reference to the x-list object prepared internally by the agent.
This version of the x-list is the same as that generated via
<code style="white-space: pre;">&#8288;get_agent_x_list(&lt;agent&gt;)&#8288;</code> except this version is internally generated and
hence only available in an internal evaluation context.</p>
</td></tr>
<tr><td><code id="email_blast_+3A_to">to</code>, <code id="email_blast_+3A_from">from</code></td>
<td>
<p>The email addresses for the recipients and of the sender.</p>
</td></tr>
<tr><td><code id="email_blast_+3A_credentials">credentials</code></td>
<td>
<p>A credentials list object that is produced by either of
the <code><a href="blastula.html#topic+credential_helpers">blastula::creds()</a></code>, <code><a href="blastula.html#topic+credential_helpers">blastula::creds_anonymous()</a></code>,
<code><a href="blastula.html#topic+credential_helpers">blastula::creds_key()</a></code>, or <code><a href="blastula.html#topic+credential_helpers">blastula::creds_file()</a></code> functions. Please
refer to the <strong>blastula</strong> documentation for information on how to use these
functions.</p>
</td></tr>
<tr><td><code id="email_blast_+3A_msg_subject">msg_subject</code></td>
<td>
<p>The subject line of the email message.</p>
</td></tr>
<tr><td><code id="email_blast_+3A_msg_header">msg_header</code>, <code id="email_blast_+3A_msg_body">msg_body</code>, <code id="email_blast_+3A_msg_footer">msg_footer</code></td>
<td>
<p>Content for the header, body, and
footer components of the HTML email message.</p>
</td></tr>
<tr><td><code id="email_blast_+3A_send_condition">send_condition</code></td>
<td>
<p>An expression that should evaluate to a logical vector
of length 1. If evaluated as <code>TRUE</code> then the email will be sent, if <code>FALSE</code>
then that won't happen. The expression can use x-list variables (e.g.,
<code>x$notify</code>, <code>x$type</code>, etc.) and all of those variables can be explored
using the <code><a href="#topic+get_agent_x_list">get_agent_x_list()</a></code> function. The default expression is <code>~ TRUE %in% x$notify</code>, which results in <code>TRUE</code> if there are any <code>TRUE</code> values in
the <code>x$notify</code> logical vector (i.e., any validation step that results in a
'notify' state).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned. The end result is the side-effect of
email-sending if certain conditions are met.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). Here is an
example of how the use of <code>email_blast()</code> inside the <code>end_fns</code> argument of
<code><a href="#topic+create_agent">create_agent()</a></code> is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>create_agent(
  tbl = ~ small_table,
  tbl_name = "small_table",
  label = "An example.",
  actions = al,
  end_fns = list(
    ~ email_blast(
      x,
      to = "joe_public@example.com",
      from = "pb_notif@example.com",
      msg_subject = "Table Validation",
      credentials = blastula::creds_key(
        id = "smtp2go"
      )
    )
  )
) %&gt;%
  col_vals_gt(a, 1) %&gt;%
  col_vals_lt(a, 7) 
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>type: agent
tbl: ~small_table
tbl_name: small_table
label: An example.
lang: en
locale: en
actions:
  warn_count: 1.0
  notify_count: 2.0
end_fns: ~email_blast(x, to = "joe_public@example.com", 
  from = "pb_notif@example.com", msg_subject = "Table Validation",
  credentials = blastula::creds_key(id = "smtp2go"),
  )
embed_report: true
steps:
- col_vals_gt:
    columns: c(a)
    value: 1.0
- col_vals_lt:
    columns: c(a)
    value: 7.0
</pre></div>


<h3>Examples</h3>

<p>For the example provided here, we'll use the included <code>small_table</code> dataset.
We are also going to create an <code>action_levels()</code> list object since this is
useful for demonstrating an emailing scenario. It will have absolute values
for the <code>warn</code> and <code>notify</code> states (with thresholds of <code>1</code> and <code>2</code> 'fail'
units, respectively, for the two states).
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 1,
    notify_at = 2
  )
</pre></div>
<p>Validate that values in column <code>a</code> from <code>small_tbl</code> are always greater than
<code>1</code> (with the <code>col_vals_gt()</code> validation function), and, that values in <code>a</code>
or are always less than <code>7</code>.
</p>
<p>The <code>email_blast()</code> function call is used in a list given to the <code>end_fns</code>
argument of <code>create_agent()</code>. The <code>email_blast()</code> call itself has a
<code>send_condition</code> argument that determines whether or not an email will be
sent. By default this is set to <code>~ TRUE %in% x$notify</code>. Let's unpack this a
bit. The variable <code>x</code> is a list (we call it an x-list) and it will be
populated with elements pertaining to the agent. After interrogation, and
only if action levels were set for the <code>notify</code> state, <code>x$notify</code> will be
present as a logical vector where the length corresponds to the number of
validation steps. Thus, if any of those steps entered the <code>notify</code> state
(here, it would take two or more failing test units, per step, for that to
happen), then the statement as a whole is <code>TRUE</code> and the email of the
interrogation report will be sent. Here is the complete set of statements for
the creation of an <em>agent</em>, the addition of validation steps, and the
interrogation of data in <code>small_table</code>:
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(
    tbl = small_table,
    tbl_name = "small_table",
    label = "An example.",
    actions = al,
    end_fns = list(
      ~ email_blast(
        x,
        to =   "a_person@example.com",
        from = "pb_notif@example.com",
        msg_subject = "Table Validation",
        credentials = blastula::creds_key(id = "smtp2go"),
        send_condition = ~ TRUE %in% x$notify
      )
    )
  ) %&gt;%
  col_vals_gt(a, value = 1) %&gt;%
  col_vals_lt(a, value = 7) %&gt;%
  interrogate()
</pre></div>
<p>The reason for the <code>~</code> present in the statements:
</p>

<ul>
<li> <p><code>~ email_blast(...)</code> and
</p>
</li>
<li> <p><code>~ TRUE %in% x$notify</code>
</p>
</li></ul>

<p>is because this defers evocation of the emailing functionality (and also
defers evaluation of the <code>send_condition</code> value) until interrogation is
complete (with <code><a href="#topic+interrogate">interrogate()</a></code>).
</p>


<h3>Function ID</h3>

<p>4-1
</p>


<h3>See Also</h3>

<p>Other Emailing: 
<code><a href="#topic+email_create">email_create</a>()</code>,
<code><a href="#topic+stock_msg_body">stock_msg_body</a>()</code>,
<code><a href="#topic+stock_msg_footer">stock_msg_footer</a>()</code>
</p>

<hr>
<h2 id='email_create'>Create an email object from a <strong>pointblank</strong> <em>agent</em></h2><span id='topic+email_create'></span>

<h3>Description</h3>

<p>The <code>email_create()</code> function produces an email message object that could be
sent using the <strong>blastula</strong> package. By supplying a <strong>pointblank</strong> agent, a
<strong>blastula</strong> <code>email_message</code> message object will be created and printing it
will make the HTML email message appear in the Viewer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>email_create(
  x,
  msg_header = NULL,
  msg_body = stock_msg_body(),
  msg_footer = stock_msg_footer()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="email_create_+3A_x">x</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function.</p>
</td></tr>
<tr><td><code id="email_create_+3A_msg_header">msg_header</code>, <code id="email_create_+3A_msg_body">msg_body</code>, <code id="email_create_+3A_msg_footer">msg_footer</code></td>
<td>
<p>Content for the header, body, and
footer components of the HTML email message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <strong>blastula</strong> <code>email_message</code> object.
</p>


<h3>Examples</h3>

<p>For the example provided here, we'll use the included <code>small_table</code> dataset.
We are also going to create an <code>action_levels()</code> list object since this is
useful for demonstrating an emailing scenario. It will have absolute values
for the <code>warn</code> and <code>notify</code> states (with thresholds of <code>1</code> and <code>2</code> 'fail'
units, respectively, for the two states).
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 1,
    notify_at = 2
  )
</pre></div>
<p>In a workflow that involves an <code>agent</code> object, we can make use of the
<code>end_fns</code> argument and programmatically email the report with the
<code><a href="#topic+email_blast">email_blast()</a></code> function. However, an alternate workflow that is demonstrated
here is to produce the email object directly. This provides the flexibility
to send the email outside of the <strong>pointblank</strong> API. The <code>email_create()</code>
function lets us do this with an <code>agent</code> object. We can then view the HTML
email just by printing <code>email_object</code>. It should appear in the Viewer.
</p>
<div class="sourceCode r"><pre>email_object &lt;-
  create_agent(
    tbl = small_table,
    tbl_name = "small_table",
    label = "An example.",
    actions = al
  ) %&gt;%
  col_vals_gt(a, value = 1) %&gt;%
  col_vals_lt(a, value = 7) %&gt;%
  interrogate() %&gt;%
  email_create()
  
email_object
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_email_create_1.png" alt="This image was generated from the first code example in the `email_create()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>4-2
</p>


<h3>See Also</h3>

<p>Other Emailing: 
<code><a href="#topic+email_blast">email_blast</a>()</code>,
<code><a href="#topic+stock_msg_body">stock_msg_body</a>()</code>,
<code><a href="#topic+stock_msg_footer">stock_msg_footer</a>()</code>
</p>

<hr>
<h2 id='export_report'>Export an <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or table scan to HTML</h2><span id='topic+export_report'></span>

<h3>Description</h3>

<p>The <em>agent</em>, <em>informant</em>, <em>multiagent</em>, and the table scan object can be
easily written as HTML with <code>export_report()</code>. Furthermore, any report
objects from the <em>agent</em>, <em>informant</em>, and <em>multiagent</em> (generated using
<code><a href="#topic+get_agent_report">get_agent_report()</a></code>, <code><a href="#topic+get_informant_report">get_informant_report()</a></code>, and
<code><a href="#topic+get_multiagent_report">get_multiagent_report()</a></code>) can be provided here for HTML export. Each HTML
document written to disk is self-contained and easily viewable in a web
browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_report(x, filename, path = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_report_+3A_x">x</code></td>
<td>
<p><em>One of several types of objects</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;object&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>An <em>agent</em> object of class <code>ptblank_agent</code>, an <em>informant</em> of class
<code>ptblank_informant</code>, a <em>multiagent</em> of class <code>ptblank_multiagent</code>, a table
scan of class <code>ptblank_tbl_scan</code>, or, customized reporting objects
(<code>ptblank_agent_report</code>, <code>ptblank_informant_report</code>,
<code>ptblank_multiagent_report.wide</code>, <code>ptblank_multiagent_report.long</code>).</p>
</td></tr>
<tr><td><code id="export_report_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The filename to create on disk for the HTML export of the object provided.
It's recommended that the extension <code>".html"</code> is included.</p>
</td></tr>
<tr><td><code id="export_report_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to which the file should be saved (this is automatically
combined with <code>filename</code>).</p>
</td></tr>
<tr><td><code id="export_report_+3A_quiet">quiet</code></td>
<td>
<p><em>Inform (or not) upon file writing</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the function <em>not</em> inform when the file is written?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if the file has been written.
</p>


<h3>Examples</h3>



<h4>A: Writing an agent report as HTML</h4>

<p>Let's go through the process of (1) developing an agent with a validation
plan (to be used for the data quality analysis of the <code><a href="#topic+small_table">small_table</a></code>
dataset), (2) interrogating the agent with the <code><a href="#topic+interrogate">interrogate()</a></code> function, and
(3) writing the agent and all its intel to a file.
</p>
<p>Creating an <code>action_levels</code> object is a common workflow step when creating a
pointblank agent. We designate failure thresholds to the <code>warn</code>, <code>stop</code>, and
<code>notify</code> states using <code><a href="#topic+action_levels">action_levels()</a></code>.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 0.10,
    stop_at = 0.25,
    notify_at = 0.35
  )
</pre></div>
<p>Now create a pointblank <code>agent</code> object and give it the <code>al</code> object (which
serves as a default for all validation steps which can be overridden). The
data will be referenced in the <code>tbl</code> argument with a leading <code>~</code>.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "`export_report()`",
    actions = al
  )
</pre></div>
<p>As with any agent object, we can add steps to the validation plan by using as
many validation functions as we want. Then, we <code><a href="#topic+interrogate">interrogate()</a></code>.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  agent %&gt;% 
  col_exists(columns = c(date, date_time)) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}"
  ) %&gt;%
  rows_distinct() %&gt;%
  col_vals_gt(columns = d, value = 100) %&gt;%
  col_vals_lte(columns = c, value = 5) %&gt;%
  interrogate()
</pre></div>
<p>The agent report can be written to an HTML file with <code>export_report()</code>.
</p>
<div class="sourceCode r"><pre>export_report(
  agent,
  filename = "agent-small_table.html"
)
</pre></div>
<p>If you're consistently writing agent reports when periodically checking data,
we could make use of <code>affix_date()</code> or <code>affix_datetime()</code> depending on the
granularity you need. Here's an example that writes the file with the format:
<code>"&lt;filename&gt;-YYYY-mm-dd_HH-MM-SS.html"</code>.
</p>
<div class="sourceCode r"><pre>export_report(
  agent,
  filename = affix_datetime(
    "agent-small_table.html"
  )
)
</pre></div>



<h4>B: Writing an informant report as HTML</h4>

<p>Let's go through the process of (1) creating an informant object that
minimally describes the <code><a href="#topic+small_table">small_table</a></code> dataset, (2) ensuring that data is
captured from the target table using the <code><a href="#topic+incorporate">incorporate()</a></code> function, and (3)
writing the informant report to HTML.
</p>
<p>Create a pointblank <code>informant</code> object with <code><a href="#topic+create_informant">create_informant()</a></code> and the
<code><a href="#topic+small_table">small_table</a></code> dataset. Use <code><a href="#topic+incorporate">incorporate()</a></code> so that info snippets are
integrated into the text.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "`export_report()`"
  ) %&gt;%
  info_snippet(
    snippet_name = "high_a",
    fn = snip_highest(column = "a")
  ) %&gt;%
  info_snippet(
    snippet_name = "low_a",
    fn = snip_lowest(column = "a")
  ) %&gt;%
  info_columns(
    columns = a,
    info = "From {low_a} to {high_a}."
  ) %&gt;%
  info_columns(
    columns = starts_with("date"),
    info = "Time-based values."
  ) %&gt;%
  info_columns(
    columns = date,
    info = "The date part of `date_time`."
  ) %&gt;%
  incorporate()
</pre></div>
<p>The informant report can be written to an HTML file with <code>export_report()</code>.
Let's do this with <code><a href="#topic+affix_date">affix_date()</a></code> so the filename has a datestamp.
</p>
<div class="sourceCode r"><pre>export_report(
  informant,
  filename = affix_date(
    "informant-small_table.html"
  )
)
</pre></div>



<h4>C: Writing a table scan as HTML</h4>

<p>We can get a report that describes all of the data in the <code>storms</code> dataset.
</p>
<div class="sourceCode r"><pre>tbl_scan &lt;- scan_data(tbl = dplyr::storms)
</pre></div>
<p>The table scan object can be written to an HTML file with <code>export_report()</code>.
</p>
<div class="sourceCode r"><pre>export_report(
  tbl_scan,
  filename = "tbl_scan-storms.html"
)
</pre></div>



<h3>Function ID</h3>

<p>9-3
</p>


<h3>See Also</h3>

<p>Other Object Ops: 
<code><a href="#topic+activate_steps">activate_steps</a>()</code>,
<code><a href="#topic+deactivate_steps">deactivate_steps</a>()</code>,
<code><a href="#topic+remove_steps">remove_steps</a>()</code>,
<code><a href="#topic+set_tbl">set_tbl</a>()</code>,
<code><a href="#topic+x_read_disk">x_read_disk</a>()</code>,
<code><a href="#topic+x_write_disk">x_write_disk</a>()</code>
</p>

<hr>
<h2 id='file_tbl'>Get a table from a local or remote file</h2><span id='topic+file_tbl'></span>

<h3>Description</h3>

<p>If your target table is in a file, stored either locally or remotely, the
<code>file_tbl()</code> function can make it possible to access it in a single function
call. Compatible file types for this function are: CSV (<code>.csv</code>), TSV
(<code>.tsv</code>), RDA (<code>.rda</code>), and RDS (<code>.rds</code>) files. This function generates an
in-memory <code>tbl_df</code> object, which can be used as a target table for
<code><a href="#topic+create_agent">create_agent()</a></code> and <code><a href="#topic+create_informant">create_informant()</a></code>. Another great option is supplying
a table-prep formula involving <code>file_tbl()</code> to <code><a href="#topic+tbl_store">tbl_store()</a></code> so that you have
access to tables based on flat files though single names via a table store.
</p>
<p>In the remote data use case, we can specify a URL starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, etc., and ending with the file containing the data table. If data
files are available in a GitHub repository then we can use the
<code><a href="#topic+from_github">from_github()</a></code> function to specify the name and location of the table data
in a repository.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_tbl(file, type = NULL, ..., keep = FALSE, verify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_tbl_+3A_file">file</code></td>
<td>
<p>The complete file path leading to a compatible data table either
in the user system or at a <code style="white-space: pre;">&#8288;http://&#8288;</code>, <code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code>
URL. For a file hosted in a GitHub repository, a call to the
<code><a href="#topic+from_github">from_github()</a></code> function can be used here.</p>
</td></tr>
<tr><td><code id="file_tbl_+3A_type">type</code></td>
<td>
<p>The file type. This is normally inferred by file extension and is
by default <code>NULL</code> to indicate that the extension will dictate the type of
file reading that is performed internally. However, if there is no
extension (and valid extensions are <code>.csv</code>, <code>.tsv</code>, <code>.rda</code>, and <code>.rds</code>), we
can provide the type as either of <code>csv</code>, <code>tsv</code>, <code>rda</code>, or <code>rds</code>.</p>
</td></tr>
<tr><td><code id="file_tbl_+3A_...">...</code></td>
<td>
<p>Options passed to <strong>readr</strong>'s <code>read_csv()</code> or <code>read_tsv()</code>
function. Both functions have the same arguments and one or the other will
be used internally based on the file extension or an explicit value given
to <code>type</code>.</p>
</td></tr>
<tr><td><code id="file_tbl_+3A_keep">keep</code></td>
<td>
<p>In the case of a downloaded file, should it be stored in the
working directory (<code>keep = TRUE</code>) or should it be downloaded to a temporary
directory? By default, this is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="file_tbl_+3A_verify">verify</code></td>
<td>
<p>If <code>TRUE</code> (the default) then a verification of the data object
having the <code>data.frame</code> class will be carried out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tbl_df</code> object.
</p>


<h3>Examples</h3>



<h4>Producing tables from CSV files</h4>

<p>A local CSV file can be obtained as a tbl object by supplying a path to the
file and some CSV reading options (the ones used by <code>readr::read_csv()</code>) to
the <code>file_tbl()</code> function. For this example we could obtain a path to a CSV
file in the <strong>pointblank</strong> package with <code>system.file()</code>.
</p>
<div class="sourceCode r"><pre>csv_path &lt;- 
  system.file(
    "data_files", "small_table.csv",
    package = "pointblank"
  )
</pre></div>
<p>Then use that path in <code>file_tbl()</code> with the option to specify the column
types in that CSV.
</p>
<div class="sourceCode r"><pre>tbl &lt;- 
  file_tbl(
    file = csv_path,
    col_types = "TDdcddlc"
  )

tbl
</pre></div>
<pre>## # A tibble: 13 × 8
##    date_time           date           a b           c      d e     f    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-…     3  3423. TRUE  high 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-…     8 10000. TRUE  low  
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-…     3  2343. TRUE  high 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-…    NA  3892. FALSE mid  
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-…     7   284. TRUE  low  
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-…     4  3291. TRUE  mid  
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-…     3   843. TRUE  high 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-…     2  1036. FALSE low  
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE high 
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE high 
## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-…     7   834. TRUE  low  
## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-…     8   108. FALSE low  
## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-…    NA  2230. TRUE  high</pre>
<p>Now that we have a 'tbl' object that is a tibble it could be introduced to
<code><a href="#topic+create_agent">create_agent()</a></code> for validation.
</p>
<div class="sourceCode r"><pre>agent &lt;- create_agent(tbl = tbl)
</pre></div>
<p>A different strategy is to provide the data-reading function call directly to
<code><a href="#topic+create_agent">create_agent()</a></code>:
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ file_tbl(
      file = system.file(
        "data_files", "small_table.csv",
        package = "pointblank"
      ),
      col_types = "TDdcddlc"
    )
  ) %&gt;%
  col_vals_gt(columns = a, value = 0)
</pre></div>
<p>All of the file-reading instructions are encapsulated in the <code>tbl</code> expression
(with the leading <code>~</code>) so the agent will always obtain the most recent
version of the table (and the logic can be translated to YAML, for later
use).
</p>



<h4>Producing tables from files on GitHub</h4>

<p>A CSV can be obtained from a public GitHub repo by using the <code><a href="#topic+from_github">from_github()</a></code>
helper function. Let's create an agent a supply a table-prep formula that
gets the same CSV file from the GitHub repository for the pointblank package.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ file_tbl(
      file = from_github(
        file = "inst/data_files/small_table.csv",
        repo = "rstudio/pointblank"
      ),
      col_types = "TDdcddlc"
    ),
    tbl_name = "small_table",
    label = "`file_tbl()` example.",
  ) %&gt;%
  col_vals_gt(columns = a, value = 0) %&gt;%
  interrogate()
</pre></div>
<div class="sourceCode r"><pre>agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_file_tbl_1.png" alt="This image was generated from the first code example in the `file_tbl()` help file." style="width:100%;">


<p>This interrogated the data that was obtained from the remote source file,
and, there's nothing to clean up (by default, the downloaded file goes into a
system temp directory).
</p>



<h4>File access, table creation, and prep via the table store</h4>

<p>Using table-prep formulas in a centralized table store can make it easier to
work with tables from disparate sources. Here's how to generate a table store
with two named entries for table preparations involving the <code><a href="#topic+tbl_store">tbl_store()</a></code> and
<code>file_tbl()</code> functions.
</p>
<div class="sourceCode r"><pre>store &lt;-
  tbl_store(
    small_table_file ~ file_tbl(
      file = system.file(
        "data_files", "small_table.csv",
        package = "pointblank"
      ),
      col_types = "TDdcddlc"
    ),
    small_high_file ~ {{ small_table_file }} %&gt;%
      dplyr::filter(f == "high")
  )
</pre></div>
<p>Now it's easy to access either of these tables via <code><a href="#topic+tbl_get">tbl_get()</a></code>. We can
reference the table in the store by its name (given to the left of the <code>~</code>).
</p>
<div class="sourceCode r"><pre>tbl_get(tbl = "small_table_file", store = store)
</pre></div>
<pre>## # A tibble: 13 × 8
##    date_time           date           a b           c      d e     f    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-…     3  3423. TRUE  high 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-…     8 10000. TRUE  low  
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-…     3  2343. TRUE  high 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-…    NA  3892. FALSE mid  
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-…     7   284. TRUE  low  
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-…     4  3291. TRUE  mid  
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-…     3   843. TRUE  high 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-…     2  1036. FALSE low  
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE high 
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE high 
## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-…     7   834. TRUE  low  
## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-…     8   108. FALSE low  
## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-…    NA  2230. TRUE  high</pre>
<p>The second table in the table store is a mutated version of the first. It's
just as easily obtainable via <code><a href="#topic+tbl_get">tbl_get()</a></code>:
</p>
<div class="sourceCode r"><pre>tbl_get(tbl = "small_high_file", store = store)
</pre></div>
<pre>## # A tibble: 6 × 8
##   date_time           date           a b             c     d e     f    
##   &lt;dttm&gt;              &lt;date&gt;     &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
## 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3 3423. TRUE  high 
## 2 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3 2343. TRUE  high 
## 3 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high 
## 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high 
## 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high 
## 6 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high</pre>
<p>The table-prep formulas in the <code>store</code> object could also be used in functions
with a <code>tbl</code> argument (like <code><a href="#topic+create_agent">create_agent()</a></code> and <code><a href="#topic+create_informant">create_informant()</a></code>). This
is accomplished most easily with the <code><a href="#topic+tbl_source">tbl_source()</a></code> function.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ tbl_source(
      tbl = "small_table_file",
      store = store
    )
  )
</pre></div>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ tbl_source(
      tbl = "small_high_file",
      store = store
    )
  )
</pre></div>



<h3>Function ID</h3>

<p>1-7
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='from_github'>Specify a file for download from GitHub</h2><span id='topic+from_github'></span>

<h3>Description</h3>

<p>The <code>from_github()</code> function is helpful for generating a valid URL that
points to a data file in a public GitHub repository. This function can be
used in the <code>file</code> argument of the <code><a href="#topic+file_tbl">file_tbl()</a></code> function or anywhere else
where GitHub URLs for raw user content are needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_github(file, repo, subdir = NULL, default_branch = "main")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="from_github_+3A_file">file</code></td>
<td>
<p>The name of the file to target in a GitHub repository. This can
be a path leading to and including the file. This is combined with any path
given in <code>subdir</code>.</p>
</td></tr>
<tr><td><code id="from_github_+3A_repo">repo</code></td>
<td>
<p>The GitHub repository address in the format
<code style="white-space: pre;">&#8288;username/repo[/subdir][@ref|#pull|@*release]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="from_github_+3A_subdir">subdir</code></td>
<td>
<p>A path string representing a subdirectory in the GitHub
repository. This is combined with any path components included in <code>file</code>.</p>
</td></tr>
<tr><td><code id="from_github_+3A_default_branch">default_branch</code></td>
<td>
<p>The name of the default branch for the repo. This is
usually <code>"main"</code> (the default used here).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1 that contains a URL.
</p>


<h3>Function ID</h3>

<p>13-6
</p>


<h3>See Also</h3>

<p>Other Utility and Helper Functions: 
<code><a href="#topic+affix_date">affix_date</a>()</code>,
<code><a href="#topic+affix_datetime">affix_datetime</a>()</code>,
<code><a href="#topic+col_schema">col_schema</a>()</code>,
<code><a href="#topic+has_columns">has_columns</a>()</code>,
<code><a href="#topic+stop_if_not">stop_if_not</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A valid URL to a data file in GitHub can be
# obtained from the HEAD of the default branch
# from_github(
#   file = "inst/data_files/small_table.csv",
#   repo = "rstudio/pointblank"
# )

# The path to the file location can be supplied
# fully or partially to `subdir`
# from_github(
#   file = "small_table.csv",
#   repo = "rstudio/pointblank",
#   subdir = "inst/data_files"
# )

# We can use the first call in combination with
# `file_tbl()` and `create_agent()`; this
# supplies a table-prep formula that gets
# a CSV file from the GitHub repository for the
# pointblank package 
# agent &lt;- 
#   create_agent(
#     tbl = ~ file_tbl(
#       file = from_github(
#         file = "inst/data_files/small_table.csv",
#         repo = "rstudio/pointblank"
#       ),
#       col_types = "TDdcddlc"
#     )
#   ) %&gt;%
#   col_vals_gt(a, 0) %&gt;%
#   interrogate()

# The `from_github()` helper function is
# pretty powerful and can get at lots of
# different files in a repository

# A data file from GitHub can be obtained from
# a commit at release time
# from_github(
#   file = "inst/extdata/small_table.csv",
#   repo = "rstudio/pointblank@v0.2.1"
# )

# A file may also be obtained from a repo at the
# point in time of a specific commit (partial or
# full SHA-1 hash for the commit can be used)
# from_github(
#   file = "data-raw/small_table.csv",
#   repo = "rstudio/pointblank@e04a71"
# )

# A file may also be obtained from an
# *open* pull request
# from_github(
#   file = "data-raw/small_table.csv",
#   repo = "rstudio/pointblank#248"
# )

</code></pre>

<hr>
<h2 id='game_revenue'>A table with game revenue data</h2><span id='topic+game_revenue'></span>

<h3>Description</h3>

<p>This table is a subset of the <code>sj_all_revenue</code> table from the <strong>intendo</strong>
data package. It's the first 2,000 rows from that table where revenue records
range from <code>2015-01-01</code> to <code>2015-01-21</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>game_revenue
</code></pre>


<h3>Format</h3>

<p>A tibble with 2,000 rows and 11 variables:
</p>

<dl>
<dt>player_id</dt><dd><p>A <code>character</code> column with unique identifiers for each
user/player.</p>
</dd>
<dt>session_id</dt><dd><p>A <code>character</code> column that contains unique identifiers for
each player session.</p>
</dd>
<dt>session_start</dt><dd><p>A date-time column that indicates when the session
(containing the revenue event) started.</p>
</dd>
<dt>time</dt><dd><p>A date-time column that indicates exactly when the player
purchase (or revenue event) occurred.</p>
</dd>
<dt>item_type</dt><dd><p>A <code>character</code> column that provides the class of the item
purchased.</p>
</dd>
<dt>item_name</dt><dd><p>A <code>character</code> column that provides the name of the item
purchased.</p>
</dd>
<dt>item_revenue</dt><dd><p>A <code>numeric</code> column with the revenue amounts per item
purchased.</p>
</dd>
<dt>session_duration</dt><dd><p>A <code>numeric</code> column that states the length of the
session (in minutes) for which the purchase occurred.</p>
</dd>
<dt>start_day</dt><dd><p>A <code>Date</code> column that provides the date of first login for
the player making a purchase.</p>
</dd>
<dt>acquisition</dt><dd><p>A <code>character</code> column that provides the method of
acquisition for the player.</p>
</dd>
<dt>country</dt><dd><p>A <code>character</code> column that provides the probable country of
residence for the player.</p>
</dd>
</dl>



<h3>Function ID</h3>

<p>14-4
</p>


<h3>See Also</h3>

<p>Other Datasets: 
<code><a href="#topic+game_revenue_info">game_revenue_info</a></code>,
<code><a href="#topic+small_table">small_table</a></code>,
<code><a href="#topic+small_table_sqlite">small_table_sqlite</a>()</code>,
<code><a href="#topic+specifications">specifications</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here is a glimpse at the data
# available in `game_revenue`
dplyr::glimpse(game_revenue)

</code></pre>

<hr>
<h2 id='game_revenue_info'>A table with metadata for the <code>game_revenue</code> dataset</h2><span id='topic+game_revenue_info'></span>

<h3>Description</h3>

<p>This table contains metadata for the <code>game_revenue</code> table. The first column
(named <code>column</code>) provides the column names from <code>game_revenue</code>. The second
column (<code>info</code>) contains descriptions for each of the columns in that
dataset. This table is in the correct format for use in the
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>game_revenue_info
</code></pre>


<h3>Format</h3>

<p>A tibble with 11 rows and 2 variables:
</p>

<dl>
<dt>column</dt><dd><p>A <code>character</code> column with unique identifiers for each
user/player.</p>
</dd>
<dt>info</dt><dd><p>A <code>character</code> column that contains unique identifiers for
each player session.</p>
</dd>
</dl>



<h3>Function ID</h3>

<p>14-5
</p>


<h3>See Also</h3>

<p>Other Datasets: 
<code><a href="#topic+game_revenue">game_revenue</a></code>,
<code><a href="#topic+small_table">small_table</a></code>,
<code><a href="#topic+small_table_sqlite">small_table_sqlite</a>()</code>,
<code><a href="#topic+specifications">specifications</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here is a glimpse at the data
# available in `game_revenue_info`
dplyr::glimpse(game_revenue_info)

</code></pre>

<hr>
<h2 id='get_agent_report'>Get a summary report from an agent</h2><span id='topic+get_agent_report'></span>

<h3>Description</h3>

<p>We can get an informative summary table from an agent by using the
<code>get_agent_report()</code> function. The table can be provided in two substantially
different forms: as a <strong>gt</strong> based display table (the default), or, as a
tibble. The amount of fields with intel is different depending on whether or
not the agent performed an interrogation (with the <code><a href="#topic+interrogate">interrogate()</a></code> function).
Basically, before <code><a href="#topic+interrogate">interrogate()</a></code> is called, the agent will contain just the
validation plan (however many rows it has depends on how many validation
functions were supplied a part of that plan). Post-interrogation, information
on the passing and failing test units is provided, along with indicators on
whether certain failure states were entered (provided they were set through
<code>actions</code>). The display table variant of the agent report, the default form,
will have the following columns:
</p>

<ul>
<li><p> i (unlabeled): the validation step number.
</p>
</li>
<li><p> STEP: the name of the validation function used for the validation step,
</p>
</li>
<li><p> COLUMNS: the names of the target columns used in the validation step
(if applicable).
</p>
</li>
<li><p> VALUES: the values used in the validation step, where applicable; this
could be as literal values, as column names, an expression, etc.
</p>
</li>
<li><p> TBL: indicates whether any there were any changes to the target table
just prior to interrogation. A rightward arrow from a small circle indicates
that there was no mutation of the table. An arrow from a circle to a purple
square indicates that preconditions were used to modify the target table. An
arrow from a circle to a half-filled circle indicates that the target table
has been segmented.
</p>
</li>
<li><p> EVAL: a symbol that denotes the success of interrogation evaluation
for each step. A checkmark indicates no issues with evaluation. A warning
sign indicates that a warning occurred during evaluation. An explosion symbol
indicates that evaluation failed due to an error. Hover over the symbol for
details on each condition.
</p>
</li>
<li><p> UNITS: the total number of test units for the validation step
</p>
</li>
<li><p> PASS: on top is the absolute number of <em>passing</em> test units and below
that is the fraction of <em>passing</em> test units over the total number of test
units.
</p>
</li>
<li><p> FAIL: on top is the absolute number of <em>failing</em> test units and below
that is the fraction of <em>failing</em> test units over the total number of test
units.
</p>
</li>
<li><p> W, S, N: indicators that show whether the <code>warn</code>, <code>stop</code>, or <code>notify</code>
states were entered; unset states appear as dashes, states that are set with
thresholds appear as unfilled circles when not entered and filled when
thresholds are exceeded (colors for W, S, and N are amber, red, and blue)
</p>
</li>
<li><p> EXT: a column that provides buttons to download data extracts as CSV
files for row-based validation steps having <strong>failing</strong> test units. Buttons
only appear when there is data to collect.
</p>
</li></ul>

<p>The small version of the display table (obtained using <code>size = "small"</code>)
omits the <code>COLUMNS</code>, <code>TBL</code>, and <code>EXT</code> columns. The width of the small table
is 575px; the standard table is 875px wide.
</p>
<p>The <code>ptblank_agent_report</code> can be exported to a standalone HTML document
with the <code><a href="#topic+export_report">export_report()</a></code> function.
</p>
<p>If choosing to get a tibble (with <code>display_table = FALSE</code>), it will have the
following columns:
</p>

<ul>
<li><p> i: the validation step number.
</p>
</li>
<li><p> type: the name of the validation function used for the validation step.
</p>
</li>
<li><p> columns: the names of the target columns used in the validation step
(if applicable).
</p>
</li>
<li><p> values: the values used in the validation step, where applicable; for
a <code><a href="#topic+conjointly">conjointly()</a></code> validation step, this is a listing of all sub-validations.
</p>
</li>
<li><p> precon: indicates whether any there are any preconditions to apply
before interrogation and, if so, the number of statements used.
</p>
</li>
<li><p> active: a logical value that indicates whether a validation step is
set to <code>"active"</code> during an interrogation.
</p>
</li>
<li><p> eval: a character value that denotes the success of interrogation
evaluation for each step. A value of <code>"OK"</code> indicates no issues with
evaluation. The <code>"WARNING"</code> value indicates a warning occurred during
evaluation. The <code>"ERROR"</code> VALUES indicates that evaluation failed due to an
error. With <code>"W+E"</code> both warnings and an error occurred during evaluation.
</p>
</li>
<li><p> units: the total number of test units for the validation step.
</p>
</li>
<li><p> n_pass: the number of <em>passing</em> test units.
</p>
</li>
<li><p> f_pass: the fraction of <em>passing</em> test units.
</p>
</li>
<li><p> W, S, N: logical value stating whether the <code>warn</code>, <code>stop</code>, or <code>notify</code>
states were entered. Will be <code>NA</code> for states that are unset.
</p>
</li>
<li><p> extract: an integer value that indicates the number of rows available
in a data extract. Will be <code>NA</code> if no extract is available.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>get_agent_report(
  agent,
  arrange_by = c("i", "severity"),
  keep = c("all", "fail_states"),
  display_table = TRUE,
  size = "standard",
  title = ":default:",
  lang = NULL,
  locale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_agent_report_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function.</p>
</td></tr>
<tr><td><code id="get_agent_report_+3A_arrange_by">arrange_by</code></td>
<td>
<p><em>Method of arranging the report's table rows</em>
</p>
<p><code style="white-space: pre;">&#8288;singl-kw:[i|severity]&#8288;</code> // <em>default:</em> <code>"i"</code>
</p>
<p>A choice to arrange the report table rows by the validation step number
(<code>"i"</code>, the default), or, to arrange in descending order by severity of the
failure state (with <code>"severity"</code>).</p>
</td></tr>
<tr><td><code id="get_agent_report_+3A_keep">keep</code></td>
<td>
<p><em>Which table rows should be kept?</em>
</p>
<p><code style="white-space: pre;">&#8288;singl-kw:[all|fail_states]&#8288;</code> // <em>default:</em> <code>"all"</code>
</p>
<p>An option to keep <code>"all"</code> of the report's table rows (the
default), or, keep only those rows that reflect one or more
<code>"fail_states"</code>.</p>
</td></tr>
<tr><td><code id="get_agent_report_+3A_display_table">display_table</code></td>
<td>
<p><em>Return a display-table report via gt</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>Should a display table be generated? If <code>TRUE</code>, and if the <strong>gt</strong> package
is installed, a display table for the report will be shown in the Viewer.
If <code>FALSE</code>, or if <strong>gt</strong> is not available, then a tibble will be returned.</p>
</td></tr>
<tr><td><code id="get_agent_report_+3A_size">size</code></td>
<td>
<p><em>Size option for display-table report</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>"standard"</code>
</p>
<p>The size of the display table, which can be either <code>"standard"</code> (the
default) or <code>"small"</code>. This only applies to a display table (where
<code>display_table = TRUE</code>).</p>
</td></tr>
<tr><td><code id="get_agent_report_+3A_title">title</code></td>
<td>
<p><em>Title customization options</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>":default:"</code>
</p>
<p>Options for customizing the title of the report. The default is the keyword
<code>":default:"</code> which produces generic title text that refers to the
<strong>pointblank</strong> package in the language governed by the <code>lang</code> option.
Another keyword option is <code>":tbl_name:"</code>, and that presents the name of the
table as the title for the report. If no title is wanted, then the
<code>":none:"</code> keyword option can be used. Aside from keyword options, text can
be provided for the title and <code>glue::glue()</code> calls can be used to construct
the text string. If providing text, it will be interpreted as Markdown text
and transformed internally to HTML. To circumvent such a transformation,
use text in <code><a href="base.html#topic+I">I()</a></code> to explicitly state that the supplied text should not be
transformed.</p>
</td></tr>
<tr><td><code id="get_agent_report_+3A_lang">lang</code></td>
<td>
<p><em>Reporting language</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use for automatic creation of briefs (short descriptions
for each validation step) and for the <em>agent report</em> (a summary table that
provides the validation plan and the results from the interrogation. By
default, <code>NULL</code> will create English (<code>"en"</code>) text. Other options include
French (<code>"fr"</code>), German (<code>"de"</code>), Italian (<code>"it"</code>), Spanish (<code>"es"</code>),
Portuguese (<code>"pt"</code>), Turkish (<code>"tr"</code>), Chinese (<code>"zh"</code>), Russian (<code>"ru"</code>),
Polish (<code>"pl"</code>), Danish (<code>"da"</code>), Swedish (<code>"sv"</code>), and Dutch (<code>"nl"</code>).
This <code>lang</code> option will override any previously set language setting (e.g.,
by the <code><a href="#topic+create_agent">create_agent()</a></code> call).</p>
</td></tr>
<tr><td><code id="get_agent_report_+3A_locale">locale</code></td>
<td>
<p><em>Locale for value formatting</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional locale ID to use for formatting values in the
<em>agent report</em> summary table according the locale's rules. Examples include
<code>"en_US"</code> for English (United States) and <code>"fr_FR"</code> for French (France);
more simply, this can be a language identifier without a country
designation, like <code>"es"</code> for Spanish (Spain, same as <code>"es_ES"</code>). This
<code>locale</code> option will override any previously set locale value (e.g., by the
<code><a href="#topic+create_agent">create_agent()</a></code> call).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_agent_report</code> object if <code>display_table = TRUE</code> or a tibble
if <code>display_table = FALSE</code>.
</p>


<h3>Examples</h3>

<p>For the example here, we'll use a simple table with a single numerical column
<code>a</code>.
</p>
<div class="sourceCode r"><pre>tbl &lt;- dplyr::tibble(a = c(5, 7, 8, 5))

tbl
#&gt; # A tibble: 4 x 1
#&gt;       a
#&gt;   &lt;dbl&gt;
#&gt; 1     5
#&gt; 2     7
#&gt; 3     8
#&gt; 4     5
</pre></div>
<p>Let's create an <em>agent</em> and validate that values in column <code>a</code> are always
greater than <code>4</code>.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(
    tbl = tbl,
    tbl_name = "small_table",
    label = "An example."
  ) %&gt;%
  col_vals_gt(columns = a, value = 4) %&gt;%
  interrogate()
</pre></div>
<p>We can get a tibble-based report from the agent by using <code>get_agent_report()</code>
with <code>display_table = FALSE</code>.
</p>
<div class="sourceCode r"><pre>agent %&gt;% get_agent_report(display_table = FALSE)
</pre></div>
<pre>## # A tibble: 1 × 14
##       i type    columns values precon active eval  units n_pass
##   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;  &lt;lgl&gt;  &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1     1 col_va… a       4      NA     TRUE   OK        4      4
## # … with 5 more variables: f_pass &lt;dbl&gt;, W &lt;lgl&gt;, S &lt;lgl&gt;,
## #   N &lt;lgl&gt;, extract &lt;int&gt;</pre>
<p>The full-featured display-table-based report can be viewed by printing the
<code>agent</code> object, but, we can get a <code>"ptblank_agent_report"</code> object returned to
us when using <code>display_table = TRUE</code> (the default for <code>get_agent_report</code>).
</p>
<div class="sourceCode r"><pre>report &lt;- get_agent_report(agent)

report
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_get_agent_report_1.png" alt="This image was generated from the first code example in the `get_agent_report()` help file." style="width:100%;">


<p>What can you do with the <code>report</code> object? Print it at will wherever, and, it
can serve as an input to the <code><a href="#topic+export_report">export_report()</a></code> function.
</p>
<p>However, the better reason to use <code>get_agent_report()</code> over just printing the
agent for display-table purposes is to make use of the different display
options.
</p>
<p>The agent report as a <strong>gt</strong> display table comes in two sizes: <code>"standard"</code>
(the default, 875px wide) and <code>"small"</code> (575px wide). Let's take a look at
the smaller-sized version of the report.
</p>
<div class="sourceCode r"><pre>small_report &lt;- 
  get_agent_report(
    agent = agent,
    size = "small"
  )
  
small_report
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_get_agent_report_2.png" alt="This image was generated from the second code example in the `get_agent_report()` help file." style="width:100%;">


<p>We can use our own title by supplying it to the <code>title</code> argument, or, use
a special keyword like <code>":tbl_name:"</code> to get the table name (set in the
<code><a href="#topic+create_agent">create_agent()</a></code> call) as the title.
</p>
<div class="sourceCode r"><pre>report_title &lt;- get_agent_report(agent, title = ":tbl_name:")

report_title
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_get_agent_report_3.png" alt="This image was generated from the third code example in the `get_agent_report()` help file." style="width:100%;">


<p>There are more options! You can change the language of the display table with
the <code>lang</code> argument (this overrides the language set in <code><a href="#topic+create_agent">create_agent()</a></code>),
validation steps can be rearranged using the <code>arrange_by</code> argument, and we
can also apply some filtering with the <code>keep</code> argument in
<code>get_agent_report()</code>.
</p>


<h3>Function ID</h3>

<p>6-2
</p>


<h3>See Also</h3>

<p>Other Interrogate and Report: 
<code><a href="#topic+interrogate">interrogate</a>()</code>
</p>

<hr>
<h2 id='get_agent_x_list'>Get the agent's <strong>x-list</strong></h2><span id='topic+get_agent_x_list'></span>

<h3>Description</h3>

<p>The agent's <strong>x-list</strong> is a record of information that the agent possesses at
any given time. The <strong>x-list</strong> will contain the most complete information
after an interrogation has taken place (before then, the data largely
reflects the validation plan). The <strong>x-list</strong> can be constrained to a
particular validation step (by supplying the step number to the <code>i</code>
argument), or, we can get the information for all validation steps by leaving
<code>i</code> unspecified. The <strong>x-list</strong> is indeed an R <code>list</code> object that contains a
veritable cornucopia of information.
</p>
<p>For an <strong>x-list</strong> obtained with <code>i</code> specified for a validation step, the
following components are available:
</p>

<ul>
<li> <p><code>time_start</code>: the time at which the interrogation began
(<code style="white-space: pre;">&#8288;POSIXct [0 or 1]&#8288;</code>)
</p>
</li>
<li> <p><code>time_end</code>: the time at which the interrogation ended
(<code style="white-space: pre;">&#8288;POSIXct [0 or 1]&#8288;</code>)
</p>
</li>
<li> <p><code>label</code>: the optional label given to the agent (<code>chr [1]</code>)
</p>
</li>
<li> <p><code>tbl_name</code>: the name of the table object, if available (<code>chr [1]</code>)
</p>
</li>
<li> <p><code>tbl_src</code>: the type of table used in the validation (<code>chr [1]</code>)
</p>
</li>
<li> <p><code>tbl_src_details</code>: if the table is a database table, this provides
further details for the DB table (<code>chr [1]</code>)
</p>
</li>
<li> <p><code>tbl</code>: the table object itself
</p>
</li>
<li> <p><code>col_names</code>: the table's column names (<code>chr [ncol(tbl)]</code>)
</p>
</li>
<li> <p><code>col_types</code>: the table's column types (<code>chr [ncol(tbl)]</code>)
</p>
</li>
<li> <p><code>i</code>: the validation step index (<code>int [1]</code>)
</p>
</li>
<li> <p><code>type</code>: the type of validation, value is validation function name
(<code>chr [1]</code>)
</p>
</li>
<li> <p><code>columns</code>: the columns specified for the validation function
(<code style="white-space: pre;">&#8288;chr [variable length]&#8288;</code>)
</p>
</li>
<li> <p><code>values</code>: the values specified for the validation function
(<code style="white-space: pre;">&#8288;mixed types [variable length]&#8288;</code>)
</p>
</li>
<li> <p><code>briefs</code>: the brief for the validation step in the specified <code>lang</code>
(<code>chr [1]</code>)
</p>
</li>
<li> <p><code>eval_error</code>, <code>eval_warning</code>: indicates whether the evaluation of the
step function, during interrogation, resulted in an error or a warning
(<code>lgl [1]</code>)
</p>
</li>
<li> <p><code>capture_stack</code>: a list of captured errors or warnings during
step-function evaluation at interrogation time (<code>list [1]</code>)
</p>
</li>
<li> <p><code>n</code>: the number of test units for the validation step (<code>num [1]</code>)
</p>
</li>
<li> <p><code>n_passed</code>, <code>n_failed</code>: the number of passing and failing test units
for the validation step (<code>num [1]</code>)
</p>
</li>
<li> <p><code>f_passed</code>: the fraction of passing test units for the validation step,
<code>n_passed</code> / <code>n</code> (<code>num [1]</code>)
</p>
</li>
<li> <p><code>f_failed</code>: the fraction of failing test units for the validation step,
<code>n_failed</code> / <code>n</code> (<code>num [1]</code>)
</p>
</li>
<li> <p><code>warn</code>, <code>stop</code>, <code>notify</code>: a logical value indicating whether the level
of failing test units caused the corresponding conditions to be entered
(<code>lgl [1]</code>)
</p>
</li>
<li> <p><code>lang</code>: the two-letter language code that indicates which
language should be used for all briefs, the agent report, and the reporting
generated by the <code><a href="#topic+scan_data">scan_data()</a></code> function (<code>chr [1]</code>)
</p>
</li></ul>

<p>If <code>i</code> is unspecified (i.e., not constrained to a specific validation step)
then certain length-one components in the <strong>x-list</strong> will be expanded to the
total number of validation steps (these are: <code>i</code>, <code>type</code>, <code>columns</code>,
<code>values</code>, <code>briefs</code>, <code>eval_error</code>, <code>eval_warning</code>, <code>capture_stack</code>, <code>n</code>,
<code>n_passed</code>, <code>n_failed</code>, <code>f_passed</code>, <code>f_failed</code>, <code>warn</code>, <code>stop</code>, and
<code>notify</code>). The <strong>x-list</strong> will also have additional components when <code>i</code> is
<code>NULL</code>, which are:
</p>

<ul>
<li> <p><code>report_object</code>: a <strong>gt</strong> table object, which is also presented as the
default print method for a <code>ptblank_agent</code>
</p>
</li>
<li> <p><code>email_object</code>: a <strong>blastula</strong> <code>email_message</code> object with a default
set of components
</p>
</li>
<li> <p><code>report_html</code>: the HTML source for the <code>report_object</code>, provided as
a length-one character vector
</p>
</li>
<li> <p><code>report_html_small</code>: the HTML source for a narrower, more condensed
version of <code>report_object</code>, provided as a length-one character vector; The
HTML has inlined styles, making it more suitable for email message bodies
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>get_agent_x_list(agent, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_agent_x_list_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function.</p>
</td></tr>
<tr><td><code id="get_agent_x_list_+3A_i">i</code></td>
<td>
<p><em>A validation step number</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The validation step number, which is assigned to each validation step in
the order of invocation. If <code>NULL</code> (the default), the <strong>x-list</strong> will
provide information for all validation steps. If a valid step number is
provided then <strong>x-list</strong> will have information pertaining only to that
step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>x_list</code> object.
</p>


<h3>Examples</h3>

<p>Create a simple data frame with a column of numerical values.
</p>
<div class="sourceCode r"><pre>tbl &lt;- dplyr::tibble(a = c(5, 7, 8, 5))

tbl
#&gt; # A tibble: 4 x 1
#&gt;       a
#&gt;   &lt;dbl&gt;
#&gt; 1     5
#&gt; 2     7
#&gt; 3     8
#&gt; 4     5
</pre></div>
<p>Create an <code>action_levels()</code> list with fractional values for the <code>warn</code>,
<code>stop</code>, and <code>notify</code> states.
</p>
<div class="sourceCode r"><pre>al &lt;-
  action_levels(
    warn_at = 0.2,
    stop_at = 0.8,
    notify_at = 0.345
  )
</pre></div>
<p>Create an agent (giving it the <code>tbl</code> and the <code>al</code> objects), supply two
validation step functions, then interrogate.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(
    tbl = tbl,
    actions = al
  ) %&gt;%
  col_vals_gt(columns = a, value = 7) %&gt;%
  col_is_numeric(columns = a) %&gt;%
  interrogate()
</pre></div>
<p>Get the <code>f_passed</code> component of the agent x-list.
</p>
<div class="sourceCode r"><pre>x &lt;- get_agent_x_list(agent)

x$f_passed
</pre></div>
<div class="sourceCode"><pre>#&gt; [1] 0.25 1.00
</pre></div>


<h3>Function ID</h3>

<p>8-1
</p>


<h3>See Also</h3>

<p>Other Post-interrogation: 
<code><a href="#topic+all_passed">all_passed</a>()</code>,
<code><a href="#topic+get_data_extracts">get_data_extracts</a>()</code>,
<code><a href="#topic+get_sundered_data">get_sundered_data</a>()</code>,
<code><a href="#topic+write_testthat_file">write_testthat_file</a>()</code>
</p>

<hr>
<h2 id='get_data_extracts'>Collect data extracts from a validation step</h2><span id='topic+get_data_extracts'></span>

<h3>Description</h3>

<p>In an agent-based workflow (i.e., initiating with <code><a href="#topic+create_agent">create_agent()</a></code>), after
interrogation with <code><a href="#topic+interrogate">interrogate()</a></code>, we can extract the row data that didn't
pass row-based validation steps with the <code>get_data_extracts()</code> function.
There is one discrete extract per row-based validation step and the amount of
data available in a particular extract depends on both the fraction of test
units that didn't pass the validation step and the level of sampling or
explicit collection from that set of units. These extracts can be collected
programmatically through <code>get_data_extracts()</code> but they may also be
downloaded as CSV files from the HTML report generated by the agent's print
method or through the use of <code><a href="#topic+get_agent_report">get_agent_report()</a></code>.
</p>
<p>The availability of data extracts for each row-based validation step depends
on whether <code>extract_failed</code> is set to <code>TRUE</code> within the <code><a href="#topic+interrogate">interrogate()</a></code> call
(it is by default). The amount of <em>fail</em> rows extracted depends on the
collection parameters in <code><a href="#topic+interrogate">interrogate()</a></code>, and the default behavior is to
collect up to the first 5000 <em>fail</em> rows.
</p>
<p>Row-based validation steps are based on those validation functions of the
form <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code> and also include <code><a href="#topic+conjointly">conjointly()</a></code> and <code><a href="#topic+rows_distinct">rows_distinct()</a></code>.
Only functions from that combined set of validation functions can yield data
extracts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data_extracts(agent, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_data_extracts_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function. It should have had <code><a href="#topic+interrogate">interrogate()</a></code> called on
it, such that the validation steps were carried out and any sample rows
from non-passing validations could potentially be available in the object.</p>
</td></tr>
<tr><td><code id="get_data_extracts_+3A_i">i</code></td>
<td>
<p><em>A validation step number</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The validation step number, which is assigned to each validation step by
<strong>pointblank</strong> in the order of definition. If <code>NULL</code> (the default), all
data extract tables will be provided in a list object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables if <code>i</code> is not provided, or, a standalone table if
<code>i</code> is given.
</p>


<h3>Examples</h3>

<p>Create a series of two validation steps focused on testing row values for
part of the <code>small_table</code> object. Use <code><a href="#topic+interrogate">interrogate()</a></code> right after that.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(
    tbl = small_table %&gt;%
      dplyr::select(a:f),
    label = "`get_data_extracts()`"
  ) %&gt;%
  col_vals_gt(d, value = 1000) %&gt;%
  col_vals_between(
    columns = c,
    left = vars(a), right = vars(d),
    na_pass = TRUE
  ) %&gt;%
  interrogate()
</pre></div>
<p>Using <code>get_data_extracts()</code> with its defaults returns of a list of tables,
where each table is named after the validation step that has an extract
available.
</p>
<div class="sourceCode r"><pre>agent %&gt;% get_data_extracts()
</pre></div>
<pre>## $`1`
## # A tibble: 6 × 6
##       a b             c     d e     f    
##   &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
## 1     8 3-ldm-038     7  284. TRUE  low  
## 2     7 1-knw-093     3  843. TRUE  high 
## 3     3 5-bce-642     9  838. FALSE high 
## 4     3 5-bce-642     9  838. FALSE high 
## 5     4 2-dmx-010     7  834. TRUE  low  
## 6     2 7-dmx-010     8  108. FALSE low  
## 
## $`2`
## # A tibble: 4 × 6
##       a b             c     d e     f    
##   &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
## 1     6 8-kdg-938     3 2343. TRUE  high 
## 2     8 3-ldm-038     7  284. TRUE  low  
## 3     7 1-knw-093     3  843. TRUE  high 
## 4     4 5-boe-639     2 1036. FALSE low</pre>
<p>We can get an extract for a specific step by specifying it in the <code>i</code>
argument. Let's get the failing rows from the first validation step (the
<code><a href="#topic+col_vals_gt">col_vals_gt()</a></code> one).
</p>
<div class="sourceCode r"><pre>agent %&gt;% get_data_extracts(i = 1)
</pre></div>
<pre>## # A tibble: 6 × 6
##       a b             c     d e     f    
##   &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
## 1     8 3-ldm-038     7  284. TRUE  low  
## 2     7 1-knw-093     3  843. TRUE  high 
## 3     3 5-bce-642     9  838. FALSE high 
## 4     3 5-bce-642     9  838. FALSE high 
## 5     4 2-dmx-010     7  834. TRUE  low  
## 6     2 7-dmx-010     8  108. FALSE low</pre>


<h3>Function ID</h3>

<p>8-2
</p>


<h3>See Also</h3>

<p>Other Post-interrogation: 
<code><a href="#topic+all_passed">all_passed</a>()</code>,
<code><a href="#topic+get_agent_x_list">get_agent_x_list</a>()</code>,
<code><a href="#topic+get_sundered_data">get_sundered_data</a>()</code>,
<code><a href="#topic+write_testthat_file">write_testthat_file</a>()</code>
</p>

<hr>
<h2 id='get_informant_report'>Get a table information report from an <em>informant</em> object</h2><span id='topic+get_informant_report'></span>

<h3>Description</h3>

<p>We can get a table information report from an informant object that's
generated by the <code><a href="#topic+create_informant">create_informant()</a></code> function. The report is provided as a
<strong>gt</strong> based display table. The amount of information shown depends on the
extent of that added via the use of the <code style="white-space: pre;">&#8288;info_*()&#8288;</code> functions or through
direct editing of a <strong>pointblank</strong> YAML file (an informant can be written
to <strong>pointblank</strong> YAML with <code style="white-space: pre;">&#8288;yaml_write(informant = &lt;informant&gt;, ...)&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_informant_report(
  informant,
  size = "standard",
  title = ":default:",
  lang = NULL,
  locale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_informant_report_+3A_informant">informant</code></td>
<td>
<p><em>The pointblank informant object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_informant&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>informant</em> object that is commonly created through the
use of the <code><a href="#topic+create_informant">create_informant()</a></code> function.</p>
</td></tr>
<tr><td><code id="get_informant_report_+3A_size">size</code></td>
<td>
<p><em>Size option for display-table report</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>"standard"</code>
</p>
<p>The size of the display table, which can be either <code>"standard"</code> (the
default, with a width of 875px), <code>"small"</code> (width of 575px), or, a pixel-
or percent-based width of your choosing (supply an integer value for the
width in pixels, or values with <code>"px"</code> or <code>"%"</code> appended, like <code>"75%"</code>,
<code>"500px"</code>, etc.).</p>
</td></tr>
<tr><td><code id="get_informant_report_+3A_title">title</code></td>
<td>
<p><em>Title customization options</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>":default:"</code>
</p>
<p>Options for customizing the title of the report. The default is the keyword
<code>":default:"</code> which produces generic title text that refers to the
<strong>pointblank</strong> package in the language governed by the <code>lang</code> option.
Another keyword option is <code>":tbl_name:"</code>, and that presents the name of the
table as the title for the report. If no title is wanted, then the
<code>":none:"</code> keyword option can be used. Aside from keyword options, text can
be provided for the title and <code>glue::glue()</code> calls can be used to construct
the text string. If providing text, it will be interpreted as Markdown text
and transformed internally to HTML. To circumvent such a transformation,
use text in <code><a href="base.html#topic+I">I()</a></code> to explicitly state that the supplied text should not be
transformed.</p>
</td></tr>
<tr><td><code id="get_informant_report_+3A_lang">lang</code></td>
<td>
<p><em>Reporting language</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use for the <em>information report</em>. By default, <code>NULL</code> will
create English (<code>"en"</code>) text. Other options include French (<code>"fr"</code>), German
(<code>"de"</code>), Italian (<code>"it"</code>), Spanish (<code>"es"</code>), Portuguese (<code>"pt"</code>), Turkish
(<code>"tr"</code>), Chinese (<code>"zh"</code>), Russian (<code>"ru"</code>), Polish (<code>"pl"</code>), Danish
(<code>"da"</code>), Swedish (<code>"sv"</code>), and Dutch (<code>"nl"</code>). This <code>lang</code> option will
override any previously set language setting (e.g., by the
<code><a href="#topic+create_informant">create_informant()</a></code> call).</p>
</td></tr>
<tr><td><code id="get_informant_report_+3A_locale">locale</code></td>
<td>
<p><em>Locale for value formatting</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional locale ID to use for formatting values in the
<em>information report</em> summary table according the locale's rules. Examples
include <code>"en_US"</code> for English (United States) and <code>"fr_FR"</code> for French
(France); more simply, this can be a language identifier without a country
designation, like <code>"es"</code> for Spanish (Spain, same as <code>"es_ES"</code>). This
<code>locale</code> option will override any previously set locale value (e.g., by the
<code><a href="#topic+create_informant">create_informant()</a></code> call).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <strong>gt</strong> table object.
</p>


<h3>Function ID</h3>

<p>7-2
</p>


<h3>See Also</h3>

<p>Other Incorporate and Report: 
<code><a href="#topic+incorporate">incorporate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate an informant object using
# the `small_table` dataset
informant &lt;- create_informant(small_table)

# This function creates some information
# without any extra help by profiling
# the supplied table object; it adds
# the sections 'table' and columns' and
# we can print the object to see the
# table information report

# Alternatively, we can get the same report
# by using `get_informant_report()`
report &lt;- get_informant_report(informant)
class(report)

</code></pre>

<hr>
<h2 id='get_multiagent_report'>Get a summary report using multiple agents</h2><span id='topic+get_multiagent_report'></span>

<h3>Description</h3>

<p>We can get an informative summary table from a collective of agents by using
the <code>get_multiagent_report()</code> function. Information from multiple agent can
be provided in three very forms: (1) the <em>Long Display</em> (stacked reports),
(2) the <em>Wide Display</em> (a comparison report), (3) as a tibble with packed
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_multiagent_report(
  multiagent,
  display_table = TRUE,
  display_mode = c("long", "wide"),
  title = ":default:",
  lang = NULL,
  locale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_multiagent_report_+3A_multiagent">multiagent</code></td>
<td>
<p>A multiagent object of class <code>ptblank_multiagent</code>.</p>
</td></tr>
<tr><td><code id="get_multiagent_report_+3A_display_table">display_table</code></td>
<td>
<p>Should a display table be generated? If <code>TRUE</code> (the
default) a display table for the report will be shown in the Viewer. If
<code>FALSE</code> then a tibble will be returned.</p>
</td></tr>
<tr><td><code id="get_multiagent_report_+3A_display_mode">display_mode</code></td>
<td>
<p>If we are getting a display table, should the agent data
be presented in a <code>"long"</code> or <code>"wide"</code> form? The default is <code>"long"</code> but
when comparing multiple runs where the target table is the same it might be
preferable to choose <code>"wide"</code>.</p>
</td></tr>
<tr><td><code id="get_multiagent_report_+3A_title">title</code></td>
<td>
<p>Options for customizing the title of the report when
<code>display_table = TRUE</code>. The default is the keyword <code>":default:"</code> which
produces generic title text. If no title is wanted, then the <code>":none:"</code>
keyword option can be used. Another keyword option is <code>":tbl_name:"</code>, and
that presents the name of the table as the title for the report (this can
only be used when <code>display_mode = "long"</code>). Aside from keyword options,
text can be provided for the title and <code>glue::glue()</code> calls can be used to
construct the text string. If providing text, it will be interpreted as
Markdown text and transformed internally to HTML. To circumvent such a
transformation, use text in <code><a href="base.html#topic+I">I()</a></code> to explicitly state that the supplied
text should not be transformed.</p>
</td></tr>
<tr><td><code id="get_multiagent_report_+3A_lang">lang</code></td>
<td>
<p><em>Reporting language</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use for the long or wide report forms. By default, <code>NULL</code>
will preserve any language set in the component reports. The following
options will force the same language across all component reports: English
(<code>"en"</code>), French (<code>"fr"</code>), German (<code>"de"</code>), Italian (<code>"it"</code>), Spanish
(<code>"es"</code>), Portuguese (<code>"pt"</code>), Turkish (<code>"tr"</code>), Chinese (<code>"zh"</code>), Russian
(<code>"ru"</code>), Polish (<code>"pl"</code>), Danish (<code>"da"</code>), Swedish (<code>"sv"</code>), and Dutch
(<code>"nl"</code>).</p>
</td></tr>
<tr><td><code id="get_multiagent_report_+3A_locale">locale</code></td>
<td>
<p><em>Locale for value formatting</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional locale ID to use for formatting values in the long or wide
report forms (according the locale's rules). Examples include <code>"en_US"</code> for
English (United States) and <code>"fr_FR"</code> for French (France); more simply,
this can be a language identifier without a country designation, like
<code>"es"</code> for Spanish (Spain, same as <code>"es_ES"</code>). This <code>locale</code> option will
override any previously set locale values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <strong>gt</strong> table object if <code>display_table = TRUE</code> or a tibble if
<code>display_table = FALSE</code>.
</p>


<h3>The Long Display</h3>

<p>When displayed as <code>"long"</code> the multiagent report will stack individual agent
reports in a single document in the order of the agents in the multiagent
object.
</p>
<p>Each validation plan (possibly with interrogation info) will be provided and
the output for each is equivalent to calling <code><a href="#topic+get_agent_report">get_agent_report()</a></code> on each
of the agents within the multiagent object.
</p>


<h3>The Wide Display</h3>

<p>When displayed as <code>"wide"</code> the multiagent report will show data from
individual agents as columns, with rows standing as validation steps common
across the agents.
</p>
<p>Each validation step is represented with an icon (standing in for the name of
the validation function) and the associated SHA1 hash. This is a highly
trustworthy way for ascertaining which validation steps are effectively
identical across interrogations. This way of organizing the report is
beneficial because different agents may have used different steps and we want
to track the validation results where the validation step doesn't change but
the target table does (i.e., new rows are added, existing rows are updated,
etc.).
</p>
<p>The single table from this display mode will have the following columns:
</p>

<ul>
<li><p> STEP: the SHA1 hash for the validation step, possibly shared among
several interrogations.
</p>
</li>
<li> <p><em>subsequent columns</em>: each column beyond <code>STEP</code> represents a separate
interrogation from an <em>agent</em> object. The time stamp for the completion of
each interrogation is shown as the column label.
</p>
</li></ul>



<h3>Examples</h3>

<p>Let's walk through several theoretical data quality analyses of an extremely
small table. that table is called <code>small_table</code> and we can find it as a
dataset in this package.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>To set failure limits and signal conditions, we designate proportional
failure thresholds to the <code>warn</code>, <code>stop</code>, and <code>notify</code> states using
<code>action_levels()</code>.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 0.05,
    stop_at = 0.10,
    notify_at = 0.20
  )
</pre></div>
<p>We will create four different agents and have slightly different validation
steps in each of them. In the first, <code>agent_1</code>, eight different validation
steps are created and the agent will interrogate the <code>small_table</code>.
</p>
<div class="sourceCode r"><pre>agent_1 &lt;-
  create_agent(
    tbl = small_table,
    label = "An example.",
    actions = al
  ) %&gt;%
  col_vals_gt(
    columns = date_time,
    value = vars(date),
    na_pass = TRUE
  ) %&gt;%
  col_vals_gt(
    columns = b, 
    value = vars(g),
    na_pass = TRUE
  ) %&gt;%
  rows_distinct() %&gt;%
  col_vals_equal(
    columns = d, 
    value = vars(d),
    na_pass = TRUE
  ) %&gt;%
  col_vals_between(
    columns = c, 
    left = vars(a), right = vars(d)
  ) %&gt;%
  col_vals_not_between(
    columns = c,
    left = 10, right = 20,
    na_pass = TRUE
  ) %&gt;%
  rows_distinct(columns = d, e, f) %&gt;%
  col_is_integer(columns = a) %&gt;%
  interrogate()
</pre></div>
<p>The second agent, <code>agent_2</code>, retains all of the steps of <code>agent_1</code> and adds
two more (the last of which is inactive).
</p>
<div class="sourceCode r"><pre>agent_2 &lt;- 
  agent_1 %&gt;%
  col_exists(columns = date, date_time) %&gt;%
  col_vals_regex(
    columns = b, 
    regex = "[0-9]-[a-z]{3}-[0-9]{3}",
    active = FALSE
  ) %&gt;%
  interrogate()
</pre></div>
<p>The third agent, <code>agent_3</code>, adds a single validation step, removes the fifth
one, and deactivates the first.
</p>
<div class="sourceCode r"><pre>agent_3 &lt;- 
  agent_2 %&gt;%
  col_vals_in_set(
    columns = f,
    set = c("low", "mid", "high")
  ) %&gt;%
  remove_steps(i = 5) %&gt;%
  deactivate_steps(i = 1) %&gt;%
  interrogate()
</pre></div>
<p>The fourth and final agent, <code>agent_4</code>, reactivates steps 1 and 10, and
removes the sixth step.
</p>
<div class="sourceCode r"><pre>agent_4 &lt;-
  agent_3 %&gt;%
  activate_steps(i = 1) %&gt;%
  activate_steps(i = 10) %&gt;%
  remove_steps(i = 6) %&gt;%
  interrogate()
</pre></div>
<p>While all the agents are slightly different from each other, we can still get
a combined report of them by creating a 'multiagent'.
</p>
<div class="sourceCode r"><pre>multiagent &lt;-
  create_multiagent(
    agent_1, agent_2, agent_3, agent_4
  )
</pre></div>
<p>Calling <code>multiagent</code> in the console prints the multiagent report. But we can
generate a <code>"ptblank_multiagent_report"</code> object with the
<code>get_multiagent_report()</code> function and specify options for layout and
presentation.
</p>
<p>By default, <code>get_multiagent_report()</code> gives you a long report with agent
reports being stacked. Think of this <code>"long"</code> option as the serial mode of
agent reports. However if we want to view interrogation results of the same
table over time, the wide view may be preferable. In this way we can see
whether the results of common validation steps improved or worsened over
consecutive interrogations of the data.
</p>
<div class="sourceCode r"><pre>report_wide &lt;- 
  get_multiagent_report(
    multiagent,
    display_mode = "wide"
  )
  
report_wide
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_get_multiagent_report_1.png" alt="This image was generated from the first code example in the `get_multiagent_report()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>10-3
</p>


<h3>See Also</h3>

<p>Other The multiagent: 
<code><a href="#topic+create_multiagent">create_multiagent</a>()</code>,
<code><a href="#topic+read_disk_multiagent">read_disk_multiagent</a>()</code>
</p>

<hr>
<h2 id='get_sundered_data'>Sunder the data, splitting it into 'pass' and 'fail' pieces</h2><span id='topic+get_sundered_data'></span>

<h3>Description</h3>

<p>Validation of the data is one thing but, sometimes, you want to use the best
part of the input dataset for something else. The <code>get_sundered_data()</code>
function works with an agent object that has intel (i.e., post
<code>interrogate()</code>) and gets either the 'pass' data piece (rows with no failing
test units across all row-based validation functions), or, the 'fail' data
piece (rows with at least one failing test unit across the same series of
validations). As a final option, we can have emit all the data with a new
column (called <code>.pb_combined</code>) which labels each row as passing or failing
across validation steps. These labels are <code>"pass"</code> and <code>"fail"</code> by default
but their values can be easily customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sundered_data(
  agent,
  type = c("pass", "fail", "combined"),
  pass_fail = c("pass", "fail"),
  id_cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sundered_data_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function. It should have had <code><a href="#topic+interrogate">interrogate()</a></code> called on
it, such that the validation steps were actually carried out.</p>
</td></tr>
<tr><td><code id="get_sundered_data_+3A_type">type</code></td>
<td>
<p>The desired piece of data resulting from the splitting. Options
for returning a single table are <code>"pass"</code> (the default) and <code>"fail"</code>. Each
of these options return a single table with, in the <code>"pass"</code> case, only the
rows that passed across all validation steps (i.e., had no failing test
units in any part of a row for any validation step), or, the complementary
set of rows in the <code>"fail"</code> case. Providing <code>NULL</code> returns both of the
split data tables in a list (with the names of <code>"pass"</code> and <code>"fail"</code>). The
option <code>"combined"</code> applies a categorical (pass/fail) label (settable in
the <code>pass_fail</code> argument) in a new <code>.pb_combined</code> flag column. For this
case the ordering of rows is fully retained from the input table.</p>
</td></tr>
<tr><td><code id="get_sundered_data_+3A_pass_fail">pass_fail</code></td>
<td>
<p>A vector for encoding the flag column with 'pass' and 'fail'
values when <code>type = "combined"</code>. The default is <code>c("pass", "fail")</code> but
other options could be <code>c(TRUE, FALSE)</code>, <code>c(1, 0)</code>, or <code>c(1L, 0L)</code>.</p>
</td></tr>
<tr><td><code id="get_sundered_data_+3A_id_cols">id_cols</code></td>
<td>
<p>An optional specification of one or more identifying columns.
When taken together, we can count on this single column or grouping of
columns to distinguish rows. If the table undergoing validation is not a
data frame or tibble, then columns need to be specified for <code>id_cols</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are some caveats to sundering. The validation steps considered for this
splitting has to be of the row-based variety (e.g., the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>
functions or <code><a href="#topic+conjointly">conjointly()</a></code>, but not <code>rows_distinct()</code>). Furthermore,
validation steps that experienced evaluation issues during interrogation are
not considered, and, validation steps where <code>active = FALSE</code> will be
disregarded. The collection of validation steps that fulfill the above
requirements for sundering are termed in-consideration validation steps.
</p>
<p>If using any <code>preconditions</code> for validation steps, we must ensure that all
in-consideration validation steps use the same specified <code>preconditions</code>
function. Put another way, we cannot split the target table using a
collection of in-consideration validation steps that use different forms of
the input table.
</p>


<h3>Value</h3>

<p>A list of table objects if <code>type</code> is <code>NULL</code>, or, a single table if a
<code>type</code> is given.
</p>


<h3>Examples</h3>

<p>Create a series of two validation steps focused on testing row values for
part of the <code>small_table</code> object. Then, use <code><a href="#topic+interrogate">interrogate()</a></code> to put the
validation plan into action.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(
    tbl = small_table %&gt;%
      dplyr::select(a:f),
    label = "`get_sundered_data()`"
  ) %&gt;%
  col_vals_gt(columns = d, value = 1000) %&gt;%
  col_vals_between(
    columns = c,
    left = vars(a), right = vars(d),
    na_pass = TRUE
  ) %&gt;%
  interrogate()
</pre></div>
<p>Get the sundered data piece that contains only rows that passed both
validation steps (the default piece). This yields 5 of 13 total rows.
</p>
<div class="sourceCode r"><pre>agent %&gt;% get_sundered_data()
</pre></div>
<pre>## # A tibble: 5 × 6
##       a b             c      d e     f    
##   &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
## 1     2 1-bcd-345     3  3423. TRUE  high 
## 2     3 5-egh-163     8 10000. TRUE  low  
## 3     2 5-jdo-903    NA  3892. FALSE mid  
## 4     4 2-dhe-923     4  3291. TRUE  mid  
## 5     1 3-dka-303    NA  2230. TRUE  high</pre>
<p>Get the complementary data piece: all of those rows that failed either of the
two validation steps. This yields 8 of 13 total rows.
</p>
<div class="sourceCode r"><pre>agent %&gt;% get_sundered_data(type = "fail")
</pre></div>
<pre>## # A tibble: 8 × 6
##       a b             c     d e     f    
##   &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
## 1     6 8-kdg-938     3 2343. TRUE  high 
## 2     8 3-ldm-038     7  284. TRUE  low  
## 3     7 1-knw-093     3  843. TRUE  high 
## 4     4 5-boe-639     2 1036. FALSE low  
## 5     3 5-bce-642     9  838. FALSE high 
## 6     3 5-bce-642     9  838. FALSE high 
## 7     4 2-dmx-010     7  834. TRUE  low  
## 8     2 7-dmx-010     8  108. FALSE low</pre>
<p>We can get all of the input data returned with a flag column (called
<code>.pb_combined</code>). This is done by using <code>type = "combined"</code> and that rightmost
column will contain <code>"pass"</code> and <code>"fail"</code> values.
</p>
<div class="sourceCode r"><pre>agent %&gt;% get_sundered_data(type = "combined")
</pre></div>
<pre>## # A tibble: 13 × 7
##        a b             c      d e     f     .pb_combined
##    &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
##  1     2 1-bcd-345     3  3423. TRUE  high  pass
##  2     3 5-egh-163     8 10000. TRUE  low   pass
##  3     6 8-kdg-938     3  2343. TRUE  high  fail
##  4     2 5-jdo-903    NA  3892. FALSE mid   pass
##  5     8 3-ldm-038     7   284. TRUE  low   fail
##  6     4 2-dhe-923     4  3291. TRUE  mid   pass
##  7     7 1-knw-093     3   843. TRUE  high  fail
##  8     4 5-boe-639     2  1036. FALSE low   fail
##  9     3 5-bce-642     9   838. FALSE high  fail
## 10     3 5-bce-642     9   838. FALSE high  fail
## 11     4 2-dmx-010     7   834. TRUE  low   fail
## 12     2 7-dmx-010     8   108. FALSE low   fail
## 13     1 3-dka-303    NA  2230. TRUE  high  pass</pre>
<p>We can change the <code>"pass"</code> or <code>"fail"</code> text values to another type of coding
with the <code>pass_fail</code> argument. One possibility is <code>TRUE</code>/<code>FALSE</code>.
</p>
<div class="sourceCode r"><pre>agent %&gt;%
  get_sundered_data(
    type = "combined",
    pass_fail = c(TRUE, FALSE)
  )
</pre></div>
<pre>## # A tibble: 13 × 7
##        a b             c      d e     f     .pb_combined
##    &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;lgl&gt;
##  1     2 1-bcd-345     3  3423. TRUE  high  TRUE
##  2     3 5-egh-163     8 10000. TRUE  low   TRUE
##  3     6 8-kdg-938     3  2343. TRUE  high  FALSE
##  4     2 5-jdo-903    NA  3892. FALSE mid   TRUE
##  5     8 3-ldm-038     7   284. TRUE  low   FALSE
##  6     4 2-dhe-923     4  3291. TRUE  mid   TRUE
##  7     7 1-knw-093     3   843. TRUE  high  FALSE
##  8     4 5-boe-639     2  1036. FALSE low   FALSE
##  9     3 5-bce-642     9   838. FALSE high  FALSE
## 10     3 5-bce-642     9   838. FALSE high  FALSE
## 11     4 2-dmx-010     7   834. TRUE  low   FALSE
## 12     2 7-dmx-010     8   108. FALSE low   FALSE
## 13     1 3-dka-303    NA  2230. TRUE  high  TRUE</pre>
<p>...and using <code>0</code> and <code>1</code> might be worthwhile in some situations.
</p>
<div class="sourceCode r"><pre>agent %&gt;%
  get_sundered_data(
    type = "combined",
    pass_fail = 0:1
  )
</pre></div>
<pre>## # A tibble: 13 × 7
##        a b             c      d e     f     .pb_combined
##    &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;        &lt;int&gt;
##  1     2 1-bcd-345     3  3423. TRUE  high             0
##  2     3 5-egh-163     8 10000. TRUE  low              0
##  3     6 8-kdg-938     3  2343. TRUE  high             1
##  4     2 5-jdo-903    NA  3892. FALSE mid              0
##  5     8 3-ldm-038     7   284. TRUE  low              1
##  6     4 2-dhe-923     4  3291. TRUE  mid              0
##  7     7 1-knw-093     3   843. TRUE  high             1
##  8     4 5-boe-639     2  1036. FALSE low              1
##  9     3 5-bce-642     9   838. FALSE high             1
## 10     3 5-bce-642     9   838. FALSE high             1
## 11     4 2-dmx-010     7   834. TRUE  low              1
## 12     2 7-dmx-010     8   108. FALSE low              1
## 13     1 3-dka-303    NA  2230. TRUE  high             0</pre>


<h3>Function ID</h3>

<p>8-3
</p>


<h3>See Also</h3>

<p>Other Post-interrogation: 
<code><a href="#topic+all_passed">all_passed</a>()</code>,
<code><a href="#topic+get_agent_x_list">get_agent_x_list</a>()</code>,
<code><a href="#topic+get_data_extracts">get_data_extracts</a>()</code>,
<code><a href="#topic+write_testthat_file">write_testthat_file</a>()</code>
</p>

<hr>
<h2 id='get_tt_param'>Get a parameter value from a summary table</h2><span id='topic+get_tt_param'></span>

<h3>Description</h3>

<p>The <code>get_tt_param()</code> function can help you to obtain a single parameter value
from a summary table generated by the <code style="white-space: pre;">&#8288;tt_*()&#8288;</code> functions
<code><a href="#topic+tt_summary_stats">tt_summary_stats()</a></code>, <code><a href="#topic+tt_string_info">tt_string_info()</a></code>, <code><a href="#topic+tt_tbl_dims">tt_tbl_dims()</a></code>, or
<code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames()</a></code>. The following parameters are to be used depending on the
input <code>tbl</code>:
</p>

<ul>
<li><p> from <code><a href="#topic+tt_summary_stats">tt_summary_stats()</a></code>: <code>"min"</code>, <code>"p05"</code>, <code>"q_1"</code>, <code>"med"</code>, <code>"q_3"</code>,
<code>"p95"</code>, <code>"max"</code>, <code>"iqr"</code>, <code>"range"</code>
</p>
</li>
<li><p> from <code><a href="#topic+tt_string_info">tt_string_info()</a></code>: <code>"length_mean"</code>, <code>"length_min"</code>, <code>"length_max"</code>
</p>
</li>
<li><p> from <code><a href="#topic+tt_tbl_dims">tt_tbl_dims()</a></code>: <code>"rows"</code>, <code>"columns"</code>
</p>
</li>
<li><p> from <code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames()</a></code>: any integer present in the <code>.param.</code> column
</p>
</li></ul>

<p>The <code><a href="#topic+tt_summary_stats">tt_summary_stats()</a></code> and <code><a href="#topic+tt_string_info">tt_string_info()</a></code> functions will generate
summary tables with columns that mirror the numeric and character columns
in their input tables, respectively. For that reason, a column name must be
supplied to the <code>column</code> argument in <code>get_tt_param()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tt_param(tbl, param, column = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_tt_param_+3A_tbl">tbl</code></td>
<td>
<p><em>Summary table generated by specific transformer functions</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A summary table generated by either of the <code><a href="#topic+tt_summary_stats">tt_summary_stats()</a></code>,
<code><a href="#topic+tt_string_info">tt_string_info()</a></code>, <code><a href="#topic+tt_tbl_dims">tt_tbl_dims()</a></code>, or <code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames()</a></code> functions.</p>
</td></tr>
<tr><td><code id="get_tt_param_+3A_param">param</code></td>
<td>
<p><em>Parameter name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The parameter name associated to the value that is to be gotten. These
parameter names are always available in the first column (<code>.param.</code>) of a
summary table obtained by <code><a href="#topic+tt_summary_stats">tt_summary_stats()</a></code>, <code><a href="#topic+tt_string_info">tt_string_info()</a></code>,
<code><a href="#topic+tt_tbl_dims">tt_tbl_dims()</a></code>, or <code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames()</a></code>.</p>
</td></tr>
<tr><td><code id="get_tt_param_+3A_column">column</code></td>
<td>
<p><em>The target column</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong> (in select cases)
</p>
<p>The column in the summary table for which the data value should be
obtained. This must be supplied for summary tables generated by
<code><a href="#topic+tt_summary_stats">tt_summary_stats()</a></code> and <code><a href="#topic+tt_string_info">tt_string_info()</a></code> (the <code><a href="#topic+tt_tbl_dims">tt_tbl_dims()</a></code> and
<code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames()</a></code> functions will always generate a two-column summary
table).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value.
</p>


<h3>Examples</h3>

<p>Get summary statistics for the first quarter of the <code>game_revenue</code> dataset
that's included in the <strong>pointblank</strong> package.
</p>
<div class="sourceCode r"><pre>stats_tbl &lt;- 
  game_revenue %&gt;%
  tt_time_slice(slice_point = 0.25) %&gt;%
  tt_summary_stats()
  
stats_tbl
#&gt; # A tibble: 9 x 3
#&gt;   .param. item_revenue session_duration
#&gt;   &lt;chr&gt;          &lt;dbl&gt;            &lt;dbl&gt;
#&gt; 1 min             0.02              5.1
#&gt; 2 p05             0.03             11  
#&gt; 3 q_1             0.08             17.2
#&gt; 4 med             0.28             28.3
#&gt; 5 q_3             1.37             32  
#&gt; 6 p95            40.0              37.1
#&gt; 7 max           143.               41  
#&gt; 8 iqr             1.28             14.8
#&gt; 9 range         143.               35.9
</pre></div>
<p>Sometimes you need a single value from the table generated by the
<code><a href="#topic+tt_summary_stats">tt_summary_stats()</a></code> function. For that, we can use the <code>get_tt_param()</code>
function. So if we wanted to test whether the maximum session duration during
the rest of the time period (the remaining 0.75) is never higher than that of
the first quarter of the year, we can supply a value from <code>stats_tbl</code> to
<code><a href="#topic+test_col_vals_lte">test_col_vals_lte()</a></code>:
</p>
<div class="sourceCode r"><pre>game_revenue %&gt;%
  tt_time_slice(
    slice_point = 0.25,
    keep = "right"
  ) %&gt;%
  test_col_vals_lte(
    columns = session_duration, 
    value = get_tt_param(
      tbl = stats_tbl,
      param = "max",
      column = "session_duration"
    )
  )
#&gt; [1] TRUE
</pre></div>


<h3>Function ID</h3>

<p>12-7
</p>


<h3>See Also</h3>

<p>Other Table Transformers: 
<code><a href="#topic+tt_string_info">tt_string_info</a>()</code>,
<code><a href="#topic+tt_summary_stats">tt_summary_stats</a>()</code>,
<code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames</a>()</code>,
<code><a href="#topic+tt_tbl_dims">tt_tbl_dims</a>()</code>,
<code><a href="#topic+tt_time_shift">tt_time_shift</a>()</code>,
<code><a href="#topic+tt_time_slice">tt_time_slice</a>()</code>
</p>

<hr>
<h2 id='has_columns'>Determine if one or more columns exist in a table</h2><span id='topic+has_columns'></span>

<h3>Description</h3>

<p>This utility function can help you easily determine whether a column of a
specified name is present in a table object. This function works well enough
on a table object but it can also be used as part of a formula in any
validation function's <code>active</code> argument. Using <code>active = ~ . %&gt;% has_columns(column_1)</code> means that the validation step will be inactive if
the target table doesn't contain a column named <code>column_1</code>. We can also use
multiple columns in <code>c()</code>, so having <code>active = ~ . %&gt;% has_columns(c(column_1, column_2))</code> in a validation step will make it
inactive at <code><a href="#topic+interrogate">interrogate()</a></code> time unless the columns <code>column_1</code> and <code>column_2</code>
are both present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_columns(x, columns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_columns_+3A_x">x</code></td>
<td>
<p><em>A data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The input table. This can be a data frame, tibble, a <code>tbl_dbi</code> object, or a
<code>tbl_spark</code> object.</p>
</td></tr>
<tr><td><code id="has_columns_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <em>required</em>
</p>
<p>One or more columns or column-selecting expressions. Each element is
checked for a match in the table <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-1 logical vector.
</p>


<h3>Examples</h3>

<p>The <code>small_table</code> dataset in the package has the columns <code>date_time</code>, <code>date</code>,
and the <code>a</code> through <code>f</code> columns.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>With <code>has_columns()</code> we can check for column existence by using it directly
on the table.
</p>
<div class="sourceCode r"><pre>small_table %&gt;% has_columns(columns = date)
</pre></div>
<div class="sourceCode"><pre>## [1] TRUE
</pre></div>
<p>Multiple column names can be supplied. The following is <code>TRUE</code> because both
columns are present in <code>small_table</code>.
</p>
<div class="sourceCode r"><pre>small_table %&gt;% has_columns(columns = c(a, b))
</pre></div>
<div class="sourceCode"><pre>## [1] TRUE
</pre></div>
<p>It's possible to use a tidyselect helper as well:
</p>
<div class="sourceCode r"><pre>small_table %&gt;% has_columns(columns = c(a, starts_with("b")))
</pre></div>
<div class="sourceCode"><pre>## [1] TRUE
</pre></div>
<p>Because column <code>h</code> isn't present, this returns <code>FALSE</code> (all specified columns
need to be present to obtain <code>TRUE</code>).
</p>
<div class="sourceCode r"><pre>small_table %&gt;% has_columns(columns = c(a, h))
</pre></div>
<div class="sourceCode"><pre>## [1] FALSE
</pre></div>
<p>The same holds in the case of tidyselect helpers. Because no columns start
with <code>"h"</code>, including <code>starts_with("h")</code> returns <code>FALSE</code> for the entire
check.
</p>
<div class="sourceCode r"><pre>small_table %&gt;% has_columns(columns = starts_with("h"))
small_table %&gt;% has_columns(columns = c(a, starts_with("h")))
</pre></div>
<div class="sourceCode"><pre>## [1] FALSE
## [1] FALSE
</pre></div>
<p>The <code>has_columns()</code> function can be useful in expressions that involve the
target table, especially if it is uncertain that the table will contain a
column that's involved in a validation.
</p>
<p>In the following agent-based validation, the first two steps will be 'active'
because all columns checked for in the expressions are present. The third
step becomes inactive because column <code>j</code> isn't there (without the <code>active</code>
statement there we would get an evaluation failure in the agent report).
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = small_table,
    tbl_name = "small_table"
  ) %&gt;%
  col_vals_gt(
    columns = c, value = vars(a),
    active = ~ . %&gt;% has_columns(c(a, c))
  ) %&gt;%
  col_vals_lt(
    columns = h, value = vars(d),
    preconditions = ~ . %&gt;% dplyr::mutate(h = d - a),
    active = ~ . %&gt;% has_columns(c(a, d))
  ) %&gt;%
  col_is_character(
    columns = j,
    active = ~ . %&gt;% has_columns(j)
  ) %&gt;%
  interrogate()
</pre></div>
<p>Through the agent's x-list, we can verify that no evaluation error (any
evaluation at all, really) had occurred. The third value, representative of
the third validation step, is actually <code>NA</code> instead of <code>FALSE</code> because the
step became inactive.
</p>
<div class="sourceCode r"><pre>x_list &lt;- get_agent_x_list(agent = agent)

x_list$eval_warning
</pre></div>
<div class="sourceCode"><pre>## [1] FALSE FALSE    NA
</pre></div>


<h3>Function ID</h3>

<p>13-2
</p>


<h3>See Also</h3>

<p>Other Utility and Helper Functions: 
<code><a href="#topic+affix_date">affix_date</a>()</code>,
<code><a href="#topic+affix_datetime">affix_datetime</a>()</code>,
<code><a href="#topic+col_schema">col_schema</a>()</code>,
<code><a href="#topic+from_github">from_github</a>()</code>,
<code><a href="#topic+stop_if_not">stop_if_not</a>()</code>
</p>

<hr>
<h2 id='incorporate'>Given an <em>informant</em> object, update and incorporate table snippets</h2><span id='topic+incorporate'></span>

<h3>Description</h3>

<p>When the <em>informant</em> object has a number of snippets available (by using
<code><a href="#topic+info_snippet">info_snippet()</a></code>) and the strings to use them (by using the <code style="white-space: pre;">&#8288;info_*()&#8288;</code>
functions and <code style="white-space: pre;">&#8288;{&lt;snippet_name&gt;}&#8288;</code> in the text elements), the process of
incorporating aspects of the table into the info text can occur by
using the <code>incorporate()</code> function. After that, the information will be fully
updated (getting the current state of table dimensions, re-rendering the
info text, etc.) and we can print the <em>informant</em> object or use the
<code><a href="#topic+get_informant_report">get_informant_report()</a></code> function to see the information report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incorporate(informant)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incorporate_+3A_informant">informant</code></td>
<td>
<p><em>The pointblank informant object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_informant&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>informant</em> object that is commonly created through the
use of the <code><a href="#topic+create_informant">create_informant()</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_informant</code> object.
</p>


<h3>Examples</h3>

<p>Take the <code>small_table</code> and assign it to <code>changing_table</code> (we'll modify it
later):
</p>
<div class="sourceCode r"><pre>changing_table &lt;- small_table

changing_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>Use <code><a href="#topic+create_informant">create_informant()</a></code> to generate an informant object with
<code>changing_table</code> given to the <code>tbl</code> argument with a leading <code>~</code> (ensures that
the table will be fetched each time it is needed, instead of being statically
stored in the object). We'll add two snippets with <code><a href="#topic+info_snippet">info_snippet()</a></code>, add
information with the <code><a href="#topic+info_columns">info_columns()</a></code> and <code><a href="#topic+info_section">info_section()</a></code> functions and then
use <code>incorporate()</code> to work the snippets into the info text.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ changing_table,
    tbl_name = "changing_table",
    label = "`informant()` example"
  ) %&gt;%
  info_snippet(
    snippet_name = "row_count",
    fn = ~ . %&gt;% nrow()
  ) %&gt;%
  info_snippet(
    snippet_name = "col_count",
    fn = ~ . %&gt;% ncol()
  ) %&gt;%
  info_columns(
    columns = a,
    info = "In the range of 1 to 10. ((SIMPLE))"
  ) %&gt;%
  info_columns(
    columns = starts_with("date"),
    info = "Time-based values (e.g., `Sys.time()`)."
  ) %&gt;%
  info_columns(
    columns = date,
    info = "The date part of `date_time`. ((CALC))"
  ) %&gt;%
  info_section(
    section_name = "rows",
    row_count = "There are {row_count} rows available."
  ) %&gt;%
  incorporate()
</pre></div>
<p>We can print the resulting object to see the information report.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_incorporate_1.png" alt="This image was generated from the first code example in the `incorporate()` help file." style="width:100%;">


<p>Let's modify <code>test_table</code> to give it more rows and an extra column.
</p>
<div class="sourceCode r"><pre>changing_table &lt;- 
  dplyr::bind_rows(changing_table, changing_table) %&gt;%
  dplyr::mutate(h = a + c)
</pre></div>
<p>Using <code>incorporate()</code> will cause the snippets to be reprocessed and
accordingly the content of the report will be updated to keep up with the
current state of the <code>changing_table</code>.
</p>
<div class="sourceCode r"><pre>informant &lt;- informant %&gt;% incorporate()
</pre></div>
<p>When printed again, we'll also see that the row and column counts in the
header have been updated to reflect the new dimensions of the target table.
Furthermore, the info text in the <code>ROWS</code> section has updated text
(<code>"There are 26 rows available."</code>).
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_incorporate_2.png" alt="This image was generated from the second code example in the `incorporate()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>7-1
</p>


<h3>See Also</h3>

<p>Other Incorporate and Report: 
<code><a href="#topic+get_informant_report">get_informant_report</a>()</code>
</p>

<hr>
<h2 id='info_columns'>Add information that focuses on aspects of a data table's columns</h2><span id='topic+info_columns'></span>

<h3>Description</h3>

<p>Upon creation of an <em>informant</em> object (with the <code><a href="#topic+create_informant">create_informant()</a></code>
function), there are two sections containing properties: (1) 'table' and (2)
'columns'. The 'columns' section is initialized with the table's column names
and their types (as <code style="white-space: pre;">&#8288;_type&#8288;</code>). Beyond that, it is useful to provide details
about the nature of each column and we can do that with the <code>info_columns()</code>
function. A single column (or multiple columns) is targeted, and then a
series of named arguments (in the form <code>entry_name = "The *info text*."</code>)
serves as additional information for the column or columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_columns(x, columns, ..., .add = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="info_columns_+3A_x">x</code></td>
<td>
<p><em>The pointblank informant object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_informant&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>informant</em> object that is commonly created through the
use of the <code><a href="#topic+create_informant">create_informant()</a></code> function.</p>
</td></tr>
<tr><td><code id="info_columns_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;|vars(&lt;columns&gt;)&#8288;</code> // <strong>required</strong>
</p>
<p>The column or set of columns to focus on. Can be defined as a column name
in quotes (e.g., <code>"&lt;column_name&gt;"</code>), one or more column names in <code>vars()</code>
(e.g., <code style="white-space: pre;">&#8288;vars(&lt;column_name&gt;)&#8288;</code>), or with a select helper (e.g.,
<code>starts_with("date")</code>).</p>
</td></tr>
<tr><td><code id="info_columns_+3A_...">...</code></td>
<td>
<p><em>Information entries</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;info-text expressions&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>Information entries as a series of named arguments. The names refer to
subsection titles within <code>COLUMN</code> -&gt; <code style="white-space: pre;">&#8288;&lt;COLUMN_NAME&gt;&#8288;</code> and the RHS contains
the <em>info text</em> (informational text that can be written as Markdown and
further styled with <em>Text Tricks</em>).</p>
</td></tr>
<tr><td><code id="info_columns_+3A_.add">.add</code></td>
<td>
<p><em>Add to existing info text</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>Should new text be added to existing text? This is <code>TRUE</code> by default;
setting to <code>FALSE</code> replaces any existing text for a property.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_informant</code> object.
</p>


<h3>Info Text</h3>

<p>The <em>info text</em> that's used for any of the <code style="white-space: pre;">&#8288;info_*()&#8288;</code> functions readily
accepts Markdown formatting, and, there are a few <em>Text Tricks</em> that can be
used to spice up the presentation. Markdown links written as <code style="white-space: pre;">&#8288;&lt; link url &gt;&#8288;</code>
or <code style="white-space: pre;">&#8288;[ link text ]( link url )&#8288;</code> will get nicely-styled links. Any dates
expressed in the ISO-8601 standard with parentheses, <code>"(2004-12-01)"</code>, will
be styled with a font variation (monospaced) and underlined in purple. Spans
of text can be converted to label-style text by using: (1) double parentheses
around text for a rectangular border as in <code style="white-space: pre;">&#8288;((label text))&#8288;</code>, or (2) triple
parentheses around text for a rounded-rectangular border like <code style="white-space: pre;">&#8288;(((label text)))&#8288;</code>.
</p>
<p>CSS style rules can be applied to spans of <em>info text</em> with the following
form:
</p>
<p><code style="white-space: pre;">&#8288;[[ info text ]]&lt;&lt; CSS style rules &gt;&gt;&#8288;</code>
</p>
<p>As an example of this in practice suppose you'd like to change the color of
some text to red and make the font appear somewhat thinner. A variation on
the following might be used:
</p>
<p><code>"This is a [[factor]]&lt;&lt;color: red; font-weight: 300;&gt;&gt; value."</code>
</p>
<p>The are quite a few CSS style rules that can be used to great effect. Here
are a few you might like:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;color: &lt;a color value&gt;;&#8288;</code> (text color)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;background-color: &lt;a color value&gt;;&#8288;</code> (the text's background color)
</p>
</li>
<li> <p><code>text-decoration: (overline | line-through | underline);</code>
</p>
</li>
<li> <p><code>text-transform: (uppercase | lowercase | capitalize);</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;letter-spacing: &lt;a +/- length value&gt;;&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;word-spacing: &lt;a +/- length value&gt;;&#8288;</code>
</p>
</li>
<li> <p><code>font-style: (normal | italic | oblique);</code>
</p>
</li>
<li> <p><code>font-weight: (normal | bold | 100-900);</code>
</p>
</li>
<li> <p><code>font-variant: (normal | bold | 100-900);</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;border: &lt;a color value&gt; &lt;a length value&gt; (solid | dashed | dotted);&#8288;</code>
</p>
</li></ul>

<p>In the above examples, 'length value' refers to a CSS length which can be
expressed in different units of measure (e.g., <code style="white-space: pre;">&#8288;12px&#8288;</code>, <code style="white-space: pre;">&#8288;1em&#8288;</code>, etc.). Some
lengths can be expressed as positive or negative values (e.g., for
<code>letter-spacing</code>). Color values can be expressed in a few ways, the most
common being in the form of hexadecimal color values or as CSS color names.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> informant can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an informant (with
<code><a href="#topic+yaml_read_informant">yaml_read_informant()</a></code>) or perform the 'incorporate' action using the target
table (via <code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code>). The way that information on table
columns is represented in YAML works like this: <em>info text</em> goes into
subsections of YAML keys named for the columns, which are themselves part of
the top-level <code>columns</code> key. Here is an example of how several calls of
<code>info_columns()</code> are expressed in R code and how the result corresponds to
the YAML representation.
</p>
<div class="sourceCode"><pre># R statement
informant %&gt;% 
  info_columns(
    columns = date_time,
    info = "*info text* 1."
  ) %&gt;%
  info_columns(
    columns = date,
    info = "*info text* 2."
  ) %&gt;%
  info_columns(
    columns = item_count,
    info = "*info text* 3. Statistics: {snippet_1}."
  ) %&gt;%
  info_columns(
    columns = c(date, date_time),
    info = "UTC time."
  )

# YAML representation
columns:
  date_time:
    _type: POSIXct, POSIXt
    info: '*info text* 1. UTC time.'
  date:
    _type: Date
    info: '*info text* 2. UTC time.'
  item_count:
    _type: integer
    info: '*info text* 3. Statistics: {snippet_1}.'
</pre></div>
<p>Subsections represented as column names are automatically generated when
creating an informant. Within these, there can be multiple subsections used
for holding <em>info text</em> on each column. The subsections used across the
different columns needn't be the same either, the only commonality that
should be enforced is the presence of the <code style="white-space: pre;">&#8288;_type&#8288;</code> key (automatically updated
at every <code><a href="#topic+incorporate">incorporate()</a></code> invocation).
</p>
<p>It's safest to use single quotation marks around any <em>info text</em> if directly
editing it in a YAML file. Note that Markdown formatting and <em>info snippet</em>
placeholders (shown here as <code>{snippet_1}</code>, see <code><a href="#topic+info_snippet">info_snippet()</a></code> for more
information) are preserved in the YAML. The Markdown to HTML conversion is
done when printing an informant (or invoking <code><a href="#topic+get_informant_report">get_informant_report()</a></code> on an
<em>informant</em>) and the processing of snippets (generation and insertion) is
done when using the <code><a href="#topic+incorporate">incorporate()</a></code> function. Thus, the source text is always
maintained in the YAML representation and is never written in processed form.
</p>


<h3>Examples</h3>

<p>Create a pointblank <code>informant</code> object with <code><a href="#topic+create_informant">create_informant()</a></code>. We can
specify a <code>tbl</code> with the <code>~</code> followed by a statement that gets the
<code>small_table</code> dataset.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "An example."
  )
</pre></div>
<p>We can add <em>info text</em> to describe the table with the various <code style="white-space: pre;">&#8288;info_*()&#8288;</code>
functions. In this example, we'll use <code>info_columns()</code> multiple times to
describe some of the columns in the <code>small_table</code> dataset. Note here that
<em>info text</em> calls are additive to the existing content inside of the
various subsections (i.e., the text will be appended and won't overwrite
existing if it lands in the same area).
</p>
<div class="sourceCode r"><pre>informant &lt;-
  informant %&gt;%
  info_columns(
    columns = a,
    info = "In the range of 1 to 10. ((SIMPLE))"
  ) %&gt;%
  info_columns(
    columns = starts_with("date"),
    info = "Time-based values (e.g., `Sys.time()`)."
  ) %&gt;%
  info_columns(
    columns = date,
    info = "The date part of `date_time`. ((CALC))"
  )
</pre></div>
<p>Upon printing the <code>informant</code> object, we see the additions made to the
'Columns' section.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_info_columns_1.png" alt="This image was generated from the first code example in the `info_columns()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>3-2
</p>


<h3>See Also</h3>

<p>Other Information Functions: 
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl</a>()</code>,
<code><a href="#topic+info_section">info_section</a>()</code>,
<code><a href="#topic+info_snippet">info_snippet</a>()</code>,
<code><a href="#topic+info_tabular">info_tabular</a>()</code>,
<code><a href="#topic+snip_highest">snip_highest</a>()</code>,
<code><a href="#topic+snip_list">snip_list</a>()</code>,
<code><a href="#topic+snip_lowest">snip_lowest</a>()</code>,
<code><a href="#topic+snip_stats">snip_stats</a>()</code>
</p>

<hr>
<h2 id='info_columns_from_tbl'>Add column information from another data table</h2><span id='topic+info_columns_from_tbl'></span>

<h3>Description</h3>

<p>The <code>info_columns_from_tbl()</code> function is a wrapper around the
<code><a href="#topic+info_columns">info_columns()</a></code> function and is useful if you wish to apply <em>info text</em> to
columns where that information already exists in a data frame (or in some
form that can readily be coaxed into a data frame). The form of the input
<code>tbl</code> (the one that contains column metadata) has a few basic requirements:
</p>

<ul>
<li><p> the data frame must have two columns
</p>
</li>
<li><p> both columns must be of class <code>character</code>
</p>
</li>
<li><p> the first column should contain column names and the second should contain
the <em>info text</em>
</p>
</li></ul>

<p>Each column that matches across tables (i.e., the <code>tbl</code> and the target table
of the informant) will have a new entry for the <code>"info"</code> property. Empty or
missing info text will be pruned from <code>tbl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_columns_from_tbl(x, tbl, .add = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="info_columns_from_tbl_+3A_x">x</code></td>
<td>
<p><em>The pointblank informant object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_informant&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>informant</em> object that is commonly created through the
use of the <code><a href="#topic+create_informant">create_informant()</a></code> function.</p>
</td></tr>
<tr><td><code id="info_columns_from_tbl_+3A_tbl">tbl</code></td>
<td>
<p><em>Metadata table with column information</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The two-column data frame which contains metadata about the target table in
the informant object.</p>
</td></tr>
<tr><td><code id="info_columns_from_tbl_+3A_.add">.add</code></td>
<td>
<p><em>Add to existing info text</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>Should new text be added to existing text? This is <code>TRUE</code> by default;
setting to <code>FALSE</code> replaces any existing text for the <code>"info"</code> property.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_informant</code> object.
</p>


<h3>Examples</h3>

<p>Create a pointblank <code>informant</code> object with <code><a href="#topic+create_informant">create_informant()</a></code>. We can
specify a <code>tbl</code> with the <code>~</code> followed by a statement that gets the
<code>game_revenue</code> dataset.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ game_revenue,
    tbl_name = "game_revenue",
    label = "An example."
  )
</pre></div>
<p>We can add <em>info text</em> to describe the data in the various columns of the
table by using <code><a href="#topic+info_columns">info_columns()</a></code> or information in another table (with
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl()</a></code>). Here, we'll do the latter. The
<code>game_revenue_info</code> dataset is included in <strong>pointblank</strong> and it contains
metadata for <code>game_revenue</code>.
</p>
<div class="sourceCode r"><pre>game_revenue_info
#&gt; # A tibble: 11 x 2
#&gt;    column           info                                                        
#&gt;    &lt;chr&gt;            &lt;chr&gt;                                                       
#&gt;  1 player_id        A `character` column with unique identifiers for each user/~
#&gt;  2 session_id       A `character` column that contains unique identifiers for e~
#&gt;  3 session_start    A date-time column that indicates when the session (contain~
#&gt;  4 time             A date-time column that indicates exactly when the player p~
#&gt;  5 item_type        A `character` column that provides the class of the item pu~
#&gt;  6 item_name        A `character` column that provides the name of the item pur~
#&gt;  7 item_revenue     A `numeric` column with the revenue amounts per item purcha~
#&gt;  8 session_duration A `numeric` column that states the length of the session (i~
#&gt;  9 start_day        A `Date` column that provides the date of first login for t~
#&gt; 10 acquisition      A `character` column that provides the method of acquisitio~
#&gt; 11 country          A `character` column that provides the probable country of ~
</pre></div>
<p>The <code>info_columns_from_tbl()</code> function takes a table object where the first
column has the column names and the second contains the <em>info text</em>.
</p>
<div class="sourceCode r"><pre>informant &lt;-
  informant %&gt;%
  info_columns_from_tbl(tbl = game_revenue_info)
</pre></div>
<p>Upon printing the <code>informant</code> object, we see the additions made to the
'Columns' section by the <code>info_columns_from_tbl(tbl = game_revenue_info)</code>
call.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_info_columns_from_tbl_1.png" alt="This image was generated from the first code example in the `info_columns_from_tbl()` help file." style="width:100%;">


<p>We can continue to add more <em>info text</em> to describe the columns since the
process is additive. The <code>info_columns_from_tbl()</code> function populates the
<code>info</code> subsection and any calls of <code><a href="#topic+info_columns">info_columns()</a></code> that also target a <code>info</code>
subsection will append text. Here, we'll add content for the <code>item_revenue</code>
and <code>acquisition</code> columns and view the updated report.
</p>
<div class="sourceCode r"><pre>informant &lt;-
  informant %&gt;%
  info_columns(
    columns = item_revenue,
    info = "Revenue reported in USD."
  ) %&gt;%
  info_columns(
    columns = acquisition,
    `top list` = "{top5_aq}"
  ) %&gt;%
  info_snippet(
    snippet_name = "top5_aq",
    fn = snip_list(column = "acquisition")
  ) %&gt;%
  incorporate()

informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_info_columns_from_tbl_2.png" alt="This image was generated from the second code example in the `info_columns_from_tbl()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>3-3
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+info_columns">info_columns()</a></code> function, which allows for manual entry of
<em>info text</em>.
</p>
<p>Other Information Functions: 
<code><a href="#topic+info_columns">info_columns</a>()</code>,
<code><a href="#topic+info_section">info_section</a>()</code>,
<code><a href="#topic+info_snippet">info_snippet</a>()</code>,
<code><a href="#topic+info_tabular">info_tabular</a>()</code>,
<code><a href="#topic+snip_highest">snip_highest</a>()</code>,
<code><a href="#topic+snip_list">snip_list</a>()</code>,
<code><a href="#topic+snip_lowest">snip_lowest</a>()</code>,
<code><a href="#topic+snip_stats">snip_stats</a>()</code>
</p>

<hr>
<h2 id='info_section'>Add information that focuses on some key aspect of the data table</h2><span id='topic+info_section'></span>

<h3>Description</h3>

<p>While the <code><a href="#topic+info_tabular">info_tabular()</a></code> and <code><a href="#topic+info_columns">info_columns()</a></code> functions allow us to
add/modify info text for specific sections, the <code>info_section()</code> makes it
possible to add sections of our own choosing and the information that make
sense for those sections. Define a <code>section_name</code> and provide a series of
named arguments (in the form <code>entry_name = "The *info text*."</code>) to build the
informational content for that section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_section(x, section_name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="info_section_+3A_x">x</code></td>
<td>
<p><em>The pointblank informant object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_informant&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>informant</em> object that is commonly created through the
use of the <code><a href="#topic+create_informant">create_informant()</a></code> function.</p>
</td></tr>
<tr><td><code id="info_section_+3A_section_name">section_name</code></td>
<td>
<p><em>The section name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the section for which this information pertains.</p>
</td></tr>
<tr><td><code id="info_section_+3A_...">...</code></td>
<td>
<p><em>Information entries</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;info-text expressions&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>Information entries as a series of named arguments. The names refer to
subsection titles within the section defined as <code>section_name</code> and the RHS
is the <em>info text</em> (informational text that can be written as Markdown and
further styled with <em>Text Tricks</em>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_informant</code> object.
</p>


<h3>Info Text</h3>

<p>The <em>info text</em> that's used for any of the <code style="white-space: pre;">&#8288;info_*()&#8288;</code> functions readily
accepts Markdown formatting, and, there are a few <em>Text Tricks</em> that can be
used to spice up the presentation. Markdown links written as <code style="white-space: pre;">&#8288;&lt; link url &gt;&#8288;</code>
or <code style="white-space: pre;">&#8288;[ link text ]( link url )&#8288;</code> will get nicely-styled links. Any dates
expressed in the ISO-8601 standard with parentheses, <code>"(2004-12-01)"</code>, will
be styled with a font variation (monospaced) and underlined in purple. Spans
of text can be converted to label-style text by using: (1) double parentheses
around text for a rectangular border as in <code style="white-space: pre;">&#8288;((label text))&#8288;</code>, or (2) triple
parentheses around text for a rounded-rectangular border like <code style="white-space: pre;">&#8288;(((label text)))&#8288;</code>.
</p>
<p>CSS style rules can be applied to spans of <em>info text</em> with the following
form:
</p>
<p><code style="white-space: pre;">&#8288;[[ info text ]]&lt;&lt; CSS style rules &gt;&gt;&#8288;</code>
</p>
<p>As an example of this in practice suppose you'd like to change the color of
some text to red and make the font appear somewhat thinner. A variation on
the following might be used:
</p>
<p><code>"This is a [[factor]]&lt;&lt;color: red; font-weight: 300;&gt;&gt; value."</code>
</p>
<p>The are quite a few CSS style rules that can be used to great effect. Here
are a few you might like:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;color: &lt;a color value&gt;;&#8288;</code> (text color)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;background-color: &lt;a color value&gt;;&#8288;</code> (the text's background color)
</p>
</li>
<li> <p><code>text-decoration: (overline | line-through | underline);</code>
</p>
</li>
<li> <p><code>text-transform: (uppercase | lowercase | capitalize);</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;letter-spacing: &lt;a +/- length value&gt;;&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;word-spacing: &lt;a +/- length value&gt;;&#8288;</code>
</p>
</li>
<li> <p><code>font-style: (normal | italic | oblique);</code>
</p>
</li>
<li> <p><code>font-weight: (normal | bold | 100-900);</code>
</p>
</li>
<li> <p><code>font-variant: (normal | bold | 100-900);</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;border: &lt;a color value&gt; &lt;a length value&gt; (solid | dashed | dotted);&#8288;</code>
</p>
</li></ul>

<p>In the above examples, 'length value' refers to a CSS length which can be
expressed in different units of measure (e.g., <code style="white-space: pre;">&#8288;12px&#8288;</code>, <code style="white-space: pre;">&#8288;1em&#8288;</code>, etc.). Some
lengths can be expressed as positive or negative values (e.g., for
<code>letter-spacing</code>). Color values can be expressed in a few ways, the most
common being in the form of hexadecimal color values or as CSS color names.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> informant can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an informant (with
<code><a href="#topic+yaml_read_informant">yaml_read_informant()</a></code>) or perform the 'incorporate' action using the target
table (via <code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code>). Extra sections (i.e., neither the
<code>table</code> nor the <code>columns</code> sections) can be generated and filled with <em>info
text</em> by using one or more calls of <code>info_section()</code>. This is how it is
expressed in both R code and in the YAML representation.
</p>
<div class="sourceCode"><pre># R statement
informant %&gt;% 
  info_section(
    section_name = "History",
    Changes = "
- Change 1
- Change 2
- Change 3",
    `Last Update` = "(2020-10-23) at 3:28 PM."
  ) %&gt;%
  info_section(
    section_name = "Additional Notes",
    `Notes 1` = "Notes with a {snippet}.",
    `Notes 2` = "**Bold notes**."
  )

# YAML representation
History:
  Changes: |2-
  
    - Change 1
    - Change 2
    - Change 3
  Last Update: (2020-10-23) at 3:28 PM.
Additional Notes:
  Notes 1: Notes with a {snippet}.
  Notes 2: '**Bold notes**.'
</pre></div>
<p>Subsections represented as column names are automatically generated when
creating an informant. Within each of the top-level sections (i.e., <code>History</code>
and <code style="white-space: pre;">&#8288;Additional Notes&#8288;</code>) there can be multiple subsections used for holding
<em>info text</em>.
</p>
<p>It's safest to use single quotation marks around any <em>info text</em> if directly
editing it in a YAML file. Note that Markdown formatting and <em>info snippet</em>
placeholders (shown here as <code>{snippet}</code>, see <code><a href="#topic+info_snippet">info_snippet()</a></code> for more
information) are preserved in the YAML. The Markdown to HTML conversion is
done when printing an informant (or invoking <code><a href="#topic+get_informant_report">get_informant_report()</a></code> on an
<em>informant</em>) and the processing of snippets (generation and insertion) is
done when using the <code><a href="#topic+incorporate">incorporate()</a></code> function. Thus, the source text is always
maintained in the YAML representation and is never written in processed form.
</p>


<h3>Examples</h3>

<p>Create a pointblank <code>informant</code> object with <code><a href="#topic+create_informant">create_informant()</a></code>. We can
specify a <code>tbl</code> with the <code>~</code> followed by a statement that gets the
<code>small_table</code> dataset.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "An example."
  )
</pre></div>
<p>An <code>informant</code> typically has the 'Table' and 'Columns' sections. We can also
create entirely different sections (that follow these) with their
own properties using the <code>info_section()</code> function. Let's create a subsection
in the report called <code>"Notes"</code> and add text to two parts of that:
<code>"creation"</code> and <code>"usage"</code>.
</p>
<div class="sourceCode r"><pre>informant &lt;-
  informant %&gt;%
  info_section(
    section_name = "Notes",
    creation = "Dataset generated on (2020-01-15).",
    usage = "`small_table %&gt;% dplyr::glimpse()`"
  ) %&gt;%
  incorporate()
</pre></div>
<p>Upon printing the <code>informant</code> object, we see the addition of the 'Notes'
section and its own information.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_info_section_1.png" alt="This image was generated from the first code example in the `info_section()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>3-4
</p>


<h3>See Also</h3>

<p>Other Information Functions: 
<code><a href="#topic+info_columns">info_columns</a>()</code>,
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl</a>()</code>,
<code><a href="#topic+info_snippet">info_snippet</a>()</code>,
<code><a href="#topic+info_tabular">info_tabular</a>()</code>,
<code><a href="#topic+snip_highest">snip_highest</a>()</code>,
<code><a href="#topic+snip_list">snip_list</a>()</code>,
<code><a href="#topic+snip_lowest">snip_lowest</a>()</code>,
<code><a href="#topic+snip_stats">snip_stats</a>()</code>
</p>

<hr>
<h2 id='info_snippet'>Generate a useful text 'snippet' from the target table</h2><span id='topic+info_snippet'></span>

<h3>Description</h3>

<p>Getting little snippets of information from a table goes hand-in-hand with
mixing those bits of info with your table info. Call <code>info_snippet()</code> to
define a snippet and how you'll get that from the target table. The snippet
definition is supplied either with a formula, or, with a
<strong>pointblank</strong>-supplied <code style="white-space: pre;">&#8288;snip_*()&#8288;</code> function. So long as you know how to
interact with a table and extract information, you can easily define snippets
for a <em>informant</em> object. And once those snippets are defined, you can insert
them into the <em>info text</em> as defined through the other <code style="white-space: pre;">&#8288;info_*()&#8288;</code> functions
(<code><a href="#topic+info_tabular">info_tabular()</a></code>, <code><a href="#topic+info_columns">info_columns()</a></code>, and <code><a href="#topic+info_section">info_section()</a></code>). Use curly braces
with just the <code>snippet_name</code> inside (e.g., <code>"This column has {n_cat} categories."</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_snippet(x, snippet_name, fn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="info_snippet_+3A_x">x</code></td>
<td>
<p><em>The pointblank informant object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_informant&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>informant</em> object that is commonly created through the
use of the <code><a href="#topic+create_informant">create_informant()</a></code> function.</p>
</td></tr>
<tr><td><code id="info_snippet_+3A_snippet_name">snippet_name</code></td>
<td>
<p><em>The snippet name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name for snippet, which is used for interpolating the result of the
snippet formula into <em>info text</em> defined by an <code style="white-space: pre;">&#8288;info_*()&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="info_snippet_+3A_fn">fn</code></td>
<td>
<p><em>Function for snippet text generation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;function&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A formula that obtains a snippet of data from the target table. It's best
to use a leading dot (<code>.</code>) that stands for the table itself and use pipes
to construct a series of operations to be performed on the table (e.g.,
<code>~ . %&gt;% dplyr::pull(column_2) %&gt;% max(na.rm = TRUE)</code>). So long as the
result is a length-1 vector, it'll likely be valid for insertion into some
info text. Alternatively, a <code style="white-space: pre;">&#8288;snip_*()&#8288;</code> function can be used here (these
functions always return a formula that's suitable for all types of data
sources).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_informant</code> object.
</p>


<h3>Snip functions provided in <strong>pointblank</strong></h3>

<p>For convenience, there are several <code style="white-space: pre;">&#8288;snip_*()&#8288;</code> functions provided in the
package that work on column data from the <em>informant</em>'s target table. These
are:
</p>

<ul>
<li> <p><code><a href="#topic+snip_list">snip_list()</a></code>: get a list of column categories
</p>
</li>
<li> <p><code><a href="#topic+snip_stats">snip_stats()</a></code>: get an inline statistical summary
</p>
</li>
<li> <p><code><a href="#topic+snip_lowest">snip_lowest()</a></code>: get the lowest value from a column
</p>
</li>
<li> <p><code><a href="#topic+snip_highest">snip_highest()</a></code> : get the highest value from a column
</p>
</li></ul>

<p>As it's understood what the target table is, only the <code>column</code> in each of
these functions is necessary for obtaining the resultant text.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> informant can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an informant (with
<code><a href="#topic+yaml_read_informant">yaml_read_informant()</a></code>) or perform the 'incorporate' action using the target
table (via <code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code>). Snippets are stored in the YAML
representation and here is is how they are expressed in both R code and in
the YAML output (showing both the <code>meta_snippets</code> and <code>columns</code> keys to
demonstrate their relationship here).
</p>
<div class="sourceCode"><pre># R statement
informant %&gt;% 
  info_columns(
    columns = date_time,
    `Latest Date` = "The latest date is {latest_date}."
  ) %&gt;%
  info_snippet(
    snippet_name = "latest_date",
    fn = ~ . %&gt;% dplyr::pull(date) %&gt;% max(na.rm = TRUE)
  ) %&gt;%
  incorporate()

# YAML representation
meta_snippets:
  latest_date: ~. %&gt;% dplyr::pull(date) %&gt;% max(na.rm = TRUE)
...
columns:
  date_time:
    _type: POSIXct, POSIXt
    Latest Date: The latest date is {latest_date}.
  date:
    _type: Date
  item_count:
    _type: integer
</pre></div>


<h3>Examples</h3>

<p>Take the <code>small_table</code> dataset included in <strong>pointblank</strong> and assign it to
<code>test_table</code>. We'll modify it later.
</p>
<div class="sourceCode r"><pre>test_table &lt;- small_table
</pre></div>
<p>Generate an informant object, add two snippets with <code>info_snippet()</code>,
add information with some other <code style="white-space: pre;">&#8288;info_*()&#8288;</code> functions and then <code><a href="#topic+incorporate">incorporate()</a></code>
the snippets into the info text. The first snippet will be made with the
expression <code>~ . %&gt;% nrow()</code> (giving us the number of rows in the dataset) and
the second uses the <code><a href="#topic+snip_highest">snip_highest()</a></code> function with column <code>a</code> (giving us
the highest value in that column).
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ test_table,
    tbl_name = "test_table",
    label = "An example."
  ) %&gt;%
  info_snippet(
    snippet_name = "row_count",
    fn = ~ . %&gt;% nrow()
  ) %&gt;%
  info_snippet(
    snippet_name = "max_a",
    fn = snip_highest(column = "a")
  ) %&gt;%
  info_columns(
    columns = a,
    info = "In the range of 1 to {max_a}. ((SIMPLE))"
  ) %&gt;%
  info_columns(
    columns = starts_with("date"),
    info = "Time-based values (e.g., `Sys.time()`)."
  ) %&gt;%
  info_columns(
    columns = date,
    info = "The date part of `date_time`. ((CALC))"
  ) %&gt;%
  info_section(
    section_name = "rows",
    row_count = "There are {row_count} rows available."
  ) %&gt;%
  incorporate()
</pre></div>
<p>We can print the <code>informant</code> object to see the information report.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_info_snippet_1.png" alt="This image was generated from the first code example in the `info_snippet()` help file." style="width:100%;">


<p>Let's modify <code>test_table</code> with some <strong>dplyr</strong> to give it more rows and an
extra column.
</p>
<div class="sourceCode r"><pre>test_table &lt;- 
  dplyr::bind_rows(test_table, test_table) %&gt;%
  dplyr::mutate(h = a + c)
</pre></div>
<p>Using <code><a href="#topic+incorporate">incorporate()</a></code> on the <code>informant</code> object will cause the snippets to be
reprocessed, and, the info text to be updated.
</p>
<div class="sourceCode r"><pre>informant &lt;- informant %&gt;% incorporate()

informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_info_snippet_2.png" alt="This image was generated from the second code example in the `info_snippet()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>3-5
</p>


<h3>See Also</h3>

<p>Other Information Functions: 
<code><a href="#topic+info_columns">info_columns</a>()</code>,
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl</a>()</code>,
<code><a href="#topic+info_section">info_section</a>()</code>,
<code><a href="#topic+info_tabular">info_tabular</a>()</code>,
<code><a href="#topic+snip_highest">snip_highest</a>()</code>,
<code><a href="#topic+snip_list">snip_list</a>()</code>,
<code><a href="#topic+snip_lowest">snip_lowest</a>()</code>,
<code><a href="#topic+snip_stats">snip_stats</a>()</code>
</p>

<hr>
<h2 id='info_tabular'>Add information that focuses on aspects of the data table as a whole</h2><span id='topic+info_tabular'></span>

<h3>Description</h3>

<p>When an <em>informant</em> object is created with the <code><a href="#topic+create_informant">create_informant()</a></code> function,
it has two starter sections: (1) 'table' and (2) 'columns'. The 'table'
section should contain a few properties upon creation, such as the supplied
table name (<code>name</code>) and table dimensions (as <code style="white-space: pre;">&#8288;_columns&#8288;</code> and <code style="white-space: pre;">&#8288;_rows&#8288;</code>). We can
add more table-based properties with the <code>info_tabular()</code> function. By
providing a series of named arguments (in the form <code>entry_name = "The *info text*."</code>), we can add more information that makes sense for describing the
table as a whole.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_tabular(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="info_tabular_+3A_x">x</code></td>
<td>
<p><em>The pointblank informant object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_informant&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>informant</em> object that is commonly created through the
use of the <code><a href="#topic+create_informant">create_informant()</a></code> function.</p>
</td></tr>
<tr><td><code id="info_tabular_+3A_...">...</code></td>
<td>
<p><em>Information entries</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;info-text expressions&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>Information entries as a series of named arguments. The names refer to
subsection titles within the <code>TABLE</code> section and the values are the <em>info
text</em> (informational text that can be written as Markdown and further
styled with <em>Text Tricks</em>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_informant</code> object.
</p>


<h3>Info Text</h3>

<p>The <em>info text</em> that's used for any of the <code style="white-space: pre;">&#8288;info_*()&#8288;</code> functions readily
accepts Markdown formatting, and, there are a few <em>Text Tricks</em> that can be
used to spice up the presentation. Markdown links written as <code style="white-space: pre;">&#8288;&lt; link url &gt;&#8288;</code>
or <code style="white-space: pre;">&#8288;[ link text ]( link url )&#8288;</code> will get nicely-styled links. Any dates
expressed in the ISO-8601 standard with parentheses, <code>"(2004-12-01)"</code>, will
be styled with a font variation (monospaced) and underlined in purple. Spans
of text can be converted to label-style text by using: (1) double parentheses
around text for a rectangular border as in <code style="white-space: pre;">&#8288;((label text))&#8288;</code>, or (2) triple
parentheses around text for a rounded-rectangular border like <code style="white-space: pre;">&#8288;(((label text)))&#8288;</code>.
</p>
<p>CSS style rules can be applied to spans of <em>info text</em> with the following
form:
</p>
<p><code style="white-space: pre;">&#8288;[[ info text ]]&lt;&lt; CSS style rules &gt;&gt;&#8288;</code>
</p>
<p>As an example of this in practice suppose you'd like to change the color of
some text to red and make the font appear somewhat thinner. A variation on
the following might be used:
</p>
<p><code>"This is a [[factor]]&lt;&lt;color: red; font-weight: 300;&gt;&gt; value."</code>
</p>
<p>The are quite a few CSS style rules that can be used to great effect. Here
are a few you might like:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;color: &lt;a color value&gt;;&#8288;</code> (text color)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;background-color: &lt;a color value&gt;;&#8288;</code> (the text's background color)
</p>
</li>
<li> <p><code>text-decoration: (overline | line-through | underline);</code>
</p>
</li>
<li> <p><code>text-transform: (uppercase | lowercase | capitalize);</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;letter-spacing: &lt;a +/- length value&gt;;&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;word-spacing: &lt;a +/- length value&gt;;&#8288;</code>
</p>
</li>
<li> <p><code>font-style: (normal | italic | oblique);</code>
</p>
</li>
<li> <p><code>font-weight: (normal | bold | 100-900);</code>
</p>
</li>
<li> <p><code>font-variant: (normal | bold | 100-900);</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;border: &lt;a color value&gt; &lt;a length value&gt; (solid | dashed | dotted);&#8288;</code>
</p>
</li></ul>

<p>In the above examples, 'length value' refers to a CSS length which can be
expressed in different units of measure (e.g., <code style="white-space: pre;">&#8288;12px&#8288;</code>, <code style="white-space: pre;">&#8288;1em&#8288;</code>, etc.). Some
lengths can be expressed as positive or negative values (e.g., for
<code>letter-spacing</code>). Color values can be expressed in a few ways, the most
common being in the form of hexadecimal color values or as CSS color names.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> informant can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an informant (with
<code><a href="#topic+yaml_read_informant">yaml_read_informant()</a></code>) or perform the 'incorporate' action using the target
table (via <code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code>). When <code>info_tabular()</code> is
represented in YAML, <em>info text</em> goes into subsections of the top-level
<code>table</code> key. Here is an example of how a call of <code>info_tabular()</code> is
expressed in R code and in the corresponding YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>informant %&gt;% 
  info_tabular(
    section_1 = "*info text* 1.",
    `section 2` = "*info text* 2 and {snippet_1}"
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>table:
  _columns: 23
  _rows: 205.0
  _type: tbl_df
  section_1: '*info text* 1.'
  section 2: '*info text* 2 and {snippet_1}'
</pre></div>
<p>Subsection titles as defined in <code>info_tabular()</code> can be set in backticks if
they are not syntactically correct as an argument name without them (e.g.,
when using spaces, hyphens, etc.).
</p>
<p>It's safest to use single quotation marks around any <em>info text</em> if directly
editing it in a YAML file. Note that Markdown formatting and <em>info snippet</em>
placeholders (shown here as <code>{snippet_1}</code>, see <code><a href="#topic+info_snippet">info_snippet()</a></code> for more
information) are preserved in the YAML. The Markdown to HTML conversion is
done when printing an informant (or invoking <code><a href="#topic+get_informant_report">get_informant_report()</a></code> on an
<em>informant</em>) and the processing of snippets (generation and insertion) is
done when using the <code><a href="#topic+incorporate">incorporate()</a></code> function. Thus, the source text is always
maintained in the YAML representation and is never written in processed form.
</p>


<h3>Examples</h3>

<p>Create a pointblank <code>informant</code> object with <code><a href="#topic+create_informant">create_informant()</a></code>. We can
specify a <code>tbl</code> with the <code>~</code> followed by a statement that gets the
<code>small_table</code> dataset.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "An example."
  )
</pre></div>
<p>We can add <em>info text</em> to describe the table with the various <code style="white-space: pre;">&#8288;info_*()&#8288;</code>
functions. In this example, we'll use <code><a href="#topic+info_tabular">info_tabular()</a></code> to generally describe
the <code>small_table</code> dataset.
</p>
<div class="sourceCode r"><pre>informant &lt;-
  informant %&gt;%
  info_tabular(
    `Row Definition` = "A row has randomized values.",
    Source = c(
      "- From the **pointblank** package.",
      "- [https://rstudio.github.io/pointblank/]()"
     )
   )
</pre></div>
<p>Upon printing the <code>informant</code> object, we see the additions made to the
'Table' section of the report.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_info_tabular_1.png" alt="This image was generated from the first code example in the `info_tabular()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>3-1
</p>


<h3>See Also</h3>

<p>Other Information Functions: 
<code><a href="#topic+info_columns">info_columns</a>()</code>,
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl</a>()</code>,
<code><a href="#topic+info_section">info_section</a>()</code>,
<code><a href="#topic+info_snippet">info_snippet</a>()</code>,
<code><a href="#topic+snip_highest">snip_highest</a>()</code>,
<code><a href="#topic+snip_list">snip_list</a>()</code>,
<code><a href="#topic+snip_lowest">snip_lowest</a>()</code>,
<code><a href="#topic+snip_stats">snip_stats</a>()</code>
</p>

<hr>
<h2 id='interrogate'>Given an agent that has a validation plan, perform an interrogation</h2><span id='topic+interrogate'></span>

<h3>Description</h3>

<p>When the agent has all the information on what to do (i.e., a validation plan
which is a series of validation steps), the interrogation process can occur
according its plan. After that, the agent will have gathered intel, and we
can use functions like <code><a href="#topic+get_agent_report">get_agent_report()</a></code> and <code><a href="#topic+all_passed">all_passed()</a></code> to understand
how the interrogation went down.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interrogate(
  agent,
  extract_failed = TRUE,
  extract_tbl_checked = TRUE,
  get_first_n = NULL,
  sample_n = NULL,
  sample_frac = NULL,
  sample_limit = 5000,
  show_step_label = FALSE,
  progress = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interrogate_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function.</p>
</td></tr>
<tr><td><code id="interrogate_+3A_extract_failed">extract_failed</code></td>
<td>
<p><em>Collect failed rows as data extracts</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>An option to collect rows that didn't pass a particular validation step.
The default is <code>TRUE</code> and further options allow for fine control of how
these rows are collected.</p>
</td></tr>
<tr><td><code id="interrogate_+3A_extract_tbl_checked">extract_tbl_checked</code></td>
<td>
<p><em>Collect validation results from each step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>An option to collect processed data frames produced by executing the
validation steps. This information is necessary for some functions
(e.g., <code>get_sundered_data()</code>), but may grow to a large size. To opt out
of attaching this data to the agent, set this argument to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="interrogate_+3A_get_first_n">get_first_n</code></td>
<td>
<p><em>Get the first n values</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>If the option to collect non-passing rows is chosen, there is the option
here to collect the first <code>n</code> rows here. Supply the number of rows to
extract from the top of the non-passing rows table (the ordering of data
from the original table is retained).</p>
</td></tr>
<tr><td><code id="interrogate_+3A_sample_n">sample_n</code></td>
<td>
<p><em>Sample n values</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>If the option to collect non-passing rows is chosen, this option allows for
the sampling of <code>n</code> rows. Supply the number of rows to sample from the
non-passing rows table. If <code>n</code> is greater than the number of non-passing
rows, then all the rows will be returned.</p>
</td></tr>
<tr><td><code id="interrogate_+3A_sample_frac">sample_frac</code></td>
<td>
<p><em>Sample a fraction of values</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;numeric&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>If the option to collect non-passing rows is chosen, this option allows for
the sampling of a fraction of those rows. Provide a number in the range of
<code>0</code> and <code>1</code>. The number of rows to return may be extremely large (and this
is especially when querying remote databases), however, the <code>sample_limit</code>
option will apply a hard limit to the returned rows.</p>
</td></tr>
<tr><td><code id="interrogate_+3A_sample_limit">sample_limit</code></td>
<td>
<p><em>Row limit for sampling</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>5000</code>
</p>
<p>A value that limits the possible number of rows returned when sampling
non-passing rows using the <code>sample_frac</code> option.</p>
</td></tr>
<tr><td><code id="interrogate_+3A_show_step_label">show_step_label</code></td>
<td>
<p><em>Show step labels in progress</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Whether to show the <code>label</code> value of each validation step in the console.</p>
</td></tr>
<tr><td><code id="interrogate_+3A_progress">progress</code></td>
<td>
<p><em>Show interrogation progress</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>interactive()</code>
</p>
<p>Whether to show the progress of an agent's interrogation in the console.
Defaults to <code>TRUE</code> in interactive sessions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_agent</code> object.
</p>


<h3>Examples</h3>

<p>Create a simple table with two columns of numerical values.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5, 8, 7),
    b = c(7, 1, 0, 0, 0, 3)
  )

tbl
#&gt; # A tibble: 6 x 2
#&gt;       a     b
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7
#&gt; 2     7     1
#&gt; 3     6     0
#&gt; 4     5     0
#&gt; 5     8     0
#&gt; 6     7     3
</pre></div>
<p>Validate that values in column <code>a</code> from <code>tbl</code> are always less than <code>5</code>. Using
<code>interrogate()</code> carries out the validation plan and completes the whole
process.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(
    tbl = tbl,
    label = "`interrogate()` example"
  ) %&gt;%
  col_vals_gt(columns = a, value = 5) %&gt;%
  interrogate()
</pre></div>
<p>We can print the resulting object to see the validation report.
</p>
<div class="sourceCode r"><pre>agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_interrogate_1.png" alt="This image was generated from the first code example in the `interrogate()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>6-1
</p>


<h3>See Also</h3>

<p>Other Interrogate and Report: 
<code><a href="#topic+get_agent_report">get_agent_report</a>()</code>
</p>

<hr>
<h2 id='log4r_step'>Enable logging of failure conditions at the validation step level</h2><span id='topic+log4r_step'></span>

<h3>Description</h3>

<p>The <code>log4r_step()</code> function can be used as an action in the <code><a href="#topic+action_levels">action_levels()</a></code>
function (as a list component for the <code>fns</code> list). Place a call to this
function in every failure condition that should produce a log (i.e., <code>warn</code>,
<code>stop</code>, <code>notify</code>). Only the failure condition with the highest severity for a
given validation step will produce a log entry (skipping failure conditions
with lower severity) so long as the call to <code>log4r_step()</code> is present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log4r_step(x, message = NULL, append_to = "pb_log_file")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log4r_step_+3A_x">x</code></td>
<td>
<p>A reference to the x-list object prepared by the <code>agent</code>. This
version of the x-list is the same as that generated via
<code style="white-space: pre;">&#8288;get_agent_x_list(&lt;agent&gt;, i = &lt;step&gt;)&#8288;</code> except this version is internally
generated and hence only available in an internal evaluation context.</p>
</td></tr>
<tr><td><code id="log4r_step_+3A_message">message</code></td>
<td>
<p>The message to use for the log entry. When not provided, a
default glue string is used for the messaging. This is dynamic since the
internal <code>glue::glue()</code> call occurs in the same environment as <code>x</code>, the
x-list that's constrained to the validation step. The default message, used
when <code>message = NULL</code> is the glue string <code>"Step {x$i} exceeded the {level} failure threshold (f_failed = {x$f_failed}) ['{x$type}']"</code>. As can be seen,
a custom message can be crafted that uses other elements of the x-list with
the <code style="white-space: pre;">&#8288;{x$&lt;component&gt;}&#8288;</code> construction.</p>
</td></tr>
<tr><td><code id="log4r_step_+3A_append_to">append_to</code></td>
<td>
<p>The file to which log entries at the warn level are
appended. This can alternatively be one or more <strong>log4r</strong> appenders.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned however log files may be written in very specific
conditions.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). Here is an
example of how <code>log4r_step()</code> can be expressed in R code (within
<code><a href="#topic+action_levels">action_levels()</a></code>, itself inside <code><a href="#topic+create_agent">create_agent()</a></code>) and in the corresponding
YAML representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>create_agent(
  tbl = ~ small_table,
  tbl_name = "small_table",
  label = "An example.",
  actions = action_levels(
    warn_at = 1,
    fns = list(
      warn = ~ log4r_step(
        x, append_to = "example_log"
      )
    )
  )
)
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>type: agent
tbl: ~small_table
tbl_name: small_table
label: An example.
lang: en
locale: en
actions:
  warn_count: 1.0
  fns:
    warn: ~log4r_step(x, append_to = "example_log")
steps: []
</pre></div>
<p>Should you need to preview the transformation of an <em>agent</em> to YAML (without
any committing anything to disk), use the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function. If
you already have a <code>.yml</code> file that holds an <em>agent</em>, you can get a glimpse
of the R expressions that are used to regenerate that agent with
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs()</a></code>.
</p>


<h3>Examples</h3>

<p>For the example provided here, we'll use the included <code>small_table</code> dataset.
We are also going to create an <code>action_levels()</code> list object since this is
useful for demonstrating a logging scenario. It will have a threshold for
the <code>warn</code> state, and, an associated function that should be invoked
whenever the <code>warn</code> state is entered. Here, the function call with
<code>log4r_step()</code> will be invoked whenever there is one failing test unit.
</p>
<div class="sourceCode r"><pre>al &lt;-
  action_levels(
    warn_at = 1,
    fns = list(
      warn = ~ log4r_step(
        x, append_to = "example_log"
      )
    )
  )
</pre></div>
<p>Within the <code><a href="#topic+action_levels">action_levels()</a></code>-produced object, it's important to match things
up: notice that <code>warn_at</code> is given a threshold and the list of functions
given to <code>fns</code> has a <code>warn</code> component.
</p>
<p>Printing <code>al</code> will show us the settings for the <code>action_levels</code> object:
</p>
<div class="sourceCode r"><pre>al
#&gt; -- The `action_levels` settings
#&gt; WARN failure threshold of 1test units.
#&gt; \fns\ ~ log4r_step(x, append_to = "example_log")
#&gt; ----
</pre></div>
<p>Let's create an agent with <code>small_table</code> as the target table. We'll apply the
<code>action_levels</code> object created above as <code>al</code>, add two validation steps, and
then <code><a href="#topic+interrogate">interrogate()</a></code> the data.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "An example.",
    actions = al
  ) %&gt;%
  col_vals_gt(columns = d, 300) %&gt;%
  col_vals_in_set(columns = f, c("low", "high")) %&gt;%
  interrogate()

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_log4r_step_1.png" alt="This image was generated from the first code example in the `log4r_step()` help file." style="width:100%;">


<p>From the agent report, we can see that both steps have yielded warnings upon
interrogation (i.e., filled yellow circles in the <code>W</code> column).
</p>
<p>What's not immediately apparent is that when entering the <code>warn</code> state
in each validation step during interrogation, the <code>log4r_step()</code> function
call was twice invoked! This generated an <code>"example_log"</code> file in the working
directory (since it was not present before the interrogation) and log entries
were appended to the file. Here are the contents of the file:
</p>
<div class="sourceCode"><pre>WARN  [2022-06-28 10:06:01] Step 1 exceeded the WARN failure threshold
  (f_failed = 0.15385) ['col_vals_gt']
WARN  [2022-06-28 10:06:01] Step 2 exceeded the WARN failure threshold
  (f_failed = 0.15385) ['col_vals_in_set']
</pre></div>


<h3>Function ID</h3>

<p>5-1
</p>

<hr>
<h2 id='print.action_levels'>Print the <code>action_levels</code> object</h2><span id='topic+print.action_levels'></span>

<h3>Description</h3>

<p>This function will allow the <code>action_levels</code> to be nicely printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'action_levels'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.action_levels_+3A_x">x</code></td>
<td>
<p>An object of class <code>action_levels</code>.</p>
</td></tr>
<tr><td><code id="print.action_levels_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='print.ptblank_agent'>Print the <code>ptblank_agent</code> object</h2><span id='topic+print.ptblank_agent'></span>

<h3>Description</h3>

<p>This function will allow the agent object to print a useful HTML-based
report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptblank_agent'
print(x, view = interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ptblank_agent_+3A_x">x</code></td>
<td>
<p>An object of class <code>ptblank_agent</code>.</p>
</td></tr>
<tr><td><code id="print.ptblank_agent_+3A_view">view</code></td>
<td>
<p>The value for <code>print()</code>s <code>browse</code> argument.</p>
</td></tr>
<tr><td><code id="print.ptblank_agent_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='print.ptblank_informant'>Print the <code>ptblank_informant</code> object</h2><span id='topic+print.ptblank_informant'></span>

<h3>Description</h3>

<p>This function will allow the informant object to print a useful HTML-based
report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptblank_informant'
print(x, view = interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ptblank_informant_+3A_x">x</code></td>
<td>
<p>An informant object of class <code>ptblank_informant</code>.</p>
</td></tr>
<tr><td><code id="print.ptblank_informant_+3A_view">view</code></td>
<td>
<p>The value for <code>print()</code>s <code>browse</code> argument.</p>
</td></tr>
<tr><td><code id="print.ptblank_informant_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='print.ptblank_multiagent'>Print the <code>ptblank_multiagent</code> object</h2><span id='topic+print.ptblank_multiagent'></span>

<h3>Description</h3>

<p>This function will allow the multiagent object to print a useful HTML-based
report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptblank_multiagent'
print(x, view = interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ptblank_multiagent_+3A_x">x</code></td>
<td>
<p>An object of class <code>ptblank_multiagent</code>.</p>
</td></tr>
<tr><td><code id="print.ptblank_multiagent_+3A_view">view</code></td>
<td>
<p>The value for <code>print()</code>s <code>browse</code> argument.</p>
</td></tr>
<tr><td><code id="print.ptblank_multiagent_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='print.ptblank_multiagent_report.long'>Print the <code>ptblank_multiagent_report.long</code> object</h2><span id='topic+print.ptblank_multiagent_report.long'></span>

<h3>Description</h3>

<p>This function will print the <code>ptblank_multiagent_report.long</code> object, which
is an HTML-based report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptblank_multiagent_report.long'
print(x, view = interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ptblank_multiagent_report.long_+3A_x">x</code></td>
<td>
<p>An object of class <code>ptblank_multiagent_report.long</code>.</p>
</td></tr>
<tr><td><code id="print.ptblank_multiagent_report.long_+3A_view">view</code></td>
<td>
<p>The value for <code>print()</code>s <code>browse</code> argument.</p>
</td></tr>
<tr><td><code id="print.ptblank_multiagent_report.long_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='print.ptblank_tbl_scan'>Print the <code>ptblank_tbl_scan</code> object</h2><span id='topic+print.ptblank_tbl_scan'></span>

<h3>Description</h3>

<p>This function will print the <code>ptblank_tbl_scan</code> object, which is an
HTML-based report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptblank_tbl_scan'
print(x, ..., view = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ptblank_tbl_scan_+3A_x">x</code></td>
<td>
<p>An object of class <code>ptblank_tbl_scan</code>.</p>
</td></tr>
<tr><td><code id="print.ptblank_tbl_scan_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
<tr><td><code id="print.ptblank_tbl_scan_+3A_view">view</code></td>
<td>
<p>The value for <code>print()</code>s <code>browse</code> argument.</p>
</td></tr>
</table>

<hr>
<h2 id='print.read_fn'>Print the a table-prep formula</h2><span id='topic+print.read_fn'></span>

<h3>Description</h3>

<p>This function will allow a table-prep formula to be nicely printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'read_fn'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.read_fn_+3A_x">x</code></td>
<td>
<p>An object of class <code>read_fn</code>.</p>
</td></tr>
<tr><td><code id="print.read_fn_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='print.tbl_store'>Print the <code>tbl_store</code> object</h2><span id='topic+print.tbl_store'></span>

<h3>Description</h3>

<p>This function will allow the <code>tbl_store</code> to be nicely printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_store'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tbl_store_+3A_x">x</code></td>
<td>
<p>An object of class <code>tbl_store</code>.</p>
</td></tr>
<tr><td><code id="print.tbl_store_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='print.x_list_i'>Print a single-step x-list to the console</h2><span id='topic+print.x_list_i'></span>

<h3>Description</h3>

<p>This function will print an x-list object, for a single step, to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'x_list_i'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.x_list_i_+3A_x">x</code></td>
<td>
<p>An x-list object of class <code>x_list_i</code>.</p>
</td></tr>
<tr><td><code id="print.x_list_i_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='print.x_list_n'>Print an x-list comprising all validation steps to the console</h2><span id='topic+print.x_list_n'></span>

<h3>Description</h3>

<p>This function will print a x-list object, with all validation steps included,
to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'x_list_n'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.x_list_n_+3A_x">x</code></td>
<td>
<p>An x-list object of class <code>x_list_n</code>.</p>
</td></tr>
<tr><td><code id="print.x_list_n_+3A_...">...</code></td>
<td>
<p>Any additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='read_disk_multiagent'>Read <strong>pointblank</strong> <em>agents</em> stored on disk as a <em>multiagent</em></h2><span id='topic+read_disk_multiagent'></span>

<h3>Description</h3>

<p>An <em>agent</em> or <em>informant</em> can be written to disk with the <code><a href="#topic+x_write_disk">x_write_disk()</a></code>
function. While useful for later retrieving the stored agent with
<code><a href="#topic+x_read_disk">x_read_disk()</a></code> it's also possible to read a series of on-disk agents with
the <code>read_disk_multiagent()</code> function, which creates a <code>ptblank_multiagent</code>
object. A <em>multiagent</em> object can also be generated via the
<code><a href="#topic+create_multiagent">create_multiagent()</a></code> function but is less convenient to use if one is just
using agents that have been previously written to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_disk_multiagent(filenames = NULL, pattern = NULL, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_disk_multiagent_+3A_filenames">filenames</code></td>
<td>
<p><em>File names</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The names of files (holding <em>agent</em> objects) that were previously written
by <code><a href="#topic+x_write_disk">x_write_disk()</a></code>.</p>
</td></tr>
<tr><td><code id="read_disk_multiagent_+3A_pattern">pattern</code></td>
<td>
<p><em>Regex pattern</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A regex pattern for accessing saved-to-disk <em>agent</em> files located in a
directory (specified in the <code>path</code> argument).</p>
</td></tr>
<tr><td><code id="read_disk_multiagent_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A path to a collection of files. This is either optional in the case that
files are specified in <code>filenames</code> (the <code>path</code> combined with all
<code>filenames</code>), or, required when providing a <code>pattern</code> for file names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_multiagent</code> object.
</p>


<h3>Function ID</h3>

<p>10-2
</p>


<h3>See Also</h3>

<p>Other The multiagent: 
<code><a href="#topic+create_multiagent">create_multiagent</a>()</code>,
<code><a href="#topic+get_multiagent_report">get_multiagent_report</a>()</code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+vars'></span><span id='topic+case_when'></span><span id='topic+between'></span><span id='topic+expr'></span><span id='topic+creds'></span><span id='topic+creds_anonymous'></span><span id='topic+creds_key'></span><span id='topic+creds_file'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>blastula</dt><dd><p><code><a href="blastula.html#topic+credential_helpers">creds</a></code>, <code><a href="blastula.html#topic+credential_helpers">creds_anonymous</a></code>, <code><a href="blastula.html#topic+credential_helpers">creds_file</a></code>, <code><a href="blastula.html#topic+credential_helpers">creds_key</a></code></p>
</dd>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+between">between</a></code>, <code><a href="dplyr.html#topic+case_when">case_when</a></code>, <code><a href="dplyr.html#topic+vars">vars</a></code></p>
</dd>
<dt>rlang</dt><dd><p><code><a href="rlang.html#topic+expr">expr</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remove_steps'>Remove one or more of an <em>agent</em>'s validation steps</h2><span id='topic+remove_steps'></span>

<h3>Description</h3>

<p>Validation steps can be removed from an <em>agent</em> object through use of the
<code>remove_steps()</code> function. This is useful, for instance, when getting an
agent from disk (via the <code><a href="#topic+x_read_disk">x_read_disk()</a></code> function) and omitting one or more
steps from the <em>agent</em>'s validation plan. Please note that when removing
validation steps all stored data extracts will be removed from the <em>agent</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_steps(agent, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_steps_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function.</p>
</td></tr>
<tr><td><code id="remove_steps_+3A_i">i</code></td>
<td>
<p><em>A validation step number</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The validation step number, which is assigned to each validation step in
the order of definition. If <code>NULL</code> (the default) then step removal won't
occur by index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_agent</code> object.
</p>
<p>A <code>ptblank_agent</code> object.
</p>


<h3>Function ID</h3>

<p>9-7
</p>


<h3>See Also</h3>

<p>Instead of removal, the <code><a href="#topic+deactivate_steps">deactivate_steps()</a></code> function will simply
change the <code>active</code> status of one or more validation steps to <code>FALSE</code> (and
<code><a href="#topic+activate_steps">activate_steps()</a></code> will do the opposite).
</p>
<p>Other Object Ops: 
<code><a href="#topic+activate_steps">activate_steps</a>()</code>,
<code><a href="#topic+deactivate_steps">deactivate_steps</a>()</code>,
<code><a href="#topic+export_report">export_report</a>()</code>,
<code><a href="#topic+set_tbl">set_tbl</a>()</code>,
<code><a href="#topic+x_read_disk">x_read_disk</a>()</code>,
<code><a href="#topic+x_write_disk">x_write_disk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an agent that has the
# `small_table` object as the
# target table, add a few
# validation steps, and then use
# `interrogate()`
agent_1 &lt;- 
  create_agent(
    tbl = small_table,
    tbl_name = "small_table",
    label = "An example."
  ) %&gt;%
  col_exists(columns = date) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]"
  ) %&gt;%
  interrogate()
  
# The second validation step has
# been determined to be unneeded and
# is to be removed; this can be done
# by using `remove_steps()` with the
# agent object
agent_2 &lt;-
  agent_1 %&gt;%
  remove_steps(i = 2) %&gt;%
  interrogate()

</code></pre>

<hr>
<h2 id='row_count_match'>Does the row count match that of a different table?</h2><span id='topic+row_count_match'></span><span id='topic+expect_row_count_match'></span><span id='topic+test_row_count_match'></span>

<h3>Description</h3>

<p>The <code>row_count_match()</code> validation function, the <code>expect_row_count_match()</code>
expectation function, and the <code>test_row_count_match()</code> test function all
check whether the row count in the target table matches that of a comparison
table. The validation function can be used directly on a data table or with
an <em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. As a
validation step or as an expectation, there is a single test unit that hinges
on whether the row counts for the two tables are the same (after any
<code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_count_match(
  x,
  count,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE,
  tbl_compare = NULL
)

expect_row_count_match(
  object,
  count,
  preconditions = NULL,
  threshold = 1,
  tbl_compare = NULL
)

test_row_count_match(
  object,
  count,
  preconditions = NULL,
  threshold = 1,
  tbl_compare = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row_count_match_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_count">count</code></td>
<td>
<p><em>The count comparison</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;numeric|integer&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>Either a literal value for the number of rows, or, a table to compare
against the target table in terms of row count values. If supplying a
comparison table, it can either be a table object such as a data frame, a
tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object. Alternatively, a
table-prep formula (<code style="white-space: pre;">&#8288;~ &lt;tbl reading code&gt;&#8288;</code>) or a function
(<code style="white-space: pre;">&#8288;function() &lt;tbl reading code&gt;&#8288;</code>) can be used to lazily read in the
comparison table at interrogation time.</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_tbl_compare">tbl_compare</code></td>
<td>
<p><em><a href="base.html#topic+Deprecated">Deprecated</a> Comparison table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The <code>tbl_compare</code> argument is deprecated. Instead, use <code>count</code>.</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="row_count_match_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that this particular validation requires some operation on the target table
before the row count comparison takes place. Using <code>preconditions</code> can be
useful at times since since we can develop a large validation plan with a
single target table and make minor adjustments to it, as needed, along the
way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed. Alternatively, a function
could instead be supplied.
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. Using
<code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices
depending on the situation (the first produces a warning, the other
<code>stop()</code>s).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>row_count_match()</code> is represented in YAML (under the top-level <code>steps</code> key
as a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>row_count_match()</code> as
a validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  row_count_match(
    count = ~ file_tbl(
      file = from_github(
        file = "sj_all_revenue_large.rds",
        repo = "rich-iannone/intendo",
        subdir = "data-large"
        )
      ),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `row_count_match()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- row_count_match:
    count: ~ file_tbl(
      file = from_github(
        file = "sj_all_revenue_large.rds",
        repo = "rich-iannone/intendo",
        subdir = "data-large"
        )
      )
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `row_count_match()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter. Arguments with default
values won't be written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is
acceptable to include them with their default when generating the YAML by
other means). It is also possible to preview the transformation of an agent
to YAML without any writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code>
function.
</p>


<h3>Examples</h3>

<p>Create a simple table with three columns and four rows of values.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5),
    b = c(7, 1, 0, 0),
    c = c(1, 1, 1, 3)
  )

tbl
#&gt; # A tibble: 4 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7     1
#&gt; 2     7     1     1
#&gt; 3     6     0     1
#&gt; 4     5     0     3
</pre></div>
<p>Create a second table which is quite different but has the same number of
rows as <code>tbl</code>.
</p>
<div class="sourceCode r"><pre>tbl_2 &lt;-
  dplyr::tibble(
    e = c("a", NA, "a", "c"),
    f = c(2.6, 1.2, 0, NA)
  )

tbl_2
#&gt; # A tibble: 4 x 2
#&gt;   e         f
#&gt;   &lt;chr&gt; &lt;dbl&gt;
#&gt; 1 a       2.6
#&gt; 2 &lt;NA&gt;    1.2
#&gt; 3 a       0  
#&gt; 4 c      NA
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the count of rows in the target table (<code>tbl</code>) matches that of
the comparison table (<code>tbl_2</code>).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  row_count_match(count = tbl_2) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_row_count_match_1.png" alt="This image was generated from the first code example in the `row_count_match()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% row_count_match(count = tbl_2)
#&gt; # A tibble: 4 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7     1
#&gt; 2     7     1     1
#&gt; 3     6     0     1
#&gt; 4     5     0     3
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_row_count_match(tbl, count = tbl_2)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_row_count_match(count = 4)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-31
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='rows_complete'>Are row data complete?</h2><span id='topic+rows_complete'></span><span id='topic+expect_rows_complete'></span><span id='topic+test_rows_complete'></span>

<h3>Description</h3>

<p>The <code>rows_complete()</code> validation function, the <code>expect_rows_complete()</code>
expectation function, and the <code>test_rows_complete()</code> test function all check
whether rows contain any <code>NA</code>/<code>NULL</code> values (optionally constrained to a
selection of specified <code>columns</code>). The validation function can be used
directly on a data table or with an <em>agent</em> object (technically, a
<code>ptblank_agent</code> object) whereas the expectation and test functions can only
be used with a data table. As a validation step or as an expectation, this
will operate over the number of test units that is equal to the number of
rows in the table (after any <code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rows_complete(
  x,
  columns = tidyselect::everything(),
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_rows_complete(
  object,
  columns = tidyselect::everything(),
  preconditions = NULL,
  threshold = 1
)

test_rows_complete(
  object,
  columns = tidyselect::everything(),
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rows_complete_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <em>default:</em> <code>everything()</code>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the set of column(s) for which the completeness of rows is
checked.</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="rows_complete_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. Using <code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good choices depending on the situation (the first produces a
warning when a quarter of the total test units fails, the other <code>stop()</code>s at
the same threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>rows_complete()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>rows_complete()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  rows_complete(
    columns = c(a, b),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `rows_complete()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- rows_complete:
    columns: c(a, b)
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `rows_complete()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter. A value for <code>columns</code> is
only necessary if checking for unique values across a subset of columns.
Arguments with default values won't be written to YAML when using
<code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with their default
when generating the YAML by other means). It is also possible to preview the
transformation of an agent to YAML without any writing to disk by using the
<code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>Create a simple table with three columns of numerical values.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5, 8, 7),
    b = c(7, 1, 0, 0, 8, 3),
    c = c(1, 1, 1, 3, 3, 3)
  )

tbl
#&gt; # A tibble: 6 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7     1
#&gt; 2     7     1     1
#&gt; 3     6     0     1
#&gt; 4     5     0     3
#&gt; 5     8     8     3
#&gt; 6     7     3     3
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that when considering only data in columns <code>a</code> and <code>b</code>, there are
only complete rows (i.e., all rows have no <code>NA</code> values).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  rows_complete(columns = c(a, b)) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_rows_complete_1.png" alt="This image was generated from the first code example in the `rows_complete()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  rows_complete(columns = c(a, b)) %&gt;%
  dplyr::pull(a)
#&gt; [1] 5 7 6 5 8 7
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_rows_complete(tbl, columns = c(a, b))
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>test_rows_complete(tbl, columns = c(a, b))
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-21
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='rows_distinct'>Are row data distinct?</h2><span id='topic+rows_distinct'></span><span id='topic+expect_rows_distinct'></span><span id='topic+test_rows_distinct'></span>

<h3>Description</h3>

<p>The <code>rows_distinct()</code> validation function, the <code>expect_rows_distinct()</code>
expectation function, and the <code>test_rows_distinct()</code> test function all check
whether row values (optionally constrained to a selection of specified
<code>columns</code>) are, when taken as a complete unit, distinct from all other units
in the table. The validation function can be used directly on a data table or
with an <em>agent</em> object (technically, a <code>ptblank_agent</code> object) whereas the
expectation and test functions can only be used with a data table. As a
validation step or as an expectation, this will operate over the number of
test units that is equal to the number of rows in the table (after any
<code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rows_distinct(
  x,
  columns = tidyselect::everything(),
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_rows_distinct(
  object,
  columns = tidyselect::everything(),
  preconditions = NULL,
  threshold = 1
)

test_rows_distinct(
  object,
  columns = tidyselect::everything(),
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rows_distinct_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_columns">columns</code></td>
<td>
<p><em>The target columns</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> // <em>default:</em> <code>everything()</code>
</p>
<p>A column-selecting expression, as one would use inside <code>dplyr::select()</code>.
Specifies the set of column(s) for which the distinctness of rows is
checked.</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="rows_distinct_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. This is
especially true when <code>x</code> is a table object because, otherwise, nothing
happens. Using <code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good choices depending on the situation (the first produces a
warning when a quarter of the total test units fails, the other <code>stop()</code>s at
the same threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.col}"</code>: The current column name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>rows_distinct()</code> is represented in YAML (under the top-level <code>steps</code> key as
a list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>rows_distinct()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  rows_distinct(
    columns = c(a, b),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `rows_distinct()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode"><pre>steps:
- rows_distinct:
    columns: c(a, b)
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `rows_distinct()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter. A value for <code>columns</code> is
only necessary if checking for unique values across a subset of columns.
Arguments with default values won't be written to YAML when using
<code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include them with their default
when generating the YAML by other means). It is also possible to preview the
transformation of an agent to YAML without any writing to disk by using the
<code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>Create a simple table with three columns of numerical values.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5, 8, 7),
    b = c(7, 1, 0, 0, 8, 3),
    c = c(1, 1, 1, 3, 3, 3)
  )

tbl
#&gt; # A tibble: 6 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7     1
#&gt; 2     7     1     1
#&gt; 3     6     0     1
#&gt; 4     5     0     3
#&gt; 5     8     8     3
#&gt; 6     7     3     3
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that when considering only data in columns <code>a</code> and <code>b</code>, there are no
duplicate rows (i.e., all rows are distinct).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  rows_distinct(columns = c(a, b)) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_rows_distinct_1.png" alt="This image was generated from the first code example in the `rows_distinct()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  rows_distinct(columns = c(a, b)) %&gt;%
  dplyr::pull(a)
#&gt; [1] 5 7 6 5 8 7
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_rows_distinct(tbl, columns = c(a, b))
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>test_rows_distinct(tbl, columns = c(a, b))
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-20
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='scan_data'>Thoroughly scan a table to better understand it</h2><span id='topic+scan_data'></span>

<h3>Description</h3>

<p>Generate an HTML report that scours the input table data. Before calling up
an <em>agent</em> to validate the data, it's a good idea to understand the data with
some level of precision. Make this the initial step of a well-balanced
<em>data quality reporting</em> workflow. The reporting output contains several
sections to make everything more digestible, and these are:
</p>

<dl>
<dt>Overview</dt><dd><p>Table dimensions, duplicate row counts, column types, and
reproducibility information</p>
</dd>
<dt>Variables</dt><dd><p>A summary for each table variable and further statistics and
summaries depending on the variable type</p>
</dd>
<dt>Interactions</dt><dd><p>A matrix plot that shows interactions between variables</p>
</dd>
<dt>Correlations</dt><dd><p>A set of correlation matrix plots for numerical
variables</p>
</dd>
<dt>Missing Values</dt><dd><p>A summary figure that shows the degree of missingness
across variables</p>
</dd>
<dt>Sample</dt><dd><p>A table that provides the head and tail rows of the dataset</p>
</dd>
</dl>

<p>The resulting object can be printed to make it viewable in the RStudio
Viewer. It's also a <code>"shiny.tag.list"</code> object and so can be integrated in R
Markdown HTML output or in Shiny applications. If you need the output HTML,
it's to export that to a file with the <code><a href="#topic+export_report">export_report()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_data(
  tbl,
  sections = "OVICMS",
  navbar = TRUE,
  width = NULL,
  lang = NULL,
  locale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan_data_+3A_tbl">tbl</code></td>
<td>
<p><em>A data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The input table. This can be a data frame, tibble, a <code>tbl_dbi</code> object, or a
<code>tbl_spark</code> object.</p>
</td></tr>
<tr><td><code id="scan_data_+3A_sections">sections</code></td>
<td>
<p><em>Sections to include</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>"OVICMS"</code>
</p>
<p>The sections to include in the finalized <code style="white-space: pre;">&#8288;Table Scan&#8288;</code> report. A string with
key characters representing section names is required here. The default
string is <code>"OVICMS"</code> wherein each letter stands for the following sections
in their default order: <code>"O"</code>: <code>"overview"</code>; <code>"V"</code>: <code>"variables"</code>; <code>"I"</code>:
<code>"interactions"</code>; <code>"C"</code>: <code>"correlations"</code>; <code>"M"</code>: <code>"missing"</code>; and <code>"S"</code>:
<code>"sample"</code>. This string can be comprised of less characters and the order
can be changed to suit the desired layout of the report. For <code>tbl_dbi</code> and
<code>tbl_spark</code> objects supplied to <code>tbl</code>, the <code>"interactions"</code> and
<code>"correlations"</code> sections are currently excluded.</p>
</td></tr>
<tr><td><code id="scan_data_+3A_navbar">navbar</code></td>
<td>
<p><em>Include navigation in HTML report</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>Should there be a navigation bar anchored to the top of the report page?</p>
</td></tr>
<tr><td><code id="scan_data_+3A_width">width</code></td>
<td>
<p><em>Width option for HTML report</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional fixed width (in pixels) for the HTML report. By default, no
fixed width is applied.</p>
</td></tr>
<tr><td><code id="scan_data_+3A_lang">lang</code></td>
<td>
<p><em>Reporting language</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use for label text in the report. By default, <code>NULL</code> will
create English (<code>"en"</code>) text. Other options include French (<code>"fr"</code>), German
(<code>"de"</code>), Italian (<code>"it"</code>), Spanish (<code>"es"</code>), Portuguese (<code>"pt"</code>), Turkish
(<code>"tr"</code>), Chinese (<code>"zh"</code>),  Russian (<code>"ru"</code>), Polish (<code>"pl"</code>), Danish
(<code>"da"</code>), Swedish (<code>"sv"</code>), and Dutch (<code>"nl"</code>).</p>
</td></tr>
<tr><td><code id="scan_data_+3A_locale">locale</code></td>
<td>
<p><em>Locale for value formatting within reports</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional locale ID to use for formatting values in the report according
the locale's rules. Examples include <code>"en_US"</code> for English (United States)
and <code>"fr_FR"</code> for French (France); more simply, this can be a language
identifier without a country designation, like <code>"es"</code> for Spanish (Spain,
same as <code>"es_ES"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_tbl_scan</code> object.
</p>


<h3>Examples</h3>

<p>Get an HTML document that describes all of the data in the <code>dplyr::storms</code>
dataset.
</p>
<div class="sourceCode r"><pre>tbl_scan &lt;- scan_data(tbl = dplyr::storms)
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_scan_data_1.png" alt="This image was generated from the first code example in the `scan_data()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>1-1
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='serially'>Run several tests and a final validation in a serial manner</h2><span id='topic+serially'></span><span id='topic+expect_serially'></span><span id='topic+test_serially'></span>

<h3>Description</h3>

<p>The <code>serially()</code> validation function allows for a series of tests to run in
sequence before either culminating in a final validation step or simply
exiting the series. This construction allows for pre-testing that may make
sense before a validation step. For example, there may be situations where
it's vital to check a column type before performing a validation on the same
column (since having the wrong type can result in an evaluation error for the
subsequent validation). Another serial workflow might entail having a bundle
of checks in a prescribed order and, if all pass, then the goal of this
testing has been achieved (e.g., checking if a table matches another through
a series of increasingly specific tests).
</p>
<p>A series as specified inside <code>serially()</code> is composed with a listing of
calls, and we would draw upon test functions (<strong>T</strong>) to describe tests and
optionally provide a finalizing call with a validation function (<strong>V</strong>).
The following constraints apply:
</p>

<ul>
<li><p> there must be at least one test function in the series (<strong>T</strong> -&gt; <strong>V</strong> is
good, <strong>V</strong> is <em>not</em>)
</p>
</li>
<li><p> there can only be one validation function call, <strong>V</strong>; it's optional but,
if included, it must be placed at the end (<strong>T</strong> -&gt; <strong>T</strong> -&gt; <strong>V</strong> is good,
these sequences are bad: (1) <strong>T</strong> -&gt; <strong>V</strong> -&gt; <strong>T</strong>, (2) <strong>T</strong> -&gt; <strong>T</strong> -&gt;
<strong>V</strong> -&gt; <strong>V</strong>)
</p>
</li>
<li><p> a validation function call (<strong>V</strong>), if included, mustn't itself yield
multiple validation steps (this may happen when providing multiple <code>columns</code>
or any <code>segments</code>)
</p>
</li></ul>

<p>Here's an example of how to arrange expressions:
</p>
<div class="sourceCode"><pre>~ test_col_exists(., columns = count),
~ test_col_is_numeric(., columns = count),
~ col_vals_gt(., columns = count, value = 2)
</pre></div>
<p>This series concentrates on the column called <code>count</code> and first checks
whether the column exists, then checks if that column is numeric, and then
finally validates whether all values in the column are greater than <code>2</code>.
</p>
<p>Note that in the above listing of calls, the <code>.</code> stands in for the target
table and is always necessary here. Also important is that all <code style="white-space: pre;">&#8288;test_*()&#8288;</code>
functions have a <code>threshold</code> argument that is set to <code>1</code> by default. Should
you need to bump up the threshold value it can be changed to a different
integer value (as an absolute threshold of failing test units) or a
decimal value between <code>0</code> and <code>1</code> (serving as a fractional threshold of
failing test units).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serially(
  x,
  ...,
  .list = list2(...),
  preconditions = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_serially(
  object,
  ...,
  .list = list2(...),
  preconditions = NULL,
  threshold = 1
)

test_serially(
  object,
  ...,
  .list = list2(...),
  preconditions = NULL,
  threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serially_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="serially_+3A_...">...</code></td>
<td>
<p><em>Test/validation expressions</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;test/validation expressions&gt;&#8288;</code> // <strong>required</strong> (or, use <code>.list</code>)
</p>
<p>A collection one-sided formulas that consist of <code style="white-space: pre;">&#8288;test_*()&#8288;</code> function calls
(e.g., <code><a href="#topic+test_col_vals_between">test_col_vals_between()</a></code>, etc.) arranged in sequence of intended
interrogation order. Typically, validations up until the final one would
have some <code>threshold</code> value set (default is <code>1</code>) for short circuiting
within the series. A finishing validation function call (e.g.,
<code><a href="#topic+col_vals_increasing">col_vals_increasing()</a></code>, etc.) can optionally be inserted at the end of the
series, serving as a validation step that only undergoes interrogation if
the prior tests adequately pass. An example of this is
<code style="white-space: pre;">&#8288;~ test_column_exists(., a), ~ col_vals_not_null(., a)&#8288;</code>).</p>
</td></tr>
<tr><td><code id="serially_+3A_.list">.list</code></td>
<td>
<p><em>Alternative to <code>...</code></em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;list of multiple expressions&gt;&#8288;</code> // <strong>required</strong> (or, use <code>...</code>)
</p>
<p>Allows for the use of a list as an input alternative to <code>...</code>.</p>
</td></tr>
<tr><td><code id="serially_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="serially_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="serially_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="serially_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="serially_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="serially_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="serially_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="serially_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Column Names</h3>

<p><code>columns</code> may be a single column (as symbol <code>a</code> or string <code>"a"</code>) or a vector
of columns (<code>c(a, b, c)</code> or <code>c("a", "b", "c")</code>). <code>{tidyselect}</code> helpers
are also supported, such as <code>contains("date")</code> and <code>where(is.double)</code>. If
passing an <em>external vector</em> of columns, it should be wrapped in <code>all_of()</code>.
</p>
<p>When multiple columns are selected by <code>columns</code>, the result will be an
expansion of validation steps to that number of columns (e.g.,
<code>c(col_a, col_b)</code> will result in the entry of two validation steps).
</p>
<p>Previously, columns could be specified in <code>vars()</code>. This continues to work,
but <code>c()</code> offers the same capability and supersedes <code>vars()</code> in <code>columns</code>.
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>serially()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>serially()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  serially(
    ~ test_col_vals_lt(., columns = a, value = 8),
    ~ test_col_vals_gt(., columns = c, value = vars(a)),
    ~ col_vals_not_null(., columns = b),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2), 
    label = "The `serially()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- serially:
    fns:
    - ~test_col_vals_lt(., columns = a, value = 8)
    - ~test_col_vals_gt(., columns = c, value = vars(a))
    - ~col_vals_not_null(., columns = b)
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `serially()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the expressions for
validation steps are necessary. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all examples here, we'll use a simple table with three numeric columns
(<code>a</code>, <code>b</code>, and <code>c</code>). This is a very basic table but it'll be more useful when
explaining things later.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 2, 6),
    b = c(6, 4, 9),
    c = c(1, 2, 3)
  )
  
tbl
#&gt; # A tibble: 3 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     6     1
#&gt; 2     2     4     2
#&gt; 3     6     9     3
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>The <code>serially()</code> function can be set up to perform a series of tests and then
perform a validation (only if all tests pass). Here, we are going to (1) test
whether columns <code>a</code> and <code>b</code> are numeric, (2) check that both don't have any
<code>NA</code> values, and (3) perform a finalizing validation that checks whether
values in <code>b</code> are greater than values in <code>a</code>. We'll determine if this
validation has any failing test units (there are 4 tests and a final
validation).
</p>
<div class="sourceCode r"><pre>agent_1 &lt;-
  create_agent(tbl = tbl) %&gt;%
  serially(
    ~ test_col_is_numeric(., columns = c(a, b)),
    ~ test_col_vals_not_null(., columns = c(a, b)),
    ~ col_vals_gt(., columns = b, value = vars(a))
    ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_serially_1.png" alt="This image was generated from the first code example in the `serially()` help file." style="width:100%;">


<p>What's going on? All four of the tests passed and so the final validation
occurred. There were no failing test units in that either!
</p>
<p>The final validation is optional and so here is a variation where only the
serial tests are performed.
</p>
<div class="sourceCode r"><pre>agent_2 &lt;-
  create_agent(tbl = tbl) %&gt;%
  serially(
    ~ test_col_is_numeric(., columns = c(a, b)),
    ~ test_col_vals_not_null(., columns = c(a, b))
  ) %&gt;%
  interrogate()
</pre></div>
<p>Everything is good here too:
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_serially_2.png" alt="This image was generated from the second code example in the `serially()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  serially(
    ~ test_col_is_numeric(., columns = c(a, b)),
    ~ test_col_vals_not_null(., columns = c(a, b)),
    ~ col_vals_gt(., columns = b, value = vars(a))
  )
#&gt; # A tibble: 3 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     6     1
#&gt; 2     2     4     2
#&gt; 3     6     9     3
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_serially(
  tbl,
  ~ test_col_is_numeric(., columns = c(a, b)),
  ~ test_col_vals_not_null(., columns = c(a, b)),
  ~ col_vals_gt(., columns = b, value = vars(a))
)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;%
  test_serially(
    ~ test_col_is_numeric(., columns = c(a, b)),
    ~ test_col_vals_not_null(., columns = c(a, b)),
    ~ col_vals_gt(., columns = b, value = vars(a))
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-35
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='set_tbl'>Set a data table to an <em>agent</em> or an <em>informant</em></h2><span id='topic+set_tbl'></span>

<h3>Description</h3>

<p>Setting a data table to an <em>agent</em> or an <em>informant</em> with <code>set_tbl()</code>
replaces any associated table (a data frame, a tibble, objects of class
<code>tbl_dbi</code> or <code>tbl_spark</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_tbl(x, tbl, tbl_name = NULL, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_tbl_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or informant object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent|ptblank_informant&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>An <em>agent</em> object of class <code>ptblank_agent</code>, or, an <em>informant</em> of class
<code>ptblank_informant</code>.</p>
</td></tr>
<tr><td><code id="set_tbl_+3A_tbl">tbl</code></td>
<td>
<p><em>Table or expression for reading in one</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;|&lt;tbl reading expression&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The input table for the <em>agent</em> or the <em>informant</em>. This can be a data
frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object.
Alternatively, an expression can be supplied to serve as instructions on
how to retrieve the target table at interrogation- or incorporation-time.
There are two ways to specify an association to a target table: (1) as a
table-prep formula, which is a right-hand side (RHS) formula expression
(e.g., <code style="white-space: pre;">&#8288;~ { &lt;tbl reading code&gt;}&#8288;</code>), or (2) as a function (e.g.,
<code style="white-space: pre;">&#8288;function() { &lt;tbl reading code&gt;}&#8288;</code>).</p>
</td></tr>
<tr><td><code id="set_tbl_+3A_tbl_name">tbl_name</code></td>
<td>
<p><em>A table name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A optional name to assign to the new input table object. If no value is
provided, a name will be generated based on whatever information is
available.</p>
</td></tr>
<tr><td><code id="set_tbl_+3A_label">label</code></td>
<td>
<p><em>An optional label for reporting</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional label for the validation plan or information report. If no
value is provided then any existing label will be retained.</p>
</td></tr>
</table>


<h3>Examples</h3>

<p>Set proportional failure thresholds to the <code>warn</code>, <code>stop</code>, and <code>notify</code>
states using <code><a href="#topic+action_levels">action_levels()</a></code>.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
      warn_at = 0.10,
      stop_at = 0.25,
    notify_at = 0.35
  )
</pre></div>
<p>Create an agent that has <code>small_table</code> set as the target table via <code>tbl</code>.
Apply the actions, add some validation steps and then interrogate the data.
</p>
<div class="sourceCode r"><pre>agent_1 &lt;- 
  create_agent(
    tbl = small_table,
    tbl_name = "small_table",
    label = "An example.",
    actions = al
  ) %&gt;%
  col_exists(columns = c(date, date_time)) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}"
  ) %&gt;%
  rows_distinct() %&gt;%
  interrogate()
</pre></div>
<p>Replace the agent's association to <code>small_table</code> with a mutated version of it
(one that removes duplicate rows). Then, interrogate the new target table.
</p>
<div class="sourceCode r"><pre>agent_2 &lt;-
  agent_1 %&gt;%
  set_tbl(
    tbl = small_table %&gt;% dplyr::distinct()
  ) %&gt;%
  interrogate()
</pre></div>


<h3>Function ID</h3>

<p>9-4
</p>


<h3>See Also</h3>

<p>Other Object Ops: 
<code><a href="#topic+activate_steps">activate_steps</a>()</code>,
<code><a href="#topic+deactivate_steps">deactivate_steps</a>()</code>,
<code><a href="#topic+export_report">export_report</a>()</code>,
<code><a href="#topic+remove_steps">remove_steps</a>()</code>,
<code><a href="#topic+x_read_disk">x_read_disk</a>()</code>,
<code><a href="#topic+x_write_disk">x_write_disk</a>()</code>
</p>

<hr>
<h2 id='small_table'>A small table that is useful for testing</h2><span id='topic+small_table'></span>

<h3>Description</h3>

<p>This is a small table with a few different types of columns. It's probably
just useful when testing the functions from <strong>pointblank</strong>. Rows 9 and 10 are
exact duplicates. The <code>c</code> column contains two <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>small_table
</code></pre>


<h3>Format</h3>

<p>A tibble with 13 rows and 8 variables:
</p>

<dl>
<dt>date_time</dt><dd><p>A date-time column (of the <code>POSIXct</code> class) with dates that
correspond exactly to those in the <code>date</code> column. Time values are somewhat
randomized but all 'seconds' values are <code>00</code>.</p>
</dd>
<dt>date</dt><dd><p>A <code>Date</code> column with dates from <code>2016-01-04</code> to <code>2016-01-30</code>.</p>
</dd>
<dt>a</dt><dd><p>An <code>integer</code> column with values ranging from <code>1</code> to <code>8</code>.</p>
</dd>
<dt>b</dt><dd><p>A <code>character</code> column with values that adhere to a common pattern.</p>
</dd>
<dt>c</dt><dd><p>An <code>integer</code> column with values ranging from <code>2</code> to <code>9</code>. Contains
two <code>NA</code> values.</p>
</dd>
<dt>d</dt><dd><p>A numeric column with values ranging from <code>108</code> to <code>10000</code>.</p>
</dd>
<dt>e</dt><dd><p>A <code>logical</code> column.</p>
</dd>
<dt>f</dt><dd><p>A <code>character</code> column with <code>"low"</code>, <code>"mid"</code>, and <code>"high"</code> values.</p>
</dd>
</dl>



<h3>Function ID</h3>

<p>14-1
</p>


<h3>See Also</h3>

<p>Other Datasets: 
<code><a href="#topic+game_revenue">game_revenue</a></code>,
<code><a href="#topic+game_revenue_info">game_revenue_info</a></code>,
<code><a href="#topic+small_table_sqlite">small_table_sqlite</a>()</code>,
<code><a href="#topic+specifications">specifications</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here is a glimpse at the data
# available in `small_table`
dplyr::glimpse(small_table)

</code></pre>

<hr>
<h2 id='small_table_sqlite'>An SQLite version of the <code>small_table</code> dataset</h2><span id='topic+small_table_sqlite'></span>

<h3>Description</h3>

<p>The <code>small_table_sqlite()</code> function creates an SQLite, <code>tbl_dbi</code> version of
the <code>small_table</code> dataset. A requirement is the availability of the <strong>DBI</strong>
and <strong>RSQLite</strong> packages. These packages can be installed by using
<code>install.packages("DBI")</code> and <code>install.packages("RSQLite")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>small_table_sqlite()
</code></pre>


<h3>Function ID</h3>

<p>14-2
</p>


<h3>See Also</h3>

<p>Other Datasets: 
<code><a href="#topic+game_revenue">game_revenue</a></code>,
<code><a href="#topic+game_revenue_info">game_revenue_info</a></code>,
<code><a href="#topic+small_table">small_table</a></code>,
<code><a href="#topic+specifications">specifications</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use `small_table_sqlite()` to
# create an SQLite version of the
# `small_table` table
#
# small_table_sqlite &lt;- small_table_sqlite()

</code></pre>

<hr>
<h2 id='snip_highest'>A <code>fn</code> for <code>info_snippet()</code>: get the highest value from a column</h2><span id='topic+snip_highest'></span>

<h3>Description</h3>

<p>The <code>snip_highest()</code> function can be used as an <code><a href="#topic+info_snippet">info_snippet()</a></code> function
(i.e., provided to <code>fn</code>) to get the highest numerical, time value, or
alphabetical value from a column in the target table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snip_highest(column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snip_highest_+3A_column">column</code></td>
<td>
<p><em>The target column</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the column that contains the target values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula needed for <code><a href="#topic+info_snippet">info_snippet()</a></code>'s <code>fn</code> argument.
</p>


<h3>Examples</h3>

<p>Generate an informant object, add a snippet with <code><a href="#topic+info_snippet">info_snippet()</a></code> and
<code>snip_highest()</code> (giving us a method to get the highest value in column <code>a</code>);
define a location for the snippet result in <code>{ }</code> and then <code><a href="#topic+incorporate">incorporate()</a></code>
the snippet into the info text. Note here that the order of the
<code><a href="#topic+info_columns">info_columns()</a></code> and <code><a href="#topic+info_snippet">info_snippet()</a></code> calls doesn't matter.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "An example."
  ) %&gt;% 
  info_columns(
    columns = a,
    `Highest Value` = "Highest value is {highest_a}."
  ) %&gt;%
  info_snippet(
    snippet_name = "highest_a",
    fn = snip_highest(column = "a")
  ) %&gt;%
  incorporate()
</pre></div>
<p>We can print the <code>informant</code> object to see the information report.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_snip_highest_1.png" alt="This image was generated from the first code example in the `snip_highest()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>3-9
</p>


<h3>See Also</h3>

<p>Other Information Functions: 
<code><a href="#topic+info_columns">info_columns</a>()</code>,
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl</a>()</code>,
<code><a href="#topic+info_section">info_section</a>()</code>,
<code><a href="#topic+info_snippet">info_snippet</a>()</code>,
<code><a href="#topic+info_tabular">info_tabular</a>()</code>,
<code><a href="#topic+snip_list">snip_list</a>()</code>,
<code><a href="#topic+snip_lowest">snip_lowest</a>()</code>,
<code><a href="#topic+snip_stats">snip_stats</a>()</code>
</p>

<hr>
<h2 id='snip_list'>A <code>fn</code> for <code>info_snippet()</code>: get a list of column categories</h2><span id='topic+snip_list'></span>

<h3>Description</h3>

<p>The <code>snip_list()</code> function can be used as an <code><a href="#topic+info_snippet">info_snippet()</a></code> function (i.e.,
provided to <code>fn</code>) to get a catalog list from a table column. You can limit
the of items in that list with the <code>limit</code> value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snip_list(
  column,
  limit = 5,
  sorting = c("inorder", "infreq", "inseq"),
  reverse = FALSE,
  sep = ",",
  and_or = NULL,
  oxford = TRUE,
  as_code = TRUE,
  quot_str = NULL,
  na_rm = FALSE,
  lang = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snip_list_+3A_column">column</code></td>
<td>
<p><em>The target column</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the column that contains the target values.</p>
</td></tr>
<tr><td><code id="snip_list_+3A_limit">limit</code></td>
<td>
<p><em>Limit for list length</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;integer&gt;&#8288;</code> // <em>default:</em> <code>5</code>
</p>
<p>A limit of items put into the generated list. The returned text will state
the remaining number of items beyond the <code>limit</code>.</p>
</td></tr>
<tr><td><code id="snip_list_+3A_sorting">sorting</code></td>
<td>
<p><em>Type of sorting within list</em>
</p>
<p><code style="white-space: pre;">&#8288;singl-kw:[inorder|infreq|inseq]&#8288;</code> // <em>default:</em> <code>"inorder"</code>
</p>
<p>A keyword used to designate the type of sorting to use for the list. The
three options are <code>"inorder"</code> (the default), <code>"infreq"</code>, and <code>"inseq"</code>.
With <code>"inorder"</code>, distinct items are listed in the order in which they
first appear. Using <code>"infreq"</code> orders the items by the decreasing frequency
of each item. The <code>"inseq"</code> option applies an alphanumeric sorting to the
distinct list items.</p>
</td></tr>
<tr><td><code id="snip_list_+3A_reverse">reverse</code></td>
<td>
<p><em>Reversal of list order</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>An option to reverse the ordering of list items. By default, this is
<code>FALSE</code> but using <code>TRUE</code> will reverse the items before applying the
<code>limit</code>.</p>
</td></tr>
<tr><td><code id="snip_list_+3A_sep">sep</code></td>
<td>
<p><em>Separator text for list</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>","</code>
</p>
<p>The separator to use between list items. By default, this is a comma.</p>
</td></tr>
<tr><td><code id="snip_list_+3A_and_or">and_or</code></td>
<td>
<p><em>Use of 'and' or 'or' within list</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The type of conjunction to use between the final and penultimate list items
(should the item length be below the <code>limit</code> value). If <code>NULL</code> (the
default) is used, then the 'and' conjunction will be used. Alternatively,
the following keywords can be used: <code>"and"</code>, <code>"or"</code>, or an empty string
(for no conjunction at all).</p>
</td></tr>
<tr><td><code id="snip_list_+3A_oxford">oxford</code></td>
<td>
<p><em>Usage of oxford comma</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>Whether to use an Oxford comma under certain conditions.</p>
</td></tr>
<tr><td><code id="snip_list_+3A_as_code">as_code</code></td>
<td>
<p><em>Treat items as code</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>Should each list item appear in a 'code font' (i.e., as monospaced text)?
By default this is <code>TRUE</code>. Using <code>FALSE</code> keeps all list items in the same
font as the rest of the information report.</p>
</td></tr>
<tr><td><code id="snip_list_+3A_quot_str">quot_str</code></td>
<td>
<p><em>Set items in double quotes</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An option for whether list items should be set in double quotes. If <code>NULL</code>
(the default), the quotation marks are mainly associated with list items
derived from <code>character</code> or <code>factor</code> values; numbers, dates, and logical
values won't have quotation marks. We can explicitly use quotations (or
not) with either <code>TRUE</code> or <code>FALSE</code> here.</p>
</td></tr>
<tr><td><code id="snip_list_+3A_na_rm">na_rm</code></td>
<td>
<p><em>Remove NA values from list</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>An option for whether NA values should be counted as an item in the list.</p>
</td></tr>
<tr><td><code id="snip_list_+3A_lang">lang</code></td>
<td>
<p><em>Reporting language</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use for any joining words (from the <code>and_or</code> option) or
additional words in the generated list string. By default, <code>NULL</code> will use
whichever <code>lang</code> setting is available in the parent
<em>informant</em> object (this is settable in the <code><a href="#topic+create_informant">create_informant()</a></code> <code>lang</code>
argument). If specified here as an override, the language options are
English (<code>"en"</code>), French (<code>"fr"</code>), German (<code>"de"</code>), Italian (<code>"it"</code>),
Spanish (<code>"es"</code>), Portuguese (<code>"pt"</code>), Turkish (<code>"tr"</code>), Chinese (<code>"zh"</code>),
Russian (<code>"ru"</code>), Polish (<code>"pl"</code>), Danish (<code>"da"</code>), Swedish (<code>"sv"</code>), and
Dutch (<code>"nl"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula needed for <code><a href="#topic+info_snippet">info_snippet()</a></code>'s <code>fn</code> argument.
</p>


<h3>Examples</h3>

<p>Generate an informant object, add a snippet with <code><a href="#topic+info_snippet">info_snippet()</a></code> and
<code>snip_list()</code> (giving us a method to get a distinct list of column values for
column <code>f</code>). Define a location for the snippet result in <code>{ }</code> and then
<code><a href="#topic+incorporate">incorporate()</a></code> the snippet into the info text. Note here that the order of
the <code><a href="#topic+info_columns">info_columns()</a></code> and <code><a href="#topic+info_snippet">info_snippet()</a></code> calls doesn't matter.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "An example."
  ) %&gt;% 
  info_columns(
    columns = f,
    `Items` = "This column contains {values_f}."
  ) %&gt;%
  info_snippet(
    snippet_name = "values_f",
    fn = snip_list(column = "f")
  ) %&gt;%
  incorporate()
</pre></div>
<p>We can print the <code>informant</code> object to see the information report.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_snip_list_1.png" alt="This image was generated from the first code example in the `snip_list()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>3-6
</p>


<h3>See Also</h3>

<p>Other Information Functions: 
<code><a href="#topic+info_columns">info_columns</a>()</code>,
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl</a>()</code>,
<code><a href="#topic+info_section">info_section</a>()</code>,
<code><a href="#topic+info_snippet">info_snippet</a>()</code>,
<code><a href="#topic+info_tabular">info_tabular</a>()</code>,
<code><a href="#topic+snip_highest">snip_highest</a>()</code>,
<code><a href="#topic+snip_lowest">snip_lowest</a>()</code>,
<code><a href="#topic+snip_stats">snip_stats</a>()</code>
</p>

<hr>
<h2 id='snip_lowest'>A <code>fn</code> for <code>info_snippet()</code>: get the lowest value from a column</h2><span id='topic+snip_lowest'></span>

<h3>Description</h3>

<p>The <code>snip_lowest()</code> function can be used as an <code><a href="#topic+info_snippet">info_snippet()</a></code> function
(i.e., provided to <code>fn</code>) to get the lowest numerical, time value, or
alphabetical value from a column in the target table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snip_lowest(column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snip_lowest_+3A_column">column</code></td>
<td>
<p><em>The target column</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the column that contains the target values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula needed for <code><a href="#topic+info_snippet">info_snippet()</a></code>'s <code>fn</code> argument.
</p>


<h3>Examples</h3>

<p>Generate an informant object, add a snippet with <code><a href="#topic+info_snippet">info_snippet()</a></code> and
<code>snip_lowest()</code> (giving us a method to get the lowest value in column <code>a</code>).
Define a location for the snippet result in <code>{ }</code> and then <code><a href="#topic+incorporate">incorporate()</a></code>
the snippet into the info text. Note here that the order of the
<code><a href="#topic+info_columns">info_columns()</a></code> and <code><a href="#topic+info_snippet">info_snippet()</a></code> calls doesn't matter.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "An example."
  ) %&gt;% 
  info_columns(
    columns = a,
    `Lowest Value` = "Lowest value is {lowest_a}."
  ) %&gt;%
  info_snippet(
    snippet_name = "lowest_a",
    fn = snip_lowest(column = "a")
  ) %&gt;%
  incorporate()
</pre></div>
<p>We can print the <code>informant</code> object to see the information report.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_snip_lowest_1.png" alt="This image was generated from the first code example in the `snip_lowest()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>3-8
</p>


<h3>See Also</h3>

<p>Other Information Functions: 
<code><a href="#topic+info_columns">info_columns</a>()</code>,
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl</a>()</code>,
<code><a href="#topic+info_section">info_section</a>()</code>,
<code><a href="#topic+info_snippet">info_snippet</a>()</code>,
<code><a href="#topic+info_tabular">info_tabular</a>()</code>,
<code><a href="#topic+snip_highest">snip_highest</a>()</code>,
<code><a href="#topic+snip_list">snip_list</a>()</code>,
<code><a href="#topic+snip_stats">snip_stats</a>()</code>
</p>

<hr>
<h2 id='snip_stats'>A <code>fn</code> for <code>info_snippet()</code>: get an inline statistical summary</h2><span id='topic+snip_stats'></span>

<h3>Description</h3>

<p>The <code>snip_stats()</code> function can be used as an <code><a href="#topic+info_snippet">info_snippet()</a></code> function
(i.e., provided to <code>fn</code>) to produce a five- or seven-number statistical
summary. This inline summary works well within a paragraph of text and can
help in describing the distribution of numerical values in a column.
</p>
<p>For a given column, three different types of inline statistical summaries can
be provided:
</p>

<ol>
<li><p> a five-number summary (<code>"5num"</code>): minimum, Q1, median, Q3, maximum
</p>
</li>
<li><p> a seven-number summary (<code>"7num"</code>): P2, P9, Q1, median, Q3, P91, P98
</p>
</li>
<li><p> Bowley's seven-figure summary (<code>"bowley"</code>): minimum, P10, Q1, median, Q3,
P90, maximum
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>snip_stats(column, type = c("5num", "7num", "bowley"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snip_stats_+3A_column">column</code></td>
<td>
<p><em>The target column</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the column that contains the target values.</p>
</td></tr>
<tr><td><code id="snip_stats_+3A_type">type</code></td>
<td>
<p><em>Type of statistical summary</em>
</p>
<p><code style="white-space: pre;">&#8288;singl-kw:[5num|7num|bowley]&#8288;</code> // <em>default:</em> <code>"5num"</code>
</p>
<p>The type of summary. By default, the <code>"5num"</code> keyword is used to generate a
five-number summary. Two other options provide seven-number summaries:
<code>"7num"</code> and <code>"bowley"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula needed for <code><a href="#topic+info_snippet">info_snippet()</a></code>'s <code>fn</code> argument.
</p>


<h3>Examples</h3>

<p>Generate an informant object, add a snippet with <code><a href="#topic+info_snippet">info_snippet()</a></code> and
<code>snip_stats()</code> (giving us a method to get some summary stats for column <code>d</code>).
Define a location for the snippet result in <code>{ }</code> and then <code><a href="#topic+incorporate">incorporate()</a></code>
the snippet into the info text. Note here that the order of the
<code><a href="#topic+info_columns">info_columns()</a></code> and <code><a href="#topic+info_snippet">info_snippet()</a></code> calls doesn't matter.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "An example."
  ) %&gt;% 
  info_columns(
    columns = d,
    `Stats` = "Stats (fivenum): {stats_d}."
  ) %&gt;%
  info_snippet(
    snippet_name = "stats_d",
    fn = snip_stats(column = "d")
  ) %&gt;%
  incorporate()
</pre></div>
<p>We can print the <code>informant</code> object to see the information report.
</p>
<div class="sourceCode r"><pre>informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_snip_stats_1.png" alt="This image was generated from the first code example in the `snip_stats()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>3-7
</p>


<h3>See Also</h3>

<p>Other Information Functions: 
<code><a href="#topic+info_columns">info_columns</a>()</code>,
<code><a href="#topic+info_columns_from_tbl">info_columns_from_tbl</a>()</code>,
<code><a href="#topic+info_section">info_section</a>()</code>,
<code><a href="#topic+info_snippet">info_snippet</a>()</code>,
<code><a href="#topic+info_tabular">info_tabular</a>()</code>,
<code><a href="#topic+snip_highest">snip_highest</a>()</code>,
<code><a href="#topic+snip_list">snip_list</a>()</code>,
<code><a href="#topic+snip_lowest">snip_lowest</a>()</code>
</p>

<hr>
<h2 id='specially'>Perform a specialized validation with a user-defined function</h2><span id='topic+specially'></span><span id='topic+expect_specially'></span><span id='topic+test_specially'></span>

<h3>Description</h3>

<p>The <code>specially()</code> validation function allows for custom validation with a
function that <em>you</em> provide. The major proviso for the provided function is
that it must either return a logical vector or a table where the final column
is logical. The function will operate on the table object, or, because you
can do whatever you like, it could also operate on other types of objects. To
do this, you can transform the input table in <code>preconditions</code> or inject an
entirely different object there. During interrogation, there won't be any
checks to ensure that the data is a table object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specially(
  x,
  fn,
  preconditions = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_specially(object, fn, preconditions = NULL, threshold = 1)

test_specially(object, fn, preconditions = NULL, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specially_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="specially_+3A_fn">fn</code></td>
<td>
<p><em>Specialized validation function</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;function&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A function that performs the specialized validation on the data. It must
either return a logical vector or a table where the last column is a
logical column.</p>
</td></tr>
<tr><td><code id="specially_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="specially_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="specially_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="specially_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="specially_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="specially_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="specially_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="specially_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>

<p>Other database tables may work to varying degrees but they haven't been
formally tested (so be mindful of this when using unsupported backends with
<strong>pointblank</strong>).
</p>


<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that a particular validation requires a calculated column, some filtering of
rows, or the addition of columns via a join, etc. Especially for an
<em>agent</em>-based report this can be advantageous since we can develop a large
validation plan with a single target table and make minor adjustments to it,
as needed, along the way. Within <code>specially()</code>, because this function is
special, there won't be internal checking as to whether the
<code>preconditions</code>-based output is a table.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed (e.g., <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternatively, a function could instead
be supplied (e.g., <code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list
object that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that
function's documentation for the lowdown on how to create reactions to
above-threshold failure levels in validation. The basic gist is that you'll
want at least a single threshold level (specified as either the fraction of
test units failed, or, an absolute value), often using the <code>warn_at</code>
argument. This is especially true when <code>x</code> is a table object because,
otherwise, nothing happens. For the <code style="white-space: pre;">&#8288;col_vals_*()&#8288;</code>-type functions, using
<code>action_levels(warn_at = 0.25)</code> or <code>action_levels(stop_at = 0.25)</code> are good
choices depending on the situation (the first produces a warning when a
quarter of the total test units fails, the other <code>stop()</code>s at the same
threshold level).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>specially()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>specially()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  specially(
    fn = function(x) { ... },
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2), 
    label = "The `specially()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- specially:
    fn: function(x) { ... }
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `specially()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter as only the expressions for
validation steps are necessary. Arguments with default values won't be
written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> function.
</p>


<h3>Examples</h3>

<p>For all examples here, we'll use a simple table with three numeric columns
(<code>a</code>, <code>b</code>, and <code>c</code>). This is a very basic table but it'll be more useful when
explaining things later.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 2, 6),
    b = c(3, 4, 6),
    c = c(9, 8, 7)
  )
  
tbl
#&gt; # A tibble: 3 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     3     9
#&gt; 2     2     4     8
#&gt; 3     6     6     7
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the target table has exactly three rows. This single validation
with <code>specially()</code> has 1 test unit since the function executed on <code>x</code> (the
target table) results in a logical vector with a length of 1. We'll determine
if this validation has any failing test units (there is 1 test unit).
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  specially(fn = function(x) nrow(x) == 3) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_specially_1.png" alt="This image was generated from the first code example in the `specially()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% specially(fn = function(x) nrow(x) == 3)
#&gt; # A tibble: 3 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     3     9
#&gt; 2     2     4     8
#&gt; 3     6     6     7
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_specially(tbl, fn = function(x) nrow(x) == 3)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_specially(fn = function(x) nrow(x) == 3)
#&gt; [1] TRUE
</pre></div>



<h4>Variations</h4>

<p>We can do more complex things with <code>specially()</code> and its variants.
</p>
<p>Check the class of the target table.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  test_specially(
    fn = function(x) {
      inherits(x, "data.frame")
    }
  )
#&gt; [1] TRUE
</pre></div>
<p>Check that the number of rows in the target table is less than <code>small_table</code>.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  test_specially(
    fn = function(x) {
      nrow(x) &lt; nrow(small_table)
    }
  )
#&gt; [1] TRUE
</pre></div>
<p>Check that all numbers across all numeric column are less than <code>10</code>.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  test_specially(
    fn = function(x) {
      (x %&gt;% 
         dplyr::select(where(is.numeric)) %&gt;%
         unlist()
      ) &lt; 10
    }
  )
#&gt; [1] TRUE
</pre></div>
<p>Check that all values in column <code>c</code> are greater than b and greater than <code>a</code>
(in each row) and always less than <code>10</code>. This creates a table with the new
column <code>d</code> which is a logical column (that is used as the evaluation of test
units).
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  test_specially(
    fn = function(x) {
      x %&gt;%
        dplyr::mutate(
          d = c &gt; b &amp; c &gt; a &amp; c &lt; 10
        )
    }
  )
#&gt; [1] TRUE
</pre></div>
<p>Check that the <code>game_revenue</code> table (which is not the target table) has
exactly 2000 rows.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% 
  test_specially(
    fn = function(x) {
      nrow(game_revenue) == 2000
    }
  )
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-36
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+tbl_match">tbl_match</a>()</code>
</p>

<hr>
<h2 id='specifications'>A table containing data pertaining to various specifications</h2><span id='topic+specifications'></span>

<h3>Description</h3>

<p>The <code>specifications</code> dataset is useful for testing the
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec()</a></code>, <code><a href="#topic+test_col_vals_within_spec">test_col_vals_within_spec()</a></code>, and
<code><a href="#topic+expect_col_vals_within_spec">expect_col_vals_within_spec()</a></code> functions. For each column, holding character
values for different specifications, rows 1-5 contain valid values, the 6th
row is an NA value, and the final two values (rows 7 and 8) are invalid.
Different specification (<code>spec</code>) keywords apply to each of columns when
validating with any of the aforementioned functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specifications
</code></pre>


<h3>Format</h3>

<p>A tibble with 8 rows and 12 variables:
</p>

<dl>
<dt>isbn_numbers</dt><dd><p>ISBN-13 numbers; can be validated with the <code>"isbn"</code>
specification.</p>
</dd>
<dt>vin_numbers</dt><dd><p>VIN numbers (identifiers for motor vehicles); can be
validated with the <code>"vin"</code> specification.</p>
</dd>
<dt>zip_codes</dt><dd><p>Postal codes for the U.S.; can be validated with the
<code>"postal[USA]"</code> specification or its <code>"zip"</code> alias.</p>
</dd>
<dt>credit_card_numbers</dt><dd><p>Credit card numbers; can be validated with the
<code>"credit_card"</code> specification or the <code>"cc"</code> alias.</p>
</dd>
<dt>iban_austria</dt><dd><p>IBAN numbers for Austrian accounts; can be validated with
the <code>"iban[AUT]"</code> specification.</p>
</dd>
<dt>swift_numbers</dt><dd><p>Swift-BIC numbers; can be validated with the <code>"swift"</code>
specification.</p>
</dd>
<dt>phone_numbers</dt><dd><p>Phone numbers; can be validated with the <code>"phone"</code>
specification.</p>
</dd>
<dt>email_addresses</dt><dd><p>Email addresses; can be validated with the <code>"email"</code>
specification.</p>
</dd>
<dt>urls</dt><dd><p>URLs; can be validated with the  <code>"url"</code> specification.</p>
</dd>
<dt>ipv4_addresses</dt><dd><p>IPv4 addresses; can be validated with the <code>"ipv4"</code>
specification</p>
</dd>
<dt>ipv6_addresses</dt><dd><p>IPv6 addresses; can be validated with the <code>"ipv6"</code>
specification</p>
</dd>
<dt>mac_addresses</dt><dd><p>MAC addresses; can be validated with the <code>"mac"</code>
specification</p>
</dd>
</dl>



<h3>Function ID</h3>

<p>14-3
</p>


<h3>See Also</h3>

<p>Other Datasets: 
<code><a href="#topic+game_revenue">game_revenue</a></code>,
<code><a href="#topic+game_revenue_info">game_revenue_info</a></code>,
<code><a href="#topic+small_table">small_table</a></code>,
<code><a href="#topic+small_table_sqlite">small_table_sqlite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here is a glimpse at the data
# available in `specifications`
dplyr::glimpse(specifications)

</code></pre>

<hr>
<h2 id='stock_msg_body'>Provide simple email message body components: body</h2><span id='topic+stock_msg_body'></span>

<h3>Description</h3>

<p>The <code>stock_msg_body()</code> function simply provides some stock text for an email
message sent via <code><a href="#topic+email_blast">email_blast()</a></code> or obtained as a standalone object through
<code><a href="#topic+email_create">email_create()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stock_msg_body()
</code></pre>


<h3>Value</h3>

<p>Text suitable for the <code>msg_body</code> argument of <code><a href="#topic+email_blast">email_blast()</a></code> and
<code><a href="#topic+email_create">email_create()</a></code>.
</p>


<h3>Function ID</h3>

<p>4-3
</p>


<h3>See Also</h3>

<p>Other Emailing: 
<code><a href="#topic+email_blast">email_blast</a>()</code>,
<code><a href="#topic+email_create">email_create</a>()</code>,
<code><a href="#topic+stock_msg_footer">stock_msg_footer</a>()</code>
</p>

<hr>
<h2 id='stock_msg_footer'>Provide simple email message body components: footer</h2><span id='topic+stock_msg_footer'></span>

<h3>Description</h3>

<p>The <code>stock_msg_footer()</code> function simply provides some stock text for an
email message sent via <code><a href="#topic+email_blast">email_blast()</a></code> or obtained as a standalone object
through <code><a href="#topic+email_create">email_create()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stock_msg_footer()
</code></pre>


<h3>Value</h3>

<p>Text suitable for the <code>msg_footer</code> argument of <code><a href="#topic+email_blast">email_blast()</a></code> and
<code><a href="#topic+email_create">email_create()</a></code>.
</p>


<h3>Function ID</h3>

<p>4-4
</p>


<h3>See Also</h3>

<p>Other Emailing: 
<code><a href="#topic+email_blast">email_blast</a>()</code>,
<code><a href="#topic+email_create">email_create</a>()</code>,
<code><a href="#topic+stock_msg_body">stock_msg_body</a>()</code>
</p>

<hr>
<h2 id='stop_if_not'>A specialized version of <code>stopifnot()</code> for <strong>pointblank</strong>: <code>stop_if_not()</code></h2><span id='topic+stop_if_not'></span>

<h3>Description</h3>

<p>This variation of <code>stopifnot()</code> works well as a standalone replacement for
<code>stopifnot()</code> but is also customized for use in validation checks in R
Markdown documents where <strong>pointblank</strong> is loaded and <code><a href="#topic+validate_rmd">validate_rmd()</a></code> is
invoked. Using <code>stop_if_not()</code> in a code chunk where the <code>validate = TRUE</code>
option is set will yield the correct reporting of successes and failures
whereas <code>stopifnot()</code> does not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_if_not(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_if_not_+3A_...">...</code></td>
<td>
<p>R expressions that should each evaluate to (a logical vector of
all) <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if all statements in <code>...</code> are <code>TRUE</code>.
</p>


<h3>Function ID</h3>

<p>13-5
</p>


<h3>See Also</h3>

<p>Other Utility and Helper Functions: 
<code><a href="#topic+affix_date">affix_date</a>()</code>,
<code><a href="#topic+affix_datetime">affix_datetime</a>()</code>,
<code><a href="#topic+col_schema">col_schema</a>()</code>,
<code><a href="#topic+from_github">from_github</a>()</code>,
<code><a href="#topic+has_columns">has_columns</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This checks whether the number of
# rows in `small_table` is greater
# than `10`
stop_if_not(nrow(small_table) &gt; 10)

# This will stop for sure: there
# isn't a `time` column in `small_table`
# (but there are the `date_time` and
# `date` columns)
# stop_if_not("time" %in% colnames(small_table))

# You're not bound to using tabular
# data here, any statements that
# evaluate to logical vectors will work
stop_if_not(1 &lt; 20:25 - 18)

</code></pre>

<hr>
<h2 id='tbl_get'>Obtain a materialized table via a table store</h2><span id='topic+tbl_get'></span>

<h3>Description</h3>

<p>The <code>tbl_get()</code> function gives us the means to materialize a table that has
an entry in a table store (i.e., has a table-prep formula with a unique
name). The table store that is used for this can be in the form of a
<code>tbl_store</code> object (created with the <code><a href="#topic+tbl_store">tbl_store()</a></code> function) or an on-disk
YAML representation of a table store (created by using <code><a href="#topic+yaml_write">yaml_write()</a></code> with a
<code>tbl_store</code> object).
</p>
<p>Should you want a table-prep formula from a table store to use as a value for
<code>tbl</code> (in <code><a href="#topic+create_agent">create_agent()</a></code>, <code><a href="#topic+create_informant">create_informant()</a></code>, or <code><a href="#topic+set_tbl">set_tbl()</a></code>), then have
a look at the <code><a href="#topic+tbl_source">tbl_source()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_get(tbl, store = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tbl_get_+3A_tbl">tbl</code></td>
<td>
<p>The table to retrieve from a table <code>store</code>. This table could be
identified by its name (e.g., <code>tbl = "large_table"</code>) or by supplying a
reference using a subset (with <code>$</code>) of the <code>tbl_store</code> object (e.g., <code>tbl = store$large_table</code>). If using the latter method then nothing needs to be
supplied to <code>store</code>.</p>
</td></tr>
<tr><td><code id="tbl_get_+3A_store">store</code></td>
<td>
<p>Either a table store object created by the <code><a href="#topic+tbl_store">tbl_store()</a></code>
function or a path to a table store YAML file created by <code><a href="#topic+yaml_write">yaml_write()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table object.
</p>


<h3>Examples</h3>

<p>Define a <code>tbl_store</code> object by adding several table-prep formulas in
<code><a href="#topic+tbl_store">tbl_store()</a></code>.
</p>
<div class="sourceCode r"><pre>store &lt;- 
  tbl_store(
    small_table_duck ~ db_tbl(
      table = small_table,
      dbname = ":memory:",
      dbtype = "duckdb"
    ),
    ~ db_tbl(
      table = "rna",
      dbname = "pfmegrnargs",
      dbtype = "postgres",
      host = "hh-pgsql-public.ebi.ac.uk",
      port = 5432,
      user = I("reader"),
      password = I("NWDMCE5xdipIjRrp")
    ),
    sml_table ~ pointblank::small_table
  )
</pre></div>
<p>Once this object is available, we can access the tables named:
<code>"small_table_duck"</code>, <code>"rna"</code>, and <code>"sml_table"</code>. Let's check that the
<code>"rna"</code> table is accessible through <code><a href="#topic+tbl_get">tbl_get()</a></code>:
</p>
<div class="sourceCode r"><pre>tbl_get(
  tbl = "rna",
  store = store
)
</pre></div>
<pre>## # Source:   table&lt;rna&gt; [?? x 9]
## # Database: postgres [reader@hh-pgsql-public.ebi.ac.uk:5432/pfmegrnargs]
##          id upi        timestamp           userstamp crc64   len seq_short
##     &lt;int64&gt; &lt;chr&gt;      &lt;dttm&gt;              &lt;chr&gt;     &lt;chr&gt; &lt;int&gt; &lt;chr&gt;    
##  1 24583872 URS000177… 2019-12-02 13:26:08 rnacen    C380…   511 ATTGAACG…
##  2 24583873 URS000177… 2019-12-02 13:26:08 rnacen    BC42…   390 ATGGGCGA…
##  3 24583874 URS000177… 2019-12-02 13:26:08 rnacen    19A5…   422 CTACGGGA…
##  4 24583875 URS000177… 2019-12-02 13:26:08 rnacen    66E1…   534 AGGGTTCG…
##  5 24583876 URS000177… 2019-12-02 13:26:08 rnacen    CC8F…   252 TACGTAGG…
##  6 24583877 URS000177… 2019-12-02 13:26:08 rnacen    19E4…   413 ATGGGCGA…
##  7 24583878 URS000177… 2019-12-02 13:26:08 rnacen    AE91…   253 TACGAAGG…
##  8 24583879 URS000177… 2019-12-02 13:26:08 rnacen    E21A…   304 CAGCAGTA…
##  9 24583880 URS000177… 2019-12-02 13:26:08 rnacen    1AA7…   460 CCTACGGG…
## 10 24583881 URS000177… 2019-12-02 13:26:08 rnacen    2046…   440 CCTACGGG…
## # … with more rows, and 2 more variables: seq_long &lt;chr&gt;, md5 &lt;chr&gt;</pre>
<p>An alternative method for getting the same table materialized is by using <code>$</code>
to get the formula of choice from <code>tbls</code> and passing that to <code>tbl_get()</code>. The
benefit of this is that we can use autocompletion to show us what's available
in the table store (i.e., appears after typing the <code>$</code>).
</p>
<div class="sourceCode r"><pre>store$small_table_duck %&gt;% tbl_get()
</pre></div>
<pre>## # Source:   table&lt;small_table&gt; [?? x 8]
## # Database: duckdb_connection
##    date_time           date           a b             c      d e     f    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## # … with more rows</pre>


<h3>Function ID</h3>

<p>1-10
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='tbl_match'>Does the target table match a comparison table?</h2><span id='topic+tbl_match'></span><span id='topic+expect_tbl_match'></span><span id='topic+test_tbl_match'></span>

<h3>Description</h3>

<p>The <code>tbl_match()</code> validation function, the <code>expect_tbl_match()</code> expectation
function, and the <code>test_tbl_match()</code> test function all check whether the
target table's composition matches that of a comparison table. The validation
function can be used directly on a data table or with an <em>agent</em> object
(technically, a <code>ptblank_agent</code> object) whereas the expectation and test
functions can only be used with a data table. The types of data tables that
can be used include data frames, tibbles, database tables (<code>tbl_dbi</code>), and
Spark DataFrames (<code>tbl_spark</code>). As a validation step or as an expectation,
there is a single test unit that hinges on whether the two tables are the
same (after any <code>preconditions</code> have been applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_match(
  x,
  tbl_compare,
  preconditions = NULL,
  segments = NULL,
  actions = NULL,
  step_id = NULL,
  label = NULL,
  brief = NULL,
  active = TRUE
)

expect_tbl_match(object, tbl_compare, preconditions = NULL, threshold = 1)

test_tbl_match(object, tbl_compare, preconditions = NULL, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tbl_match_+3A_x">x</code></td>
<td>
<p><em>A pointblank agent or a data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;|obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), or, an <em>agent</em> object of class <code>ptblank_agent</code> that is
commonly created with <code><a href="#topic+create_agent">create_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_tbl_compare">tbl_compare</code></td>
<td>
<p><em>A data table for comparison</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A table to compare against the target table. This can either be a table
object, a table-prep formula. This can be a table object such as a data
frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object.
Alternatively, a table-prep formula (<code style="white-space: pre;">&#8288;~ &lt;tbl reading code&gt;&#8288;</code>) or a
function (<code style="white-space: pre;">&#8288;function() &lt;tbl reading code&gt;&#8288;</code>) can be used to lazily read in
the table at interrogation time.</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_preconditions">preconditions</code></td>
<td>
<p><em>Input table modification prior to validation</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;table mutation expression&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression for mutating the input table before proceeding with
the validation. This can either be provided as a one-sided R formula using
a leading <code>~</code> (e.g., <code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> or as a
function (e.g., <code>function(x) dplyr::mutate(x, col = col + 10)</code>. See the
<em>Preconditions</em> section for more information.</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_segments">segments</code></td>
<td>
<p><em>Expressions for segmenting the target table</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;segmentation expressions&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional expression or set of expressions (held in a list) that serve to
segment the target table by column values. Each expression can be given in
one of two ways: (1) as column names, or (2) as a two-sided formula where
the LHS holds a column name and the RHS contains the column values to
segment on. See the <em>Segments</em> section for more details on this.</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_actions">actions</code></td>
<td>
<p><em>Thresholds and actions for different states</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;action_levels&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A list containing threshold levels so that the validation step can react
accordingly when exceeding the set levels for different states. This is to
be created with the <code><a href="#topic+action_levels">action_levels()</a></code> helper function.</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_step_id">step_id</code></td>
<td>
<p><em>Manual setting of the step ID value</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>One or more optional identifiers for the single or multiple validation
steps generated from calling a validation function. The use of step IDs
serves to distinguish validation steps from each other and provide an
opportunity for supplying a more meaningful label compared to the step
index. By default this is <code>NULL</code>, and <strong>pointblank</strong> will automatically
generate the step ID value (based on the step index) in this case. One or
more values can be provided, and the exact number of ID values should (1)
match the number of validation steps that the validation function call will
produce (influenced by the number of <code>columns</code> provided), (2) be an ID
string not used in any previous validation step, and (3) be a vector with
unique values.</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_label">label</code></td>
<td>
<p><em>Optional label for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Optional label for the validation step. This label appears in the <em>agent</em>
report and, for the best appearance, it should be kept quite short. See
the <em>Labels</em> section for more information.</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_brief">brief</code></td>
<td>
<p><em>Brief description for the validation step</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A <em>brief</em> is a short, text-based description for the validation step. If
nothing is provided here then an <em>autobrief</em> is generated by the <em>agent</em>,
using the language provided in <code><a href="#topic+create_agent">create_agent()</a></code>'s <code>lang</code> argument (which
defaults to <code>"en"</code> or English). The <em>autobrief</em> incorporates details of the
validation step so it's often the preferred option in most cases (where a
<code>label</code> might be better suited to succinctly describe the validation).</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_active">active</code></td>
<td>
<p><em>Is the validation step active?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>A logical value indicating whether the validation step should be active. If
the validation function is working with an <em>agent</em>, <code>FALSE</code> will make the
validation step inactive (still reporting its presence and keeping indexes
for the steps unchanged). If the validation function will be operating
directly on data (no <em>agent</em> involvement), then any step with <code>active = FALSE</code> will simply pass the data through with no validation whatsoever.
Aside from a logical vector, a one-sided R formula using a leading <code>~</code> can
be used with <code>.</code> (serving as the input data table) to evaluate to a single
logical value. With this approach, the <strong>pointblank</strong> function
<code><a href="#topic+has_columns">has_columns()</a></code> can be used to determine whether to make a validation step
active on the basis of one or more columns existing in the table
(e.g., <code>~ . %&gt;% has_columns(c(d, e))</code>).</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_object">object</code></td>
<td>
<p><em>A data table for expectations or tests</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A data frame, tibble (<code>tbl_df</code> or <code>tbl_dbi</code>), or Spark DataFrame
(<code>tbl_spark</code>) that serves as the target table for the expectation function
or the test function.</p>
</td></tr>
<tr><td><code id="tbl_match_+3A_threshold">threshold</code></td>
<td>
<p><em>The failure threshold</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>1</code>
</p>
<p>A simple failure threshold value for use with the expectation (<code>expect_</code>)
and the test (<code>test_</code>) function variants. By default, this is set to <code>1</code>
meaning that any single unit of failure in data validation results in an
overall test failure. Whole numbers beyond <code>1</code> indicate that any failing
units up to that absolute threshold value will result in a succeeding
<strong>testthat</strong> test or evaluate to <code>TRUE</code>. Likewise, fractional values
(between <code>0</code> and <code>1</code>) act as a proportional failure threshold, where <code>0.15</code>
means that 15 percent of failing test units results in an overall test
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the validation function, the return value is either a
<code>ptblank_agent</code> object or a table object (depending on whether an agent
object or a table was passed to <code>x</code>). The expectation function invisibly
returns its input but, in the context of testing data, the function is
called primarily for its potential side-effects (e.g., signaling failure).
The test function returns a logical value.
</p>


<h3>Supported Input Tables</h3>

<p>The types of data tables that are officially supported are:
</p>

<ul>
<li><p> data frames (<code>data.frame</code>) and tibbles (<code>tbl_df</code>)
</p>
</li>
<li><p> Spark DataFrames (<code>tbl_spark</code>)
</p>
</li>
<li><p> the following database tables (<code>tbl_dbi</code>):
</p>

<ul>
<li> <p><em>PostgreSQL</em> tables (using the <code>RPostgres::Postgres()</code> as driver)
</p>
</li>
<li> <p><em>MySQL</em> tables (with <code>RMySQL::MySQL()</code>)
</p>
</li>
<li> <p><em>Microsoft SQL Server</em> tables (via <strong>odbc</strong>)
</p>
</li>
<li> <p><em>BigQuery</em> tables (using <code>bigrquery::bigquery()</code>)
</p>
</li>
<li> <p><em>DuckDB</em> tables (through <code>duckdb::duckdb()</code>)
</p>
</li>
<li> <p><em>SQLite</em> (with <code>RSQLite::SQLite()</code>)
</p>
</li></ul>

</li></ul>



<h3>Preconditions</h3>

<p>Providing expressions as <code>preconditions</code> means <strong>pointblank</strong> will preprocess
the target table during interrogation as a preparatory step. It might happen
that this particular validation requires some operation on the target table
before the comparison takes place. Using <code>preconditions</code> can be useful at
times since since we can develop a large validation plan with a single target
table and make minor adjustments to it, as needed, along the way.
</p>
<p>The table mutation is totally isolated in scope to the validation step(s)
where <code>preconditions</code> is used. Using <strong>dplyr</strong> code is suggested here since
the statements can be translated to SQL if necessary (i.e., if the target
table resides in a database). The code is most easily supplied as a one-sided
<strong>R</strong> formula (using a leading <code>~</code>). In the formula representation, the <code>.</code>
serves as the input data table to be transformed. Alternatively, a function
could instead be supplied.
</p>


<h3>Segments</h3>

<p>By using the <code>segments</code> argument, it's possible to define a particular
validation with segments (or row slices) of the target table. An optional
expression or set of expressions that serve to segment the target table by
column values. Each expression can be given in one of two ways: (1) as column
names, or (2) as a two-sided formula where the LHS holds a column name and
the RHS contains the column values to segment on.
</p>
<p>As an example of the first type of expression that can be used,
<code>vars(a_column)</code> will segment the target table in however many unique values
are present in the column called <code>a_column</code>. This is great if every unique
value in a particular column (like different locations, or different dates)
requires it's own repeating validation.
</p>
<p>With a formula, we can be more selective with which column values should be
used for segmentation. Using <code>a_column ~ c("group_1", "group_2")</code> will
attempt to obtain two segments where one is a slice of data where the value
<code>"group_1"</code> exists in the column named <code>"a_column"</code>, and, the other is a
slice where <code>"group_2"</code> exists in the same column. Each group of rows
resolved from the formula will result in a separate validation step.
</p>
<p>Segmentation will always occur after <code>preconditions</code> (i.e., statements that
mutate the target table), if any, are applied. With this type of one-two
combo, it's possible to generate labels for segmentation using an expression
for <code>preconditions</code> and refer to those labels in <code>segments</code> without having to
generate a separate version of the target table.
</p>


<h3>Actions</h3>

<p>Often, we will want to specify <code>actions</code> for the validation. This argument,
present in every validation function, takes a specially-crafted list object
that is best produced by the <code><a href="#topic+action_levels">action_levels()</a></code> function. Read that function's
documentation for the lowdown on how to create reactions to above-threshold
failure levels in validation. The basic gist is that you'll want at least a
single threshold level (specified as either the fraction of test units
failed, or, an absolute value), often using the <code>warn_at</code> argument. Using
<code>action_levels(warn_at = 1)</code> or <code>action_levels(stop_at = 1)</code> are good choices
depending on the situation (the first produces a warning, the other
<code>stop()</code>s).
</p>


<h3>Labels</h3>

<p><code>label</code> may be a single string or a character vector that matches the number
of expanded steps. <code>label</code> also supports <code>{glue}</code> syntax and exposes the
following dynamic variables contextualized to the current step:
</p>

<ul>
<li> <p><code>"{.step}"</code>: The validation step name
</p>
</li>
<li> <p><code>"{.seg_col}"</code>: The current segment's column name
</p>
</li>
<li> <p><code>"{.seg_val}"</code>: The current segment's value/group
</p>
</li></ul>

<p>The glue context also supports ordinary expressions for further flexibility
(e.g., <code>"{toupper(.step)}"</code>) as long as they return a length-1 string.
</p>


<h3>Briefs</h3>

<p>Want to describe this validation step in some detail? Keep in mind that this
is only useful if <code>x</code> is an <em>agent</em>. If that's the case, <code>brief</code> the agent
with some text that fits. Don't worry if you don't want to do it. The
<em>autobrief</em> protocol is kicked in when <code>brief = NULL</code> and a simple brief will
then be automatically generated.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> agent can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and the
resulting YAML can be used to regenerate an agent (with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>)
or interrogate the target table (via <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). When
<code>tbl_match()</code> is represented in YAML (under the top-level <code>steps</code> key as a
list member), the syntax closely follows the signature of the validation
function. Here is an example of how a complex call of <code>tbl_match()</code> as a
validation step is expressed in R code and in the corresponding YAML
representation.
</p>
<p>R statement:
</p>
<div class="sourceCode r"><pre>agent %&gt;% 
  tbl_match(
    tbl_compare = ~ file_tbl(
      file = from_github(
        file = "sj_all_revenue_large.rds",
        repo = "rich-iannone/intendo",
        subdir = "data-large"
        )
      ),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "The `tbl_match()` step.",
    active = FALSE
  )
</pre></div>
<p>YAML representation:
</p>
<div class="sourceCode yaml"><pre>steps:
- tbl_match:
    tbl_compare: ~ file_tbl(
      file = from_github(
        file = "sj_all_revenue_large.rds",
        repo = "rich-iannone/intendo",
        subdir = "data-large"
        )
      )
    preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
    segments: b ~ c("group_1", "group_2")
    actions:
      warn_fraction: 0.1
      stop_fraction: 0.2
    label: The `tbl_match()` step.
    active: false
</pre></div>
<p>In practice, both of these will often be shorter. Arguments with default
values won't be written to YAML when using <code><a href="#topic+yaml_write">yaml_write()</a></code> (though it is
acceptable to include them with their default when generating the YAML by
other means). It is also possible to preview the transformation of an agent
to YAML without any writing to disk by using the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code>
function.
</p>


<h3>Examples</h3>

<p>Create a simple table with three columns and four rows of values.
</p>
<div class="sourceCode r"><pre>tbl &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5),
    b = c(7, 1, 0, 0),
    c = c(1, 1, 1, 3)
  )

tbl
#&gt; # A tibble: 4 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7     1
#&gt; 2     7     1     1
#&gt; 3     6     0     1
#&gt; 4     5     0     3
</pre></div>
<p>Create a second table which is the same as <code>tbl</code>.
</p>
<div class="sourceCode r"><pre>tbl_2 &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5),
    b = c(7, 1, 0, 0),
    c = c(1, 1, 1, 3)
  )

tbl_2
#&gt; # A tibble: 4 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7     1
#&gt; 2     7     1     1
#&gt; 3     6     0     1
#&gt; 4     5     0     3
</pre></div>


<h4>A: Using an <code>agent</code> with validation functions and then <code>interrogate()</code></h4>

<p>Validate that the target table (<code>tbl</code>) and the comparison table (<code>tbl_2</code>) are
equivalent in terms of content.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  tbl_match(tbl_compare = tbl_2) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report, showing the single entry
that corresponds to the validation step demonstrated here.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_tbl_match_1.png" alt="This image was generated from the first code example in the `tbl_match()` help file." style="width:100%;">





<h4>B: Using the validation function directly on the data (no <code>agent</code>)</h4>

<p>This way of using validation functions acts as a data filter. Data is passed
through but should <code>stop()</code> if there is a single test unit failing. The
behavior of side effects can be customized with the <code>actions</code> option.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% tbl_match(tbl_compare = tbl_2)
#&gt; # A tibble: 4 x 3
#&gt;       a     b     c
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     5     7     1
#&gt; 2     7     1     1
#&gt; 3     6     0     1
#&gt; 4     5     0     3
</pre></div>



<h4>C: Using the expectation function</h4>

<p>With the <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> form, we would typically perform one validation at a
time. This is primarily used in <strong>testthat</strong> tests.
</p>
<div class="sourceCode r"><pre>expect_tbl_match(tbl, tbl_compare = tbl_2)
</pre></div>



<h4>D: Using the test function</h4>

<p>With the <code style="white-space: pre;">&#8288;test_*()&#8288;</code> form, we should get a single logical value returned to
us.
</p>
<div class="sourceCode r"><pre>tbl %&gt;% test_tbl_match(tbl_compare = tbl_2)
#&gt; [1] TRUE
</pre></div>



<h3>Function ID</h3>

<p>2-33
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+col_count_match">col_count_match</a>()</code>,
<code><a href="#topic+col_exists">col_exists</a>()</code>,
<code><a href="#topic+col_is_character">col_is_character</a>()</code>,
<code><a href="#topic+col_is_date">col_is_date</a>()</code>,
<code><a href="#topic+col_is_factor">col_is_factor</a>()</code>,
<code><a href="#topic+col_is_integer">col_is_integer</a>()</code>,
<code><a href="#topic+col_is_logical">col_is_logical</a>()</code>,
<code><a href="#topic+col_is_numeric">col_is_numeric</a>()</code>,
<code><a href="#topic+col_is_posix">col_is_posix</a>()</code>,
<code><a href="#topic+col_schema_match">col_schema_match</a>()</code>,
<code><a href="#topic+col_vals_between">col_vals_between</a>()</code>,
<code><a href="#topic+col_vals_decreasing">col_vals_decreasing</a>()</code>,
<code><a href="#topic+col_vals_equal">col_vals_equal</a>()</code>,
<code><a href="#topic+col_vals_expr">col_vals_expr</a>()</code>,
<code><a href="#topic+col_vals_gt">col_vals_gt</a>()</code>,
<code><a href="#topic+col_vals_gte">col_vals_gte</a>()</code>,
<code><a href="#topic+col_vals_in_set">col_vals_in_set</a>()</code>,
<code><a href="#topic+col_vals_increasing">col_vals_increasing</a>()</code>,
<code><a href="#topic+col_vals_lt">col_vals_lt</a>()</code>,
<code><a href="#topic+col_vals_lte">col_vals_lte</a>()</code>,
<code><a href="#topic+col_vals_make_set">col_vals_make_set</a>()</code>,
<code><a href="#topic+col_vals_make_subset">col_vals_make_subset</a>()</code>,
<code><a href="#topic+col_vals_not_between">col_vals_not_between</a>()</code>,
<code><a href="#topic+col_vals_not_equal">col_vals_not_equal</a>()</code>,
<code><a href="#topic+col_vals_not_in_set">col_vals_not_in_set</a>()</code>,
<code><a href="#topic+col_vals_not_null">col_vals_not_null</a>()</code>,
<code><a href="#topic+col_vals_null">col_vals_null</a>()</code>,
<code><a href="#topic+col_vals_regex">col_vals_regex</a>()</code>,
<code><a href="#topic+col_vals_within_spec">col_vals_within_spec</a>()</code>,
<code><a href="#topic+conjointly">conjointly</a>()</code>,
<code><a href="#topic+row_count_match">row_count_match</a>()</code>,
<code><a href="#topic+rows_complete">rows_complete</a>()</code>,
<code><a href="#topic+rows_distinct">rows_distinct</a>()</code>,
<code><a href="#topic+serially">serially</a>()</code>,
<code><a href="#topic+specially">specially</a>()</code>
</p>

<hr>
<h2 id='tbl_source'>Obtain a table-prep formula from a table store</h2><span id='topic+tbl_source'></span>

<h3>Description</h3>

<p>The <code>tbl_source()</code> function provides a convenient means to access a
table-prep formula from either a <code>tbl_store</code> object or a table store YAML
file (which can be created with the <code><a href="#topic+yaml_write">yaml_write()</a></code> function). A call to
<code>tbl_source()</code> is most useful as an input to the <code>tbl</code> argument of
<code><a href="#topic+create_agent">create_agent()</a></code>, <code><a href="#topic+create_informant">create_informant()</a></code>, or <code><a href="#topic+set_tbl">set_tbl()</a></code>.
</p>
<p>Should you need to obtain the table itself (that is generated via the
table-prep formula), then the <code><a href="#topic+tbl_get">tbl_get()</a></code> function should be used for that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_source(tbl, store = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tbl_source_+3A_tbl">tbl</code></td>
<td>
<p>The table name associated with a table-prep formula. This is part
of the table <code>store</code>. This table could be identified by its name (e.g.,
<code>tbl = "large_table"</code>) or by supplying a reference using a subset (with
<code>$</code>) of the <code>tbl_store</code> object (e.g., <code>tbl = store$large_table</code>). If using
the latter method then nothing needs to be supplied to <code>store</code>.</p>
</td></tr>
<tr><td><code id="tbl_source_+3A_store">store</code></td>
<td>
<p>Either a table store object created by the <code><a href="#topic+tbl_store">tbl_store()</a></code>
function or a path to a table store YAML file created by <code><a href="#topic+yaml_write">yaml_write()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table-prep formula.
</p>


<h3>Examples</h3>

<p>Let's create a <code>tbl_store</code> object by giving two table-prep formulas to
<code><a href="#topic+tbl_store">tbl_store()</a></code>.
</p>
<div class="sourceCode r"><pre>store &lt;- 
  tbl_store(
    small_table_duck ~ db_tbl(
      table = small_table,
      dbname = ":memory:",
      dbtype = "duckdb"
    ),
    sml_table ~ pointblank::small_table
  )
</pre></div>
<p>We can pass a table-prep formula to <code><a href="#topic+create_agent">create_agent()</a></code> via <code><a href="#topic+tbl_source">tbl_source()</a></code>, add
some validation steps, and interrogate the table shortly thereafter.
</p>
<div class="sourceCode r"><pre>agent_1 &lt;- 
  create_agent(
    tbl = ~ tbl_source("sml_table", store),
    label = "`tbl_source()` example",
    actions = action_levels(warn_at = 0.10)
  ) %&gt;% 
  col_exists(columns = c(date, date_time)) %&gt;%
  interrogate()
</pre></div>
<p>The <code>agent_1</code> object can be printed to see the validation report in the
Viewer.
</p>
<div class="sourceCode r"><pre>agent_1
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_tbl_source_1.png" alt="This image was generated from the first code example in the `tbl_source()` help file." style="width:100%;">


<p>The <code>tbl_store</code> object can be transformed to YAML with the <code><a href="#topic+yaml_write">yaml_write()</a></code>
function. The following statement writes the <code>tbl_store.yml</code> file by default
(but a different name could be used with the <code>filename</code> argument):
</p>
<div class="sourceCode r"><pre>yaml_write(store)
</pre></div>
<p>Let's modify the agent's target to point to the table labeled as
<code>"sml_table"</code> in the YAML representation of the <code>tbl_store</code>.
</p>
<div class="sourceCode r"><pre>agent_2 &lt;-
  agent_1 %&gt;% 
  set_tbl(
    ~ tbl_source(
        tbl = "sml_table",
        store = "tbl_store.yml"
      )
  )
</pre></div>
<p>We can likewise write the agent to a YAML file with <code><a href="#topic+yaml_write">yaml_write()</a></code> (writes to
<code>agent-sml_table.yml</code> by default but the <code>filename</code> allows for any filename
you want).
</p>
<div class="sourceCode r"><pre>yaml_write(agent_2)
</pre></div>
<p>Now that both the agent and the associated table store are present as on-disk
YAML, interrogations can be done by using <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>.
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_agent_interrogate(filename = "agent-sml_table.yml")
</pre></div>


<h3>Function ID</h3>

<p>1-9
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='tbl_store'>Define a store of tables with table-prep formulas: a table store</h2><span id='topic+tbl_store'></span>

<h3>Description</h3>

<p>It can be useful to set up all the data sources you need and just draw from
them when necessary. This upfront configuration with <code>tbl_store()</code> lets us
define the methods for obtaining tabular data from mixed sources (e.g.,
database tables, tables generated from flat files, etc.) and provide
identifiers for these data preparation procedures.
</p>
<p>What results from this work is a convenient way to materialize tables with
<code><a href="#topic+tbl_get">tbl_get()</a></code>. We can also get any table-prep formula from the table store
with <code><a href="#topic+tbl_source">tbl_source()</a></code>. The content of a table-prep formulas can involve reading
a table from a location, or, it can involve data transformation. One can
imagine scenarios where we might (1) procure several mutated variations of
the same source table, (2) generate a table using disparate data sources, or
(3) filter the rows of a database table according to the system time. Another
nice aspect of organizing table-prep formulas in a single object is supplying
it to the <code>tbl</code> argument of <code><a href="#topic+create_agent">create_agent()</a></code> or <code><a href="#topic+create_informant">create_informant()</a></code> via <code>$</code>
notation (e.g, <code style="white-space: pre;">&#8288;create_agent(tbl = &lt;tbl_store&gt;$&lt;name&gt;)&#8288;</code>) or with
<code><a href="#topic+tbl_source">tbl_source()</a></code> (e.g.,
<code style="white-space: pre;">&#8288;create_agent(tbl = ~ tbl_source("&lt;name&gt;", &lt;tbl_store&gt;))&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_store(..., .list = list2(...), .init = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tbl_store_+3A_...">...</code></td>
<td>
<p>Expressions that contain table-prep formulas and table names for
data retrieval. Two-sided formulas (e.g, <code style="white-space: pre;">&#8288;&lt;LHS&gt; ~ &lt;RHS&gt;&#8288;</code>) are to be used,
where the left-hand side is an identifier and the right-hand contains a
statement that obtains a table (i.e., the table-prep formula). If the LHS
is omitted then an identifier will be generated for you.</p>
</td></tr>
<tr><td><code id="tbl_store_+3A_.list">.list</code></td>
<td>
<p>Allows for the use of a list as an input alternative to <code>...</code>.</p>
</td></tr>
<tr><td><code id="tbl_store_+3A_.init">.init</code></td>
<td>
<p>We can optionally provide an initialization statement (in a
one-sided formula) that should be executed whenever <em>any</em> of tables in the
table store are obtained. This is useful, for instance, for including a
<code>library()</code> call that can be executed before any table-prep formulas in
<code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tbl_store</code> object that contains table-prep formulas.
</p>


<h3>YAML</h3>

<p>A <strong>pointblank</strong> table store can be written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code> and
the resulting YAML can be used in several ways. The ideal scenario is to have
pointblank agents and informants also in YAML form. This way the agent and
informant can refer to the table store YAML (via <code><a href="#topic+tbl_source">tbl_source()</a></code>), and, the
processing of both agents and informants can be performed with
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code> and <code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code>. With the
following R code, a table store with two table-prep formulas is generated and
written to YAML (if no filename is given then the YAML is written to
<code>"tbl_store.yml"</code>).
</p>
<p>R statement for generating the <code>"tbl_store.yml"</code> file:
</p>
<div class="sourceCode r"><pre>tbl_store(
  tbl_duckdb ~ db_tbl(small_table, dbname = ":memory:", dbtype = "duckdb"),
  sml_table_high ~ small_table %&gt;% dplyr::filter(f == "high"),
  .init = ~ library(tidyverse)
) %&gt;%
  yaml_write()
</pre></div>
<p>YAML representation (<code>"tbl_store.yml"</code>):
</p>
<div class="sourceCode yaml"><pre>type: tbl_store
tbls:
  tbl_duckdb: ~ db_tbl(small_table, dbname = ":memory:", dbtype = "duckdb")
  sml_table_high: ~ small_table %&gt;% dplyr::filter(f == "high")
init: ~library(tidyverse)
</pre></div>
<p>This is useful when you want to get fresh pulls of prepared data from a
source materialized in an R session (with the <code><a href="#topic+tbl_get">tbl_get()</a></code> function. For
example, the <code>sml_table_high</code> table can be obtained by using
<code>tbl_get("sml_table_high", "tbl_store.yml")</code>. To get an agent to check this
prepared data periodically, then the following example with <code><a href="#topic+tbl_source">tbl_source()</a></code>
will be useful:
</p>
<p>R code to generate agent that checks <code>sml_table_high</code> and writing the agent
to YAML:
</p>
<div class="sourceCode r"><pre>create_agent(
  tbl = ~ tbl_source("sml_table_high", "tbl_store.yml"),
  label = "An example that uses a table store.",
  actions = action_levels(warn_at = 0.10)
) %&gt;% 
  col_exists(c(date, date_time)) %&gt;%
  write_yaml()
</pre></div>
<p>The YAML representation (<code>"agent-sml_table_high.yml"</code>):
</p>
<div class="sourceCode yaml"><pre>tbl: ~ tbl_source("sml_table_high", "tbl_store.yml")
tbl_name: sml_table_high
label: An example that uses a table store.
actions:
  warn_fraction: 0.1
locale: en
steps:
  - col_exists:
    columns: c(date, date_time)
</pre></div>
<p>Now, whenever the <code>sml_table_high</code> table needs to be validated, it can be
done with <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code> (e.g.,
<code>yaml_agent_interrogate("agent-sml_table_high.yml")</code>).
</p>


<h3>Examples</h3>



<h4>Creating an in-memory table store and adding table-prep formulas</h4>

<p>The table store provides a way to get the tables we need fairly easily. Think
of an identifier for the table you'd like and then provide the code necessary
to obtain that table. Then repeat as many times as you like!
</p>
<p>Here we'll define two tables that can be materialized later: <code>tbl_duckdb</code> (an
in-memory DuckDB database table with <strong>pointblank</strong>'s <code>small_table</code> dataset)
and <code>sml_table_high</code> (a filtered version of <code>tbl_duckdb</code>):
</p>
<div class="sourceCode r"><pre>store_1 &lt;-
  tbl_store(
    tbl_duckdb ~ 
      db_tbl(
        pointblank::small_table,
        dbname = ":memory:",
        dbtype = "duckdb"
      ),
    sml_table_high ~ 
      db_tbl(
        pointblank::small_table,
        dbname = ":memory:",
        dbtype = "duckdb"
      ) %&gt;%
      dplyr::filter(f == "high")
  )
</pre></div>
<p>We can see what's in the table store <code>store_1</code> by printing it out:
</p>
<div class="sourceCode r"><pre>store_1
</pre></div>
<pre>## -- The `table_store` table-prep formulas
## 1 tbl_duckdb // ~ db_tbl(pointblank::small_table, dbname = ":memory:",
## dbtype = "duckdb")
## 2 sml_table_high // ~ db_tbl(pointblank::small_table, dbname = ":memory:",
## dbtype = "duckdb") %&gt;% dplyr::filter(f == "high")
## ----</pre>
<p>It's good to check that the tables can be obtained without error. We can do
this with the <code><a href="#topic+tbl_get">tbl_get()</a></code> function. With that function, we need to supply the
given name of the table-prep formula (in quotes) and the table store object.
</p>
<div class="sourceCode r"><pre>tbl_get(tbl = "tbl_duckdb", store = store_1)
</pre></div>
<pre>## # Source:   table&lt;pointblank::small_table&gt; [?? x 8]
## # Database: duckdb_connection
##    date_time           date           a b             c      d e     f    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## # … with more rows</pre>
<div class="sourceCode r"><pre>tbl_get(tbl = "sml_table_high", store = store_1)
</pre></div>
<pre>## # Source:   lazy query [?? x 8]
## # Database: duckdb_connection
##   date_time           date           a b             c     d e     f    
##   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
## 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3 3423. TRUE  high 
## 2 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3 2343. TRUE  high 
## 3 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high 
## 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high 
## 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high 
## 6 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high</pre>
<p>We can shorten the <code>tbl_store()</code> statement with some syntax that
<strong>pointblank</strong> provides. The <code>sml_table_high</code> table-prep is simply a
transformation of <code>tbl_duckdb</code>, so, we can use <code>{{ tbl_duckdb }}</code> in place of
the repeated statement. Additionally, we can provide a <code>library()</code> call to
the <code>.init</code> argument of <code>tbl_store()</code> so that <strong>dplyr</strong> is available (thus
allowing us to use <code>filter(...)</code> instead of <code>dplyr::filter(...)</code>). Here is
the revised <code>tbl_store()</code> call:
</p>
<div class="sourceCode r"><pre>store_2 &lt;- 
  tbl_store(
    tbl_duckdb ~ 
      db_tbl(
        pointblank::small_table,
        dbname = ":memory:",
        dbtype = "duckdb"
      ),
    sml_table_high ~ 
      {{ tbl_duckdb }} %&gt;%
      filter(f == "high"),
    .init = ~ library(tidyverse)
  )
</pre></div>
<p>Printing the table store <code>store_2</code> now shows that we used an <code>.init</code>
statement:
</p>
<div class="sourceCode r"><pre>store_2
</pre></div>
<pre>## -- The `table_store` table-prep formulas
## 1 tbl_duckdb // ~ db_tbl(pointblank::small_table, dbname = ":memory:",
## dbtype = "duckdb")
## 2 sml_table_high // ~ {{tbl_duckdb}} %&gt;% filter(f == "high") 
## ----
## INIT // ~library(tidyverse)
## ----</pre>
<p>Checking again with <code><a href="#topic+tbl_get">tbl_get()</a></code> should provide the same tables as before:
</p>
<div class="sourceCode r"><pre>tbl_get(tbl = "tbl_duckdb", store = store_2)
</pre></div>
<pre>## # Source:   table&lt;pointblank::small_table&gt; [?? x 8]
## # Database: duckdb_connection
##    date_time           date           a b             c      d e     f    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## # … with more rows</pre>
<div class="sourceCode r"><pre>tbl_get(tbl = "sml_table_high", store = store_2)
</pre></div>
<pre>## # Source:   lazy query [?? x 8]
## # Database: duckdb_connection
##   date_time           date           a b             c     d e     f    
##   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
## 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3 3423. TRUE  high 
## 2 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3 2343. TRUE  high 
## 3 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high 
## 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high 
## 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high 
## 6 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high</pre>



<h4>Using a table store in a data validation workflow</h4>

<p>Define a <code>tbl_store</code> object by adding table-prep formulas inside the
<code><a href="#topic+tbl_store">tbl_store()</a></code> call.
</p>
<div class="sourceCode r"><pre>store_3 &lt;- 
  tbl_store(
    small_table_duck ~ db_tbl(
      table = small_table,
      dbname = ":memory:",
      dbtype = "duckdb"
    ),
    ~ db_tbl(
      table = "rna",
      dbname = "pfmegrnargs",
      dbtype = "postgres",
      host = "hh-pgsql-public.ebi.ac.uk",
      port = 5432,
      user = I("reader"),
      password = I("NWDMCE5xdipIjRrp")
    ),
    all_revenue ~ db_tbl(
      table = file_tbl(
        file = from_github(
          file = "sj_all_revenue_large.rds",
          repo = "rich-iannone/intendo",
          subdir = "data-large"
        )
      ),
      dbname = ":memory:",
      dbtype = "duckdb"
    ),
    sml_table ~ pointblank::small_table
  )
</pre></div>
<p>Let's get a summary of what's in the table store <code>store_3</code> through printing:
</p>
<div class="sourceCode r"><pre>store_3
</pre></div>
<pre>## -- The `table_store` table-prep formulas
## 1 small_table_duck // ~ db_tbl(table = small_table, dbname = ":memory:",
## dbtype = "duckdb")
## 2 rna // ~db_tbl(table = "rna", dbname = "pfmegrnargs", dbtype =
## "postgres", host = "hh-pgsql-public.ebi.ac.uk", port = 5432, user =
## I("reader"), password = I("NWDMCE5xdipIjRrp"))
## 3 all_revenue // ~ db_tbl(table = file_tbl(file = from_github(file =
## "sj_all_revenue_large.rds", repo = "rich-iannone/intendo", subdir =
## "data-large")), dbname = ":memory:", dbtype = "duckdb")
## 4 sml_table // ~ pointblank::small_table
## ----</pre>
<p>Once this object is available, you can check that the table of interest is
produced to your specification with the <code><a href="#topic+tbl_get">tbl_get()</a></code> function.
</p>
<div class="sourceCode r"><pre>tbl_get(
  tbl = "small_table_duck",
  store = store_3
)
</pre></div>
<pre>## # Source:   table&lt;small_table&gt; [?? x 8]
## # Database: duckdb_connection
##    date_time           date           a b             c      d e     f    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## # … with more rows</pre>
<p>Another way to get the same table materialized is by using <code>$</code> to get the
entry of choice for <code><a href="#topic+tbl_get">tbl_get()</a></code>.
</p>
<div class="sourceCode r"><pre>store_3$small_table_duck %&gt;% tbl_get()
</pre></div>
<pre>## # Source:   table&lt;small_table&gt; [?? x 8]
## # Database: duckdb_connection
##    date_time           date           a b             c      d e     f    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## # … with more rows</pre>
<p>Creating an agent is easy when all table-prep formulas are encapsulated in a
<code>tbl_store</code> object. Use <code>$</code> notation to pass the appropriate procedure for
reading a table to the <code>tbl</code> argument.
</p>
<div class="sourceCode r"><pre>agent_1 &lt;-
  create_agent(
    tbl = store_3$small_table_duck
  )
</pre></div>
<p>There are other ways to use the table store to assign a target table to an
agent, like using the <code><a href="#topic+tbl_source">tbl_source()</a></code> function (which extracts the table-prep
formula from the table store).
</p>
<div class="sourceCode r"><pre>agent_2 &lt;-
  create_agent(
    tbl = ~ tbl_source(
      tbl = "small_table_duck",
      store = store_3
      )
  )
</pre></div>



<h4>Writing a table store to a YAML file</h4>

<p>The table store can be moved to YAML with <code>yaml_write</code> and the <code><a href="#topic+tbl_source">tbl_source()</a></code>
call could then refer to that on-disk table store. Let's do that YAML
conversion.
</p>
<div class="sourceCode r"><pre>yaml_write(store_3)
</pre></div>
<p>The above writes the <code>tbl_store.yml</code> file (by not providing a <code>filename</code> this
default filename is chosen).
</p>
<p>It can be convenient to read table-prep formulas from a YAML file that's a
table store. To achieve this, we can modify the <code><a href="#topic+tbl_source">tbl_source()</a></code> statement in
the <code><a href="#topic+create_agent">create_agent()</a></code> call so that <code>store</code> refers to the on-disk YAML file.
</p>
<div class="sourceCode r"><pre>agent_3 &lt;-
  create_agent(
    tbl = ~ tbl_source(
      tbl = "small_table_duck",
      store = "tbl_store.yml"
    )
  )
</pre></div>



<h3>Function ID</h3>

<p>1-8
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+validate_rmd">validate_rmd</a>()</code>
</p>

<hr>
<h2 id='tt_string_info'>Table Transformer: obtain a summary table for string columns</h2><span id='topic+tt_string_info'></span>

<h3>Description</h3>

<p>With any table object, you can produce a summary table that is scoped to
string-based columns. The output summary table will have a leading column
called <code>".param."</code> with labels for each of the three rows, each corresponding
to the following pieces of information pertaining to string length:
</p>

<ol>
<li><p> Mean String Length (<code>"length_mean"</code>)
</p>
</li>
<li><p> Minimum String Length (<code>"length_min"</code>)
</p>
</li>
<li><p> Maximum String Length (<code>"length_max"</code>)
</p>
</li></ol>

<p>Only string data from the input table will generate columns in the output
table. Column names from the input will be used in the output, preserving
order as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tt_string_info(tbl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tt_string_info_+3A_tbl">tbl</code></td>
<td>
<p><em>A data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A table object to be used as input for the transformation. This can be a
data frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> object.
</p>


<h3>Examples</h3>

<p>Get string information for the string-based columns in the <code>game_revenue</code>
dataset that is included in the <strong>pointblank</strong> package.
</p>
<div class="sourceCode r"><pre>tt_string_info(tbl = game_revenue)
#&gt; # A tibble: 3 x 7
#&gt;   .param.     player_id session_id item_type item_name acquisition country
#&gt;   &lt;chr&gt;           &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1 length_mean        15         24      2.22      7.35        7.97    8.53
#&gt; 2 length_min         15         24      2         5           5       5   
#&gt; 3 length_max         15         24      3        11          14      14
</pre></div>
<p>Ensure that <code>player_id</code> and <code>session_id</code> values always have the same fixed
numbers of characters (<code>15</code> and <code>24</code>, respectively) throughout the table.
</p>
<div class="sourceCode r"><pre>tt_string_info(tbl = game_revenue) %&gt;%
  col_vals_equal(
    columns = player_id,
    value = 15
  ) %&gt;%
  col_vals_equal(
    columns = session_id,
    value = 24
  )
#&gt; # A tibble: 3 x 7
#&gt;   .param.     player_id session_id item_type item_name acquisition country
#&gt;   &lt;chr&gt;           &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1 length_mean        15         24      2.22      7.35        7.97    8.53
#&gt; 2 length_min         15         24      2         5           5       5   
#&gt; 3 length_max         15         24      3        11          14      14
</pre></div>
<p>We see data, and not an error, so both validations were successful!
</p>
<p>Let's use a <code>tt_string_info()</code>-transformed table with the
<code><a href="#topic+test_col_vals_lte">test_col_vals_lte()</a></code> to check that the maximum string length in column <code>f</code>
of the <code>small_table</code> dataset is no greater than <code>4</code>.
</p>
<div class="sourceCode r"><pre>tt_string_info(tbl = small_table) %&gt;%
  test_col_vals_lte(
    columns = f,
    value = 4
  )
#&gt; [1] TRUE
</pre></div>


<h3>Function ID</h3>

<p>12-2
</p>


<h3>See Also</h3>

<p>Other Table Transformers: 
<code><a href="#topic+get_tt_param">get_tt_param</a>()</code>,
<code><a href="#topic+tt_summary_stats">tt_summary_stats</a>()</code>,
<code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames</a>()</code>,
<code><a href="#topic+tt_tbl_dims">tt_tbl_dims</a>()</code>,
<code><a href="#topic+tt_time_shift">tt_time_shift</a>()</code>,
<code><a href="#topic+tt_time_slice">tt_time_slice</a>()</code>
</p>

<hr>
<h2 id='tt_summary_stats'>Table Transformer: obtain a summary stats table for numeric columns</h2><span id='topic+tt_summary_stats'></span>

<h3>Description</h3>

<p>With any table object, you can produce a summary table that is scoped to the
numeric column values. The output summary table will have a leading column
called <code>".param."</code> with labels for each of the nine rows, each corresponding
to the following summary statistics:
</p>

<ol>
<li><p> Minimum (<code>"min"</code>)
</p>
</li>
<li><p> 5th Percentile (<code>"p05"</code>)
</p>
</li>
<li><p> 1st Quartile (<code>"q_1"</code>)
</p>
</li>
<li><p> Median (<code>"med"</code>)
</p>
</li>
<li><p> 3rd Quartile (<code>"q_3"</code>)
</p>
</li>
<li><p> 95th Percentile (<code>"p95"</code>)
</p>
</li>
<li><p> Maximum (<code>"max"</code>)
</p>
</li>
<li><p> Interquartile Range (<code>"iqr"</code>)
</p>
</li>
<li><p> Range (<code>"range"</code>)
</p>
</li></ol>

<p>Only numerical data from the input table will generate columns in the output
table. Column names from the input will be used in the output, preserving
order as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tt_summary_stats(tbl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tt_summary_stats_+3A_tbl">tbl</code></td>
<td>
<p><em>A data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A table object to be used as input for the transformation. This can be a
data frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> object.
</p>


<h3>Examples</h3>

<p>Get summary statistics for the <code>game_revenue</code> dataset that is included in the
<strong>pointblank</strong> package.
</p>
<div class="sourceCode r"><pre>tt_summary_stats(tbl = game_revenue)
#&gt; # A tibble: 9 x 3
#&gt;   .param. item_revenue session_duration
#&gt;   &lt;chr&gt;          &lt;dbl&gt;            &lt;dbl&gt;
#&gt; 1 min             0                 3.2
#&gt; 2 p05             0.02              8.2
#&gt; 3 q_1             0.09             18.5
#&gt; 4 med             0.38             26.5
#&gt; 5 q_3             1.25             33.8
#&gt; 6 p95            22.0              39.5
#&gt; 7 max           143.               41  
#&gt; 8 iqr             1.16             15.3
#&gt; 9 range         143.               37.8
</pre></div>
<p>Table transformers work great in conjunction with validation functions. Let's
ensure that the maximum revenue for individual purchases in the
<code>game_revenue</code> table is less than $150.
</p>
<div class="sourceCode r"><pre>tt_summary_stats(tbl = game_revenue) %&gt;%
  col_vals_lt(
    columns = item_revenue,
    value = 150,
    segments = .param. ~ "max"
  )
#&gt; # A tibble: 9 x 3
#&gt;   .param. item_revenue session_duration
#&gt;   &lt;chr&gt;          &lt;dbl&gt;            &lt;dbl&gt;
#&gt; 1 min             0                 3.2
#&gt; 2 p05             0.02              8.2
#&gt; 3 q_1             0.09             18.5
#&gt; 4 med             0.38             26.5
#&gt; 5 q_3             1.25             33.8
#&gt; 6 p95            22.0              39.5
#&gt; 7 max           143.               41  
#&gt; 8 iqr             1.16             15.3
#&gt; 9 range         143.               37.8
</pre></div>
<p>We see data, and not an error, so the validation was successful!
</p>
<p>Let's do another: for in-app purchases in the <code>game_revenue</code> table, check
that the median revenue is somewhere between $8 and $12.
</p>
<div class="sourceCode r"><pre>game_revenue %&gt;% 
  dplyr::filter(item_type == "iap") %&gt;%
  tt_summary_stats() %&gt;%
  col_vals_between(
    columns = item_revenue,
    left = 8, right = 12,
    segments = .param. ~ "med"
  )
#&gt; # A tibble: 9 x 3
#&gt;   .param. item_revenue session_duration
#&gt;   &lt;chr&gt;          &lt;dbl&gt;            &lt;dbl&gt;
#&gt; 1 min             0.4              3.2 
#&gt; 2 p05             1.39             5.99
#&gt; 3 q_1             4.49            14.0 
#&gt; 4 med            10.5             22.6 
#&gt; 5 q_3            20.3             30.6 
#&gt; 6 p95            66.0             38.8 
#&gt; 7 max           143.              41   
#&gt; 8 iqr            15.8             16.7 
#&gt; 9 range         143.              37.8
</pre></div>
<p>We can get more creative with this transformer. Why not use a transformed
table in a validation plan? While performing validations of the
<code>game_revenue</code> table with an agent we can include the same revenue check as
above by using <code>tt_summary_stats()</code> in the <code>preconditions</code> argument. This
transforms the target table into a summary table for the validation step. The
final step of the transformation in <code>preconditions</code> is a <code>dplyr::filter()</code>
step that isolates the row of the median statistic.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = game_revenue,
    tbl_name = "game_revenue",
    label = "`tt_summary_stats()` example.",
    actions = action_levels(
      warn_at = 0.10,
      stop_at = 0.25,
      notify_at = 0.35
    )
  ) %&gt;%
  rows_complete() %&gt;%
  rows_distinct() %&gt;%
  col_vals_between(
    columns = item_revenue,
    left = 8, right = 12,
    preconditions = ~ . %&gt;%
      dplyr::filter(item_type == "iap") %&gt;%
      tt_summary_stats() %&gt;%
      dplyr::filter(.param. == "med")
  ) %&gt;%
  interrogate()
</pre></div>
<p>Printing the <code>agent</code> in the console shows the validation report in the
Viewer. Here is an excerpt of validation report. Take note of the final step
(<code style="white-space: pre;">&#8288;STEP 3&#8288;</code>) as it shows the entry that corresponds to the <code><a href="#topic+col_vals_between">col_vals_between()</a></code>
validation step that uses the summary stats table as its target.
</p>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_tt_summary_stats_1.png" alt="This image was generated from the first code example in the `tt_summary_stats()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>12-1
</p>


<h3>See Also</h3>

<p>Other Table Transformers: 
<code><a href="#topic+get_tt_param">get_tt_param</a>()</code>,
<code><a href="#topic+tt_string_info">tt_string_info</a>()</code>,
<code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames</a>()</code>,
<code><a href="#topic+tt_tbl_dims">tt_tbl_dims</a>()</code>,
<code><a href="#topic+tt_time_shift">tt_time_shift</a>()</code>,
<code><a href="#topic+tt_time_slice">tt_time_slice</a>()</code>
</p>

<hr>
<h2 id='tt_tbl_colnames'>Table Transformer: get a table's column names</h2><span id='topic+tt_tbl_colnames'></span>

<h3>Description</h3>

<p>With any table object, you can produce a summary table that contains table's
column names. The output summary table will have two columns and as many rows
as there are columns in the input table. The first column is the <code>".param."</code>
column, which is an integer-based column containing the indices of the
columns from the input table. The second column, <code>"value"</code>, contains the
column names from the input table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tt_tbl_colnames(tbl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tt_tbl_colnames_+3A_tbl">tbl</code></td>
<td>
<p><em>A data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A table object to be used as input for the transformation. This can be a
data frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> object.
</p>


<h3>Examples</h3>

<p>Get the column names of the <code>game_revenue</code> dataset that is included in the
<strong>pointblank</strong> package.
</p>
<div class="sourceCode r"><pre>tt_tbl_colnames(tbl = game_revenue)
#&gt; # A tibble: 11 x 2
#&gt;    .param. value           
#&gt;      &lt;int&gt; &lt;chr&gt;           
#&gt;  1       1 player_id       
#&gt;  2       2 session_id      
#&gt;  3       3 session_start   
#&gt;  4       4 time            
#&gt;  5       5 item_type       
#&gt;  6       6 item_name       
#&gt;  7       7 item_revenue    
#&gt;  8       8 session_duration
#&gt;  9       9 start_day       
#&gt; 10      10 acquisition     
#&gt; 11      11 country
</pre></div>
<p>This output table is useful when you want to validate the column names of the
table. Here, we check that <code>game_revenue</code> table, included in the
<strong>pointblank</strong> package, has certain column names present with
<code><a href="#topic+test_col_vals_make_subset">test_col_vals_make_subset()</a></code>.
</p>
<div class="sourceCode r"><pre>tt_tbl_colnames(tbl = game_revenue) %&gt;%
  test_col_vals_make_subset(
    columns = value,
    set = c("acquisition", "country")
  )
#&gt; [1] TRUE
</pre></div>
<p>We can check to see whether the column names in the <code>specifications</code> table
are all less than <code>15</code> characters in length. For this, we would use the
combination of <code>tt_tbl_colnames()</code>, then <code><a href="#topic+tt_string_info">tt_string_info()</a></code>, and finally
<code><a href="#topic+test_col_vals_lt">test_col_vals_lt()</a></code> to perform the test.
</p>
<div class="sourceCode r"><pre>specifications %&gt;%
  tt_tbl_colnames() %&gt;%
  tt_string_info() %&gt;%
  test_col_vals_lt(
    columns = value,
    value = 15
  )
#&gt; [1] FALSE
</pre></div>
<p>This returned <code>FALSE</code> and this is because the column name
<code>credit_card_numbers</code> is 16 characters long.
</p>


<h3>Function ID</h3>

<p>12-4
</p>


<h3>See Also</h3>

<p>Other Table Transformers: 
<code><a href="#topic+get_tt_param">get_tt_param</a>()</code>,
<code><a href="#topic+tt_string_info">tt_string_info</a>()</code>,
<code><a href="#topic+tt_summary_stats">tt_summary_stats</a>()</code>,
<code><a href="#topic+tt_tbl_dims">tt_tbl_dims</a>()</code>,
<code><a href="#topic+tt_time_shift">tt_time_shift</a>()</code>,
<code><a href="#topic+tt_time_slice">tt_time_slice</a>()</code>
</p>

<hr>
<h2 id='tt_tbl_dims'>Table Transformer: get the dimensions of a table</h2><span id='topic+tt_tbl_dims'></span>

<h3>Description</h3>

<p>With any table object, you can produce a summary table that contains nothing
more than the table's dimensions: the number of rows and the number of
columns. The output summary table will have two columns and two rows. The
first is the <code>".param."</code> column with the labels <code>"rows"</code> and <code>"columns"</code>; the
second column, <code>"value"</code>, contains the row and column counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tt_tbl_dims(tbl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tt_tbl_dims_+3A_tbl">tbl</code></td>
<td>
<p><em>A data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A table object to be used as input for the transformation. This can be a
data frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> object.
</p>


<h3>Examples</h3>

<p>Get the dimensions of the <code>game_revenue</code> dataset that is included in the
<strong>pointblank</strong> package.
</p>
<div class="sourceCode r"><pre>tt_tbl_dims(tbl = game_revenue)
#&gt; # A tibble: 2 x 2
#&gt;   .param. value
#&gt;   &lt;chr&gt;   &lt;int&gt;
#&gt; 1 rows     2000
#&gt; 2 columns    11
</pre></div>
<p>This output table is useful when a table validation depends on its
dimensions. Here, we check that <code>game_revenue</code> has at least <code>1500</code> rows.
</p>
<div class="sourceCode r"><pre>tt_tbl_dims(tbl = game_revenue) %&gt;%
  dplyr::filter(.param. == "rows") %&gt;%
  test_col_vals_gt(
    columns = value,
    value = 1500
  )
#&gt; [1] TRUE
</pre></div>
<p>We can check <code>small_table</code> to ensure that number of columns is less than
<code>10</code>.
</p>
<div class="sourceCode r"><pre>tt_tbl_dims(tbl = small_table) %&gt;%
  dplyr::filter(.param. == "columns") %&gt;%
  test_col_vals_lt(
    columns = value,
    value = 10
  )
#&gt; [1] TRUE
</pre></div>


<h3>Function ID</h3>

<p>12-3
</p>


<h3>See Also</h3>

<p>Other Table Transformers: 
<code><a href="#topic+get_tt_param">get_tt_param</a>()</code>,
<code><a href="#topic+tt_string_info">tt_string_info</a>()</code>,
<code><a href="#topic+tt_summary_stats">tt_summary_stats</a>()</code>,
<code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames</a>()</code>,
<code><a href="#topic+tt_time_shift">tt_time_shift</a>()</code>,
<code><a href="#topic+tt_time_slice">tt_time_slice</a>()</code>
</p>

<hr>
<h2 id='tt_time_shift'>Table Transformer: shift the times of a table</h2><span id='topic+tt_time_shift'></span>

<h3>Description</h3>

<p>With any table object containing date or date-time columns, these values can
be precisely shifted with <code>tt_time_shift()</code> and specification of the time
shift. We can either provide a string with the time shift components and the
shift direction (like <code>"-4y 10d"</code>) or a <code>difftime</code> object (which can be
created via <strong>lubridate</strong> expressions or by using the <code><a href="base.html#topic+difftime">base::difftime()</a></code>
function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tt_time_shift(tbl, time_shift = "0y 0m 0d 0H 0M 0S")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tt_time_shift_+3A_tbl">tbl</code></td>
<td>
<p><em>A data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A table object to be used as input for the transformation. This can be a
data frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object.</p>
</td></tr>
<tr><td><code id="tt_time_shift_+3A_time_shift">time_shift</code></td>
<td>
<p><em>Time-shift specification</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>"0y 0m 0d 0H 0M 0S"</code>
</p>
<p>Either a character-based representation that specifies the time difference
by which all time values in time-based columns will be shifted, or, a
<code>difftime</code> object. The character string is constructed in the format
<code>"0y 0m 0d 0H 0M 0S"</code> and individual time components can be omitted (i.e.,
<code>"1y 5d"</code> is a valid specification of shifting time values ahead one year
and five days). Adding a <code>"-"</code> at the beginning of the string (e.g.,
<code>"-2y"</code>) will shift time values back.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>time_shift</code> specification cannot have a higher time granularity than the
least granular time column in the input table. Put in simpler terms, if there
are any date-based based columns (or just a single date-based column) then
the time shifting can only be in terms of years, months, and days. Using a
<code>time_shift</code> specification of <code>"20d 6H"</code> in the presence of any dates will
result in a truncation to <code>"20d"</code>. Similarly, a <code>difftime</code> object will be
altered in the same circumstances, however, the object will resolved to an
exact number of days through rounding.
</p>


<h3>Value</h3>

<p>A data frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object
depending on what was provided as <code>tbl</code>.
</p>


<h3>Examples</h3>

<p>Let's use the <code>game_revenue</code> dataset, included in the <strong>pointblank</strong> package,
as the input table for the first demo. It has entries in the first 21 days of
2015 and we'll move all of the date and date-time values to the beginning of
2021 with the <code>tt_time_shift()</code> function and the <code>"6y"</code> <code>time_shift</code>
specification.
</p>
<div class="sourceCode r"><pre>tt_time_shift(
  tbl = game_revenue,
  time_shift = "6y"
)
#&gt; # A tibble: 2,000 x 11
#&gt;    player_id       session_id  session_start       time                item_type
#&gt;    &lt;chr&gt;           &lt;chr&gt;       &lt;dttm&gt;              &lt;dttm&gt;              &lt;chr&gt;    
#&gt;  1 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 01:31:03 2021-01-01 01:31:27 iap      
#&gt;  2 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 01:31:03 2021-01-01 01:36:57 iap      
#&gt;  3 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 01:31:03 2021-01-01 01:37:45 iap      
#&gt;  4 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 01:31:03 2021-01-01 01:42:33 ad       
#&gt;  5 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 11:55:20 ad       
#&gt;  6 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 12:08:56 ad       
#&gt;  7 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 12:14:08 ad       
#&gt;  8 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 12:21:44 ad       
#&gt;  9 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 12:24:20 ad       
#&gt; 10 FXWUORGYNJAE271 FXWUORGYNJ~ 2021-01-01 15:17:18 2021-01-01 15:19:36 ad       
#&gt; # i 1,990 more rows
#&gt; # i 6 more variables: item_name &lt;chr&gt;, item_revenue &lt;dbl&gt;,
#&gt; #   session_duration &lt;dbl&gt;, start_day &lt;date&gt;, acquisition &lt;chr&gt;, country &lt;chr&gt;
</pre></div>
<p>Keeping only the <code>date_time</code> and <code>a</code>-<code>f</code> columns of <code>small_table</code>, also
included in the package, shift the times back 2 days and 12 hours with the
<code>"-2d 12H"</code> specification.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  dplyr::select(-date) %&gt;%
  tt_time_shift("-2d 12H")
#&gt; # A tibble: 13 x 7
#&gt;    date_time               a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-01 23:00:00     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-01 12:32:00     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-03 01:32:00     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-04 05:23:00     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-07 00:36:00     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-08 18:15:00     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-13 06:46:00     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-14 23:27:00     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-24 08:07:00     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-25 14:51:00     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-27 23:23:00     1 3-dka-303    NA  2230. TRUE  high
</pre></div>


<h3>Function ID</h3>

<p>12-5
</p>


<h3>See Also</h3>

<p>Other Table Transformers: 
<code><a href="#topic+get_tt_param">get_tt_param</a>()</code>,
<code><a href="#topic+tt_string_info">tt_string_info</a>()</code>,
<code><a href="#topic+tt_summary_stats">tt_summary_stats</a>()</code>,
<code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames</a>()</code>,
<code><a href="#topic+tt_tbl_dims">tt_tbl_dims</a>()</code>,
<code><a href="#topic+tt_time_slice">tt_time_slice</a>()</code>
</p>

<hr>
<h2 id='tt_time_slice'>Table Transformer: slice a table with a slice point on a time column</h2><span id='topic+tt_time_slice'></span>

<h3>Description</h3>

<p>With any table object containing date, date-time columns, or a mixture
thereof, any one of those columns can be used to effectively slice the data
table in two with a <code>slice_point</code>: and you get to choose which of those
slices you want to keep. The slice point can be defined in several ways. One
method involves using a decimal value between <code>0</code> and <code>1</code>, which defines the
slice point as the time instant somewhere between the earliest time value (at
<code>0</code>) and the latest time value (at <code>1</code>). Another way of defining the slice
point is by supplying a time value, and the following input types are
accepted: (1) an ISO 8601 formatted time string (as a date or a date-time),
(2) a <code>POSIXct</code> time, or (3) a <code>Date</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tt_time_slice(
  tbl,
  time_column = NULL,
  slice_point = 0,
  keep = c("left", "right"),
  arrange = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tt_time_slice_+3A_tbl">tbl</code></td>
<td>
<p><em>A data table</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;tbl_*&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A table object to be used as input for the transformation. This can be a
data frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object.</p>
</td></tr>
<tr><td><code id="tt_time_slice_+3A_time_column">time_column</code></td>
<td>
<p><em>Column with time data</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The time-based column that will be used as a basis for the slicing. If no
time column is provided then the first one found will be used.</p>
</td></tr>
<tr><td><code id="tt_time_slice_+3A_slice_point">slice_point</code></td>
<td>
<p><code style="white-space: pre;">&#8288;scalar&lt;numeric|character|POSIXct|Date&gt;&#8288;</code> // <em>default:</em> <code>0</code>
</p>
<p>The location on the <code>time_column</code> where the slicing will occur. This can
either be a decimal value from <code>0</code> to <code>1</code>, an ISO 8601 formatted time
string (as a date or a date-time), a <code>POSIXct</code> time, or a <code>Date</code> object.</p>
</td></tr>
<tr><td><code id="tt_time_slice_+3A_keep">keep</code></td>
<td>
<p><em>Data slice to keep</em>
</p>
<p><code style="white-space: pre;">&#8288;singl-kw:[left|right]&#8288;</code> // <em>default:</em> <code>"left"</code>
</p>
<p>Which slice should be kept? The <code>"left"</code> side (the default) contains data
rows that are earlier than the <code>slice_point</code> and the <code>"right"</code> side will
have rows that are later.</p>
</td></tr>
<tr><td><code id="tt_time_slice_+3A_arrange">arrange</code></td>
<td>
<p><em>Arrange data slice by the time data?</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the slice be arranged by the <code>time_column</code>? This may be useful if
the input <code>tbl</code> isn't ordered by the <code>time_column</code>. By default, this is
<code>FALSE</code> and the original ordering is retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is the option to <code>arrange</code> the table by the date or date-time values in
the <code>time_column</code>. This ordering is always done in an ascending manner. Any
<code>NA</code>/<code>NULL</code> values in the <code>time_column</code> will result in the corresponding rows
can being removed (no matter which slice is retained).
</p>


<h3>Value</h3>

<p>A data frame, a tibble, a <code>tbl_dbi</code> object, or a <code>tbl_spark</code> object
depending on what was provided as <code>tbl</code>.
</p>


<h3>Examples</h3>

<p>Let's use the <code>game_revenue</code> dataset, included in the <strong>pointblank</strong> package,
as the input table for the first demo. It has entries in the first 21 days of
2015 and we'll elect to get all of the records where the <code>time</code> values are
strictly for the first 15 days of 2015. The <code>keep</code> argument has a default of
<code>"left"</code> so all rows where the <code>time</code> column is less than
<code>"2015-01-16 00:00:00"</code> will be kept.
</p>
<div class="sourceCode r"><pre>tt_time_slice(
  tbl = game_revenue,
  time_column = "time",
  slice_point = "2015-01-16"
)
#&gt; # A tibble: 1,208 x 11
#&gt;    player_id       session_id  session_start       time                item_type
#&gt;    &lt;chr&gt;           &lt;chr&gt;       &lt;dttm&gt;              &lt;dttm&gt;              &lt;chr&gt;    
#&gt;  1 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:31:27 iap      
#&gt;  2 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:36:57 iap      
#&gt;  3 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:37:45 iap      
#&gt;  4 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:42:33 ad       
#&gt;  5 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 11:55:20 ad       
#&gt;  6 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:08:56 ad       
#&gt;  7 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:14:08 ad       
#&gt;  8 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:21:44 ad       
#&gt;  9 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:24:20 ad       
#&gt; 10 FXWUORGYNJAE271 FXWUORGYNJ~ 2015-01-01 15:17:18 2015-01-01 15:19:36 ad       
#&gt; # i 1,198 more rows
#&gt; # i 6 more variables: item_name &lt;chr&gt;, item_revenue &lt;dbl&gt;,
#&gt; #   session_duration &lt;dbl&gt;, start_day &lt;date&gt;, acquisition &lt;chr&gt;, country &lt;chr&gt;
</pre></div>
<p>Omit the first 25% of records from <code>small_table</code>, also included in the
package, with a fractional <code>slice_point</code> of <code>0.25</code> on the basis of a timeline
that begins at <code style="white-space: pre;">&#8288;2016-01-04 11:00:00&#8288;</code> and ends at <code style="white-space: pre;">&#8288;2016-01-30 11:23:00&#8288;</code>.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  tt_time_slice(
    slice_point = 0.25,
    keep = "right"
  )
#&gt; # A tibble: 8 x 8
#&gt;   date_time           date           a b             c     d e     f    
#&gt;   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt; 1 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4 3291. TRUE  mid  
#&gt; 2 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high 
#&gt; 3 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2 1036. FALSE low  
#&gt; 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high 
#&gt; 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high 
#&gt; 6 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7  834. TRUE  low  
#&gt; 7 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8  108. FALSE low  
#&gt; 8 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high
</pre></div>


<h3>Function ID</h3>

<p>12-6
</p>


<h3>See Also</h3>

<p>Other Table Transformers: 
<code><a href="#topic+get_tt_param">get_tt_param</a>()</code>,
<code><a href="#topic+tt_string_info">tt_string_info</a>()</code>,
<code><a href="#topic+tt_summary_stats">tt_summary_stats</a>()</code>,
<code><a href="#topic+tt_tbl_colnames">tt_tbl_colnames</a>()</code>,
<code><a href="#topic+tt_tbl_dims">tt_tbl_dims</a>()</code>,
<code><a href="#topic+tt_time_shift">tt_time_shift</a>()</code>
</p>

<hr>
<h2 id='validate_rmd'>Perform <strong>pointblank</strong> validation testing within R Markdown documents</h2><span id='topic+validate_rmd'></span>

<h3>Description</h3>

<p>The <code>validate_rmd()</code> function sets up a framework for validation testing
within specialized validation code chunks inside an R Markdown document. To
enable this functionality, <code>validate_rmd()</code> should be called early within an
R Markdown document code chunk (preferably in the <code>setup</code> chunk) to signal
that validation should occur within specific code chunks. The validation code
chunks require the <code>validate = TRUE</code> option to be set. Using <strong>pointblank</strong>
validation functions on data in these marked code chunks will flag overall
failure if the stop threshold is exceeded anywhere. All errors are reported
in the validation code chunk after rendering the document to HTML, where a
centered status button either indicates success or the number of overall
failures. Clicking the button reveals the otherwise hidden validation
statements and their error messages (if any).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_rmd(summary = TRUE, log_to_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_rmd_+3A_summary">summary</code></td>
<td>
<p><em>Include a validation summary</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>If <code>TRUE</code> then there will be a leading summary of all validations in the
rendered R Markdown document. With <code>FALSE</code>, this element is not shown.</p>
</td></tr>
<tr><td><code id="validate_rmd_+3A_log_to_file">log_to_file</code></td>
<td>
<p><em>Log validation results to a file</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical|character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An option to log errors to a text file. By default, no logging is done but
<code>TRUE</code> will write log entries to <code>"validation_errors.log"</code> in the working
directory. To both enable logging and to specify a file name, include a
path to a log file of the desired name.</p>
</td></tr>
</table>


<h3>Function ID</h3>

<p>1-4
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code><a href="#topic+action_levels">action_levels</a>()</code>,
<code><a href="#topic+create_agent">create_agent</a>()</code>,
<code><a href="#topic+create_informant">create_informant</a>()</code>,
<code><a href="#topic+db_tbl">db_tbl</a>()</code>,
<code><a href="#topic+draft_validation">draft_validation</a>()</code>,
<code><a href="#topic+file_tbl">file_tbl</a>()</code>,
<code><a href="#topic+scan_data">scan_data</a>()</code>,
<code><a href="#topic+tbl_get">tbl_get</a>()</code>,
<code><a href="#topic+tbl_source">tbl_source</a>()</code>,
<code><a href="#topic+tbl_store">tbl_store</a>()</code>
</p>

<hr>
<h2 id='write_testthat_file'>Transform a <strong>pointblank</strong> agent to a <strong>testthat</strong> test file</h2><span id='topic+write_testthat_file'></span>

<h3>Description</h3>

<p>With a <strong>pointblank</strong> <em>agent</em>, we can write a <strong>testthat</strong> test file and opt
to place it in the <code>testthat/tests</code> if it is available in the project path
(we can specify an alternate path as well). This works by transforming the
validation steps to a series of <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> calls inside individual
<code><a href="testthat.html#topic+test_that">testthat::test_that()</a></code> statements.
</p>
<p>A major requirement for using <code>write_testthat_file()</code> on an agent is the
presence of an expression that can retrieve the target table. Typically, we
might supply a table-prep formula, which is a formula that can be invoked to
obtain the target table (e.g., <code>tbl = ~ pointblank::small_table</code>). This
user-supplied statement will be used by <code>write_testthat_file()</code> to generate a
table-loading statement at the top of the new <strong>testthat</strong> test file so that
the target table is available for each of the <code><a href="testthat.html#topic+test_that">testthat::test_that()</a></code>
statements that follow. If an <em>agent</em> was not created using a table-prep
formula set for the <code>tbl</code>, it can be modified via the <code><a href="#topic+set_tbl">set_tbl()</a></code> function.
</p>
<p>Thresholds will be obtained from those applied for the <code>stop</code> state. This can
be set up for a <strong>pointblank</strong> <em>agent</em> by passing an <code>action_levels</code> object
to the <code>actions</code> argument of <code><a href="#topic+create_agent">create_agent()</a></code> or the same argument of any
included validation function. If <code>stop</code> thresholds are not available, then a
threshold value of <code>1</code> will be used for each generated <code style="white-space: pre;">&#8288;expect_*()&#8288;</code> statement
in the resulting <strong>testthat</strong> test file.
</p>
<p>There is no requirement that the <strong>agent</strong> first undergo interrogation with
<code><a href="#topic+interrogate">interrogate()</a></code>. However, it may be useful as a dry run to interactively
perform an interrogation on the target data before generating the
<strong>testthat</strong> test file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_testthat_file(
  agent,
  name = NULL,
  path = NULL,
  overwrite = FALSE,
  skips = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_testthat_file_+3A_agent">agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">&#8288;obj:&lt;ptblank_agent&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code><a href="#topic+create_agent">create_agent()</a></code> function.</p>
</td></tr>
<tr><td><code id="write_testthat_file_+3A_name">name</code></td>
<td>
<p><em>Name for generated testthat file</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional name for for the <strong>testhat</strong> test file. This should be a name
without extension and without the leading <code>"test-"</code> text. If nothing is
supplied, the name will be derived from the <code>tbl_name</code> in the agent. If
that's not present, a generic name will be used.</p>
</td></tr>
<tr><td><code id="write_testthat_file_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A path can be specified here if there shouldn't be an attempt to place the
file in <code>testthat/tests</code>.</p>
</td></tr>
<tr><td><code id="write_testthat_file_+3A_overwrite">overwrite</code></td>
<td>
<p><em>Overwrite a previous file of the same name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should a <strong>testthat</strong> file of the same name be overwritten?</p>
</td></tr>
<tr><td><code id="write_testthat_file_+3A_skips">skips</code></td>
<td>
<p><em>Test skipping</em>
</p>
<p><code style="white-space: pre;">&#8288;vector&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>This is an optional vector of test-skipping keywords modeled after the
<strong>testthat</strong> <code style="white-space: pre;">&#8288;skip_on_*()&#8288;</code> functions. The following keywords can be used to
include <code style="white-space: pre;">&#8288;skip_on_*()&#8288;</code> statements: <code>"cran"</code> (<code><a href="testthat.html#topic+skip">testthat::skip_on_cran()</a></code>),
<code>"travis"</code> (<code><a href="testthat.html#topic+skip_on_travis">testthat::skip_on_travis()</a></code>), <code>"appveyor"</code>
(<code><a href="testthat.html#topic+skip_on_travis">testthat::skip_on_appveyor()</a></code>), <code>"ci"</code> (<code><a href="testthat.html#topic+skip">testthat::skip_on_ci()</a></code>),
<code>"covr"</code> (<code><a href="testthat.html#topic+skip">testthat::skip_on_covr()</a></code>), <code>"bioc"</code>
(<code><a href="testthat.html#topic+skip">testthat::skip_on_bioc()</a></code>). There are keywords for skipping tests on
certain operating systems and all of them will insert a specific
<code><a href="testthat.html#topic+skip">testthat::skip_on_os()</a></code> call. These are <code>"windows"</code>
(<code>skip_on_os("windows")</code>), <code>"mac"</code> (<code>skip_on_os("mac")</code>), <code>"linux"</code>
(<code>skip_on_os("linux")</code>), and <code>"solaris"</code> (<code>skip_on_os("solaris")</code>). These
calls will be placed at the top of the generated <strong>testthat</strong> test file.</p>
</td></tr>
<tr><td><code id="write_testthat_file_+3A_quiet">quiet</code></td>
<td>
<p><em>Inform (or not) upon file writing</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the function <em>not</em> inform when the file is written?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests for inactive validation steps will be skipped with a clear message
indicating that the reason for skipping was due to the test not being active.
Any inactive validation steps can be forced into an active state by using the
<code><a href="#topic+activate_steps">activate_steps()</a></code> on an <em>agent</em> (the opposite is possible with the
<code><a href="#topic+deactivate_steps">deactivate_steps()</a></code> function).
</p>
<p>The <strong>testthat</strong> package comes with a series of <code style="white-space: pre;">&#8288;skip_on_*()&#8288;</code> functions which
conveniently cause the test file to be skipped entirely if certain conditions
are met. We can quickly set any number of these at the top of the
<strong>testthat</strong> test file by supplying keywords as a vector to the <code>skips</code>
option of <code>write_testthat_file()</code>. For instance, setting
<code style="white-space: pre;">&#8288;skips = c("cran", "windows)&#8288;</code> will add the <strong>testthat</strong> <code>skip_on_cran()</code> and
<code>skip_on_os("windows")</code> statements, meaning that the generated test file
won't run on a CRAN system or if the system OS is Windows.
</p>
<p>Here is an example of <strong>testthat</strong> test file output (<code>"test-small_table.R"</code>):
</p>
<div class="sourceCode r"><pre># Generated by pointblank

tbl &lt;- small_table

test_that("column `date_time` exists", {
  
  expect_col_exists(
    tbl,
    columns = date_time,
    threshold = 1
  ) 
})

test_that("values in `c` should be &lt;= `5`", {
  
  expect_col_vals_lte(
    tbl,
    columns = c,
    value = 5,
    threshold = 0.25
  ) 
})

</pre></div>
<p>This was generated by the following set of R statements:
</p>
<div class="sourceCode r"><pre>library(pointblank)

agent &lt;- 
  create_agent(
    tbl = ~ small_table,
    actions = action_levels(stop_at = 0.25)
  ) %&gt;%
  col_exists(date_time) %&gt;%
  col_vals_lte(c, value = 5)
  
write_testthat_file(
  agent = agent,
  name = "small_table",
  path = "."
)
</pre></div>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if the <strong>testthat</strong> file has been written.
</p>


<h3>Examples</h3>



<h4>Creating a <strong>testthat</strong> file from an <em>agent</em></h4>

<p>Let's walk through a data quality analysis of an extremely small table. It's
actually called <code>small_table</code> and we can find it as a dataset in this
package.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>Creating an <code>action_levels</code> object is a common workflow step when creating a
pointblank agent. We designate failure thresholds to the <code>warn</code>, <code>stop</code>, and
<code>notify</code> states using <code>action_levels()</code>.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 0.10,
    stop_at = 0.25,
    notify_at = 0.35
  )
</pre></div>
<p>A pointblank <code>agent</code> object is now created and the <code>al</code> object is provided to
the agent. The static thresholds provided by the <code>al</code> object make reports a
bit more useful after interrogation.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ small_table,
    label = "An example.",
    actions = al
  ) %&gt;%
  col_exists(c(date, date_time)) %&gt;%
  col_vals_regex(
    b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}"
  ) %&gt;%
  col_vals_gt(d, value = 100) %&gt;%
  col_vals_lte(c, value = 5) %&gt;%
  interrogate()
</pre></div>
<p>This agent and all of the checks can be transformed into a testthat file with
<code>write_testthat_file()</code>. The <code>stop</code> thresholds will be ported over to the
<code style="white-space: pre;">&#8288;expect_*()&#8288;</code> functions in the new file.
</p>
<div class="sourceCode r"><pre>write_testthat_file(
  agent = agent,
  name = "small_table",
  path = "."
)
</pre></div>
<p>The above code will generate a file with the name <code>"test-small_table.R"</code>. The
path was specified with <code>"."</code> so the file will be placed in the working
directory. If you'd like to easily add this new file to the <code>tests/testthat</code>
directory then <code>path = NULL</code> (the default) will makes this possible (this is
useful during package development).
</p>
<p>What's in the new file? This:
</p>
<div class="sourceCode r"><pre># Generated by pointblank

tbl &lt;- small_table

test_that("column `date` exists", {
  
  expect_col_exists(
    tbl,
    columns = date,
    threshold = 1
  ) 
})

test_that("column `date_time` exists", {
  
  expect_col_exists(
    tbl,
    columns = date_time,
    threshold = 1
  ) 
})

test_that("values in `b` should match the regular expression: 
`[0-9]-[a-z]{3}-[0-9]{3}`", {
  
  expect_col_vals_regex(
    tbl,
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}",
    threshold = 0.25
  ) 
})

test_that("values in `d` should be &gt; `100`", {
  
  expect_col_vals_gt(
    tbl,
    columns = d,
    value = 100,
    threshold = 0.25
  ) 
})

test_that("values in `c` should be &lt;= `5`", {
  
  expect_col_vals_lte(
    tbl,
    columns = c,
    value = 5,
    threshold = 0.25
  ) 
})
</pre></div>



<h4>Using an <em>agent</em> stored on disk as a YAML file</h4>

<p>An agent on disk as a YAML file can be made into a <strong>testthat</strong> file. The
<code>"agent-small_table.yml"</code> file is available in the <strong>pointblank</strong> package
and the path can be obtained with <code>system.file()</code>.
</p>
<div class="sourceCode r"><pre>yml_file &lt;- 
  system.file(
    "yaml", "agent-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>Writing the <strong>testthat</strong> file into the working directory is much the same as
before but we're reading the agent from disk this time. It's a read and write
combo, really. Again, we are choosing to write the file to the working
directory by using <code>path = "."</code>.
</p>
<div class="sourceCode r"><pre>write_testthat_file(
  agent = yaml_read_agent(yml_file),
  name = "from_agent_yaml",
  path = "."
)
</pre></div>



<h3>Function ID</h3>

<p>8-5
</p>


<h3>See Also</h3>

<p>Other Post-interrogation: 
<code><a href="#topic+all_passed">all_passed</a>()</code>,
<code><a href="#topic+get_agent_x_list">get_agent_x_list</a>()</code>,
<code><a href="#topic+get_data_extracts">get_data_extracts</a>()</code>,
<code><a href="#topic+get_sundered_data">get_sundered_data</a>()</code>
</p>

<hr>
<h2 id='x_read_disk'>Read an <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or table scan from disk</h2><span id='topic+x_read_disk'></span>

<h3>Description</h3>

<p>An <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or table scan that has been written to
disk (with <code><a href="#topic+x_write_disk">x_write_disk()</a></code>) can be read back into memory with the
<code>x_read_disk()</code> function. For an <em>agent</em> or an <em>informant</em> object that has
been generated in this way, it may not have a data table associated with it
(depending on whether the <code>keep_tbl</code> option was <code>TRUE</code> or <code>FALSE</code> when
writing to disk) but it should still be able to produce reporting (by
printing the <em>agent</em> or <em>informant</em> to the console or using
<code><a href="#topic+get_agent_report">get_agent_report()</a></code>/<code><a href="#topic+get_informant_report">get_informant_report()</a></code>). An <em>agent</em> will return an
x-list with <code><a href="#topic+get_agent_x_list">get_agent_x_list()</a></code> and yield any available data extracts with
<code><a href="#topic+get_data_extracts">get_data_extracts()</a></code>. Furthermore, all of an <em>agent</em>'s validation steps will
still be present (along with results from the last interrogation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_read_disk(filename, path = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x_read_disk_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of a file that was previously written by <code><a href="#topic+x_write_disk">x_write_disk()</a></code>.</p>
</td></tr>
<tr><td><code id="x_read_disk_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to the file (combined with <code>filename</code>).</p>
</td></tr>
<tr><td><code id="x_read_disk_+3A_quiet">quiet</code></td>
<td>
<p><em>Inform (or not) upon file writing</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the function <em>not</em> inform when the file is written?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Should a written-to-disk <em>agent</em> or <em>informant</em> possess a table-prep formula
or a specific in-memory tablewe could use the <code><a href="#topic+interrogate">interrogate()</a></code> or
<code><a href="#topic+incorporate">incorporate()</a></code> function again. For a <em>data quality reporting</em> workflow, it
is useful to <code><a href="#topic+interrogate">interrogate()</a></code> target tables that evolve over time. While the
same validation steps will be used, more can be added before calling
<code><a href="#topic+interrogate">interrogate()</a></code>. For an <em>information management</em> workflow with an <em>informant</em>
object, using <code><a href="#topic+incorporate">incorporate()</a></code> will update aspects of the reporting such as
table dimensions, and info snippets/text will be regenerated.
</p>


<h3>Value</h3>

<p>Either a <code>ptblank_agent</code>, <code>ptblank_informant</code>, or a
<code>ptblank_tbl_scan</code> object.
</p>


<h3>Examples</h3>



<h4>A: Reading an agent from disk</h4>

<p>The process of developing an agent and writing it to disk with the
<code><a href="#topic+x_write_disk">x_write_disk()</a></code> function is explained in that function's documentation.
Suppose we have such a written file that's named <code>"agent-small_table.rds"</code>,
we could read that to a new agent object with <code>x_read_disk()</code>.
</p>
<div class="sourceCode r"><pre>agent &lt;- x_read_disk("agent-small_table.rds")
</pre></div>



<h4>B: Reading an informant from disk</h4>

<p>If there is an informant written to disk via <code><a href="#topic+x_write_disk">x_write_disk()</a></code> and it's named
<code>"informant-small_table.rds"</code>. We could read that to a new informant object
with <code>x_read_disk()</code>.
</p>
<div class="sourceCode r"><pre>informant &lt;- x_read_disk("informant-small_table.rds")
</pre></div>



<h4>C: Reading a multiagent from disk</h4>

<p>The process of creating a multiagent and writing it to disk with the
<code><a href="#topic+x_write_disk">x_write_disk()</a></code> function is shown in that function's documentation. Should
we have such a written file called <code>"multiagent-small_table.rds"</code>, we could
read that to a new multiagent object with <code>x_read_disk()</code>.
</p>
<div class="sourceCode r"><pre>multiagent &lt;- x_read_disk("multiagent-small_table.rds")
</pre></div>



<h4>D: Reading a table scan from disk</h4>

<p>If there is a table scan written to disk via <code><a href="#topic+x_write_disk">x_write_disk()</a></code> and it's named
<code>"tbl_scan-storms.rds"</code>, we could read it back into R with <code>x_read_disk()</code>.
</p>
<div class="sourceCode r"><pre>tbl_scan &lt;- x_read_disk("tbl_scan-storms.rds")
</pre></div>



<h3>Function ID</h3>

<p>9-2
</p>


<h3>See Also</h3>

<p>Other Object Ops: 
<code><a href="#topic+activate_steps">activate_steps</a>()</code>,
<code><a href="#topic+deactivate_steps">deactivate_steps</a>()</code>,
<code><a href="#topic+export_report">export_report</a>()</code>,
<code><a href="#topic+remove_steps">remove_steps</a>()</code>,
<code><a href="#topic+set_tbl">set_tbl</a>()</code>,
<code><a href="#topic+x_write_disk">x_write_disk</a>()</code>
</p>

<hr>
<h2 id='x_write_disk'>Write an <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or table scan to disk</h2><span id='topic+x_write_disk'></span>

<h3>Description</h3>

<p>Writing an <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or even a table scan to disk
with <code>x_write_disk()</code> can be useful for keeping data validation intel or
table information close at hand for later retrieval (with <code><a href="#topic+x_read_disk">x_read_disk()</a></code>).
By default, any data table that the <em>agent</em> or <em>informant</em> may have held
before being committed to disk will be expunged (not applicable to any table
scan since they never hold a table object). This behavior can be changed by
setting <code>keep_tbl</code> to <code>TRUE</code> but this only works in the case where the table
is not of the <code>tbl_dbi</code> or the <code>tbl_spark</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_write_disk(
  x,
  filename,
  path = NULL,
  keep_tbl = FALSE,
  keep_extracts = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x_write_disk_+3A_x">x</code></td>
<td>
<p><em>One of several types of objects</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;object&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>An <em>agent</em> object of class <code>ptblank_agent</code>, an <em>informant</em> of class
<code>ptblank_informant</code>, or an table scan of class <code>ptblank_tbl_scan</code>.</p>
</td></tr>
<tr><td><code id="x_write_disk_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The filename to create on disk for the <code>agent</code>, <code>informant</code>, or table scan.</p>
</td></tr>
<tr><td><code id="x_write_disk_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to which the file should be saved (this is automatically
combined with <code>filename</code>).</p>
</td></tr>
<tr><td><code id="x_write_disk_+3A_keep_tbl">keep_tbl</code></td>
<td>
<p><em>Keep data table inside object</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>An option to keep a data table that is associated with the
<em>agent</em> or <em>informant</em> (which is the case when the <em>agent</em>, for example, is
created using <code style="white-space: pre;">&#8288;create_agent(tbl = &lt;data table, ...)&#8288;</code>). The default is
<code>FALSE</code> where the data table is removed before writing to disk. For
database tables of the class <code>tbl_dbi</code> and for Spark DataFrames
(<code>tbl_spark</code>) the table is always removed (even if <code>keep_tbl</code> is set to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="x_write_disk_+3A_keep_extracts">keep_extracts</code></td>
<td>
<p><em>Keep data extracts inside object</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>An option to keep any collected extract data for failing rows. Only applies
to <em>agent</em> objects. By default, this is <code>FALSE</code> (i.e., extract data is
removed).</p>
</td></tr>
<tr><td><code id="x_write_disk_+3A_quiet">quiet</code></td>
<td>
<p><em>Inform (or not) upon file writing</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the function <em>not</em> inform when the file is written?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to set up a table-prep formula so that the <em>agent</em> and
<em>informant</em> can access refreshed data after being read from disk through
<code><a href="#topic+x_read_disk">x_read_disk()</a></code>. This can be done initially with the <code>tbl</code> argument of
<code><a href="#topic+create_agent">create_agent()</a></code>/<code><a href="#topic+create_informant">create_informant()</a></code> by passing in a table-prep formula or a
function that can obtain the target table when invoked. Alternatively, we can
use the <code><a href="#topic+set_tbl">set_tbl()</a></code> with a similarly crafted <code>tbl</code> expression to ensure that
an <em>agent</em> or <em>informant</em> can retrieve a table at a later time.
</p>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if the file has been written.
</p>


<h3>Examples</h3>



<h4>A: Writing an <code>agent</code> to disk</h4>

<p>Let's go through the process of (1) developing an agent with a validation
plan (to be used for the data quality analysis of the <code><a href="#topic+small_table">small_table</a></code>
dataset), (2) interrogating the agent with the <code><a href="#topic+interrogate">interrogate()</a></code> function, and
(3) writing the agent and all its intel to a file.
</p>
<p>Creating an <code>action_levels</code> object is a common workflow step when creating a
pointblank agent. We designate failure thresholds to the <code>warn</code>, <code>stop</code>, and
<code>notify</code> states using <code><a href="#topic+action_levels">action_levels()</a></code>.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 0.10,
    stop_at = 0.25,
    notify_at = 0.35
  )
</pre></div>
<p>Now, let's create a pointblank <code>agent</code> object and give it the <code>al</code> object
(which serves as a default for all validation steps which can be overridden).
The data will be referenced in the <code>tbl</code> argument with a leading <code>~</code>.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "`x_write_disk()`",
    actions = al
  )
</pre></div>
<p>Then, as with any <code>agent</code> object, we can add steps to the validation plan by
using as many validation functions as we want. After that, use
<code><a href="#topic+interrogate">interrogate()</a></code>.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  agent %&gt;% 
  col_exists(columns = c(date, date_time)) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}"
  ) %&gt;%
  rows_distinct() %&gt;%
  col_vals_gt(columns = d, value = 100) %&gt;%
  col_vals_lte(columns = c, value = 5) %&gt;%
  interrogate()
</pre></div>
<p>The <code>agent</code> can be written to a file with the <code>x_write_disk()</code> function.
</p>
<div class="sourceCode r"><pre>x_write_disk(
  agent,
  filename = "agent-small_table.rds"
)
</pre></div>
<p>We can read the file back as an agent with the <code><a href="#topic+x_read_disk">x_read_disk()</a></code> function and
we'll get all of the intel along with the restored agent.
</p>
<p>If you're consistently writing agent reports when periodically checking data,
we could make use of the <code><a href="#topic+affix_date">affix_date()</a></code> or <code><a href="#topic+affix_datetime">affix_datetime()</a></code> depending on
the granularity you need. Here's an example that writes the file with the
format: <code>"&lt;filename&gt;-YYYY-mm-dd_HH-MM-SS.rds"</code>.
</p>
<div class="sourceCode r"><pre>x_write_disk(
  agent,
  filename = affix_datetime(
    "agent-small_table.rds"
  )
)
</pre></div>



<h4>B: Writing an <code>informant</code> to disk</h4>

<p>Let's go through the process of (1) creating an informant object that
minimally describes the <code><a href="#topic+small_table">small_table</a></code> dataset, (2) ensuring that data is
captured from the target table using the <code><a href="#topic+incorporate">incorporate()</a></code> function, and (3)
writing the informant to a file.
</p>
<p>Create a pointblank <code>informant</code> object with <code><a href="#topic+create_informant">create_informant()</a></code> and the
<code><a href="#topic+small_table">small_table</a></code> dataset. Use <code><a href="#topic+incorporate">incorporate()</a></code> so that info snippets are
integrated into the text.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "`x_write_disk()`"
  ) %&gt;%
  info_snippet(
    snippet_name = "high_a",
    fn = snip_highest(column = "a")
  ) %&gt;%
  info_snippet(
    snippet_name = "low_a",
    fn = snip_lowest(column = "a")
  ) %&gt;%
  info_columns(
    columns = a,
    info = "From {low_a} to {high_a}."
  ) %&gt;%
  info_columns(
    columns = starts_with("date"),
    info = "Time-based values."
  ) %&gt;%
  info_columns(
    columns = date,
    info = "The date part of `date_time`."
  ) %&gt;%
  incorporate()
</pre></div>
<p>The <code>informant</code> can be written to a file with <code>x_write_disk()</code>. Let's do this
with <code><a href="#topic+affix_date">affix_date()</a></code> so that the filename has a datestamp.
</p>
<div class="sourceCode r"><pre>x_write_disk(
  informant,
  filename = affix_date(
    "informant-small_table.rds"
  )
)
</pre></div>
<p>We can read the file back into a new informant object (in the same state as
when it was saved) by using <code><a href="#topic+x_read_disk">x_read_disk()</a></code>.
</p>



<h4>C: Writing a multiagent to disk</h4>

<p>Let's create one more pointblank agent object, provide it with some
validation steps, and <code><a href="#topic+interrogate">interrogate()</a></code>.
</p>
<div class="sourceCode r"><pre>agent_b &lt;-
  create_agent(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "`x_write_disk()`",
    actions = al
  ) %&gt;%
  col_vals_gt(
    columns = b,
    value = g,
    na_pass = TRUE,
    label = "b &gt; g"
  ) %&gt;%
  col_is_character(
    columns = c(b, f),
    label = "Verifying character-type columns" 
  ) %&gt;%
  interrogate()
</pre></div>
<p>Now we can combine the earlier <code>agent</code> object with the newer <code>agent_b</code> to
create a <code>multiagent</code>.
</p>
<div class="sourceCode r"><pre>multiagent &lt;- create_multiagent(agent, agent_b)
</pre></div>
<p>The <code>multiagent</code> can be written to a file with the <code>x_write_disk()</code> function.
</p>
<div class="sourceCode r"><pre>x_write_disk(
  multiagent,
  filename = "multiagent-small_table.rds"
)
</pre></div>
<p>We can read the file back as a multiagent with the <code><a href="#topic+x_read_disk">x_read_disk()</a></code> function
and we'll get all of the constituent agents and their associated intel back
as well.
</p>



<h4>D: Writing a table scan to disk</h4>

<p>We can get a report that describes all of the data in the <code>storms</code> dataset.
</p>
<div class="sourceCode r"><pre>tbl_scan &lt;- scan_data(tbl = dplyr::storms)
</pre></div>
<p>The table scan object can be written to a file with <code>x_write_disk()</code>.
</p>
<div class="sourceCode r"><pre>x_write_disk(
  tbl_scan,
  filename = "tbl_scan-storms.rds"
)
</pre></div>



<h3>Function ID</h3>

<p>9-1
</p>


<h3>See Also</h3>

<p>Other Object Ops: 
<code><a href="#topic+activate_steps">activate_steps</a>()</code>,
<code><a href="#topic+deactivate_steps">deactivate_steps</a>()</code>,
<code><a href="#topic+export_report">export_report</a>()</code>,
<code><a href="#topic+remove_steps">remove_steps</a>()</code>,
<code><a href="#topic+set_tbl">set_tbl</a>()</code>,
<code><a href="#topic+x_read_disk">x_read_disk</a>()</code>
</p>

<hr>
<h2 id='yaml_agent_interrogate'>Get an <em>agent</em> from <strong>pointblank</strong> YAML and <code>interrogate()</code></h2><span id='topic+yaml_agent_interrogate'></span>

<h3>Description</h3>

<p>The <code>yaml_agent_interrogate()</code> function operates much like the
<code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code> function (reading a <strong>pointblank</strong> YAML file and
generating an <em>agent</em> with a validation plan in place). The key difference is
that this function takes things a step further and interrogates the target
table (defined by table-prep formula that is required in the YAML file). The
additional auto-invocation of <code><a href="#topic+interrogate">interrogate()</a></code> uses the default options of
that function. As with <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code> the agent is returned except, this
time, it has intel from the interrogation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_agent_interrogate(filename, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yaml_agent_interrogate_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the YAML file that contains fields related to an <em>agent</em>.</p>
</td></tr>
<tr><td><code id="yaml_agent_interrogate_+3A_path">path</code></td>
<td>
<p>#' @param path <em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to the YAML file (combined with <code>filename</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_agent</code> object.
</p>


<h3>Examples</h3>

<p>There's a YAML file available in the <strong>pointblank</strong> package that's also
called <code>"agent-small_table.yml"</code>. The path for it can be accessed through
<code>system.file()</code>:
</p>
<div class="sourceCode r"><pre>yml_file_path &lt;- 
  system.file(
    "yaml", "agent-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>The YAML file can be read as an agent with a pre-existing validation plan by
using the <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code> function.
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_read_agent(filename = yml_file_path)

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_1.png" alt="This image was generated from the first code example in the `yaml_write()` help file." style="width:100%;">


<p>This particular agent is using <code>~ tbl_source("small_table", "tbl_store.yml")</code>
to source the table-prep from a YAML file that holds a table store (can be
seen using <code>yaml_agent_string(agent = agent)</code>). Let's put that file in the
working directory (the <strong>pointblank</strong> package has the corresponding YAML
file):
</p>
<div class="sourceCode r"><pre>yml_tbl_store_path &lt;-
  system.file(
    "yaml", "tbl_store.yml",
    package = "pointblank"
  )

file.copy(from = yml_tbl_store_path, to = ".")
</pre></div>
<p>As can be seen from the validation report, no interrogation was yet
performed. Saving an agent to YAML will remove any traces of interrogation
data and serve as a plan for a new interrogation on the same target table. We
can either follow this up with with <code><a href="#topic+interrogate">interrogate()</a></code> and get an agent with
intel, or, we can interrogate directly from the YAML file with
<code>yaml_agent_interrogate()</code>:
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_agent_interrogate(filename = yml_file_path)

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_2.png" alt="This image was generated from the second code example in the `yaml_write()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>11-4
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs</a>()</code>,
<code><a href="#topic+yaml_agent_string">yaml_agent_string</a>()</code>,
<code><a href="#topic+yaml_exec">yaml_exec</a>()</code>,
<code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate</a>()</code>,
<code><a href="#topic+yaml_read_agent">yaml_read_agent</a>()</code>,
<code><a href="#topic+yaml_read_informant">yaml_read_informant</a>()</code>,
<code><a href="#topic+yaml_write">yaml_write</a>()</code>
</p>

<hr>
<h2 id='yaml_agent_show_exprs'>Display validation expressions using <strong>pointblank</strong> YAML</h2><span id='topic+yaml_agent_show_exprs'></span>

<h3>Description</h3>

<p>The <code>yaml_agent_show_exprs()</code> function follows the specifications of a
<strong>pointblank</strong> YAML file to generate and show the <strong>pointblank</strong> expressions
for generating the described validation plan. The expressions are shown in
the console, providing an opportunity to copy the statements and extend as
needed. A <strong>pointblank</strong> YAML file can itself be generated by using the
<code><a href="#topic+yaml_write">yaml_write()</a></code> function with a pre-existing <em>agent</em>, or, it can be carefully
written by hand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_agent_show_exprs(filename, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yaml_agent_show_exprs_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the YAML file that contains fields related to an <em>agent</em>.</p>
</td></tr>
<tr><td><code id="yaml_agent_show_exprs_+3A_path">path</code></td>
<td>
<p>#' @param path <em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to the YAML file (combined with <code>filename</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<p>Let's create a validation plan for the data quality analysis of the
<code>small_table</code> dataset. We need an agent and its table-prep formula enables
retrieval of the target table.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "A simple example with the `small_table`.",
    actions = action_levels(
      warn_at = 0.10,
      stop_at = 0.25,
      notify_at = 0.35
    )
  ) %&gt;%
  col_exists(columns = c(date, date_time)) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}"
  ) %&gt;%
  rows_distinct() %&gt;%
  col_vals_gt(columns = d, value = 100) %&gt;%
  col_vals_lte(columns = c, value = 5)
</pre></div>
<p>The agent can be written to a <strong>pointblank</strong> YAML file with <code><a href="#topic+yaml_write">yaml_write()</a></code>.
</p>
<div class="sourceCode r"><pre>yaml_write(
  agent = agent,
  filename = "agent-small_table.yml"
)
</pre></div>
<p>At a later time, the YAML file can be read into a new agent with the
<code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code> function.
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_read_agent(filename = "agent-small_table.yml")

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_agent_show_exprs_1.png" alt="This image was generated from the first code example in the `yaml_agent_show_exprs()` help file." style="width:100%;">


<p>To get a sense of which expressions are being used to generate the new agent,
we can use <code>yaml_agent_show_exprs()</code>.
</p>
<div class="sourceCode r"><pre>yaml_agent_show_exprs(filename = "agent-small_table.yml")
</pre></div>
<div class="sourceCode"><pre>create_agent(
  tbl = ~small_table,
  actions = action_levels(
    warn_at = 0.1,
    stop_at = 0.25,
    notify_at = 0.35
  ),
  tbl_name = "small_table",
  label = "A simple example with the `small_table`."
) %&gt;%
  col_exists(
    columns = c(date, date_time)
  ) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}"
  ) %&gt;%
  rows_distinct() %&gt;%
  col_vals_gt(
    columns = d,
    value = 100
  ) %&gt;%
  col_vals_lte(
    columns = c,
    value = 5
  ) 
</pre></div>


<h3>Function ID</h3>

<p>11-6
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate</a>()</code>,
<code><a href="#topic+yaml_agent_string">yaml_agent_string</a>()</code>,
<code><a href="#topic+yaml_exec">yaml_exec</a>()</code>,
<code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate</a>()</code>,
<code><a href="#topic+yaml_read_agent">yaml_read_agent</a>()</code>,
<code><a href="#topic+yaml_read_informant">yaml_read_informant</a>()</code>,
<code><a href="#topic+yaml_write">yaml_write</a>()</code>
</p>

<hr>
<h2 id='yaml_agent_string'>Display <strong>pointblank</strong> YAML using an agent or a YAML file</h2><span id='topic+yaml_agent_string'></span>

<h3>Description</h3>

<p>With <strong>pointblank</strong> YAML, we can serialize an agent's validation plan (with
<code><a href="#topic+yaml_write">yaml_write()</a></code>), read it back later with a new agent (with
<code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code>), or perform an interrogation on the target data table
directly with the YAML file (with <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>). The
<code>yaml_agent_string()</code> function allows us to inspect the YAML generated by
<code><a href="#topic+yaml_write">yaml_write()</a></code> in the console, giving us a look at the YAML without needing
to open the file directly. Alternatively, we can provide an <em>agent</em> to the
<code>yaml_agent_string()</code> and view the YAML representation of the validation plan
without needing to write the YAML to disk beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_agent_string(agent = NULL, filename = NULL, path = NULL, expanded = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yaml_agent_string_+3A_agent">agent</code></td>
<td>
<p>An <em>agent</em> object of class <code>ptblank_agent</code>. If an object is
provided here, then <code>filename</code> must not be provided.</p>
</td></tr>
<tr><td><code id="yaml_agent_string_+3A_filename">filename</code></td>
<td>
<p>The name of the YAML file that contains fields related to an
<em>agent</em>. If a file name is provided here, then <em>agent</em> object must not be
provided in <code>agent</code>.</p>
</td></tr>
<tr><td><code id="yaml_agent_string_+3A_path">path</code></td>
<td>
<p>An optional path to the YAML file (combined with <code>filename</code>).</p>
</td></tr>
<tr><td><code id="yaml_agent_string_+3A_expanded">expanded</code></td>
<td>
<p>Should the written validation expressions for an <em>agent</em> be
expanded such that <strong>tidyselect</strong> expressions for columns are evaluated,
yielding a validation function per column? By default, this is <code>FALSE</code>
so expressions as written will be retained in the YAML representation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned. Instead, text is printed to the console.
</p>


<h3>Examples</h3>

<p>There's a YAML file available in the <strong>pointblank</strong> package that's called
<code>"agent-small_table.yml"</code>. The path for it can be accessed through
<code>system.file()</code>:
</p>
<div class="sourceCode r"><pre>yml_file_path &lt;- 
  system.file(
    "yaml", "agent-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>We can view the contents of the YAML file in the console with the
<code>yaml_agent_string()</code> function.
</p>
<div class="sourceCode r"><pre>yaml_agent_string(filename = yml_file_path)
</pre></div>
<div class="sourceCode yaml"><pre>type: agent
tbl: ~ tbl_source("small_table", "tbl_store.yml")
tbl_name: small_table
label: A simple example with the `small_table`.
lang: en
locale: en
actions:
  warn_fraction: 0.1
  stop_fraction: 0.25
  notify_fraction: 0.35
steps:
- col_exists:
    columns: vars(date)
- col_exists:
    columns: vars(date_time)
- col_vals_regex:
    columns: vars(b)
    regex: '[0-9]-[a-z]{3}-[0-9]{3}'
- rows_distinct:
    columns: ~
- col_vals_gt:
    columns: vars(d)
    value: 100.0
- col_vals_lte:
    columns: vars(c)
    value: 5.0
</pre></div>
<p>Incidentally, we can also use <code>yaml_agent_string()</code> to print YAML in the
console when supplying an <em>agent object</em> as the input. This can be useful for
previewing YAML output just before writing it to disk with <code><a href="#topic+yaml_write">yaml_write()</a></code>.
</p>


<h3>Function ID</h3>

<p>11-5
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate</a>()</code>,
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs</a>()</code>,
<code><a href="#topic+yaml_exec">yaml_exec</a>()</code>,
<code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate</a>()</code>,
<code><a href="#topic+yaml_read_agent">yaml_read_agent</a>()</code>,
<code><a href="#topic+yaml_read_informant">yaml_read_informant</a>()</code>,
<code><a href="#topic+yaml_write">yaml_write</a>()</code>
</p>

<hr>
<h2 id='yaml_exec'>Execute all agent and informant YAML tasks</h2><span id='topic+yaml_exec'></span>

<h3>Description</h3>

<p>The <code>yaml_exec()</code> function takes all relevant <strong>pointblank</strong> YAML files in a
directory and executes them. Execution involves interrogation of agents for
YAML agents and incorporation of informants for YAML informants. Under the
hood, this uses <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code> and <code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code>
and then <code><a href="#topic+x_write_disk">x_write_disk()</a></code> to save the processed objects to an output
directory. These written artifacts can be read in at any later time with the
<code><a href="#topic+x_read_disk">x_read_disk()</a></code> function or the <code><a href="#topic+read_disk_multiagent">read_disk_multiagent()</a></code> function. This is
useful when data in the target tables are changing and the periodic testing
of such tables is part of a data quality monitoring plan.
</p>
<p>The output RDS files are named according to the object type processed, the
target table, and the date-time of processing. For convenience and
modularity, this setup is ideal when a table store YAML file (typically named
<code>"tbl_store.yml"</code> and produced via the <code><a href="#topic+tbl_store">tbl_store()</a></code> and <code><a href="#topic+yaml_write">yaml_write()</a></code>
workflow) is available in the directory, and when table-prep formulas are
accessed by name through <code><a href="#topic+tbl_source">tbl_source()</a></code>.
</p>
<p>A typical directory of files set up for execution in this way might have the
following contents:
</p>

<ul>
<li><p> a <code>"tbl_store.yml"</code> file for holding table-prep formulas (created with
<code><a href="#topic+tbl_store">tbl_store()</a></code> and written to YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code>)
</p>
</li>
<li><p> one or more YAML <em>agent</em> files to validate tables (ideally using
<code><a href="#topic+tbl_source">tbl_source()</a></code>)
</p>
</li>
<li><p> one or more YAML <em>informant</em> files to provide refreshed metadata on tables
(again, using <code><a href="#topic+tbl_source">tbl_source()</a></code> to reference table preparations is ideal)
</p>
</li>
<li><p> an output folder (default is <code>"output"</code>) to save serialized versions of
processed agents and informants
</p>
</li></ul>

<p>Minimal example files of the aforementioned types can be found in the
<strong>pointblank</strong> package through the following <code>system.file()</code> calls:
</p>

<ul>
<li> <p><code>system.file("yaml", "agent-small_table.yml", package = "pointblank")</code>
</p>
</li>
<li> <p><code>system.file("yaml", "informant-small_table.yml", package = "pointblank")</code>
</p>
</li>
<li> <p><code>system.file("yaml", "tbl_store.yml", package = "pointblank")</code>
</p>
</li></ul>

<p>The directory itself can be accessed using <code>system.file("yaml", package = "pointblank")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_exec(
  path = NULL,
  files = NULL,
  write_to_disk = TRUE,
  output_path = file.path(path, "output"),
  keep_tbl = FALSE,
  keep_extracts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yaml_exec_+3A_path">path</code></td>
<td>
<p>The path that contains the YAML files for agents and informants.</p>
</td></tr>
<tr><td><code id="yaml_exec_+3A_files">files</code></td>
<td>
<p>A vector of YAML files to use in the execution workflow. By
default, <code>yaml_exec()</code> will attempt to process every valid YAML file in
<code>path</code> but supplying a vector here limits the scope to the specified files.</p>
</td></tr>
<tr><td><code id="yaml_exec_+3A_write_to_disk">write_to_disk</code></td>
<td>
<p>Should the execution workflow include a step that writes
output files to disk? This internally calls <code><a href="#topic+x_write_disk">x_write_disk()</a></code> to write RDS
files and uses the base filename of the agent/informant YAML file as part
of the output filename, appending the date-time to the basename.</p>
</td></tr>
<tr><td><code id="yaml_exec_+3A_output_path">output_path</code></td>
<td>
<p>The output path for any generated output files. By
default, this will be a subdirectory of the provided <code>path</code> called
<code>"output"</code>.</p>
</td></tr>
<tr><td><code id="yaml_exec_+3A_keep_tbl">keep_tbl</code>, <code id="yaml_exec_+3A_keep_extracts">keep_extracts</code></td>
<td>
<p>For agents, the table may be kept if it is a
data frame object (databases tables will never be pulled for storage) and
<em>extracts</em>, collections of table rows that failed a validation step, may
also be stored. By default, both of these options are set to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a named vector of file paths for the input files
that were processed; file output paths (for wherever writing occurred) are
given as the names.
</p>


<h3>Function ID</h3>

<p>11-8
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate</a>()</code>,
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs</a>()</code>,
<code><a href="#topic+yaml_agent_string">yaml_agent_string</a>()</code>,
<code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate</a>()</code>,
<code><a href="#topic+yaml_read_agent">yaml_read_agent</a>()</code>,
<code><a href="#topic+yaml_read_informant">yaml_read_informant</a>()</code>,
<code><a href="#topic+yaml_write">yaml_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {

# The 'yaml' directory that is
# accessible in the package through
# `system.file()` contains the files
# 1. `agent-small_table.yml`
# 2. `informant-small_table.yml`
# 3. `tbl_store.yml`

# There are references in YAML files
# 1 &amp; 2 to the table store YAML file,
# so, they all work together cohesively

# Let's process the agent and the
# informant YAML files with `yaml_exec()`;
# and we'll specify the working directory
# as the place where the output RDS files
# are written

output_dir &lt;- getwd()

yaml_exec(
  path = system.file(
    "yaml", package = "pointblank"
  ),
  output = output_dir
)

# This generates two RDS files in the
# working directory: one for the agent
# and the other for the informant; each
# of them are automatically time-stamped
# so that periodic execution can be
# safely carried out without risk of
# overwriting 

}

</code></pre>

<hr>
<h2 id='yaml_informant_incorporate'>Get an <em>informant</em> from <strong>pointblank</strong> YAML and <code>incorporate()</code></h2><span id='topic+yaml_informant_incorporate'></span>

<h3>Description</h3>

<p>The <code>yaml_informant_incorporate()</code> function operates much like the
<code><a href="#topic+yaml_read_informant">yaml_read_informant()</a></code> function (reading a <strong>pointblank</strong> YAML file and
generating an <em>informant</em> with all information in place). The key difference
is that this function takes things a step further and incorporates aspects
from the the target table (defined by table-prep formula that is required in
the YAML file). The additional auto-invocation of <code><a href="#topic+incorporate">incorporate()</a></code> uses the
default options of that function. As with <code><a href="#topic+yaml_read_informant">yaml_read_informant()</a></code> the
informant is returned except, this time, it has been updated with the latest
information from the target table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_informant_incorporate(filename, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yaml_informant_incorporate_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the YAML file that contains fields related to an <em>informant</em>.</p>
</td></tr>
<tr><td><code id="yaml_informant_incorporate_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to the YAML file (combined with <code>filename</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_informant</code> object.
</p>


<h3>Examples</h3>

<p>There's a YAML file available in the <strong>pointblank</strong> package that's called
<code>"informant-small_table.yml"</code>. The path for it can be accessed through
<code>system.file()</code>:
</p>
<div class="sourceCode r"><pre>yml_file_path &lt;- 
  system.file(
    "yaml", "informant-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>The YAML file can be read as an informant by using the
<code>yaml_informant_incorporate()</code> function. If you expect metadata to change
with time, it's best to use <code>yaml_informant_incorporate()</code> instead of
<code><a href="#topic+yaml_read_informant">yaml_read_informant()</a></code> since the former will go the extra mile and perform
<code><a href="#topic+incorporate">incorporate()</a></code> in addition to the reading.
</p>
<div class="sourceCode r"><pre>informant &lt;- yaml_informant_incorporate(filename = yml_file_path)

informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_3.png" alt="This image was generated from the third code example in the `yaml_write()` help file." style="width:100%;">


<p>As can be seen from the information report, the available table metadata was
restored and reported. If the metadata were to change with time, that would
be updated as well.
</p>


<h3>Function ID</h3>

<p>11-7
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate</a>()</code>,
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs</a>()</code>,
<code><a href="#topic+yaml_agent_string">yaml_agent_string</a>()</code>,
<code><a href="#topic+yaml_exec">yaml_exec</a>()</code>,
<code><a href="#topic+yaml_read_agent">yaml_read_agent</a>()</code>,
<code><a href="#topic+yaml_read_informant">yaml_read_informant</a>()</code>,
<code><a href="#topic+yaml_write">yaml_write</a>()</code>
</p>

<hr>
<h2 id='yaml_read_agent'>Read a <strong>pointblank</strong> YAML file to create an <em>agent</em> object</h2><span id='topic+yaml_read_agent'></span>

<h3>Description</h3>

<p>With <code>yaml_read_agent()</code> we can read a <strong>pointblank</strong> YAML file that
describes a validation plan to be carried out by an <em>agent</em> (typically
generated by the <code><a href="#topic+yaml_write">yaml_write()</a></code> function. What's returned is a new <em>agent</em>
with that validation plan, ready to interrogate the target table at will
(using the table-prep formula that is set with the <code>tbl</code> argument of
<code><a href="#topic+create_agent">create_agent()</a></code>). The agent can be given more validation steps if needed
before using <code><a href="#topic+interrogate">interrogate()</a></code> or taking part in any other agent ops (e.g.,
writing to disk with outputs intact via <code><a href="#topic+x_write_disk">x_write_disk()</a></code> or again to
<strong>pointblank</strong> YAML with <code><a href="#topic+yaml_write">yaml_write()</a></code>).
</p>
<p>To get a picture of how <code>yaml_read_agent()</code> is interpreting the validation
plan specified in the <strong>pointblank</strong> YAML, we can use the
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs()</a></code> function. That function shows us (in the console)
the <strong>pointblank</strong> expressions for generating the described validation plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_read_agent(filename, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yaml_read_agent_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the YAML file that contains fields related to an <em>agent</em>.</p>
</td></tr>
<tr><td><code id="yaml_read_agent_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to the YAML file (combined with <code>filename</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_agent</code> object.
</p>


<h3>Examples</h3>

<p>There's a YAML file available in the <strong>pointblank</strong> package that's also
called <code>"agent-small_table.yml"</code>. The path for it can be accessed through
<code>system.file()</code>:
</p>
<div class="sourceCode r"><pre>yml_file_path &lt;- 
  system.file(
    "yaml", "agent-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>The YAML file can be read as an agent with a pre-existing validation plan by
using the <code>yaml_read_agent()</code> function.
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_read_agent(filename = yml_file_path)

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_1.png" alt="This image was generated from the first code example in the `yaml_write()` help file." style="width:100%;">


<p>This particular agent is using <code>~ tbl_source("small_table", "tbl_store.yml")</code>
to source the table-prep from a YAML file that holds a table store (can be
seen using <code>yaml_agent_string(agent = agent)</code>). Let's put that file in the
working directory (the <strong>pointblank</strong> package has the corresponding YAML
file):
</p>
<div class="sourceCode r"><pre>yml_tbl_store_path &lt;-
  system.file(
    "yaml", "tbl_store.yml",
    package = "pointblank"
  )

file.copy(from = yml_tbl_store_path, to = ".")
</pre></div>
<p>As can be seen from the validation report, no interrogation was yet
performed. Saving an agent to YAML will remove any traces of interrogation
data and serve as a plan for a new interrogation on the same target table. We
can either follow this up with with <code><a href="#topic+interrogate">interrogate()</a></code> and get an agent with
intel, or, we can interrogate directly from the YAML file with
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>:
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_agent_interrogate(filename = yml_file_path)

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_2.png" alt="This image was generated from the second code example in the `yaml_write()` help file." style="width:100%;">




<h3>Function ID</h3>

<p>11-2
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate</a>()</code>,
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs</a>()</code>,
<code><a href="#topic+yaml_agent_string">yaml_agent_string</a>()</code>,
<code><a href="#topic+yaml_exec">yaml_exec</a>()</code>,
<code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate</a>()</code>,
<code><a href="#topic+yaml_read_informant">yaml_read_informant</a>()</code>,
<code><a href="#topic+yaml_write">yaml_write</a>()</code>
</p>

<hr>
<h2 id='yaml_read_informant'>Read a <strong>pointblank</strong> YAML file to create an <em>informant</em> object</h2><span id='topic+yaml_read_informant'></span>

<h3>Description</h3>

<p>With <code>yaml_read_informant()</code> we can read a <strong>pointblank</strong> YAML file that
describes table information (typically generated by the <code><a href="#topic+yaml_write">yaml_write()</a></code>
function. What's returned is a new <em>informant</em> object with the information
intact. The <em>informant</em> object can be given more information through use of
the <code style="white-space: pre;">&#8288;info_*()&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_read_informant(filename, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yaml_read_informant_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <strong>required</strong>
</p>
<p>The name of the YAML file that contains fields related to an <em>informant</em>.</p>
</td></tr>
<tr><td><code id="yaml_read_informant_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to the YAML file (combined with <code>filename</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ptblank_informant</code> object.
</p>


<h3>Examples</h3>

<p>There's a YAML file available in the <strong>pointblank</strong> package that's called
<code>"informant-small_table.yml"</code>. The path for it can be accessed through
<code>system.file()</code>:
</p>
<div class="sourceCode r"><pre>yml_file_path &lt;- 
  system.file(
    "yaml", "informant-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>The YAML file can be read as an informant by using the
<code>yaml_read_informant()</code> function.
</p>
<div class="sourceCode r"><pre>informant &lt;- yaml_read_informant(filename = yml_file_path)

informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_3.png" alt="This image was generated from the third code example in the `yaml_write()` help file." style="width:100%;">


<p>As can be seen from the information report, the available table metadata was
restored and reported. If you expect metadata to change with time, it might
be beneficial to use <code><a href="#topic+incorporate">incorporate()</a></code> to query the target table. Or, we can
perform this querying directly from the YAML file with
<code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code>.
</p>


<h3>Function ID</h3>

<p>11-3
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate</a>()</code>,
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs</a>()</code>,
<code><a href="#topic+yaml_agent_string">yaml_agent_string</a>()</code>,
<code><a href="#topic+yaml_exec">yaml_exec</a>()</code>,
<code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate</a>()</code>,
<code><a href="#topic+yaml_read_agent">yaml_read_agent</a>()</code>,
<code><a href="#topic+yaml_write">yaml_write</a>()</code>
</p>

<hr>
<h2 id='yaml_write'>Write <strong>pointblank</strong> objects to YAML files</h2><span id='topic+yaml_write'></span>

<h3>Description</h3>

<p>With <code>yaml_write()</code> we can take different <strong>pointblank</strong> objects (these are
the <code>ptblank_agent</code>, <code>ptblank_informant</code>, and <code>tbl_store</code>) and write them to
YAML. With an <em>agent</em>, for example, <code>yaml_write()</code> will write that everything
that is needed to specify an <em>agent</em> and it's validation plan to a YAML file.
With YAML, we can modify the YAML markup if so desired, or, use as is to
create a new agent with the <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code> function. That <em>agent</em> will
have a validation plan and is ready to <code><a href="#topic+interrogate">interrogate()</a></code> the data. We can go a
step further and perform an interrogation directly from the YAML file with
the <code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code> function. That returns an agent with intel
(having already interrogated the target data table). An <em>informant</em> object
can also be written to YAML with <code>yaml_write()</code>.
</p>
<p>One requirement for writing an <em>agent</em> or an <em>informant</em> to YAML is that we
need to have a table-prep formula specified (it's an R formula that is used
to read the target table when <code><a href="#topic+interrogate">interrogate()</a></code> or <code><a href="#topic+incorporate">incorporate()</a></code> is called).
This option can be set when using <code><a href="#topic+create_agent">create_agent()</a></code>/<code><a href="#topic+create_informant">create_informant()</a></code> or
with <code><a href="#topic+set_tbl">set_tbl()</a></code> (useful with an existing agent or informant object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_write(
  ...,
  .list = list2(...),
  filename = NULL,
  path = NULL,
  expanded = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yaml_write_+3A_...">...</code></td>
<td>
<p><em>Pointblank agents, informants, table stores</em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;series of obj:&lt;ptblank_agent|ptblank_informant|tbl_store&gt;&gt;&#8288;</code>
// <strong>required</strong>
</p>
<p>Any mix of <strong>pointblank</strong> objects such as the <em>agent</em>
(<code>ptblank_agent</code>), the <em>informant</em> (<code>ptblank_informant</code>), or the table
store (<code>tbl_store</code>). The agent and informant can be combined into a single
YAML file (so long as both objects refer to the same table). A table store
cannot be combined with either an agent or an informant so it must undergo
conversion alone.</p>
</td></tr>
<tr><td><code id="yaml_write_+3A_.list">.list</code></td>
<td>
<p><em>Alternative to <code>...</code></em>
</p>
<p><code style="white-space: pre;">&#8288;&lt;list of multiple expressions&gt;&#8288;</code> // <strong>required</strong> (or, use <code>...</code>)
</p>
<p>Allows for the use of a list as an input alternative to <code>...</code>.</p>
</td></tr>
<tr><td><code id="yaml_write_+3A_filename">filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The name of the YAML file to create on disk. It is recommended that either
the <code>.yaml</code> or <code>.yml</code> extension be used for this file. If not provided then
default names will be used (<code>"tbl_store.yml"</code>) for a table store and the
other objects will get default naming to the effect of
<code>"&lt;object&gt;-&lt;tbl_name&gt;.yml"</code>.</p>
</td></tr>
<tr><td><code id="yaml_write_+3A_path">path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;character&gt;&#8288;</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to which the YAML file should be saved (combined with
<code>filename</code>).</p>
</td></tr>
<tr><td><code id="yaml_write_+3A_expanded">expanded</code></td>
<td>
<p><em>Expand validation when repeating across multiple columns</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the written validation expressions for an <em>agent</em> be expanded such
that <strong>tidyselect</strong> expressions for columns are evaluated, yielding a
validation function per column? By default, this is <code>FALSE</code> so expressions
as written will be retained in the YAML representation.</p>
</td></tr>
<tr><td><code id="yaml_write_+3A_quiet">quiet</code></td>
<td>
<p><em>Inform (or not) upon file writing</em>
</p>
<p><code style="white-space: pre;">&#8288;scalar&lt;logical&gt;&#8288;</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>.  Should the function <em>not</em> inform when the file is written?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if the YAML file has been written.
</p>


<h3>Examples</h3>



<h4>Writing an <code>agent</code> object to a YAML file</h4>

<p>Let's go through the process of developing an agent with a validation plan.
We'll use the <code>small_table</code> dataset in the following examples, which will
eventually offload the developed validation plan to a YAML file.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>Creating an <code>action_levels</code> object is a common workflow step when creating a
<strong>pointblank</strong> agent. We designate failure thresholds to the <code>warn</code>, <code>stop</code>,
and <code>notify</code> states using <code><a href="#topic+action_levels">action_levels()</a></code>.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 0.10,
    stop_at = 0.25,
    notify_at = 0.35
  )
</pre></div>
<p>Now let's create the <code>agent</code> and pass it the <code>al</code> object (which serves as a
default for all validation steps which can be overridden). The data will be
referenced in <code>tbl</code> with a leading <code>~</code> and this is a requirement for writing
to YAML since the preparation of the target table must be self contained.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "A simple example with the `small_table`.",
    actions = al
  )
</pre></div>
<p>Then, as with any <code>agent</code> object, we can add steps to the validation plan by
using as many validation functions as we want.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  agent %&gt;% 
  col_exists(columns = c(date, date_time)) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}"
  ) %&gt;%
  rows_distinct() %&gt;%
  col_vals_gt(columns = d, value = 100) %&gt;%
  col_vals_lte(columns = c, value = 5)
</pre></div>
<p>The agent can be written to a <strong>pointblank</strong>-readable YAML file with the
<code>yaml_write()</code> function. Here, we'll use the filename
<code>"agent-small_table.yml"</code> and, after writing, the YAML file will be in the
working directory:
</p>
<div class="sourceCode r"><pre>yaml_write(agent, filename = "agent-small_table.yml")
</pre></div>
<p>We can view the YAML file in the console with the <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code>
function.
</p>
<div class="sourceCode r"><pre>yaml_agent_string(filename = "agent-small_table.yml")
</pre></div>
<div class="sourceCode yaml"><pre>type: agent
tbl: ~small_table
tbl_name: small_table
label: A simple example with the `small_table`.
lang: en
locale: en
actions:
  warn_fraction: 0.1
  stop_fraction: 0.25
  notify_fraction: 0.35
steps:
- col_exists:
    columns: c(date, date_time)
- col_vals_regex:
    columns: c(b)
    regex: '[0-9]-[a-z]{3}-[0-9]{3}'
- rows_distinct:
    columns: ~
- col_vals_gt:
    columns: c(d)
    value: 100.0
- col_vals_lte:
    columns: c(c)
    value: 5.0
</pre></div>
<p>Incidentally, we can also use <code><a href="#topic+yaml_agent_string">yaml_agent_string()</a></code> to print YAML in the
console when supplying an agent as the input. This can be useful for
previewing YAML output just before writing it to disk with <code>yaml_write()</code>.
</p>



<h4>Reading an <code>agent</code> object from a YAML file</h4>

<p>There's a YAML file available in the <strong>pointblank</strong> package that's also
called <code>"agent-small_table.yml"</code>. The path for it can be accessed through
<code>system.file()</code>:
</p>
<div class="sourceCode r"><pre>yml_file_path &lt;- 
  system.file(
    "yaml", "agent-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>The YAML file can be read as an agent with a pre-existing validation plan by
using the <code><a href="#topic+yaml_read_agent">yaml_read_agent()</a></code> function.
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_read_agent(filename = yml_file_path)

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_1.png" alt="This image was generated from the first code example in the `yaml_write()` help file." style="width:100%;">


<p>This particular agent is using <code>~ tbl_source("small_table", "tbl_store.yml")</code>
to source the table-prep from a YAML file that holds a table store (can be
seen using <code>yaml_agent_string(agent = agent)</code>). Let's put that file in the
working directory (the <strong>pointblank</strong> package has the corresponding YAML
file):
</p>
<div class="sourceCode r"><pre>yml_tbl_store_path &lt;-
  system.file(
    "yaml", "tbl_store.yml",
    package = "pointblank"
  )

file.copy(from = yml_tbl_store_path, to = ".")
</pre></div>
<p>As can be seen from the validation report, no interrogation was yet
performed. Saving an agent to YAML will remove any traces of interrogation
data and serve as a plan for a new interrogation on the same target table. We
can either follow this up with with <code><a href="#topic+interrogate">interrogate()</a></code> and get an agent with
intel, or, we can interrogate directly from the YAML file with
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate()</a></code>:
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_agent_interrogate(filename = yml_file_path)

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_2.png" alt="This image was generated from the second code example in the `yaml_write()` help file." style="width:100%;">





<h4>Writing an <code>informant</code> object to a YAML file</h4>

<p>Let's walk through how we can generate some useful information for a really
small table. We can create an <code>informant</code> object with <code><a href="#topic+create_informant">create_informant()</a></code>
and we'll again use the <code>small_table</code> dataset.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "A simple example with the `small_table`."
  )
</pre></div>
<p>Then, as with any <code>informant</code> object, we can add info text to the
using as many <code style="white-space: pre;">&#8288;info_*()&#8288;</code> functions as we want.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  informant %&gt;%
  info_columns(
    columns = a,
    info = "In the range of 1 to 10. (SIMPLE)"
  ) %&gt;%
  info_columns(
    columns = starts_with("date"),
    info = "Time-based values (e.g., `Sys.time()`)."
  ) %&gt;%
  info_columns(
    columns = date,
    info = "The date part of `date_time`. (CALC)"
  )
</pre></div>
<p>The informant can be written to a <strong>pointblank</strong>-readable YAML file with the
<code>yaml_write()</code> function. Here, we'll use the filename
<code>"informant-small_table.yml"</code> and, after writing, the YAML file will be in
the working directory:
</p>
<div class="sourceCode r"><pre>yaml_write(informant, filename = "informant-small_table.yml")
</pre></div>
<p>We can inspect the YAML file in the working directory and expect to see the
following:
</p>
<div class="sourceCode yaml"><pre>type: informant
tbl: ~small_table
tbl_name: small_table
info_label: A simple example with the `small_table`.
lang: en
locale: en
table:
  name: small_table
  _columns: 8
  _rows: 13.0
  _type: tbl_df
columns:
  date_time:
  _type: POSIXct, POSIXt
info: Time-based values (e.g., `Sys.time()`).
date:
  _type: Date
  info: Time-based values (e.g., `Sys.time()`). The date part of `date_time`.
a:
  _type: integer
  info: In the range of 1 to 10. (SIMPLE)
b:
  _type: character
c:
  _type: numeric
d:
  _type: numeric
e:
  _type: logical
f:
  _type: character
</pre></div>



<h4>Reading an <code>informant</code> object from a YAML file</h4>

<p>There's a YAML file available in the <strong>pointblank</strong> package that's also
called <code>"informant-small_table.yml"</code>. The path for it can be accessed through
<code>system.file()</code>:
</p>
<div class="sourceCode r"><pre>yml_file_path &lt;- 
  system.file(
    "yaml", "informant-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>The YAML file can be read as an informant by using the
<code><a href="#topic+yaml_read_informant">yaml_read_informant()</a></code> function.
</p>
<div class="sourceCode r"><pre>informant &lt;- yaml_read_informant(filename = yml_file_path)

informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_3.png" alt="This image was generated from the third code example in the `yaml_write()` help file." style="width:100%;">


<p>As can be seen from the information report, the available table metadata was
restored and reported. If you expect metadata to change with time, it might
be beneficial to use <code><a href="#topic+incorporate">incorporate()</a></code> to query the target table. Or, we can
perform this querying directly from the YAML file with
<code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code>:
</p>
<div class="sourceCode r"><pre>informant &lt;- yaml_informant_incorporate(filename = yml_file_path)
</pre></div>
<p>There will be no apparent difference in this particular case since
<code>small_data</code> is a static table with no alterations over time. However,
using <code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate()</a></code> is good practice since this refreshing
of data will be important with real-world datasets.
</p>



<h3>Function ID</h3>

<p>11-1
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code><a href="#topic+yaml_agent_interrogate">yaml_agent_interrogate</a>()</code>,
<code><a href="#topic+yaml_agent_show_exprs">yaml_agent_show_exprs</a>()</code>,
<code><a href="#topic+yaml_agent_string">yaml_agent_string</a>()</code>,
<code><a href="#topic+yaml_exec">yaml_exec</a>()</code>,
<code><a href="#topic+yaml_informant_incorporate">yaml_informant_incorporate</a>()</code>,
<code><a href="#topic+yaml_read_agent">yaml_read_agent</a>()</code>,
<code><a href="#topic+yaml_read_informant">yaml_read_informant</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
