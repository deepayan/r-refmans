<!DOCTYPE html><html><head><title>Help for package ABM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ABM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ABM-package'><p>Agent Based Model Simulation Framework</p></a></li>
<li><a href='#addAgent'><p>add an agent to a population</p></a></li>
<li><a href='#Agent'><p>R6 class that represent an agent</p></a></li>
<li><a href='#clearEvents'><p>Unschedule all event from an agent</p></a></li>
<li><a href='#Contact'><p>An R6 class that implements a contact pattern in R</p></a></li>
<li><a href='#Event'><p>R6 class to create and represent an event</p></a></li>
<li><a href='#getAgent'><p>Get the agent at an index in the population</p></a></li>
<li><a href='#getID'><p>Get the ID of the agent.</p></a></li>
<li><a href='#getSize'><p>Get the size of a population</p></a></li>
<li><a href='#getState'><p>Get the state of the agent</p></a></li>
<li><a href='#getTime'><p>returns the event time</p></a></li>
<li><a href='#getWaitingTime'><p>Generate a waiting time from an WaitingTime object</p></a></li>
<li><a href='#leave'><p>leave the population that the agent is in</p></a></li>
<li><a href='#matchState'><p>Check if the state of an agent matches a given state</p></a></li>
<li><a href='#newAgent'><p>Create an agent with a given state</p></a></li>
<li><a href='#newConfigurationModel'><p>Creates a random network using the configuration model</p></a></li>
<li><a href='#newCounter'><p>Create a logger of the Counter class</p></a></li>
<li><a href='#newEvent'><p>Creates a new event in R</p></a></li>
<li><a href='#newExpWaitingTime'><p>Creates an exponentially distributed waiting time</p></a></li>
<li><a href='#newGammaWaitingTime'><p>Creates an gamma distributed waiting time</p></a></li>
<li><a href='#newPopulation'><p>Create a new population</p></a></li>
<li><a href='#newRandomMixing'><p>Creates a RandomMixing object</p></a></li>
<li><a href='#newStateLogger'><p>Create a logger of the StateLogger class</p></a></li>
<li><a href='#Population'><p>R6 class that represents a population</p></a></li>
<li><a href='#schedule'><p>Schedule (attach) an event to an agent</p></a></li>
<li><a href='#setDeathTime'><p>set the time of death for an agent</p></a></li>
<li><a href='#setState'><p>Set the state of the agent</p></a></li>
<li><a href='#setStates'><p>Set the state for each agent in a population</p></a></li>
<li><a href='#Simulation'><p>R6 class Create and represent a Simulation object</p></a></li>
<li><a href='#State'><p>The state of an agent</p></a></li>
<li><a href='#stateMatch'><p>Check if two states match</p></a></li>
<li><a href='#unschedule'><p>Unschedule (detach) an event from an agent</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Agent Based Model Simulation Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-14</td>
</tr>
<tr>
<td>Description:</td>
<td>A high-performance, flexible and extensible framework to
    develop continuous-time agent based models. Its high performance
    allows it to simulate millions of agents efficiently. Agents are
    defined by their states (arbitrary R lists). The events are handled in
    chronological order. This avoids the multi-event interaction problem
    in a time step of discrete-time simulations, and gives precise
    outcomes. The states are modified by provided or user-defined events.
    The framework provides a flexible and customizable implementation of
    state transitions (either spontaneous or caused by agent
    interactions), making the framework suitable to apply to epidemiology
    and ecology, e.g., to model life history stages, competition and
    cooperation, and disease and information spread. The agent
    interactions are flexible and extensible. The framework provides
    random mixing and network interactions, and supports multi-level
    mixing patterns.  It can be easily extended to other interactions such
    as inter- and intra-households (or workplaces and schools) by
    subclassing an R6 class. It can be used to study the effect of
    age-specific, group-specific, and contact- specific intervention
    strategies, and complex interactions between individual behavior and
    population dynamics. This modeling concept can also be used in
    business, economical and political models. As a generic event based
    framework, it can be applied to many other fields. More information
    about the implementation and examples can be found at
    <a href="https://github.com/junlingm/ABM">https://github.com/junlingm/ABM</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/junlingm/ABM">https://github.com/junlingm/ABM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/junlingm/ABM/issues">https://github.com/junlingm/ABM/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-14 21:22:27 UTC; jma</td>
</tr>
<tr>
<td>Author:</td>
<td>Junling Ma [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Junling Ma &lt;junlingm@uvic.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-14 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ABM-package'>Agent Based Model Simulation Framework</h2><span id='topic+ABM'></span><span id='topic+ABM-package'></span>

<h3>Description</h3>

<p>This package provides a framework to simulate agent based models that are
based on states and events.
</p>


<h3>Details</h3>



<h4>Agent</h4>

<p>The concept of this framework is agent, which is an object of the <a href="#topic+Agent">Agent</a>
class. An agent maintains its own state, which is a named R list storing any
R values in it. (see <a href="#topic+State">State</a> ). The main task of an agent is to manage events
(see <a href="#topic+Event">Event</a>), and handle them in chronological order.
</p>



<h4>Population</h4>

<p>An object of the <a href="#topic+Population">Population</a> class manages agents and their contacts. The
contacts of agents are managed by Contact objects. The main functionality for
a contact object is to provide contacts of a given individuals at a given
time. For example, <code><a href="#topic+newRandomMixing">newRandomMixing()</a></code> returns such an object that finds a
random agent in the population as a contact. the effect of contacts on the
states of agents are defined using a state transition rule. Please see
<code>addTransition</code> method of <a href="#topic+Simulation">Simulation</a> for more details.
</p>



<h4>Simulation</h4>

<p>The <a href="#topic+Simulation">Simulation</a> class inherits the <a href="#topic+Population">Population</a> class. So a simulation
manages agents and their contacts. Thus, the class also inherits the <a href="#topic+Agent">Agent</a>
class. So a simulation can have its own state, and events attached
(scheduled) to it. In addition, it also manages all the transitions, using
its <code>addTransition</code> method. At last, it maintains loggers, which record
(or count) the state changes, and report their values at specified times.
</p>
<p>During a simulation the earliest event in the simulation is picked out,
unscheduled (detached), and handled, which potentially causes the state
change of the agent (or another agent in the simulation). The state change is
then logged by loggers (see <code><a href="#topic+newCounter">newCounter()</a></code> and
<code><a href="#topic+newStateLogger">newStateLogger()</a></code> for more details) that recognize the state
change.
</p>



<h4>Usage</h4>

<p>To use this framework, we start by creating a simulation
object, populate the simulation with agents (either using the argument in
the constructor, or use its <code>addAgent</code> method), and
initialize the agents with their initial states using its <code>setState</code> method.
</p>
<p>We then attach (<code><a href="#topic+schedule">schedule()</a></code>) events to agents (possibly to the populations or
the simulation object too), so that these events change the agents' state.
For models which agents' states are defined by discrete states, such as the
SIR epidemic model, the events are managed by the framework through state
transitions, using rules defined by the <code>addTransition</code> method of
the <a href="#topic+Simulation">Simulation</a> class.
</p>
<p>At last, we add loggers to the simulation using
the <a href="#topic+Simulation">Simulation</a> class' <code>addLogger</code> method' and either <code><a href="#topic+newCounter">newCounter()</a></code> or
<code><a href="#topic+newStateLogger">newStateLogger()</a></code>. At last, run the simulation using
its <code>run</code> method, which returns the observations of the loggers
at the requested time points as a data.frame object.
</p>
<p>For more information and examples, please see the <a href="https://github.com/junlingm/ABM/wiki/">Wiki</a> pages on Github.
</p>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Junling Ma <a href="mailto:junlingm@uvic.ca">junlingm@uvic.ca</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/junlingm/ABM">https://github.com/junlingm/ABM</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/junlingm/ABM/issues">https://github.com/junlingm/ABM/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># simulate an SIR model using the Gillespie method
# the population size
N = 10000
# the initial number of infectious agents
I0 = 10
# the transmission rate
beta = 0.4
# the recovery rate
gamma = 0.2
# an waiting time egenerator that handles 0 rate properly
wait.exp = function(rate) {
  if (rate == 0) Inf else rexp(1, rate)
}
# this is a function that rescheduled all the events. When the
# state changed, the old events are invalid because they are
# calculated from the old state. This is possible because the
# waiting times are exponentially distributed
reschedule = function(time, agent, state) {
  clearEvents(agent)
  t.inf = time + wait.exp(beta*state$I*state$S/N)
  schedule(agent, newEvent(t.inf, handler.infect))
  t.rec = time + wait.exp(gamma*state$I)
  schedule(agent, newEvent(t.rec, handler.recover))
}
# The infection event handler
# an event handler take 3 arguments
#   time is the current simulation time
#   sim is an external pointer to the Simulation object.
#   agent is the agent that the event is scheduled to
handler.infect = function(time, sim, agent) {
  x = getState(agent)
  x$S = x$S - 1
  x$I = x$I + 1
  setState(agent, x)
  reschedule(time, agent, x)
}
# The recovery event handler
handler.recover = function(time, sim, agent) {
  x = getState(agent)
  x$R = x$R + 1
  x$I = x$I - 1
  setState(agent, x)
  reschedule(time, agent, x)
}
# create a new simulation with no agent in it.
# note that the simulation object itself is an agent
sim = Simulation$new()
# the initial state
x = list(S=N-I0, I=I0, R=0)
sim$state = x
# schedule an infection event and a recovery event
reschedule(0, sim$get, sim$state)
# add state loggers that saves the S, I, and R states
sim$addLogger(newStateLogger("S", NULL, "S"))
sim$addLogger(newStateLogger("I", NULL, "I"))
sim$addLogger(newStateLogger("R", sim$get, "R"))
# now the simulation is setup, and is ready to run
result = sim$run(0:100)
# the result is a data.frame object
print(result)

# simulate an agent based SEIR model
# specify an exponential waiting time for recovery
gamma = newExpWaitingTime(0.2)
# specify a tansmission rate
beta = 0.4
# specify a exponentially distributed latent period
sigma =newExpWaitingTime(0.5)
# the population size
N = 10000
# create a simulation with N agents, initialize the first 5 with a state "I" 
# and the remaining with "S".
sim = Simulation$new(N, function(i) if (i &lt;= 5) "I" else "S")
# add event loggers that counts the individuals in each state.
# the first variable is the name of the counter, the second is
# the state for counting. States should be lists. However, for
# simplicity, if the state has a single value, then we 
# can specify the list as the value, e.g., "S", and the state
# is equivalent to list("S")
sim$addLogger(newCounter("S", "S"))
sim$addLogger(newCounter("E", "E"))
sim$addLogger(newCounter("I", "I"))
sim$addLogger(newCounter("R", "R"))
# create a random mixing contact pattern and attach it to sim
m = newRandomMixing()
sim$addContact(m)
# the transition for leaving latent state anbd becoming infectious
sim$addTransition("E"-&gt;"I", sigma)
# the transition for recovery
sim$addTransition("I"-&gt;"R", gamma)
# the transition for tranmission, which is caused by the contact m
# also note that the waiting time can be a number, which is the same
# as newExpWaitingTime(beta)
sim$addTransition("I" + "S" -&gt; "I" + "E" ~ m, beta)
# run the simulation, and get a data.frame object
result = sim$run(0:100)
print(result)

</code></pre>

<hr>
<h2 id='addAgent'>add an agent to a population</h2><span id='topic+addAgent'></span>

<h3>Description</h3>

<p>add an agent to a population
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="addAgent_+3A_population">population</code></td>
<td>
<p>an external pointer to a population, for example,
one returned by <code><a href="#topic+newPopulation">newPopulation()</a></code></p>
</td></tr>
<tr><td><code id="addAgent_+3A_agent">agent</code></td>
<td>
<p>an external pointer to an agent, returned by <code><a href="#topic+newAgent">newAgent()</a></code> or
<code><a href="#topic+getAgent">getAgent()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>if the agent is an R6 class, we should use <code>agent$get</code> to get
the external pointer. Similarly, if population is an R6 object, then we
should either use <code>population$addAgent()</code> or <code>population$get</code>.
</p>

<hr>
<h2 id='Agent'>R6 class that represent an agent</h2><span id='topic+Agent'></span>

<h3>Description</h3>

<p>The key task of an agent is to maintain events, and handle them in the
chronological order. Agents also maintain their states, which is a list of
values. The events, when handled, operate on the state of the agent (or other
agents).
</p>


<h3>Details</h3>

<p>During the simulation the agent with the earliest event in the simulation is
picked out, unscheduled, then its earliest event is handled, which
potentially causes the state change of the agent (or another agent in the
simulation). The state change is then logged by loggers that recognize the
state change.
</p>
<p>An agent itself cannot handle the event. Instead, it has to be added to a
simulation (or a population that itself is added to a simulation).
</p>
<p>Note that specifying death.time is equivalent to call the
<code style="white-space: pre;">&#8288;$setDeathTime&#8288;</code> method.
Check if the state of the agent matches a given state
</p>
<p>At the time of death, the agent is removed from the simulation.
Calling it multiple times causes the agent to die at the earliest time.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>state</code></dt><dd><p>Get/set the state of the agent</p>
</dd>
<dt><code>id</code></dt><dd><p>Get the agent ID</p>
</dd>
<dt><code>get</code></dt><dd><p>Get the external pointer for the agent</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-R6Agent-new"><code>Agent$new()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Agent-match"><code>Agent$match()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Agent-schedule"><code>Agent$schedule()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Agent-unschedule"><code>Agent$unschedule()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Agent-leave"><code>Agent$leave()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Agent-setDeathTime"><code>Agent$setDeathTime()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Agent-clone"><code>Agent$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-R6Agent-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Agent$new(agent = NULL, death.time = NA)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>agent</code></dt><dd><p>can be either an external pointer to an agent such as one
returned by newAgent, or a list representing the initial state for creating
a new agent, or NULL (an empty state)</p>
</dd>
<dt><code>death.time</code></dt><dd><p>the time of death for the agent, a numeric value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-R6Agent-match"></a>



<h4>Method <code>match()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Agent$match(rule)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rule</code></dt><dd><p>the state to match, a list</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a logical value
Schedule an event
</p>


<hr>
<a id="method-R6Agent-schedule"></a>



<h4>Method <code>schedule()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Agent$schedule(event)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>event</code></dt><dd><p>an object of the R6 class Event, or an external pointer
returned by newEvent</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the agent itself (invisible)
Unschedule an event
</p>


<hr>
<a id="method-R6Agent-unschedule"></a>



<h4>Method <code>unschedule()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Agent$unschedule(event)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>event</code></dt><dd><p>an object of the R6 class Event, or an external pointer
returned by newEvent</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the agent itself (invisible)
leave the population that the agent is in
</p>


<hr>
<a id="method-R6Agent-leave"></a>



<h4>Method <code>leave()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Agent$leave()</pre></div>



<h5>Returns</h5>

<p>the agent itself
set the time of death for the agent
</p>


<hr>
<a id="method-R6Agent-setDeathTime"></a>



<h4>Method <code>setDeathTime()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Agent$setDeathTime(time)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>time</code></dt><dd><p>the time of death, a numeric value</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the agent itself (invisible)
</p>


<hr>
<a id="method-R6Agent-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Agent$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='clearEvents'>Unschedule all event from an agent</h2><span id='topic+clearEvents'></span>

<h3>Description</h3>

<p>Unschedule all event from an agent
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="clearEvents_+3A_agent">agent</code></td>
<td>
<p>an external pointer returned by newAgent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If agent is an R6 object, then we should use either
agent$clearEvents() or clearEvents(agent$get)
</p>

<hr>
<h2 id='Contact'>An R6 class that implements a contact pattern in R</h2><span id='topic+Contact'></span>

<h3>Description</h3>

<p>An R6 class that implements a contact pattern in R
</p>
<p>An R6 class that implements a contact pattern in R
</p>


<h3>Details</h3>

<p>The main task of the class is to return the contacts of a given agent. Each
object of this class is associated to a population. A population may have
multiple contacts attached, e.g., a random mixing contact pattern and a
network contact pattern.
</p>
<p>This class must be subclassed in order to implement specific functionality.
To subclass, we must implement three methods, namely contact, addAgent, and
build. See more details in the documentation of each method.
</p>
<p>. This method should be called from the C++ side. Users should not
call this directly.
</p>
<p>When an agent is added to a population, it is added to each of the
contact patterns. When a contact pattern is added to a population, all
agents in a population is added to the contact pattern, one by one.
</p>
<p>Note that, immediately before the simulation is run, while reporting
the states to the simulation object, the population will call the
build method for each Contact object. Thus a contact object may choose
to ignore adding agents before build is called, and handle all agents
within the finalize method. However, the contact object must handle
adding an agent after build is called.
</p>
<p>When an agent leaves a population, it is removed from each of the
contact patterns.
</p>
<p>This method may also be called in event handlers to remove an agent
</p>
<p>This method is called immediately before the simulation is run,
when the attached population reports the states to the simulation object.
</p>
<p>Thus this method can be considered as a callback function to notify the
contact object the population state, such as its agents, states, events,
and contact patterns are all initialized, so the contact pattern should
finish initialization, for example, building the contact network.
</p>
<p>This is needed because some contact patterns, such as a configuration-
model contact network, cannot be built while adding agents one by one.
It must be generated when all agents are present. This is unlike the
Albert-Barabasi networkm which can be built while adding the agents.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>get</code></dt><dd><p>.The external pointer pointing to the C++ RContact object.</p>
</dd>
<dt><code>attached</code></dt><dd><p>a logical value indicating whether the object has been attached
to a population</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-R6Contact-new"><code>Contact$new()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Contact-attach"><code>Contact$attach()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Contact-contact"><code>Contact$contact()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Contact-addAgent"><code>Contact$addAgent()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Contact-remove"><code>Contact$remove()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Contact-build"><code>Contact$build()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Contact-clone"><code>Contact$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-R6Contact-new"></a>



<h4>Method <code>new()</code></h4>

<p>the constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>Contact$new()</pre></div>


<hr>
<a id="method-R6Contact-attach"></a>



<h4>Method <code>attach()</code></h4>

<p>attach to a population
</p>


<h5>Usage</h5>

<div class="r"><pre>Contact$attach(population)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>population</code></dt><dd><p>the population to attach to. An external pointer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-R6Contact-contact"></a>



<h4>Method <code>contact()</code></h4>

<p>Returns the contacts of the given agent
</p>


<h5>Usage</h5>

<div class="r"><pre>Contact$contact(time, agent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>time</code></dt><dd><p>the current time in the simulation, a number</p>
</dd>
<dt><code>agent</code></dt><dd><p>the agent whose contacts are requested. An external pointer</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a list of external pointers pointing to the contacting agents
</p>


<hr>
<a id="method-R6Contact-addAgent"></a>



<h4>Method <code>addAgent()</code></h4>

<p>Add an agent to the contact pattern
</p>


<h5>Usage</h5>

<div class="r"><pre>Contact$addAgent(agent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>agent</code></dt><dd><p>the agent to be added. An external pointer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-R6Contact-remove"></a>



<h4>Method <code>remove()</code></h4>

<p>Remove an agent from the contact pattern
</p>


<h5>Usage</h5>

<div class="r"><pre>Contact$remove(agent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>agent</code></dt><dd><p>the agent to be removed. An external pointer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-R6Contact-build"></a>



<h4>Method <code>build()</code></h4>

<p>Build the contact pattern
</p>


<h5>Usage</h5>

<div class="r"><pre>Contact$build()</pre></div>


<hr>
<a id="method-R6Contact-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Contact$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Event'>R6 class to create and represent an event</h2><span id='topic+Event'></span>

<h3>Description</h3>

<p>R6 class to create and represent an event
</p>
<p>R6 class to create and represent an event
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>time</code></dt><dd><p>returns the event time</p>
</dd>
<dt><code>get</code></dt><dd><p>returns the external pointer, which can then be passed to
functions such as schedule and unschedule.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-R6Event-new"><code>Event$new()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Event-clone"><code>Event$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-R6Event-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Event$new(time, handler)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>time</code></dt><dd><p>the time that this event will occur. A length-1
numeric vector.</p>
</dd>
<dt><code>handler</code></dt><dd><p>an R function that handles the event when it occurs.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The R handler function should take exactly 3 arguments
</p>

<ol>
<li><p> time: the current time in the simulation
</p>
</li>
<li><p> sim: the simulation object, an external pointer
</p>
</li>
<li><p> agent: the agent to whom this event is attached to.
</p>
</li></ol>

<p>The return value of the handler function is ignored.
</p>


<hr>
<a id="method-R6Event-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Event$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># This handler prints increases a counter in the state of the 
# Simulation object, and schedule another event every 0.1 time unit.
handler = function(time, sim, agent) {
  x = getState(sim)
  x$counter = x$counter + 1
  setState(sim, x)
  schedule(agent, newEvent(time + 0.1, handler))
}
# create a new simulation with no agents. but the simulation itself is
# an agent. So we can use all the methods of agent
sim = Simulation$new()
# set the state of the simulation, initialize the counter
sim$state = list(counter = 0)
# schedule a new event at time 0
sim$schedule(Event$new(0, handler))
# add a logger for the counter. Note that, because sim is an R6 class
# to use it in the newStateLogger function, we need to access the 
# external pointer using its $get method
sim$addLogger(newStateLogger("counter", sim$get, "counter"))
# run the simulation for 10 time units.
print(sim$run(0:10))
# interestingly, the counts are not exactly in 10 event time unit. 
# Firstly, report always happen before event, so event at time 0 is 
# not counted in the time interval 0 to 1. Secondly, the event time 
# is stored as a numeric value with increments of 0.1, which is 
# subject to rounding errors. So some the the integer tiome events
# may be before the reporting and some may be after.

</code></pre>

<hr>
<h2 id='getAgent'>Get the agent at an index in the population</h2><span id='topic+getAgent'></span>

<h3>Description</h3>

<p>Get the agent at an index in the population
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAgent_+3A_population">population</code></td>
<td>
<p>an external pointer to a population, for example,
one returned by <code><a href="#topic+newPopulation">newPopulation()</a></code></p>
</td></tr>
<tr><td><code id="getAgent_+3A_i">i</code></td>
<td>
<p>the index of the agent, starting from 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the agent at index i in the population.
</p>

<hr>
<h2 id='getID'>Get the ID of the agent.</h2><span id='topic+getID'></span>

<h3>Description</h3>

<p>Get the ID of the agent.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getID_+3A_agent">agent</code></td>
<td>
<p>an external pointer returned by newAgent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before an agent is added to a population, its id is 0.
After it is added, its id is the index in the population
(starting from 1).
</p>
<p>If agent is an R6 object, then we should either use <code>agent$id</code>,
or use <code>getID(agent$get)</code>
</p>


<h3>Value</h3>

<p>an integer value
</p>

<hr>
<h2 id='getSize'>Get the size of a population</h2><span id='topic+getSize'></span>

<h3>Description</h3>

<p>Get the size of a population
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSize_+3A_population">population</code></td>
<td>
<p>an external pointer to a population, for example,
one returned by <code><a href="#topic+newPopulation">newPopulation()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the population size, an integer
</p>

<hr>
<h2 id='getState'>Get the state of the agent</h2><span id='topic+getState'></span>

<h3>Description</h3>

<p>Get the state of the agent
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getState_+3A_agent">agent</code></td>
<td>
<p>an external pointer returned by newAgent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If agent is an R6 object, then we should either use agent$schedule,
or use schedule(agent$get, event)
</p>


<h3>Value</h3>

<p>a list holding the state
</p>

<hr>
<h2 id='getTime'>returns the event time</h2><span id='topic+getTime'></span>

<h3>Description</h3>

<p>returns the event time
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTime_+3A_event">event</code></td>
<td>
<p>an external pointer returned by the newEvent function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value
</p>
<p>This function avoids the overhead of an R6 class, and is thus faster.
This is the recommended method to get event time in an event handler.
</p>

<hr>
<h2 id='getWaitingTime'>Generate a waiting time from an WaitingTime object</h2><span id='topic+getWaitingTime'></span>

<h3>Description</h3>

<p>Generate a waiting time from an WaitingTime object
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWaitingTime_+3A_generator">generator</code></td>
<td>
<p>an external pointer to a WaitingTime object, e.g.,
one returned by newExpWaitingTime or newGammaWaitingTime</p>
</td></tr>
<tr><td><code id="getWaitingTime_+3A_time">time</code></td>
<td>
<p>the current simulation time, a numeric value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value
</p>

<hr>
<h2 id='leave'>leave the population that the agent is in</h2><span id='topic+leave'></span>

<h3>Description</h3>

<p>leave the population that the agent is in
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="leave_+3A_agent">agent</code></td>
<td>
<p>an external pointer returned by newAgent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If agent is an R6 object, then we should use either
agent$leave() or leave(agent$get)
</p>

<hr>
<h2 id='matchState'>Check if the state of an agent matches a given state</h2><span id='topic+matchState'></span>

<h3>Description</h3>

<p>Check if the state of an agent matches a given state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchState(agent, rule)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchState_+3A_agent">agent</code></td>
<td>
<p>an external pointer returned by newAgent</p>
</td></tr>
<tr><td><code id="matchState_+3A_rule">rule</code></td>
<td>
<p>a list holding the state to match against</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is equivalent to
stateMatch(getState(agent), rule)
</p>
<p>The state matches the rule if and only if each domain (names of the
list) in rule has the same value as in state. The domains in domains of the
state not listed in rule are not matched
</p>


<h3>Value</h3>

<p>a logical value
</p>

<hr>
<h2 id='newAgent'>Create an agent with a given state</h2><span id='topic+newAgent'></span>

<h3>Description</h3>

<p>Create an agent with a given state
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="newAgent_+3A_state">state</code></td>
<td>
<p>a list giving the initial state of the agent, or NULL (an empty
list)</p>
</td></tr>
<tr><td><code id="newAgent_+3A_death_time">death_time</code></td>
<td>
<p>the death time for the agent, an optional numeric value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting death_time is equivalent to calling the <code><a href="#topic+setDeathTime">setDeathTime()</a></code>
function.
</p>


<h3>Value</h3>

<p>an external pointer pointing to the agent
</p>

<hr>
<h2 id='newConfigurationModel'>Creates a random network using the configuration model</h2><span id='topic+newConfigurationModel'></span>

<h3>Description</h3>

<p>Creates a random network using the configuration model
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="newConfigurationModel_+3A_rng">rng</code></td>
<td>
<p>a function that generates random degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The population must be an external pointer, not an R6 object
To use an R6 object, we should use its pointer representation from its
$get method.
</p>
<p>The function rng should take exactly one argument n for the number of degrees
to generate, and should return an integer vector of length n.
</p>


<h3>Value</h3>

<p>an external pointer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creates a simulation with 100 agents
sim = Simulation$new(100)
# add a Poisson network with a mean degree 5
sim$addContact(newConfigurationModel(function(n) rpois(n, 5)))

</code></pre>

<hr>
<h2 id='newCounter'>Create a logger of the Counter class</h2><span id='topic+newCounter'></span>

<h3>Description</h3>

<p>When state changes occur, it is passed to each logger, which then
change its value. At the specified time points in a run, the
values of the logger are reported and recorded in a data.frame object,
where the columns represent variables, and rows represent the
observation at each time point given to each run. Each logger has a
name, which becomes the the column name in the data.frame.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="newCounter_+3A_name">name</code></td>
<td>
<p>the name of the counter, must be a length-1 character vector</p>
</td></tr>
<tr><td><code id="newCounter_+3A_from">from</code></td>
<td>
<p>a list specifying state of the agent, or a character or numeric
value that is equivalent to list(from). please see the details section</p>
</td></tr>
<tr><td><code id="newCounter_+3A_to">to</code></td>
<td>
<p>a list (can be NULL) specifying the state of the agent after the
state change, or a character or numeric value that is equivalent to
list(from). please see the details section</p>
</td></tr>
<tr><td><code id="newCounter_+3A_initial">initial</code></td>
<td>
<p>the initial value of the counter. Default to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if the argument &quot;to&quot; is not NULL, then the counter counts the
transitions from &quot;from&quot; to &quot;to&quot;. Otherwise, it counts the number of agents
in a state that matches the &quot;from&quot; argument. Specifically, if the agent
jumps to &quot;from&quot;, then the count increases by 1. If the agents jumps away
from &quot;from&quot;, then the count decreases by 1.
</p>


<h3>Value</h3>

<p>an external pointer that can be passed to the <a href="#topic+Simulation">Simulation</a> class'
<code style="white-space: pre;">&#8288;$addLogger&#8288;</code>.
</p>

<hr>
<h2 id='newEvent'>Creates a new event in R</h2><span id='topic+newEvent'></span>

<h3>Description</h3>

<p>Creates a new event in R
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="newEvent_+3A_time">time</code></td>
<td>
<p>the time that this event will occur. A length-1
numeric vector.</p>
</td></tr>
<tr><td><code id="newEvent_+3A_handler">handler</code></td>
<td>
<p>an R function that handles the event when it occurs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The R handler function should take exactly 3 arguments
</p>

<ol>
<li><p> time: the current time in the simulation
</p>
</li>
<li><p> sim: the simulation object, an external pointer
</p>
</li>
<li><p> agent: the agent to whom this event is attached to.
</p>
</li></ol>

<p>The return value of the handler function is ignored.
</p>
<p>This function avoids the overhead of an R6 class, and is thus faster.
This is the recommended method to create an event in an event handler.
</p>


<h3>Value</h3>

<p>an external pointer, which can then be passed to
functions such as schedule and unschedule.
</p>

<hr>
<h2 id='newExpWaitingTime'>Creates an exponentially distributed waiting time</h2><span id='topic+newExpWaitingTime'></span>

<h3>Description</h3>

<p>Creates an exponentially distributed waiting time
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="newExpWaitingTime_+3A_rate">rate</code></td>
<td>
<p>the rate of the exponential distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an C++ object of type ExpWaitingTime.
It can be passed to addTransition or Simulation$addTransition to
specify the waiting time for a transition. As a C++ object, it is faster
than using an R function to generate waiting times because there is
no need to call an R function from C++.
</p>


<h3>Value</h3>

<p>an external pointer
</p>

<hr>
<h2 id='newGammaWaitingTime'>Creates an gamma distributed waiting time</h2><span id='topic+newGammaWaitingTime'></span>

<h3>Description</h3>

<p>Creates an gamma distributed waiting time
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="newGammaWaitingTime_+3A_shape">shape</code></td>
<td>
<p>the shape parameter of the gamma distribution</p>
</td></tr>
<tr><td><code id="newGammaWaitingTime_+3A_scale">scale</code></td>
<td>
<p>the scale parameter of the gamma distribution, i.e., 1/rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an C++ object of type ExpWaitingTime.
It can be passed to addTransition or Simulation$addTransition to
specify the waiting time for a transition. As a C++ object, it is faster
than using an R function to generate waiting times because there is
no need to call an R function from C++.
</p>


<h3>Value</h3>

<p>an external pointer
</p>

<hr>
<h2 id='newPopulation'>Create a new population</h2><span id='topic+newPopulation'></span>

<h3>Description</h3>

<p>Create a new population
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="newPopulation_+3A_n">n</code></td>
<td>
<p>an integer specifying the population size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The population will be created with &quot;n&quot; individuals in it.
These individuals have an empty state upon created. Note that
individuals can be added later by the &quot;add&quot; method, the initial
population size is for convenience, not required
</p>

<hr>
<h2 id='newRandomMixing'>Creates a RandomMixing object</h2><span id='topic+newRandomMixing'></span>

<h3>Description</h3>

<p>Creates a RandomMixing object
</p>


<h3>Value</h3>

<p>an external pointer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creates a simulation with 100 agents
sim = Simulation$new(100)
# add a random mixing contact pattern for these agents.
sim$addContact(newRandomMixing())

</code></pre>

<hr>
<h2 id='newStateLogger'>Create a logger of the StateLogger class</h2><span id='topic+newStateLogger'></span>

<h3>Description</h3>

<p>When state changes occur, it is passed to each logger, which then
change its value. At the specified time points in a run, the
values of the logger are reported and recorded in a data.frame object,
where the columns represent variables, and rows represent the
observation at each time point given to each run. Each logger has a
name, which becomes the the column name in the data.frame.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="newStateLogger_+3A_name">name</code></td>
<td>
<p>the name of the logger. A length-1 character vector</p>
</td></tr>
<tr><td><code id="newStateLogger_+3A_agent">agent</code></td>
<td>
<p>the agent whose state will be logged. An external pointer</p>
</td></tr>
<tr><td><code id="newStateLogger_+3A_state.name">state.name</code></td>
<td>
<p>the state name of the state of the agent to be logged.
A character vector of length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a state changed happened to any agent, the specified state
of the agent given by the &quot;agent&quot; argument will be logged. If
<code>state.name==NULL</code> then the state of the agent who just changed is
logged.
</p>
<p>The agent must be an external pointer. To use an R6 object, we need
to use its $get method to get the external pointer.
</p>
<p>The state to be logged must have a numeric value.
</p>

<hr>
<h2 id='Population'>R6 class that represents a population</h2><span id='topic+Population'></span>

<h3>Description</h3>

<p>A population is a collection of agents. There are two important tasks
for a population:
</p>

<ol>
<li><p> to manage the agents in it
</p>
</li>
<li><p> to define the contact patterns of the agents
</p>
</li></ol>

<p>The contact patterns are defined by objects of the Contact class that
are associated with the population. A population may have multiple
Contact objects, for example, one for random mixing, one for close
contacts represented by a contact network, and another for social
network.
</p>


<h3>Super class</h3>

<p><code>ABM::R6Agent</code> -&gt; <code>R6Population</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>size</code></dt><dd><p>The population size, an integer</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-R6Population-new"><code>Population$new()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Population-addAgent"><code>Population$addAgent()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Population-removeAgent"><code>Population$removeAgent()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Population-addContact"><code>Population$addContact()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Population-agent"><code>Population$agent()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Population-setState"><code>Population$setState()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Population-setStates"><code>Population$setStates()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Population-clone"><code>Population$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="leave"><a href='../../ABM/html/R6Agent.html#method-R6Agent-leave'><code>ABM::R6Agent$leave()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="match"><a href='../../ABM/html/R6Agent.html#method-R6Agent-match'><code>ABM::R6Agent$match()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="schedule"><a href='../../ABM/html/R6Agent.html#method-R6Agent-schedule'><code>ABM::R6Agent$schedule()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="setDeathTime"><a href='../../ABM/html/R6Agent.html#method-R6Agent-setDeathTime'><code>ABM::R6Agent$setDeathTime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="unschedule"><a href='../../ABM/html/R6Agent.html#method-R6Agent-unschedule'><code>ABM::R6Agent$unschedule()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-R6Population-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Population$new(population = 0, initializer = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>population</code></dt><dd><p>can be either an external pointer pointing to
a population object returned from newPopulation, or an integer
specifying the population size, or a list.</p>
</dd>
<dt><code>initializer</code></dt><dd><p>a function or NULL</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If population is a number (the population size), then initializer
can be a function that take the index of an agent and return its initial
state.  If it is a list, the length is the population size, and each element
corresponds to the initial state of an agent (with the same index).
Add an agent
</p>


<hr>
<a id="method-R6Population-addAgent"></a>



<h4>Method <code>addAgent()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Population$addAgent(agent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>agent</code></dt><dd><p>either an object of the R6 class Agent, or an external
pointer returned from newAgent.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The agent is scheduled in the population. If the population
is already added to a simulation, the agent will report its state
to the simulation.
remove an agent
</p>



<h5>Returns</h5>

<p>the population object itself (invisible) for chaining actions
</p>


<hr>
<a id="method-R6Population-removeAgent"></a>



<h4>Method <code>removeAgent()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Population$removeAgent(agent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>agent</code></dt><dd><p>either an object of the R6 class Agent, or an external
pointer returned from newAgent.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The agent is scheduled in the population. If the population
is already added to a simulation, the agent will report its state
to the simulation.
Add a contact pattern
</p>



<h5>Returns</h5>

<p>the population object itself (invisible) for chaining actions
</p>


<hr>
<a id="method-R6Population-addContact"></a>



<h4>Method <code>addContact()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Population$addContact(contact)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>contact</code></dt><dd><p>an external pointer pointing to a Contact object,
e.g., created from newRandomMixing.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If the contact has already been added, this call does nothing.
return a specific agent by index
</p>


<hr>
<a id="method-R6Population-agent"></a>



<h4>Method <code>agent()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Population$agent(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>the index of the agent (starting from 1)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>an external pointer pointing to the agent
set the state of a specific agent by index
</p>


<hr>
<a id="method-R6Population-setState"></a>



<h4>Method <code>setState()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Population$setState(i, state)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>the index of the agent (starting from 1)</p>
</dd>
<dt><code>state</code></dt><dd><p>a list holding the state to set</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the population object itself (invisible) for chaining actions
Set the states for the agents
</p>


<hr>
<a id="method-R6Population-setStates"></a>



<h4>Method <code>setStates()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Population$setStates(states)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>states</code></dt><dd><p>either a list holding the states (one for each agent), or a
function</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If <code>states</code> is a function then it takes a single argument
<code>i</code>, specifying the index of the agent (starting from 1), and returns
a state.
</p>



<h5>Returns</h5>

<p>the population object itself for chaining actions
</p>


<hr>
<a id="method-R6Population-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Population$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='schedule'>Schedule (attach) an event to an agent</h2><span id='topic+schedule'></span>

<h3>Description</h3>

<p>Schedule (attach) an event to an agent
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="schedule_+3A_agent">agent</code></td>
<td>
<p>an external pointer returned by newAgent</p>
</td></tr>
<tr><td><code id="schedule_+3A_event">event</code></td>
<td>
<p>an external pointer returned by newEvent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If agent is an R6 object, then we should use either
agent$schedule(event) or schedule(agent$get, event)
</p>
<p>Similarly, if event is an R6 object, then we should use
schedule(agent, event$get)
</p>

<hr>
<h2 id='setDeathTime'>set the time of death for an agent</h2><span id='topic+setDeathTime'></span>

<h3>Description</h3>

<p>set the time of death for an agent
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDeathTime_+3A_agent">agent</code></td>
<td>
<p>an external pointer returned by <code><a href="#topic+newAgent">newAgent()</a></code> or <code><a href="#topic+getAgent">getAgent()</a></code></p>
</td></tr>
<tr><td><code id="setDeathTime_+3A_time">time</code></td>
<td>
<p>the time of death, a numeric value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If agent is an R6 object, then we should use either
agent$leave() or leave(agent$get)
</p>
<p>At the time of death, the agent is removed from the simulation. Calling it
multiple times causes the agent to die at the earliest time.
</p>

<hr>
<h2 id='setState'>Set the state of the agent</h2><span id='topic+setState'></span>

<h3>Description</h3>

<p>Set the state of the agent
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="setState_+3A_agent">agent</code></td>
<td>
<p>an external pointer returned by newAgent</p>
</td></tr>
<tr><td><code id="setState_+3A_state">state</code></td>
<td>
<p>an R list giving the components of the state to be
undated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this framework, a state is a list, each named
component is called a domain. This function only updates the
values of the domain given in the &quot;value&quot; list, while leave the
other components not in the &quot;value&quot; list unchanged.
</p>
<p>If agent is an R6 object, then we should either use agent$schedule,
or use schedule(agent$get, event)
</p>

<hr>
<h2 id='setStates'>Set the state for each agent in a population</h2><span id='topic+setStates'></span>

<h3>Description</h3>

<p>Set the state for each agent in a population
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="setStates_+3A_population">population</code></td>
<td>
<p>an external pointer to a population, for example,
one returned by <code><a href="#topic+newPopulation">newPopulation()</a></code></p>
</td></tr>
<tr><td><code id="setStates_+3A_states">states</code></td>
<td>
<p>either a list holding the states (one for each agent), or a
function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>states</code> is a function then it takes a single argument
<code>i</code>, specifying the index of the agent (starting from 1), and returns
a state.
</p>

<hr>
<h2 id='Simulation'>R6 class Create and represent a Simulation object</h2><span id='topic+Simulation'></span>

<h3>Description</h3>

<p>The <a href="#topic+Simulation">Simulation</a> class inherits the <a href="#topic+Population">Population</a> class. So a simulation
manages agents and their contact. Thus, the class also inherits the
<a href="#topic+Agent">Agent</a> class. So a simulation can have its own state, and events attached
(scheduled) to it. In addition, it also manages all the transitions, using
its <code>addTransition</code> method. ASt last, it maintains loggers, which
record (or count) the state changes, and report their values at specified
times.
</p>


<h3>Super classes</h3>

<p><code>ABM::R6Agent</code> -&gt; <code>ABM::R6Population</code> -&gt; <code>R6Simulation</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-R6Simulation-new"><code>Simulation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-run"><code>Simulation$run()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-resume"><code>Simulation$resume()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-addLogger"><code>Simulation$addLogger()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-addTransition"><code>Simulation$addTransition()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-clone"><code>Simulation$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="leave"><a href='../../ABM/html/R6Agent.html#method-R6Agent-leave'><code>ABM::R6Agent$leave()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="match"><a href='../../ABM/html/R6Agent.html#method-R6Agent-match'><code>ABM::R6Agent$match()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="schedule"><a href='../../ABM/html/R6Agent.html#method-R6Agent-schedule'><code>ABM::R6Agent$schedule()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="setDeathTime"><a href='../../ABM/html/R6Agent.html#method-R6Agent-setDeathTime'><code>ABM::R6Agent$setDeathTime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="unschedule"><a href='../../ABM/html/R6Agent.html#method-R6Agent-unschedule'><code>ABM::R6Agent$unschedule()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="addAgent"><a href='../../ABM/html/R6Population.html#method-R6Population-addAgent'><code>ABM::R6Population$addAgent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="addContact"><a href='../../ABM/html/R6Population.html#method-R6Population-addContact'><code>ABM::R6Population$addContact()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="agent"><a href='../../ABM/html/R6Population.html#method-R6Population-agent'><code>ABM::R6Population$agent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="removeAgent"><a href='../../ABM/html/R6Population.html#method-R6Population-removeAgent'><code>ABM::R6Population$removeAgent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="setState"><a href='../../ABM/html/R6Population.html#method-R6Population-setState'><code>ABM::R6Population$setState()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="setStates"><a href='../../ABM/html/R6Population.html#method-R6Population-setStates'><code>ABM::R6Population$setStates()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-R6Simulation-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$new(simulation = 0, initializer = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>simulation</code></dt><dd><p>can be either an external pointer pointing to
a population object returned from newSimulation, or an integer
specifying the population size, or a list</p>
</dd>
<dt><code>initializer</code></dt><dd><p>a function or NULL</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If simulation is a number (the population size), then initializer
can be a function that take the index of an agent and return its initial
state. If it is a list, the length is the population size, and each element
corresponds to the initial state of an agent (with the same index).
Run the simulation
</p>


<hr>
<a id="method-R6Simulation-run"></a>



<h4>Method <code>run()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$run(time)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>time</code></dt><dd><p>the time points to return the logger values.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>the returned list can be coerced into a data.frame object
which first column is time, and other columns are logger results,
each row corresponds to a time point.
</p>
<p>The Simulation object first collect and log the states from all
agents in the simulation, then set the current time to the time of
the first event, then call the resume method to actually run it.
</p>
<p>Continue running the simulation
</p>



<h5>Returns</h5>

<p>a list of numeric vectors, with time and values reported
by all logger.
</p>


<hr>
<a id="method-R6Simulation-resume"></a>



<h4>Method <code>resume()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$resume(time)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>time</code></dt><dd><p>the time points to return the logger values.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>the returned list can be coerced into a data.frame object
which first column is time, and other columns are logger results,
each row corresponds to a time point.
</p>
<p>The Simulation object repetitively handle the events until the the
last time point in &quot;time&quot; is reached. ASt each time point, the
logger states are collected in put in a list to return.
Add a logger to the simulation
</p>



<h5>Returns</h5>

<p>a list of numeric vectors, with time and values reported
by all logger.
</p>


<hr>
<a id="method-R6Simulation-addLogger"></a>



<h4>Method <code>addLogger()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$addLogger(logger)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>logger, </code></dt><dd><p>an external pointer returned by functions like
newCounter or newStateLogger.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>without adding a logger, there will be no useful simulation
results returned.
Add a transition to the simulation
</p>



<h5>Returns</h5>

<p>the simulation object itself (invisible)
</p>


<hr>
<a id="method-R6Simulation-addTransition"></a>



<h4>Method <code>addTransition()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$addTransition(
  rule,
  waiting.time,
  to_change_callback = NULL,
  changed_callback = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rule</code></dt><dd><p>is a formula that gives the transition rule</p>
</dd>
<dt><code>waiting.time</code></dt><dd><p>either an external pointer to a WaitingTime object
such as one returned by newExpWaitingTime or newGammaWaitingTime, or
a function (see the details section)</p>
</dd>
<dt><code>to_change_callback</code></dt><dd><p>the R callback function to determine if
the change should occur. See the details section.</p>
</dd>
<dt><code>changed_callback</code></dt><dd><p>the R callback function after the change
happened. See the details section.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If waiting.time is a function then it should take exactly one
argument time, which is a numeric value holding the current value, and
return a single numeric value for the waiting time (i.e., should not add
time).
</p>
<p>Formula can be used to specify either a spontaneous
transition change, or a transition caused by a contact.
</p>
<p>A spontaneous transition has the form from -&gt; to, where from and
to are state specifications. It is either a variable name holding
a state (R list) or the list itself. The list can also be specified
by state(...) instead of list(...)
</p>
<p>For a spontaneous transition, the callback functions take the
following two arguments
</p>

<ol>
<li><p> time: the current time in the simulation
</p>
</li>
<li><p> agent: the agent who initiate the contact, an external pointer
</p>
</li></ol>

<p>A transition caused by contact, the formula needs to specify the
states of both the agent who initiate the contact and the contact
agent. The two states are connected by a + sign, the one before the
</p>

<ul>
<li><p> sign is the initiator, and the one after the sign is the contact.
The transition must be associated with a Contact object, using
a ~ operator. The Contact object must be specified by a variable name
that hold the external pointer to the object (created by e.g.,
the newRandomMixing function) For example, suppose S=list(&quot;S&quot;),
I=list(&quot;I&quot;), and m=newRandomMixing(sim), then a possible rule
specifying an infectious agent contacting a susceptible agent causing
it to become exposed can be
specified by
</p>
</li></ul>

<p>I + S -&gt; I + list(&quot;E&quot;) ~ m
</p>
<p>For a transition caused by a contact, the callback functions take
the third argument:
3. contact: the contact agent, an external pointer
</p>



<h5>Returns</h5>

<p>the simulation object itself (invisible)
</p>


<hr>
<a id="method-R6Simulation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='State'>The state of an agent</h2><span id='topic+State'></span>

<h3>Description</h3>

<p>In this framework, a state is a list, each named component is called a
domain. The value of a domain can be any R value. The list can be at most
one unnamed value, which corresponds to a domain with no name. This is
useful if there is only one domain.
</p>


<h3>Details</h3>

<p>A state can be matched to an R list (called a rule in this case).
The state matches the rule if and only if each domain (names of the
list) in rule has the same value as in state. The domains in domains of the
state not listed in rule are not matched. In addition, to match to a rule,
the domain values must be either a number or a character. This is useful
for identifying state changes. See <code><a href="#topic+newCounter">newCounter()</a></code> and
the <a href="#topic+Simulation">Simulation</a> class' <code>addTransition</code> method for more details.
</p>

<hr>
<h2 id='stateMatch'>Check if two states match</h2><span id='topic+stateMatch'></span>

<h3>Description</h3>

<p>Check if two states match
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="stateMatch_+3A_state">state</code></td>
<td>
<p>a list holding a state to check</p>
</td></tr>
<tr><td><code id="stateMatch_+3A_rule">rule</code></td>
<td>
<p>a list holding the state to match against</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state matches the rule if and only if each domain (names of the
list) in rule has the same value as in state. The domains in domains of the
state not listed in rule are not matched
</p>


<h3>Value</h3>

<p>a logical value
</p>

<hr>
<h2 id='unschedule'>Unschedule (detach) an event from an agent</h2><span id='topic+unschedule'></span>

<h3>Description</h3>

<p>Unschedule (detach) an event from an agent
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="unschedule_+3A_agent">agent</code></td>
<td>
<p>an external pointer returned by newAgent</p>
</td></tr>
<tr><td><code id="unschedule_+3A_event">event</code></td>
<td>
<p>an external pointer returned by newEvent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If agent is an R6 object, then we should use either
agent$unschedule(event) or unschedule(agent$get, event)
</p>
<p>Similarly, if event is an R6 object, then we should use
unschedule(agent, event$get)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
