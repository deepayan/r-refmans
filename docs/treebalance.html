<!DOCTYPE html><html><head><title>Help for package treebalance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treebalance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#areaPerPairI'><p>Calculation of the area per pair index for rooted trees</p></a></li>
<li><a href='#avgLeafDepI'><p>Calculation of the average leaf depth index for rooted trees</p></a></li>
<li><a href='#avgVertDep'><p>Calculation of the average vertex depth for rooted trees</p></a></li>
<li><a href='#B1I'><p>Calculation of the B1 index for rooted trees</p></a></li>
<li><a href='#B2I'><p>Calculation of the B2 index for rooted trees</p></a></li>
<li><a href='#cherryI'><p>Calculation of the cherry index for rooted trees</p></a></li>
<li><a href='#collessI'><p>Calculation of the Colless index for rooted binary trees</p></a></li>
<li><a href='#collesslikeI'><p>Calculation of the Colless-like indices for rooted trees</p></a></li>
<li><a href='#colPlaLab'><p>Calculation of the Colijn-Plazzotta rank for rooted binary trees</p></a></li>
<li><a href='#colPlaLab_inv'><p>Generation of the rooted binary tree corresponding to a given Colijn-Plazzotta rank</p></a></li>
<li><a href='#ewCollessI'><p>Calculation of the equal weights Colless index for rooted binary trees</p></a></li>
<li><a href='#furnasI'><p>Calculation of the Furnas rank for rooted binary trees</p></a></li>
<li><a href='#furnasI_inv'><p>Calculation of rooted binary tree for tuple (rank, leaf number)</p></a></li>
<li><a href='#getDescMatrix'><p>Auxiliary functions</p></a></li>
<li><a href='#IbasedI'><p>Calculation of the I-based indices for rooted trees</p></a></li>
<li><a href='#maxDelW'><p>Calculation of the (modified) maximum difference in widths for a rooted tree</p></a></li>
<li><a href='#maxDepth'><p>Calculation of the maximum depth of the tree</p></a></li>
<li><a href='#maxWidth'><p>Calculation of the maximum width of the tree</p></a></li>
<li><a href='#mCherryI'><p>Calculation of the modified cherry index for rooted binary trees</p></a></li>
<li><a href='#mWovermD'><p>Calculation of the maximum width over maximum depth of the tree</p></a></li>
<li><a href='#rogersI'><p>Calculation of the Rogers J index for rooted binary trees</p></a></li>
<li><a href='#rQuartetI'><p>Calculation of the rooted quartet index for rooted trees</p></a></li>
<li><a href='#sackinI'><p>Calculation of the Sackin index for rooted trees</p></a></li>
<li><a href='#sShapeI'><p>Calculation of the s-shape statistic for rooted trees</p></a></li>
<li><a href='#stairs1'><p>Calculation of the stairs1 value for rooted binary trees</p></a></li>
<li><a href='#stairs2'><p>Calculation of the stairs2 value for rooted binary trees</p></a></li>
<li><a href='#symNodesI'><p>Calculation of the symmetry nodes index for rooted binary trees</p></a></li>
<li><a href='#totCophI'><p>Calculation of the total cophenetic index for rooted trees</p></a></li>
<li><a href='#totIntPathLen'><p>Calculation of the total internal path length for rooted trees</p></a></li>
<li><a href='#totPathLen'><p>Calculation of the total path length for rooted trees</p></a></li>
<li><a href='#varLeafDepI'><p>Calculation of the variance of leaf depths index for rooted trees</p></a></li>
<li><a href='#wedEth'><p>Wedderburn Etherington numbers (from OEIS)</p></a></li>
<li><a href='#weighL1dist'><p>Calculation of weighted l1 distance index for rooted binary trees</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Computation of Tree (Im)Balance Indices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The aim of the 'R' package 'treebalance' is to provide functions for the computation of 
    a large variety of (im)balance indices for rooted trees. The package accompanies the book 
    &rdquo;Tree balance indices: a comprehensive survey&rdquo; by M. Fischer, L. Herbst, S. Kersting, 
    L. Kuehn and K. Wicke (2023) &lt;ISBN: 978-3-031-39799-8&gt;, &lt;<a href="https://doi.org/10.1007%2F978-3-031-39800-1">doi:10.1007/978-3-031-39800-1</a>&gt;, which gives a precise definition for the terms 'balance index' and 'imbalance index' (Chapter 4)
    and provides an overview of the terminology in this manual (Chapter 2). For further information 
    on (im)balance indices, see also Fischer et al. (2021) <a href="https://treebalance.wordpress.com">https://treebalance.wordpress.com</a>.
    Considering both established and new (im)balance indices, 'treebalance' provides (among 
    others) functions for calculating the following 18 established indices and index families: the 
    average leaf depth, the B1 and B2 index, the Colijn-Plazzotta rank, the normal, corrected, 
    quadratic and equal weights Colless index, the family of Colless-like indices, the family of 
    I-based indices, the Rogers J index, the Furnas rank, the rooted quartet index, the s-shape 
    statistic, the Sackin index, the symmetry nodes index, the total cophenetic index and the 
    variance of leaf depths. Additionally, we include 9 tree shape statistics that satisfy the 
    definition of an (im)balance index but have not been thoroughly analyzed in terms of tree 
    balance in the literature yet. These are: the total internal path length, the total path length, 
    the average vertex depth, the maximum width, the modified maximum difference in widths, the 
    maximum depth, the maximum width over maximum depth, the stairs1 and the stairs2 index. 
    As input, most functions of 'treebalance' require a rooted (phylogenetic) tree in 'phylo' format 
    (as introduced in 'ape' 1.9 in November 2006). 'phylo' is used to store (phylogenetic) trees 
    with no vertices of out-degree one. For further information on the format we kindly refer the 
    reader to E. Paradis (2012) <a href="http://ape-package.ird.fr/misc/FormatTreeR_24Oct2012.pdf">http://ape-package.ird.fr/misc/FormatTreeR_24Oct2012.pdf</a>.</td>
</tr>
<tr>
<td>Author:</td>
<td>Mareike Fischer [aut],
  Lina Herbst [aut],
  Sophie Kersting [aut],
  Luise Kuehn [aut, cre],
  Kristina Wicke [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luise Kuehn &lt;treebalanceindices@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, memoise, gmp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-14 08:29:24 UTC; kuehnl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-14 10:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='areaPerPairI'>Calculation of the area per pair index for rooted trees</h2><span id='topic+areaPerPairI'></span>

<h3>Description</h3>

<p>This function calculates the area per pair index <code class="reqn">APP(T)</code> for a given rooted
tree <code class="reqn">T</code>. The tree must not necessarily be binary. <code class="reqn">APP(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">APP(T)=\frac{2}{n\cdot(n-1)}\cdot\sum_{1\leq i&lt;j\leq n} d_T(i,j)</code>
</p>
<p> in which <code class="reqn">n</code> denotes the
number of leaves in <code class="reqn">T</code>, and
<code class="reqn">d_T(i,j)</code> denotes the number of edges on the path between the two
leaves <code class="reqn">i</code> and <code class="reqn">j</code>. Note that <code class="reqn">APP(T)</code> can also be
computed from the Sackin index <code class="reqn">S(T)</code> and the total cophenetic
index <code class="reqn">TCI(T)</code> of <code class="reqn">T</code> as
<code class="reqn">APP(T)=\frac{2}{n}\cdot S(T)-\frac{4}{n(n-1)}\cdot TCI(T)</code>
enabling efficient computation.<br /><br />
The area per pair index does not fulfill the definition of an (im)balance
index given in &quot;Tree balance indices: a comprehensive survey&quot; (Fischer et al., 2023). <br /><br />
For details on the area per pair index, see 
also Chapter 24 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_24).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areaPerPairI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areaPerPairI_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>areaPerPairI</code> returns the area per pair index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>T. Araujo Lima, F. M. D. Marquitti, and M. A. M. de Aguiar. Measuring Tree Balance with Normalized Tree Area. arXiv e-prints, art. arXiv:2008.12867, 2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
areaPerPairI(tree)

</code></pre>

<hr>
<h2 id='avgLeafDepI'>Calculation of the average leaf depth index for rooted trees</h2><span id='topic+avgLeafDepI'></span>

<h3>Description</h3>

<p>This function calculates the average leaf depth <code class="reqn">N(T)</code> for a given
rooted tree <code class="reqn">T</code>. The tree must not necessarily be binary. <code class="reqn">N(T)</code> is
defined as </p>
<p style="text-align: center;"><code class="reqn">N(T)=\frac{1}{n}\cdot\sum_{u\in V_{in}(T)} n_u</code>
</p>
<p> in which <code class="reqn">n</code> denotes the number of leaves in <code class="reqn">T</code>,
<code class="reqn">V_{in}(T)</code> denotes the set of inner nodes of <code class="reqn">T</code> and
<code class="reqn">n_u</code> denotes the number of leaves in the pending subtree that is rooted
at the inner node <code class="reqn">u</code>. Note that <code class="reqn">N(T)</code> can also be
computed from the Sackin index <code class="reqn">S(T)</code> as <code class="reqn">N(T)=\frac{1}{n}\cdot S(T)</code>.
The average leaf depth is an imbalance index.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">N(T)=0</code> and a warning. <br /><br />
For details on the average leaf depth, see also Chapter 6 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_6).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avgLeafDepI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avgLeafDepI_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>avgLeafDepI</code> returns the average leaf depth of the given tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>M. J. Sackin. &quot;Good&quot; and &quot;Bad&quot; Phenograms. Systematic Biology, 21(2):225-226, 1972. doi: 10.1093/sysbio/21.2.225.
</p>
<p>K.-T. Shao and R. R. Sokal. Tree Balance. Systematic Zoology, 39(3):266, 1990. <br /> doi: 10.2307/2992186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
avgLeafDepI(tree)

</code></pre>

<hr>
<h2 id='avgVertDep'>Calculation of the average vertex depth for rooted trees</h2><span id='topic+avgVertDep'></span>

<h3>Description</h3>

<p>This function calculates the average vertex depth <code class="reqn">AVD(T)</code> for a given rooted
tree <code class="reqn">T</code>. The tree must not necessarily be binary. <code class="reqn">AVD(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">AVD(T)=\frac{1}{|V(T)|}\cdot\sum_{x\in V(T)} \delta(x)</code>
</p>
<p> in
which <code class="reqn">V(T)</code> denotes the set of vertices of <code class="reqn">T</code>, and <code class="reqn">\delta(x)</code>
denotes the depth of the vertex <code class="reqn">x</code>. The average vertex depth is a normalised version of the total path length and an
imbalance index.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">AVD(T)=0</code> and a warning. <br /><br />
For details on the average vertex depth, see 
also Chapter 23 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_23).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avgVertDep(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avgVertDep_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>avgVertDep</code> returns the average vertex depth of the given tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>A. Herrada et al. Scaling properties of protein family phylogenies. BMC Evolutionary Biology, 11(1), June 2011. doi: 10.1186/1471-2148-11-155.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,,),),(,)));")
avgVertDep(tree)

</code></pre>

<hr>
<h2 id='B1I'>Calculation of the B1 index for rooted trees</h2><span id='topic+B1I'></span>

<h3>Description</h3>

<p>This function calculates the <code class="reqn">B1</code> index <code class="reqn">B1(T)</code> for a given rooted
tree <code class="reqn">T</code>. The tree must not necessarily be binary. <code class="reqn">B1(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">B1(T)=\sum_{u\in V_{in}(T)\setminus\{\rho\}} h(T_u)^{-1}</code>
</p>
<p> in which
<code class="reqn">V_{in}(T)\setminus\{\rho\}</code> denotes the set of inner vertices of <code class="reqn">T</code> without the root, and
<code class="reqn">h(T_u)</code> denotes the height of the pending subtree rooted at <code class="reqn">u</code>.
When restricted to binary trees, the <code class="reqn">B1</code> index is a balance index. For
arbitrary trees it does not fulfill the definition of an (im)balance index.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">B1(T)=0</code> and a warning. <br /><br />
For details on the B1 index, see 
also Chapter 10 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_10).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B1I(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B1I_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>B1I</code> returns the B1 index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>K.-T. Shao and R. R. Sokal. Tree Balance. Systematic Zoology, 39(3):266, 1990. <br /> doi: 10.2307/2992186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
B1I(tree)

</code></pre>

<hr>
<h2 id='B2I'>Calculation of the B2 index for rooted trees</h2><span id='topic+B2I'></span>

<h3>Description</h3>

<p>This function calculates the B2 index <code class="reqn">B2(T)</code> for a given rooted
tree <code class="reqn">T</code>. The tree must not necessarily be binary. <code class="reqn">B2(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">B2(T)=-\sum_{x\in V_L(T)} p_x\cdot log(p_x)</code>
</p>
<p> in which <code class="reqn">V_L(T)</code> denotes the leaf
set of <code class="reqn">T</code>, and in which </p>
<p style="text-align: center;"><code class="reqn">p_x=\prod_{v\in anc(x)} \frac{1}{|child(v)|}</code>
</p>
<p> denotes
the probability of reaching leaf <code class="reqn">x</code> when starting at the root and assuming
equiprobable branching at each vertex <code class="reqn">v\in anc(x)</code> with <code class="reqn">anc(x)</code>
denoting the set of ancestors of <code class="reqn">x</code> excluding
<code class="reqn">x</code>. <code class="reqn">child(v)</code> denotes the set of children of the inner vertex <code class="reqn">v</code>.<br />
The <code class="reqn">B2</code> index is a balance index.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">B2(T)=0</code> and a warning. <br /><br />
For details on the B2 index, see 
also Chapter 11 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_11).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B2I(tree, logbase = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B2I_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
<tr><td><code id="B2I_+3A_logbase">logbase</code></td>
<td>
<p>The base that shall be used for the logarithm. For binary
trees it is common to use base 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>B2I</code> returns the B2 index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting, Luise Kuehn
</p>


<h3>References</h3>

<p>K.-T. Shao and R. R. Sokal. Tree Balance. Systematic Zoology, 39(3):266, 1990. <br /> doi: 10.2307/2992186.
</p>
<p>P.-M. Agapow and A. Purvis. Power of Eight Tree Shape Statistics to Detect Nonrandom Diversification: A Comparison by Simulation of Two Models of Cladogenesis. Systematic Biology, 51(6):866-872, 2002.doi: 10.1080/10635150290102564. <br /> URL https://doi.org/10.1080/10635150290102564.
</p>
<p>M. Hayati, B. Shadgar, and L. Chindelevitch. A new resolution function to evaluate tree shape statistics. PLOS ONE, 14(11):e0224197, 2019. doi: 10.1371/journal.pone.0224197.<br /> URL https://doi.org/10.1371/journal.pone.0224197.
</p>
<p>M. Kirkpatrick and M. Slatkin. Searching for evolutionary patterns in the shape of a phylogenetic tree. Evolution, 47(4):1171-1181, 1993. doi: 10.1111/j.1558-5646.1993.tb02144.x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
B2I(tree)

</code></pre>

<hr>
<h2 id='cherryI'>Calculation of the cherry index for rooted trees</h2><span id='topic+cherryI'></span>

<h3>Description</h3>

<p>This function calculates the cherry index <code class="reqn">ChI(T)</code> for a
given rooted tree <code class="reqn">T</code>. The tree must not necessarily be binary.
<code class="reqn">ChI(T)</code> is defined as the number of cherries in the tree. A cherry
is a pair of leaves that have the same direct ancestor. Note, if a vertex <code class="reqn">u</code>
has <code class="reqn">x</code> leaves as direct descendants, the number of cherries induced by <code class="reqn">u</code> is
<code class="reqn">binom(x,2)</code>. <br /><br />
The cherry index does not fulfill the definition
of an (im)balance index given in &quot;Tree balance indices: a comprehensive survey&quot;
(Fischer et al., 2023). <br /><br />
For details on the cherry index, see 
also Chapter 24 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_24).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cherryI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cherryI_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cherryI</code> returns the cherry index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>A. McKenzie and M. Steel. Distributions of cherries for two models of trees. Mathematical Biosciences, 164(1):81-92, 2000. doi: 10.1016/s0025-5564(99)00060-7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
cherryI(tree)
tree &lt;- ape::read.tree(text="((,),((((,),),),(,)));")
cherryI(tree)
tree &lt;- ape::read.tree(text="((,,,),(,,));")
cherryI(tree)

</code></pre>

<hr>
<h2 id='collessI'>Calculation of the Colless index for rooted binary trees</h2><span id='topic+collessI'></span>

<h3>Description</h3>

<p>This function calculates variants of the Colless index for a given rooted
binary tree <code class="reqn">T</code>. All of them are imbalance indices.<br /><br />
The original Colless index <code class="reqn">C(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">C(T)=\sum_{u \in V_{in}(T)} |n_{u_a}-n_{u_b}|</code>
</p>

<p>in which <code class="reqn">V_{in}(T)</code> denotes the set of all inner vertices
of <code class="reqn">T</code>, and in which <code class="reqn">n_{u_a}</code>
and <code class="reqn">n_{u_b}</code> denote the number of leaves in the two pending subtrees that are
rooted at the direct descendants of <code class="reqn">u</code>. <br /><br />
The corrected Colless index <code class="reqn">I_C(T)</code> of <code class="reqn">T</code> is defined as <code class="reqn">I_C(T)=0</code> for
<code class="reqn">n=1</code> and <code class="reqn">n=2</code> and for <code class="reqn">n&gt;2</code> as
</p>
<p style="text-align: center;"><code class="reqn">I_C(T)=\frac{2\cdot C(T)}{(n-1)\cdot(n-2)}</code>
</p>

<p>in which <code class="reqn">n</code> denotes the
total number of leaves in <code class="reqn">T</code>. <br /><br />
The quadratic Colless index <code class="reqn">QC(T)</code> of <code class="reqn">T</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">QC(T)=\sum_{u\in V_{in}(T)} |n_{u_a}-n_{u_b}|^2</code>
</p>
 <p><br /><br />
Special cases: For <code class="reqn">n=1</code> the function returns <code class="reqn">C(T)=I_C(T)=QC(T)=0</code> and a warning. <br /><br />
For details on the original, corrected and quadratic Colless indices, see 
also Chapters 12, 13 and 15 in &quot;Tree balance indices: a comprehensive survey&quot; 
(https://doi.org/10.1007/978-3-031-39800-1_12, https://doi.org/10.1007/978-3-031-39800-1_13, 
https://doi.org/10.1007/978-3-031-39800-1_15).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collessI(tree, method = "original")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collessI_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
<tr><td><code id="collessI_+3A_method">method</code></td>
<td>
<p>A character string specifying the version that shall be computed.
It can be one of the following: &quot;original&quot;, &quot;corrected&quot;, &quot;quadratic&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>collessI</code> returns the Colless index of the given tree according to the chosen method.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn and Sophie Kersting
</p>


<h3>References</h3>

<p>D. Colless. Review of Phylogenetics: the theory and practice of phylogenetic systematics. Systematic Zoology, 1982. ISSN 00397989.
</p>
<p>T. M. Coronado, M. Fischer, L. Herbst, F. Rossello, and K. Wicke. On the minimum value of the Colless index and the bifurcating trees that achieve it. Journal of Mathematical Biology, 2020.doi: 10.1007/s00285-020-01488-9.
</p>
<p>S. B. Heard. Patterns in tree balance among cladistic, phenetic, and randomly generated phylogenetic trees. Evolution, 1992. doi: 10.1111/j.1558-5646.1992.tb01171.x.
</p>
<p>K. Bartoszek, T. M. Coronado, A. Mir, and F. Rossello. Squaring within the Colless index yields a better balance index. Mathematical Biosciences, 331:108503, 2021. doi: 10.1016/j.mbs.2020.108503.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
collessI(tree, method="original")
collessI(tree, method="corrected")
collessI(tree, method="quadratic")

</code></pre>

<hr>
<h2 id='collesslikeI'>Calculation of the Colless-like indices for rooted trees</h2><span id='topic+collesslikeI'></span>

<h3>Description</h3>

<p>This function calculates the Colless-like index for a given rooted
tree <code class="reqn">T</code> according to the chosen weight function <code class="reqn">f</code> and dissimilarity <code class="reqn">D</code>.
The Colless-like index <code class="reqn">CL(T)</code>
relative to <code class="reqn">D</code> and <code class="reqn">f</code> is the sum of the <code class="reqn">(D,f)</code>-balance values
over all inner vertices of the tree. More precisely,
</p>
<p style="text-align: center;"><code class="reqn">CL(T)=\sum_{v\in V_{in}(T)} bal_{D,f}(v)</code>
</p>

<p>where <code class="reqn">V_{in}(T)</code> is the
set of inner vertices of <code class="reqn">T</code>. The <code class="reqn">(D,f)</code>-balance value
of <code class="reqn">v</code> with children <code class="reqn">v_1,...,v_k</code> is computed as
</p>
<p style="text-align: center;"><code class="reqn">bal_{D,f}(v)=D(fs(T_{v_1}),...,fs(T_{v_k}))</code>
</p>

<p>with <code class="reqn">D</code> denoting the dissimilarity and <code class="reqn">fs</code> denoting the f.size.<br />
The f.size <code class="reqn">fs(T)</code> of a tree <code class="reqn">T</code> uses the function <code class="reqn">f</code>, which maps any
integer to a non-negative real number, to build a weighted sum of
the out-degrees of all vertices in <code class="reqn">T</code>. More precisely,
</p>
<p style="text-align: center;"><code class="reqn">fs(T)=\sum_{v\in V(T)} f(deg+(v))</code>
</p>

<p>where <code class="reqn">V(T)</code> is the set of all
vertices of <code class="reqn">T</code> and <code class="reqn">deg+(v)</code> denotes the out-degree (i.e. the number of
children) of the vertex <code class="reqn">v</code>. The <code class="reqn">f</code>-functions that are already
implemented are <code class="reqn">f(x)=e^x</code> and <code class="reqn">f(x)=ln(x+e)</code>.<br />
The dissimilarity <code class="reqn">D(x_1,...,x_k)</code> of a vector <code class="reqn">x_1,...,x_k</code> assigns
a non-negative value to the vector, is independent of the order of the vector
entries and equals zero if and only if <code class="reqn">x_1=...=x_k</code>. In this
implementation the following dissimilarity functions are already built-in:
mean deviation from the median (<code class="reqn">mdm</code>),
the sample variance (<code class="reqn">var</code>) and the sample standard deviation (<code class="reqn">sd</code>).<br />
<code>collesslikeI</code> also allows the use of other functions for the weight function <code class="reqn">f</code>
and the dissimilarity <code class="reqn">D</code>.<br /><br />
Special cases: For <code class="reqn">n=1</code> the function returns <code class="reqn">CL(T)=0</code> and a warning. <br /><br />
For details on the family of Colless-like indices, see 
also Chapter 16 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_16).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collesslikeI(tree, f.size, dissim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collesslikeI_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
<tr><td><code id="collesslikeI_+3A_f.size">f.size</code></td>
<td>
<p>A character string specifying the function <code class="reqn">f</code> that shall be used to compute the f.size.
It can be one of the following: &quot;exp&quot;, &quot;ln&quot; or the name of a function as a string.</p>
</td></tr>
<tr><td><code id="collesslikeI_+3A_dissim">dissim</code></td>
<td>
<p>A character string specifying the dissimilarity that shall be
used. It can be one of the following: &quot;mdm&quot;, &quot;var&quot;, &quot;sd&quot; or the name of a function as a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>collesslikeI</code> returns the Colless-like index of the given tree according to the chosen
function and dissimilarity.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn, Sophie Kersting
</p>


<h3>References</h3>

<p>A. Mir, L. Rotger, and F. Rossello. Sound Colless-like balance indices for multifurcating trees. PLOSONE, 13(9):e0203401, 2018. doi: 10.1371/journal.pone.0203401
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
collesslikeI(tree, f.size="exp", dissim="mdm")
collesslikeI(tree, f.size="exp", dissim="var")
collesslikeI(tree, f.size="ln", dissim="sd")
myfsize &lt;- function(x) return(x+1)
mydissim &lt;- function(x) return (var(x))
collesslikeI(tree, f.size="myfsize",dissim = "mydissim")

</code></pre>

<hr>
<h2 id='colPlaLab'>Calculation of the Colijn-Plazzotta rank for rooted binary trees</h2><span id='topic+colPlaLab'></span>

<h3>Description</h3>

<p>This function calculates the Colijn-Plazzotta rank <code class="reqn">CP(T)</code> for a
given rooted binary tree <code class="reqn">T</code>.<br /><br />
For a binary tree <code class="reqn">T</code>, the Colijn-Plazzotta rank <code class="reqn">CP(T)</code> is
recursively defined as <code class="reqn">CP(T)=1</code> if <code class="reqn">T</code> consists of only
one leaf and otherwise
</p>
<p style="text-align: center;"><code class="reqn">CP(T)=\frac{1}{2}\cdot CP(T_1)\cdot(CP(T_1)-1)+CP(T_2)+1</code>
</p>

<p>with <code class="reqn">CP(T_1) \geq CP(T_2)</code> being the ranks of the two pending
subtrees rooted at the children of the root of <code class="reqn">T</code>. This rank
of <code class="reqn">T</code> corresponds to its position in the
lexicographically sorted list of (<code class="reqn">i,j</code>): (1),(1,1),(2,1),(2,2),(3,1),...
The Colijn-Plazzotta rank of binary trees has been shown to be an imbalance index.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">CP(T)=1</code> and a warning.<br /><br />
Note that problems can sometimes arise even for trees with small leaf numbers due
to the limited range of computable values (ranks can reach INF quickly). <br /><br />
For details on the Colijn-Plazzotta rank, see 
also Chapter 21 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_21).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colPlaLab(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colPlaLab_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>colPlaLab</code> returns the Colijn-Plazotta rank of the given tree. Since the values can get quite large, the
function returns them in big.z format (package gmp).
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting, Luise Kuehn
</p>


<h3>References</h3>

<p>C. Colijn and G. Plazzotta. A Metric on Phylogenetic Tree Shapes. Systematic Biology, doi: 10.1093/sysbio/syx046.
</p>
<p>N. A. Rosenberg. On the Colijn-Plazzotta numbering scheme for unlabeled binary rooted trees. Discrete Applied Mathematics, 2021. doi: 10.1016/j.dam.2020.11.021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
colPlaLab(tree)

</code></pre>

<hr>
<h2 id='colPlaLab_inv'>Generation of the rooted binary tree corresponding to a given Colijn-Plazzotta rank</h2><span id='topic+colPlaLab_inv'></span>

<h3>Description</h3>

<p>This function generates the unique rooted binary tree <code class="reqn">T</code> (in phylo
format) that corresponds to the given Colijn-Plazzotta rank <code class="reqn">CP(T)</code>. It
is the inverse function of colPlaLab(). <br /><br />
<code>colPlaLab()</code>:
For a given rooted binary tree <code class="reqn">T</code>, <code class="reqn">CP(T)</code> is recursively defined as
<code class="reqn">CP(T)=1</code> if <code class="reqn">T</code> consists of only one vertex and otherwise
<code class="reqn">CP(T)=\frac{1}{2}\cdot CP(T_1)\cdot(CP(T_1)-1)+CP(T_2)+1</code> with
<code class="reqn">CP(T_1) \geq CP(T_2)</code> being the
ranks of the two pending subtrees rooted at the children of the root of <code class="reqn">T</code>.
The rank <code class="reqn">CP(T)</code> of <code class="reqn">T</code> corresponds to its position in the
lexicographically sorted list of (<code class="reqn">i,j</code>): (1),(1,1),(2,1),(2,2),(3,1),... <br /><br />
<code>colPlaLab_inv()</code>:
For a given rank <code class="reqn">CP</code> the corresponding tree <code class="reqn">T</code> can be reconstructed
by starting from one vertex <code class="reqn">\rho</code> (labelled <code class="reqn">CP</code>) and recursively
splitting vertices whose labels <code class="reqn">h</code> are greater than 1 into two children with the labels:
</p>
<p style="text-align: center;"><code class="reqn">i=\left\lceil\frac{1+\sqrt{8\cdot h-7}}{2}\right\rceil-1</code>
</p>
<p> and
</p>
<p style="text-align: center;"><code class="reqn">j=h-\frac{i\cdot(i-1)}{2}-1</code>
</p>

<p>until there are no more vertices to split. <br />
For <code class="reqn">CP=1</code> the function returns the smallest possible tree in the
phylo format: the tree consisting of a single edge.<br /><br />
Note that problems can arise for extremely high input values (&gt;10e+18). <br /><br />
For details on the Colijn-Plazzotta rank, see 
also Chapter 21 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_21).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colPlaLab_inv(rank)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colPlaLab_inv_+3A_rank">rank</code></td>
<td>
<p>An integer denoting the Colijn-Plazzotta rank of the sought tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>colPlaLab_inv</code> returns the unique rooted binary tree for the given rank.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>C. Colijn and G. Plazzotta. A Metric on Phylogenetic Tree Shapes. Systematic Biology, 67(1):113-126,2018. doi: 10.1093/sysbio/syx046.
</p>
<p>N. A. Rosenberg. On the Colijn-Plazzotta numbering scheme for unlabeled binary rooted trees. Discrete Applied Mathematics, 291:88-98, 2021. doi: 10.1016/j.dam.2020.11.021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colPlaLab_inv(22)

</code></pre>

<hr>
<h2 id='ewCollessI'>Calculation of the equal weights Colless index for rooted binary trees</h2><span id='topic+ewCollessI'></span>

<h3>Description</h3>

<p>This function calculates the equal weights Colless index <code class="reqn">I_2(T)</code> for a
given rooted binary tree <code class="reqn">T</code>. <code class="reqn">I_2(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">I_2(T)=\frac{1}{n-2}\cdot\sum_{u\in V_{in}(T), n_u&gt;2} \frac{|n_{u_a}-n_{u_b}|}{n_u-2}</code>
</p>

<p>in which <code class="reqn">V_{in}(T)</code> denotes the set of all inner vertices of <code class="reqn">T</code>,
and in which <code class="reqn">n_u</code>, <code class="reqn">n_{u_a}</code> and <code class="reqn">n_{u_b}</code> denote the number of
leaves in the pending subtrees that are rooted at <code class="reqn">u</code> and the two direct
descendants of <code class="reqn">u</code>. The equal weights Colless index is an imbalance index.<br /><br />
For <code class="reqn">n=1</code> and <code class="reqn">n=2</code> the function returns <code class="reqn">I_2(T)=0</code> and a warning. <br /><br />
For details on the equal weigths Colless index, see 
also Chapter 14 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_14).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewCollessI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewCollessI_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ewCollessI</code> returns the equal weights Colless index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>A. O. Mooers and S. B. Heard. Inferring Evolutionary Process from Phylogenetic Tree Shape. The Quarterly Review of Biology, 72(1), 1997. doi: 10.1086/419657.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
ewCollessI(tree)

</code></pre>

<hr>
<h2 id='furnasI'>Calculation of the Furnas rank for rooted binary trees</h2><span id='topic+furnasI'></span>

<h3>Description</h3>

<p>This function calculates the Furnas rank <code class="reqn">F(T)</code> for a given rooted
binary tree <code class="reqn">T</code>. <code class="reqn">F(T)</code> is the unique rank of the tree <code class="reqn">T</code>
among all rooted binary trees with <code class="reqn">n</code> leaves in the left-light rooted
ordering. For details on the left-light rooted ordering as well as details
on how the Furnas rank is computed, see &quot;The generation
of random, binary unordered trees&quot; by G.W. Furnas (1984) or &quot;Tree balance
indices: a comprehensive survey&quot; by Fischer et al. (2023). The Furnas rank
is a balance index.<br /><br />
The concept of assigning each rooted binary tree a unique tuple <code class="reqn">(rank, n)</code>
allows to store many trees with minimal storage use. <br /><br />
For details on the Furnas rank, see 
also Chapter 22 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_22).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>furnasI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="furnasI_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>furnasI</code> returns the unique Furnas rank of the given tree, i.e.
the rank of the tree among all rooted binary trees with <code class="reqn">n</code> leaves in the
left-light rooted ordering. Since the values can get quite large, the function
returns them in <code class="reqn">big.z</code> format (package <code class="reqn">gmp</code>).
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn, Lina Herbst
</p>


<h3>References</h3>

<p>G. W. Furnas. The generation of random, binary unordered trees. Journal of Classification, 1984. doi: 10.1007/bf01890123. URL https://doi.org/10.1007/bf01890123.
</p>
<p>M. Kirkpatrick and M. Slatkin. Searching for evolutionary patterns in the shape of a phylogenetic tree. Evolution, 1993. doi: 10.1111/j.1558-5646.1993.tb02144.x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
furnasI(tree)

</code></pre>

<hr>
<h2 id='furnasI_inv'>Calculation of rooted binary tree for tuple (rank, leaf number)</h2><span id='topic+furnasI_inv'></span>

<h3>Description</h3>

<p>This function calculates the unique tree <code class="reqn">T</code> (in phylo format) for two
given integer values <code class="reqn">r</code> and <code class="reqn">n</code>, with <code class="reqn">n</code> denoting the number
of leaves of <code class="reqn">T</code> and <code class="reqn">r</code> denoting the rank of <code class="reqn">T</code> in the
left-light rooted ordering of all rooted binary trees with <code class="reqn">n</code> leaves.
It is the inverse function of <code>furnasI()</code>. For details on how to calculate
<code class="reqn">T</code> (including algorithm) see &quot;The generation of random, binary
unordered trees&quot; by G.W. Furnas (1984) or &quot;Tree balance indices: a comprehensive
survey&quot; by Fischer et al. (2023).<br /><br />
<code>furnasI_inv</code> can be used e.g. to generate random rooted binary trees with a
certain number of leaves. Also, the concept of assigning each rooted binary
tree a unique tuple <code class="reqn">(rank, n)</code> allows to store many trees with minimal
storage use. <br /><br />
For details on the Furnas rank, see 
also Chapter 22 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_22).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>furnasI_inv(rank, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="furnasI_inv_+3A_rank">rank</code></td>
<td>
<p>An integer denoting the rank of the sought tree among all rooted
binary trees with <code class="reqn">n</code> leaves.</p>
</td></tr>
<tr><td><code id="furnasI_inv_+3A_n">n</code></td>
<td>
<p>An integer denoting the number of leaves of the sought tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>furnasI_inv</code> returns the unique tree (in phylo format) for
the given leaf number and rank.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>G. W. Furnas. The generation of random, binary unordered trees. Journal of Classification, 1984. doi: 10.1007/bf01890123. URL https://doi.org/10.1007/bf01890123.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>furnasI_inv(rank=6,n=8)

</code></pre>

<hr>
<h2 id='getDescMatrix'>Auxiliary functions</h2><span id='topic+getDescMatrix'></span><span id='topic+getAncVec'></span><span id='topic+getNodesOfDepth'></span><span id='topic+symBucketLexicoSort'></span><span id='topic+getAllAncestors'></span><span id='topic+cPL_inv'></span><span id='topic+maxDepthLeaf'></span><span id='topic+get.subtreesize'></span><span id='topic+getlca'></span><span id='topic+we_eth'></span><span id='topic+getfurranks'></span><span id='topic+getsubtree'></span><span id='topic+is_binary'></span><span id='topic+is_phylo'></span><span id='topic+tree_decomposition'></span><span id='topic+tree_merge'></span><span id='topic+treenumber'></span><span id='topic+treenumber_inv'></span><span id='topic+auxE_l_X'></span>

<h3>Description</h3>

<p><code>getDescMatrix</code> - Creates a matrix that contains the descendants of
node <code class="reqn">i</code> in row <code class="reqn">i</code>.
</p>
<p><code>getAncVec</code> - Creates a vector that contains the parent (direct ancestor) of
node <code class="reqn">i</code> at position <code class="reqn">i</code>.
</p>
<p><code>getNodesOfDepth</code> - Creates a matrix that contains the nodes of
depth <code class="reqn">i</code> in row <code class="reqn">i</code>.
</p>
<p><code>symBucketLexicoSort</code> - Sorts the pairs of numbers lexicographically and
returns ranking. Uses bucket sort.
</p>
<p><code>getAllAncestors</code> - Returns all ancestors of <code class="reqn">v</code> including <code class="reqn">v</code> itself.
</p>
<p><code>cPL_inv</code> - Returns the binary tree that belongs to the input label in an incomplete
Newick format.
</p>
<p><code>maxDepthLeaf</code> - Returns the maximumy&lt; depth of a leaf in the subtree that
is rooted at <code class="reqn">v</code>.
</p>
<p><code>get.subtreesize</code> - Creates a vector that contains at the <code class="reqn">i</code>-th position
the number of leaves in the pending subtree rooted at <code class="reqn">i</code>.
</p>
<p><code>getlca</code> - Returns the name of the lowest common ancestor of the two
input vertices <code class="reqn">v</code> and <code class="reqn">w</code>.
</p>
<p><code>we_eth</code> - Returns the Wedderburn-Etherington number <code class="reqn">we(n)</code>
for a given non-negative integer <code class="reqn">n</code>.
</p>
<p><code>getfurranks</code> - Returns for each vertex <code class="reqn">i</code> the Furnas rank of the
subtree rooted at <code class="reqn">i</code>.
</p>
<p><code>getsubtree</code> - Returns the pending subtree (in phylo format) that is
rooted at the input vertex. If the input vertex is a leaf, the function returns
the standard tree for <code class="reqn">n=1</code> (with 1 edge).
</p>
<p><code>is_binary</code> - Returns TRUE if the input tree is binary and FALSE otherwise.
</p>
<p><code>is_phylo</code> - Tests all requirements of the phylo format, and returns TRUE
if the tree is correctly formatted, else FALSE with detailed feedback on the
features that are not met.
</p>
<p><code>tree_decomposition</code> - Returns a list of length two, which
contains the two pending subtrees that are rooted at the children of the root
of the input tree. The
smaller one (according to the number of leaves) is stated first.
</p>
<p><code>tree_merge</code> - Returns a rooted tree <code class="reqn">T</code> in phylo
format, which contains the input trees <code class="reqn">tree1</code> and <code class="reqn">tree2</code> as
&quot;left&quot; and &quot;right&quot; maximal pending subtrees.
</p>
<p><code>treenumber</code> - Returns the unique tree number <code class="reqn">tn(T)</code> of the given tree.
<code class="reqn">tn(T)</code> is the rank of the tree <code class="reqn">T</code> among all
rooted binary trees in the left-light rooted ordering. It can
be calculated as follows: </p>
<p style="text-align: center;"><code class="reqn">tn(T)=F(T) + \sum_{i=1}^{n-1} we(i)</code>
</p>

<p>in which <code class="reqn">n</code> is the number of leaves in <code class="reqn">T</code>, <code class="reqn">F(T)</code> is the Furnas
rank of <code class="reqn">T</code>, i.e. the rank of <code class="reqn">T</code> in the left-light rooted ordering
of all rooted binary trees with <code class="reqn">n</code> leaves, and <code class="reqn">we(i)</code> is the
Wedderburn-Etherington number of <code class="reqn">i</code>.
The concept of assigning each rooted binary tree a unique tree number allows
to store many trees with minimal storage use.
For <code class="reqn">n=1</code> the function returns <code class="reqn">tn(T)=1</code> and a warning.
</p>
<p><code>treenumber_inv</code> - Returns the unique tree (in phylo format) for
the given tree number.
</p>
<p><code>auxE_l_X</code> - Returns the sum of all products of l different values in X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDescMatrix(tree)

getAncVec(tree)

getNodesOfDepth(mat, root, n)

symBucketLexicoSort(workLabs)

getAllAncestors(tree, v)

cPL_inv(label)

maxDepthLeaf(tree, v = length(tree$tip.label) + 1)

get.subtreesize(tree)

getlca(tree, v, w)

we_eth(n)

getfurranks(tree)

getsubtree(tree, subroot)

is_binary(tree)

is_phylo(tree)

tree_decomposition(tree)

tree_merge(tree1, tree2)

treenumber(tree)

treenumber_inv(treenum)

auxE_l_X(subX, Xset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDescMatrix_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format, &gt;= 2 leaves</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_mat">mat</code></td>
<td>
<p>Descendants matrix from <code>getDescMatrix</code></p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_root">root</code></td>
<td>
<p>Number (label) of the root of the tree</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_n">n</code></td>
<td>
<p>Number of leaves of the tree</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_worklabs">workLabs</code></td>
<td>
<p>numeric matrix (2 columns)</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_v">v</code></td>
<td>
<p>A vertex of the tree.</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_label">label</code></td>
<td>
<p>A Colijn-Plazotta label of desired tree, a positive integer.</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_w">w</code></td>
<td>
<p>A vertex of the tree.</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_subroot">subroot</code></td>
<td>
<p>A vertex of the tree. It is not recommended to use
leaves as subroots.</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_tree1">tree1</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_tree2">tree2</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_treenum">treenum</code></td>
<td>
<p>An integer denoting the tree number of the sought tree.</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_subx">subX</code></td>
<td>
<p>integer &gt;=1, size of the subsets of X.</p>
</td></tr>
<tr><td><code id="getDescMatrix_+3A_xset">Xset</code></td>
<td>
<p>Vector (multiset) of numeric values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>desc_mat</code> numeric matrix
</p>
<p><code>anc_vec</code> numeric vector
</p>
<p><code>nodes_of_depth</code> numeric matrix
</p>
<p><code>ranking</code> numeric vector
</p>
<p><code>vectorWithAncs</code> numeric vector
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting, Luise Kuehn and Lina Herbst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- cbind(c(7,7,6,5,5,6),c(1,2,3,4,6,7))
tree &lt;- list(edge=mat, tip.label=c("","","",""), Nnode=3)
getDescMatrix(tree)
mat &lt;- cbind(c(5,5,5,5),c(1,2,3,4))
tree &lt;- list(edge=mat, tip.label=c("","","",""), Nnode=1)
getDescMatrix(tree)
getAncVec(tree)
getNodesOfDepth(mat=getDescMatrix(tree),root=length(tree$tip.label)+1,
n=length(tree$tip.label))
myWorkLabs &lt;- cbind(c(0,1,2,3,1,0),c(0,2,2,4,1,0))
symBucketLexicoSort(myWorkLabs)
getAllAncestors(tree,v=6)
cPL_inv(label=6)
maxDepthLeaf(tree,v=6)
get.subtreesize(tree)
getlca(tree,1,2)
we_eth(5)
getfurranks(tree)
getsubtree(tree,4)
is_binary(ape::read.tree(text="((((,),),(,)),(((,),),(,)));"))
is_phylo(ape::read.tree(text="((((,),),(,)),(((,),),(,)));"))
tree_decomposition(ape::read.tree(text="((((,),),(,)),(((,),),(,)));"))
treeA &lt;- ape::read.tree(text="(((,),),(,));")
treeB &lt;- ape::read.tree(text="((,),);")
tree_merge(treeA, treeB)
treenumber(ape::read.tree(text="((((,),),(,)),(((,),),(,)));"))
treenumber_inv(192)
auxE_l_X(subX=3,Xset=c(1,1,2,2))
</code></pre>

<hr>
<h2 id='IbasedI'>Calculation of the I-based indices for rooted trees</h2><span id='topic+IbasedI'></span>

<h3>Description</h3>

<p>This function calculates <code class="reqn">I</code>-based indices <code class="reqn">I(T)</code> for a given rooted
tree <code class="reqn">T</code>. Note that the leaves of the tree may represent single species or
groups of more than one species. Thus, a vector is required that contains for
each leaf the number of species that it represents.
The tree may contain few polytomies, which are not allowed to concentrate in
a particular region of the tree (see p. 238 in Fusco and Cronk (1995)).<br /><br />
Let <code class="reqn">v</code> be a vertex of <code class="reqn">T</code> that fulfills the following criteria: a)
The number of descendant (terminal) species of <code class="reqn">v</code> is <code class="reqn">k_v&gt;3</code>
(note that if each leaf represents only one species <code class="reqn">k_v</code> is simply the
number of leaves in the pending subtree rooted at <code class="reqn">v</code>), and
b) <code class="reqn">v</code> has exactly two children.<br /><br />
Then, we can calculate the <code class="reqn">I_v</code> value as follows:
</p>
<p style="text-align: center;"><code class="reqn">I_v=\frac{k_{v_a}-\left\lceil\frac{k_v}{2}\right\rceil}{k_v-1-\left\lceil\frac{k_v}{2}\right\rceil}</code>
</p>

<p>in which <code class="reqn">k_{v_a}</code> denotes the number of descendant (terminal) species
in the bigger one of the two pending subtrees rooted at <code class="reqn">v</code>.<br /><br />
As the expected value of <code class="reqn">I_v</code> under the Yule model depends on <code class="reqn">k_v</code>,
Purvis et al. (2002) suggested to take the corrected values <code class="reqn">I'_v</code> or <code class="reqn">I_v^w</code> instead.<br />
The <code class="reqn">I'_v</code> value of <code class="reqn">v</code> is defined as follows: <code class="reqn">I'_v=I_v</code> if <code class="reqn">k_v</code> is odd and <code class="reqn">I'_v=\frac{k_v-1}{k_v}\cdot I_v</code>
if <code class="reqn">k_v</code> is even.<br />
The <code class="reqn">I_v^w</code> value of <code class="reqn">v</code> is defined as follows: </p>
<p style="text-align: center;"><code class="reqn">I_v^w=\frac{w(I_v)\cdot I_v}{mean_{V'(T)} w(I_v)}</code>
</p>

<p>where <code class="reqn">V'(T)</code> is the set of inner vertices of <code class="reqn">T</code> that have precisely
two children and <code class="reqn">k_v\geq 4</code>, and <code class="reqn">w(I_v)</code> is a weight function with
<code class="reqn">w(I_v)=1</code> if <code class="reqn">k_v</code> is odd and <code class="reqn">w(I_v)=\frac{k_v-1}{k_v}</code> if <code class="reqn">k_v</code>
is even and <code class="reqn">I_v&gt;0</code>, and <code class="reqn">w(I_v)=\frac{2\cdot(k_v-1)}{k_v}</code>
if <code class="reqn">k_v</code> is even and <code class="reqn">I_v=0</code>. <br /><br />
The <code class="reqn">I</code>-based index of <code class="reqn">T</code> can now be calculated using different methods.
Here, we only state the version for the <code class="reqn">I'</code> correction method, but the non-corrected
version or the <code class="reqn">I_v^w</code> corrected version works analoguously.
1) root: The <code class="reqn">I'</code> index of <code class="reqn">T</code> equals the <code class="reqn">I'_v</code> value of the root of
<code class="reqn">T</code>, i.e. <code class="reqn">I'(T)=I'_{\rho}</code>, provided that the root fulfills the two
criteria. Note that this method does not fulfil the definition of an (im)balance index.
2) median: The <code class="reqn">I'</code> index of <code class="reqn">T</code> equals the median <code class="reqn">I'_v</code> value of all
vertices <code class="reqn">v</code> that fulfill the two criteria.
3) total: The <code class="reqn">I'</code> index of <code class="reqn">T</code> equals the summarised <code class="reqn">I'_v</code> values of all
vertices <code class="reqn">v</code> that fulfill the two criteria.
4) mean: The <code class="reqn">I'</code> index of <code class="reqn">T</code> equals the mean <code class="reqn">I'_v</code> value of all
vertices <code class="reqn">v</code> that fulfill the two criteria.
5) quartile deviation: The <code class="reqn">I'</code> index of <code class="reqn">T</code> equals the quartile
deviation (half the difference between third and first quartile) of the <code class="reqn">I'_v</code> values of all
vertices <code class="reqn">v</code> that fulfill the two criteria. <br /><br />
For details on the family of I-based indices, see 
also Chapter 17 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_17).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IbasedI(
  tree,
  specnum = rep(1, length(tree$tip.label)),
  method = "mean",
  correction = "none",
  logs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IbasedI_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format (with possibly few polytomies).</p>
</td></tr>
<tr><td><code id="IbasedI_+3A_specnum">specnum</code></td>
<td>
<p>A vector whose <code class="reqn">i</code>-th entry is the number of species that
the <code class="reqn">i</code>-th leaf represents. (default is 1,...,1)</p>
</td></tr>
<tr><td><code id="IbasedI_+3A_method">method</code></td>
<td>
<p>A character string specifying the method that shall be used to
calculate <code class="reqn">I(T)</code>. It can be one of the following: &quot;root&quot;, &quot;median&quot;,
&quot;total&quot;, &quot;mean&quot;, &quot;quartdev&quot;.</p>
</td></tr>
<tr><td><code id="IbasedI_+3A_correction">correction</code></td>
<td>
<p>A character string specifying the correction method that
shall be applied to the I values. It can be one of the following:
&quot;none&quot;, &quot;prime&quot;, &quot;w&quot;.</p>
</td></tr>
<tr><td><code id="IbasedI_+3A_logs">logs</code></td>
<td>
<p>Boolean value, (default true), determines if the number of suitable
nodes (i.e. nodes that fulfill the criteria) and polytomies in the tree should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>IbasedI</code> returns an <code class="reqn">I</code>-based balance index of the given tree according to the chosen (correction and) method.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn and Sophie Kersting
</p>


<h3>References</h3>

<p>G. Fusco and Q. C. Cronk. A new method for evaluating the shape of large phylogenies. Journal of Theoretical Biology, 1995. doi: 10.1006/jtbi.1995.0136. URL https://doi.org/10.1006/jtbi.1995.0136.
</p>
<p>A. Purvis, A. Katzourakis, and P.-M. Agapow. Evaluating Phylogenetic Tree Shape: Two Modifications to Fusco &amp; Cronks Method. Journal of Theoretical Biology, 2002. doi: 10.1006/jtbi.2001.2443. URL https://doi.org/10.1006/jtbi.2001.2443.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="(((((,),),),),);")
IbasedI(tree, method="mean")
IbasedI(tree, method="mean", correction="prime", specnum=c(1,1,2,1,1,1))

</code></pre>

<hr>
<h2 id='maxDelW'>Calculation of the (modified) maximum difference in widths for a rooted tree</h2><span id='topic+maxDelW'></span>

<h3>Description</h3>

<p>This function calculates the maximum difference in widths <code class="reqn">delW(T)</code> and
the modified maximum difference in width <code class="reqn">mdelW(T)</code> for a
given rooted tree <code class="reqn">T</code>. The tree must not necessarily be binary.
<code class="reqn">delW(T)</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">delW(T)=\max_{i=0,...,h(T)-1} |w(i+1)-w(i)|</code>
</p>

<p>and <code class="reqn">mdelW(T)</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">mdelW(T)=\max_{i=0,...,h(T)-1} w(i+1)-w(i)</code>
</p>

<p>in which <code class="reqn">h(T)</code> denotes the height of the tree <code class="reqn">T</code> and <code class="reqn">w(i)</code> denotes
the number of vertices in <code class="reqn">T</code> that have depth <code class="reqn">i</code>. The modified maximum difference
in widths is a balance index, while the maximum difference in widths is neither a balance nor imbalance index. <br /><br />
Note that there was a spelling error in the previous manual of this function - we wrote &quot;maximum difference in widths&quot; 
while the given definition and the R code corresponded to the &quot;modified maximum difference in width&quot;. <br /><br />
For details on the maximum difference in widths and the modified maximum difference in widths, see 
also Chapters 24 and 23 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_24, https://doi.org/10.1007/978-3-031-39800-1_23).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxDelW(tree, method = "modified")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxDelW_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
<tr><td><code id="maxDelW_+3A_method">method</code></td>
<td>
<p>A character string specifying whether the original maximum difference in widths or the 
modified maximum difference in widths shall be computed. Can be any of &quot;original&quot; or &quot;modified&quot; (default is modified).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>maxDelW</code> returns the maximum difference in widths of a tree (if <code>method</code> is set to <code>original</code>) 
or the modified maximum difference in widths (if <code>method</code> is set to <code>modified</code>).
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting, Luise Kuehn
</p>


<h3>References</h3>

<p>C. Colijn, J. Gardy. Phylogenetic tree shapes resolve disease transmission patterns. Evolution, Medicine, and Public Health, 2014(1):96-108, 2014. ISSN 2050-6201. doi: 10.1093/emph/eou018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
maxDelW(tree, method="original")
tree &lt;- ape::read.tree(text="((,),((((,),),),(,)));")
maxDelW(tree, method="modified")

</code></pre>

<hr>
<h2 id='maxDepth'>Calculation of the maximum depth of the tree</h2><span id='topic+maxDepth'></span>

<h3>Description</h3>

<p>This function calculates the maximum depth of any vertex in a rooted tree <code class="reqn">T</code>, which
is at the same time its height <code class="reqn">h(T)</code>. The tree must not necessarily be binary. Formally,
<code class="reqn">h(T)</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">h(T)=\max_{v\in V(T)} \delta(v)</code>
</p>

<p>with <code class="reqn">\delta(v)</code> being the depth of the vertex <code class="reqn">v</code>.
The maximum depth is an imbalance index.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">h(T)=0</code> and a warning. <br /><br />
For details on the maximum depth, see 
also Chapter 23 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_23).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxDepth(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxDepth_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>maxDepth</code> returns the maximum depth, i.e. height, of a tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn, Sophie Kersting
</p>


<h3>References</h3>

<p>C. Colijn and J. Gardy.  Phylogenetic tree shapes resolve disease transmission patterns. Evolution, Medicine, and Public Health, 2014(1):96-108, 2014. ISSN 2050-6201. doi: 10.1093/emph/eou018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
maxDepth(tree)
tree &lt;- ape::read.tree(text="((,),((((,),),),(,)));")
maxDepth(tree)

</code></pre>

<hr>
<h2 id='maxWidth'>Calculation of the maximum width of the tree</h2><span id='topic+maxWidth'></span>

<h3>Description</h3>

<p>This function calculates the maximum width <code class="reqn">maxWidth(T)</code> for a
given rooted tree <code class="reqn">T</code>. The tree must not necessarily be binary.
<code class="reqn">maxWidth(T)</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">maxWidth(T)=\max_{i=0,...,h(T)} w(i)</code>
</p>

<p>in which <code class="reqn">h(T)</code> denotes the height of the tree <code class="reqn">T</code> and <code class="reqn">w(i)</code> denotes
the number of vertices in <code class="reqn">T</code> that have depth <code class="reqn">i</code>. The maximum width
is a balance index. <br /><br />
For details on the maximum width, see 
also Chapter 23 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_23).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxWidth(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxWidth_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>maxWidth</code> returns the maximum width of a tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>C. Colijn and J. Gardy.  Phylogenetic tree shapes resolve disease transmission patterns. Evolution, Medicine, and Public Health, 2014(1):96-108, 2014. ISSN 2050-6201. doi: 10.1093/emph/eou018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
maxWidth(tree)
tree &lt;- ape::read.tree(text="((,),((((,),),),(,)));")
maxWidth(tree)

</code></pre>

<hr>
<h2 id='mCherryI'>Calculation of the modified cherry index for rooted binary trees</h2><span id='topic+mCherryI'></span>

<h3>Description</h3>

<p>This function calculates the modified cherry index <code class="reqn">mChI(T)</code> for a
given rooted binary tree <code class="reqn">T</code>. Note that compared to the original cherry index <code class="reqn">ChI(T)</code>, 
the modified cherry index is defined for binary trees only.
<code class="reqn">mChI(T)</code> is defined as <code class="reqn">n-2\cdot ChI(T)</code>, i.e. it counts the 
number of leaves of the tree which are not in a cherry. A cherry
is a pair of leaves that have the same direct ancestor. <br /><br />
The modified cherry index does not fulfill the definition
of an (im)balance index given in &quot;Tree balance indices: a comprehensive survey&quot;
(Fischer et al., 2023). <br /><br />
For details on the modified cherry index, see 
also Chapter 24 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_24).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mCherryI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mCherryI_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mCherryI</code> returns the modified cherry index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>S. J. Kersting, M. Fischer. Measuring tree balance using symmetry nodes — A new balance index and its extremal properties. Mathematical Biosciences, 341:108690, 2021. doi: 10.1016/j.mbs.2021.108690.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
mCherryI(tree)
tree &lt;- ape::read.tree(text="((,),((((,),),),(,)));")
mCherryI(tree)

</code></pre>

<hr>
<h2 id='mWovermD'>Calculation of the maximum width over maximum depth of the tree</h2><span id='topic+mWovermD'></span>

<h3>Description</h3>

<p>This function calculates the maximum width over maximum depth <code class="reqn">mWovermD(T)</code> for a
given rooted tree <code class="reqn">T</code>. The tree must not necessarily be binary. For <code class="reqn">n&gt;1</code>,
<code class="reqn">mWovermD(T)</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">mWovermD(T)=maxWidth(T) / h(T)</code>
</p>

<p>in which <code class="reqn">h(T)</code> denotes the height of the tree <code class="reqn">T</code>, which is the same as the 
maximum depth of any leaf in the tree, and <code class="reqn">maxWidth(T)</code> denotes
the maximum width of the tree <code class="reqn">T</code>. The maximum width over maximum depth
is a balance index. <br /><br />
For details on the maximum width over maximum depth, see 
also Chapter 23 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_23).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mWovermD(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mWovermD_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mWovermD</code> returns the maximum width over maximum depth of a tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>C. Colĳn and J. Gardy. Phylogenetic tree shapes resolve disease transmission patterns. Evolution, Medicine, and Public Health, 2014(1):96–108, 2014. doi: 10.1093/emph/eou018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
mWovermD(tree)
tree &lt;- ape::read.tree(text="((,),((((,),),),(,)));")
mWovermD(tree)

</code></pre>

<hr>
<h2 id='rogersI'>Calculation of the Rogers J index for rooted binary trees</h2><span id='topic+rogersI'></span>

<h3>Description</h3>

<p>This function calculates the Rogers J index <code class="reqn">J(T)</code> for a given rooted
binary tree <code class="reqn">T</code>. It is defined as the number of inner vertices whose balance
value is unequal to zero, more precisely
</p>
<p style="text-align: center;"><code class="reqn">J(T)=\sum_{u \in V_{in}(T)} (1-I(n_{u_a}=n_{u_b}))</code>
</p>

<p>in which <code class="reqn">V_{in}(T)</code> denotes the set of all inner vertices
of <code class="reqn">T</code>, and in which <code class="reqn">n_{u_a}</code>
and <code class="reqn">n_{u_b}</code> denote the number of leaves in the two pending subtrees that are
rooted at the direct descendants of <code class="reqn">u</code>. <br />
Special cases: For <code class="reqn">n=1</code>, the function returns <code class="reqn">J(T)=0</code> and a warning. <br /><br />
For details on the Rogers J index, see 
also Chapter 19 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_19).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rogersI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rogersI_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rogersI</code> returns the Rogers J index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>J. S. Rogers. Central Moments and Probability Distributions of Three Measures of Phylogenetic Tree Imbalance. Systematic Biology, 45(1):99-110, 1996. doi: 10.1093/sysbio/45.1.99.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
rogersI(tree)

</code></pre>

<hr>
<h2 id='rQuartetI'>Calculation of the rooted quartet index for rooted trees</h2><span id='topic+rQuartetI'></span>

<h3>Description</h3>

<p>This function calculates the rooted quartet index <code class="reqn">rQI(T)</code> for a given
rooted tree <code class="reqn">T</code>. The tree must not necessarily be binary.<br /><br />
Let <code class="reqn">T</code> be a rooted tree, whose leaves are <code class="reqn">1,...,n</code>. Let
<code class="reqn">P_4</code> denote the set of all subsets of <code class="reqn">\{1,...,n\}</code> that have
cardinality 4. Let <code class="reqn">T(Q)</code> denote the rooted quartet on <code class="reqn">Q\in P_4</code>
that is obtained by taking the subgraph of <code class="reqn">T</code> that is induced by
<code class="reqn">Q</code> and supressing its outdegree-1 vertices. <code class="reqn">T(Q)</code> can have one of
the five following shapes:<br /><br />
- <code class="reqn">Q_0^*</code>: This is the caterpillar tree shape on 4 leaves, i.e.
<code>"(,(,(,)));"</code> in Newick format. It has 2 automorphisms.<br />
- <code class="reqn">Q_1^*</code>: This is the tree shape on 4 leaves that has three pending
subtrees rooted at the children of the root of <code class="reqn">T</code>, one of them being
a cherry and the other two
being single vertices, i.e. <code>"((,),,);"</code> in Newick format. It has 4
automorphisms.<br />
- <code class="reqn">Q_2^*</code>: This is the tree shape on 4 leaves that has two pending
subtrees rooted at the children of the root of <code class="reqn">T</code>, one of them being
a star tree shape on 3 leaves
and the other one being a single vertex, i.e. <code>"((,,),);"</code> in Newick
format. It has 6 automorphisms.<br />
- <code class="reqn">Q_3^*</code>: This is the fully balanced binary tree shape on 4 leaves,
i.e. <code>"((,),(,));"</code> in Newick format. It has 8 automorphisms.<br />
- <code class="reqn">Q_4^*</code>: This is the star tree shape on 4 leaves, i.e.
<code>"(,,,);"</code> in Newick format. It has 24 automorphisms.<br /><br />
<code class="reqn">T(Q)</code> is assigned an rQI-value based on its shape, i.e. <code class="reqn">rQI(T(Q))=q_i</code>
if <code class="reqn">T(Q)</code> has the shape <code class="reqn">Q_i^*</code>. The values <code class="reqn">q_0,...,q_4</code> are
chosen in such a way that they increase with the symmetry of the shape as
measured by means of its number of automorphisms. Coronado et al. (2019)
suggested the values <code class="reqn">q_0=0</code> and <code class="reqn">q_i=i</code> or <code class="reqn">q_i=2^i</code> for <code class="reqn">i=1,...,4</code>.<br />
The rooted quartet index <code class="reqn">rQI(T)</code> of the tree <code class="reqn">T</code> is then defined as
the sum of the rQI-values of its rooted quartets:
</p>
<p style="text-align: center;"><code class="reqn">rQI(T)=\sum_{Q\in P_4} rQI(T(Q))</code>
</p>

<p>The rooted quartet index is a balance index. <br /><br />
For details on the rooted quartet index, see 
also Chapter 20 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_20).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rQuartetI(tree, shapeVal = c(0, 1, 2, 3, 4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rQuartetI_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
<tr><td><code id="rQuartetI_+3A_shapeval">shapeVal</code></td>
<td>
<p>A vector of length 5 containing the shape values <code class="reqn">q_0,...,q_4</code>.
Default is <code class="reqn">(q_0,q_1,q_2,q_3,q_4)=(0,1,2,3,4)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rQuartetI</code> returns the rooted quartet index of the given tree based on the chosen shape values (see description for details).
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>T. M. Coronado, A. Mir, F. Rossello, and G. Valiente.  A balance index for phylogenetic trees based on rooted quartets. Journal of Mathematical Biology, 79(3):1105-1148, 2019. doi: 10.1007/s00285-019-01377-w. URL https://doi.org/10.1007/s00285-019-01377-w.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
rQuartetI(tree)

</code></pre>

<hr>
<h2 id='sackinI'>Calculation of the Sackin index for rooted trees</h2><span id='topic+sackinI'></span>

<h3>Description</h3>

<p>This function calculates the Sackin index <code class="reqn">S(T)</code> for a given rooted
tree <code class="reqn">T</code>. The tree must not necessarily be binary. <code class="reqn">S(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">S(T)=\sum_{x\in V_L(T)} \delta(x)=\sum_{u\in V_{in}(T)} n_u</code>
</p>
<p> in
which <code class="reqn">V_L(T)</code> denotes the leaf set of <code class="reqn">T</code>, <code class="reqn">\delta(x)</code>
denotes the depth of the leaf <code class="reqn">x</code>, <code class="reqn">V_{in}(T)</code> denotes the set of
inner vertices in <code class="reqn">T</code>, and <code class="reqn">n_u</code> denotes the number of leaves
in the pending subtree that is rooted at <code class="reqn">u</code>. The Sackin index is an
imbalance index.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">S(T)=0</code> and a warning. <br /><br />
For details on the Sackin index, see 
also Chapter 5 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sackinI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sackinI_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sackinI</code> returns the Sackin index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>M.J. Sackin. &quot;Good&quot; and &quot;Bad&quot; Phenograms. Systematic Biology, 21(2):225-226, 1972. doi: 10.1093/sysbio/21.2.225.
</p>
<p>K.-T. Shao and R.R. Sokal. Tree Balance. Systematic Zoology, 39(3):266, 1990. doi: 10.2307/2992186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
sackinI(tree)

</code></pre>

<hr>
<h2 id='sShapeI'>Calculation of the s-shape statistic for rooted trees</h2><span id='topic+sShapeI'></span>

<h3>Description</h3>

<p>This function calculates the s-shape statistic <code class="reqn">sShape(T)</code> for a given rooted
tree <code class="reqn">T</code>. The tree must not necessarily be binary, however <code class="reqn">sShape</code> only fulfils
the definition of an imbalance index on the space of binary trees. <code class="reqn">sShape(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">sShape(T)=\sum_{u\in V_{in}(T)} log(n_u-1)</code>
</p>
<p> in
which <code class="reqn">V_{in}(T)</code> denotes the set of inner vertices of <code class="reqn">T</code>
and <code class="reqn">n_u</code> denotes the number of leaves
in the pending subtree that is rooted at <code class="reqn">u</code>. An arbitrary logarithm base can be used
(for binary trees it is common to use base 2).<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">sShape(T)=0</code> and a warning. <br /><br />
For details on the s-shape statistic, see 
also Chapter 9 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_9).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sShapeI(tree, logbase = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sShapeI_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
<tr><td><code id="sShapeI_+3A_logbase">logbase</code></td>
<td>
<p>The logarithm base that shall be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sShapeI</code> returns the s-shape statistic of the given tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>M.G. Blum and O. Francois. Which random processes describe the tree of life? a large-scale study of phylogenetic tree imbalance. Systematic Biology, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
sShapeI(tree)

</code></pre>

<hr>
<h2 id='stairs1'>Calculation of the stairs1 value for rooted binary trees</h2><span id='topic+stairs1'></span>

<h3>Description</h3>

<p>This function calculates the stairs1 value <code class="reqn">st1(T)</code> for a given rooted
binary tree <code class="reqn">T</code>. It is a modified version of the Rogers J index and is
defined as the fraction of inner vertices whose balance
value is unequal to zero, more precisely
</p>
<p style="text-align: center;"><code class="reqn">st1(T)=\frac{1}{n-1}\cdot\sum_{u \in V_{in}(T)} (1-I(n_{u_a}=n_{u_b}))</code>
</p>

<p>in which <code class="reqn">V_{in}(T)</code> denotes the set of all inner vertices
of <code class="reqn">T</code>, and in which <code class="reqn">n_{u_a}</code>
and <code class="reqn">n_{u_b}</code> denote the number of leaves in the two pending subtrees that are
rooted at the direct descendants of <code class="reqn">u</code>. The stairs1 value is an imbalance index. <br /><br />
Special cases: For <code class="reqn">n=1</code>, the function returns <code class="reqn">st1(T)=0</code> and a warning. <br /><br />
For details on the stairs1 value, see 
also Chapter 23 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_23).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stairs1(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stairs1_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>stairs1</code> returns the stairs1 value of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>M. M. Norstrom, M. C. Prosperi, R. R. Gray, A. C. Karlsson, and M. Salemi. PhyloTempo: A Set of R Scripts for Assessing and Visualizing Temporal Clustering in Genealogies Inferred from Serially Sampled Viral Sequences. Evolutionary Bioinformatics, 8:EBO.S9738, 2012. ISSN 1176-9343, 1176-9343. doi:10.4137/EBO.S9738.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
stairs1(tree)

</code></pre>

<hr>
<h2 id='stairs2'>Calculation of the stairs2 value for rooted binary trees</h2><span id='topic+stairs2'></span>

<h3>Description</h3>

<p>This function calculates the stairs2 value <code class="reqn">st2(T)</code> for a given rooted
binary tree <code class="reqn">T</code>. It is defined as the mean ratio between the leaf
numbers of the smaller and larger pending subtree over all inner vertices, more precisely
</p>
<p style="text-align: center;"><code class="reqn">st2(T)=\frac{1}{n-1}\cdot\sum_{u \in V_{in}(T)} \frac{n_{u_a}}{n_{u_b}}</code>
</p>

<p>in which <code class="reqn">V_{in}(T)</code> denotes the set of all inner vertices
of <code class="reqn">T</code>, and in which <code class="reqn">n_{u_a}\geq n_{u_b}</code> denote the number of leaves
in the two pending subtrees that are
rooted at the direct descendants of <code class="reqn">u</code>. The stairs2 value is an imbalance index. <br /><br />
Special cases: For <code class="reqn">n=1</code>, the function returns <code class="reqn">st2(T)=0</code> and a warning. <br /><br />
For details on the stairs2 value, see 
also Chapter 23 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_23).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stairs2(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stairs2_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>stairs2</code> returns the stairs2 value of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>C. Colijn, J. Gardy. Phylogenetic tree shapes resolve disease transmission patterns. Evolution, Medicine, and Public Health, 2014(1):96-108, 2014. ISSN 2050-6201. doi: 10.1093/emph/eou018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
stairs2(tree)

</code></pre>

<hr>
<h2 id='symNodesI'>Calculation of the symmetry nodes index for rooted binary trees</h2><span id='topic+symNodesI'></span>

<h3>Description</h3>

<p>This function calculates the symmetry nodes index <code class="reqn">SNI(T)</code> for a given rooted
binary tree <code class="reqn">T</code>. <code class="reqn">SNI(T)</code> is defined as the number of inner vertices <code class="reqn">v</code> that are not
symmetry nodes, i.e. the two pending subtrees rooted at the children of <code class="reqn">v</code> do not
have the same tree shape.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">SNI(T)=0</code> and a warning. <br /><br />
For details on the symmetry nodes index, see 
also Chapter 18 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_18).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symNodesI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symNodesI_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>symNodesI</code> returns the symmetry nodes index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>S. J. Kersting, M. Fischer. Measuring tree balance using symmetry nodes — A new balance index and its extremal properties. Mathematical Biosciences, page 108690, 2021.  ISSN 0025-5564.  doi:https://doi.org/10.1016/j.mbs.2021.108690
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
symNodesI(tree)

</code></pre>

<hr>
<h2 id='totCophI'>Calculation of the total cophenetic index for rooted trees</h2><span id='topic+totCophI'></span>

<h3>Description</h3>

<p>This function calculates the total cophenetic index <code class="reqn">TCI(T)</code> of a given
rooted tree <code class="reqn">T</code>. The tree must not necessarily be binary. <code class="reqn">TCI(T)</code>
is defined as </p>
<p style="text-align: center;"><code class="reqn">TCI(T)=\sum_{1\leq i&lt;j\leq n} \delta(lca(i,j))=\sum_{u\in V_{in}(T)\setminus\{\rho\}} binom(n_u,2)</code>
</p>
<p> in which <code class="reqn">\delta(lca(i,j))</code> denotes the depth of the lowest
common ancestor of the two leaves <code class="reqn">i</code> and <code class="reqn">j</code> and <code class="reqn">V_{in}(T)\setminus\{\rho\}</code>
denotes the set of all inner vertices exept the root and <code class="reqn">n_u</code> denotes the
number of descendant leaves of <code class="reqn">u</code>. The second formula is useful for efficient
computation of <code class="reqn">TCI(T)</code>. The total cophenetic index is an imbalance index.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">TCI(T)=0</code>. <br /><br />
For details on the total cophenetic index, see 
also Chapter 8 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_8).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totCophI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totCophI_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>totCophI</code> returns the total cophenetic index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>A. Mir, F. Rossello, and L. Rotger. A new balance index for phylogenetic trees. Mathematical Bio-sciences, 241(1):125-136, 2013. doi: 10.1016/j.mbs.2012.10.005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
totCophI(tree)
tree &lt;- ape::read.tree(text="((,),((((,),),),(,)));")
totCophI(tree)
tree &lt;- ape::read.tree(text="((,,,),(,,));")
totCophI(tree)

</code></pre>

<hr>
<h2 id='totIntPathLen'>Calculation of the total internal path length for rooted trees</h2><span id='topic+totIntPathLen'></span>

<h3>Description</h3>

<p>This function calculates the total internal path length <code class="reqn">TIP(T)</code> for a given rooted
tree <code class="reqn">T</code>. The tree must not necessarily be binary. <code class="reqn">TIP(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">TIP(T)=\sum_{x\in V_{in}(T)} \delta(x)</code>
</p>
<p> in
which <code class="reqn">V_{in}(T)</code> denotes the set of inner vertices of <code class="reqn">T</code>, and <code class="reqn">\delta(x)</code>
denotes the depth of the vertex <code class="reqn">x</code>. The total internal path length is an
imbalance index. <br /><br />
For details on the total internal path length, see 
also Chapter 23 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_23).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totIntPathLen(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totIntPathLen_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>totIntPathLen</code> returns the total internal path length of the given tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>D. E. Knuth. The art of computer programming: fundamental algorithms, volume 1. Addison-Wesley, Reading, Mass, 3rd edition, 1997. ISBN 9780201896831.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,,),),(,)));")
totIntPathLen(tree)

</code></pre>

<hr>
<h2 id='totPathLen'>Calculation of the total path length for rooted trees</h2><span id='topic+totPathLen'></span>

<h3>Description</h3>

<p>This function calculates the total path length <code class="reqn">TPL(T)</code> for a given rooted
tree <code class="reqn">T</code>. The tree must not necessarily be binary. <code class="reqn">TPL(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">TPL(T)=\sum_{x\in V(T)} \delta(x)</code>
</p>
<p> in
which <code class="reqn">V(T)</code> denotes the set of vertices of <code class="reqn">T</code>, and <code class="reqn">\delta(x)</code>
denotes the depth of the vertex <code class="reqn">x</code>. The total path length is an
imbalance index.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">TPL(T)=0</code> and a warning. <br /><br />
For details on the total path length, see 
also Chapter 23 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_23).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totPathLen(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totPathLen_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>totPathLen</code> returns the total path length of the given tree.
</p>


<h3>Author(s)</h3>

<p>Luise Kuehn
</p>


<h3>References</h3>

<p>see e.g. R. P. Dobrow, J. A. Fill. Total path length for random recursive trees. Combinatorics, Probability and Computing, 8(4):317–333, 1999. doi: 10.1017/S0963548399003855.
</p>
<p>see e.g. L. Takacs. On the total heights of random rooted trees. Journal of Applied Probability, 29(3):543–556, 1992. doi: 10.2307/3214892.
</p>
<p>see e.g. L. Takacs. On the total heights of random rooted binary trees. Journal of Combinatorial Theory, Series B, 61(2):155–166, 1994. ISSN 0095-8956. doi: 10.1006/jctb.1994.1041.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,,),),(,)));")
totPathLen(tree)

</code></pre>

<hr>
<h2 id='varLeafDepI'>Calculation of the variance of leaf depths index for rooted trees</h2><span id='topic+varLeafDepI'></span>

<h3>Description</h3>

<p>This function calculates the variance of leaf depths index <code class="reqn">VLD(T)</code>
for a given rooted tree <code class="reqn">T</code>. The tree must not necessarily be binary.
<code class="reqn">VLD(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">VLD(T)=\frac{1}{n}\cdot\sum_{x\in V_L(T)} (\delta(x)-N(T))^2</code>
</p>

<p>in which <code class="reqn">n</code> denotes the number of leaves of <code class="reqn">T</code>, <code class="reqn">V_L(T)</code>
denotes the set of leaves of <code class="reqn">T</code>, <code class="reqn">\delta(x)</code> denotes the depth of
the leaf <code class="reqn">x</code> and <code class="reqn">N(T)</code> denotes the average leaf depth of <code class="reqn">T</code>.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">VLD(T)=0</code> and a warning. <br /><br />
For details on the variance of leaf depths, see 
also Chapter 7 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_7).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varLeafDepI(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varLeafDepI_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>varLeafDepI</code> returns the variance of leaf depths index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>T. M. Coronado, A. Mir, F. Rossello, and L. Rotger. On Sackin's original proposal: the variance of the leaves' depths as a phylogenetic balance index. BMC Bioinformatics, 21(1), 2020. doi: 10.1186/s12859-020-3405-1. URL https://doi.org/10.1186/s12859-020-3405-1.
</p>
<p>M. J. Sackin. &quot;Good&quot; and &quot;Bad&quot; Phenograms. Systematic Biology, 21(2):225-226, 1972. doi: 10.1093/sysbio/21.2.225.
</p>
<p>K.-T. Shao and R. R. Sokal. Tree Balance. Systematic Zoology, 39(3):266, 1990. doi: 10.2307/2992186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
varLeafDepI(tree)

</code></pre>

<hr>
<h2 id='wedEth'>Wedderburn Etherington numbers (from OEIS)</h2><span id='topic+wedEth'></span>

<h3>Description</h3>

<p>Contains a vector of Wedderburn Etherington numbers for <code class="reqn">n=1</code> to <code class="reqn">n=2545</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wedEth)
</code></pre>


<h3>Format</h3>

<p>numerical vector
</p>


<h3>Source</h3>

<p>OEIS Sequence A001190 available at https://oeis.org/A001190
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wedEth)
wedEth[5]
</code></pre>

<hr>
<h2 id='weighL1dist'>Calculation of weighted l1 distance index for rooted binary trees</h2><span id='topic+weighL1dist'></span>

<h3>Description</h3>

<p>This function calculates the weighted l1 distance index <code class="reqn">D_{l1}(T)</code> for a
given rooted binary tree <code class="reqn">T</code>. <code class="reqn">D_{l1}(T)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">D_{l1}(T)=\sum_{z=2}^n z \cdot |f_n(z)-p_n(z)|</code>
</p>
<p> in which <code class="reqn">n</code> denotes the
number of leaves of <code class="reqn">T</code>, <code class="reqn">f_n(z)</code> denotes the frequency of pending subtrees
of size <code class="reqn">z</code> in <code class="reqn">T</code> and <code class="reqn">p_n(z)</code> is the expected number of
pending subtrees of size <code class="reqn">z</code> under the Yule model, i.e. <code class="reqn">p_n(z)=\frac{1}{n-1}</code>
if <code class="reqn">z=n</code> and otherwise <code class="reqn">\frac{n}{n-1}\cdot\frac{2}{z\cdot(z+1)}</code>.<br /><br />
For <code class="reqn">n=1</code> the function returns <code class="reqn">D_{l1}(T)=0</code>. <br /><br />
For details on the weighted l1 distance index, see 
also Chapter 24 in &quot;Tree balance indices: a comprehensive survey&quot; (https://doi.org/10.1007/978-3-031-39800-1_24).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighL1dist(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighL1dist_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in phylo format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>weighL1distI</code> returns the weighted l1 distance index of the given tree.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>

<p>M. G. Blum and O. Francois. On statistical tests of phylogenetic tree imbalance: The Sackin and other indices revisited. Mathematical Biosciences, 195(2):141-153, 2005. doi: 10.1016/j.mbs.2005.03.003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text="((((,),),(,)),(((,),),(,)));")
weighL1dist(tree)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
