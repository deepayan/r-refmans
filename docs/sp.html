<!DOCTYPE html><html><head><title>Help for package sp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addAttrToGeom-methods'><p> constructs SpatialXxxDataFrame from geometry and attributes</p></a></li>
<li><a href='#aggregate'><p> aggregation of spatial objects</p></a></li>
<li><a href='#as.SpatialPolygons.GridTopology'><p>Make SpatialPolygons object from GridTopology object</p></a></li>
<li><a href='#as.SpatialPolygons.PolygonsList'><p>Making SpatialPolygons objects</p></a></li>
<li><a href='#bbox-methods'><p> retrieve bbox from spatial data</p></a></li>
<li><a href='#bpy.colors'><p> blue-pink-yellow color scheme, which also prints well on</p>
black/white printers</a></li>
<li><a href='#bubble'>
<p>Create a bubble plot of spatial data</p></a></li>
<li><a href='#char2dms'><p>Convert character vector to DMS-class object</p></a></li>
<li><a href='#compassRose'><p>Display a compass rose.</p></a></li>
<li><a href='#coordinates'><p> set spatial coordinates to create a Spatial object, or retrieve</p>
spatial coordinates from a Spatial object</a></li>
<li><a href='#coordinates-methods'><p> retrieve (or set) spatial coordinates</p></a></li>
<li><a href='#coordnames-methods'><p> retrieve or assign coordinate names for classes in sp</p></a></li>
<li><a href='#CRS-class'><p>Class &quot;CRS&quot; of coordinate reference system arguments</p></a></li>
<li><a href='#degAxis'><p> axis with degrees</p></a></li>
<li><a href='#dimensions-methods'><p> retrieve spatial dimensions from spatial data</p></a></li>
<li><a href='#disaggregate-methods'><p> disaggregate SpatialLines, SpatialLinesDataFrame,</p>
SpatialPolygons, or SpatialPolygonsDataFrame objects</a></li>
<li><a href='#DMS-class'><p>Class &quot;DMS&quot; for degree, minute, decimal second values</p></a></li>
<li><a href='#elide-methods'><p>Methods for Function elide in Package &lsquo;maptools&rsquo;</p></a></li>
<li><a href='#flip'><p> rearrange data in SpatialPointsDataFrame or SpatialGridDataFrame</p>
for plotting with spplot (levelplot/xyplot wrapper)</a></li>
<li><a href='#geometry-methods'><p> Methods for retrieving the geometry from a composite (geometry + attributes) object</p></a></li>
<li><a href='#gridded-methods'><p> specify spatial data as being gridded, or find out whether they are</p></a></li>
<li><a href='#gridIndex2nb'><p>create neighbourhood (nb) object from grid geometry</p></a></li>
<li><a href='#gridlines'><p> Create N-S and E-W grid lines over a geographic region</p></a></li>
<li><a href='#GridsDatums'><p>Grids and Datums PE&amp;RS listing</p></a></li>
<li><a href='#GridTopology-class'><p>Class &quot;GridTopology&quot;</p></a></li>
<li><a href='#image.SpatialGridDataFrame'><p> Image or contour method for gridded spatial data; convert to and from image data structure</p></a></li>
<li><a href='#is.projected'><p> Sets or retrieves projection attributes on classes extending</p>
SpatialData</a></li>
<li><a href='#Line'><p> create objects of class Line or Lines</p></a></li>
<li><a href='#Line-class'><p>Class &quot;Line&quot;</p></a></li>
<li><a href='#Lines-class'><p>Class &quot;Lines&quot;</p></a></li>
<li><a href='#loadMeuse'><p> deprecated function to load the Meuse data set</p></a></li>
<li><a href='#mapasp'><p> Calculate aspect ratio for plotting geographic maps;</p>
create nice degree axis labels</a></li>
<li><a href='#merge'>
<p>Merge a Spatial* object having attributes with a data.frame</p></a></li>
<li><a href='#meuse'><p>Meuse river data set</p></a></li>
<li><a href='#meuse.grid'><p> Prediction Grid for Meuse Data Set</p></a></li>
<li><a href='#meuse.grid_ll'><p>Prediction Grid for Meuse Data Set, geographical coordinates</p></a></li>
<li><a href='#meuse.riv'><p> River Meuse outline</p></a></li>
<li><a href='#over-methods'><p> consistent spatial overlay for points, grids and polygons</p></a></li>
<li><a href='#panel.spplot'><p>panel and panel utility functions for spplot</p></a></li>
<li><a href='#point.in.polygon'><p> do point(s) fall in a given polygon?</p></a></li>
<li><a href='#Polygon-class'><p>Class &quot;Polygon&quot;</p></a></li>
<li><a href='#polygons'><p> sets spatial coordinates to create spatial data, or retrieves</p>
spatial coordinates</a></li>
<li><a href='#Polygons-class'><p>Class &quot;Polygons&quot;</p></a></li>
<li><a href='#polygons-methods'><p> Retrieve polygons from SpatialPolygonsDataFrame object</p></a></li>
<li><a href='#read.asciigrid'><p> read/write to/from (ESRI) asciigrid format</p></a></li>
<li><a href='#recenter-methods'><p>Methods for Function recenter in Package &lsquo;sp&rsquo;</p></a></li>
<li><a href='#Rlogo'><p>Rlogo jpeg image</p></a></li>
<li><a href='#select.spatial'><p> select points spatially</p></a></li>
<li><a href='#sp'><p>A package providing classes and methods for spatial data: points,</p>
lines, polygons and grids</a></li>
<li><a href='#sp-deprecated'><p> Deprecated functions in sp</p></a></li>
<li><a href='#sp2Mondrian'><p>write map data for Mondrian</p></a></li>
<li><a href='#Spatial-class'><p>Class &quot;Spatial&quot;</p></a></li>
<li><a href='#SpatialGrid-class'><p>Class &quot;SpatialGrid&quot;</p></a></li>
<li><a href='#SpatialGridDataFrame-class'><p>Class &quot;SpatialGridDataFrame&quot;</p></a></li>
<li><a href='#SpatialLines'><p> create objects of class SpatialLines or SpatialLinesDataFrame</p></a></li>
<li><a href='#SpatialLines-class'><p>a class for spatial lines</p></a></li>
<li><a href='#SpatialLinesDataFrame-class'><p>a class for spatial lines with attributes</p></a></li>
<li><a href='#SpatialMultiPoints'><p> create objects of class SpatialMultiPoints or SpatialMultiPointsDataFrame</p></a></li>
<li><a href='#SpatialMultiPoints-class'><p>Class &quot;SpatialMultiPoints&quot;</p></a></li>
<li><a href='#SpatialMultiPointsDataFrame-class'><p>Class &quot;SpatialMultiPointsDataFrame&quot;</p></a></li>
<li><a href='#SpatialPixels'><p> define spatial grid</p></a></li>
<li><a href='#SpatialPixels-class'><p>Class &quot;SpatialPixels&quot;</p></a></li>
<li><a href='#SpatialPixelsDataFrame'><p> define spatial grid with attribute data</p></a></li>
<li><a href='#SpatialPixelsDataFrame-class'><p>Class &quot;SpatialPixelsDataFrame&quot;</p></a></li>
<li><a href='#SpatialPoints'><p> create objects of class SpatialPoints or SpatialPointsDataFrame</p></a></li>
<li><a href='#SpatialPoints-class'><p>Class &quot;SpatialPoints&quot;</p></a></li>
<li><a href='#SpatialPointsDataFrame-class'><p>Class &quot;SpatialPointsDataFrame&quot;</p></a></li>
<li><a href='#SpatialPolygons'><p> create objects of class SpatialPolygons or SpatialPolygonsDataFrame</p></a></li>
<li><a href='#SpatialPolygons-class'><p>Class &quot;SpatialPolygons&quot;</p></a></li>
<li><a href='#SpatialPolygonsDataFrame-class'><p>Class &quot;SpatialPolygonsDataFrame&quot;</p></a></li>
<li><a href='#spChFIDs-methods'><p>change feature IDs in spatial objects</p></a></li>
<li><a href='#spDistsN1'><p>Euclidean or Great Circle distance between points</p></a></li>
<li><a href='#spplot'><p>Plot methods for spatial data with attributes</p></a></li>
<li><a href='#spsample'><p> sample point locations in (or on) a spatial object</p></a></li>
<li><a href='#spTransform'><p> spTransform for map projection and datum transformation</p></a></li>
<li><a href='#stack'><p> rearrange data in SpatialPointsDataFrame or SpatialGridDataFrame</p>
for plotting with spplot (levelplot/xyplot wrapper)</a></li>
<li><a href='#surfaceArea'>
<p>Compute surface area of a digital elevation model.</p></a></li>
<li><a href='#zerodist'><p> find point pairs with equal spatial coordinates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1-2</td>
</tr>
<tr>
<td>Title:</td>
<td>Classes and Methods for Spatial Data</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, graphics, grDevices, lattice, grid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RColorBrewer, gstat, deldir, knitr, rmarkdown, sf, terra,
raster</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and methods for spatial
  data; the classes document where the spatial location information
  resides, for 2D or 3D data. Utility functions are provided, e.g. for
  plotting data as maps, spatial selection, as well as methods for
  retrieving coordinates, for subsetting, print, summary, etc. From this
  version, 'rgdal', 'maptools', and 'rgeos' are no longer used at all,
  see <a href="https://r-spatial.org/r/2023/05/15/evolution4.html">https://r-spatial.org/r/2023/05/15/evolution4.html</a> for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/edzer/sp/">https://github.com/edzer/sp/</a> <a href="https://edzer.github.io/sp/">https://edzer.github.io/sp/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/edzer/sp/issues">https://github.com/edzer/sp/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>bpy.colors.R AAA.R Class-CRS.R CRS-methods.R Class-Spatial.R
Spatial-methods.R projected.R Class-SpatialPoints.R
SpatialPoints-methods.R Class-SpatialPointsDataFrame.R
SpatialPointsDataFrame-methods.R Class-SpatialMultiPoints.R
SpatialMultiPoints-methods.R
Class-SpatialMultiPointsDataFrame.R
SpatialMultiPointsDataFrame-methods.R Class-GridTopology.R
Class-SpatialGrid.R Class-SpatialGridDataFrame.R
Class-SpatialLines.R SpatialLines-methods.R
Class-SpatialLinesDataFrame.R SpatialLinesDataFrame-methods.R
Class-SpatialPolygons.R Class-SpatialPolygonsDataFrame.R
SpatialPolygons-methods.R SpatialPolygonsDataFrame-methods.R
GridTopology-methods.R SpatialGrid-methods.R
SpatialGridDataFrame-methods.R SpatialPolygons-internals.R
point.in.polygon.R SpatialPolygons-displayMethods.R zerodist.R
image.R stack.R bubble.R mapasp.R select.spatial.R gridded.R
asciigrid.R spplot.R over.R spsample.R recenter.R dms.R
gridlines.R spdists.R rbind.R flipSGDF.R chfids.R loadmeuse.R
compassRose.R surfaceArea.R spOptions.R subset.R disaggregate.R
sp_spat1.R merge.R aggregate.R elide.R sp2Mondrian.R</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-26 11:02:23 UTC; edzer</td>
</tr>
<tr>
<td>Author:</td>
<td>Edzer Pebesma [aut, cre],
  Roger Bivand [aut],
  Barry Rowlingson [ctb],
  Virgilio Gomez-Rubio [ctb],
  Robert Hijmans [ctb],
  Michael Sumner [ctb],
  Don MacQueen [ctb],
  Jim Lemon [ctb],
  Finn Lindgren [ctb],
  Josh O'Brien [ctb],
  Joseph O'Rourke [ctb],
  Patrick Hausmann [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edzer Pebesma &lt;edzer.pebesma@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-26 23:20:07 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:27:51 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='addAttrToGeom-methods'> constructs SpatialXxxDataFrame from geometry and attributes</h2><span id='topic+addAttrToGeom'></span><span id='topic+addAttrToGeom-methods'></span><span id='topic+addAttrToGeom+2CSpatialPoints+2Cdata.frame-method'></span><span id='topic+addAttrToGeom+2CSpatialMultiPoints+2Cdata.frame-method'></span><span id='topic+addAttrToGeom+2CSpatialGrid+2Cdata.frame-method'></span><span id='topic+addAttrToGeom+2CSpatialPixels+2Cdata.frame-method'></span><span id='topic+addAttrToGeom+2CSpatialPolygons+2Cdata.frame-method'></span><span id='topic+addAttrToGeom+2CSpatialLines+2Cdata.frame-method'></span>

<h3>Description</h3>

<p> constructs SpatialXxxDataFrame from geometry and attributes</p>


<h3>Usage</h3>

<pre><code class='language-R'>addAttrToGeom(x, y, match.ID, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addAttrToGeom-methods_+3A_x">x</code></td>
<td>
<p>geometry (locations) of the queries</p>
</td></tr>
<tr><td><code id="addAttrToGeom-methods_+3A_y">y</code></td>
<td>
<p>data.frame object with attributes</p>
</td></tr>
<tr><td><code id="addAttrToGeom-methods_+3A_match.id">match.ID</code></td>
<td>
<p> logical; if TRUE, the IDs of the geometry and of the
data.frame are matched (possibly swapping records), and an error occurs
when some IDs do not match </p>
</td></tr>
<tr><td><code id="addAttrToGeom-methods_+3A_...">...</code></td>
<td>
<p>(optional) arguments passed to the constructor functions </p>
</td></tr>
</table>


<h3>Value</h3>

<p> an object of class XxxDataFrame, where Xxx is the class of x</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;SpatialPoints&quot;, y = &quot;data.frame&quot;</dt><dd> </dd>
<dt>x = &quot;SpatialPixels&quot;, y = &quot;data.frame&quot;</dt><dd> </dd>
<dt>x = &quot;SpatialGrid&quot;, y = &quot;data.frame&quot;</dt><dd> </dd>
<dt>x = &quot;SpatialLines&quot;, y = &quot;data.frame&quot;</dt><dd> </dd>
<dt>x = &quot;SpatialPolygons&quot;, y = &quot;data.frame&quot;</dt><dd> </dd>
</dl>



<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a></p>


<h3>See Also</h3>

<p><a href="grDevices.html#topic+over">over</a></p>

<hr>
<h2 id='aggregate'> aggregation of spatial objects </h2><span id='topic+aggregate'></span><span id='topic+aggregate.Spatial'></span>

<h3>Description</h3>

<p> spatial aggregation of thematic information in spatial objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Spatial'
aggregate(x, by = list(ID = rep(1, length(x))),
	FUN, ..., dissolve = TRUE, areaWeighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_+3A_x">x</code></td>
<td>
<p>object deriving from <a href="sp.html#topic+Spatial">Spatial</a>, with attributes </p>
</td></tr>
<tr><td><code id="aggregate_+3A_by">by</code></td>
<td>
<p>aggregation predicate; if <code>by</code> is a <a href="sp.html#topic+Spatial">Spatial</a> object,
the geometry by which attributes in <code>x</code> are aggregated; if <code>by</code>
is a list, aggregation by attribute(s), see <a href="stats.html#topic+aggregate.data.frame">aggregate.data.frame</a></p>
</td></tr>
<tr><td><code id="aggregate_+3A_fun">FUN</code></td>
<td>
<p>aggregation function, e.g. <a href="base.html#topic+mean">mean</a>; see details</p>
</td></tr>
<tr><td><code id="aggregate_+3A_...">...</code></td>
<td>
<p>arguments passed on to function <code>FUN</code>, unless <code>minDimension</code>
is specified, which is passed on to function <a href="grDevices.html#topic+over">over</a></p>
</td></tr>
<tr><td><code id="aggregate_+3A_dissolve">dissolve</code></td>
<td>
<p>logical; should, when aggregating based on attributes, the
resulting geometries be dissolved? Note that if <code>x</code> has class
<code>SpatialPointsDataFrame</code>, this returns an object of class <code>SpatialMultiPointsDataFrame</code>; deprecated</p>
</td></tr>
<tr><td><code id="aggregate_+3A_areaweighted">areaWeighted</code></td>
<td>
<p>logical; should the aggregation of <code>x</code> be weighted by the
areas it intersects with each feature of <code>by</code>? See value; deprecated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For as far as these functions use package rgeos, (lines, polygons,
dissolve = TRUE), they are deprecated as rgeos will retire; try
using sf::aggregate instead.
</p>
<p><code>FUN</code> should be a function that takes as first argument a
vector, and that returns a single number. The canonical examples
are <a href="base.html#topic+mean">mean</a> and <a href="base.html#topic+sum">sum</a>. Counting features is obtained when
summing an attribute variable that has the value 1 everywhere.
</p>


<h3>Value</h3>

 
<p>The aggregation of attribute values of <code>x</code> either over the
geometry of <code>by</code> by using <a href="grDevices.html#topic+over">over</a> for spatial matching,
or by attribute values, using aggregation function <code>FUN</code>.
</p>
<p>If <code>areaWeighted</code> is <code>TRUE</code>, <code>FUN</code> is ignored and the
area weighted mean is computed for numerical variables, or if all
attributes are <code>factor</code>s, the area dominant factor level (area
mode) is returned.  This computes the intersection of <code>x</code>
and <code>by</code>; see examples below.  As this uses code from package
rgeos, it is deprecated as package rgeos will retire.
</p>
<p>If <code>by</code> is missing, aggregates over all features.
</p>


<h3>Note</h3>

<p> uses <a href="grDevices.html#topic+over">over</a> to find spatial match if <code>by</code> is a 
<a href="sp.html#topic+Spatial">Spatial</a> object </p>


<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("meuse")
coordinates(meuse) &lt;- ~x+y
data("meuse.grid")
coordinates(meuse.grid) &lt;- ~x+y
gridded(meuse.grid) &lt;- TRUE
i = cut(meuse.grid$dist, c(0,.25,.5,.75,1), include.lowest = TRUE)
j = sample(1:2, 3103,replace=TRUE)

x = aggregate(meuse.grid["dist"], list(i=i,j=j), mean, dissolve = FALSE)
spplot(x["j"], col.regions=bpy.colors())


</code></pre>

<hr>
<h2 id='as.SpatialPolygons.GridTopology'>Make SpatialPolygons object from GridTopology object</h2><span id='topic+as.SpatialPolygons.GridTopology'></span><span id='topic+coerce+2CGridTopology+2CSpatialPolygons-method'></span><span id='topic+HexPoints2SpatialPolygons'></span><span id='topic+IDvaluesGridTopology'></span><span id='topic+as.SpatialPolygons.SpatialPixels'></span><span id='topic+coerce+2CSpatialPixels+2CSpatialPolygons-method'></span><span id='topic+IDvaluesSpatialPixels'></span>

<h3>Description</h3>

<p>Converts grids of regular rectangles into a <code>SpatialPolygons</code> object, which can be transformed to a different projection or datum with <code>spTransform</code> in package <code>rgdal</code>. The function is not suitable for high-resolution grids. The ordering of the grid cells is as in <code>coordinates()</code> of the same object, and is reported by <code>IDvaluesGridTopology</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SpatialPolygons.GridTopology(grd, proj4string = CRS(as.character(NA)))
IDvaluesGridTopology(obj)
as.SpatialPolygons.SpatialPixels(obj)
IDvaluesSpatialPixels(obj)
HexPoints2SpatialPolygons(hex, dx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatialPolygons.GridTopology_+3A_grd">grd</code></td>
<td>
<p><code>GridTopology</code> object</p>
</td></tr>
<tr><td><code id="as.SpatialPolygons.GridTopology_+3A_proj4string">proj4string</code></td>
<td>
<p>object of class <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</td></tr>
<tr><td><code id="as.SpatialPolygons.GridTopology_+3A_obj">obj</code></td>
<td>
 <p><code>SpatialPixels</code> object </p>
</td></tr>
<tr><td><code id="as.SpatialPolygons.GridTopology_+3A_hex">hex</code></td>
<td>
 <p><code>SpatialPoints</code> object with points that are generated by hexagonal sampling; 
see <a href="sp.html#topic+spsample">spsample</a></p>
</td></tr>
<tr><td><code id="as.SpatialPolygons.GridTopology_+3A_dx">dx</code></td>
<td>
<p> spacing of two horizontally adjacent points; if missing, this will be computed
from the points </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.SpatialPolygons.GridTopology</code> and <code>as.SpatialPolygons.SpatialPixels</code> return a <code>SpatialPolygons</code> object;
<code>IDvaluesGridTopology</code> and <code>IDvaluesSpatialPixels</code> return a character vector with the object grid indices.
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+GridTopology">GridTopology</a></code>, <code><a href="sp.html#topic+SpatialPixels">SpatialPixels</a></code>, <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code>
<code>spTransform</code> in package <code>rgdal</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lattice)
grd &lt;- GridTopology(cellcentre.offset=c(-175,55), cellsize=c(10,10), cells.dim=c(4,4))
SpP_grd &lt;- as.SpatialPolygons.GridTopology(grd)
plot(SpP_grd)
text(coordinates(SpP_grd), sapply(slot(SpP_grd, "polygons"), function(i) slot(i, "ID")), cex=0.5)
trdata &lt;- data.frame(A=rep(c(1,2,3,4), 4), B=rep(c(1,2,3,4), each=4),
 row.names=sapply(slot(SpP_grd, "polygons"), function(i) slot(i, "ID")))
SpPDF &lt;- SpatialPolygonsDataFrame(SpP_grd, trdata)
spplot(SpPDF)

data(meuse.grid)
gridded(meuse.grid)=~x+y
xx = spsample(meuse.grid,  type="hexagonal", cellsize=200)
xxpl = HexPoints2SpatialPolygons(xx)
image(meuse.grid["dist"])
plot(xxpl, add = TRUE)
points(xx, cex = .5)
## Not run: 
spplot(aggregate(as(meuse.grid[,1:3], "SpatialPolygonsDataFrame"), xxpl,
 areaWeighted=TRUE), main = "aggregated meuse.grid")

## End(Not run)
</code></pre>

<hr>
<h2 id='as.SpatialPolygons.PolygonsList'>Making SpatialPolygons objects</h2><span id='topic+as.SpatialPolygons.PolygonsList'></span>

<h3>Description</h3>

<p>This function is used in making SpatialPolygons objects from other formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SpatialPolygons.PolygonsList(Srl, proj4string=CRS(as.character(NA)))



</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatialPolygons.PolygonsList_+3A_srl">Srl</code></td>
<td>
<p>A list of Polygons objects</p>
</td></tr>


<tr><td><code id="as.SpatialPolygons.PolygonsList_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class <code>"CRS"</code>;
holding a valid proj4 string</p>
</td></tr>




</table>


<h3>Value</h3>

<p>The functions return a SpatialPolygons object
</p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>


<h3>Examples</h3>

<pre><code class='language-R'>grd &lt;- GridTopology(c(1,1), c(1,1), c(10,10))
polys &lt;- as.SpatialPolygons.GridTopology(grd)
plot(polys)
text(coordinates(polys), labels=sapply(slot(polys, "polygons"), function(i) slot(i, "ID")), cex=0.6)
</code></pre>

<hr>
<h2 id='bbox-methods'> retrieve bbox from spatial data</h2><span id='topic+bbox+2CSpatial-method'></span><span id='topic+bbox+2CANY-method'></span><span id='topic+bbox+2CLine-method'></span><span id='topic+bbox+2CLines-method'></span><span id='topic+bbox+2CPolygon-method'></span><span id='topic+bbox+2CPolygons-method'></span><span id='topic+bbox'></span>

<h3>Description</h3>

<p>retrieves spatial bounding box from spatial data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	bbox(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox-methods_+3A_obj">obj</code></td>
<td>
<p> object deriving from class &quot;Spatial&quot;, or one of classes: &quot;Line&quot;, &quot;Lines&quot;, &quot;Polygon&quot; or &quot;Polygons&quot;, or ANY, which requires obj to be an array with at least two columns </p>
</td></tr>
</table>


<h3>Value</h3>

<p> two-column matrix; the first column has the minimum,
the second the maximum values; rows represent the spatial
dimensions</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;Spatial&quot;</dt><dd><p> object deriving from class &quot;Spatial&quot; </p>
</dd>
<dt>obj = &quot;ANY&quot;</dt><dd><p> an array with at least two columns </p>
</dd>
<dt>obj = &quot;Line&quot;</dt><dd><p> object deriving from class &quot;Line&quot; </p>
</dd>
<dt>obj = &quot;Lines&quot;</dt><dd><p> object deriving from class &quot;Lines&quot; </p>
</dd>
<dt>obj = &quot;Polygon&quot;</dt><dd><p> object deriving from class &quot;Polygon&quot; </p>
</dd>
<dt>obj = &quot;Polygons&quot;</dt><dd><p> object deriving from class &quot;Polygons&quot; </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># just 9 points on a grid:
x &lt;- c(1,1,1,2,2,2,3,3,3)
y &lt;- c(1,2,3,1,2,3,1,2,3)
xy &lt;- cbind(x,y)
S &lt;- SpatialPoints(xy)
bbox(S)

# data.frame
data(meuse.grid)
coordinates(meuse.grid) &lt;- ~x+y
gridded(meuse.grid) &lt;- TRUE
bbox(meuse.grid)

</code></pre>

<hr>
<h2 id='bpy.colors'> blue-pink-yellow color scheme, which also prints well on 
black/white printers </h2><span id='topic+bpy.colors'></span>

<h3>Description</h3>

<p> Create a vector of &lsquo;n&rsquo; &ldquo;contiguous&rdquo; colors.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> bpy.colors(n = 100, cutoff.tails = 0.1, alpha = 1.0) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpy.colors_+3A_n">n</code></td>
<td>
<p>number of colors (&gt;= 1) to be in the palette</p>
</td></tr>
<tr><td><code id="bpy.colors_+3A_cutoff.tails">cutoff.tails</code></td>
<td>
<p>tail fraction to be cut off on each side.  If 0,
this palette runs from black to white; by cutting off the tails, it runs
from blue to yellow, which looks nicer. </p>
</td></tr>
<tr><td><code id="bpy.colors_+3A_alpha">alpha</code></td>
<td>
<p>numeric; alpha transparency, 0 is fully transparent, 1 is opaque. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> A character vector, &lsquo;cv&rsquo;, of color names.  This can be used
either to create a user-defined color palette for subsequent graphics
by &lsquo;palette(cv)&rsquo;, a &lsquo;col=&rsquo; specification in graphics functions or in
&lsquo;par&rsquo;.  </p>


<h3>Note</h3>

<p> This color map prints well on black-and-white printers. </p>


<h3>Author(s)</h3>

<p> unknown; the pallette was posted to gnuplot-info a few
decades ago; R implementation Edzer Pebesma, 
<a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a></p>


<h3>See Also</h3>

<p><a href="grDevices.html#topic+rainbow">rainbow</a>, <a href="grDevices.html#topic+cm.colors">cm.colors</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>bpy.colors(10)
p &lt;- expand.grid(x=1:30,y=1:30)
p$z &lt;- p$x + p$y
coordinates(p) &lt;- c("x", "y")
gridded(p) &lt;- TRUE
image(p, col = bpy.colors(100), asp = 1)
# require(lattice)
# trellis.par.set("regions", list(col=bpy.colors())) # make this default pallette
</code></pre>

<hr>
<h2 id='bubble'>
Create a bubble plot of spatial data
</h2><span id='topic+bubble'></span>

<h3>Description</h3>

<p>Create a bubble plot of spatial data, with options for bicolour
residual plots (xyplot wrapper)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bubble(obj, zcol = 1, ..., fill = TRUE, maxsize = 3, do.sqrt = TRUE, pch, 
	col = c("#d01c8b", "#4dac26"), key.entries = quantile(data[,zcol]), main, 
	identify = FALSE, labels = row.names(data.frame(obj)), key.space = "right",
	scales = list(draw = FALSE), xlab = NULL, ylab = NULL, panel = panel.bubble,
	sp.layout = NULL, 
	xlim = bbexpand(bbox(obj)[1,], 0.04), 
	ylim = bbexpand(bbox(obj)[2,], 0.04))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bubble_+3A_obj">obj</code></td>
<td>
<p> object of, or extending, class SpatialPointsDataFrame 
or SpatialGridDataFrame, see <a href="raster.html#topic+coordinates">coordinates</a> or <a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a>; 
the object knows about its spatial coordinates</p>
</td></tr>
<tr><td><code id="bubble_+3A_zcol">zcol</code></td>
<td>
<p> z-variable column name, or column number after removing
spatial coordinates from x@data: 1 refers to the first non-coordinate
column </p>
</td></tr>
<tr><td><code id="bubble_+3A_fill">fill</code></td>
<td>
<p> logical; if TRUE, filled circles are plotted (pch = 16), 
else open circles (pch = 1); the pch argument overrides this </p>
</td></tr>
<tr><td><code id="bubble_+3A_maxsize">maxsize</code></td>
<td>
 <p><code>cex</code> value for largest circle </p>
</td></tr>
<tr><td><code id="bubble_+3A_do.sqrt">do.sqrt</code></td>
<td>
<p> logical; if TRUE the plotting symbol area (sqrt(diameter)) 
is proportional to the value of the z-variable; if FALSE, the symbol size
(diameter) is proportional to the z-variable </p>
</td></tr>
<tr><td><code id="bubble_+3A_pch">pch</code></td>
<td>
<p> plotting character </p>
</td></tr>
<tr><td><code id="bubble_+3A_col">col</code></td>
<td>
<p> colours to be used; numeric vector of size two: first value
is for negative values, second for positive values. Default colors: 
5-class PiYG from colorbrewer.org. </p>
</td></tr>
<tr><td><code id="bubble_+3A_key.entries">key.entries</code></td>
<td>
<p> the values that will be plotted in the key; by default 
the five quantiles min, q.25, median q.75, max </p>
</td></tr>
<tr><td><code id="bubble_+3A_main">main</code></td>
<td>
<p> main plotting title </p>
</td></tr>
<tr><td><code id="bubble_+3A_identify">identify</code></td>
<td>
<p> logical; if true, regular <code>plot</code> is called instead of
<code>xyplot</code>, and followed by a call to <code>identify()</code>. </p>
</td></tr>
<tr><td><code id="bubble_+3A_labels">labels</code></td>
<td>
<p> labels argument passed to <code>plot</code> if <code>identify</code>
is TRUE </p>
</td></tr>
<tr><td><code id="bubble_+3A_...">...</code></td>
<td>
<p> arguments, passed to <code>xyplot</code>, or <code>plot</code> if 
identification is required. </p>
</td></tr>
<tr><td><code id="bubble_+3A_key.space">key.space</code></td>
<td>
<p>location of the key</p>
</td></tr>
<tr><td><code id="bubble_+3A_scales">scales</code></td>
<td>
<p>scales argument as passed to <a href="lattice.html#topic+xyplot">xyplot</a></p>
</td></tr>
<tr><td><code id="bubble_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="bubble_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="bubble_+3A_panel">panel</code></td>
<td>
<p>panel function used</p>
</td></tr>
<tr><td><code id="bubble_+3A_sp.layout">sp.layout</code></td>
<td>
<p>possible layout items; see <a href="raster.html#topic+spplot">spplot</a></p>
</td></tr>
<tr><td><code id="bubble_+3A_xlim">xlim</code></td>
<td>
<p>x axis limit</p>
</td></tr>
<tr><td><code id="bubble_+3A_ylim">ylim</code></td>
<td>
<p>y axis limit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns (or plots) the bubble plot; if <code>identify</code> is TRUE, returns
the indexes (row numbers) of identified points.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>See Also</h3>

<p><a href="lattice.html#topic+xyplot">xyplot</a>, <a href="sp.html#topic+mapasp">mapasp</a>, <a href="graphics.html#topic+identify">identify</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
coordinates(meuse) &lt;- c("x", "y") # promote to SpatialPointsDataFrame
bubble(meuse, "cadmium", maxsize = 2.5, main = "cadmium concentrations (ppm)", 
    key.entries = 2^(-1:4))
bubble(meuse, "zinc", main = "zinc concentrations (ppm)",
    key.entries =  100 * 2^(0:4))
</code></pre>

<hr>
<h2 id='char2dms'>Convert character vector to DMS-class object</h2><span id='topic+char2dms'></span><span id='topic+dd2dms'></span><span id='topic+coerce+2CDMS+2Cnumeric-method'></span><span id='topic+coerce+2CDMS+2Ccharacter-method'></span><span id='topic+as.character.DMS'></span>

<h3>Description</h3>

<p>These two helper functions convert character vectors and decimal degree vectors to the DMS-class representation of degrees, minutes, and decimal seconds. &quot;DMS&quot; objects cannot contain NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2dms(from, chd = "d", chm = "'", chs = "\"")
dd2dms(dd, NS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char2dms_+3A_from">from</code></td>
<td>
<p>character vector of degree, minute, decimal second data</p>
</td></tr>
<tr><td><code id="char2dms_+3A_chd">chd</code></td>
<td>
<p>degree character terminator</p>
</td></tr>
<tr><td><code id="char2dms_+3A_chm">chm</code></td>
<td>
<p>minute character terminator</p>
</td></tr>
<tr><td><code id="char2dms_+3A_chs">chs</code></td>
<td>
<p>second character terminator</p>
</td></tr>
<tr><td><code id="char2dms_+3A_dd">dd</code></td>
<td>
<p>numeric vector of decimal degrees</p>
</td></tr>
<tr><td><code id="char2dms_+3A_ns">NS</code></td>
<td>
<p>logical, TRUE for north/south decimal degrees, FALSE for east/west decimal degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In char2dms, the input data vector should use a regular format, such as that used in the PROJ.4 library, with a trailing capital (NSWE) indicating compass direction.
</p>


<h3>Value</h3>

<p>Both functions return a &quot;DMS&quot; object.
</p>


<h3>Methods</h3>


<dl>
<dt>from = &quot;DMS&quot;, to = &quot;numeric&quot;</dt><dd><p>coerce a <code>"DMS"</code> object to a <code>"numeric"</code> vector</p>
</dd>
<dt>from = &quot;DMS&quot;, to = &quot;character&quot;</dt><dd><p>coerce a <code>"DMS"</code> object to a <code>"character"</code> vector (the <code>as.character.DMS</code> S3 method is also available)</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> </p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+DMS-class">DMS-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(state)
str(state.center$y)
stateN &lt;- dd2dms(state.center$y, NS=TRUE)
str(attributes(stateN))
ch.stateN &lt;- as.character(stateN)
str(ch.stateN)
stateNa &lt;- char2dms(ch.stateN)
str(attributes(stateNa))
ch.stateN &lt;- as(stateN, "character")
str(ch.stateN)
stateNa &lt;- char2dms(ch.stateN)
str(attributes(stateNa))
</code></pre>

<hr>
<h2 id='compassRose'>Display a compass rose.</h2><span id='topic+compassRose'></span>

<h3>Description</h3>

<p>Displays a basic compass rose, usually to orient a map.</p>


<h3>Usage</h3>

<pre><code class='language-R'> compassRose(x,y,rot=0,cex=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compassRose_+3A_x">x</code>, <code id="compassRose_+3A_y">y</code></td>
<td>
<p>The position of the center of the compass rose in user units.</p>
</td></tr>
<tr><td><code id="compassRose_+3A_rot">rot</code></td>
<td>
<p>Rotation for the compass rose in degrees. See Details.</p>
</td></tr>
<tr><td><code id="compassRose_+3A_cex">cex</code></td>
<td>
<p>The character expansion to use in the display.</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>&lsquo;<span class="samp">&#8288;compassRose&#8288;</span>&rsquo; displays a conventional compass rose at the position
requested. The size of the compass rose is determined by the character
expansion, as the central &quot;rose&quot; is calculated relative to the character size.
Rotation is in degrees counterclockwise.
</p>


<h3>Value</h3>

<p>nil</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>

<hr>
<h2 id='coordinates'> set spatial coordinates to create a Spatial object, or retrieve
spatial coordinates from a Spatial object</h2><span id='topic+coordinates'></span><span id='topic+coordinates+3C-'></span>

<h3>Description</h3>

<p> set spatial coordinates to create a Spatial object, or retrieve
spatial coordinates from a Spatial object</p>


<h3>Usage</h3>

<pre><code class='language-R'>	coordinates(obj, ...)
	coordinates(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordinates_+3A_obj">obj</code></td>
<td>
<p> object deriving from class &quot;Spatial&quot; </p>
</td></tr>
<tr><td><code id="coordinates_+3A_object">object</code></td>
<td>
<p> object of class &quot;data.frame&quot; </p>
</td></tr>
<tr><td><code id="coordinates_+3A_value">value</code></td>
<td>
<p> spatial coordinates; either a matrix, list, or data
frame with numeric data, or column names, column number or a
reference: a formula (in the form of e.g. <code>~x+y</code>), column numbers
(e.g. <code>c(1,2)</code>) or column names (e.g. <code>c("x","y")</code>) specifying
which columns in <code>object</code> are the spatial coordinates. If the coordinates
are part of object, giving the reference does not duplicate them, giving
their value does duplicate them in the resulting structure.
</p>
</td></tr>
<tr><td><code id="coordinates_+3A_...">...</code></td>
<td>
<p>additional arguments that may be used by particular methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p> usually an object of class SpatialPointsDataFrame; if the coordinates
set cover the full set of variables in object, an object of class SpatialPoints
is returned </p>


<h3>Examples</h3>

<pre><code class='language-R'># data.frame
data(meuse.grid)
coordinates(meuse.grid) &lt;- ~x+y
gridded(meuse.grid) &lt;- TRUE
class(meuse.grid)
bbox(meuse.grid)

data(meuse)
meuse.xy = meuse[c("x", "y")]
coordinates(meuse.xy) &lt;- ~x+y
class(meuse.xy)

</code></pre>

<hr>
<h2 id='coordinates-methods'> retrieve (or set) spatial coordinates </h2><span id='topic+coordinates-methods'></span><span id='topic+coordinates+2Clist-method'></span><span id='topic+coordinates+2Cdata.frame-method'></span><span id='topic+coordinates+2Cmatrix-method'></span><span id='topic+coordinates+2CSpatialPoints-method'></span><span id='topic+coordinates+2CSpatialMultiPoints-method'></span><span id='topic+coordinates+2CSpatialPolygons-method'></span><span id='topic+coordinates+2CSpatialPolygonsDataFrame-method'></span><span id='topic+coordinates+2CLine-method'></span><span id='topic+coordinates+2CLines-method'></span><span id='topic+coordinates+2CSpatialLines-method'></span><span id='topic+coordinates+2CGridTopology-method'></span><span id='topic+coordinates+2CSpatialPixels-method'></span><span id='topic+coordinates+2CSpatialPixelsDataFrame-method'></span><span id='topic+coordinates+2CSpatialGrid-method'></span><span id='topic+coordinates+2CSpatialGridDataFrame-method'></span><span id='topic+coordinates+3C-+2Cdata.frame-method'></span>

<h3>Description</h3>

<p> retrieve (or set) spatial coordinates from (for) spatial data </p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;list&quot;</dt><dd><p> list with (at least) two numeric components of equal length </p>
</dd>
<dt>obj = &quot;data.frame&quot;</dt><dd><p> data.frame with at least two numeric components </p>
</dd>
<dt>obj = &quot;matrix&quot;</dt><dd><p> numeric matrix with at least two columns </p>
</dd>
<dt>obj = &quot;SpatialPoints&quot;</dt><dd><p> object of, or deriving from, SpatialPoints </p>
</dd>
<dt>obj = &quot;SpatialPointsDataFrame&quot;</dt><dd><p> object of, or deriving from, 
SpatialPointsDataFrame </p>
</dd>
<dt>obj = &quot;SpatialPolygons&quot;</dt><dd><p> object of, or deriving from, SpatialPolygons </p>
</dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;</dt><dd><p> object of, or deriving from, 
SpatialPolygonsDataFrame </p>
</dd>
<dt>obj = &quot;Line&quot;</dt><dd><p> object of class Line; returned value is matrix </p>
</dd>
<dt>obj = &quot;Lines&quot;</dt><dd><p> object of class Lines; returned value is list of matrices </p>
</dd>
<dt>obj = &quot;SpatialLines&quot;</dt><dd><p> object of, or deriving from, SpatialLines; returned
value is list of lists of matrices </p>
</dd>
<dt>obj = &quot;GridTopology&quot;</dt><dd><p> object of, or deriving from, GridTopology </p>
</dd>
<dt>obj = &quot;GridTopology&quot;</dt><dd><p> object of, or deriving from, GridTopology </p>
</dd>
<dt>obj = &quot;SpatialPixels&quot;</dt><dd><p> object of, or deriving from, SpatialPixels </p>
</dd>
<dt>obj = &quot;SpatialPixelsDataFrame&quot;</dt><dd><p> object of, or deriving from, SpatialPixelsDataFrame </p>
</dd>
<dt>obj = &quot;SpatialGrid&quot;</dt><dd><p> object of, or deriving from, SpatialGrid </p>
</dd>
<dt>obj = &quot;SpatialGridDataFrame&quot;</dt><dd><p> object of, or deriving from, SpatialGridDataFrame </p>
</dd>
</dl>


<h3>Methods for &quot;coordinates&lt;-&quot;</h3>


<dl>
<dt>object = &quot;data.frame&quot;, value=&quot;ANY&quot;</dt><dd><p> promote data.frame to object of class
<a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a>, by specifying coordinates; see <a href="raster.html#topic+coordinates">coordinates</a></p>
</dd>
</dl>

<hr>
<h2 id='coordnames-methods'> retrieve or assign coordinate names for classes in sp</h2><span id='topic+coordnames'></span><span id='topic+coordnames-methods'></span><span id='topic+coordnames+2CSpatialPoints-method'></span><span id='topic+coordnames+2CSpatialMultiPoints-method'></span><span id='topic+coordnames+2CSpatialLines-method'></span><span id='topic+coordnames+2CLines-method'></span><span id='topic+coordnames+2CLine-method'></span><span id='topic+coordnames+2CPolygon-method'></span><span id='topic+coordnames+2CPolygons-method'></span><span id='topic+coordnames+2CSpatialPolygons-method'></span><span id='topic+coordnames+3C-'></span><span id='topic+coordnames+3C-+2CSpatialPoints+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CSpatialMultiPoints+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CSpatialLines+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CLines+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CLine+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CSpatialPolygons+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CGridTopology+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CSpatialGrid+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CSpatialPixels+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CGridTopology+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CSpatialGrid+2Ccharacter-method'></span><span id='topic+coordnames+3C-+2CSpatialPixels+2Ccharacter-method'></span>

<h3>Description</h3>

<p>retrieve or assign coordinate names for classes in <span class="pkg">sp</span>
</p>


<h3>Methods for coordnames</h3>


<dl>
<dt>x = &quot;SpatialPoints&quot;</dt><dd><p> retrieves coordinate names </p>
</dd>
<dt>x = &quot;SpatialLines&quot;</dt><dd><p> retrieves coordinate names </p>
</dd>
<dt>x = &quot;Lines&quot;</dt><dd><p> retrieves coordinate names </p>
</dd>
<dt>x = &quot;Line&quot;</dt><dd><p> retrieves coordinate names </p>
</dd>
<dt>x = &quot;SpatialPolygons&quot;</dt><dd><p> retrieves coordinate names </p>
</dd>
<dt>x = &quot;Polygons&quot;</dt><dd><p> retrieves coordinate names </p>
</dd>
<dt>x = &quot;Polygon&quot;</dt><dd><p> retrieves coordinate names </p>
</dd>
</dl>


<h3>Methods for &quot;coordnames&lt;-&quot;</h3>


<dl>
<dt>x = &quot;SpatialPoints&quot;, value = &quot;character&quot;</dt><dd><p> replace coordinate names </p>
</dd>
<dt>x = &quot;SpatialLines&quot;, value = &quot;character&quot;</dt><dd><p> replace coordinate names </p>
</dd>
<dt>x = &quot;Lines&quot;, value = &quot;character&quot;</dt><dd><p> replace coordinate names </p>
</dd>
<dt>x = &quot;Line&quot;, value = &quot;character&quot;</dt><dd><p> replace coordinate names </p>
</dd>
<dt>x = &quot;SpatialPolygons&quot;, value = &quot;character&quot;</dt><dd><p> replace coordinate names </p>
</dd>
<dt>x = &quot;GridTopology&quot;, value = &quot;character&quot;</dt><dd><p> replace coordinate names </p>
</dd>
<dt>x = &quot;SpatialGrid&quot;, value = &quot;character&quot;</dt><dd><p> replace coordinate names </p>
</dd>
<dt>x = &quot;SpatialPixels&quot;, value = &quot;character&quot;</dt><dd><p> replace coordinate names </p>
</dd>
</dl>

<hr>
<h2 id='CRS-class'>Class &quot;CRS&quot; of coordinate reference system arguments</h2><span id='topic+CRS-class'></span><span id='topic+CRS'></span><span id='topic+identicalCRS'></span><span id='topic+print.CRS'></span><span id='topic+show+2CCRS-method'></span><span id='topic+wkt+2CCRS-method'></span><span id='topic+rebuild_CRS'></span><span id='topic+rebuild_CRS+2CCRS-method'></span><span id='topic+is.projected+2CCRS-method'></span>

<h3>Description</h3>

<p>Interface class to the PROJ projection and transformation system. The class is defined as an empty stub accepting value NA in the sp package. The initiation function may call the PROJ library through <span class="pkg">sf</span> to verify the argument set against those known in the library, returning error messages where necessary. If the <code>"CRS"</code> object is instantiated using <code>CRS()</code> with <span class="pkg">sf</span> using PROJ &gt;= 6 and GDAL &gt;= 3, the object may also have a WKT2 (2019) string carried as a <code>comment</code>. The arguments for a Proj.4 string must be entered exactly as in the Proj.4 documentation, in particular there cannot be any white space in <code>+&lt;key&gt;=&lt;value&gt;</code> strings, and successive such strings can only be separated by blanks. Note that only &ldquo;+proj=longlat +ellps=WGS84&rdquo; is accepted for geographical coordinates, which must be ordered (eastings, northings); the &ldquo;+ellps=&rdquo; definition must be given (or expanded internally from a given &ldquo;+datum=&rdquo; value) for recent versions of the Proj.4 library, and should be set to an appropriate value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CRS(projargs, doCheckCRSArgs=TRUE, SRS_string=NULL, get_source_if_boundcrs=TRUE,
 use_cache=TRUE)
identicalCRS(x,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CRS-class_+3A_projargs">projargs</code></td>
<td>
<p>A character string of projection arguments; the arguments must be entered exactly as in the PROJ.4 documentation; if the projection is unknown, use <code>as.character(NA)</code>, it may be missing or an empty string of zero length and will then set to the missing value. With <span class="pkg">sf</span> built with PROJ &gt;= 6 and GDAL &gt;= 3, the <code>+init=</code> key may only be used with value <code>epsg:&lt;code&gt;</code>. From <span class="pkg">sp</span> version 1.4-4, the string associated with the SRS_string argument may be entered as-is and will be set as SRS_string if the projargs argument does not begin with a <code>+</code> (suggested by Mikko Vihtakari).</p>
</td></tr>
<tr><td><code id="CRS-class_+3A_docheckcrsargs">doCheckCRSArgs</code></td>
<td>
<p>default TRUE</p>
</td></tr>
<tr><td><code id="CRS-class_+3A_srs_string">SRS_string</code></td>
<td>
<p>default NULL, only used when <span class="pkg">sf</span> is built with PROJ &gt;= 6 and GDAL &gt;= 3; a valid WKT string or SRS definition such as <code>"EPSG:4326"</code> or <code>"ESRI:102761"</code></p>
</td></tr>
<tr><td><code id="CRS-class_+3A_get_source_if_boundcrs">get_source_if_boundcrs</code></td>
<td>
<p>(from <span class="pkg">rgdal</span> 1.5-17, default TRUE) The presence of the <code>+towgs84=</code> key in a Proj4 string <code>projargs=</code> argument value may promote the output WKT2 CRS to BOUNDCRS for PROJ &gt;= 6 and GDAL &gt;= 3, which is a coordinate operation from the input datum to WGS84. This is often unfortunate, so a PROJ function is called through <span class="pkg">rgdal</span> to retrieve the underlying source definition.</p>
</td></tr>
<tr><td><code id="CRS-class_+3A_use_cache">use_cache</code></td>
<td>
<p>default TRUE, if FALSE ignore cached lookup values</p>
</td></tr>
<tr><td><code id="CRS-class_+3A_x">x</code></td>
<td>
<p>object having a <a href="raster.html#topic+proj4string">proj4string</a> method,
or if <code>y</code> is missing, list with objects that have a <code>proj4string</code> method</p>
</td></tr>
<tr><td><code id="CRS-class_+3A_y">y</code></td>
<td>
<p>object of class <a href="sp.html#topic+Spatial">Spatial</a>, or having a <a href="raster.html#topic+proj4string">proj4string</a> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CRS</code> returns on success an object of class
<a href="sp.html#topic+CRS">CRS</a>. <code>identicalCRS</code> returns a logical, indicating
whether <code>x</code> and <code>y</code> have identical CRS, or if <code>y</code>
is missing whether all objects in list <code>x</code>
have identical CRS.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>CRS("projargs")</code>, where &quot;projargs&quot; is a valid string of PROJ.4 arguments. If the argument is a zero-length string or a character <code>NA</code>, the object records <code>NA</code>. If the <code>"CRS"</code> object is instantiated using <code>CRS()</code> with <span class="pkg">sf</span> using PROJ &gt;= 6 and GDAL &gt;= 3, the object may also have a WKT2 (2019) string carried as a <code>comment</code>. The initiation function may call the PROJ library through <span class="pkg">sf</span> to verify the argument set against those known in the library, returning error messages where necessary.
</p>


<h3>Slots</h3>


<dl>
<dt><code>projargs</code>:</dt><dd><p>Object of class <code>"character"</code>: projection arguments; the arguments must be entered exactly as in the PROJ.4 documentation, in particular there cannot be any white space in +&lt;arg&gt;=&lt;value&gt; strings, and successive such strings can only be separated by blanks. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "CRS")</code>: print deprecated Proj.4 projection arguments and WKT2 2019 representation if available </p>
</dd>
<dt>wkt</dt><dd><p><code>signature(object = "CRS")</code>: return WKT comment on object</p>
</dd>
<dt>rebuild_CRS</dt><dd><p>rebuild a CRS object, usually used to add a WKT comment with PROJ &gt;= 6 and GDAL &gt;= 3</p>
</dd>
</dl>



<h3>Note</h3>

<p>Lists of projections may be seen by using the programs installed with the PROJ.4 library, in particular proj and cs2cs; with the latter, -lp lists projections, -le ellipsoids, -lu units, and -ld datum(s) known to the installed software (available in <span class="pkg">sf</span> using <code>sf_proj_info</code>). These are added to in successive releases, so tracking the website or compiling and installing the most recent revisions will give the greatest choice. Finding the very important datum transformation parameters to be given with the +towgs84 tag is a further challenge, and is essential when the datums used in data to be used together differ. Tracing projection arguments is easier now than before the mass ownership of GPS receivers raised the issue of matching coordinates from different argument sets (GPS output and paper map, for example). See <code>GridsDatums</code>, <code><a href="sf.html#topic+sf_proj_info">sf_proj_info</a></code> for help in finding CRS definitions.
</p>
<p>The 4.9.1 release of the PROJ library omitted a small file of defaults, leading to reports of &ldquo;major axis or radius = 0 or not given&rdquo; errors. From 0.9-3, rgdal checks for the presence of this file (proj_def.dat), and if not found, and under similar conditions to those used by PROJ.4, adds &ldquo;+ellps=WGS84&rdquo; to the input string being checked by <code>checkCRSArgs</code> The &ldquo;+no_defs&rdquo; tag ignores the file of defaults, and the default work-around implemented to get around this problem; strings including &ldquo;init&rdquo; and &ldquo;datum&rdquo; tags also trigger the avoidance of the work-around. Now messages are issued when a candidate CRS is checked; they may be suppressed using <code>suppressMessages</code>.
</p>
<p>From release 6 of the PROJ library, when used in building <span class="pkg">sf</span> with GDAL &gt;= 3, the <code>+datum=</code> key in the Proj.4 string CRS representation is deprecated, and the <code>+towgs84=</code> and <code>+nadgrids=</code> keys may be deprecated soon. For this reason, <span class="pkg">sp</span> and <span class="pkg">sf</span> are starting to use WKT2 (2019) string representations. In <span class="pkg">sp</span>, the <code>"CRS"</code> object in itself remains unchanged, but the content of its <code>"projargs"</code> slot may be degraded. To work around the degradation, a <code>comment</code> is added around the <code>"CRS"</code> object containing a WKT2 (2019) string when <span class="pkg">sf</span> is available and built with PROJ &gt;= 6 and GDAL &gt;=3.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p><a href="https://github.com/OSGeo/PROJ">https://github.com/OSGeo/PROJ</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>CRS()
CRS("")
CRS(as.character(NA))
CRS("+proj=longlat +datum=WGS84")
run &lt;- FALSE
run &lt;- require(sf) 
if (run) {
  print((CRS("+proj=longlat +datum=NAD27")))
}
if (run) {
  print((CRS("+init=epsg:4267")))
}
if (run) {
  print((CRS("+init=epsg:26978")))
}
if (run) {
  print((CRS(paste("+proj=sterea +lat_0=52.15616055555555",
 "+lon_0=5.38763888888889 +k=0.999908 +x_0=155000 +y_0=463000 +ellps=bessel",
 " +towgs84=565.237,50.0087,465.658,-0.406857,0.350733,-1.87035,4.0812 +units=m"))))
}
if (run) {
  print((CRS("+init=epsg:28992")))
}
if (run) {
  print((CRS("EPSG:28992")))
}
if (run) {
  print((CRS(SRS_string="EPSG:28992")))
}
if (run) {
  o &lt;- try(CRS(SRS_string="ESRI:102760"))
  if (!inherits(o, "try-error")) print((o))
}
if (run) {
  o &lt;- try(CRS("EPSG:4326"))
  if (!inherits(o, "try-error")) print((o))
}
if (run) {
  o &lt;- try(CRS("ESRI:102760"))
  if (!inherits(o, "try-error")) print((o))
}
if (run) {
o &lt;- new("Spatial")
proj4string(o) &lt;- CRS("+init=epsg:27700")
}
if (run &amp;&amp; !is.null(comment(slot(o, "proj4string")))) {
  cat(wkt(o), sep="\n")
  cat(wkt(slot(o, "proj4string")), sep="\n")
}
</code></pre>

<hr>
<h2 id='degAxis'> axis with degrees </h2><span id='topic+degAxis'></span>

<h3>Description</h3>

<p>draw axes on a plot using degree symbols in numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degAxis(side, at, labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degAxis_+3A_side">side</code></td>
<td>
<p>integer; see <a href="graphics.html#topic+axis">axis</a></p>
</td></tr>
<tr><td><code id="degAxis_+3A_at">at</code></td>
<td>
<p>numeric; if missing, <a href="graphics.html#topic+axTicks">axTicks</a> is called for nice values; see <a href="graphics.html#topic+axis">axis</a></p>
</td></tr>
<tr><td><code id="degAxis_+3A_labels">labels</code></td>
<td>
<p>character; if omitted labels are constructed with degree symbols, ending
in N/S/E/W; in case of negative degrees, sign is reversed and S or W is added; see <a href="graphics.html#topic+axis">axis</a></p>
</td></tr>
<tr><td><code id="degAxis_+3A_...">...</code></td>
<td>
<p>passed to the actual <a href="graphics.html#topic+axis">axis</a> call</p>
</td></tr>
</table>


<h3>Value</h3>

<p> axis is plotted on current graph </p>


<h3>Note</h3>

<p>decimal degrees are used if variation is small, instead of minutes and seconds</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy = cbind(x = 2 * runif(100) - 1, y = 2 * runif(100) - 1)
plot(SpatialPoints(xy, proj4string = CRS("+proj=longlat +ellps=WGS84")),xlim=c(-1,1),ylim=c(-1,1))
degAxis(1)
degAxis(2, at = c(-1,-0.5,0,0.5,1))
#
</code></pre>

<hr>
<h2 id='dimensions-methods'> retrieve spatial dimensions from spatial data</h2><span id='topic+dimensions+2CSpatial-method'></span><span id='topic+dimensions'></span>

<h3>Description</h3>

<p>retrieves spatial dimensions box from spatial data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	dimensions(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimensions-methods_+3A_obj">obj</code></td>
<td>
<p> object deriving from class &quot;Spatial&quot; </p>
</td></tr>
</table>


<h3>Value</h3>

<p> two-column matrix; the first column has the minimum,
the second the maximum values; rows represent the spatial
dimensions</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;Spatial&quot;</dt><dd><p> object deriving from class &quot;Spatial&quot; </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># just 9 points on a grid:
x &lt;- c(1,1,1,2,2,2,3,3,3)
y &lt;- c(1,2,3,1,2,3,1,2,3)
xy &lt;- cbind(x,y)
S &lt;- SpatialPoints(xy)
dimensions(S)

# data.frame
data(meuse.grid)
coordinates(meuse.grid) &lt;- ~x+y
gridded(meuse.grid) &lt;- TRUE
dimensions(meuse.grid)

</code></pre>

<hr>
<h2 id='disaggregate-methods'> disaggregate SpatialLines, SpatialLinesDataFrame, 
SpatialPolygons, or SpatialPolygonsDataFrame objects </h2><span id='topic+disaggregate'></span><span id='topic+disaggregate-methods'></span><span id='topic+disaggregate+2CSpatialPolygons-method'></span><span id='topic+disaggregate+2CSpatialPolygonsDataFrame-method'></span><span id='topic+disaggregate+2CSpatialLines-method'></span><span id='topic+disaggregate+2CSpatialLinesDataFrame-method'></span>

<h3>Description</h3>

<p> disaggregate SpatialLines, SpatialLinesDataFrame, 
SpatialPolygons, or SpatialPolygonsDataFrame objects, using functions from rgeos to handle polygon hole nesting </p>


<h3>Usage</h3>

<pre><code class='language-R'> disaggregate(x, ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disaggregate-methods_+3A_x">x</code></td>
<td>
<p>object of class <a href="sp.html#topic+SpatialLines">SpatialLines</a> or <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></p>
</td></tr>
<tr><td><code id="disaggregate-methods_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>object of class <a href="sp.html#topic+SpatialLines">SpatialLines</a> or <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a>,
where groups of <a href="sp.html#topic+Line">Line</a> or <a href="sp.html#topic+Polygon">Polygon</a> are disaggregated to
one <a href="sp.html#topic+Line">Line</a> per <a href="sp.html#topic+Lines">Lines</a>, or one <a href="sp.html#topic+Polygon">Polygon</a>
per <a href="sp.html#topic+Polygons">Polygons</a>, respectively.
</p>


<h3>Author(s)</h3>

<p> Robert Hijmans, Edzer Pebesma </p>

<hr>
<h2 id='DMS-class'>Class &quot;DMS&quot; for degree, minute, decimal second values</h2><span id='topic+DMS-class'></span><span id='topic+print.DMS'></span><span id='topic+show+2CDMS-method'></span><span id='topic+coerce+2CDMS-method'></span><span id='topic+as.double.DMS'></span><span id='topic+as.numeric.DMS'></span>

<h3>Description</h3>

<p>The class provides a container for coordinates stored as degree, minute, decimal second values.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("DMS", ...)</code>, converted from decimal degrees using <code>dd2dms()</code>, or converted from character strings using <code>char2dms()</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>WS</code>:</dt><dd><p>Object of class <code>"logical"</code> TRUE if input value negative</p>
</dd>
<dt><code>deg</code>:</dt><dd><p>Object of class <code>"numeric"</code> degrees</p>
</dd>
<dt><code>min</code>:</dt><dd><p>Object of class <code>"numeric"</code> minutes</p>
</dd>
<dt><code>sec</code>:</dt><dd><p>Object of class <code>"numeric"</code> decimal seconds</p>
</dd>
<dt><code>NS</code>:</dt><dd><p>Object of class <code>"logical"</code> TRUE if input value is a Northing</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "DMS", to = "numeric")</code>: convert to decimal degrees </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "DMS")</code>: print data values </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> </p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+char2dms">char2dms</a></code>, <code><a href="sp.html#topic+dd2dms">dd2dms</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(state)
dd2dms(state.center$x)
dd2dms(state.center$y, NS=TRUE)
as.numeric(dd2dms(state.center$y))
as(dd2dms(state.center$y, NS=TRUE), "numeric")
as.numeric.DMS(dd2dms(state.center$y))
state.center$y
</code></pre>

<hr>
<h2 id='elide-methods'>Methods for Function elide in Package &lsquo;maptools&rsquo;</h2><span id='topic+elide-methods'></span><span id='topic+elide+2CSpatialPoints-method'></span><span id='topic+elide+2CSpatialPointsDataFrame-method'></span><span id='topic+elide+2CSpatialLines-method'></span><span id='topic+elide+2CSpatialLinesDataFrame-method'></span><span id='topic+elide+2CSpatialPolygons-method'></span><span id='topic+elide+2CSpatialPolygonsDataFrame-method'></span><span id='topic+elide'></span>

<h3>Description</h3>

<p>Methods for function <code>elide</code> to translate and disguise coordinate placing in the real world. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elide(obj, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elide-methods_+3A_obj">obj</code></td>
<td>
<p>object to be elided</p>
</td></tr>
<tr><td><code id="elide-methods_+3A_...">...</code></td>
<td>
<p>other arguments:
</p>

<dl>
<dt>bb</dt><dd><p>if NULL, uses bounding box of object, otherwise the given bounding box</p>
</dd>
<dt>shift</dt><dd><p>values to shift the coordinates of the input object; this is made ineffective by the scale argument</p>
</dd>
<dt>reflect</dt><dd><p>reverse coordinate axes</p>
</dd>
<dt>scale</dt><dd><p>if NULL, coordinates not scaled; if TRUE, the longer dimension is scaled to lie within [0,1] and aspect maintained; if a scalar, the output range of [0,1] is multiplied by scale</p>
</dd>
<dt>flip</dt><dd><p>translate coordinates on the main diagonal</p>
</dd>
<dt>rotate</dt><dd><p>default 0, rotate angle degrees clockwise around center</p>
</dd>
<dt>center</dt><dd><p>default NULL, if not NULL, the rotation center, numeric of length two</p>
</dd>
<dt>unitsq</dt><dd><p>logical, default FALSE, if TRUE and scale TRUE, impose unit square bounding box (currently only points)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>The methods return objects of the input class object with elided coordinates; the coordinate reference system is not set. Note that if the input coordinates or centroids are in the data slot data.frame of the input object, they should be removed before the use of these methods, otherwise they will betray the input positions.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;SpatialPoints&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialPointsDataFrame&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialLines&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialLinesDataFrame&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialPolygons&quot;</dt><dd><p>elides object</p>
</dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;</dt><dd><p>elides object</p>
</dd>
</dl>


<h3>Note</h3>

<p>Rotation code kindly contributed by Don MacQueen</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
coordinates(meuse) &lt;- c("x", "y")
proj4string(meuse) &lt;- CRS("+init=epsg:28992")
data(meuse.riv)
river_polygon &lt;- Polygons(list(Polygon(meuse.riv)), ID="meuse")
rivers &lt;- SpatialPolygons(list(river_polygon))
proj4string(rivers) &lt;- CRS("+init=epsg:28992")
rivers1 &lt;- elide(rivers, reflect=c(TRUE, TRUE), scale=TRUE)
meuse1 &lt;- elide(meuse, bb=bbox(rivers), reflect=c(TRUE, TRUE), scale=TRUE)
opar &lt;- par(mfrow=c(1,2))
plot(rivers, axes=TRUE)
plot(meuse, add=TRUE)
plot(rivers1, axes=TRUE)
plot(meuse1, add=TRUE)
par(opar)
meuse1 &lt;- elide(meuse, shift=c(10000, -10000))
bbox(meuse)
bbox(meuse1)
rivers1 &lt;- elide(rivers, shift=c(10000, -10000))
bbox(rivers)
bbox(rivers1)
meuse1 &lt;- elide(meuse, rotate=-30, center=apply(bbox(meuse), 1, mean))
bbox(meuse)
bbox(meuse1)
plot(meuse1, axes=TRUE)
</code></pre>

<hr>
<h2 id='flip'> rearrange data in SpatialPointsDataFrame or SpatialGridDataFrame 
for plotting with spplot (levelplot/xyplot wrapper) </h2><span id='topic+flipHorizontal'></span><span id='topic+flipVertical'></span>

<h3>Description</h3>

 
<p>rearrange SpatialPointsDataFrame for plotting with spplot or levelplot </p>


<h3>Usage</h3>

<pre><code class='language-R'>flipHorizontal(x)
flipVertical(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip_+3A_x">x</code></td>
<td>
<p> object of class SpatialGridDataFrame </p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>object of class SpatialGridDataFrame, with pixels flipped horizontally
or vertically. Note that the spatial structure is destroyed (or at least:
drastically changed).  </p>


<h3>Author(s)</h3>

<p>Michael Sumner</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid) # data frame
gridded(meuse.grid) = c("x", "y") # promotes to 
fullgrid(meuse.grid) = TRUE
d = meuse.grid["dist"]
image(d, axes=TRUE)
image(flipHorizontal(d), axes=TRUE)
image(flipVertical(d), axes=TRUE)
</code></pre>

<hr>
<h2 id='geometry-methods'> Methods for retrieving the geometry from a composite (geometry + attributes) object </h2><span id='topic+geometry'></span><span id='topic+geometry-methods'></span><span id='topic+geometry+2CSpatial-method'></span><span id='topic+geometry+2CSpatialPointsDataFrame-method'></span><span id='topic+geometry+2CSpatialMultiPointsDataFrame-method'></span><span id='topic+geometry+2CSpatialGridDataFrame-method'></span><span id='topic+geometry+2CSpatialPixelsDataFrame-method'></span><span id='topic+geometry+2CSpatialLinesDataFrame-method'></span><span id='topic+geometry+2CSpatialPolygonsDataFrame-method'></span><span id='topic+geometry+3C-'></span><span id='topic+geometry+3C-+2Cdata.frame+2CSpatial-method'></span>

<h3>Description</h3>

<p>geometry retrieves the SpatialXxx object from a SpatialXxxDataFrame object,
with Xxx Lines, Points, Polygons, Grid, or Pixels. geometry&lt;- converts a
data.frame into a Spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
geometry(obj) 
geometry(obj) &lt;- value 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geometry-methods_+3A_obj">obj</code></td>
<td>
<p>in case of assignment, a data.frame, else an object of class Spatial</p>
</td></tr>
<tr><td><code id="geometry-methods_+3A_value">value</code></td>
<td>
<p>object of class Spatial</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;Spatial&quot;</dt><dd> </dd>
<dt>obj = &quot;SpatialPointsDataFrame&quot;</dt><dd> </dd>
<dt>obj = &quot;SpatialMultiPointsDataFrame&quot;</dt><dd> </dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;</dt><dd> </dd>
<dt>obj = &quot;SpatialPixelsDataFrame&quot;</dt><dd> </dd>
<dt>obj = &quot;SpatialGridDataFrame&quot;</dt><dd> </dd>
<dt>obj = &quot;SpatialLinesDataFrame&quot;</dt><dd> </dd>
</dl>



<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
m = meuse
coordinates(m) = meuse[, c("x", "y")]
pts = geometry(m)
class(pts)
geometry(meuse) = pts
class(meuse)
identical(m, meuse) # TRUE
</code></pre>

<hr>
<h2 id='gridded-methods'> specify spatial data as being gridded, or find out whether they are </h2><span id='topic+gridded-methods'></span><span id='topic+gridparameters'></span><span id='topic+fullgrid'></span><span id='topic+fullgrid+2CSpatial-method'></span><span id='topic+gridded'></span><span id='topic+gridded+2CSpatial-method'></span><span id='topic+fullgrid+3C-'></span><span id='topic+gridded+3C-'></span><span id='topic+fullgrid+3C-+2CSpatial+2CANY-method'></span><span id='topic+fullgrid+3C-+2CSpatialGrid+2Clogical-method'></span><span id='topic+fullgrid+3C-+2CSpatialGridDataFrame+2Clogical-method'></span><span id='topic+fullgrid+3C-+2CSpatialPixels+2Clogical-method'></span><span id='topic+fullgrid+3C-+2CSpatialPixelsDataFrame+2Clogical-method'></span><span id='topic+gridded+3C-+2CSpatialGrid+2Clogical-method'></span><span id='topic+gridded+3C-+2CSpatialGridDataFrame+2Clogical-method'></span><span id='topic+gridded+3C-+2CSpatialPixels+2Clogical-method'></span><span id='topic+gridded+3C-+2CSpatialPixelsDataFrame+2Clogical-method'></span><span id='topic+gridded+3C-+2CSpatialPoints+2Clist-method'></span><span id='topic+gridded+3C-+2CSpatialPoints+2Clogical-method'></span><span id='topic+gridded+3C-+2CSpatialPointsDataFrame+2Clist-method'></span><span id='topic+gridded+3C-+2CSpatialPointsDataFrame+2Clogical-method'></span><span id='topic+gridded+3C-+2Cdata.frame+2CGridTopology-method'></span><span id='topic+gridded+3C-+2Cdata.frame+2Ccharacter-method'></span><span id='topic+gridded+3C-+2Cdata.frame+2Cformula-method'></span>

<h3>Description</h3>

<p>returns logical (TRUE or FALSE) telling whether the object is gridded
or not; in assignment promotes a non-gridded structure to a gridded
one, or demotes a gridded structure back to a non-structured one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	gridded(obj)
	gridded(obj) &lt;- value
	fullgrid(obj)
	fullgrid(obj) &lt;- value
	gridparameters(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridded-methods_+3A_obj">obj</code></td>
<td>
<p> object deriving from class &quot;Spatial&quot; (for gridded), or
object of class <a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a> (for fullgrid and gridparameters)</p>
</td></tr>
<tr><td><code id="gridded-methods_+3A_value">value</code></td>
<td>
<p>logical replacement values, TRUE or FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p> if obj derives from class Spatial, gridded(object) will tell
whether it is has topology on a regular grid; if assigned TRUE, if the
object derives from SpatialPoints and has gridded topology,
grid topology will be added to object, and the class of the object
will be promoted to <a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a> or 
<a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a>
</p>
<p><code>fullgrid</code> returns a logical, telling whether the grid is full
and ordered (i.e., in full matrix form), or whether it is not full
or unordered (i.e. a list of points that happen to lie on a grid. If
assigned, the way the points are stored may be changed. Changing a set
of points to full matrix form and back may change the original order of
the points, and will remove duplicate points if they were present.
</p>
<p><code>gridparameters</code> returns, if <code>obj</code> inherits from
SpatialGridDataFrame its grid parameters, else it returns numeric(0).  The
returned value is a data.frame with three columns, named cellcentre.offset
(&quot;lower left cell centre coordinates&quot;), cellsize, and cells.dim (cell
dimension); the rows correspond to the spatial dimensions.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;Spatial&quot;</dt><dd><p> object deriving from class &quot;Spatial&quot; </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># just 9 points on a grid:
x &lt;- c(1,1,1,2,2,2,3,3,3)
y &lt;- c(1,2,3,1,2,3,1,2,3)
xy &lt;- cbind(x,y)
S &lt;- SpatialPoints(xy)
class(S)
plot(S)
gridded(S) &lt;- TRUE
gridded(S)
class(S)
summary(S)
plot(S)
gridded(S) &lt;- FALSE
gridded(S)
class(S)

# data.frame
data(meuse.grid)
coordinates(meuse.grid) &lt;- ~x+y
gridded(meuse.grid) &lt;- TRUE
plot(meuse.grid) # not much good
summary(meuse.grid)

</code></pre>

<hr>
<h2 id='gridIndex2nb'>create neighbourhood (nb) object from grid geometry</h2><span id='topic+gridIndex2nb'></span>

<h3>Description</h3>

<p>create neighbourhood (nb) object from grid geometry</p>


<h3>Usage</h3>

<pre><code class='language-R'> gridIndex2nb(obj, maxdist = sqrt(2), fullMat = TRUE, ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridIndex2nb_+3A_obj">obj</code></td>
<td>
<p>object of class <a href="sp.html#topic+SpatialGrid">SpatialGrid</a> or <a href="sp.html#topic+SpatialPixels">SpatialPixels</a></p>
</td></tr>
<tr><td><code id="gridIndex2nb_+3A_maxdist">maxdist</code></td>
<td>
<p> maximum distance to be considered (inclusive), expressed in number
of grid cell (sqrt(2) results in queen neighbours) </p>
</td></tr>
<tr><td><code id="gridIndex2nb_+3A_fullmat">fullMat</code></td>
<td>
<p> use <a href="stats.html#topic+dist">dist</a> to compute distances from grid (row/col) indices;
FALSE avoids forming the full distance matrix, at a large performance cost </p>
</td></tr>
<tr><td><code id="gridIndex2nb_+3A_...">...</code></td>
<td>
<p> arguments passed on to <a href="stats.html#topic+dist">dist</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class nb, which is a list.
</p>
<p>The nb object follows the convention of nb objects in package spdep;
it is a list with each list element corresponding to a grid cell or
pixel; the list element contains the indices of neighbours defined
as cells less than maxdist away, measured in cell unit (N/S/E/W
neighbour has distance 1). 
</p>


<h3>Note</h3>

<p> Unequal grid cell size is ignored; grid cell row/col indices
are taken to be the coordinates from which distances are computed.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p>plot.nb in package spdep</p>

<hr>
<h2 id='gridlines'> Create N-S and E-W grid lines over a geographic region </h2><span id='topic+gridlines'></span><span id='topic+gridat'></span><span id='topic+text'></span><span id='topic+text.SpatialPointsDataFrame'></span><span id='topic+labels'></span><span id='topic+labels.SpatialLines'></span>

<h3>Description</h3>

<p> Create N-S and E-W grid lines over a geographic region; create and plot corresponding labels </p>


<h3>Usage</h3>

<pre><code class='language-R'>gridlines(x, easts = pretty(bbox(x)[1,]), norths = pretty(bbox(x)[2,]),
 ndiscr = 100) 
gridat(x, easts = pretty(bbox(x)[1,]), norths = pretty(bbox(x)[2,]),
 offset = 0.5, side = "WS")
## S3 method for class 'SpatialLines'
labels(object, labelCRS, side = 1:2, ...)
## S3 method for class 'SpatialPointsDataFrame'
text(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridlines_+3A_x">x</code></td>
<td>
<p>object deriving from class <a href="sp.html#topic+Spatial-class">Spatial-class</a></p>
</td></tr>
<tr><td><code id="gridlines_+3A_easts">easts</code></td>
<td>
<p>numeric; east-west values for vertical lines</p>
</td></tr>
<tr><td><code id="gridlines_+3A_norths">norths</code></td>
<td>
<p>numeric; north-south values for horizontal lines</p>
</td></tr>
<tr><td><code id="gridlines_+3A_ndiscr">ndiscr</code></td>
<td>
<p>integer; number of points used to discretize the line, could
be set to 2, unless the grid is (re)projected</p>
</td></tr>
<tr><td><code id="gridlines_+3A_offset">offset</code></td>
<td>
<p>offset value to be returned, see <a href="graphics.html#topic+text">text</a></p>
</td></tr>
<tr><td><code id="gridlines_+3A_object">object</code></td>
<td>
<p><a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a> object, as returned by <code>gridlines</code></p>
</td></tr>
<tr><td><code id="gridlines_+3A_labelcrs">labelCRS</code></td>
<td>
<p>the CRS in which the grid lines were drawn and labels should be 
printed; if missing, the CRS from <code>object</code> is taken</p>
</td></tr>
<tr><td><code id="gridlines_+3A_side">side</code></td>
<td>
<p>for <code>labels</code>: integer, indicating side(s) at which gridlines labels will be drawn:
1=below (S), 2=left (W), 3=above (N), and 4=right (E);
for <code>gridat</code>: default &ldquo;WS&rdquo;, if &ldquo;EN&rdquo; labels placed on the top and right borders</p>
</td></tr>
<tr><td><code id="gridlines_+3A_...">...</code></td>
<td>
<p> for <code>labels</code>: ignored; for <code>text</code>: arguments passed on 
to <a href="graphics.html#topic+text">text</a>, see below for example use of <code>adj</code></p>
</td></tr>
</table>


<h3>Value</h3>

 <p><code>gridlines</code> returns an object of class
<a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a>, with lines as specified; the return
object inherits the projection information of <code>x</code>; <code>gridat</code>
returns a SpatialPointsDataFrame with points at the west and south
ends of the grid lines created by <code>gridlines</code>, with degree
labels.
</p>
<p>The <code>labels</code> method for <code>SpatialLines</code> objects returns a
<a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a> object with the parameters needed
to print labels below and left of the gridlines. The locations for
the labels are those of <code>proj4string(object)</code> the labels also
unless <code>labelCRS</code> is given, in which case they are in that CRS.
This object is prepared to be plotted with <code>text</code>:
</p>
<p>The <code>text</code> method for <code>SpatialPointsDataFrame</code> puts text labels
on its coordinates, and takes care of attributes <code>pos</code>, <code>labels</code>,
<code>srt</code> and <code>offset</code>; see <a href="graphics.html#topic+text">text</a>.
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a>, using example code
of Roger Bivand.
</p>


<h3>See Also</h3>

 <p><a href="sp.html#topic+spTransform">spTransform</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
run &lt;- FALSE
if (requireNamespace("sf", quietly=TRUE)) run &lt;- TRUE

data(meuse)
coordinates(meuse) = ~x+y
plot(meuse)
plot(gridlines(meuse), add = TRUE)
text(labels(gridlines(meuse)))
title("default gridlines within Meuse bounding box")

if (run) {
proj4string(meuse) &lt;- CRS("+init=epsg:28992")
crs.longlat &lt;- CRS("+init=epsg:4326")
meuse_ll &lt;- spTransform(meuse, crs.longlat)
grd &lt;- gridlines(meuse_ll)
grd_x &lt;- spTransform(grd, CRS("+init=epsg:28992"))

# labels South and West:
plot(meuse)
plot(grd_x, add=TRUE, lty=2)
grdat_ll &lt;- gridat(meuse_ll)
grdat_x &lt;- spTransform(grdat_ll, CRS("+init=epsg:28992"))
text(grdat_x)
}
if (run) {
# labels North and East:
plot(meuse)
plot(grd_x, add=TRUE, lty=2)
grdat_ll &lt;- gridat(meuse_ll, side="EN")
grdat_x &lt;- spTransform(grdat_ll, CRS("+init=epsg:28992"))
text(grdat_x)
}
if (run) {
# now using labels:
plot(meuse)
plot(grd_x, add=TRUE, lty=2)
text(labels(grd_x, crs.longlat))
}
if (run) {
# demonstrate axis labels with angle, both sides:
sp = SpatialPoints(rbind(c(-101,9), c(-101,55), c(-19,9), c(-19,55)), crs.longlat)
laea = CRS("+proj=laea +lat_0=30 +lon_0=-40")
sp.l = spTransform(sp, laea)
plot(sp.l, expandBB = c(0, 0.05, 0, .05))
gl = spTransform(gridlines(sp), laea)
plot(gl, add = TRUE)
text(labels(gl, crs.longlat))
text(labels(gl, crs.longlat, side = 3:4), col = 'red')
title("curved text label demo")
}
if (run) {
# polar:
pts=SpatialPoints(rbind(c(-180,-70),c(0,-70),c(180,-89),c(180,-70)), crs.longlat)
polar = CRS("+init=epsg:3031")
gl = spTransform(gridlines(pts, easts = seq(-180,180,20), ndiscr = 100), polar)
plot(spTransform(pts, polar), expandBB = c(.05,0,.05,0))
lines(gl)
l = labels(gl, crs.longlat, side = 3)
l$pos = NULL # pos is too simple, use adj:
text(l, adj = c(0.5, -0.5)) 
l = labels(gl, crs.longlat, side = 4)
l$srt = 0 # otherwise they end up upside-down
text(l)
title("grid line labels on polar projection, epsg 3031")
}
## Not run: 
if (require(maps)) demo(polar) # adds the map of the antarctic

## End(Not run)

</code></pre>

<hr>
<h2 id='GridsDatums'>Grids and Datums PE&amp;RS listing</h2><span id='topic+GridsDatums'></span>

<h3>Description</h3>

<p>A data.frame of years and months of Grids &amp; Datums column publications by country and country code.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("GridsDatums")</code></pre>


<h3>Format</h3>

<p>A data frame with 241 observations on the following 4 variables.
</p>

<dl>
<dt><code>country</code></dt><dd><p>name of PE&amp;RS column</p>
</dd>
<dt><code>month</code></dt><dd><p>issue month</p>
</dd>
<dt><code>year</code></dt><dd><p>publication year</p>
</dd>
<dt><code>ISO</code></dt><dd><p>ISO code for country</p>
</dd>
</dl>



<h3>Details</h3>

<p>The journal <em>Photogrammetric Engineering &amp; Remote Sensing</em>, run by the American Society for Photogrammetry and Remote Sensing (ASPRS), began publishing a more-or-less monthly column on the spatial reference systems used in different countries, including their datums. The column first appeared in September 1997, and continued until March 2016; subsequent columns are updated reprints of previous ones. Some also cover other topics, such as world and Martian spatial reference systems. They are written by Clifford J. Mugnier, Louisiana State University, Fellow Emeritus ASPRS. To access the columns, visit <a href="https://www.asprs.org/asprs-publications/grids-and-datums">https://www.asprs.org/asprs-publications/grids-and-datums</a>.</p>


<h3>Source</h3>

<p><a href="https://www.asprs.org/asprs-publications/grids-and-datums">https://www.asprs.org/asprs-publications/grids-and-datums</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GridsDatums)
GridsDatums[grep("Norway", GridsDatums$country),]
GridsDatums[grep("Google", GridsDatums$country),]
GridsDatums[grep("^Mars$", GridsDatums$country),]
</code></pre>

<hr>
<h2 id='GridTopology-class'>Class &quot;GridTopology&quot; </h2><span id='topic+GridTopology-class'></span><span id='topic+print.summary.GridTopology'></span><span id='topic+summary+2CGridTopology-method'></span><span id='topic+show+2CGridTopology-method'></span><span id='topic+show+2Csummary.GridTopology-method'></span><span id='topic+coerce+2CGridTopology+2Cdata.frame-method'></span><span id='topic+coerce+2CSpatialGrid+2CGridTopology-method'></span><span id='topic+coerce+2CSpatialPixels+2CGridTopology-method'></span>

<h3>Description</h3>

<p> class for defining a rectangular grid of
arbitrary dimension </p>


<h3>Objects from the Class</h3>

<p>Objects are created by using e.g. 
</p>
<p>GridTopology(c(0,0), c(1,1), c(5,5))
</p>
<p>see <a href="sp.html#topic+SpatialGrid">SpatialGrid</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>cellcentre.offset</code>:</dt><dd><p>numeric; vector with the smallest centroid coordinates for
each dimension; coordinates refer to the cell centre </p>
</dd>
<dt><code>cellsize</code>:</dt><dd><p>numeric; vector with the cell size in each dimension</p>
</dd>
<dt><code>cells.dim</code>:</dt><dd><p>integer; vector with number of cells in each dimension</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coordinates</dt><dd><p><code>signature(x = "SpatialGrid")</code>: calculates coordinates for
each point on the grid</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SpatialGrid")</code>: summarize object</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "GridTopology", to = "data.frame")</code>: 
convert to data.frame with columns cellcentre.offset, cellsize and cells.dim</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a></code>, <code><a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = GridTopology(c(0,0), c(1,1), c(5,5))
class(x)
x
summary(x)
coordinates(x)
y = SpatialGrid(grid = x)
class(y)
y
</code></pre>

<hr>
<h2 id='image.SpatialGridDataFrame'> Image or contour method for gridded spatial data; convert to and from image data structure  </h2><span id='topic+image.SpatialGridDataFrame'></span><span id='topic+image.SpatialPixelsDataFrame'></span><span id='topic+image.SpatialPixels'></span><span id='topic+contour.SpatialGridDataFrame'></span><span id='topic+contour.SpatialPixelsDataFrame'></span><span id='topic+as.image.SpatialGridDataFrame'></span><span id='topic+image2Grid'></span><span id='topic+imageScale'></span>

<h3>Description</h3>

<p> Create image for gridded data in SpatialGridDataFrame or SpatialPixelsDataFrame
objects. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialGridDataFrame'
image(x, attr = 1, xcol = 1, ycol = 2, 
	col = heat.colors(12), red=NULL, green=NULL, blue=NULL,
        axes = FALSE, xlim = NULL,
	ylim = NULL, add = FALSE, ..., asp = NA, setParUsrBB=FALSE,
        interpolate = FALSE, angle = 0, 
	useRasterImage = !(.Platform$GUI[1] == "Rgui" &amp;&amp;
        getIdentification() == "R Console") &amp;&amp; missing(breaks), breaks,
	zlim = range(as.numeric(x[[attr]])[is.finite(x[[attr]])]))
## S3 method for class 'SpatialPixelsDataFrame'
image(x, ...) 
## S3 method for class 'SpatialPixels'
image(x, ...) 
## S3 method for class 'SpatialGridDataFrame'
contour(x, attr = 1, xcol = 1, ycol = 2,
	col = 1, add = FALSE, xlim = NULL, ylim = NULL, axes = FALSE,
         ..., setParUsrBB = FALSE)
## S3 method for class 'SpatialPixelsDataFrame'
contour(x, ...) 
as.image.SpatialGridDataFrame(x, xcol = 1, ycol = 2, attr = 1)
image2Grid(im, p4 = as.character(NA), digits=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.SpatialGridDataFrame_+3A_x">x</code></td>
<td>
<p> object of class <a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a> </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_attr">attr</code></td>
<td>
<p> column of attribute variable; this may be
the column name in the data.frame of <code>data</code> (as.data.frame(data)), or
a column number </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_xcol">xcol</code></td>
<td>
<p> column number of x-coordinate, in the coordinate matrix </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_ycol">ycol</code></td>
<td>
<p> column number of y-coordinate, in the coordinate matrix </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_col">col</code></td>
<td>
<p>a vector of colors </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_red">red</code>, <code id="image.SpatialGridDataFrame_+3A_green">green</code>, <code id="image.SpatialGridDataFrame_+3A_blue">blue</code></td>
<td>
<p>columns names or numbers given instead of the <code>attr</code> argument when the data represent an image encoded in three colour bands on the 0-255 integer scale; all three columns must be given in this case, and the attribute values will be constructed using function <code>rgb</code> </p>
</td></tr>

<tr><td><code id="image.SpatialGridDataFrame_+3A_axes">axes</code></td>
<td>
<p> logical; should coordinate axes be drawn? </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_xlim">xlim</code></td>
<td>
<p> x-axis limits </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_ylim">ylim</code></td>
<td>
<p> y-axis limits </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_zlim">zlim</code></td>
<td>
<p> data limits for plotting the (raster, attribute) values </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_add">add</code></td>
<td>
<p> logical; if FALSE, the image is added to the plot layout setup
by <code>plot(as(x, "Spatial"),axes=axes,xlim=xlim,ylim=ylim,asp=asp)</code>
which sets up axes and plotting region; if TRUE, the image is added
to the existing plot. </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_...">...</code></td>
<td>
<p> arguments passed to <a href="Matrix.html#topic+image">image</a>, see examples </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_asp">asp</code></td>
<td>
<p> aspect ratio to be used for plot </p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_setparusrbb">setParUsrBB</code></td>
<td>
<p>default FALSE, see <code><a href="sp.html#topic+Spatial-class">Spatial-class</a></code> for further details</p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_userasterimage">useRasterImage</code></td>
<td>
<p>if TRUE, use <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> to render the image if available; for legacy rendering set FALSE; should be FALSE on Windows SDI installations</p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_breaks">breaks</code></td>
<td>
<p>class breaks for coloured values</p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_interpolate">interpolate</code></td>
<td>
<p>default FALSE, a logical vector (or scalar) indicating whether to apply linear interpolation to the image when drawing, see <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code></p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_angle">angle</code></td>
<td>
<p>default 0, angle of rotation (in degrees, anti-clockwise from positive x-axis, about the bottom-left corner), see <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code></p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_im">im</code></td>
<td>
<p>list with components named x, y, and z, as used for <code>image</code></p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_p4">p4</code></td>
<td>
<p>CRS object, proj4 string</p>
</td></tr>
<tr><td><code id="image.SpatialGridDataFrame_+3A_digits">digits</code></td>
<td>
<p>default 10, number of significant digits to use for checking equal row/column spacing</p>
</td></tr>
</table>


<h3>Value</h3>

 <p><code>as.image.SpatialGridDataFrame</code> returns the list with
elements <code>x</code> and <code>y</code>, containing the coordinates of the cell
centres of a matrix <code>z</code>, containing the attribute values in matrix
form as needed by <a href="Matrix.html#topic+image">image</a>. </p>


<h3>Note</h3>

<p> Providing <code>xcol</code> and <code>ycol</code> attributes seems obsolete,
and it is for 2D data, but it may provide opportunities for plotting
certain slices in 3D data. I haven't given this much thought yet.
</p>
<p><a href="graphics.html#topic+filled.contour">filled.contour</a> seems to misinterpret the coordinate values,
if we take the image.default manual page as the reference. </p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>See Also</h3>

 <p><a href="graphics.html#topic+image.default">image.default</a>, <a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a>,
<a href="lattice.html#topic+levelplot">levelplot</a> in package <code>lattice</code>. Function
<code>image.plot</code> in package <code>fields</code> can be used to make a legend for an 
image, see an example in <a href="https://stat.ethz.ch/pipermail/r-sig-geo/2007-June/002143.html">https://stat.ethz.ch/pipermail/r-sig-geo/2007-June/002143.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid)
coordinates(meuse.grid) = c("x", "y") # promote to SpatialPointsDataFrame
gridded(meuse.grid) = TRUE            # promote to SpatialGridDataFrame
data(meuse)
coordinates(meuse) = c("x", "y")
image(meuse.grid["dist"], main = "Distance to river Meuse")
points(coordinates(meuse), pch = "+")
image(meuse.grid["dist"], main = "Distance to river Meuse",
 useRasterImage=TRUE)
points(coordinates(meuse), pch = "+")

# color scale:
layout(cbind(1,2), c(4,1),1)
image(meuse.grid["dist"])
imageScale(meuse.grid$dist, axis.pos=4, add.axis=FALSE)
axis(4,at=c(0,.2,.4,.8), las=2)

data(Rlogo)
d = dim(Rlogo)
cellsize = abs(c(gt[2],gt[6]))
cells.dim = c(d[1], d[2]) # c(d[2],d[1])
cellcentre.offset = c(x = gt[1] + 0.5 * cellsize[1], y = gt[4] - (d[2] - 0.5) * abs(cellsize[2]))
grid = GridTopology(cellcentre.offset, cellsize, cells.dim)
df = as.vector(Rlogo[,,1])
for (band in 2:d[3]) df = cbind(df, as.vector(Rlogo[,,band]))
df = as.data.frame(df)
names(df) = paste("band", 1:d[3], sep="")
Rlogo &lt;- SpatialGridDataFrame(grid = grid, data = df)
summary(Rlogo)
image(Rlogo, red="band1", green="band2", blue="band3")
image(Rlogo, red="band1", green="band2", blue="band3",
 useRasterImage=FALSE)
is.na(Rlogo$band1) &lt;- Rlogo$band1 == 255
is.na(Rlogo$band2) &lt;- Rlogo$band2 == 255
is.na(Rlogo$band3) &lt;- Rlogo$band3 == 255
Rlogo$i7 &lt;- 7
image(Rlogo, "i7")
image(Rlogo, red="band1", green="band2", blue="band3", add=TRUE)
</code></pre>

<hr>
<h2 id='is.projected'> Sets or retrieves projection attributes on classes extending
SpatialData </h2><span id='topic+is.projected'></span><span id='topic+proj4string'></span><span id='topic+proj4string+3C-'></span><span id='topic+is.projected+2CSpatial-method'></span><span id='topic+proj4string+2CSpatial-method'></span><span id='topic+wkt'></span><span id='topic+wkt+2CSpatial-method'></span><span id='topic+proj4string+3C-+2CSpatial+2CCRS-method'></span><span id='topic+proj4string+3C-+2CSpatial+2Ccharacter-method'></span><span id='topic+get_ll_warn'></span><span id='topic+get_ll_TOL'></span><span id='topic+set_ll_warn'></span><span id='topic+set_ll_TOL'></span><span id='topic+get_ReplCRS_warn'></span><span id='topic+set_ReplCRS_warn'></span>

<h3>Description</h3>

<p> Sets or retrieves projection attributes on classes extending
SpatialData; set or retrieve option value for error or warning on exceedance of geographical coordinate range, set or retrieve option value for exceedance tolerance of geographical coordinate range. Note that only &ldquo;+proj=longlat +ellps=WGS84&rdquo; is accepted for geographical coordinates, which must be ordered (eastings, northings); the &ldquo;+ellps=&rdquo; definition must be given (or expanded internally from a given &ldquo;+datum=&rdquo; value) for recent versions of the PROJ library, and should be set to an appropriate value.
</p>
<p>From release 6 of the PROJ library, when used in building <span class="pkg">rgdal</span> with GDAL &gt;= 3, the <code>+datum=</code> key in the Proj.4 string CRS representation is deprecated, and the <code>+towgs84=</code> and <code>+nadgrids=</code> keys may be deprecated soon. For this reason, <span class="pkg">sp</span>, <span class="pkg">rgdal</span> and <span class="pkg">sf</span> are starting to use WKT2 (2019) string representations. In <span class="pkg">sp</span>, the <code>"CRS"</code> object in itself remains unchanged, but the content of its <code>"projargs"</code> slot may be degraded. To work around the degradation, a <code>comment</code> is added around the <code>"CRS"</code> object containing a WKT2 (2019) string when <span class="pkg">rgdal</span> is available and built with PROJ &gt;= 6 and GDAL &gt;=3. The <code>wkt()</code> accessor function returns the WKT2 (2019) string comment belonging to the <code>"CRS"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.projected(obj)
proj4string(obj)
proj4string(obj) &lt;- value
wkt(obj)
get_ll_warn()
get_ll_TOL()
get_ReplCRS_warn()
set_ll_warn(value)
set_ll_TOL(value)
set_ReplCRS_warn(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.projected_+3A_obj">obj</code></td>
<td>
<p>An object of class or extending <a href="sp.html#topic+Spatial-class">Spatial-class</a></p>
</td></tr>
<tr><td><code id="is.projected_+3A_value">value</code></td>
<td>
<p>For <code>proj4string</code> CRS object, containing a valid proj4 string; attempts to assign an object containing &ldquo;longlat&rdquo; to data extending beyond longitude [-180, 360] or lattitude [-90, 90] will be stopped. For <code>set_ll_warn</code> a single logical value, if FALSE (default) error on range exceedance, if TRUE, warning. For <code>set_ll_TOL</code> the value of the power of <code>.Machine$double.eps</code> (default 0.25) to use as tolerance in testing range exceedance. <code>set_ReplCRS_warn</code> may be used to turn off warnings issued when changing object CRS with the <code>proj4string</code> replacement method (by setting <code>value=FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p> proj4 strings are operative through CRAN package rgdal. For strings defined as &ldquo;longlat&rdquo;, the minimum longitude should be -180, the maximum longitude 360, the minimum latitude -90, and the maximum latitude 90. Note that the <code>proj4string</code> replacement method does not project spatial data - for this use <code>spTransform</code> methods in the rgdal package.</p>


<h3>Value</h3>

 <p><code>is.projected</code> returns a logical that may be <code>NA</code>; 
<code>proj4string</code> returns a character vector of length 1.</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a>
</p>


<h3>See Also</h3>

 <p><a href="sp.html#topic+CRS">CRS</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>o &lt;- new("Spatial")
proj4string(o) &lt;- CRS("+init=epsg:27700")
if (!is.null(comment(slot(o, "proj4string")))) {
  cat(strsplit(wkt(o), "\n")[[1]], sep="\n")
  cat(strsplit(wkt(slot(o, "proj4string")), "\n")[[1]], sep="\n")
}
is.projected(CRS("+proj=longlat"))
is.projected(CRS("+proj=geocent"))
is.projected(CRS("+proj=geocent +units=km"))

</code></pre>

<hr>
<h2 id='Line'> create objects of class Line or Lines</h2><span id='topic+Line'></span><span id='topic+Lines'></span>

<h3>Description</h3>

<p> create objects of class <code>Line</code> or <code>Lines</code> from coordinates</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
Line(coords)
Lines(slinelist, ID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Line_+3A_coords">coords</code></td>
<td>
<p> 2-column numeric matrix with coordinates for a single line </p>
</td></tr>
<tr><td><code id="Line_+3A_slinelist">slinelist</code></td>
<td>
<p> list with elements of class <a href="sp.html#topic+Line-class">Line-class</a></p>
</td></tr>
<tr><td><code id="Line_+3A_id">ID</code></td>
<td>
<p>a single word unique character identifier, 
character vector of length one</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Line</code> returns an object of class <a href="sp.html#topic+Line-class">Line-class</a>;
<code>Lines</code> returns an object of class <a href="sp.html#topic+Lines-class">Lines-class</a>
</p>


<h3>See Also</h3>

 <p><a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# from the sp vignette:
l1 = cbind(c(1,2,3),c(3,2,2))
l1a = cbind(l1[,1]+.05,l1[,2]+.05)
l2 = cbind(c(1,2,3),c(1,1.5,1))
Sl1 = Line(l1)
Sl1a = Line(l1a)
Sl2 = Line(l2)
S1 = Lines(list(Sl1, Sl1a), ID="a")
S2 = Lines(list(Sl2), ID="b")
</code></pre>

<hr>
<h2 id='Line-class'>Class &quot;Line&quot; </h2><span id='topic+Line-class'></span>

<h3>Description</h3>

<p> class for line objects </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Line", ...)</code>,
or (preferred) by calls to the function <a href="sp.html#topic+Line">Line</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>coords</code>:</dt><dd><p>Object of class <code>"matrix"</code>, containing the
line coordinates </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coordinates</dt><dd><p><code>signature(obj = "Line")</code>: retrieve coordinates
from line </p>
</dd>
<dt>lines</dt><dd><p><code>signature(x = "Line")</code>: add lines to a plot </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Roger Bivand, Edzer Pebesma </p>


<h3>See Also</h3>

<p><a href="sp.html#topic+Lines-class">Lines-class</a>, <a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a>
</p>

<hr>
<h2 id='Lines-class'>Class &quot;Lines&quot; </h2><span id='topic+Lines-class'></span>

<h3>Description</h3>

<p> class for sets of line objects </p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lines-class_+3A_sl">SL</code>, <code id="Lines-class_+3A_lines">Lines</code></td>
<td>
<p>an Lines object</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <a href="sp.html#topic+Line">Line</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>Lines</code>:</dt><dd><p>Object of class <code>"list"</code>, containing elements
of class <a href="sp.html#topic+Line-class">Line-class</a></p>
</dd>
<dt><code>ID</code>:</dt><dd><p><code>"character"</code> vector of length one, with unique identifier string</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coordinates</dt><dd><p><code>signature(obj = "Line")</code>: retrieve coordinates
from lines; returns list with matrices </p>
</dd>
<dt>lines</dt><dd><p><code>signature(x = "Line")</code>: add lines to a plot</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Roger Bivand, Edzer Pebesma </p>


<h3>See Also</h3>

<p><a href="sp.html#topic+Lines-class">Lines-class</a>, <a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a>
</p>

<hr>
<h2 id='loadMeuse'> deprecated function to load the Meuse data set </h2><span id='topic+loadMeuse'></span>

<h3>Description</h3>

<p> deprecated function to load the Meuse data set </p>


<h3>Usage</h3>

<pre><code class='language-R'>loadMeuse()
</code></pre>


<h3>Value</h3>

<p> none; it prints a warning to run demo(meuse) </p>


<h3>See Also</h3>

<p><a href="sp.html#topic+meuse">meuse</a>, <a href="sp.html#topic+meuse.grid">meuse.grid</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo(meuse)
</code></pre>

<hr>
<h2 id='mapasp'> Calculate aspect ratio for plotting geographic maps;
create nice degree axis labels </h2><span id='topic+mapasp'></span><span id='topic+degreeLabelsEW'></span><span id='topic+degreeLabelsNS'></span>

<h3>Description</h3>

<p> Calculate aspect ratio for plotting geographic maps;
create nice degree axis labels </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
mapasp(data, xlim, ylim)
degreeLabelsEW(x)
degreeLabelsNS(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapasp_+3A_data">data</code></td>
<td>
<p> object of class or extending <code>Spatial</code></p>
</td></tr>
<tr><td><code id="mapasp_+3A_xlim">xlim</code></td>
<td>
<p> the xlim argument passed (or derived from bounding box) </p>
</td></tr>
<tr><td><code id="mapasp_+3A_ylim">ylim</code></td>
<td>
<p> the ylim argument passed (or derived from bounding box) </p>
</td></tr>
<tr><td><code id="mapasp_+3A_x">x</code></td>
<td>
<p> numeric; values at which tics and marks will be generated </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mapasp</code> is used for the aspect argument in lattice plots and spplot; 
</p>
<p>let x = dy/dx, with dy and dx the y- and x-size of the map.
</p>
<p>let s = 1/cos((My * pi)/180) with My the y coordinate of the middle of the map
(the mean of ylim)
</p>
<p>for latlong (longlat) data, <code>mapasp</code> returns s * x.
for other data, mapasp returns &quot;iso&quot;.
</p>


<h3>Note</h3>

<p>the values for <code>x</code> are typically obtained from <a href="graphics.html#topic+axTicks">axTicks</a></p>


<h3>See Also</h3>

 <p><a href="lattice.html#topic+levelplot">levelplot</a> in package <code>lattice</code></p>

<hr>
<h2 id='merge'> 
Merge a Spatial* object having attributes with a data.frame
</h2><span id='topic+merge'></span><span id='topic+merge+2CSpatial+2Cdata.frame-method'></span><span id='topic+merge+2CSpatial+2CANY-method'></span>

<h3>Description</h3>

<p>Merge a Spatial object having a data.frame (i.e. merging of non-spatial attributes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Spatial,data.frame'
merge(x, y, by = intersect(names(x), names(y)),
 by.x = by, by.y = by, all.x = TRUE, suffixes = c(".x",".y"),
 incomparables = NULL, duplicateGeoms = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_+3A_x">x</code></td>
<td>
<p>object deriving from <a href="sp.html#topic+Spatial">Spatial</a></p>
</td></tr>
<tr><td><code id="merge_+3A_y">y</code></td>
<td>
<p>object of class <code>data.frame</code>, or any other class that can be coerced to a data.frame with <code>as.data.frame</code></p>
</td></tr>
<tr><td><code id="merge_+3A_by">by</code>, <code id="merge_+3A_by.x">by.x</code>, <code id="merge_+3A_by.y">by.y</code></td>
<td>
<p>specifications of the common columns. See 'Details' in (base) <code><a href="base.html#topic+merge">merge</a></code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_all.x">all.x</code></td>
<td>
<p>logical; if TRUE, then the returned object will have all rows of x, even those that has no matching row in y. These rows will have NAs in those columns that are usually filled with values from y</p>
</td></tr>
<tr><td><code id="merge_+3A_suffixes">suffixes</code></td>
<td>
<p>character(2) specifying the suffixes to be used for making non-by names() unique.</p>
</td></tr>
<tr><td><code id="merge_+3A_incomparables">incomparables</code></td>
<td>
<p>values which cannot be matched. See <code><a href="base.html#topic+match">match</a></code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_duplicategeoms">duplicateGeoms</code></td>
<td>
<p>logical; if <code>TRUE</code> geometries in <code>x</code> are
duplicated if there are multiple matches between records in <code>x</code>
and <code>y</code></p>
</td></tr>
<tr><td><code id="merge_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> a Spatial* object </p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+merge">merge</a></code> </p>

<hr>
<h2 id='meuse'>Meuse river data set</h2><span id='topic+meuse'></span>

<h3>Description</h3>

<p>This data set gives locations and topsoil heavy metal concentrations, along with a number of soil and landscape variables at the observation locations, collected in a flood plain of the river Meuse, near the village of Stein (NL). Heavy metal concentrations are from composite samples of an area of approximately 15 m x 15 m.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meuse)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>x</dt><dd><p>a numeric vector; Easting (m) in Rijksdriehoek (RDH)
(Netherlands topographical) map coordinates </p>
</dd>
<dt>y</dt><dd><p>a numeric vector; Northing (m) in RDH  coordinates </p>
</dd>
<dt>cadmium</dt><dd><p>topsoil cadmium concentration, mg kg-1 soil (&quot;ppm&quot;); zero cadmium
values in the original data set have been shifted to 0.2 (half the lowest 
non-zero value) </p>
</dd>
<dt>copper</dt><dd><p>topsoil copper concentration, mg kg-1 soil  (&quot;ppm&quot;) </p>
</dd>
<dt>lead</dt><dd><p>topsoil lead concentration, mg kg-1 soil  (&quot;ppm&quot;) </p>
</dd>
<dt>zinc</dt><dd><p>topsoil zinc concentration, mg kg-1 soil  (&quot;ppm&quot;) </p>
</dd> 
<dt>elev</dt><dd><p>relative elevation above local river bed, m </p>
</dd>
<dt>dist</dt><dd><p>distance to the Meuse; obtained from the nearest cell in
<a href="sp.html#topic+meuse.grid">meuse.grid</a>, which in turn was derived by a spread (spatial distance)
GIS operation, horizontal precision 20 metres; then
normalized to $[0,1]$ </p>
</dd>
<dt>om</dt><dd><p>organic matter, kg (100 kg)-1 soil (percent)</p>
</dd>
<dt>ffreq</dt><dd><p>flooding frequency class: 1 = once in two years; 2 = once in ten years; 3 = one in 50 years</p>
</dd>
<dt>soil</dt><dd><p>soil type according to the 1:50 000 soil map of the Netherlands. 1 = Rd10A (Calcareous weakly-developed meadow soils, light sandy clay); 2 = Rd90C/VII (Non-calcareous weakly-developed meadow soils, heavy sandy clay to light clay); 3 = Bkd26/VII (Red Brick soil, fine-sandy, silty light clay)</p>
</dd>
<dt>lime</dt><dd><p>lime class: 0 = absent, 1 = present by field test with 5% HCl</p>
</dd>
<dt>landuse</dt><dd><p>landuse class: Aa  Agriculture/unspecified = , Ab = Agr/sugar beetsm, Ag = Agr/small grains, Ah = Agr/??, Am = Agr/maize, B = woods, Bw  = trees in pasture, DEN = ??, Fh = tall fruit trees, Fl = low fruit trees; Fw = fruit trees in pasture, Ga = home gardens, SPO = sport field, STA = stable yard, Tv = ??
, W = pasture</p>
</dd>
<dt>dist.m</dt><dd><p>distance to river Meuse in metres, as obtained during the field survey</p>
</dd>
</dl>



<h3>Note</h3>

<p>row.names refer to the original sample number.
</p>
<p>Soil units were mapped with a minimum delination width of 150 m, and so somewhat generalize the landscape.
</p>
<p>Approximate equivalent World Reference Base 2002 for Soil Resources names are: Rd10A Gleyic Fluvisols; Rd90C Haplic Fluvisols; Bkd26 Haplic Luvisols. Units Rd90C and Bkd26 have winter groundwater &gt; 80cm, summer &gt; 120cm depth.
</p>


<h3>Author(s)</h3>

<p>Field data were collected by Ruud van Rijn and
Mathieu Rikken; compiled for R by Edzer Pebesma; description 
extended by David Rossiter </p>


<h3>References</h3>

<p>M G J Rikken and R P G Van Rijn, 1993. Soil pollution with heavy metals - an inquiry into spatial variation, cost of mapping and the risk evaluation of copper, cadmium, lead and zinc in the floodplains of the Meuse west of Stein, the Netherlands. Doctoraalveldwerkverslag, Dept. of Physical Geography, Utrecht University
</p>
<p>P.A. Burrough, R.A. McDonnell, 1998. Principles of Geographical Information Systems. Oxford University Press.
</p>
<p>Stichting voor Bodemkartering (STIBOKA), 1970. Bodemkaart van Nederland : Blad 59 Peer, Blad 60 West en 60 Oost Sittard: schaal 1 : 50 000. Wageningen, STIBOKA.
</p>
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
summary(meuse)
coordinates(meuse) &lt;- ~x+y
proj4string(meuse) &lt;- CRS("+init=epsg:28992")
</code></pre>

<hr>
<h2 id='meuse.grid'> Prediction Grid for Meuse Data Set </h2><span id='topic+meuse.grid'></span>

<h3>Description</h3>

<p>The <code>meuse.grid</code> data frame has 3103 rows and 7 columns;
a grid with 40 m x 40 m spacing that covers the Meuse study area (see <a href="sp.html#topic+meuse">meuse</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meuse.grid)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>x</dt><dd><p>a numeric vector; x-coordinate (see <a href="sp.html#topic+meuse">meuse</a>) </p>
</dd>
<dt>y</dt><dd><p>a numeric vector; y-coordinate (see <a href="sp.html#topic+meuse">meuse</a>) </p>
</dd>
<dt>dist</dt><dd><p>distance to the Meuse river; obtained by a spread
(spatial distance) GIS operation, from border of river; normalized to
$[0,1]$ </p>
</dd>
<dt>ffreq</dt><dd><p>flooding frequency class, for definitions see this item in <a href="sp.html#topic+meuse">meuse</a>; it is not known how this map was generated</p>
</dd>
<dt>part.a</dt><dd><p>arbitrary division of the area in two areas, a and b</p>
</dd>
<dt>part.b</dt><dd><p>see <code>part.a</code></p>
</dd>
<dt>soil</dt><dd><p>soil type, for definitions see this item in <a href="sp.html#topic+meuse">meuse</a>; it is questionable whether these data come from a real soil map, they do not match the published 1:50 000 map</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>x</code> and <code>y</code> are in RD New, the Dutch topographical map
coordinate system. Roger Bivand projected this to UTM in the
R-Grass interface package.
</p>


<h3>Source</h3>

<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>


<h3>References</h3>

<p>See the <a href="sp.html#topic+meuse">meuse</a> documentation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid)
coordinates(meuse.grid) = ~x+y
proj4string(meuse.grid) &lt;- CRS("+init=epsg:28992")
gridded(meuse.grid) = TRUE
spplot(meuse.grid)
</code></pre>

<hr>
<h2 id='meuse.grid_ll'>Prediction Grid for Meuse Data Set, geographical coordinates</h2><span id='topic+meuse.grid_ll'></span>

<h3>Description</h3>

<p>The object contains the meuse.grid data as a SpatialPointsDataFrame 
after transformation to WGS84 and geographical coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meuse.grid_ll)</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'SpatialPointsDataFrame' [package &quot;sp&quot;]. 
</p>


<h3>Source</h3>

<p>See the <a href="sp.html#topic+meuse">meuse</a> documentation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid_ll)
</code></pre>

<hr>
<h2 id='meuse.riv'> River Meuse outline </h2><span id='topic+meuse.riv'></span><span id='topic+meuse.area'></span>

<h3>Description</h3>

<p>The <code>meuse.riv</code> data consists of an outline of the Meuse
river in the area a few kilometers around the <a href="sp.html#topic+meuse">meuse</a>
data set. 
</p>
<p>The <code>meuse.area</code> polygon has an outline of <a href="sp.html#topic+meuse.grid">meuse.grid</a>. See
example below how it can be created from <a href="sp.html#topic+meuse.grid">meuse.grid</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meuse.riv)
data(meuse.area)</code></pre>


<h3>Format</h3>

<p><code>meuse.riv</code>: two-column data.frame containing 176 coordinates.
</p>
<p><code>meuse.area</code>: two-column matrix with coordinates of outline.
</p>


<h3>Details</h3>

<p><code>x</code> and <code>y</code> are in RDM, the Dutch topographical map
coordinate system. See examples of <code>spTransform</code> for projection parameters.
</p>


<h3>References</h3>

<p>See the <a href="sp.html#topic+meuse">meuse</a> documentation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.riv)
plot(meuse.riv, type = "l", asp = 1)
data(meuse.grid)
coordinates(meuse.grid) = c("x", "y")
gridded(meuse.grid) = TRUE
image(meuse.grid, "dist", add = TRUE)
data(meuse)
coordinates(meuse) = c("x", "y")
meuse.sr = SpatialPolygons(list(Polygons(list(Polygon(meuse.riv)),"meuse.riv")))
spplot(meuse.grid, col.regions=bpy.colors(), main = "meuse.grid",
  sp.layout=list(
	list("sp.polygons", meuse.sr),
	list("sp.points", meuse, pch="+", col="black")
  )
)
spplot(meuse, "zinc", col.regions=bpy.colors(),  main = "zinc, ppm",
  cuts = c(100,200,400,700,1200,2000), key.space = "right",
  sp.layout= list("sp.polygons", meuse.sr, fill = "lightblue")
)


</code></pre>

<hr>
<h2 id='over-methods'> consistent spatial overlay for points, grids and polygons </h2><span id='topic+over'></span><span id='topic++25over+25'></span><span id='topic+over-methods'></span><span id='topic+over+2CSpatialPoints+2CSpatialPoints-method'></span><span id='topic+over+2CSpatialPoints+2CSpatialPointsDataFrame-method'></span><span id='topic+over+2CSpatialPoints+2CSpatialPolygons-method'></span><span id='topic+over+2CSpatialPoints+2CSpatialPolygonsDataFrame-method'></span><span id='topic+over+2CSpatialGridDataFrame+2CSpatialPolygonsDataFrame-method'></span><span id='topic+over+2CSpatialPolygons+2CSpatialPoints-method'></span><span id='topic+over+2CSpatialPolygons+2CSpatialPointsDataFrame-method'></span><span id='topic+over+2CSpatialGridDataFrame+2CSpatialPoints-method'></span><span id='topic+over+2CSpatialGrid+2CSpatialPoints-method'></span><span id='topic+over+2CSpatialPixelsDataFrame+2CSpatialPoints-method'></span><span id='topic+over+2CSpatialPixels+2CSpatialPoints-method'></span><span id='topic+over+2CSpatialPoints+2CSpatialGrid-method'></span><span id='topic+over+2CSpatialPoints+2CSpatialGridDataFrame-method'></span><span id='topic+over+2CSpatialPoints+2CSpatialPixels-method'></span><span id='topic+over+2CSpatialPoints+2CSpatialPixelsDataFrame-method'></span><span id='topic+over+2CSpatialPolygons+2CSpatialGridDataFrame-method'></span><span id='topic+over+2CSpatialGrid+2CSpatialPolygons-method'></span><span id='topic+over+2CSpatialGrid+2CSpatialPolygonsDataFrame-method'></span><span id='topic+over+2CSpatialPolygons+2CSpatialGrid-method'></span><span id='topic+over+2CSpatialGrid+2CSpatialGrid-method'></span><span id='topic+over+2CSpatialGrid+2CSpatialGridDataFrame-method'></span><span id='topic+over+2CSpatialGrid+2CSpatialPixels-method'></span><span id='topic+over+2CSpatialGrid+2CSpatialPixelsDataFrame-method'></span><span id='topic+over+2CSpatialGrid+2CSpatialPointsDataFrame-method'></span><span id='topic+over+2CSpatial+2CSpatial-method'></span><span id='topic+overDF_for_rgeos'></span>

<h3>Description</h3>

<p> consistent spatial overlay for points, grids and
polygons: at the spatial locations of object x retrieves the indexes
or attributes from spatial object y </p>


<h3>Usage</h3>

<pre><code class='language-R'>over(x, y, returnList = FALSE, fn = NULL, ...)
x %over% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="over-methods_+3A_x">x</code></td>
<td>
<p>geometry (locations) of the queries</p>
</td></tr>
<tr><td><code id="over-methods_+3A_y">y</code></td>
<td>
<p>layer from which the geometries or attributes are queried</p>
</td></tr>
<tr><td><code id="over-methods_+3A_returnlist">returnList</code></td>
<td>
<p> logical; see value </p>
</td></tr>
<tr><td><code id="over-methods_+3A_fn">fn</code></td>
<td>
<p>(optional) a function; see value </p>
</td></tr>
<tr><td><code id="over-methods_+3A_...">...</code></td>
<td>
<p>arguments passed on to function <code>fn</code>, except for the special
argument <code>minDimension</code>: minimal dimension for an intersection to be counted;
-1 takes any intersection, and does not order; 0 takes any intersection
but will order according to dimensionality of the intersections (if returnList
is TRUE, 1 (2) selects intersections with dimension 1, meaning
lines (2, meaning areas); see <code>vignette("over")</code> for details </p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>If <code>y</code> is only geometry an object of length <code>length(x)</code>.
If <code>returnList</code> is <code>FALSE</code>, a vector with the (first) index
of <code>y</code> for each geometry (point, grid cell centre, polygon
or lines) matching <code>x</code>.  if <code>returnList</code> is TRUE, a list of
length <code>length(x)</code>, with list element <code>i</code> the vector of
all indices of the geometries in <code>y</code> that correspond to the
$i$-th geometry in <code>x</code>.
</p>
<p>If <code>y</code> has attribute data, attribute data are
returned. <code>returnList</code> is FALSE, a <code>data.frame</code> with
number of rows equal to <code>length(x)</code> is returned, if it is
TRUE a list with <code>length(x)</code> elements is returned, with a list
element the <code>data.frame</code> elements of all geometries in <code>y</code>
that correspond to that element of <code>x</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;SpatialPoints&quot;, y = &quot;SpatialPolygons&quot;</dt><dd><p> returns a numeric
vector of length equal to the number of points; the number is the
index (number) of the polygon of <code>y</code> in which a point falls;
NA denotes the point does not fall in a polygon; if a point falls
in multiple polygons, the last polygon is recorded.  </p>
</dd>
<dt>x = &quot;SpatialPointsDataFrame&quot;, y = &quot;SpatialPolygons&quot;</dt><dd><p> equal
to the previous method, except that an argument <code>fn=xxx</code> is
allowed, e.g. <code>fn = mean</code> which will then report a data.frame
with the mean attribute values of the <code>x</code> points falling 
in each polygon (set) of <code>y</code> </p>
</dd>
<dt>x = &quot;SpatialPoints&quot;, y = &quot;SpatialPolygonsDataFrame&quot;</dt><dd><p> returns
a data.frame of the second argument with row entries corresponding
to the first argument </p>
</dd>
<dt>x = &quot;SpatialPolygons&quot;, y = &quot;SpatialPoints&quot;</dt><dd><p> returns
the polygon index of points in <code>y</code>; if <code>x</code> is
a <code>SpatialPolygonsDataFrame</code>, a data.frame with rows from
<code>x</code> corresponding to points in <code>y</code> is returned.</p>
</dd>
<dt>x = &quot;SpatialGridDataFrame&quot;, y = &quot;SpatialPoints&quot;</dt><dd><p> returns
object of class SpatialPointsDataFrame with grid attribute values
x at spatial point locations y; NA for NA grid cells or points
outside grid, and NA values on NA grid cells. </p>
</dd>
<dt>x = &quot;SpatialGrid&quot;, y = &quot;SpatialPoints&quot;</dt><dd><p> returns grid values
x at spatial point locations y; NA for NA grid cells or points
outside the grid </p>
</dd>
<dt>x = &quot;SpatialPixelsDataFrame&quot;, y = &quot;SpatialPoints&quot;</dt><dd><p> returns
grid values x at spatial point locations y; NA for NA grid cells
or points outside the grid </p>
</dd>
<dt>x = &quot;SpatialPixels&quot;, y = &quot;SpatialPoints&quot;</dt><dd><p> returns grid
values x at spatial point locations y; NA for NA grid cells or
points outside the grid </p>
</dd>
<dt>x = &quot;SpatialPoints&quot;, y = &quot;SpatialGrid&quot;</dt><dd><p> xx </p>
</dd>
<dt>x = &quot;SpatialPoints&quot;, y = &quot;SpatialGridDataFrame&quot;</dt><dd><p> xx </p>
</dd>
<dt>x = &quot;SpatialPoints&quot;, y = &quot;SpatialPixels&quot;</dt><dd><p> xx </p>
</dd>
<dt>x = &quot;SpatialPoints&quot;, y = &quot;SpatialPixelsDataFrame&quot;</dt><dd><p> xx </p>
</dd>
<dt>x = &quot;SpatialPolygons&quot;, y = &quot;SpatialGridDataFrame&quot;</dt><dd><p> xx </p>
</dd>
</dl>



<h3>Note</h3>

<p><code>over</code> can be seen as a left outer join in SQL; the
match is a spatial intersection.
</p>
<p>points on a polygon boundary and points corresponding to a
polygon vertex are considered to be inside the polygon.
</p>
<p>These methods assume that pixels and grid cells are never
overlapping; for objects of class <code>SpatialPixels</code> this is
not guaranteed.
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a></p>


<h3>See Also</h3>

<p><code>vignette("over")</code> for examples and figures</p>

<hr>
<h2 id='panel.spplot'>panel and panel utility functions for spplot</h2><span id='topic+panel.spplot'></span><span id='topic+panel.gridplot'></span><span id='topic+panel.pointsplot'></span><span id='topic+panel.polygonsplot'></span><span id='topic+spplot.key'></span><span id='topic+SpatialPolygonsRescale'></span><span id='topic+sp.lines'></span><span id='topic+sp.points'></span><span id='topic+sp.polygons'></span><span id='topic+sp.text'></span><span id='topic+sp.grid'></span><span id='topic+sp.panel.layout'></span><span id='topic+longlat.scales'></span><span id='topic+bbexpand'></span>

<h3>Description</h3>

<p>panel functions for spplot functions, and functions that can be
useful within these panel functions </p>


<h3>Usage</h3>

<pre><code class='language-R'>spplot.key(sp.layout, rows = 1, cols = 1)
SpatialPolygonsRescale(obj, offset, scale = 1, fill = "black", col = "black",
	plot.grid = TRUE, ...)
sp.lines(obj, col = 1, ...)
sp.points(obj, pch = 3, ...)
sp.polygons(obj, col = 1, fill = "transparent", ...)
sp.grid(obj, col = 1, alpha = 1,..., at = pretty(obj[[1]]), col.regions = col)
sp.text(loc, txt, ...)
sp.panel.layout(lst, p.number, ...)
bbexpand(x, fraction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.spplot_+3A_sp.layout">sp.layout</code></td>
<td>
<p> list; see <a href="raster.html#topic+spplot">spplot</a> for definition </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_rows">rows</code></td>
<td>
<p> integer; panel row(s) for which the layout should be drawn </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_cols">cols</code></td>
<td>
<p> integer; panel column(s) for which the layout should be drawn </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_obj">obj</code></td>
<td>
<p> object of class <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a> for
<code>SpatialPolygonsRescale</code>; of class <a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a>,
<a href="sp.html#topic+Lines-class">Lines-class</a> or <a href="sp.html#topic+Line-class">Line-class</a> for <code>sp.lines</code> of a
class that has a <a href="sp.html#topic+coordinates-methods">coordinates-methods</a> for <code>sp.points</code>; of
class <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a> for <code>sp.polygons</code>.  When obj is
character, the actual object is retrieved by <code>get(obj)</code> before its
class is evaluated.  </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_offset">offset</code></td>
<td>
<p> offset for shifting a Polygons object </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_scale">scale</code></td>
<td>
<p> scale for rescaling </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_fill">fill</code></td>
<td>
<p> fill color </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_col">col</code></td>
<td>
<p> line color </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_plot.grid">plot.grid</code></td>
<td>
<p>logical; plot through grid functions (TRUE), or through
traditional graphics functions (FALSE)</p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_pch">pch</code></td>
<td>
<p> plotting character </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_at">at</code></td>
<td>
<p> numeric; values at which colour breaks should occur </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_col.regions">col.regions</code></td>
<td>
<p> colours to fill the grid cells, defaults to col </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_loc">loc</code></td>
<td>
<p> numeric vector of two elements </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_txt">txt</code></td>
<td>
<p> text to be plotted </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_alpha">alpha</code></td>
<td>
<p> alpha (transparency) level </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_lst">lst</code></td>
<td>
<p> sp.layout argument, see <a href="raster.html#topic+spplot">spplot</a></p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_p.number">p.number</code></td>
<td>
<p> panel number; in a panel, panel.number() should be
passed to this argument </p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_x">x</code></td>
<td>
<p>length two numeric vector, containing a range</p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_fraction">fraction</code></td>
<td>
<p>fraction to expand the range by</p>
</td></tr>
<tr><td><code id="panel.spplot_+3A_...">...</code></td>
<td>
<p> arguments passed to the underlying panel, lattice or 
grid functions </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The panel functions of <a href="raster.html#topic+spplot">spplot</a>, <code>panel.gridplot</code> for grids,
<code>panel.pointsplot</code> for points, or <code>panel.polygonsplot</code> for lines
or polygons can be called with arguments <code>(x,y,...)</code>.
Customizing spplot plots can be done by extending the panel function,
or by supplying an sp.layout argument; see the documentation for
<a href="raster.html#topic+spplot">spplot</a>. Inside these panel functions, <code>sp.panel.layout</code>
is called to deal with plotting the items in a <code>sp.layout</code> object.
</p>
<p><code>SpatialPolygonsRescale</code> scales and shifts an object of class
<a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>; this is useful e.g. for scale bars, or other
layout items.
</p>
<p><code>sp.lines</code>, <code>sp.points</code>, <code>sp.polygons</code> and <code>sp.text</code>
plot lines, points, polygons or text in a panel.
</p>
<p><code>spplot.key</code> draws the <code>sp.layout</code> object at given rows/cols.
</p>
<p><code>sp.pagefn</code> can be passed as a <code>page</code> argument, and will
call function <code>spplot.key</code> for the last panel drawn on a page.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>References</h3>

<p><a href="https://edzer.github.io/sp/">https://edzer.github.io/sp/</a> has a graph gallery with
examples with R code.
</p>


<h3>See Also</h3>

<p><a href="raster.html#topic+spplot">spplot</a>, <a href="sp.html#topic+spplot-methods">spplot-methods</a></p>

<hr>
<h2 id='point.in.polygon'> do point(s) fall in a given polygon? </h2><span id='topic+point.in.polygon'></span>

<h3>Description</h3>

<p>verifies for one or more points whether they fall in a given polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point.in.polygon(point.x, point.y, pol.x, pol.y, mode.checked=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point.in.polygon_+3A_point.x">point.x</code></td>
<td>
<p>numerical array of x-coordinates of points</p>
</td></tr>
<tr><td><code id="point.in.polygon_+3A_point.y">point.y</code></td>
<td>
<p>numerical array of y-coordinates of points</p>
</td></tr>
<tr><td><code id="point.in.polygon_+3A_pol.x">pol.x</code></td>
<td>
<p>numerical array of x-coordinates of polygon</p>
</td></tr>
<tr><td><code id="point.in.polygon_+3A_pol.y">pol.y</code></td>
<td>
<p>numerical array of y-coordinates of polygon</p>
</td></tr>
<tr><td><code id="point.in.polygon_+3A_mode.checked">mode.checked</code></td>
<td>
<p>default FALSE, used internally to save time when all the other argument are known to be of storage mode double</p>
</td></tr>
</table>


<h3>Value</h3>

<p> integer array; values are:
0: point is strictly exterior to pol;
1: point is strictly interior to pol;
2: point lies on the relative interior of an edge of pol;
3: point is a vertex of pol.
</p>


<h3>References</h3>

 
<p>Uses the C function InPoly().  InPoly is Copyright (c) 1998 by
Joseph O'Rourke.  It may be freely redistributed in its entirety
provided that this copyright notice is not removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># open polygon:
point.in.polygon(1:10,1:10,c(3,5,5,3),c(3,3,5,5))
# closed polygon:
point.in.polygon(1:10,rep(4,10),c(3,5,5,3,3),c(3,3,5,5,3))
</code></pre>

<hr>
<h2 id='Polygon-class'>Class &quot;Polygon&quot; </h2><span id='topic+Polygon-class'></span>

<h3>Description</h3>

<p> class for spatial polygon </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <code>Polygon</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>ringDir</code>:</dt><dd><p>Object of class <code>"integer"</code>; the ring direction of the ring (polygon) coordinates, holes are expected to be anti-clockwise </p>
</dd>
<dt><code>labpt</code>:</dt><dd><p>Object of class <code>"numeric"</code>; an x, y coordinate pair forming the label point of the polygon </p>
</dd>
<dt><code>area</code>:</dt><dd><p>Object of class <code>"numeric"</code>; the planar area of the polygon, does not respect projection as objects of this class have no projection defined </p>
</dd>
<dt><code>hole</code>:</dt><dd><p>Object of class <code>"logical"</code>; does the polygon seem to be a hole </p>
</dd>
<dt><code>coords</code>:</dt><dd><p>Object of class <code>"matrix"</code>; coordinates of the polygon;
first point should equal the last point </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Line"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;Polygon&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>


<h3>See Also</h3>

<p><a href="sp.html#topic+Polygons-class">Polygons-class</a>, <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></p>

<hr>
<h2 id='polygons'> sets spatial coordinates to create spatial data, or retrieves
spatial coordinates </h2><span id='topic+polygons+3C-'></span><span id='topic+polygons'></span>

<h3>Description</h3>

<p> sets spatial coordinates to create spatial data, or retrieves
spatial coordinates </p>


<h3>Usage</h3>

<pre><code class='language-R'>	polygons(obj)
	polygons(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygons_+3A_obj">obj</code></td>
<td>
<p> object of class &quot;SpatialPolygons&quot; or &quot;SpatialPolygonsDataFrame&quot; </p>
</td></tr>
<tr><td><code id="polygons_+3A_object">object</code></td>
<td>
<p> object of class &quot;data.frame&quot; </p>
</td></tr>
<tr><td><code id="polygons_+3A_value">value</code></td>
<td>
<p> object of class &quot;SpatialPolygons&quot; </p>
</td></tr>
</table>


<h3>Value</h3>

<p> polygons returns the SpatialPolygons of obj; polygons&lt;- promotes a
data.frame to a SpatialPolygonsDataFrame object </p>


<h3>Examples</h3>

<pre><code class='language-R'>grd &lt;- GridTopology(c(1,1), c(1,1), c(10,10))
polys &lt;- as.SpatialPolygons.GridTopology(grd)
centroids &lt;- coordinates(polys)
x &lt;- centroids[,1]
y &lt;- centroids[,2]
z &lt;- 1.4 + 0.1*x + 0.2*y + 0.002*x*x
df &lt;- data.frame(x=x, y=y, z=z, row.names=row.names(polys))
polygons(df) &lt;- polys
class(df)
summary(df)
</code></pre>

<hr>
<h2 id='Polygons-class'>Class &quot;Polygons&quot;</h2><span id='topic+Polygons-class'></span>

<h3>Description</h3>

<p> Collection of objects of class <code>"Polygon"</code> </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <code>Polygons</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>Polygons</code>:</dt><dd><p>Object of class <code>"list"</code>; list with objects
of class <a href="sp.html#topic+Polygon-class">Polygon-class</a> </p>
</dd>
<dt><code>plotOrder</code>:</dt><dd><p>Object of class <code>"integer"</code>; order in which
the Polygon objects should be plotted, currently by order of decreasing size </p>
</dd>
<dt><code>labpt</code>:</dt><dd><p>Object of class <code>"numeric"</code>; pair of x, y coordinates giving a label point, the label point of the largest polygon component  </p>
</dd>
<dt><code>ID</code>:</dt><dd><p>Object of class <code>"character"</code>; unique identifier string  </p>
</dd>
<dt><code>area</code>:</dt><dd><p>Object of class <code>"numeric"</code>; the gross total planar area of the Polygon list but not double-counting holes (changed from 0.9-58 - islands are summed, holes are ignored rather than subtracted); these values are used to make sure that polygons of a smaller area are plotted after polygons of a larger area, does not respect projection as objects of this class have no projection defined </p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class &quot;Polygons&quot; in the signature.
</p>


<h3>Note</h3>

<p> By default, single polygons (where Polygons is a list of length one) are not expected to be holes, but in multiple polygons, hole definitions for member polygons can be set. Polygon objects belonging to an Polygons object should either not overlap one-other, or should be fully included (as lakes or islands in lakes). They should not be self-intersecting. Checking of hole FALSE/TRUE status for Polygons objects is now handled by round-trip coercion to <code>sf</code> and back to <code>sp</code>. </p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>

<hr>
<h2 id='polygons-methods'> Retrieve polygons from SpatialPolygonsDataFrame object </h2><span id='topic+polygons-methods'></span><span id='topic+polygons+2CSpatial-method'></span><span id='topic+polygons+2CSpatialPolygons-method'></span><span id='topic+polygons+3C-+2Cdata.frame+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Retrieve polygons from SpatialPolygonsDataFrame object
</p>


<h3>Methods for polygons</h3>


<dl>
<dt>obj = &quot;SpatialPolygons&quot;</dt><dd><p> object of, or deriving from, SpatialPolygons </p>
</dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;</dt><dd><p> object of, or deriving from, 
SpatialPolygonsDataFrame </p>
</dd>
</dl>


<h3>Methods for &quot;polygons&lt;-&quot;</h3>


<dl>
<dt>object = &quot;data.frame&quot;, value=&quot;SpatialPolygons&quot;</dt><dd><p> promote data.frame to object of class
<a href="sp.html#topic+SpatialPolygonsDataFrame-class">SpatialPolygonsDataFrame-class</a>, by specifying polygons </p>
</dd>
</dl>

<hr>
<h2 id='read.asciigrid'> read/write to/from (ESRI) asciigrid format </h2><span id='topic+read.asciigrid'></span><span id='topic+write.asciigrid'></span>

<h3>Description</h3>

<p> read/write to/from ESRI asciigrid format </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
read.asciigrid(fname, as.image = FALSE, plot.image = FALSE, colname = fname,
 proj4string = CRS(as.character(NA)))
write.asciigrid(x, fname, attr = 1, na.value = -9999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.asciigrid_+3A_fname">fname</code></td>
<td>
<p> file name </p>
</td></tr>
<tr><td><code id="read.asciigrid_+3A_as.image">as.image</code></td>
<td>
<p>logical; if FALSE, a list is returned, ready to be
shown with the <code>image</code> command; if FALSE an object of
class <a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a> is returned </p>
</td></tr>
<tr><td><code id="read.asciigrid_+3A_plot.image">plot.image</code></td>
<td>
<p>logical; if TRUE, an image of the map is plotted</p>
</td></tr>
<tr><td><code id="read.asciigrid_+3A_colname">colname</code></td>
<td>
<p>alternative name for data column if not file name</p>
</td></tr>
<tr><td><code id="read.asciigrid_+3A_proj4string">proj4string</code></td>
<td>
<p>A CRS object setting the projection arguments of the Spatial Grid returned</p>
</td></tr>
<tr><td><code id="read.asciigrid_+3A_x">x</code></td>
<td>
<p> object of class <a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a></p>
</td></tr>
<tr><td><code id="read.asciigrid_+3A_attr">attr</code></td>
<td>
<p>attribute column; if missing, the first
column is taken; a name or a column number may be given</p>
</td></tr>
<tr><td><code id="read.asciigrid_+3A_na.value">na.value</code></td>
<td>
<p>numeric; value given to missing valued cells in the
resulting map</p>
</td></tr>
<tr><td><code id="read.asciigrid_+3A_...">...</code></td>
<td>
<p> arguments passed to <a href="utils.html#topic+write.table">write.table</a>, which is used
to write the numeric data </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read.asciigrid</code> returns the grid map read; either as
an object of class <a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a> or, if
as.image is TRUE, as list with components <code>x</code>, <code>y</code> and <code>z</code>.
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma</p>


<h3>See Also</h3>

 <p><a href="sp.html#topic+as.image.SpatialGridDataFrame">as.image.SpatialGridDataFrame</a>, <a href="Matrix.html#topic+image">image</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.asciigrid(system.file("external/test.ag", package="sp")[1])
class(x)
image(x)
</code></pre>

<hr>
<h2 id='recenter-methods'>Methods for Function recenter in Package &lsquo;sp&rsquo;</h2><span id='topic+recenter-methods'></span><span id='topic+recenter'></span><span id='topic+recenter+2CSpatialPolygons-method'></span><span id='topic+recenter+2CPolygons-method'></span><span id='topic+recenter+2CPolygon-method'></span><span id='topic+recenter+2CSpatialLines-method'></span><span id='topic+recenter+2CLines-method'></span><span id='topic+recenter+2CLine-method'></span>

<h3>Description</h3>

<p>Methods for function <code>recenter</code> in package <span class="pkg">sp</span> to shift or re-center geographical coordinates for a Pacific view. All longitudes &lt; 0 are added to 360, to avoid for instance parts of Alaska being represented on the far left and right of a plot because they have values straddling 180 degrees. In general, using a projected coordinate reference system is to be preferred, but this method permits a geographical coordinate reference system to be used. This idea was suggested by Greg Snow, and corresponds to the two world representations in the <span class="pkg">maps</span> package. 
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;SpatialPolygons&quot;</dt><dd><p>recenter a SpatialPolygons object</p>
</dd>
<dt>obj = &quot;Polygons&quot;</dt><dd><p>recenter a Polygons object </p>
</dd>
<dt>obj = &quot;Polygon&quot;</dt><dd><p>recenter an Polygon object </p>
</dd>
<dt>obj = &quot;SpatialLines&quot;</dt><dd><p>recenter a SpatialLines object </p>
</dd>
<dt>obj = &quot;Lines&quot;</dt><dd><p>recenter a Lines object </p>
</dd>
<dt>obj = &quot;Line&quot;</dt><dd><p>recenter an Line object </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>crds &lt;- matrix(c(179, -179, -179, 179, 50, 50, 52, 52), ncol=2)
SL &lt;- SpatialLines(list(Lines(list(Line(crds)), "1")),
 CRS("+proj=longlat +ellps=WGS84"))
bbox(SL)
SLr &lt;- recenter(SL)
bbox(SLr)
rcrds &lt;- rbind(crds, crds[1,])
SpP &lt;- SpatialPolygons(list(Polygons(list(Polygon(rcrds)), ID="r1")),
 proj4string=CRS("+proj=longlat +ellps=WGS84"))
bbox(SpP)
SpPr &lt;- recenter(SpP)
bbox(SpPr)
opar &lt;- par(mfrow=c(1,2))
plot(SpP)
plot(SpPr)
par(opar)
crds &lt;- matrix(c(-1, 1, 1, -1, 50, 50, 52, 52), ncol=2)
SL &lt;- SpatialLines(list(Lines(list(Line(crds)), "1")),
 CRS("+proj=longlat +ellps=WGS84"))
bbox(SL)
SLr &lt;- recenter(SL)
bbox(SLr)
rcrds &lt;- rbind(crds, crds[1,])
SpP &lt;- SpatialPolygons(list(Polygons(list(Polygon(rcrds)), ID="r1")),
 proj4string=CRS("+proj=longlat +ellps=WGS84"))
bbox(SpP)
SpPr &lt;- recenter(SpP)
bbox(SpPr)
opar &lt;- par(mfrow=c(1,2))
plot(SpP)
plot(SpPr)
par(opar)
</code></pre>

<hr>
<h2 id='Rlogo'>Rlogo jpeg image</h2><span id='topic+Rlogo'></span><span id='topic+gt'></span>

<h3>Description</h3>

<p>Rlogo jpeg image data as imported by <code>getRasterData</code> in the rgdal package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Rlogo)</code></pre>


<h3>Format</h3>

<p>The format is:
int [1:101, 1:77, 1:3] 255 255 255 255 255 255 255 255 255 255 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Rlogo)
d = dim(Rlogo)
cellsize = abs(c(gt[2],gt[6]))
cells.dim = c(d[1], d[2]) # c(d[2],d[1])
cellcentre.offset = c(x = gt[1] + 0.5 * cellsize[1], y = gt[4] - (d[2] - 0.5) * abs(cellsize[2]))
grid = GridTopology(cellcentre.offset, cellsize, cells.dim)
df = as.vector(Rlogo[,,1])
for (band in 2:d[3]) df = cbind(df, as.vector(Rlogo[,,band]))
df = as.data.frame(df)
names(df) = paste("band", 1:d[3], sep="")
Rlogo &lt;- SpatialGridDataFrame(grid = grid, data = df)
summary(Rlogo)
spplot(Rlogo, zcol=1:3, names.attr=c("red","green","blue"), 
	col.regions=grey(0:100/100),
	main="example of three-layer (RGB) raster image", as.table=TRUE)
</code></pre>

<hr>
<h2 id='select.spatial'> select points spatially </h2><span id='topic+select.spatial'></span>

<h3>Description</h3>

<p>select a number of points by digitizing the area they fall in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.spatial(data, digitize = TRUE, pch = "+", rownames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.spatial_+3A_data">data</code></td>
<td>
<p>data object of class, or extending <code>SpatialPoints</code>;
this object knows about its x and y coordinate </p>
</td></tr>
<tr><td><code id="select.spatial_+3A_digitize">digitize</code></td>
<td>
<p> logical; if TRUE, points in a digitized polygon
are selected; if FALSE, points identified by mouse clicks are selected </p>
</td></tr>
<tr><td><code id="select.spatial_+3A_pch">pch</code></td>
<td>
<p>plotting character used for points</p>
</td></tr>
<tr><td><code id="select.spatial_+3A_rownames">rownames</code></td>
<td>
<p>logical; if FALSE, row (coordinate) numbers are returned;
if TRUE and data contains a data.frame part, row.names for selected points
in the data.frame are returned. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> if rownames == FALSE, array with either indexes (row numbers)
of points inside the digitized polygon; if rownames == TRUE, character
array with corresponding row names in the data.frame part </p>


<h3>See Also</h3>

<p><a href="sp.html#topic+point.in.polygon">point.in.polygon</a>, <a href="graphics.html#topic+locator">locator</a>, 
<a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a>, <a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
## the following command requires user interaction: left mouse
## selects points, right mouse ends digitizing
data(meuse)
coordinates(meuse) = c("x", "y")
# select.spatial(meuse)
</code></pre>

<hr>
<h2 id='sp'>A package providing classes and methods for spatial data: points,
lines, polygons and grids </h2><span id='topic+sp'></span>

<h3>Description</h3>

<p>This package provides S4 classes for importing, manipulating and exporting
spatial data in R, and for methods including print/show, plot, subset,
<code>[</code>, <code>[[</code>, <code>\$</code>, names, dim, summary, and a number of
methods specific to spatial data handling.
</p>


<h3>Introduction</h3>

<p>Several spatial statistical packages have been around for a long while,
but no organized set of classes for spatial data has yet been devised.
Many of the spatial packages make their own assumptions, or use their
own class definitions for spatial data, making it inconvenient to move
from one package to another. This package tries to provide a solid set
of classes for many different types of spatial data. The idea is that
spatial statistical packages will either support these classes (i.e.,
directly read and write them) or will provide conversion to them, so that
we have a base class set with which any package can exchange. This way,
many-to-many conversions can be replace with one-to-many conversions,
provided either in this package or the spatial packages. Wherever possible
conversion (coercion) functions are automatic, or provided by sp.
</p>
<p>External packages that depend on sp will provide importing and exporting
from and to external GIS formats, e.g. through GDAL, OGR or shapelib.
</p>
<p>In addition, this package tries to provide convenient methods to print,
summarize and plot such spatial data.
</p>


<h3>Dimensions</h3>

<p>In principal, geographical data are two-dimensional, on a flat surface (a
map) or on a sphere (the earth). This package provides space for dealing
with higher dimensional data where possible; this is e.g. very simple
for points and grids, but hard to do for polygons. Plotting functions
are devised primarily for two-dimensional data, or two-dimensional
projections of higher dimensional data.
</p>


<h3>Coordinate reference systems</h3>

<p>Central to spatial data is that they have a coordinate reference system,
which is coded in object of CRS class. Central to operations on different
spatial data sets is that their coordinate reference system is compatible
(i.e., identical). 
</p>
<p>This CRS can be a character string describing a reference system in
a way understood by the PROJ.4 projection library, or a (character)
missing value. An interface to the PROJ.4 library is available only if
the R package rgdal is present.
</p>


<h3>Class structure</h3>

<p>All spatial classes derive from a basic class <code>Spatial</code>, which only
provides a bounding box and a CRS. This class has no useful instances, but
useful derived classes. 
</p>
<p>SpatialPoints extends Spatial and has coordinates.  The method
<a href="raster.html#topic+coordinates">coordinates</a> extracts the numeric matrix with coordinates from an
object of class SpatialPoints, or from other (possibly derived) classes
that have points.
</p>
<p>Objects of class SpatialGrid points on a regular grid. Either a full grid
is stored or a partial grid (i.e., only the non-missing valued cells);
calling <a href="raster.html#topic+coordinates">coordinates</a> on them will give the coordinates for the
grid cells.
</p>
<p>SpatialPoints, SpatialPixels and SpatialGrid can be of arbitrary
dimension, although most of the effort is in making them work for two
dimensional data.
</p>
<p>SpatialLines provides lines, and SpatialPolygons provides polygons, i.e.,
lines that end where they start and do not intersect with itself.
SpatialLines and SpatialPolygons only have two-dimensional data.
</p>
<p>SpatialPointsDataFrame extends SpatialPoints with a data slot, having
a data.frame with attribute data. Similarly, SpatialPixelsDataFrame,
SpatialLinesDataFrame, SpatialPolygonsDataFrame extend the primary
spatial information with attribute data.
</p>


<h3>References</h3>

<p>PROJ.4: <a href="https://github.com/OSGeo/PROJ">https://github.com/OSGeo/PROJ</a>
</p>
<p>GDAL and OGR: <a href="https://gdal.org/">https://gdal.org/</a>.
</p>


<h3>Authors</h3>

<p>sp is a collaborative effort of Edzer Pebesma, Roger Bivand, Barry
Rowlingson and Virgilo G\'omez-Rubio.
</p>

<hr>
<h2 id='sp-deprecated'> Deprecated functions in sp </h2><span id='topic+getSpPPolygonsIDSlots'></span><span id='topic+getSpPPolygonsLabptSlots'></span><span id='topic+getSpPnParts'></span><span id='topic+getSpPnHoles'></span><span id='topic+getSpPplotOrderSlot'></span><span id='topic+getSpPpolygonsSlot'></span><span id='topic+getPolygonAreaSlot'></span><span id='topic+getPolygonCoordsSlot'></span><span id='topic+getPolygonLabptSlot'></span><span id='topic+getPolygonHoleSlot'></span><span id='topic+getPolygonsIDSlot'></span><span id='topic+getPolygonsLabptSlot'></span><span id='topic+getPolygonsPolygonsSlot'></span><span id='topic+getPolygonsplotOrderSlot'></span><span id='topic+getLinesLinesSlot'></span><span id='topic+getLinesIDSlot'></span><span id='topic+getSLlinesSlot'></span><span id='topic+getSLLinesIDSlots'></span><span id='topic+get_evolution_status'></span><span id='topic+set_evolution_status'></span>

<h3>Description</h3>

<p>Deprecated functions is sp: getSpP*, getPolygon*, getLines* getSL*
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_evolution_status(value)
get_evolution_status()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp-deprecated_+3A_value">value</code></td>
<td>
<p>evolution status: only 2L to use sf functions in place of rgdal</p>
</td></tr>
</table>


<h3>Note</h3>

<p> For <code>overlay</code> the new implementation is found in the <a href="grDevices.html#topic+over">over</a> 
method; this works slightly different and more consistent. </p>

<hr>
<h2 id='sp2Mondrian'>write map data for Mondrian</h2><span id='topic+sp2Mondrian'></span>

<h3>Description</h3>

<p>The function outputs a SpatialPolygonsDataFrame object to be used by Mondrian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2Mondrian(SP, file, new_format=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp2Mondrian_+3A_sp">SP</code></td>
<td>
<p>a SpatialPolygonsDataFrame object</p>
</td></tr>
<tr><td><code id="sp2Mondrian_+3A_file">file</code></td>
<td>
<p>file where output is written</p>
</td></tr>
<tr><td><code id="sp2Mondrian_+3A_new_format">new_format</code></td>
<td>
<p>default TRUE, creates a text data file and a separate map file; the old format put both data sets in a single file - the map file is named by inserting &quot;MAP_&quot; into the file= argument after the rightmost directory separator (if any)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>At this release, the function writes out a text file with both data and polygon(s) identified as belonging to each row of data.
</p>


<h3>Author(s)</h3>

<p>Patrick Hausmann and Roger Bivand</p>


<h3>References</h3>

<p><a href="https://www.theusrus.de/Mondrian/">https://www.theusrus.de/Mondrian/</a>, Ihaka Lecture 1: 28 September 2023, Interactive Graphics and Data Analysis, Antony Unwin <a href="https://www.auckland.ac.nz/en/science/about-the-faculty/department-of-statistics/ihaka-lecture-series.html">https://www.auckland.ac.nz/en/science/about-the-faculty/department-of-statistics/ihaka-lecture-series.html</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("sf", quietly=TRUE)) {
td &lt;- tempdir()
xx &lt;- as(sf::st_read(system.file("shape/nc.shp", package="sf")[1], quiet=TRUE), "Spatial")
sp2Mondrian(xx, file=file.path(td, "sids1.txt"))
}
</code></pre>

<hr>
<h2 id='Spatial-class'>Class &quot;Spatial&quot;</h2><span id='topic+Spatial-class'></span><span id='topic+Spatial'></span><span id='topic+print.summary.Spatial'></span><span id='topic+subset.Spatial'></span><span id='topic+cbind.Spatial'></span><span id='topic+head.Spatial'></span><span id='topic+tail.Spatial'></span><span id='topic+summary+2CSpatial-method'></span><span id='topic+plot+2CSpatial+2Cmissing-method'></span><span id='topic+getParUsrBB'></span><span id='topic+setParUsrBB'></span><span id='topic+coordinates+3C-+2CSpatial-method'></span><span id='topic++5B+5B+3C-+2CSpatial+2CANY+2Cmissing-method'></span><span id='topic++5B+3C-+2CSpatial-method'></span><span id='topic++5B+5B+2CSpatial+2CANY+2Cmissing-method'></span><span id='topic++24+3C-+2CSpatial-method'></span><span id='topic++24+2CSpatial-method'></span><span id='topic+im-class'></span><span id='topic+owin-class'></span><span id='topic+ppp-class'></span><span id='topic+psp-class'></span><span id='topic+rebuild_CRS+2CSpatial-method'></span>

<h3>Description</h3>

<p> An abstract class from which useful spatial classes are
derived </p>


<h3>Usage</h3>

<pre><code class='language-R'>Spatial(bbox, proj4string = CRS(as.character(NA)))
## S3 method for class 'Spatial'
subset(x, subset, select, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spatial-class_+3A_bbox">bbox</code></td>
<td>
<p>a bounding box matrix</p>
</td></tr>
<tr><td><code id="Spatial-class_+3A_proj4string">proj4string</code></td>
<td>
<p>a CRS object</p>
</td></tr>
<tr><td><code id="Spatial-class_+3A_x">x</code></td>
<td>
<p>object of class Spatial</p>
</td></tr>
<tr><td><code id="Spatial-class_+3A_subset">subset</code></td>
<td>
<p>see <a href="base.html#topic+subset.data.frame">subset.data.frame</a></p>
</td></tr>
<tr><td><code id="Spatial-class_+3A_select">select</code></td>
<td>
<p>see <a href="base.html#topic+subset.data.frame">subset.data.frame</a></p>
</td></tr>
<tr><td><code id="Spatial-class_+3A_drop">drop</code></td>
<td>
<p>see <a href="base.html#topic+subset.data.frame">subset.data.frame</a></p>
</td></tr>
<tr><td><code id="Spatial-class_+3A_...">...</code></td>
<td>
<p>passed through</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>are never to be generated; only derived classes can be meaningful </p>


<h3>Slots</h3>


<dl>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; 2-column matrix
holding the minimum in first and maximum in second column for the
x-coordinate (first row), y-coordinate (second row) and optionally,
for points and grids only, further coordinates. The constructed 
Spatial object will be invalid if any bbox values are NA or infinite. The column names must be <code>c("min", "max")</code></p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>. The name of this slot was chosen to reflect the use of Proj.4 strings to represent coordinate reference systems (CRS). The slot name will continue to be used, but as PROJ &gt;= 6 and GDAL &gt;= 3 are taken into use for reading files and for projection and transformation, the Proj.4 string CRS representation is being supplemented by a WKT2 (2019) representation. The reason for the modification is that important keys in the Proj.4 string representation are being deprecated in PROJ &gt;= 6 and GDAL &gt;= 3. Legacy <code>"CRS"</code>  objects hold only a valid Proj.4 string, which can be used for unprojecting or reprojecting coordinates; it is initialised to NA. If the <code>"CRS"</code> object is instantiated using <code>CRS()</code> with <span class="pkg">rgdal</span> using PROJ &gt;= 6 and GDAL &gt;= 3, the object may also have a WKT2 (2019) string carried as a <code>comment</code>. Non-NA strings may be checked for validity in the rgdal package, but attempts to assign a string containing &quot;longlat&quot; to data extending beyond longitude [-180, 360] or lattitude [-90, 90] will be stopped or warned, use <code><a href="sp.html#topic+set_ll_warn">set_ll_warn</a></code> to warn rather than stop, and <code><a href="sp.html#topic+set_ll_TOL">set_ll_TOL</a></code> to change the default tolerance for the range exceedance tests.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>bbox</dt><dd><p><code>signature(obj = "Spatial")</code>: retrieves the bbox element </p>
</dd>
<dt>dimensions</dt><dd><p><code>signature(obj = "Spatial")</code>: retrieves the number
of spatial dimensions spanned </p>
</dd>
<dt>gridded</dt><dd><p><code>signature(obj = "Spatial")</code>: logical, tells whether
the data is on a regular spatial grid </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "Spatial", y = "missing")</code>: plot method
for spatial objects; does nothing but setting up a plotting region choosing
a suitable aspect if not given(see below), colouring the plot background using either a bg= argument or par(&quot;bg&quot;), and possibly drawing axes.  </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "Spatial")</code>: summarize object</p>
</dd>
<dt><code>$</code></dt><dd><p> retrieves attribute column </p>
</dd>
<dt><code>$&lt;-</code></dt><dd><p> sets or replaces attribute column, or promote a
geometry-only object to an object having an attribute </p>
</dd>
<dt>rebuild_CRS</dt><dd><p>rebuild a CRS object, usually used to add a WKT comment with PROJ &gt;= 6 and GDAL &gt;= 3</p>
</dd>
</dl>



<h3>plot method arguments</h3>

<p>The plot method for &ldquo;Spatial&rdquo; objects takes the following arguments:
</p>

<dl>
<dt>x</dt><dd><p>object of class Spatial</p>
</dd>
<dt>xlim</dt><dd><p>default NULL; the x limits (x1, x2) of the plot</p>
</dd>
<dt>ylim</dt><dd><p>default NULL; the y limits of the plot</p>
</dd>
<dt>asp</dt><dd><p>default NA; the y/x aspect ratio</p>
</dd>
<dt>axes</dt><dd><p>default FALSE; a logical value indicating whether both axes should be drawn </p>
</dd>
<dt>bg</dt><dd><p>default <code>par("bg")</code>; colour to be used for the background of the device region</p>
</dd>
<dt>xaxs</dt><dd><p> The style of axis interval calculation to be used for the x-axis</p>
</dd>
<dt>yaxs</dt><dd><p> The style of axis interval calculation to be used for the y-axis</p>
</dd>
<dt>lab</dt><dd><p>A numerical vector of the form <code>c(x, y, len)</code> which modifies the default way that axes are annotated</p>
</dd>
<dt>setParUsrBB</dt><dd><p>default FALSE; set the <code>par</code> &ldquo;usr&rdquo; bounding box; see below</p>
</dd>
<dt>bgMap</dt><dd><p>object of class <code>ggmap</code>, or returned by function <code>RgoogleMaps::GetMap</code></p>
</dd>
<dt>expandBB</dt><dd><p> numeric; factor to expand the plotting region default: <code>bbox(x)</code> with on
each side (1=below, 2=left, 3=above and 4=right); defaults to <code>c(0,0,0,0)</code>; 
setting <code>xlim</code> or <code>ylim</code> overrides this. </p>
</dd>
<dt>...</dt><dd><p>passed through</p>
</dd>
</dl>



<h3>Warning </h3>

<p>this class is not useful in itself, but all spatial
classes in this package derive from it </p>


<h3>Note</h3>

  
<p>The default aspect for map plots is 1; if however data are not
projected (coordinates are longlat), the aspect is by default set to
1/cos(My * pi)/180) with My the y coordinate of the middle of the map
(the mean of ylim, which defaults to the y range of bounding box).
</p>
<p>The argument <code>setParUsrBB</code> may be used to pass the logical value <code>TRUE</code> to functions within <code>plot.Spatial</code>. When set to <code>TRUE</code>, par(&ldquo;usr&rdquo;) will be overwritten with <code>c(xlim, ylim)</code>, which defaults to the bounding box of the spatial object. This is only needed in the particular context of graphic output to a specified device with given width and height, to be matched to the spatial object, when using par(&ldquo;xaxs&rdquo;) and par(&ldquo;yaxs&rdquo;) in addition to <code>par(mar=c(0,0,0,0))</code>.
</p>


<h3>Author(s)</h3>

<p> r-spatial team; Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a>
Roger Bivand, Barry Rowlingson, Virgilio G\'omez-Rubio
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a></code>,
<code><a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a></code>,


<code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>,
<code><a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>o &lt;- new("Spatial")
proj4string(o) &lt;- CRS("+init=epsg:27700")
if (!is.null(comment(slot(o, "proj4string")))) {
  cat(strsplit(wkt(o), "\n")[[1]], sep="\n")
  cat(strsplit(wkt(slot(o, "proj4string")), "\n")[[1]], sep="\n")
}
</code></pre>

<hr>
<h2 id='SpatialGrid-class'>Class &quot;SpatialGrid&quot; </h2><span id='topic+SpatialGrid-class'></span><span id='topic++5B+2CSpatialGrid-method'></span><span id='topic+print.summary.SpatialGrid'></span><span id='topic+as.data.frame.SpatialGrid'></span><span id='topic+summary+2CSpatialGrid-method'></span><span id='topic+coerce+2CSpatialGrid+2Cdata.frame-method'></span><span id='topic+coerce+2CSpatialGrid+2CSpatialPixels-method'></span><span id='topic+coerce+2CSpatialGrid+2CSpatialPoints-method'></span><span id='topic+coerce+2CSpatialGrid+2CSpatialPolygons-method'></span><span id='topic+show+2CSpatialGrid-method'></span><span id='topic+plot+2CSpatialGrid+2Cmissing-method'></span><span id='topic+coordnames+2CSpatialGrid-method'></span>

<h3>Description</h3>

<p> class for defining a full, rectangular grid of
arbitrary dimension </p>


<h3>Objects from the Class</h3>

<p>Objects are created by using e.g. 
</p>
<p>SpatialGrid(grid)
</p>
<p>with grid of class <a href="sp.html#topic+GridTopology-class">GridTopology-class</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>grid</code></dt><dd><p> object of class <a href="sp.html#topic+GridTopology-class">GridTopology-class</a>, defining the
grid topology (offset, cellsize, dim) </p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; bounding box </p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; projection  </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"SpatialPoints"</code> directly;
Class <code>"Spatial"</code>, by class <code>"SpatialPoints"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>coordinates</dt><dd><p><code>signature(x = "SpatialGrid")</code>: calculates coordinates for
each point on the grid; coordinates are not stored in objects of class SpatialGrid</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SpatialGrid")</code>: summarize object</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SpatialGrid")</code>: plots cell centers </p>
</dd>
<dt>&quot;[&quot;</dt><dd><p><code>signature(x = "SpatialGrid")</code>: select rows and columns </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a></code>, <code><a href="sp.html#topic+SpatialGrid">SpatialGrid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = GridTopology(c(0,0), c(1,1), c(5,5))
class(x)
x
summary(x)
coordinates(x)
y = SpatialGrid(grid = x)
class(y)
y
</code></pre>

<hr>
<h2 id='SpatialGridDataFrame-class'>Class &quot;SpatialGridDataFrame&quot; </h2><span id='topic+SpatialGridDataFrame-class'></span><span id='topic++5B+2CSpatialGridDataFrame-method'></span><span id='topic+show+2CSpatialGridDataFrame-method'></span><span id='topic+cbind.SpatialGridDataFrame'></span><span id='topic+plot.SpatialGridDataFrame'></span><span id='topic+print.summary.SpatialGridDataFrame'></span><span id='topic+as.array.SpatialGridDataFrame'></span><span id='topic+coerce+2CSpatialGridDataFrame+2CSpatialPointsDataFrame-method'></span><span id='topic+coerce+2CSpatialGridDataFrame+2CSpatialPixelsDataFrame-method'></span><span id='topic+coerce+2CSpatialGridDataFrame+2CSpatialPolygonsDataFrame-method'></span><span id='topic+coerce+2CSpatialGridDataFrame+2Cdata.frame-method'></span><span id='topic+coerce+2CSpatialGridDataFrame+2Cmatrix-method'></span><span id='topic+coerce+2CSpatialGridDataFrame+2Carray-method'></span><span id='topic+as.data.frame.SpatialGridDataFrame'></span><span id='topic+dim.SpatialGridDataFrame'></span><span id='topic+coerce+2Cim+2CSpatialGridDataFrame-method'></span><span id='topic+coerce+2Cppp+2CSpatialGridDataFrame-method'></span><span id='topic+plot+2CSpatialGridDataFrame+2Cmissing-method'></span>

<h3>Description</h3>

<p>  Class for spatial attributes that have spatial locations
on a (full) regular grid. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>as(x,
"SpatialGridDataFrame")</code>, where <code>x</code> is of class
<a href="sp.html#topic+SpatialPixelsDataFrame-class">SpatialPixelsDataFrame-class</a>, or by importing through rgdal.  
Ordered full grids are stored instead or unordered non-NA cells; 
</p>


<h3>Slots</h3>


<dl>
<dt><code>grid</code>:</dt><dd><p>see <a href="sp.html#topic+GridTopology-class">GridTopology-class</a>; grid parameters </p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; bounding box </p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; projection </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class data.frame, containing attribute data </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"SpatialGrid"</code>, directly.
Class <code>"Spatial"</code>, by class <code>"SpatialGrid"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>coordinates</dt><dd><p><code>signature(x = "SpatialGridDataFrame")</code>: retrieves (and calculates!) coordinates </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "SpatialGridDataFrame")</code>: selects rows, columns, and attributes; returns an
object of class <code>SpatialGridDataFrame</code></p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "SpatialGridDataFrame")</code>: coerce to matrix; increasing col index corresponds to decreasing y coordinate, row index increases with coordinate index </p>
</dd>
<dt>as.array</dt><dd><p><code>signature(x = "SpatialGridDataFrame")</code>: coerce to array; increasing array index for the second dimension corresponds to decreasing coordinates, all other coordinate dimensions increase with array index </p>
</dd>
<dt>cbind</dt><dd><p><code>signature(...)</code>: if arguments have identical topology, combine their
attribute values</p>
</dd>
</dl>



<h3>Plot method arguments</h3>

<p>The plot methods for &ldquo;SpatialPixelsDataFrame&rdquo; or &ldquo;SpatialGridDataFrame&rdquo; 
objects take the following arguments:
</p>

<dl>
<dt>x</dt><dd><p>object of class <a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPixelsDataFrame</a> or <a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a></p>
</dd>
<dt>...</dt><dd><p> arguments passed on to <a href="sp.html#topic+image.SpatialGridDataFrame">image.SpatialGridDataFrame</a></p>
</dd>
<dt>attr</dt><dd><p> integer or character, indicating the attribute variable to be plotted; default 1</p>
</dd>
<dt>col</dt><dd><p> color ramp to be used; default <code>bpy.colors(100)</code> for continuous, or
<code>RColorBrewer::brewer.pal(nlevels(x[[1]]), "Set2")</code> for factor variables</p>
</dd>
<dt>breaks</dt><dd><p> for continuous attributes: values at which color breaks should take place </p>
</dd>
<dt>zlim</dt><dd><p> for continuous attributes: 
numeric of length 2, specifying the range of attribute values to be plotted; 
default to data range <code>range(as.numeric(x[[attr]])[is.finite(x[[attr]])])</code></p>
</dd>
<dt>axes</dt><dd><p> logical: draw x and y axes? default <code>FALSE</code></p>
</dd>
<dt>xaxs</dt><dd><p>character, default &quot;i&quot;, see <a href="graphics.html#topic+par">par</a></p>
</dd>
<dt>yaxs</dt><dd><p>character, default equal to <code>xaxs</code>, see <a href="graphics.html#topic+par">par</a></p>
</dd>
<dt>at</dt><dd><p>numeric or NULL, values at which axis tics and labels should be drawn; default NULL (use <a href="base.html#topic+pretty">pretty</a>)</p>
</dd>
<dt>border</dt><dd><p>color, to be used for drawing grid lines; default NA (don't draw grid lines)</p>
</dd>
<dt>axis.pos</dt><dd><p>integer, 1-4; default 4, see <a href="graphics.html#topic+axis">axis</a></p>
</dd>
<dt>add.axis</dt><dd><p>logical: draw axis along scale? default <code>TRUE</code></p>
</dd>
<dt>what</dt><dd><p>what to draw: <code>"image"</code>, <code>"scale"</code>, or <code>"both"</code>; default &quot;both&quot;</p>
</dd>
<dt>scale.size</dt><dd><p>size for the scale bar; use <a href="graphics.html#topic+lcm">lcm</a> to specify in absolute size, or a numeric
value such as <code>1/6</code> to specify relative size; default <code>lcm(2.8)</code></p>
</dd>
<dt>scale.shrink</dt><dd><p> non-negative numeric indicating the amount to shrink the scale length, default 0</p>
</dd>
<dt>scale.frac</dt><dd><p>for categorical attributes: numeric between 0 and 1, indicating the scale width, default 0.3</p>
</dd>
<dt>scale.n</dt><dd><p>for categorical attributes: integer, indicating how many scale categories should fill a complete width; default 15</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a></code>, which does not contain the attribute data,
and <code><a href="sp.html#topic+SpatialPixelsDataFrame-class">SpatialPixelsDataFrame-class</a> which holds possibly incomplete
  grids </code>
</p>
<p>Plotting gridded data with sp: <a href="https://r-spatial.org/r/2016/03/08/plotting-spatial-grids.html">https://r-spatial.org/r/2016/03/08/plotting-spatial-grids.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid) # only the non-missing valued cells
coordinates(meuse.grid) = c("x", "y") # promote to SpatialPointsDataFrame
gridded(meuse.grid) &lt;- TRUE # promote to SpatialPixelsDataFrame
x = as(meuse.grid, "SpatialGridDataFrame") # creates the full grid
x[["idist"]] = 1 - x[["dist"]] # assigns new attribute
image(x["idist"]) # note the single [ for attribute selection

# toy example:
df = data.frame(z = c(1:6,NA,8,9),
    xc = c(1,1,1,2,2,2,3,3,3),
    yc = c(rep(c(0, 1.5, 3),3)))
coordinates(df) = ~xc+yc
gridded(df) = TRUE
df = as(df, "SpatialGridDataFrame") # to full grid
image(df["z"])
# draw labels to verify:
cc = coordinates(df)
z=df[["z"]]
zc=as.character(z)
zc[is.na(zc)]="NA"
text(cc[,1],cc[,2],zc)

# the following is weird, but illustrates the concept of row/col selection:
fullgrid(meuse.grid) = TRUE
image(meuse.grid)
image(meuse.grid[20:70, 10:70, "dist"], add = TRUE, col = bpy.colors())

# as.matrix, as.array
sgdim = c(3,4)
SG = SpatialGrid(GridTopology(rep(0,2), rep(10,2), sgdim))
SGDF = SpatialGridDataFrame(SG, data.frame(val = 1:12))
as.array(SGDF)
as.matrix(SGDF)
as(SGDF, "array")
</code></pre>

<hr>
<h2 id='SpatialLines'> create objects of class SpatialLines or SpatialLinesDataFrame</h2><span id='topic+SpatialLines'></span><span id='topic+SpatialLinesDataFrame'></span><span id='topic+as.SpatialLines.SLDF'></span><span id='topic+getSpatialLinesMidPoints'></span><span id='topic+LineLength'></span><span id='topic+LinesLength'></span><span id='topic+SpatialLinesLengths'></span>

<h3>Description</h3>

<p> create objects of class <code>SpatialLines</code> or 
<code>SpatialLinesDataFrame</code> from
lists of <code>Lines</code> objects and data.frames; extract list od Lines from a SpatialLines object</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
SpatialLines(LinesList, proj4string = CRS(as.character(NA)))
SpatialLinesDataFrame(sl, data, match.ID = TRUE)
as.SpatialLines.SLDF(SLDF)
getSpatialLinesMidPoints(SL)
LineLength(cc, longlat = FALSE, sum = TRUE)
LinesLength(Ls, longlat = FALSE)
SpatialLinesLengths(SL, longlat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialLines_+3A_lineslist">LinesList</code></td>
<td>
<p> list with objects of class <a href="sp.html#topic+Lines-class">Lines-class</a></p>
</td></tr>
<tr><td><code id="SpatialLines_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class <code>"CRS"</code>; holding a valid proj4 string</p>
</td></tr>
<tr><td><code id="SpatialLines_+3A_sl">sl</code>, <code id="SpatialLines_+3A_sl">SL</code></td>
<td>
<p> object of class <a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a></p>
</td></tr>
<tr><td><code id="SpatialLines_+3A_data">data</code></td>
<td>
<p> object of class <code>data.frame</code>; the number of rows in <code>data</code>
should equal the number of <code>Lines</code> elements in <code>sl</code></p>
</td></tr>
<tr><td><code id="SpatialLines_+3A_match.id">match.ID</code></td>
<td>
<p>logical: (default TRUE): match SpatialLines member
Lines ID slot values with data.frame row names, and re-order the
data frame rows if necessary; if character: indicates the column
in <code>data</code> with Lines IDs to match</p>
</td></tr>
<tr><td><code id="SpatialLines_+3A_sldf">SLDF</code></td>
<td>
<p>SpatialLinesDataFrame object</p>
</td></tr>
<tr><td><code id="SpatialLines_+3A_ls">Ls</code></td>
<td>
<p>Object of class <code>Lines</code></p>
</td></tr>
<tr><td><code id="SpatialLines_+3A_cc">cc</code></td>
<td>
<p>Object of class <code>Line</code>, or two-column matrix with points</p>
</td></tr>
<tr><td><code id="SpatialLines_+3A_longlat">longlat</code></td>
<td>
<p>if FALSE, Euclidean distance, if TRUE Great Circle distance in kilometers</p>
</td></tr>
<tr><td><code id="SpatialLines_+3A_sum">sum</code></td>
<td>
<p>logical; if <code>TRUE</code> return scalar length of sum of 
segments in Line, if <code>FALSE</code> return vector with segment lengths</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatialLines</code> returns object of class <code>SpatialLines</code>;
<code>SpatialLinesDataFrame</code> returns object of class <code>SpatialLinesDataFrame</code>
<code>getSpatialLinesMidPoints</code> returns an object of class <code>SpatialPoints</code>,each point containing the (weighted) mean of the lines elements; weighted in the sense that mean is called twice.
</p>


<h3>See Also</h3>

 <p><a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a> </p>

<hr>
<h2 id='SpatialLines-class'>a class for spatial lines </h2><span id='topic+SpatialLines-class'></span><span id='topic++5B+2CSpatialLines-method'></span><span id='topic+plot+2CSpatialLines+2Cmissing-method'></span><span id='topic+summary+2CSpatialLines-method'></span><span id='topic+rbind.SpatialLines'></span><span id='topic+coerce+2CSpatialLines+2CSpatialPoints-method'></span><span id='topic+coerce+2CSpatialLines+2CSpatialPointsDataFrame-method'></span><span id='topic+coerce+2CLines+2CSpatialPoints-method'></span><span id='topic+coerce+2CLines+2CSpatialMultiPoints-method'></span><span id='topic+coerce+2CSpatialLines+2CSpatialMultiPoints-method'></span><span id='topic+coerce+2Cdeldir+2CSpatialLines-method'></span><span id='topic+row.names.SpatialLines'></span>

<h3>Description</h3>

<p> a class that holds spatial lines </p>


<h3>Objects from the Class</h3>

<p>hold a list of Lines objects; each Lines object holds a list
of Line (line) objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lines</code>:</dt><dd><p>Object of class <code>"list"</code>; list members are all of
class <a href="sp.html#topic+Lines-class">Lines-class</a></p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; see <a href="sp.html#topic+Spatial-class">Spatial-class</a> </p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; see <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Spatial"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(obj = "SpatialLines")</code>: select subset of (sets of) lines; NAs are not permitted in the row index</p>
</dd>
<dt>coordinates</dt><dd><p> value is a list of lists with matrices </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SpatialLines", y = "missing")</code>: 
plot lines in SpatialLines object</p>
</dd>
<dt>lines</dt><dd><p><code>signature(x = "SpatialLines")</code>: 
add lines in SpatialLines object to a plot </p>
</dd>
<dt>rbind</dt><dd><p><code>signature(object = "SpatialLines")</code>: 
rbind-like method, see notes </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SpatialLines")</code>: 
summarize object </p>
</dd>
</dl>



<h3>plot method arguments</h3>

<p>The plot method for &ldquo;SpatialLines&rdquo; objects takes the following arguments:
</p>

<dl>
<dt>x</dt><dd><p>object of class SpatialLines</p>
</dd>
<dt>xlim</dt><dd><p>default NULL; the x limits (x1, x2) of the plot</p>
</dd>
<dt>ylim</dt><dd><p>default NULL; the y limits of the plot</p>
</dd>
<dt>col</dt><dd><p>default 1; default plotting color</p>
</dd>
<dt>lwd</dt><dd><p>default 1; line width</p>
</dd>
<dt>lty</dt><dd><p>default 1; line type</p>
</dd>
<dt>add</dt><dd><p>default FALSE; add to existing plot</p>
</dd>
<dt>axes</dt><dd><p>default FALSE; a logical value indicating whether both axes should be drawn </p>
</dd>
<dt>lend</dt><dd><p>default 0; line end style</p>
</dd>
<dt>ljoin</dt><dd><p>default 0; line join style</p>
</dd>
<dt>lmitre</dt><dd><p>default 10; line mitre limit</p>
</dd>
<dt>...</dt><dd><p>passed through</p>
</dd>
<dt>setParUsrBB</dt><dd><p>set the <code>par</code> &ldquo;usr&rdquo; bounding box, see note in <a href="sp.html#topic+Spatial-class">Spatial-class</a></p>
</dd>
</dl>



<h3>Note</h3>

<p><code>rbind</code> calls the function <code><a href="sp.html#topic+SpatialLines">SpatialLines</a></code>, where it is 
checked that all IDs are unique. If <code>rbind</code>-ing <code>SpatialLines</code> without 
unique IDs, it is possible to set the argument <code>makeUniqueIDs = TRUE</code>, although
it is preferred to change these explicitly with <code><a href="sp.html#topic+spChFIDs">spChFIDs</a></code>.
</p>


<h3>Author(s)</h3>

<p> Roger Bivand, Edzer Pebesma </p>


<h3>See Also</h3>

<p><a href="sp.html#topic+Line-class">Line-class</a>, <a href="sp.html#topic+Lines-class">Lines-class</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# from the sp vignette:
l1 = cbind(c(1,2,3),c(3,2,2))
rownames(l1) = letters[1:3]
l1a = cbind(l1[,1]+.05,l1[,2]+.05)
rownames(l1a) = letters[1:3]
l2 = cbind(c(1,2,3),c(1,1.5,1))
rownames(l2) = letters[1:3]
Sl1 = Line(l1)
Sl1a = Line(l1a)
Sl2 = Line(l2)
S1 = Lines(list(Sl1, Sl1a), ID="a")
S2 = Lines(list(Sl2), ID="b")
Sl = SpatialLines(list(S1,S2))
summary(Sl)
plot(Sl, col = c("red", "blue"))
</code></pre>

<hr>
<h2 id='SpatialLinesDataFrame-class'>a class for spatial lines with attributes </h2><span id='topic+SpatialLinesDataFrame-class'></span><span id='topic+coerce+2CSpatialLinesDataFrame+2Cdata.frame-method'></span><span id='topic++5B+2CSpatialLinesDataFrame-method'></span><span id='topic+rbind.SpatialLinesDataFrame'></span><span id='topic+coerce+2CSpatialLinesDataFrame+2CSpatialPointsDataFrame-method'></span><span id='topic+coerce+2CSpatialLinesDataFrame+2CSpatialMultiPointsDataFrame-method'></span><span id='topic+dim.SpatialLinesDataFrame'></span><span id='topic+row.names.SpatialLinesDataFrame'></span>

<h3>Description</h3>

<p> this class holds data consisting of (sets of lines), where each
set of lines relates to an attribute row in a data.frame </p>


<h3>Objects from the Class</h3>

<p>can be created by the function <a href="sp.html#topic+SpatialLinesDataFrame">SpatialLinesDataFrame</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <a href="base.html#topic+data.frame">data.frame</a> containing the attribute table </p>
</dd>
<dt><code>lines</code>:</dt><dd><p>Object of class <code>"list"</code>; see <a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a></p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; see <a href="sp.html#topic+Spatial-class">Spatial-class</a> </p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; see <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"SpatialLines"</code>, directly.
Class <code>"Spatial"</code>, by class <code>"SpatialLines"</code>.
</p>


<h3>Methods</h3>

<p>Methods defined with class &quot;SpatialLinesDataFrame&quot; in the signature:
</p>

<dl>
<dt>[</dt><dd><p><code>signature(x = "SpatialLinesDataFrame")</code>: subset rows or
columns; in case of row subsetting, the line sets are also subsetted; NAs are not permitted in the row index </p>
</dd>
<dt>coordinates</dt><dd><p><code>signature(obj = "SpatialLinesDataFrame")</code>: retrieves
a list with lists of coordinate matrices </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SpatialLinesDataFrame")</code>: print method </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SpatialLinesDataFrame")</code>: plot points</p>
</dd>
<dt>lines</dt><dd><p><code>signature(object = "SpatialLinesDataFrame")</code>: add lines to plot</p>
</dd>
<dt>rbind</dt><dd><p><code>signature(object = "SpatialLinesDataFrame")</code>: 
rbind-like method</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>rbind</code> for <code>SpatialLinesDataFrame</code> is only possible for 
objects with unique IDs. If you want to <code>rbind</code> objects
with duplicated IDs, see<code><a href="sp.html#topic+spChFIDs">spChFIDs</a></code>.
</p>


<h3>Author(s)</h3>

<p> Roger Bivand; Edzer Pebesma </p>


<h3>See Also</h3>

<p><a href="sp.html#topic+SpatialLines-class">SpatialLines-class</a>
</p>

<hr>
<h2 id='SpatialMultiPoints'> create objects of class SpatialMultiPoints or SpatialMultiPointsDataFrame</h2><span id='topic+SpatialMultiPoints'></span><span id='topic+SpatialMultiPointsDataFrame'></span>

<h3>Description</h3>

<p> create objects of class <a href="sp.html#topic+SpatialMultiPoints-class">SpatialMultiPoints-class</a> or 
<a href="sp.html#topic+SpatialMultiPointsDataFrame-class">SpatialMultiPointsDataFrame-class</a> from
coordinates, and from coordinates and <code>data.frame</code>s</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
SpatialMultiPoints(coords, proj4string=CRS(as.character(NA)), bbox = NULL)
SpatialMultiPointsDataFrame(coords, data,
      proj4string = CRS(as.character(NA)), match.ID, bbox = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialMultiPoints_+3A_coords">coords</code></td>
<td>
<p>list with in each element a numeric matrix or data.frame with coordinates 
(each row representing a point); in case of SpatialMultiPointsDataFrame an object
of class <a href="sp.html#topic+SpatialMultiPoints-class">SpatialMultiPoints-class</a> is also allowed</p>
</td></tr>
<tr><td><code id="SpatialMultiPoints_+3A_proj4string">proj4string</code></td>
<td>
<p> projection string of class <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</td></tr>
<tr><td><code id="SpatialMultiPoints_+3A_bbox">bbox</code></td>
<td>
<p>bounding box matrix, usually NULL and constructed from the data, but may be passed through for coercion purposes if clearly needed</p>
</td></tr>
<tr><td><code id="SpatialMultiPoints_+3A_data">data</code></td>
<td>
<p> object of class <code>data.frame</code>; the number of rows in <code>data</code> 
should equal the number of points in the <code>coords</code> object</p>
</td></tr>
<tr><td><code id="SpatialMultiPoints_+3A_match.id">match.ID</code></td>
<td>
<p> logical or character; if missing, and <code>coords</code> and <code>data</code> both have
row names, and their order does not correspond, matching is done by these
row names and a warning is issued; this warning can be suppressed by setting
<code>match.ID</code> to TRUE.
If TRUE AND coords has non-automatic 
rownames (i.e., coerced to a matrix by <code>as.matrix</code>,
<code>dimnames(coords)[[1]]</code> is not <code>NULL</code>), AND <code>data</code> has
row.names (i.e. is a data.frame), then the <code>SpatialMultiPointsDataFrame</code>
object is formed by matching the row names of both components, leaving
the order of the coordinates in tact. Checks are done to see whether
both row names are sufficiently unique, and all data are matched.
If FALSE, coordinates and data are simply &quot;glued&quot; together, ignoring row names. If
character: indicates the column in <code>data</code> with coordinates IDs
to use for matching records. See examples below.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatialMultiPoints</code> returns an object of class <code>SpatialMultiPoints</code>;
<code>SpatialMultiPointsDataFrame</code> returns an object of class <code>SpatialMultiPointsDataFrame</code>;
</p>


<h3>See Also</h3>

 <p><a href="raster.html#topic+coordinates">coordinates</a>, <a href="sp.html#topic+SpatialMultiPoints-class">SpatialMultiPoints-class</a>,
<a href="sp.html#topic+SpatialMultiPointsDataFrame-class">SpatialMultiPointsDataFrame-class</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>cl1 = cbind(rnorm(3, 10), rnorm(3, 10))
cl2 = cbind(rnorm(5, 10), rnorm(5,  0))
cl3 = cbind(rnorm(7,  0), rnorm(7, 10))

mp = SpatialMultiPoints(list(cl1, cl2, cl3))
mpx = rbind(mp, mp) # rbind method
plot(mp, col = 2, cex = 1, pch = 1:3)
mp
mp[1:2]

print(mp, asWKT=TRUE, digits=3)

mpdf = SpatialMultiPointsDataFrame(list(cl1, cl2, cl3), data.frame(a = 1:3))
mpdf
mpdfx = rbind(mpdf, mpdf) # rbind method

plot(mpdf, col = mpdf$a, cex = 1:3)
as(mpdf, "data.frame")
mpdf[1:2,]
</code></pre>

<hr>
<h2 id='SpatialMultiPoints-class'>Class &quot;SpatialMultiPoints&quot; </h2><span id='topic+SpatialMultiPoints-class'></span><span id='topic++5B+2CSpatialMultiPoints-method'></span><span id='topic+coerce+2CSpatialMultiPoints+2Cmatrix-method'></span><span id='topic+coerce+2CSpatialMultiPoints+2Cdata.frame-method'></span><span id='topic+coerce+2CSpatialMultiPoints+2CSpatialPoints-method'></span><span id='topic+show+2CSpatialMultiPoints-method'></span><span id='topic+as.data.frame.SpatialMultiPoints'></span><span id='topic+plot+2CSpatialMultiPoints+2Cmissing-method'></span><span id='topic+summary+2CSpatialMultiPoints-method'></span><span id='topic+print.SpatialMultiPoints'></span><span id='topic+summary.SpatialMultiPoints'></span><span id='topic+rbind.SpatialMultiPoints'></span><span id='topic++24+2CSpatialMultiPoints-method'></span><span id='topic++24+3C-+2CSpatialMultiPoints+2Ccharacter-method'></span><span id='topic+row.names.SpatialMultiPoints'></span>

<h3>Description</h3>

<p>  Class for (irregularly spaced) MultiPoints </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>SpatialPoints(x)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coords</code>:</dt><dd><p>Object of class <code>"list"</code>, containing the
coordinates of point sets (each list element is a matrix) </p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>, with bounding box </p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>, projection string </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Spatial"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "SpatialMultiPoints")</code>: subsets point sets</p>
</dd> 
<dt>coerce</dt><dd><p><code>signature(from = "SpatialPoints", to = "data.frame")</code>: 
coerce to data.frame</p>
</dd>
<dt>coordinates</dt><dd><p><code>signature(obj = "SpatialMultiPoints")</code>: retrieves
all the coordinates, as one single matrix </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SpatialPoints", y = "missing")</code>: plot points</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SpatialPoints")</code>: summarize object</p>
</dd>
<dt>points</dt><dd><p><code>signature(x = "SpatialPoints")</code>: add point symbols to plot</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SpatialPoints")</code>: prints coordinates </p>
</dd>
<dt>rbind</dt><dd><p><code>signature(object = "SpatialPoints")</code>: rbind-like method </p>
</dd>  </dl>



<h3>plot method arguments</h3>

<p>The plot method for &ldquo;SpatialPoints&rdquo; objects takes the following arguments:
</p>

<dl>
<dt>x</dt><dd><p>object of class SpatialPoints</p>
</dd>
<dt>pch</dt><dd><p>default 3; either an integer specifying a symbol or a single character to be used as the default in plotting points</p>
</dd>
<dt>axes</dt><dd><p>default FALSE; a logical value indicating whether both axes should be drawn </p>
</dd>
<dt>add</dt><dd><p>default FALSE; add to existing plot</p>
</dd>
<dt>xlim</dt><dd><p>default NULL; the x limits (x1, x2) of the plot</p>
</dd>
<dt>ylim</dt><dd><p>default NULL; the y limits of the plot</p>
</dd>
<dt>...</dt><dd><p>passed through</p>
</dd>
<dt>setParUsrBB</dt><dd><p>default FALSE; set the <code>par</code> &ldquo;usr&rdquo; bounding box, see note in <a href="sp.html#topic+Spatial-class">Spatial-class</a></p>
</dd>
<dt>cex</dt><dd><p>default 1; numerical value giving the amount by which plotting text and symbols should be magnified relative to the default</p>
</dd>
<dt>col</dt><dd><p>default 1; default plotting color</p>
</dd>
<dt>lwd</dt><dd><p>default 1; line width</p>
</dd>
<dt>bg</dt><dd><p>default 1; colour to be used for the background of the device region</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+SpatialMultiPointsDataFrame-class">SpatialMultiPointsDataFrame-class</a></code>
<code><a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl1 = cbind(rnorm(3, 10), rnorm(3, 10))
cl2 = cbind(rnorm(5, 10), rnorm(5,  0))
cl3 = cbind(rnorm(7,  0), rnorm(7, 10))

mp = SpatialMultiPoints(list(cl1, cl2, cl3))
plot(mp, col = 2, cex = 1, pch = 1:3)
mp
mp[1:2]

print(mp, asWKT=TRUE, digits=3)
</code></pre>

<hr>
<h2 id='SpatialMultiPointsDataFrame-class'>Class &quot;SpatialMultiPointsDataFrame&quot; </h2><span id='topic+SpatialMultiPointsDataFrame-class'></span><span id='topic++5B+2CSpatialMultiPointsDataFrame-method'></span><span id='topic+coerce+2CSpatialMultiPointsDataFrame+2Cdata.frame-method'></span><span id='topic+coerce+2CSpatialMultiPointsDataFrame+2CSpatialPointsDataFrame-method'></span><span id='topic+show+2CSpatialMultiPointsDataFrame-method'></span><span id='topic+points+2CSpatialMultiPointsDataFrame-method'></span><span id='topic+coordinates+2CSpatialMultiPointsDataFrame-method'></span><span id='topic+as.data.frame.SpatialMultiPointsDataFrame'></span><span id='topic+dim.SpatialMultiPointsDataFrame'></span><span id='topic+print.SpatialMultiPointsDataFrame'></span><span id='topic+rbind.SpatialMultiPointsDataFrame'></span><span id='topic+row.names.SpatialMultiPointsDataFrame'></span>

<h3>Description</h3>

<p> Class for spatial attributes that correspond to point sets </p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'SpatialMultiPointsDataFrame'
x[i, j, ..., drop = TRUE]
  ## S4 method for signature 'SpatialMultiPointsDataFrame,data.frame'
coerce(from, to, strict=TRUE)
  ## S4 method for signature 'SpatialMultiPointsDataFrame'
coordinates(obj)
  ## S4 method for signature 'SpatialMultiPointsDataFrame'
show(object)
  ## S4 method for signature 'SpatialMultiPointsDataFrame'
points(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialMultiPointsDataFrame-class_+3A_x">x</code>, <code id="SpatialMultiPointsDataFrame-class_+3A_from">from</code>, <code id="SpatialMultiPointsDataFrame-class_+3A_obj">obj</code>, <code id="SpatialMultiPointsDataFrame-class_+3A_object">object</code></td>
<td>
<p><code>SpatialMultiPointsDataFrame</code> object</p>
</td></tr>
<tr><td><code id="SpatialMultiPointsDataFrame-class_+3A_to">to</code></td>
<td>
<p>class to which to coerce</p>
</td></tr>
<tr><td><code id="SpatialMultiPointsDataFrame-class_+3A_strict">strict</code></td>
<td>
<p>see <code><a href="methods.html#topic+as">as</a></code></p>
</td></tr>
<tr><td><code id="SpatialMultiPointsDataFrame-class_+3A_i">i</code></td>
<td>
<p>row indices</p>
</td></tr>
<tr><td><code id="SpatialMultiPointsDataFrame-class_+3A_j">j</code></td>
<td>
<p>column indices</p>
</td></tr>
<tr><td><code id="SpatialMultiPointsDataFrame-class_+3A_drop">drop</code></td>
<td>
<p>see <code><a href="base.html#topic+Extract">Extract</a></code></p>
</td></tr>
<tr><td><code id="SpatialMultiPointsDataFrame-class_+3A_...">...</code></td>
<td>
<p>indices passed through</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class data.frame containing
the attribute data (may or may not contain the coordinates in its columns) </p>
</dd>
<dt><code>coords</code>:</dt><dd><p>Object of class <code>"list"</code>; the list with coordinates matrices;
points are rows in the matrix, the list length equals the number of rows in the <code>data</code> slot </p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; bounding box</p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; projection string</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"SpatialMultiPoints"</code>, directly.
Class <code>"Spatial"</code>, by class <code>"SpatialMultiPoints"</code>.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+coordinates">coordinates</a></code>, <code><a href="sp.html#topic+SpatialMultiPoints-class">SpatialMultiPoints-class</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create three sets of points:
cl1 = cbind(rnorm(3, 10), rnorm(3, 10))
cl2 = cbind(rnorm(5, 10), rnorm(5,  0))
cl3 = cbind(rnorm(7,  0), rnorm(7, 10))

mpdf = SpatialMultiPointsDataFrame(list(cl1, cl2, cl3), data.frame(a = 1:3))
mpdf

plot(mpdf, col = mpdf$a, cex = 1:3)
as(mpdf, "data.frame")
mpdf[1:2,]

</code></pre>

<hr>
<h2 id='SpatialPixels'> define spatial grid </h2><span id='topic+SpatialPixels'></span><span id='topic+SpatialGrid'></span><span id='topic+GridTopology'></span><span id='topic+SpatialGrid'></span><span id='topic+plot.SpatialGrid'></span><span id='topic+coordinatevalues'></span><span id='topic+points2grid'></span><span id='topic+getGridIndex'></span><span id='topic+getGridTopology'></span><span id='topic+areaSpatialGrid'></span>

<h3>Description</h3>

<p>defines spatial grid by offset, cell size and dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GridTopology(cellcentre.offset, cellsize, cells.dim)
SpatialPixels(points, tolerance = sqrt(.Machine$double.eps),
		proj4string = CRS(as.character(NA)), round = NULL, grid = NULL)
SpatialGrid(grid, proj4string = CRS(as.character(NA)))
coordinatevalues(obj)
points2grid(points, tolerance = sqrt(.Machine$double.eps), round=NULL)
getGridIndex(cc, grid, all.inside = TRUE)
getGridTopology(obj)
areaSpatialGrid(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialPixels_+3A_cellcentre.offset">cellcentre.offset</code></td>
<td>
<p>numeric; vector with the smallest centroid coordinates for
each dimension; coordinates refer to the cell centre</p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_cellsize">cellsize</code></td>
<td>
<p>numeric; vector with the cell size in each dimension</p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_cells.dim">cells.dim</code></td>
<td>
<p>integer; vector with number of cells in each dimension</p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_points">points</code></td>
<td>
<p> coordinates, object of class <a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a> </p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_grid">grid</code></td>
<td>
<p> grid topology; object of class <a href="sp.html#topic+GridTopology-class">GridTopology-class</a>;
for calls to <code>SpatialPixels</code>, a value of NULL implies that this will 
be derived from the point coordinates </p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_tolerance">tolerance</code></td>
<td>
<p> precision, used to which extent points are exactly on
a grid</p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_round">round</code></td>
<td>
<p>default NULL, otherwise a value passed to as the digits argument to <code>round</code> for setting cell size</p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_proj4string">proj4string</code></td>
<td>
<p> object of class <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_obj">obj</code></td>
<td>
<p>object of class or deriving from <a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a></p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_cc">cc</code></td>
<td>
<p> numeric matrix with coordinates </p>
</td></tr>
<tr><td><code id="SpatialPixels_+3A_all.inside">all.inside</code></td>
<td>
<p> logical; if TRUE and <code>cc</code> points fall outside
the grid area, an error message is generated; if FALSE, NA values
are generated for such points </p>
</td></tr>
</table>


<h3>Value</h3>

<p> GridTopology returns a value of class <a href="sp.html#topic+GridTopology-class">GridTopology-class</a>;
SpatialGrid returns an object of class <a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a>
</p>
<p><code>coordinatevalues</code> returns a list with the unique x-coordinates,
the unique y-coordinate, etc. instead of the <a href="raster.html#topic+coordinates">coordinates</a> of all
grid cells
</p>
<p>SpatialGrid returns an object of class <a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a>. 
</p>
<p>points2grid returns the <a href="sp.html#topic+GridTopology-class">GridTopology-class</a> from a set of points.
</p>
<p>getGridIndex finds the index of a set of point coordinates in a given
grid topology, and depending on <code>all.inside</code> setting, generates NA
or an error message if points are outside the grid domain.
</p>
<p>getGridTopology returns the slot of class <a href="sp.html#topic+GridTopology-class">GridTopology-class</a> from
obj.
</p>
<p>areaSpatialGrid returns the spatial area of (the non-missing valued cells
of) the grid. For objects of class <a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a>
the area refers to cells where any (one or more) of the attribute columns
are non-missing valued.
</p>


<h3>Note</h3>

 
<p>SpatialGrid stores grid topology and may or may not store the coordinates
of the actual points, which may form a subset of the full grid. To find
out or change this, see <a href="sp.html#topic+fullgrid">fullgrid</a>.
</p>
<p>points2grid tries to figure out the grid topology from points. It succeeds
only if points on a grid line have constant y column, and points on a
grid column have constant x coordinate, etc. In other cases, use signif
on the raw coordinate matrices to make sure this is the case.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a></p>


<h3>See Also</h3>

 
<p><a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a>,
<a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = GridTopology(c(0,0), c(1,1), c(5,4))
class(x)
x
summary(x)
coordinates(x)
coordinates(GridTopology(c(0,0), c(1,1), c(5,4)))
coordinatevalues(x)
data(meuse.grid)
coordinates(meuse.grid) &lt;- c("x", "y")
points2grid(meuse.grid)
data(meuse.grid)
set.seed(1)
meuse.grid$x &lt;- meuse.grid$x + rnorm(length(meuse.grid$x), 0, 0.002)
meuse.grid$y &lt;- meuse.grid$y + rnorm(length(meuse.grid$y), 0, 0.002)
coordinates(meuse.grid) &lt;- c("x", "y")
#EJP
# points2grid(meuse.grid, tolerance=0.76, round=1)
data(meuse.grid)
a &lt;- which(meuse.grid$x == 180140)
b &lt;- which(meuse.grid$x == 180180)
c &lt;- which(meuse.grid$x == 179260)
d &lt;- which(meuse.grid$y == 332460)
e &lt;- which(meuse.grid$y == 332420)
f &lt;- which(meuse.grid$y == 330740)
meuse.grid &lt;- meuse.grid[-c(a, b, c, d, e, f),]
coordinates(meuse.grid) &lt;- c("x", "y")
points2grid(meuse.grid)
data(meuse.grid)
set.seed(1)
meuse.grid$x &lt;- meuse.grid$x + rnorm(length(meuse.grid$x), 0, 0.002)
meuse.grid$y &lt;- meuse.grid$y + rnorm(length(meuse.grid$y), 0, 0.002)
meuse.grid &lt;- meuse.grid[-c(a, b, c, d, e, f),]
coordinates(meuse.grid) &lt;- c("x", "y")
# EJP
# points2grid(meuse.grid, tolerance=0.69, round=1)
</code></pre>

<hr>
<h2 id='SpatialPixels-class'>Class &quot;SpatialPixels&quot; </h2><span id='topic+SpatialPixels-class'></span><span id='topic++5B+2CSpatialPixels-method'></span><span id='topic+coerce+2CSpatialPixels+2CSpatialGrid-method'></span><span id='topic+print.summary.SpatialPixels'></span><span id='topic+as.data.frame.SpatialPixels'></span><span id='topic+summary+2CSpatialPixels-method'></span><span id='topic+coerce+2CSpatialPixels+2Cdata.frame-method'></span><span id='topic+show+2CSpatialPixels-method'></span><span id='topic+plot+2CSpatialPixels+2Cmissing-method'></span><span id='topic+rbind.SpatialPixels'></span>

<h3>Description</h3>

<p> class for defining a pixels, forming a
possibly incomplete rectangular grid of arbitrary dimension </p>


<h3>Objects from the Class</h3>

<p>Objects are created by using e.g. 
</p>
<p>SpatialPixels(points)
</p>
<p>with points of class <a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>grid</code></dt><dd><p> object of class <a href="sp.html#topic+GridTopology-class">GridTopology-class</a>, defining the
grid topology (offset, cellsize, dim) </p>
</dd>
<dt><code>grid.index</code></dt><dd><p>integer; index of points in full grid</p>
</dd>
<dt><code>coords</code></dt><dd><p> coordinates of points, or bbox of grid </p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; bounding box </p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; projection  </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"SpatialPoints"</code> directly;
Class <code>"Spatial"</code>, by class <code>"SpatialPoints"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>coordinates</dt><dd><p><code>signature(x = "SpatialPixels")</code>: calculates coordinates for
each point on the grid; coordinates are not stored in objects of class SpatialGrid</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SpatialPixels")</code>: summarize object</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SpatialPixels")</code>: plots cell centers </p>
</dd>
<dt>&quot;[&quot;</dt><dd><p><code>signature(x = "SpatialPixels")</code>: select pixel cells; the argument
<code>drop=FALSE</code> (default) does not recalculate grid topology for the selection, if
<code>drop=TRUE</code> the grid topology is recomputed, and might change. </p>
</dd>
<dt>rbind</dt><dd><p><code>signature(x = "SpatialPixels")</code>: rbind-like method</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+SpatialPixelsDataFrame-class">SpatialPixelsDataFrame-class</a></code>, <code><a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid)
pts = meuse.grid[c("x", "y")]
y = SpatialPixels(SpatialPoints(pts))
class(y)
y
summary(y)
plot(y) # plots grid
plot(y, grid = FALSE) # plots points
</code></pre>

<hr>
<h2 id='SpatialPixelsDataFrame'> define spatial grid with attribute data </h2><span id='topic+SpatialPixelsDataFrame'></span><span id='topic+SpatialGridDataFrame'></span>

<h3>Description</h3>

<p> defines spatial grid by offset, cell size and dimensions </p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatialPixelsDataFrame(points, data, tolerance = sqrt(.Machine$double.eps), 
		proj4string = CRS(as.character(NA)), round = NULL, grid = NULL)
SpatialGridDataFrame(grid, data, proj4string = CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialPixelsDataFrame_+3A_points">points</code></td>
<td>
<p> coordinates, either as numeric matrix or as object of class
<a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a> </p>
</td></tr>
<tr><td><code id="SpatialPixelsDataFrame_+3A_grid">grid</code></td>
<td>
<p> grid topology; object of class <a href="sp.html#topic+GridTopology-class">GridTopology-class</a>; for
calls to <code>SpatialPixelsDataFrame</code> a value of NULL implies that this will 
be derived from the point coordinates </p>
</td></tr>
<tr><td><code id="SpatialPixelsDataFrame_+3A_data">data</code></td>
<td>
<p> data.frame; contains the attribute (actual grid) data </p>
</td></tr>
<tr><td><code id="SpatialPixelsDataFrame_+3A_tolerance">tolerance</code></td>
<td>
<p> precision up to which extent points should be 
exactly on a grid </p>
</td></tr>
<tr><td><code id="SpatialPixelsDataFrame_+3A_round">round</code></td>
<td>
<p>default NULL, otherwise a value passed to as the digits argument to <code>round</code> for setting cell size</p>
</td></tr>
<tr><td><code id="SpatialPixelsDataFrame_+3A_proj4string">proj4string</code></td>
<td>
<p>object of class <a href="sp.html#topic+CRS-class">CRS-class</a> in the first
form only used when <code>points</code> does not inherit from <a href="sp.html#topic+Spatial-class">Spatial-class</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p> SpatialPixelsDataFrame returns an object of class
<a href="sp.html#topic+SpatialPixelsDataFrame-class">SpatialPixelsDataFrame-class</a>; SpatialGridDataFrame returns an object
of class <a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a>. 
</p>


<h3>Note</h3>

 
<p>SpatialPixels stores grid topology and coordinates of the actual points,
which may be in the form of a subset (set of pixels) of a full grid. To
find out or change this, see <a href="sp.html#topic+fullgrid">fullgrid</a> and <a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a>.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>See Also</h3>

 
<p><a href="sp.html#topic+gridded">gridded</a>,
<a href="sp.html#topic+gridded+3C-">gridded&lt;-</a>,
<a href="sp.html#topic+SpatialGrid">SpatialGrid</a>,
<a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid)
m = SpatialPixelsDataFrame(points = meuse.grid[c("x", "y")], data = meuse.grid)
class(m)
summary(m)
</code></pre>

<hr>
<h2 id='SpatialPixelsDataFrame-class'>Class &quot;SpatialPixelsDataFrame&quot; </h2><span id='topic+SpatialPixelsDataFrame-class'></span><span id='topic++5B+2CSpatialPixelsDataFrame-method'></span><span id='topic+show+2CSpatialPixelsDataFrame-method'></span><span id='topic+plot.SpatialPixelsDataFrame'></span><span id='topic+print.summary.SpatialPixelsDataFrame'></span><span id='topic+coerce+2CSpatialPixelsDataFrame+2CSpatialPointsDataFrame-method'></span><span id='topic+coerce+2CSpatialPixelsDataFrame+2CSpatialGridDataFrame-method'></span><span id='topic+coerce+2CSpatialPixelsDataFrame+2CSpatialPolygonsDataFrame-method'></span><span id='topic+coerce+2CSpatialPixelsDataFrame+2Cdata.frame-method'></span><span id='topic+coerce+2CSpatialPixelsDataFrame+2Cmatrix-method'></span><span id='topic+coerce+2CSpatialPixelsDataFrame+2Carray-method'></span><span id='topic+as.data.frame.SpatialPixelsDataFrame'></span><span id='topic+rbind.SpatialPixelsDataFrame'></span><span id='topic+dim.SpatialPixelsDataFrame'></span><span id='topic+plot+2CSpatialPixelsDataFrame+2Cmissing-method'></span>

<h3>Description</h3>

<p>  Class for spatial attributes that have spatial locations
on a regular grid. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>as(x,
"SpatialPixelsDataFrame")</code>, where <code>x</code> is of class
<a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a>, or by importing through rgdal.  
Ordered full grids are stored instead or unordered non-NA cells; 
</p>


<h3>Slots</h3>


<dl>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; bounding box </p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; projection </p>
</dd>
<dt><code>coords</code>:</dt><dd><p>see <a href="sp.html#topic+SpatialPoints">SpatialPoints</a>; points slot </p>
</dd>
<dt><code>coords.nrs</code></dt><dd><p>see <a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></p>
</dd>
<dt><code>grid</code>:</dt><dd><p>see <a href="sp.html#topic+GridTopology-class">GridTopology-class</a>; grid parameters </p>
</dd>
<dt><code>grid.index</code>:</dt><dd><p>integer; index of points in the list to points
in the full (ordered) grid. x cycles fastest; all coordinates increase
from low to hight except y, which decreases from high to low </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class data.frame, containing the attribute data </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"SpatialPixels"</code>, directly.
Class <code>"Spatial"</code>, by class <code>"SpatialPixels"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>coordinates</dt><dd><p><code>signature(x = "SpatialPixelsDataFrame")</code>: retrieves coordinates </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "SpatialPixelsDataFrame")</code>: selects row(s) and/or attribute(s), and returns an
object of class <code>SpatialPixelsDataFrame</code>; rows refer here to the pixel
numbers, not grid lines. For selecting a square block in a grid, coerce to
a <a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a> first, and use <code>[</code> on that object</p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "SpatialPixelsDataFrame")</code>: coerce to matrix </p>
</dd>
<dt>rbind</dt><dd><p><code>signature(x = "SpatialPixelsDataFrame")</code>: rbind-like method </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SpatialPixelsDataFrame", y = "missing")</code>: see
<a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a> for details</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+SpatialPixels-class">SpatialPixels-class</a></code>, which does not contain the attribute data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid) # only the non-missing valued cells
coordinates(meuse.grid) = c("x", "y") # promote to SpatialPointsDataFrame
gridded(meuse.grid) &lt;- TRUE # promote to SpatialPixelsDataFrame
meuse.grid[["idist"]] = 1 - meuse.grid[["dist"]] # assigns new attribute
image(meuse.grid["idist"]) # note the single [

# toy example:
df = data.frame(z = c(1:6,NA,8,9),
    xc = c(1,1,1,2,2,2,3,3,3),
    yc = c(rep(c(0, 1.5, 3),3)))
coordinates(df) = ~xc+yc
gridded(df) = TRUE
image(df["z"])
# draw labels to verify:
cc = coordinates(df)
z=df[["z"]]
zc=as.character(z)
zc[is.na(zc)]="NA"
text(cc[,1],cc[,2],zc)

</code></pre>

<hr>
<h2 id='SpatialPoints'> create objects of class SpatialPoints or SpatialPointsDataFrame</h2><span id='topic+SpatialPoints'></span><span id='topic+SpatialPointsDataFrame'></span>

<h3>Description</h3>

<p> create objects of class <a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a> or 
<a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a> from
coordinates, and from coordinates and <code>data.frame</code>s</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
SpatialPoints(coords, proj4string=CRS(as.character(NA)), bbox = NULL)
SpatialPointsDataFrame(coords, data, coords.nrs = numeric(0), 
      proj4string = CRS(as.character(NA)), match.ID, bbox = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialPoints_+3A_coords">coords</code></td>
<td>
<p>numeric matrix or data.frame with coordinates 
(each row is a point); in case of SpatialPointsDataFrame an object
of class <a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a> is also allowed</p>
</td></tr>
<tr><td><code id="SpatialPoints_+3A_proj4string">proj4string</code></td>
<td>
<p> projection string of class <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</td></tr>
<tr><td><code id="SpatialPoints_+3A_bbox">bbox</code></td>
<td>
<p>bounding box matrix, usually NULL and constructed from the data, but may be passed through for coercion purposes if clearly needed</p>
</td></tr>
<tr><td><code id="SpatialPoints_+3A_data">data</code></td>
<td>
<p> object of class <code>data.frame</code>; the number of rows in <code>data</code> 
should equal the number of points in the <code>coords</code> object</p>
</td></tr>
<tr><td><code id="SpatialPoints_+3A_coords.nrs">coords.nrs</code></td>
<td>
<p>numeric; if present, records the column positions where
in <code>data</code> the coordinates were taken from (used by <a href="sp.html#topic+coordinates+3C-">coordinates&lt;-</a>)</p>
</td></tr>
<tr><td><code id="SpatialPoints_+3A_match.id">match.ID</code></td>
<td>
<p> logical or character; if missing, and <code>coords</code> and <code>data</code> both have
row names, and their order does not correspond, matching is done by these
row names and a warning is issued; this warning can be suppressed by setting
<code>match.ID</code> to TRUE.
If TRUE AND coords has non-automatic 
rownames (i.e., coerced to a matrix by <code>as.matrix</code>,
<code>dimnames(coords)[[1]]</code> is not <code>NULL</code>), AND <code>data</code> has
row.names (i.e. is a data.frame), then the <code>SpatialPointsDataFrame</code>
object is formed by matching the row names of both components, leaving
the order of the coordinates in tact. Checks are done to see whether
both row names are sufficiently unique, and all data are matched.
If FALSE, coordinates and data are simply &quot;glued&quot; together, ignoring row names. If
character: indicates the column in <code>data</code> with coordinates IDs
to use for matching records. See examples below.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatialPoints</code> returns an object of class <code>SpatialPoints</code>;
<code>SpatialPointsDataFrame</code> returns an object of class <code>SpatialPointsDataFrame</code>;
</p>


<h3>See Also</h3>

 <p><a href="raster.html#topic+coordinates">coordinates</a>, <a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a>,
<a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1331)
pts = cbind(1:5, 1:5)
dimnames(pts)[[1]] = letters[1:5]
df = data.frame(a = 1:5)
row.names(df) = letters[5:1]

library(sp)
options(warn=1) # show warnings where they occur
SpatialPointsDataFrame(pts, df) # warn
SpatialPointsDataFrame(pts, df, match.ID = TRUE) # don't warn
SpatialPointsDataFrame(pts, df, match.ID = FALSE) # don't warn
df$m = letters[5:1]
SpatialPointsDataFrame(pts, df, match.ID = "m") # don't warn

dimnames(pts)[[1]] = letters[5:1]
SpatialPointsDataFrame(pts, df) # don't warn: ID matching doesn't reorder
</code></pre>

<hr>
<h2 id='SpatialPoints-class'>Class &quot;SpatialPoints&quot; </h2><span id='topic+SpatialPoints-class'></span><span id='topic++5B+2CSpatialPoints-method'></span><span id='topic+coerce+2CSpatialPoints+2Cmatrix-method'></span><span id='topic+coerce+2CSpatialPoints+2Cdata.frame-method'></span><span id='topic+coerce+2CSpatialPoints+2CSpatialPixels-method'></span><span id='topic+coerce+2CSpatialPoints+2CLine-method'></span><span id='topic+coerce+2CSpatialPoints+2CLines-method'></span><span id='topic+coerce+2CSpatialPoints+2CSpatialLines-method'></span><span id='topic+coerce+2CSpatialPointsDataFrame+2CSpatialPixelsDataFrame-method'></span><span id='topic+show+2CSpatialPoints-method'></span><span id='topic+as.data.frame.SpatialPoints'></span><span id='topic+plot+2CSpatialPoints+2Cmissing-method'></span><span id='topic+summary+2CSpatialPoints-method'></span><span id='topic+print.SpatialPoints'></span><span id='topic+summary.SpatialPoints'></span><span id='topic+rbind.SpatialPoints'></span><span id='topic++24+2CSpatialPoints-method'></span><span id='topic++24+3C-+2CSpatialPoints+2Ccharacter-method'></span><span id='topic+row.names.SpatialPoints'></span><span id='topic+coerce+2Cppp+2CSpatialPoints-method'></span>

<h3>Description</h3>

<p>  Class for (irregularly spaced) points </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>SpatialPoints(x)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coords</code>:</dt><dd><p>Object of class <code>"matrix"</code>, containing the
coordinates (each row is a point) </p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>, with bounding box </p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>, projection string </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Spatial"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "SpatialPoints")</code>: subsets the points; only
rows (points) can be subsetted </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialPoints", to = "data.frame")</code>: 
retrieves the data part</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialPoints", to = "SpatialPixels")</code>: equivalent to assigning gridded TRUE for a copy of the object</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialPointsDataFrame", to = "SpatialPixelsDataFrame")</code>: equivalent to assigning gridded TRUE for a copy of the object</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "data.frame", to = "SpatialPoints")</code>: sets
coordinates, which may be in a data frame </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "SpatialPoints")</code>: set
coordinates, which may be in a matrix </p>
</dd>
<dt>coordinates</dt><dd><p><code>signature(obj = "SpatialPoints")</code>: retrieves
the coordinates, as matrix </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SpatialPoints", y = "missing")</code>: plot points</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SpatialPoints")</code>: summarize object</p>
</dd>
<dt>points</dt><dd><p><code>signature(x = "SpatialPoints")</code>: add point symbols to plot</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SpatialPoints")</code>: prints coordinates </p>
</dd>
<dt>rbind</dt><dd><p><code>signature(object = "SpatialPoints")</code>: rbind-like method </p>
</dd>  </dl>



<h3>plot method arguments</h3>

<p>The plot method for &ldquo;SpatialPoints&rdquo; objects takes the following arguments:
</p>

<dl>
<dt>x</dt><dd><p>object of class SpatialPoints</p>
</dd>
<dt>pch</dt><dd><p>default 3; either an integer specifying a symbol or a single character to be used as the default in plotting points</p>
</dd>
<dt>axes</dt><dd><p>default FALSE; a logical value indicating whether both axes should be drawn </p>
</dd>
<dt>add</dt><dd><p>default FALSE; add to existing plot</p>
</dd>
<dt>xlim</dt><dd><p>default NULL; the x limits (x1, x2) of the plot</p>
</dd>
<dt>ylim</dt><dd><p>default NULL; the y limits of the plot</p>
</dd>
<dt>...</dt><dd><p>passed through</p>
</dd>
<dt>setParUsrBB</dt><dd><p>default FALSE; set the <code>par</code> &ldquo;usr&rdquo; bounding box, see note in <a href="sp.html#topic+Spatial-class">Spatial-class</a></p>
</dd>
<dt>cex</dt><dd><p>default 1; numerical value giving the amount by which plotting text and symbols should be magnified relative to the default</p>
</dd>
<dt>col</dt><dd><p>default 1; default plotting color</p>
</dd>
<dt>lwd</dt><dd><p>default 1; line width</p>
</dd>
<dt>bg</dt><dd><p>default 1; colour to be used for the background of the device region</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(1,2,3,4,5)
y = c(3,2,5,1,4)
S &lt;- SpatialPoints(cbind(x,y))
S &lt;- SpatialPoints(list(x,y))
S &lt;- SpatialPoints(data.frame(x,y))
S
plot(S)
</code></pre>

<hr>
<h2 id='SpatialPointsDataFrame-class'>Class &quot;SpatialPointsDataFrame&quot; </h2><span id='topic+SpatialPointsDataFrame-class'></span><span id='topic++5B+2CSpatialPointsDataFrame-method'></span><span id='topic+coerce+2CSpatialPointsDataFrame+2Cdata.frame-method'></span><span id='topic+coerce+2CSpatialPointsDataFrame+2CSpatialPoints-method'></span><span id='topic+show+2CSpatialPointsDataFrame-method'></span><span id='topic+points+2CSpatialPointsDataFrame-method'></span><span id='topic+coordinates+2CSpatialPointsDataFrame-method'></span><span id='topic+as.data.frame.SpatialPointsDataFrame'></span><span id='topic+dim.SpatialPointsDataFrame'></span><span id='topic+print.SpatialPointsDataFrame'></span><span id='topic+ShowSpatialPointsDataFrame'></span><span id='topic+as.SpatialPoints.SpatialPointsDataFrame'></span><span id='topic+rbind.SpatialPointsDataFrame'></span><span id='topic+row.names.SpatialPointsDataFrame'></span><span id='topic+coerce+2Cppp+2CSpatialPointsDataFrame-method'></span>

<h3>Description</h3>

<p> Class for spatial attributes that have spatial point locations </p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'SpatialPointsDataFrame'
x[i, j, ..., drop = TRUE]
  ## S4 method for signature 'SpatialPointsDataFrame,SpatialPoints'
coerce(from, to, strict=TRUE)
  ## S4 method for signature 'SpatialPointsDataFrame,data.frame'
coerce(from, to, strict=TRUE)
  ## S4 method for signature 'SpatialPointsDataFrame'
coordinates(obj)
  ## S4 method for signature 'SpatialPointsDataFrame'
show(object)
  ## S4 method for signature 'SpatialPointsDataFrame'
points(x)
  ## S3 method for class 'SpatialPointsDataFrame'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialPointsDataFrame-class_+3A_x">x</code>, <code id="SpatialPointsDataFrame-class_+3A_from">from</code>, <code id="SpatialPointsDataFrame-class_+3A_obj">obj</code>, <code id="SpatialPointsDataFrame-class_+3A_object">object</code></td>
<td>
<p><code>SpatialPointsDataFrame</code> object</p>
</td></tr>
<tr><td><code id="SpatialPointsDataFrame-class_+3A_to">to</code></td>
<td>
<p>class to which to coerce</p>
</td></tr>
<tr><td><code id="SpatialPointsDataFrame-class_+3A_strict">strict</code></td>
<td>
<p>see <code><a href="methods.html#topic+as">as</a></code></p>
</td></tr>
<tr><td><code id="SpatialPointsDataFrame-class_+3A_i">i</code></td>
<td>
<p>row indices</p>
</td></tr>
<tr><td><code id="SpatialPointsDataFrame-class_+3A_j">j</code></td>
<td>
<p>column indices</p>
</td></tr>
<tr><td><code id="SpatialPointsDataFrame-class_+3A_drop">drop</code></td>
<td>
<p>see <code><a href="base.html#topic+Extract">Extract</a></code></p>
</td></tr>
<tr><td><code id="SpatialPointsDataFrame-class_+3A_...">...</code></td>
<td>
<p>indices passed through</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>coordinates(x) = c("x", "y") </code>.
or of the form <code>coordinates(x) = xy</code>; see <a href="raster.html#topic+coordinates">coordinates</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class data.frame containing
the attribute data (may or may not contain the coordinates in its columns) </p>
</dd>
<dt><code>coords</code>:</dt><dd><p>Object of class <code>"matrix"</code>; the coordinates matrix
(points are rows in the matrix) </p>
</dd>
<dt><code>coords.nrs</code></dt><dd><p>Object of class logical; if TRUE, when
the object was created the coordinates were retrieved from the data.frame,
and hence stripped from it; after coercion to data.frame, e.g. by 
as.data.frame(x), coordinates will again be added (as first few columns) 
to the data.frame </p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; bounding box</p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; projection string</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"SpatialPoints"</code>, directly.
Class <code>"Spatial"</code>, by class <code>"SpatialPoints"</code>.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+coordinates">coordinates</a></code>, <code><a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
xy = meuse[c("x", "y")] # retrieve coordinates as data.frame
class(meuse)
data(meuse) # reload data.frame
coordinates(meuse) = c("x", "y") # specify column names
class(meuse)
data(meuse) # reload data.frame
coordinates(meuse) = c(1, 2) # specify column names
class(meuse)
data(meuse) # reload data.frame
coordinates(meuse) = ~x+y # formula
class(meuse)
data(meuse) # reload data.frame
coordinates(meuse) = xy   # as data frame
class(meuse)
data(meuse) # reload data.frame
coordinates(meuse) = as.matrix(xy)   # as matrix
meuse$log.zn = log(meuse$zinc)
class(meuse)
dim(meuse)
</code></pre>

<hr>
<h2 id='SpatialPolygons'> create objects of class SpatialPolygons or SpatialPolygonsDataFrame</h2><span id='topic+SpatialPolygons'></span><span id='topic+SpatialPolygonsDataFrame'></span><span id='topic+Polygon'></span><span id='topic+Polygons'></span><span id='topic+getSpatialPolygonsLabelPoints'></span>

<h3>Description</h3>

<p> create objects of class <code>SpatialPolygons</code> or <code>SpatialPolygonsDataFrame</code> from
lists of <code>Polygons</code> objects and <code>data.frame</code>s</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
Polygon(coords, hole=as.logical(NA))
Polygons(srl, ID)
SpatialPolygons(Srl, pO, proj4string=CRS(as.character(NA)))
SpatialPolygonsDataFrame(Sr, data, match.ID = TRUE)
getSpatialPolygonsLabelPoints(SP)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialPolygons_+3A_coords">coords</code></td>
<td>
<p>2-column numeric matrix with coordinates; first point (row) should
equal last coordinates (row); if the hole argument is not given, the status of the polygon as a hole or an island will be taken from the ring direction, with clockwise meaning island, and counter-clockwise meaning hole</p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_hole">hole</code></td>
<td>
<p>logical value for setting polygon as hole or not; if the hole argument is not given, the status of the polygon as a hole or an island will be taken from the ring direction, with clockwise meaning island, and counter-clockwise meaning hole</p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_proj4string">proj4string</code></td>
<td>
<p> projection string of class <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_srl">srl</code></td>
<td>
<p>list with <a href="sp.html#topic+Polygon-class">Polygon-class</a> objects</p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_id">ID</code></td>
<td>
<p>character vector of length one with identifier</p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_srl">Srl</code></td>
<td>
<p> list with objects of class <a href="sp.html#topic+Polygons-class">Polygons-class</a></p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_po">pO</code></td>
<td>
<p> integer vector; plotting order; if missing in reverse order of Polygons area </p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_sr">Sr</code></td>
<td>
<p> object of class <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_data">data</code></td>
<td>
<p> object of class <code>data.frame</code>; the number of rows in <code>data</code> should equal the number of <a href="sp.html#topic+Polygons-class">Polygons-class</a> objects in <code>Sr</code></p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_match.id">match.ID</code></td>
<td>
<p>logical: (default TRUE): match SpatialPolygons
member Polygons ID slot values with data frame row names, and
re-order the data frame rows if necessary. If character: indicates
the column in <code>data</code> with Polygons IDs to match</p>
</td></tr>
<tr><td><code id="SpatialPolygons_+3A_sp">SP</code></td>
<td>
<p>object of class <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>Polygon</code>, if the hole argument is not given, the status of the polygon as a hole or an island will be taken from the ring direction, with clockwise meaning island, and counter-clockwise meaning hole. In <code>Polygons</code>, if all of the member Polygon objects are holes, the largest by area will be converted to island status. Until 2010-04-17, version 0.9-61, the area of this converted object was erroneously left at its hole value of zero. Thanks to Patrick Giraudoux for spotting the bug. 
</p>
<p>The class definitions used for polygons in <span class="pkg">sp</span> do not accord with those of
the simple features specification of the Open Geospatial Consortium. The <span class="pkg">rgeos</span> package, an interface to Geometry Engine &ndash; Open Source (GEOS), uses this
specification, in which each hole (interior ring) must be associated with
its containing exterior ring. In order to avoid introducing incompatible
changes into the class definition of Polygons objects, a comment has been
added as a single character string to each such object. Here we can trust
the data source to assign the hole status correctly, and use round-trip coercion to <code>sf</code> to add such comments to each Polygons member of  
the polygons slot of this SpatialPolygons object. Exterior rings are coded
zero, while interior rings are coded with the 1-based index of the
exterior ring to which they belong. SpatialPolygons objects created by reading using <code>sf</code> have the comments set on input, as OGR also uses SFS.
</p>
<p>Refer to Bivand et al. (2013), pages 47-48 and 132-133 for a further discussion.
</p>


<h3>Value</h3>

<p><code>Polygon</code> returns an object of class <code>Polygon</code>;
<code>Polygons</code> returns an object of class <code>Polygons</code>;
<code>SpatialPolygons</code> returns object of class <code>SpatialPolygons</code>;
<code>SpatialPolygonsDataFrame</code> returns object of class <code>SpatialPolygonsDataFrame</code>
<code>getSpatialPolygonsLabelPoints</code> returns an object of class
<code>SpatialPoints</code> with label points.
</p>


<h3>References</h3>

<p>Roger Bivand, Edzer Pebesma and Virgilio Gomez-Rubio, 2013. Applied spatial data analysis with R, Second edition. Springer, NY. <a href="https://asdar-book.org/">https://asdar-book.org/</a></p>


<h3>See Also</h3>

 <p><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>, <a href="sp.html#topic+SpatialPolygonsDataFrame-class">SpatialPolygonsDataFrame-class</a> </p>

<hr>
<h2 id='SpatialPolygons-class'>Class &quot;SpatialPolygons&quot;</h2><span id='topic+SpatialPolygons-class'></span><span id='topic++5B+2CSpatialPolygons-method'></span><span id='topic+as.data.frame.SpatialPolygons'></span><span id='topic+as.SpatialPolygonsDataFrame.SpatialPolygons'></span><span id='topic+coerce+2CSpatialPolygons+2CSpatialPolygonsDataFrame-method'></span><span id='topic+plot+2CSpatialPolygons+2Cmissing-method'></span><span id='topic+summary+2CSpatialPolygons-method'></span><span id='topic+rbind.SpatialPolygons'></span><span id='topic+coerce+2CPolygons+2CLines-method'></span><span id='topic+coerce+2CSpatialPolygons+2CSpatialLines-method'></span><span id='topic+coerce+2Cdeldir+2CSpatialPolygons-method'></span><span id='topic+row.names.SpatialPolygons'></span><span id='topic+get_Polypath'></span><span id='topic+set_Polypath'></span><span id='topic+get_PolypathRule'></span><span id='topic+set_PolypathRule'></span>

<h3>Description</h3>

<p>  class to hold polygon topology (without attributes) </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>polygons</code>:</dt><dd><p>Object of class <code>"list"</code>; list elements are
all of class <a href="sp.html#topic+Polygons-class">Polygons-class</a></p>
</dd>
<dt><code>plotOrder</code>:</dt><dd><p>Object of class <code>"integer"</code>; integer array
giving the order in which objects should be plotted </p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; see <a href="sp.html#topic+Spatial-class">Spatial-class</a> </p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; see <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Spatial"</code>, directly.
</p>


<h3>Methods</h3>

<p>Methods defined with class &quot;SpatialPolygons&quot; in the signature:
</p>

<dl>
<dt>[</dt><dd><p><code>signature(obj = "SpatialPolygons")</code>: select subset of (sets of) polygons; NAs are not permitted in the row index</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SpatialPolygons", y = "missing")</code>: 
plot polygons in SpatialPolygons object</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SpatialPolygons")</code>: summarize object</p>
</dd>
<dt>rbind</dt><dd><p><code>signature(object = "SpatialPolygons")</code>: rbind-like method</p>
</dd>
</dl>



<h3>plot method arguments</h3>

<p>The <code>plot</code> method for spatial polygons takes the following arguments:
</p>

<dl>
<dt>x</dt><dd><p>a SpatialPolygons object</p>
</dd>
<dt>col</dt><dd><p>a vector of colour values</p>
</dd>
<dt>border</dt><dd><p>default <code>par("fg")</code>; the colour to draw the border</p>
</dd>
<dt>add</dt><dd><p>default FALSE; if TRUE, add to existing plot</p>
</dd>
<dt>xlim, ylim</dt><dd><p>default NULL; ranges for the plotted &lsquo;x&rsquo; and &lsquo;y&rsquo; values</p>
</dd>
<dt>xpd</dt><dd><p>default NULL; controls clipping, see <code><a href="graphics.html#topic+par">par</a></code></p>
</dd>
<dt>density</dt><dd><p>default NULL; the density of shading lines, in lines per inch, see <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</dd>
<dt>angle</dt><dd><p>default 45; the slope of shading lines, given as an angle in degrees (counter-clockwise), see <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</dd>
<dt>pbg</dt><dd><p>default NULL, set to <code>par("bg")</code> by default &ldquo;transparent&rdquo;; the colour to paint holes</p>
</dd>
<dt>axes</dt><dd><p>default FALSE; draw axes</p>
</dd>
<dt>lty</dt><dd><p>default <code>par("lty")</code>; border line type</p>
</dd>
<dt>...</dt><dd><p>other arguments passed through</p>
</dd>
<dt>setParUsrBB</dt><dd><p>default FALSE;  see <code><a href="sp.html#topic+Spatial-class">Spatial-class</a></code> for further details</p>
</dd>
<dt>usePolypath</dt><dd><p>default NULL to set from option value; use <code><a href="graphics.html#topic+polypath">polypath</a></code> for hole-handling in plot</p>
</dd>
<dt>rule</dt><dd><p>default NULL to set from option value; character value specifying the path fill mode, see <code><a href="graphics.html#topic+polypath">polypath</a></code></p>
</dd>
</dl>

<p>The options for <code>usePolypath</code> and <code>rule</code> may be retrieved with <code>get_Polypath</code> (default TRUE on package load) and <code>get_PolypathRule</code> (default &ldquo;winding&rdquo; on package load), and set with <code>set_Polypath</code> and <code>set_PolypathRule</code>
</p>
<p>The class definitions used for polygons in <span class="pkg">sp</span> do not accord with those of
the simple features specification of the Open Geospatial Consortium. The <span class="pkg">rgeos</span> package, an interface to Geometry Engine &ndash; Open Source (GEOS), uses this
specification, in which each hole (interior ring) must be associated with
its containing exterior ring. In order to avoid introducing incompatible
changes into the class definition of Polygons objects, a comment has been
added as a single character string to each such object. Here we can trust
the data source to assign the hole status correctly, and use round-trip coercion to <code>sf</code> to add such comments to each Polygons member of  
the polygons slot of this SpatialPolygons object. Exterior rings are coded
zero, while interior rings are coded with the 1-based index of the
exterior ring to which they belong. SpatialPolygons objects created by reading using <code>sf</code> or <code>terra</code> have the comments set on input, as OGR also uses SFS.
</p>
<p>Refer to Bivand et al. (2013), pages 47-48 and 132-133 for a further discussion.
</p>


<h3>Note</h3>

<p><code>rbind</code> calls the function <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code>, where it is 
checked that all IDs are unique. If <code>rbind</code>-ing <code>SpatialPolygons</code> without 
unique IDs, it is possible to set the argument <code>makeUniqueIDs = TRUE</code>, although
it is preferred to change these explicitly with <code><a href="sp.html#topic+spChFIDs">spChFIDs</a></code>.
</p>


<h3>Author(s)</h3>

<p> Roger Bivand </p>


<h3>References</h3>

<p>Roger Bivand, Edzer Pebesma and Virgilio Gomez-Rubio, 2013. Applied spatial data analysis with R, Second edition. Springer, NY. <a href="https://asdar-book.org/">https://asdar-book.org/</a></p>


<h3>See Also</h3>

 <p><code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example, from vignette("sp"):
Sr1 = Polygon(cbind(c(2,4,4,1,2),c(2,3,5,4,2)))
Sr2 = Polygon(cbind(c(5,4,2,5),c(2,3,2,2)))
Sr3 = Polygon(cbind(c(4,4,5,10,4),c(5,3,2,5,5)))
Sr4 = Polygon(cbind(c(5,6,6,5,5),c(4,4,3,3,4)), hole = TRUE)

Srs1 = Polygons(list(Sr1), "s1")
Srs2 = Polygons(list(Sr2), "s2")
Srs3 = Polygons(list(Sr3, Sr4), "s3/4")
SpP = SpatialPolygons(list(Srs1,Srs2,Srs3), 1:3)
plot(SpP, col = 1:3, pbg="white")

grd &lt;- GridTopology(c(1,1), c(1,1), c(10,10))
polys &lt;- as(grd, "SpatialPolygons")
plot(polys)
text(coordinates(polys), labels=row.names(polys))
</code></pre>

<hr>
<h2 id='SpatialPolygonsDataFrame-class'>Class &quot;SpatialPolygonsDataFrame&quot; </h2><span id='topic+SpatialPolygonsDataFrame-class'></span><span id='topic++5B+2CSpatialPolygonsDataFrame-method'></span><span id='topic+as.data.frame.SpatialPolygonsDataFrame'></span><span id='topic+coerce+2CSpatialPolygonsDataFrame+2Cdata.frame-method'></span><span id='topic+coerce+2CSpatialPolygonsDataFrame+2CSpatialLinesDataFrame-method'></span><span id='topic+coerce+2CSpatialPolygonsDataFrame+2CSpatialPolygons-method'></span><span id='topic+rbind.SpatialPolygonsDataFrame'></span><span id='topic+dim.SpatialPolygonsDataFrame'></span><span id='topic+row.names.SpatialPolygonsDataFrame'></span>

<h3>Description</h3>

<p> class to hold polygons with attributes </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code>; attribute table </p>
</dd>
<dt><code>polygons</code>:</dt><dd><p>Object of class <code>"list"</code>; see <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a> </p>
</dd>
<dt><code>plotOrder</code>:</dt><dd><p>Object of class <code>"integer"</code>; see <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a> </p>
</dd>
<dt><code>bbox</code>:</dt><dd><p>Object of class <code>"matrix"</code>; see <a href="sp.html#topic+Spatial-class">Spatial-class</a></p>
</dd>
<dt><code>proj4string</code>:</dt><dd><p>Object of class <code>"CRS"</code>; see <a href="sp.html#topic+CRS-class">CRS-class</a></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"SpatialPolygons"</code>, directly.
Class <code>"Spatial"</code>, by class <code>"SpatialPolygons"</code>.
</p>


<h3>Methods</h3>

<p>Methods defined with class &quot;SpatialPolygonsDataFrame&quot; in the signature:
</p>

<dl>
<dt>[</dt><dd><p><code>signature(x = "SpatialPolygonsDataFrame")</code>: select subset of (sets of) polygons; NAs are not permitted in the row index</p>
</dd>
<dt>rbind</dt><dd><p><code>signature(object = "SpatialPolygonsDataFrame")</code>: 
rbind-like method, see notes below</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>SpatialPolygonsDataFrame</code> with default ID matching checks the data frame row names against the Polygons ID slots. They must then agree with each other, and be unique (no Polygons objects can share IDs); the data frame rows will be re-ordered if needed to match the Polygons IDs..
</p>
<p>If you want to <code>rbind</code> objects with 
duplicated IDs, see<code><a href="sp.html#topic+spChFIDs">spChFIDs</a></code>.</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>See Also</h3>

<p><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example, from scratch:
Sr1 = Polygon(cbind(c(2,4,4,1,2),c(2,3,5,4,2)))
Sr2 = Polygon(cbind(c(5,4,2,5),c(2,3,2,2)))
Sr3 = Polygon(cbind(c(4,4,5,10,4),c(5,3,2,5,5)))
Sr4 = Polygon(cbind(c(5,6,6,5,5),c(4,4,3,3,4)), hole = TRUE)

Srs1 = Polygons(list(Sr1), "s1")
Srs2 = Polygons(list(Sr2), "s2")
Srs3 = Polygons(list(Sr3, Sr4), "s3/4")
SpP = SpatialPolygons(list(Srs1,Srs2,Srs3), 1:3)
plot(SpP, col = 1:3, pbg="white")

grd &lt;- GridTopology(c(1,1), c(1,1), c(10,10))
polys &lt;- as(grd, "SpatialPolygons")
centroids &lt;- coordinates(polys)
x &lt;- centroids[,1]
y &lt;- centroids[,2]
z &lt;- 1.4 + 0.1*x + 0.2*y + 0.002*x*x
ex_1.7 &lt;- SpatialPolygonsDataFrame(polys,
 data=data.frame(x=x, y=y, z=z, row.names=row.names(polys)))
brks &lt;- quantile(z, seq(0,1,1/7))
cols &lt;- grey((length(brks):2)/length(brks))
dens &lt;- (2:length(brks))*3
plot(ex_1.7, col=cols[findInterval(z, brks, all.inside=TRUE)])
plot(ex_1.7, density=dens[findInterval(z, brks, all.inside=TRUE)])
</code></pre>

<hr>
<h2 id='spChFIDs-methods'>change feature IDs in spatial objects</h2><span id='topic+spChFIDs-methods'></span><span id='topic+spChFIDs+3C-'></span><span id='topic+spChFIDs+3C-+2CSpatial-method'></span><span id='topic+spChFIDs+2CSpatialLines+2Ccharacter-method'></span><span id='topic+spChFIDs+2CSpatialLinesDataFrame+2Ccharacter-method'></span><span id='topic+spChFIDs+2CSpatialPolygons+2Ccharacter-method'></span><span id='topic+spChFIDs+2CSpatialPolygonsDataFrame+2Ccharacter-method'></span><span id='topic+spChFIDs'></span>

<h3>Description</h3>

<p>When the feature IDs need to be changed in SpatialLines* or SpatialPolygons* objects, these methods may be used. The new IDs should be a character vector of unique IDs of the correct length.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;SpatialLines&quot;, x = &quot;character&quot;</dt><dd><p>replace IDs in a SpatialLines object</p>
</dd>
<dt>obj = &quot;SpatialLinesDataFrame&quot;, x = &quot;character&quot;</dt><dd><p>replace IDs in a SpatialLinesDataFrame object</p>
</dd>
<dt>obj = &quot;SpatialPolygons&quot;, x = &quot;character&quot;</dt><dd><p>replace IDs in a SpatialPolygons object</p>
</dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;, x = &quot;character&quot;</dt><dd><p>replace IDs in a SpatialPolygonsDataFrame object</p>
</dd>
</dl>


<h3>Note</h3>

<p>It is usually sensible to keep a copy of the original feature IDs in the object, but this should be done by the user.</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(sf)) {
xx &lt;- as(st_read(system.file("shape/nc.shp", package="sf")[1]), "Spatial")
row.names(xx) &lt;- as.character(xx$"FIPSNO")
row.names(as(xx, "data.frame"))
xx1 &lt;- spChFIDs(xx, as.character(xx$CNTY_ID))
row.names(as(xx1, "data.frame"))
}
## End(Not run)
</code></pre>

<hr>
<h2 id='spDistsN1'>Euclidean or Great Circle distance between points</h2><span id='topic+spDistsN1'></span><span id='topic+spDists'></span>

<h3>Description</h3>

<p>The function returns a vector of distances between a matrix of 2D points, first column longitude, second column latitude, and a single 2D point, using Euclidean or Great Circle distance (WGS84 ellipsoid) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spDistsN1(pts, pt, longlat = FALSE)
spDists(x, y = x, longlat = FALSE, segments = FALSE, diagonal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spDistsN1_+3A_pts">pts</code></td>
<td>
<p>A matrix of 2D points, first column x/longitude, second column y/latitude, or a SpatialPoints or SpatialPointsDataFrame object</p>
</td></tr>
<tr><td><code id="spDistsN1_+3A_pt">pt</code></td>
<td>
<p>A single 2D point, first value x/longitude, second value y/latitude, or a SpatialPoints or SpatialPointsDataFrame object with one point only</p>
</td></tr>
<tr><td><code id="spDistsN1_+3A_x">x</code></td>
<td>
<p>A matrix of n-D points with row denoting points, first column x/longitude, second column y/latitude, or a Spatial object that has a <a href="raster.html#topic+coordinates">coordinates</a> method</p>
</td></tr>
<tr><td><code id="spDistsN1_+3A_y">y</code></td>
<td>
<p>A matrix of n-D points with row denoting points, first column x/longitude, second column y/latitude, or a Spatial object that has a <a href="raster.html#topic+coordinates">coordinates</a> method</p>
</td></tr>
<tr><td><code id="spDistsN1_+3A_longlat">longlat</code></td>
<td>
<p>logical;
if FALSE, Euclidean distance,
if TRUE Great Circle (WGS84 ellipsoid) distance; 
if <code>x</code> is a Spatial object, longlat should not be specified but will be derived 
from <a href="sp.html#topic+is.projected">is.projected</a><code>(x)</code> </p>
</td></tr>
<tr><td><code id="spDistsN1_+3A_segments">segments</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>y</code> must be missing; the vector of distances
between consecutive points in <code>x</code> is returned. </p>
</td></tr>
<tr><td><code id="spDistsN1_+3A_diagonal">diagonal</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>y</code> must be given and have the same number of
points as <code>x</code>; the vector with distances between points with identical index is returned. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>spDistsN1</code> returns a numeric vector of distances in the metric of the points if longlat=FALSE, or in kilometers if longlat=TRUE.
</p>
<p><code>spDists</code> returns a full matrix of distances in the metric of the points if longlat=FALSE, or in kilometers if longlat=TRUE; it uses <code>spDistsN1</code> in case points are two-dimensional. In case of <code>spDists(x,x)</code>, it will compute 
all n x n distances, not the sufficient n x (n-1).
</p>


<h3>Note</h3>

<p>The function can also be used to find a local kilometer equivalent to a plot scaled in decimal degrees in order to draw a scale bar.  </p>


<h3>Author(s)</h3>

<p>Roger Bivand, Edzer Pebesma</p>


<h3>References</h3>

<p><code>http://www.abecedarical.com/javascript/script_greatcircle.html</code></p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+is.projected">is.projected</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ll &lt;- matrix(c(5, 6, 60, 60), ncol=2)
km &lt;- spDistsN1(ll, ll[1,], longlat=TRUE)
zapsmall(km)
utm32 &lt;- matrix(c(276.9799, 332.7052, 6658.1572, 6655.2055), ncol=2)
spDistsN1(utm32, utm32[1,])
dg &lt;- spDistsN1(ll, ll[1,])
dg
dg[2]/km[2]
data(meuse)
coordinates(meuse) &lt;- c("x", "y")
res &lt;- spDistsN1(meuse, meuse[1,])
summary(res)

p1 = SpatialPoints(cbind(1:3, 1:3))
spDists(p1)
spDists(p1, p1)
spDists(p1, p1, diagonal = TRUE)
try(spDists(p1, p1, segments = TRUE))
spDists(p1, segments = TRUE)
p2 = SpatialPoints(cbind(5:2, 2:5))
spDists(p1, p2)
try(spDists(p1, p2, diagonal = TRUE)) # fails
try(spDists(p1, p2, segments = TRUE)) # fails

# longlat points:
proj4string(p1) = "+proj=longlat +ellps=WGS84"
proj4string(p2) = "+proj=longlat +ellps=WGS84"
is.projected(p1)
is.projected(p2)
spDists(p1)
spDists(p1, p1)
spDists(p1, p1, diagonal = TRUE)
spDists(p1, p2)
try(spDists(p1, p2, diagonal = TRUE)) # fails
spDists(p1, p2[1:length(p1),], diagonal = TRUE)
spDists(p1, segments = TRUE)
spDists(p1[0],p2[0],diagonal=TRUE)
spDists(p1[0])

p1 = SpatialPoints(cbind(1:3, 1:3, 1:3))
spDists(p1)
spDists(p1, p1)
try(spDists(p1, p1, diagonal = TRUE))
try(spDists(p1, p1, segments = TRUE))
try(spDists(p1, segments = TRUE))
p2 = SpatialPoints(cbind(5:2, 2:5, 3:6))
spDists(p1, p2)
try(spDists(p1, p2, diagonal = TRUE)) # fails
try(spDists(p1, p2, segments = TRUE)) # fails

</code></pre>

<hr>
<h2 id='spplot'>Plot methods for spatial data with attributes</h2><span id='topic+spplot'></span><span id='topic+spplot.grid'></span><span id='topic+spplot.locator'></span><span id='topic+spplot.polygons'></span><span id='topic+spplot.points'></span><span id='topic+layout.north.arrow'></span><span id='topic+layout.scale.bar'></span><span id='topic+mapLegendGrob'></span><span id='topic+sp.theme'></span><span id='topic+spplot-methods'></span><span id='topic+spplot+2CSpatialPixelsDataFrame-method'></span><span id='topic+spplot+2CSpatialGridDataFrame-method'></span><span id='topic+spplot+2CSpatialPolygonsDataFrame-method'></span><span id='topic+spplot+2CSpatialLinesDataFrame-method'></span><span id='topic+spplot+2CSpatialPointsDataFrame-method'></span><span id='topic+spplot+2CSpatialMultiPointsDataFrame-method'></span><span id='topic+sppanel'></span><span id='topic+sppanel+2CLine-method'></span><span id='topic+sppanel+2CLines-method'></span><span id='topic+sppanel+2CNULL-method'></span><span id='topic+sppanel+2CSpatialGrid-method'></span><span id='topic+sppanel+2CSpatialLines-method'></span><span id='topic+sppanel+2CSpatialPixels-method'></span><span id='topic+sppanel+2CSpatialPoints-method'></span><span id='topic+sppanel+2CSpatialPolygons-method'></span><span id='topic+sppanel+2Ccharacter-method'></span><span id='topic+sppanel+2Clist-method'></span><span id='topic+panel.RgoogleMaps'></span><span id='topic+panel.ggmap'></span><span id='topic+sppanel-methods'></span><span id='topic+set_col_regions'></span><span id='topic+get_col_regions'></span>

<h3>Description</h3>

<p>Lattice (trellis) plot methods for spatial data with attributes</p>


<h3>Usage</h3>

<pre><code class='language-R'>spplot(obj, ...)
spplot.grid(obj, zcol = names(obj), ..., names.attr, scales = list(draw = FALSE),
 xlab = NULL, ylab = NULL, aspect = mapasp(obj,xlim,ylim),
 panel = panel.gridplot, sp.layout = NULL, formula, xlim = bbox(obj)[1, ],
 ylim = bbox(obj)[2, ], checkEmptyRC = TRUE, col.regions = get_col_regions())
spplot.polygons(obj, zcol = names(obj), ..., names.attr, scales = list(draw = FALSE),
 xlab = NULL, ylab = NULL, aspect = mapasp(obj,xlim,ylim),
 panel = panel.polygonsplot, sp.layout = NULL, formula, xlim = bbox(obj)[1, ],
 ylim = bbox(obj)[2, ], col.regions = get_col_regions())
spplot.points(obj, zcol = names(obj), ..., names.attr, scales = list(draw = FALSE),
 xlab = NULL, ylab = NULL, aspect = mapasp(obj,xlim,ylim),
 panel = panel.pointsplot, sp.layout = NULL, identify = FALSE, formula,
 xlim = bbexpand(bbox(obj)[1, ], 0.04), ylim = bbexpand(bbox(obj)[2, ], 0.04),
 edge.col = "transparent", colorkey = FALSE, col.regions = get_col_regions())
mapLegendGrob(obj, widths = unit(1, "cm"), heights = unit(1, "cm"),
	fill = "black", just = "right")
sp.theme(set = FALSE, regions = list(col = bpy.colors(100)), ...)
layout.north.arrow(type = 1)
layout.scale.bar(height = 0.05)
spplot.locator(n = 512, type = "n", ...)
set_col_regions(value)
get_col_regions()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spplot_+3A_obj">obj</code></td>
<td>
<p> object of class extending <a href="sp.html#topic+Spatial-class">Spatial-class</a></p>
</td></tr> 
<tr><td><code id="spplot_+3A_zcol">zcol</code></td>
<td>
<p> character; attribute name(s) or column number(s) in attribute table </p>
</td></tr>
<tr><td><code id="spplot_+3A_names.attr">names.attr</code></td>
<td>
<p> names to use in panel, if different from zcol names </p>
</td></tr>
<tr><td><code id="spplot_+3A_scales">scales</code></td>
<td>
<p> scales argument to be passed to Lattice plots; use
<code>list(draw = TRUE)</code> to draw axes scales; see <a href="lattice.html#topic+xyplot">xyplot</a> for full options </p>
</td></tr>
<tr><td><code id="spplot_+3A_...">...</code></td>
<td>
<p> other arguments passed to <a href="lattice.html#topic+levelplot">levelplot</a> (grids, polygons) or 
<a href="lattice.html#topic+xyplot">xyplot</a> (points) </p>
</td></tr>
<tr><td><code id="spplot_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis </p>
</td></tr>
<tr><td><code id="spplot_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis </p>
</td></tr>
<tr><td><code id="spplot_+3A_aspect">aspect</code></td>
<td>
<p>aspect ratio for spatial axes; defaults to &quot;iso&quot; (one unit
on the x-axis equals one unit on the y-axis) but may be set to more
suitable values if the data are e.g. if coordinates are latitude/longitude </p>
</td></tr>
<tr><td><code id="spplot_+3A_panel">panel</code></td>
<td>
<p> depending on the class of obj, <a href="sp.html#topic+panel.polygonsplot">panel.polygonsplot</a> (for
polygons or lines), <a href="sp.html#topic+panel.gridplot">panel.gridplot</a> (grids) or <a href="sp.html#topic+panel.pointsplot">panel.pointsplot</a>
(points) is used; for further control custom panel functions can be
supplied that call one of these panel functions, but do read below how the
argument <code>sp.layout</code> may help </p>
</td></tr>
<tr><td><code id="spplot_+3A_sp.layout">sp.layout</code></td>
<td>
<p>NULL or list; see notes below</p>
</td></tr>
<tr><td><code id="spplot_+3A_identify">identify</code></td>
<td>
<p> if not FALSE, identify plotted objects (currently only working
for points plots). Labels for identification are the row.names of the
attribute table <code>row.names(as.data.frame(obj))</code>. If TRUE, identify
on panel <code>(1,1)</code>; for identifying on panel <code>i,j</code>, pass the
value <code>c(i,j)</code></p>
</td></tr>
<tr><td><code id="spplot_+3A_formula">formula</code></td>
<td>
<p>optional; may be useful to plot a transformed value. Defaults
to <code>z~x+y</code> for single and <code>z~x+y|name</code> for multiple attributes; use
e.g. <code>exp(x)~x+y|name</code> to plot the exponent of the z-variable</p>
</td></tr>
<tr><td><code id="spplot_+3A_xlim">xlim</code></td>
<td>
<p> numeric; x-axis limits </p>
</td></tr>
<tr><td><code id="spplot_+3A_ylim">ylim</code></td>
<td>
<p> numeric; y-axis limits </p>
</td></tr>
<tr><td><code id="spplot_+3A_edge.col">edge.col</code></td>
<td>
<p> color of symbol edge </p>
</td></tr>
<tr><td><code id="spplot_+3A_colorkey">colorkey</code></td>
<td>
<p> if FALSE, use symbol key; if TRUE, use continuous, levelplot-like colorkey; if list, follow syntax of argument <code>colorkey</code> in <a href="lattice.html#topic+interaction">levelplot</a> (see below for an example) </p>
</td></tr>
<tr><td><code id="spplot_+3A_widths">widths</code></td>
<td>
<p>width of grob</p>
</td></tr>
<tr><td><code id="spplot_+3A_heights">heights</code></td>
<td>
<p>heights of grob</p>
</td></tr>
<tr><td><code id="spplot_+3A_fill">fill</code></td>
<td>
<p>fill color of grob</p>
</td></tr>
<tr><td><code id="spplot_+3A_just">just</code></td>
<td>
<p>grob placement justification</p>
</td></tr>
<tr><td><code id="spplot_+3A_set">set</code></td>
<td>
<p> logical; if TRUE, trellis.par.set is called, else a list is returned
that can be passed to trellis.par.set() </p>
</td></tr>
<tr><td><code id="spplot_+3A_regions">regions</code></td>
<td>
<p> color ramp for the theme </p>
</td></tr>
<tr><td><code id="spplot_+3A_height">height</code></td>
<td>
<p>height of scale bar; width is 1.0</p>
</td></tr>
<tr><td><code id="spplot_+3A_n">n</code></td>
<td>
<p>see locator</p>
</td></tr>
<tr><td><code id="spplot_+3A_type">type</code></td>
<td>
<p>see locator</p>
</td></tr>
<tr><td><code id="spplot_+3A_checkemptyrc">checkEmptyRC</code></td>
<td>
<p>logical; if TRUE, a check is done to see if
empty rows or columns are present, and need to be taken care of. Setting
to FALSE may improve speed. </p>
</td></tr>
<tr><td><code id="spplot_+3A_col.regions">col.regions</code></td>
<td>
<p> vector with fill colours; in case the variable
to be plotted is a factor, this vector should have length equal to the
number of factor levels </p>
</td></tr> 
<tr><td><code id="spplot_+3A_value">value</code></td>
<td>
<p> vector with color values, default for <code>col.regions</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>spplot returns a lattice plot of class &quot;trellis&quot;, if you fail to &quot;see&quot; it,
explicitly call <code>print(spplot(...))</code>. If <code>identify</code> is TRUE,
the plot is plotted and the return value is a vector with row names of
the selected points.
</p>
<p><code>spplot.locator</code> returns a matrix with identified point locations;
use <code>trellis.focus</code> first to focus on a given panel.
</p>
<p><code>get_col_regions</code> returns the default value for <code>col.regions</code>
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;SpatialPixelsDataFrame&quot;</dt><dd><p> see <a href="raster.html#topic+spplot">spplot</a> </p>
</dd>
<dt>obj = &quot;SpatialGridDataFrame&quot;</dt><dd><p> see <a href="raster.html#topic+spplot">spplot</a> </p>
</dd>
<dt>obj = &quot;SpatialPolygonsDataFrame&quot;</dt><dd><p> see <a href="raster.html#topic+spplot">spplot</a> </p>
</dd>
<dt>obj = &quot;SpatialLinesDataFrame&quot;</dt><dd><p> see <a href="raster.html#topic+spplot">spplot</a> </p>
</dd>
<dt>obj = &quot;SpatialPointsDataFrame&quot;</dt><dd><p> see <a href="raster.html#topic+spplot">spplot</a> </p>
</dd>
</dl>


<h3>Note</h3>

<p>Missing values in the attributes are (currently) not allowed.
</p>
<p><code>spplot.grid</code>, <code>spplot.polygons</code> and <code>spplot.points</code> are S4
methods for <code>spplot</code>; see <a href="sp.html#topic+spplot-methods">spplot-methods</a>.
</p>
<p>Useful arguments that can be passed as <code>...</code> are: 
</p>

<dl>
<dt><code>layout</code></dt><dd><p>integer; for the layout of panels (cols,rows)</p>
</dd>
<dt><code>pretty</code></dt><dd><p>logical; choose colour breaks at pretty numbers?</p>
</dd>
<dt><code>at</code></dt><dd><p>specify at which values colours change</p>
</dd>
<dt><code>as.table</code></dt><dd><p>logical; start drawing panels upper-left instead
of lower-left</p>
</dd>
<dt><code>page</code></dt><dd><p>to add marks to each plotted page</p>
</dd>
</dl>

<p>for useful values see the appropriate documentation of <a href="lattice.html#topic+xyplot">xyplot</a>
(in case of points), and <a href="lattice.html#topic+levelplot">levelplot</a> (otherwise).
</p>
<p>If <code>obj</code> is of SpatialPointsDataFrame, the following options are
useful to pass:
</p>

<dl>
<dt><code>key.space</code></dt><dd><p> character: &quot;bottom&quot;, &quot;right&quot;, &quot;left&quot; or &quot;right&quot; to denote
key location, or list: see argument key in the help for <a href="lattice.html#topic+xyplot">xyplot</a> what
the options are</p>
</dd>
<dt><code>legendEntries</code></dt><dd><p> character; array with key legend (text) entries; 
suitable defaults obtained from data </p>
</dd>
<dt><code>cuts</code></dt><dd><p>number of cuts, or, for objects of class <a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a> only, the actual cuts to use</p>
</dd>
<dt><code>do.log</code></dt><dd><p>logical; if TRUE use log-linear scale to divide range in equal cuts,
else use a linear scale if <code>cuts</code> is only number of cuts </p>
</dd>
<dt><code>pch</code></dt><dd><p> integer; plotting character to use; defaults to 16 if fill is TRUE, else 1 </p>
</dd>
<dt><code>cex</code></dt><dd><p>numeric; character expansion, proportional to default value of 1</p>
</dd>
<dt><code>fill</code></dt><dd><p> logical; use filled circles? </p>
</dd>
</dl>

<p><code>layout.north.arrow</code> and <code>layout.scale.bar</code> can be used
to set a north arrow or scale bar.
</p>
<p>The <code>sp.layout</code> argument is either a single layout item, or a list
with one or more layout items. A layout item is one of
</p>

<ul>
<li><p>a list with one or more <code>Spatial*</code> objects, along with
style arguments like <code>col</code>, <code>lty</code>, <code>pch</code>, <code>fill</code> etc.
</p>
</li>
<li><p>a list with its first argument the layout function or
the name of the layout function to be called: <code>sp.points</code> for
SpatialPoints, <code>sp.polygons</code> for SpatialPolygons object, <code>sp.lines</code>
for a SpatialLines object, and <code>sp.text</code> for text to place. The
second argument contains the object (or text) to be plotted; remaining
arguments are passed to the corresponding <code>panel.*</code> functions.</p>
</li></ul>

<p>The order of items in <code>sp.layout</code> matters; objects are drawn in the
order they appear. With respect to <code>obj</code>, default plot order and
precedence of <code>sp.layout</code> items is as follows: for points and
lines, <code>sp.layout</code> items are drawn over (after) <code>obj</code>; for
grids and polygons, <code>sp.layout</code> items are drawn behind (before)
<code>obj</code>.  Transparency may further help making multiple things
visible. Adding a <code>first</code> argument to a layout item overrides its
default plotting order with respect to <code>obj</code>:
</p>
<p>Special control elements of <code>sp.layout</code> items:
</p>

<dl>
<dt><code>first</code></dt><dd><p>logical; should the layout item be drawn before
the <code>obj</code> (TRUE), or after (FALSE)? This overrides
the default order (points and lines in front, polygons and grids behind). </p>
</dd>
<dt><code>which</code></dt><dd><p>integer; controls to which panel a layout
item should be added. If <code>which</code> is present in the main,
top-level list it applies to all layout items; in sub-lists with
layout items it denotes the (set of) panel(s) in which the layout
item should be drawn.  Without a <code>which</code> item, layout items
are drawn in each panel.</p>
</dd>
</dl>

<p><code>sp.theme</code> returns a lattice theme; use, after loading package
<code>lattice</code>, the command <code>trellis.par.set(sp.theme())</code>
after a device is opened or changed to make this work. Currently, this only
sets the colors to <a href="sp.html#topic+bpy.colors">bpy.colors</a>.
</p>
<p>If the attributes to be plotted are of type factor, spplot tries
to create a legend that reflects this. In this case, the color ramp
passed needs to be of the same length as the number of factor levels.
The factor levels are derived from the first map; subsequent factors
with different factor levels result in an error.
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a>
</p>


<h3>References</h3>

<p><a href="https://edzer.github.io/sp/">https://edzer.github.io/sp/</a>
</p>


<h3>See Also</h3>

<p><a href="lattice.html#topic+xyplot">xyplot</a>, <a href="lattice.html#topic+levelplot">levelplot</a>,
<a href="lattice.html#topic+interaction">panel.identify</a> to identify objects </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lattice)
trellis.par.set(sp.theme()) # sets bpy.colors() ramp
demo(meuse, ask = FALSE, echo = FALSE)
l2 = list("SpatialPolygonsRescale", layout.north.arrow(), offset = c(181300,329800), 
	scale = 400)
l3 = list("SpatialPolygonsRescale", layout.scale.bar(), offset = c(180500,329800), 
	scale = 500, fill=c("transparent","black"))
l4 = list("sp.text", c(180500,329900), "0")
l5 = list("sp.text", c(181000,329900), "500 m")

spplot(meuse, c("ffreq"), sp.layout=list(l2,l3,l4,l5), col.regions= "black", 
	pch=c(1,2,3), key.space=list(x=0.1,y=.95,corner=c(0,1)))
spplot(meuse, c("zinc", "lead"), sp.layout=list(l2,l3,l4,l5, which = 2),
	key.space=list(x=0.1,y=.95,corner=c(0,1)))
# plotting factors:
meuse$f = factor(sample(letters[6:10], 155, replace=TRUE),levels=letters[1:10])
meuse$g = factor(sample(letters[1:5], 155, replace=TRUE),levels=letters[1:10])
spplot(meuse, c("f","g"), col.regions=bpy.colors(10))

if (require(RColorBrewer)) {
	spplot(meuse, c("ffreq"), sp.layout=list(l2,l3,l4,l5),
		col.regions=brewer.pal(3, "Set1"))
}

meuse.grid$g = factor(sample(letters[1:5], 3103, replace=TRUE),
	levels=letters[1:10])
meuse.grid$f = factor(sample(letters[6:10], 3103, replace=TRUE),
	levels=letters[1:10])
spplot(meuse.grid, c("f","g"), col.regions=bpy.colors(10))

# example modifying colorkey for points:
spplot(meuse["dist"], colorkey = list(
	right = list( # see ?levelplot in package trellis, argument colorkey:
		fun = draw.colorkey, 
		args = list(
			key = list(
				at = seq(0, 1, .1), # colour breaks
				col = bpy.colors(11), # colours
				labels = list(
					at = c(0, .2, .4, .6, .8, 1), 
					labels = c("0x", "20x", "40x", "60x", "80x", "100x")
				)
			)
		)
	)
))
l6 = list(meuse.grid["dist"], col = grey(seq(.5,.9,length.out=10)))
spplot(meuse, c("zinc", "lead"), sp.layout = l6)
spplot(meuse, c("zinc", "lead"), 
	sp.layout = list(meuse.grid, meuse.riv, col = 'grey'))

#  Custom legend placement, taken from 
# http://stackoverflow.com/questions/29344692/custom-placement-of-spplot-legend-in-the-map
s &lt;- spplot(meuse.grid[,'dist'], colorkey = list(space = "left", height = 0.4))

args &lt;- s$legend$left$args$key

## Prepare list of arguments needed by `legend=` argument (as described in ?xyplot)
library(lattice) # draw.colorkey
legendArgs &lt;- list(fun = draw.colorkey,
                   args = list(key = args),
                   corner = c(0.05,.75))

## Call spplot() again, this time passing in to legend the arguments
## needed to print a color key
spplot(meuse.grid[,'dist'], colorkey = FALSE,
       legend = list(inside = legendArgs))
</code></pre>

<hr>
<h2 id='spsample'> sample point locations in (or on) a spatial object </h2><span id='topic+spsample-methods'></span><span id='topic+spsample+2CSpatial-method'></span><span id='topic+spsample+2CLine-method'></span><span id='topic+spsample+2CLines-method'></span><span id='topic+spsample+2CSpatialLines-method'></span><span id='topic+spsample+2CPolygon-method'></span><span id='topic+spsample+2CPolygons-method'></span><span id='topic+spsample+2CSpatialGrid-method'></span><span id='topic+spsample+2CSpatialPixels-method'></span><span id='topic+spsample+2CSpatialPolygons-method'></span><span id='topic+spsample'></span><span id='topic+makegrid'></span>

<h3>Description</h3>

<p> sample point locations within a square area, a grid,
a polygon, or on a spatial line, using regular or random sampling
methods; the methods used assume that the geometry used is not spherical, 
so objects should be in planar coordinates </p>


<h3>Usage</h3>

<pre><code class='language-R'>spsample(x, n, type, ...)
makegrid(x, n = 10000, nsig = 2, cellsize, offset = rep(0.5, nrow(bb)),
	pretty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spsample_+3A_x">x</code></td>
<td>
<p>Spatial object; <code>spsample(x,...)</code> is a generic method for the
existing <code>sample.Xxx</code> functions</p>
</td></tr>
<tr><td><code id="spsample_+3A_...">...</code></td>
<td>
<p> optional arguments, passed to the appropriate <code>sample.Xxx</code>
functions; see NOTES for <code>nclusters</code> and <code>iter</code></p>
</td></tr>
<tr><td><code id="spsample_+3A_n">n</code></td>
<td>
<p> (approximate) sample size </p>
</td></tr>
<tr><td><code id="spsample_+3A_type">type</code></td>
<td>
<p> character; <code>"random"</code> for completely spatial random;
<code>"regular"</code> for regular (systematically aligned) sampling;
<code>"stratified"</code> for stratified random (one single random location in
each &quot;cell&quot;); <code>"nonaligned"</code> for nonaligned systematic sampling
(nx random y coordinates, ny random x coordinates); <code>"hexagonal"</code>
for sampling on a hexagonal lattice; <code>"clustered"</code> for clustered sampling;
<code>"Fibonacci"</code> for Fibonacci sampling on the sphere (see references).</p>
</td></tr>
<tr><td><code id="spsample_+3A_bb">bb</code></td>
<td>
<p> bounding box of the sampled domain; setting this to a smaller
value leads to sub-region sampling </p>
</td></tr>
<tr><td><code id="spsample_+3A_offset">offset</code></td>
<td>
<p> for square cell-based sampling types (regular, stratified, 
nonaligned, hexagonal): the offset (position) of the regular
grid; the default for <code>spsample</code> methods is a random location in
the unit cell [0,1] x [0,1], leading to a different grid after
each call; if this is set to <code>c(0.5,0.5)</code>, the returned grid is
not random (but, in Ripley's wording, &quot;centric systematic&quot;). For
line objects, a single offset value is taken, where the value varies within 
the [0, 1] interval, and 0 is the beginning of each Line object, and 1 
its end </p>
</td></tr>
<tr><td><code id="spsample_+3A_cellsize">cellsize</code></td>
<td>
<p> if missing, a cell size is derived from the sample size
<code>n</code>; otherwise, this cell size is used for all sampling methods
except <code>"random"</code> </p>
</td></tr>
<tr><td><code id="spsample_+3A_nsig">nsig</code></td>
<td>
<p> for &quot;pretty&quot; cell size; <code>spsample</code> does not result in
pretty grids </p>
</td></tr>
<tr><td><code id="spsample_+3A_pretty">pretty</code></td>
<td>
<p>logical; if <code>TRUE</code>, choose pretty (rounded) coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p> an object of class <a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a>. The number of
points is only guaranteed to equal <code>n</code> when sampling is done in a
square box, i.e. (<code>sample.Spatial</code>). Otherwise, the obtained number
of points will have expected value <code>n</code>. 
</p>
<p>When <code>x</code> is of a class deriving from <a href="sp.html#topic+Spatial-class">Spatial-class</a> for which
no <a href="sp.html#topic+spsample-methods">spsample-methods</a> exists, sampling is done in the bounding box
of the object, using <code>spsample.Spatial</code>. An overlay using
<a href="grDevices.html#topic+over">over</a> may be necessary to select the features inside the geometry
afterwards. 
</p>
<p>Sampling type <code>"nonaligned"</code> is not implemented for line objects. 
</p>
<p>Some methods may return NULL if no points could be successfully placed. 
</p>
<p><code>makegrid</code> makes a regular grid that covers <code>x</code>; when
<code>cellsize</code> is not given it derives one from the number of grid
points requested (approximating the number of cells). It tries to
choose pretty cell size and grid coordinates.
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;Spatial&quot;</dt><dd><p> sample in the bbox of <code>x</code> </p>
</dd>
<dt>x = &quot;Line&quot;</dt><dd><p> sample on a line </p>
</dd>
<dt>x = &quot;Polygon&quot;</dt><dd><p> sample in a Polygon </p>
</dd>
<dt>x = &quot;Polygons&quot;</dt><dd><p> sample in a Polygons object, consisting of possibly
multiple Polygon objects (holes must be correctly defined, use <code>checkPolygonsHoles</code> if need be) </p>
</dd>
<dt>x = &quot;SpatialPolygons&quot;</dt><dd><p> sample in an SpatialPolygons object; sampling
takes place over all Polygons objects present, use subsetting to vary
sampling intensity (density); holes must be correctly defined, use <code>checkPolygonsHoles</code> if need be </p>
</dd>
<dt>x = &quot;SpatialGrid&quot;</dt><dd><p> sample in an SpatialGrid object </p>
</dd>
<dt>x = &quot;SpatialPixels&quot;</dt><dd><p> sample in an SpatialPixels object </p>
</dd>
</dl>


<h3>Note</h3>

<p>If an <a href="sp.html#topic+Polygon-class">Polygon-class</a> object has zero area (i.e. is a line),
samples on this line element are returned. If the area is very close
to zero, the algorithm taken here (generating points in a square
area, selecting those inside the polygon) may be very resource
intensive. When numbers of points per polygon are small and
type=&quot;random&quot;, the number searched for is inflated to ensure hits,
and the points returned sampled among these.
</p>
<p>The following two arguments can be further specified:
</p>
<p><code>nclusters</code> Number of clusters (strata) to sample from.
</p>
<p><code>iter</code>(default = 4) number of times to try to place sample points
in a polygon before giving up and returning NULL - this may occur when
trying to hit a small and awkwardly shaped polygon in a large bounding
box with a small number of points
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a></p>


<h3>References</h3>

<p>Chapter 3 in B.D. Ripley, 1981. Spatial Statistics, Wiley
</p>
<p>Fibonacci sampling:  Alvaro Gonzalez, 2010. Measurement of Areas on a
Sphere Using Fibonacci and Latitude-Longitude Lattices. Mathematical
Geosciences 42(1), p. 49-64 </p>


<h3>See Also</h3>

<p><a href="grDevices.html#topic+over">over</a>, <a href="sp.html#topic+point.in.polygon">point.in.polygon</a>, <a href="base.html#topic+sample">sample</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(meuse.riv)
meuse.sr = SpatialPolygons(list(Polygons(list(Polygon(meuse.riv)), "x")))

plot(meuse.sr)
points(spsample(meuse.sr, n = 1000, "regular"), pch = 3)

plot(meuse.sr)
points(spsample(meuse.sr, n = 1000, "random"), pch = 3)

plot(meuse.sr)
points(spsample(meuse.sr, n = 1000, "stratified"), pch = 3)

plot(meuse.sr)
points(spsample(meuse.sr, n = 1000, "nonaligned"), pch = 3)

plot(meuse.sr)
points(spsample(meuse.sr@polygons[[1]], n = 100, "stratified"), pch = 3, cex=.5)

data(meuse.grid)
gridded(meuse.grid) = ~x+y
image(meuse.grid)
points(spsample(meuse.grid,n=1000,type="random"), pch=3, cex=.5)
image(meuse.grid)
points(spsample(meuse.grid,n=1000,type="stratified"), pch=3, cex=.5)
image(meuse.grid)
points(spsample(meuse.grid,n=1000,type="regular"), pch=3, cex=.5)
image(meuse.grid)
points(spsample(meuse.grid,n=1000,type="nonaligned"), pch=3, cex=.5)

fullgrid(meuse.grid) = TRUE
image(meuse.grid)
points(spsample(meuse.grid,n=1000,type="stratified"), pch=3,cex=.5)

</code></pre>

<hr>
<h2 id='spTransform'> spTransform for map projection and datum transformation </h2><span id='topic+spTransform-methods'></span><span id='topic+spTransform+2CSpatial+2CCRS-method'></span><span id='topic+spTransform+2CSpatial+2Ccharacter-method'></span><span id='topic+spTransform+2CSpatial+2CANY-method'></span><span id='topic+spTransform'></span>

<h3>Description</h3>

<p> spTransform for map projection and datum transformation </p>


<h3>Usage</h3>

<pre><code class='language-R'>spTransform(x, CRSobj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spTransform_+3A_x">x</code></td>
<td>
<p> object to be transformed </p>
</td></tr>
<tr><td><code id="spTransform_+3A_crsobj">CRSobj</code></td>
<td>
<p> object of class <a href="sp.html#topic+CRS">CRS</a>, or of class <code>character</code> in
which case it is converted to <a href="sp.html#topic+CRS">CRS</a></p>
</td></tr>
<tr><td><code id="spTransform_+3A_...">...</code></td>
<td>
<p>further arguments (ignored) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>object with coordinates transformed to the new coordinate reference
system.
</p>


<h3>Note</h3>

<p>Package <code>sf</code> provides the methods doing actual transformation.
</p>

<hr>
<h2 id='stack'> rearrange data in SpatialPointsDataFrame or SpatialGridDataFrame 
for plotting with spplot (levelplot/xyplot wrapper) </h2><span id='topic+spmap.to.lev'></span><span id='topic+stack.SpatialPointsDataFrame'></span><span id='topic+stack.SpatialGridDataFrame'></span>

<h3>Description</h3>

 
<p>rearrange SpatialPointsDataFrame for plotting with spplot or levelplot </p>


<h3>Usage</h3>

<pre><code class='language-R'>spmap.to.lev(data, zcol = 1:n, n = 2, names.attr)
## S3 method for class 'SpatialPointsDataFrame'
stack(x, select, ...)
## S3 method for class 'SpatialGridDataFrame'
stack(x, select, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_+3A_data">data</code></td>
<td>
<p> object of class (or extending) SpatialPointsDataFrame or
SpatialGridDataFrame </p>
</td></tr>
<tr><td><code id="stack_+3A_zcol">zcol</code></td>
<td>
<p> z-coordinate column name(s), or a column number (range) (after
removing the spatial coordinate columns: 1 refers to the first non-coordinate
column, etc. ) </p>
</td></tr>
<tr><td><code id="stack_+3A_names.attr">names.attr</code></td>
<td>
<p>names of the set of z-columns (these names
will appear in the plot); if omitted, column names of <code>zcol</code> </p>
</td></tr>
<tr><td><code id="stack_+3A_n">n</code></td>
<td>
<p> number of columns to be stacked </p>
</td></tr>
<tr><td><code id="stack_+3A_x">x</code></td>
<td>
<p> same as <code>data</code></p>
</td></tr>
<tr><td><code id="stack_+3A_select">select</code></td>
<td>
<p> same as <code>zcol</code></p>
</td></tr>
<tr><td><code id="stack_+3A_...">...</code></td>
<td>
<p> ignored </p>
</td></tr>
</table>


<h3>Value</h3>

 
<p><code>spmap.to.lev</code> returns a data frame with the following elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> x-coordinate for each row</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> y-coordinate for each row</p>
</td></tr> 
<tr><td><code>z</code></td>
<td>
<p> column vector with each of the elements in columns <code>zcol</code>
of <code>data</code> stacked </p>
</td></tr> 
<tr><td><code>name</code></td>
<td>
<p> factor; name of each of the stacked <code>z</code> columns </p>
</td></tr> 
</table>
<p><code>stack</code> is an S3 method: it return a data.frame with a column
<code>values</code> that has the stacked coordinates and attributes, and a
column <code>ind</code> that indicates the variable stacked; it also
replicates the coordinates. </p>


<h3>See Also</h3>

 <p><a href="raster.html#topic+spplot">spplot</a>, <a href="lattice.html#topic+levelplot">levelplot</a> in package <code>lattice</code>, and <a href="utils.html#topic+stack">stack</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lattice)
data(meuse.grid) # data frame
coordinates(meuse.grid) = c("x", "y") # promotes to SpatialPointsDataFrame
meuse.grid[["idist"]] = 1 - meuse.grid[["dist"]] # add variable
# the following is made much easier by spplot:
levelplot(z~x+y|name, spmap.to.lev(meuse.grid, z=c("dist","idist"), names.attr =
	c("distance", "inverse of distance")), aspect = "iso")
levelplot(values~x+y|ind, as.data.frame(stack(meuse.grid)),aspect = "iso")
gridded(meuse.grid) = TRUE
levelplot(z~x+y|name, spmap.to.lev(meuse.grid, z=c("dist","idist"), names.attr =
	c("distance", "inverse of distance")), aspect = "iso")
levelplot(values~x+y|ind, as.data.frame(stack(meuse.grid)), asp = "iso")

</code></pre>

<hr>
<h2 id='surfaceArea'>
Compute surface area of a digital elevation model.
</h2><span id='topic+surfaceArea'></span><span id='topic+surfaceArea.matrix'></span><span id='topic+surfaceArea+2CSpatialPixelsDataFrame-method'></span><span id='topic+surfaceArea+2CSpatialGridDataFrame-method'></span><span id='topic+surfaceArea+2Cmatrix-method'></span>

<h3>Description</h3>

<p>It is often said that if Wales was flattened out it would have
an area bigger than England. This function computes the surface
area of a grid of heights taking into account the sloping nature
of the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceArea(m, ...)
surfaceArea.matrix(m, cellx = 1, celly = 1, byCell = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceArea_+3A_m">m</code></td>
<td>

<p>a matrix of height values, or an object of class <a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPixelsDataFrame</a> or <a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a>.
</p>
</td></tr>
<tr><td><code id="surfaceArea_+3A_cellx">cellx</code></td>
<td>

<p>the size of the grid cells in the x-direction, in the same units as the height values.
</p>
</td></tr>
<tr><td><code id="surfaceArea_+3A_celly">celly</code></td>
<td>

<p>the size of the grid cells in the y-direction, in the same units as
the height values.
</p>
</td></tr>
<tr><td><code id="surfaceArea_+3A_bycell">byCell</code></td>
<td>

<p>return single value or matrix of values
</p>
</td></tr>
<tr><td><code id="surfaceArea_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a single value of the total area if byCell=FALSE, or a matrix
the same shape as m of individual cell surface areas if
byCell=TRUE. In this case, the sum of the returned matrix should be
the same value as that which is returned if byCell=FALSE.
</p>
<p>Missing values (NA) in the input matrix are allowed. They will produce
an NA in the output matrix for byCell=TRUE, and contribute zero to the
total area. They also have an effect on adjacent cells - see code
comments for details.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;matrix&quot;</dt><dd><p> takes a matrix as input, requires cellx and celly to be set </p>
</dd>
<dt>obj = &quot;SpatialGridDataFrame&quot;</dt><dd><p> takes an object of class <a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a> as input, and retrieves cellx and celly from this </p>
</dd>
<dt>obj = &quot;SpatialPixelsDataFrame&quot;</dt><dd><p> takes an object of class <a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPixelsDataFrame</a> as input, and retrieves cellx and celly from this </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Barry Rowlingson &lt;b.rowlingson@lancaster.ac.uk&gt;, integration in sp Edzer
Pebesma.
</p>


<h3>References</h3>

<p>Calculating Landscape Surface Area from Digital Elevation Models, Jeff S. Jenness
Wildlife Society Bulletin, Vol. 32, No. 3 (Autumn, 2004), pp. 829-839
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surfaceArea(volcano)
image(surfaceArea(volcano,byCell=TRUE))

data(meuse.grid)
gridded(meuse.grid) = ~x+y
image(surfaceArea(meuse.grid["dist"], byCell=TRUE))
surfaceArea(meuse.grid["dist"])
</code></pre>

<hr>
<h2 id='zerodist'> find point pairs with equal spatial coordinates </h2><span id='topic+zerodist'></span><span id='topic+zerodist2'></span><span id='topic+remove.duplicates'></span>

<h3>Description</h3>

<p> find point pairs with equal spatial coordinates </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
zerodist(obj, zero = 0.0, unique.ID = FALSE, memcmp = TRUE) 
zerodist2(obj1, obj2, zero = 0.0, memcmp = TRUE) 
remove.duplicates(obj, zero = 0.0, remove.second = TRUE, memcmp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zerodist_+3A_obj">obj</code></td>
<td>
<p> object of, or extending, class <a href="sp.html#topic+SpatialPoints">SpatialPoints</a> </p>
</td></tr>
<tr><td><code id="zerodist_+3A_obj1">obj1</code></td>
<td>
<p> object of, or extending, class <a href="sp.html#topic+SpatialPoints">SpatialPoints</a> </p>
</td></tr>
<tr><td><code id="zerodist_+3A_obj2">obj2</code></td>
<td>
<p> object of, or extending, class <a href="sp.html#topic+SpatialPoints">SpatialPoints</a> </p>
</td></tr>
<tr><td><code id="zerodist_+3A_zero">zero</code></td>
<td>
<p> distance values less than or equal to this threshold value are
considered to have zero distance (default 0.0);
units are those of the coordinates for projected data or unknown projection,
or km if coordinates are defined to be longitude/latitude </p>
</td></tr>
<tr><td><code id="zerodist_+3A_unique.id">unique.ID</code></td>
<td>
<p>logical; if TRUE, return an ID (integer) for each point 
that is different only when two points do not share the same location </p>
</td></tr>
<tr><td><code id="zerodist_+3A_memcmp">memcmp</code></td>
<td>
<p>use <code>memcmp</code> to find exactly equal coordinates; see NOTE</p>
</td></tr>
<tr><td><code id="zerodist_+3A_remove.second">remove.second</code></td>
<td>
<p>logical; if TRUE, the second of each pair of duplicate
points is removed, if FALSE remove the first</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>zerodist</code> and <code>zerodist2</code> return a two-column matrix
with in each row pairs of row numbers with identical coordinates;
a matrix with zero rows is returned if no such pairs are found. For
<code>zerodist</code>, row number pairs refer to row pairs in <code>obj</code>. For
<code>zerodist2</code>, row number pairs refer to rows in <code>obj</code> and
<code>obj2</code>, respectively. <code>remove.duplicates</code> removes duplicate
observations if present, and else returns <code>obj</code>. </p>


<h3>Note</h3>

<p> When using kriging, duplicate observations sharing identical
spatial locations result in singular covariance matrices.
This function may help identify and remove spatial duplices.
The full matrix with all pair-wise distances is not stored; the
double loop is done at the C level.  
</p>
<p>When <code>unique.ID=TRUE</code> is used, an integer index is returned. sp
1.0-14 returned the highest index, sp 1.0-15 and later return the
lowest index.
</p>
<p>When <code>zero</code> is 0.0 and <code>memcmp</code> is not <code>FALSE</code>,
<code>zerodist</code> uses <code>memcmp</code> to evaluate exact equality of
coordinates; there may be cases where this results in a different
evaluation compared to doing the double arithmetic of computing
distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
summary(meuse)
# pick 10 rows
n &lt;- 10
ran10 &lt;- sample(nrow(meuse), size = n, replace = TRUE)
meusedup &lt;- rbind(meuse, meuse[ran10, ])
coordinates(meusedup) &lt;- c("x", "y")
zd &lt;- zerodist(meusedup)
sum(abs(zd[1:n,1] - sort(ran10))) # 0!
# remove the duplicate rows:
meusedup2 &lt;- meusedup[-zd[,2], ]
summary(meusedup2)
meusedup3 &lt;- subset(meusedup, !(1:nrow(meusedup) %in% zd[,2]))
summary(meusedup3)
coordinates(meuse) &lt;- c("x", "y")
zerodist2(meuse, meuse[c(10:33,1,10),])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
