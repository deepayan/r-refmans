<!DOCTYPE html><html lang="en"><head><title>Help for package joinet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {joinet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#joinet-package'><p>Multivariate Elastic Net Regression</p></a></li>
<li><a href='#coef.joinet'><p>Extract Coefficients</p></a></li>
<li><a href='#cv.joinet'><p>Model comparison</p></a></li>
<li><a href='#joinet'><p>Multivariate Elastic Net Regression</p></a></li>
<li><a href='#predict.joinet'><p>Make Predictions</p></a></li>
<li><a href='#weights.joinet'><p>Extract Weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Penalised Multivariate Regression ('Multi-Target Learning')</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements penalised multivariate regression (i.e., for multiple outcomes and many features) by stacked generalisation (&lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtab576">doi:10.1093/bioinformatics/btab576</a>&gt;). For positively correlated outcomes, a single multivariate regression is typically more predictive than multiple univariate regressions. Includes functions for model fitting, extracting coefficients, outcome prediction, and performance measurement. For optional comparisons, install 'remMap' from GitHub (<a href="https://github.com/cran/remMap">https://github.com/cran/remMap</a>).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, palasso, cornet</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, MASS, mice, earth, spls, MRCE,
remMap, MultivariateRandomForest, SiER, mcen, GPM, RMTL, MTPS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rauschenberger/joinet">https://github.com/rauschenberger/joinet</a>,
<a href="https://rauschenberger.github.io/joinet/">https://rauschenberger.github.io/joinet/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rauschenberger/joinet/issues">https://github.com/rauschenberger/joinet/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-27 09:06:52 UTC; armin.rauschenberger</td>
</tr>
<tr>
<td>Author:</td>
<td>Armin Rauschenberger
    <a href="https://orcid.org/0000-0001-6498-4801"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Armin Rauschenberger &lt;armin.rauschenberger@uni.lu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-27 15:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='joinet-package'>Multivariate Elastic Net Regression</h2><span id='topic+joinet-package'></span>

<h3>Description</h3>

<p>The R package <code>joinet</code> implements multivariate
ridge and lasso regression using stacked generalisation.
This multivariate regression typically outperforms
univariate regression at predicting correlated outcomes.
It provides predictive and interpretable models
in high-dimensional settings.
</p>


<h3>Details</h3>

<p>Use function <code><a href="#topic+joinet">joinet</a></code> for model fitting.
Type <code>library(joinet)</code> and then <code>?joinet</code> or
<code>help("joinet)"</code> to open its help file.
</p>
<p>See the vignette for further examples.
Type <code>vignette("joinet")</code> or <code>browseVignettes("joinet")</code>
to open the vignette.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Armin Rauschenberger <a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a> (<a href="https://orcid.org/0000-0001-6498-4801">ORCID</a>)
</p>


<h3>References</h3>

<p><a href="https://orcid.org/0000-0001-6498-4801">Armin Rauschenberger</a>
and
<a href="https://orcid.org/0000-0003-3977-7469">Enrico Glaab</a>
(2021)
&quot;Predicting correlated outcomes from molecular data&quot;.
<em>Bioinformatics</em> 37(21):3889â€“3895.
<a href="https://doi.org/10.1093/bioinformatics/btab576">doi:10.1093/bioinformatics/btab576</a>.
(Click
<a href="https://orbilu.uni.lu/bitstream/10993/47788/1/joinet.pdf">here</a>
to access PDF.)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/rauschenberger/joinet">https://github.com/rauschenberger/joinet</a>
</p>
</li>
<li> <p><a href="https://rauschenberger.github.io/joinet/">https://rauschenberger.github.io/joinet/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rauschenberger/joinet/issues">https://github.com/rauschenberger/joinet/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#--- data simulation ---
n &lt;- 50; p &lt;- 100; q &lt;- 3
X &lt;- matrix(rnorm(n*p),nrow=n,ncol=p)
Y &lt;- replicate(n=q,expr=rnorm(n=n,mean=rowSums(X[,1:5])))
# n samples, p inputs, q outputs

#--- model fitting ---
object &lt;- joinet(Y=Y,X=X)
# slot "base": univariate
# slot "meta": multivariate

#--- make predictions ---
y_hat &lt;- predict(object,newx=X)
# n x q matrix "base": univariate
# n x q matrix "meta": multivariate 

#--- extract coefficients ---
coef &lt;- coef(object)
# effects of inputs on outputs
# q vector "alpha": intercepts
# p x q matrix "beta": slopes

#--- model comparison ---
loss &lt;- cv.joinet(Y=Y,X=X)
# cross-validated loss
# row "base": univariate
# row "meta": multivariate

## End(Not run)

</code></pre>

<hr>
<h2 id='coef.joinet'>Extract Coefficients</h2><span id='topic+coef.joinet'></span>

<h3>Description</h3>

<p>Extracts pooled coefficients.
(The meta learners linearly combines
the coefficients from the base learners.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joinet'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.joinet_+3A_object">object</code></td>
<td>
<p><a href="#topic+joinet">joinet</a> object</p>
</td></tr>
<tr><td><code id="coef.joinet_+3A_...">...</code></td>
<td>
<p>further arguments (not applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the pooled coefficients.
The slot <code>alpha</code> contains the intercepts
in a vector of length <code class="reqn">q</code>,
and the slot <code>beta</code> contains the slopes
in a matrix with <code class="reqn">p</code> rows (inputs) and <code class="reqn">q</code> columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
n &lt;- 50; p &lt;- 100; q &lt;- 3
X &lt;- matrix(rnorm(n*p),nrow=n,ncol=p)
Y &lt;- replicate(n=q,expr=rnorm(n=n,mean=rowSums(X[,1:5])))
object &lt;- joinet(Y=Y,X=X)
coef &lt;- coef(object)
## End(Not run)

</code></pre>

<hr>
<h2 id='cv.joinet'>Model comparison</h2><span id='topic+cv.joinet'></span>

<h3>Description</h3>

<p>Compares univariate and multivariate regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.joinet(
  Y,
  X,
  family = "gaussian",
  nfolds.ext = 5,
  nfolds.int = 10,
  foldid.ext = NULL,
  foldid.int = NULL,
  type.measure = "deviance",
  alpha.base = 1,
  alpha.meta = 1,
  compare = FALSE,
  mice = FALSE,
  cvpred = FALSE,
  times = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.joinet_+3A_y">Y</code></td>
<td>
<p>outputs<strong>:</strong>
numeric matrix with <code class="reqn">n</code> rows (samples)
and <code class="reqn">q</code> columns (outputs)</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_x">X</code></td>
<td>
<p>inputs<strong>:</strong>
numeric matrix with <code class="reqn">n</code> rows (samples)
and <code class="reqn">p</code> columns (inputs)</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_family">family</code></td>
<td>
<p>distribution<strong>:</strong>
vector of length <code class="reqn">1</code> or <code class="reqn">q</code> with entries
<code>"gaussian"</code>, <code>"binomial"</code> or <code>"poisson"</code></p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_nfolds.ext">nfolds.ext</code></td>
<td>
<p>number of external folds</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_nfolds.int">nfolds.int</code></td>
<td>
<p>number of internal folds</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_foldid.ext">foldid.ext</code></td>
<td>
<p>external fold identifiers<strong>:</strong>
vector of length <code class="reqn">n</code> with entries
between <code class="reqn">1</code> and <code>nfolds.ext</code>;
or <code>NULL</code></p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_foldid.int">foldid.int</code></td>
<td>
<p>internal fold identifiers<strong>:</strong>
vector of length <code class="reqn">n</code> with entries
between <code class="reqn">1</code> and <code>nfolds.int</code>;
or <code>NULL</code></p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_type.measure">type.measure</code></td>
<td>
<p>loss function<strong>:</strong>
vector of length <code class="reqn">1</code> or <code class="reqn">q</code> with entries
<code>"deviance"</code>, <code>"class"</code>, <code>"mse"</code> or <code>"mae"</code>
(see <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>)</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_alpha.base">alpha.base</code></td>
<td>
<p>elastic net mixing parameter for base learners<strong>:</strong>
numeric between <code class="reqn">0</code> (ridge) and <code class="reqn">1</code> (lasso)</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_alpha.meta">alpha.meta</code></td>
<td>
<p>elastic net mixing parameter for meta learners<strong>:</strong>
numeric between <code class="reqn">0</code> (ridge) and <code class="reqn">1</code> (lasso)</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_compare">compare</code></td>
<td>
<p>experimental arguments<strong>:</strong>
character vector with entries &quot;mnorm&quot;, &quot;spls&quot;, &quot;mrce&quot;,
&quot;sier&quot;, &quot;mtps&quot;, &quot;rmtl&quot;, &quot;gpm&quot; and others
(requires packages <code>spls</code>, <code>MRCE</code>, <code>SiER</code>, <code>MTPS</code>, <code>RMTL</code> or <code>GPM</code>)</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_mice">mice</code></td>
<td>
<p>missing data imputation<strong>:</strong>
logical (<code>mice=TRUE</code> requires package <code>mice</code>)</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_cvpred">cvpred</code></td>
<td>
<p>return cross-validated predictions: logical</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_times">times</code></td>
<td>
<p>measure computation time<strong>:</strong>
logical</p>
</td></tr>
<tr><td><code id="cv.joinet_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
and <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with <code class="reqn">q</code> columns,
including the cross-validated loss from the univariate models
(<code>base</code>), the multivariate models (<code>meta</code>),
and the intercept-only models (<code>none</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
n &lt;- 50; p &lt;- 100; q &lt;- 3
X &lt;- matrix(rnorm(n*p),nrow=n,ncol=p)
Y &lt;- replicate(n=q,expr=rnorm(n=n,mean=rowSums(X[,1:5])))
cv.joinet(Y=Y,X=X)
## End(Not run)

## Not run: 
# correlated features
n &lt;- 50; p &lt;- 100; q &lt;- 3
mu &lt;- rep(0,times=p)
Sigma &lt;- 0.90^abs(col(diag(p))-row(diag(p)))
X &lt;- MASS::mvrnorm(n=n,mu=mu,Sigma=Sigma)
mu &lt;- rowSums(X[,sample(seq_len(p),size=5)])
Y &lt;- replicate(n=q,expr=rnorm(n=n,mean=mu))
#Y &lt;- t(MASS::mvrnorm(n=q,mu=mu,Sigma=diag(n)))
cv.joinet(Y=Y,X=X)
## End(Not run)

## Not run: 
# other distributions
n &lt;- 50; p &lt;- 100; q &lt;- 3
X &lt;- matrix(rnorm(n*p),nrow=n,ncol=p)
eta &lt;- rowSums(X[,1:5])
Y &lt;- replicate(n=q,expr=rbinom(n=n,size=1,prob=1/(1+exp(-eta))))
cv.joinet(Y=Y,X=X,family="binomial")
Y &lt;- replicate(n=q,expr=rpois(n=n,lambda=exp(scale(eta))))
cv.joinet(Y=Y,X=X,family="poisson")
## End(Not run)

## Not run: 
# uncorrelated outcomes
n &lt;- 50; p &lt;- 100; q &lt;- 3
X &lt;- matrix(rnorm(n*p),nrow=n,ncol=p)
y &lt;- rnorm(n=n,mean=rowSums(X[,1:5]))
Y &lt;- cbind(y,matrix(rnorm(n*(q-1)),nrow=n,ncol=q-1))
cv.joinet(Y=Y,X=X)
## End(Not run)

## Not run: 
# sparse and dense models
n &lt;- 50; p &lt;- 100; q &lt;- 3
X &lt;- matrix(rnorm(n*p),nrow=n,ncol=p)
Y &lt;- replicate(n=q,expr=rnorm(n=n,mean=rowSums(X[,1:5])))
set.seed(1) # fix folds
cv.joinet(Y=Y,X=X,alpha.base=1) # lasso
set.seed(1)
cv.joinet(Y=Y,X=X,alpha.base=0) # ridge
## End(Not run)

</code></pre>

<hr>
<h2 id='joinet'>Multivariate Elastic Net Regression</h2><span id='topic+joinet'></span>

<h3>Description</h3>

<p>Implements multivariate elastic net regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinet(
  Y,
  X,
  family = "gaussian",
  nfolds = 10,
  foldid = NULL,
  type.measure = "deviance",
  alpha.base = 1,
  alpha.meta = 1,
  weight = NULL,
  sign = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joinet_+3A_y">Y</code></td>
<td>
<p>outputs<strong>:</strong>
numeric matrix with <code class="reqn">n</code> rows (samples)
and <code class="reqn">q</code> columns (outputs)</p>
</td></tr>
<tr><td><code id="joinet_+3A_x">X</code></td>
<td>
<p>inputs<strong>:</strong>
numeric matrix with <code class="reqn">n</code> rows (samples)
and <code class="reqn">p</code> columns (inputs)</p>
</td></tr>
<tr><td><code id="joinet_+3A_family">family</code></td>
<td>
<p>distribution<strong>:</strong>
vector of length <code class="reqn">1</code> or <code class="reqn">q</code> with entries
<code>"gaussian"</code>, <code>"binomial"</code> or <code>"poisson"</code></p>
</td></tr>
<tr><td><code id="joinet_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds</p>
</td></tr>
<tr><td><code id="joinet_+3A_foldid">foldid</code></td>
<td>
<p>fold identifiers<strong>:</strong>
vector of length <code class="reqn">n</code> with entries between <code class="reqn">1</code> and <code>nfolds</code>;
or <code>NULL</code> (balance)</p>
</td></tr>
<tr><td><code id="joinet_+3A_type.measure">type.measure</code></td>
<td>
<p>loss function<strong>:</strong>
vector of length <code class="reqn">1</code> or <code class="reqn">q</code> with entries
<code>"deviance"</code>, <code>"class"</code>, <code>"mse"</code> or <code>"mae"</code>
(see <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>)</p>
</td></tr>
<tr><td><code id="joinet_+3A_alpha.base">alpha.base</code></td>
<td>
<p>elastic net mixing parameter for base learners<strong>:</strong>
numeric between <code class="reqn">0</code> (ridge) and <code class="reqn">1</code> (lasso)</p>
</td></tr>
<tr><td><code id="joinet_+3A_alpha.meta">alpha.meta</code></td>
<td>
<p>elastic net mixing parameter for meta learners<strong>:</strong>
numeric between <code class="reqn">0</code> (ridge) and <code class="reqn">1</code> (lasso)</p>
</td></tr>
<tr><td><code id="joinet_+3A_weight">weight</code></td>
<td>
<p>input-output relations<strong>:</strong>
matrix with <code class="reqn">p</code> rows (inputs) and <code class="reqn">q</code> columns (outputs)
with entries <code class="reqn">0</code> (exclude) and <code class="reqn">1</code> (include),
or <code>NULL</code> (see details)</p>
</td></tr>
<tr><td><code id="joinet_+3A_sign">sign</code></td>
<td>
<p>output-output relations<strong>:</strong>
matrix with <code class="reqn">q</code> rows (&quot;meta-inputs&quot;) and <code class="reqn">q</code> columns (outputs), 
with entries <code class="reqn">-1</code> (negative), <code class="reqn">0</code> (none),
<code class="reqn">1</code> (positive) and <code class="reqn">NA</code> (any),
or <code>NULL</code> (see details)</p>
</td></tr>
<tr><td><code id="joinet_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="glmnet.html#topic+glmnet">glmnet</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>input-output relations:</strong>
In this matrix with <code class="reqn">p</code> rows and <code class="reqn">q</code> columns,
the entry in the <code class="reqn">j</code>th row and the <code class="reqn">k</code>th column
indicates whether the <code class="reqn">j</code>th input may be used for 
modelling the <code class="reqn">k</code>th output
(where <code class="reqn">0</code> means &quot;exclude&quot; and
<code class="reqn">1</code> means &quot;include&quot;).
By default (<code>sign=NULL</code>),
all entries are set to <code class="reqn">1</code>.
</p>
<p><strong>output-output relations:</strong>
In this matrix with <code class="reqn">q</code> rows and <code class="reqn">q</code> columns,
the entry in the <code class="reqn">l</code>th row and the <code class="reqn">k</code>th column
indicates how the <code class="reqn">l</code>th output may be used for
modelling the <code class="reqn">k</code>th output
(where <code class="reqn">-1</code> means negative effect,
<code class="reqn">0</code> means no effect,
<code class="reqn">1</code> means positive effect,
and <code class="reqn">NA</code> means any effect).
</p>
<p>There are three short-cuts for filling up this matrix:
(1) <code>sign=1</code> sets all entries to <code class="reqn">1</code> (non-negativity constraints).
This is useful if all pairs of outcomes
are assumed to be <em>positively</em> correlated
(potentially after changing the sign of some outcomes).
(2) <code>code=NA</code> sets all diagonal entries to <code class="reqn">1</code>
and all off-diagonal entries to <code>NA</code> (no constraints).
(3) <code>sign=NULL</code> uses Spearman correlation to determine the entries,
with <code class="reqn">-1</code> for significant negative, <code class="reqn">0</code> for insignificant,
<code class="reqn">1</code> for significant positive correlations.
</p>
<p><strong>elastic net:</strong>
<code>alpha.base</code> controls input-output effects,
<code>alpha.meta</code> controls output-output effects;
lasso renders sparse models (<code>alpha</code><code class="reqn">=1</code>),
ridge renders dense models (<code>alpha</code><code class="reqn">=0</code>)
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>joinet</code>.
Available methods include
<code><a href="#topic+predict.joinet">predict</a></code>,
<code><a href="#topic+coef.joinet">coef</a></code>,
and <code><a href="#topic+weights.joinet">weights</a></code>.
The slots <code>base</code> and <code>meta</code> each contain
<code class="reqn">q</code> <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>-like objects.
</p>


<h3>References</h3>

<p><a href="https://orcid.org/0000-0001-6498-4801">Armin Rauschenberger</a>
and
<a href="https://orcid.org/0000-0003-3977-7469">Enrico Glaab</a>
(2021)
&quot;Predicting correlated outcomes from molecular data&quot;.
<em>Bioinformatics</em> 37(21):3889â€“3895.
<a href="https://doi.org/10.1093/bioinformatics/btab576">doi:10.1093/bioinformatics/btab576</a>.
(Click
<a href="https://orbilu.uni.lu/bitstream/10993/47788/1/joinet.pdf">here</a>
to access PDF.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.joinet">cv.joinet</a></code>, vignette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
n &lt;- 50; p &lt;- 100; q &lt;- 3
X &lt;- matrix(rnorm(n*p),nrow=n,ncol=p)
Y &lt;- replicate(n=q,expr=rnorm(n=n,mean=rowSums(X[,1:5])))
object &lt;- joinet(Y=Y,X=X)
## End(Not run)

## Not run: 
browseVignettes("joinet") # further examples
## End(Not run)

</code></pre>

<hr>
<h2 id='predict.joinet'>Make Predictions</h2><span id='topic+predict.joinet'></span>

<h3>Description</h3>

<p>Predicts outcome from features with stacked model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joinet'
predict(object, newx, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.joinet_+3A_object">object</code></td>
<td>
<p><a href="#topic+joinet">joinet</a> object</p>
</td></tr>
<tr><td><code id="predict.joinet_+3A_newx">newx</code></td>
<td>
<p>covariates<strong>:</strong>
numeric matrix with <code class="reqn">n</code> rows (samples)
and <code class="reqn">p</code> columns (variables)</p>
</td></tr>
<tr><td><code id="predict.joinet_+3A_type">type</code></td>
<td>
<p>character &quot;link&quot; or &quot;response&quot;</p>
</td></tr>
<tr><td><code id="predict.joinet_+3A_...">...</code></td>
<td>
<p>further arguments (not applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns predictions from base and meta learners.
The slots <code>base</code> and <code>meta</code> each contain a matrix
with <code class="reqn">n</code> rows (samples) and <code class="reqn">q</code> columns (variables).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
n &lt;- 50; p &lt;- 100; q &lt;- 3
X &lt;- matrix(rnorm(n*p),nrow=n,ncol=p)
Y &lt;- replicate(n=q,expr=rnorm(n=n,mean=rowSums(X[,1:5])))
Y[,1] &lt;- 1*(Y[,1]&gt;median(Y[,1]))
object &lt;- joinet(Y=Y,X=X,family=c("binomial","gaussian","gaussian"))
predict(object,newx=X)
## End(Not run)

</code></pre>

<hr>
<h2 id='weights.joinet'>Extract Weights</h2><span id='topic+weights.joinet'></span>

<h3>Description</h3>

<p>Extracts coefficients from the meta learner,
i.e. the weights for the base learners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joinet'
weights(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights.joinet_+3A_object">object</code></td>
<td>
<p><a href="#topic+joinet">joinet</a> object</p>
</td></tr>
<tr><td><code id="weights.joinet_+3A_...">...</code></td>
<td>
<p>further arguments (not applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with
<code class="reqn">1+q</code> rows and <code class="reqn">q</code> columns.
The first row contains the intercepts,
and the other rows contain the slopes,
which are the effects of the outcomes
in the row on the outcomes in the column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
n &lt;- 50; p &lt;- 100; q &lt;- 3
X &lt;- matrix(rnorm(n*p),nrow=n,ncol=p)
Y &lt;- replicate(n=q,expr=rnorm(n=n,mean=rowSums(X[,1:5])))
object &lt;- joinet(Y=Y,X=X)
weights(object)
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
