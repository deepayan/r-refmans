<!DOCTYPE html><html><head><title>Help for package lmf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lmf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lmf-package'>
<p>Functions for estimation and inference of selection in age-structured populations</p></a></li>
<li><a href='#atCfn'>
<p>Calculate corrected temporal mean coefficients of selection</p></a></li>
<li><a href='#boot.lmf'>
<p>Bootstrap resampling for class &quot;lmf&quot;</p></a></li>
<li><a href='#ci.boot.lmf'>
<p>Confidence intervals for class &quot;boot.lmf&quot;</p></a></li>
<li><a href='#eigenl'>
<p>Calculating lambda, u and v</p></a></li>
<li><a href='#fs'>
<p>Estimate temporal coefficients of selection</p></a></li>
<li><a href='#inv'>
<p>Calculate the inverse of a matrix</p></a></li>
<li><a href='#lm.extract'>
<p>Extract linear regression components</p></a></li>
<li><a href='#lmf'>
<p>Fitting age-structured selection model</p></a></li>
<li><a href='#lnL.M'>
<p>Maximum likelihood function for temporal coefficients of selection</p></a></li>
<li><a href='#nearPD'>
<p>Find nearest positive definite matrix</p></a></li>
<li><a href='#nfs'>
<p>Estimate temporal coefficients of selection assuming no fluctuating selection</p></a></li>
<li><a href='#plot.boot.lmf'>
<p>Plotting function for class &quot;boot.lmf&quot;</p></a></li>
<li><a href='#plot.lmf'>
<p>Plot diagnostics for an lmf object</p></a></li>
<li><a href='#projection'>
<p>The projection matrix</p></a></li>
<li><a href='#rmnorm'>
<p>Generate random numbers from the multivariate normal distribution</p></a></li>
<li><a href='#se'>
<p>Standard error</p></a></li>
<li><a href='#sparrowdata'>
<p>House Sparrow data set</p></a></li>
<li><a href='#summary.boot.lmf'>
<p>Summarizing bootstraps of lmf fits</p></a></li>
<li><a href='#summary.lmf'>
<p>Summarizing lmf fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Estimation and Inference of Selection in
Age-Structured Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2013-10-31</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Kvalnes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Kvalnes &lt;thomas.kvalnes@ntnu.no&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for estimation and statistical
               inference on directional and fluctuating selection in age-structured
               populations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-24 11:34:41 UTC; hornik</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-24 11:41:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='lmf-package'>
Functions for estimation and inference of selection in age-structured populations
</h2><span id='topic+lmf-package'></span>

<h3>Description</h3>

<p>This R package estimates directional and fluctuating selection in
age-structured populations and provides methods for statistical inference using
the procedures developed by Engen et al. 2012. Also compatible with
data without age-structure.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> lmf</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2013-10-31</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Thomas Kvalnes, Centre for Biodiversity Dynamics, Norwegian University of
Science and Technology, N-7491 Trondheim, Norway
</p>
<p>Maintainer: Thomas Kvalnes &lt;thomas.kvalnes@ntnu.no&gt;
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>

<hr>
<h2 id='atCfn'>
Calculate corrected temporal mean coefficients of selection
</h2><span id='topic+atCfn'></span>

<h3>Description</h3>

<p>Calculate the temporal mean coefficients of selection (alpha) corrected for
sampling error, i.e. the best linear predictor (BLP) of alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atCfn(aM, M, At, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atCfn_+3A_am">aM</code></td>
<td>
<p>the estimated temporal mean selection coefficients.
</p>
</td></tr>
<tr><td><code id="atCfn_+3A_m">M</code></td>
<td>
<p>the estimated temporal covariance matrix (fluctuating selection).
</p>
</td></tr>
<tr><td><code id="atCfn_+3A_at">At</code></td>
<td>
<p>a list containing the named variance-covariance matrix for
each year. Sorted by year.
</p>
</td></tr>
<tr><td><code id="atCfn_+3A_at">at</code></td>
<td>
<p>a list containing the named vectors of the estimated selection
coefficient for each year. Sorted by year.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further details are found in Engen et al. 2012.
</p>


<h3>Value</h3>

<p>Returns a vector with the named best linear predictors for the temporal mean
coefficients of selection (alpha).
</p>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmf">lmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Extract aM, M, At and at
aM &lt;- lmf.1$aM
M &lt;- lmf.1$M
At &lt;- lmf.1$At
at &lt;- lmf.1$at
#Calculate Best Linear Predictor (BLP)
atCfn(aM = aM, M = M, At = At, at = at)
</code></pre>

<hr>
<h2 id='boot.lmf'>
Bootstrap resampling for class &quot;lmf&quot;
</h2><span id='topic+boot.lmf'></span><span id='topic+print.boot.lmf'></span>

<h3>Description</h3>

<p>Generates bootstrap replicates of the estimated parameters in a &quot;lmf&quot; model.
Ordinary bootstrap is performed for the projection matrix, while both
parametric and ordinary (non-parametric) resampling is available for the
remaining parameters in the model. In addition, bootstrapping under any choosen
null hypothesis is available for hypothesis testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.lmf(object, nboot = 1000, what = c("projection", "alpha", "H0", "all"),
  asim = c("ordinary", "parametric"), sig.dj = TRUE,
  H0exp = list(alpha = NULL, M = NULL),
  H0con = c("fs", "nfs", "ds", "nds"), method = c("BFGS"),
  control = list(maxit = 500, reltol = sqrt(.Machine$double.eps)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.lmf_+3A_object">object</code></td>
<td>
<p>a fitted object of of class &quot;lmf&quot;.
</p>
</td></tr>
<tr><td><code id="boot.lmf_+3A_nboot">nboot</code></td>
<td>
<p>the number og bootstraps desired.
</p>
</td></tr>
<tr><td><code id="boot.lmf_+3A_what">what</code></td>
<td>
<p>which set of parameters to bootstrap. Options are &quot;projection&quot; to
only resample projection matrix, growth rate <code class="reqn">(\lambda)</code>, stable age
distribution (u) and reproductive values (v). &quot;alpha&quot; to resample demographic
and environmental variances as well as all the estimates selection parameters.
&quot;H0&quot; to resample temporal coefficients of selection under a given null
hypothesis (This options requires specification of the additional
arguments <code>H0exp</code> and <code>H0con</code>). &quot;all&quot; (default) to resample all the
above mentioned parameters (also here <code>H0exp</code> and <code>H0con</code> must be
specified for hypothesis testing or only &quot;projection&quot; and &quot;alpha&quot; will
be resampled).
</p>
</td></tr>
<tr><td><code id="boot.lmf_+3A_asim">asim</code></td>
<td>
<p>the type of bootstrap for the parameters other than the
projection matrix (which is always ordinary bootstrapped). Options are
&quot;parametric&quot; (default) and &quot;ordinary&quot;.
</p>
</td></tr>
<tr><td><code id="boot.lmf_+3A_sig.dj">sig.dj</code></td>
<td>
<p>logical, <code>TRUE</code>(default) to include uncertainty in the
estimation of the demographic variance when bootstrapping alpha estimates.
</p>
</td></tr>
<tr><td><code id="boot.lmf_+3A_h0exp">H0exp</code></td>
<td>
<p>a list with the first element a vector containing the expected
temproal mean coefficients of selection (alpha) and the second element a
matrix containing the elements of the expected temporal variance-covariance
matrix (M) under the null hypothesis. This argument needs to be specified to
perform hypothesis testing.
</p>
</td></tr>
<tr><td><code id="boot.lmf_+3A_h0con">H0con</code></td>
<td>
<p>the conditions under which the null hypothesis should be tested.
Options are &quot;fs&quot; to assume fluctuating selection, &quot;nfs&quot; to assume no
fluctuating selection, &quot;ds&quot; to assume directional selection and &quot;nds&quot; to
assume no directional selection. &quot;nds&quot; is not implemented due to increased
risk of Type I error if the assumption is not correct, but is included
here for completeness.
</p>
</td></tr>
<tr><td><code id="boot.lmf_+3A_method">method</code></td>
<td>
<p>defines what optimalization algorithm to be used in the
maximization of the loglikelihood. Alternatives are: &quot;Nelder-Mead&quot;,
&quot;BFGS&quot; (default), &quot;CG&quot;, &quot;L-BFGS-B&quot; and &quot;SANN&quot;. Not all are applicable here.
See <code>?optim</code> for details.
</p>
</td></tr>
<tr><td><code id="boot.lmf_+3A_control">control</code></td>
<td>
<p>a list of control parameters for the maximization of the
likelihood. <code>maxit</code> sets the maximum number of iterations to use before
convergence and <code>reltol</code> sets the relative threshold for improvement in
the likelihood which desides whether to continue maximation or end.
See <code>?optim</code> for details.
</p>
</td></tr>
<tr><td><code id="boot.lmf_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to optim for the maximization
of the loglikelihood. See <code>?optim</code> for options.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resampling procedures preserve the observed ratios of the different age
classes during resampling of the projection matrix.
</p>
<p>Ordinary bootstrap will often be subject to bias due to few years of data in
most available data sets within biology (generally &lt;&lt; 40), thus the parametric
bootstrap is recomended for most purposes.
</p>
<p>The bootstrap procedure is closely associated with the method deployed in
<code>lmf</code> and further details can be found in Engen et al. 2012.
</p>
<p>Different from Engen et al. 2012, the sigma2.dj is defined as independent gamma
distributed variables with <em>shape</em> = <code class="reqn">\frac{(EX)^2}{Var(X)}</code> and
<em>rate</em> = <code class="reqn">\frac{EX}{Var(X)}</code>. Where <em>X</em> = <code class="reqn">\hat\sigma^2_{dj}</code> and 
using the mean and variance from in the paper.
</p>


<h3>Value</h3>

<p><code>boot.lmf</code> returns a object of class &quot;boot.lmf&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and
print a summary of the bootstrap replicates and to print results from tests of
hypotheses. For construction of confidene intervals for the parameters the
function <code>ci.boot.lmf</code> is used.
</p>
<p>An object of class &quot;boot.lmf&quot; is a list containing at most the following
components:
</p>
<table>
<tr><td><code>running.time</code></td>
<td>
<p>the total time used for computation.</p>
</td></tr>
<tr><td><code>optim.time</code></td>
<td>
<p>the time used for maximation of the loglikelihood.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>asim</code></td>
<td>
<p>the value specified of asim.</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>the number of bootstrap replicates generated.</p>
</td></tr>
<tr><td><code>uage</code></td>
<td>
<p>the unique age classes in the data set.</p>
</td></tr>
<tr><td><code>nage</code></td>
<td>
<p>the number of unique age classes in the data set.</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>the number of parameters in the model.</p>
</td></tr>
<tr><td><code>uyear</code></td>
<td>
<p>the unique years in the data set.</p>
</td></tr>
<tr><td><code>nyear</code></td>
<td>
<p>the number of unique years in the data set.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>the estimated projection matrix.</p>
</td></tr>
<tr><td><code>lboot</code></td>
<td>
<p>the bootstrap replicates of the projection matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the deterministic multiplicative growth rate of the population.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the stable age distribution.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the vector of reproductive values for each age class.</p>
</td></tr>
<tr><td><code>luvboot</code></td>
<td>
<p>the bootstrap replicates of <code class="reqn">\lambda</code>, u and v.</p>
</td></tr>
<tr><td><code>sigma2.dj</code></td>
<td>
<p>a list containing the demographic variance for each age class.
Sorted by age class.</p>
</td></tr>
<tr><td><code>djboot</code></td>
<td>
<p>the bootstrap replicates of <code>sigma2.dj</code>.</p>
</td></tr>
<tr><td><code>sigma2.d</code></td>
<td>
<p>the total demographic variance of the population.</p>
</td></tr>
<tr><td><code>dboot</code></td>
<td>
<p>the bootstrap replicates of <code>sigma2.d</code>.</p>
</td></tr>
<tr><td><code>Atboot</code></td>
<td>
<p>the bootstrap replicates of the yearly variance-covariance
matrices. The unscaled variance-covariance matrices are kept constant, but
each set of yearly estimates are scaled by the bootstrapped <code>sigma2.dj</code>.</p>
</td></tr>
<tr><td><code>atboot</code></td>
<td>
<p>the bootstrap replicates of the yearly coefficients of
selection. This can be performed &quot;parametric&quot;(default) or &quot;ordinary&quot;.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the estimated temporal covariance matrix (fluctuating selection).</p>
</td></tr>
<tr><td><code>aM</code></td>
<td>
<p>the estimated temporal mean coefficients of selection.</p>
</td></tr>
<tr><td><code>Mboot</code></td>
<td>
<p>the bootstrap replicates of <code>M</code>.</p>
</td></tr>
<tr><td><code>aMboot</code></td>
<td>
<p>the bootstrap replicates of <code>aM</code>.</p>
</td></tr>
<tr><td><code>atCboot</code></td>
<td>
<p>the bootstrap replicates of the best linear predictor for
the estimated yearly coefficients of selection (i.e. corrected for
sampling errors).</p>
</td></tr>
<tr><td><code>Anf</code></td>
<td>
<p>the estimated temporal covariance matrix assuming no
fluctuating selection.</p>
</td></tr>
<tr><td><code>anf</code></td>
<td>
<p>the estimated temporal mean selection coefficients assuming
no fluctuating selection.</p>
</td></tr>
<tr><td><code>Anfboot</code></td>
<td>
<p>the bootstrap replicates of <code>Anf</code>.</p>
</td></tr>
<tr><td><code>anfboot</code></td>
<td>
<p>the bootstrap replicates of <code>anf</code>.</p>
</td></tr>
<tr><td><code>sigma2.e</code></td>
<td>
<p>the environmental variance of the population.</p>
</td></tr>
<tr><td><code>eboot</code></td>
<td>
<p>the bootstrap replicates of <code>sigma2.e</code>.</p>
</td></tr>
<tr><td><code>eCboot</code></td>
<td>
<p>the bootstrap replicates of <code>sigma2.eC</code>.</p>
</td></tr>
<tr><td><code>H0aMboot</code></td>
<td>
<p>the bootstrap replicates of <code>aM</code> under the
specified null hypothesis <code>H0exp</code> and the assumption of fluctuating
selection (<code>Hexp = "fs"</code>).</p>
</td></tr>
<tr><td><code>H0anfboot</code></td>
<td>
<p>the bootstrap replicates of <code>anf</code> under the
specified null hypothesis <code>H0exp</code> and the assumption of no fluctuating
selection (<code>Hexp = "nfs"</code>).</p>
</td></tr>
<tr><td><code>H0atnfboot</code></td>
<td>
<p>the bootstrap replicates of <code>at</code> under the
specified null hypothesis <code>H0exp</code> and the assumption of directional
selection (<code>Hexp = "ds"</code>). These bootstrap replicates are used to
generate <code>H0Mnfboot</code>.</p>
</td></tr>
<tr><td><code>H0Mnfboot</code></td>
<td>
<p>the bootstrap replicates of <code>M</code> under the
specified null hypothesis <code>H0exp</code> and the assumption of directional
selection (<code>Hexp = "ds"</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmf">lmf</a></code>, <code><a href="#topic+ci.boot.lmf">ci.boot.lmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Bootstrap parameters
b.1 &lt;- boot.lmf(object = lmf.1, nboot = 10, sig.dj = TRUE,
 what = "all", asim = "parametric")
#Print
b.1
#Summary
summary(b.1)
#View density plots
plot(b.1)
#Test of hypoteses
b.2 &lt;- boot.lmf(object = lmf.1, nboot = 10, sig.dj = TRUE,
 what = "H0", H0exp = list(rep(0, 3), matrix(0, ncol = 3, nrow = 3)),
 asim = "parametric")
#Summary
summary(b.2)
</code></pre>

<hr>
<h2 id='ci.boot.lmf'>
Confidence intervals for class &quot;boot.lmf&quot;
</h2><span id='topic+ci.boot.lmf'></span><span id='topic+print.ci.boot.lmf'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs) for the bootstrapped parameters in
an object of class &quot;boot.lmf&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.boot.lmf(x, clevel = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.boot.lmf_+3A_x">x</code></td>
<td>
<p>an object of class &quot;boot.lmf&quot;.
</p>
</td></tr>
<tr><td><code id="ci.boot.lmf_+3A_clevel">clevel</code></td>
<td>
<p>the confidence level required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ci.boot.lmf</code> construct confidence intervals (CIs) from the quantiles of the
bootstrap replicates and uses the function <code>quantile</code>.
</p>
<p>See Engen et al. 2012 for details on the method for estimating and bootstrapping
the parameters.
</p>


<h3>Value</h3>

<p><code>ci.boot.lmf</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>the number of bootstrap replicates generated.</p>
</td></tr>
<tr><td><code>what</code></td>
<td>
<p>which set of parameters which has been to bootstrapped. See
<code>?boot.lmf</code> for details.</p>
</td></tr>
<tr><td><code>clevel</code></td>
<td>
<p>the confidence level specified.</p>
</td></tr>
<tr><td><code>uage</code></td>
<td>
<p>the unique age classes in the data set.</p>
</td></tr>
<tr><td><code>nage</code></td>
<td>
<p>the number of unique age classes in the data set.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>CI for the projection matrix.</p>
</td></tr>
<tr><td><code>luv</code></td>
<td>
<p>CI for <code class="reqn">\lambda</code>, u and v.</p>
</td></tr>
<tr><td><code>sigma2.dj</code></td>
<td>
<p>CI for the demographic variance for each age class.</p>
</td></tr>
<tr><td><code>sigma2.d</code></td>
<td>
<p>CI for the total demographic variance</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>CI for the estimated temporal covariance matrix.</p>
</td></tr>
<tr><td><code>aM</code></td>
<td>
<p>CI for the estimated temporal mean coefficients of selection</p>
</td></tr>
<tr><td><code>sigma2.e</code></td>
<td>
<p>CI for the environmental variance</p>
</td></tr>
<tr><td><code>Anf</code></td>
<td>
<p>CI for the estimated temporal covariance matrix assuming no
fluctuating selection.</p>
</td></tr>
<tr><td><code>anf</code></td>
<td>
<p>CI for the estimated temporal mean selection coefficients assuming
no fluctuating selection.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmf">lmf</a></code>, <code><a href="#topic+boot.lmf">boot.lmf</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Bootstrap parameters
b.1 &lt;- boot.lmf(object = lmf.1, nboot = 10, sig.dj = TRUE,
 what = "all", asim = "parametric")
#Generate CI
ci.boot.lmf(b.1)
</code></pre>

<hr>
<h2 id='eigenl'>
Calculating lambda, u and v
</h2><span id='topic+eigenl'></span>

<h3>Description</h3>

<p>Calculates the deterministic multiplicative growth rate (lambda), the
stable age distribution (u) and the reproductive values (v) from a
given projection matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenl(pm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenl_+3A_pm">pm</code></td>
<td>

<p>a projection matrix. For instance, the output from the function <code>procomp</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a projection matrix (l), this function calculates the real dominant
eigenvalue (lambda), and the left (u) and right (v) eigenvectors, defined by
l*u = lambda*u and v*l = lambda*v.
</p>


<h3>Value</h3>

<p><code>eigenl</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>the deterministic multiplicative growth rate of the population
from which the projection matrix was estimated</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the stable age distribution of the population from which the
projection matrix was estimated</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the reproductive values of the population from which the projection
matrix was estimated</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+procomp">procomp</a></code>, <code><a href="#topic+promat">promat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#The uniue age classes
unique.age &lt;- unique(sparrowdata$age)
#Estimate the projection matrix
pro.comp &lt;- procomp(a = sparrowdata, uage = unique.age)
projection.matrix &lt;- promat(pc = pro.comp, nage = length(unique.age))
#Estimate lambda, u and v
eigenl(pm = projection.matrix)
</code></pre>

<hr>
<h2 id='fs'>
Estimate temporal coefficients of selection
</h2><span id='topic+fs'></span>

<h3>Description</h3>

<p><code>fs</code> is a function which estimates the temporal covariance matrix (i.e.
fluctuating selection) and the temporal mean alpha coefficients (i.e. directional
selection) through a numerical maximization of a loglikelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs(At, at, npar, nyear, method, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs_+3A_at">At</code></td>
<td>
<p>a list containing the named yearly variance-covariance matrices.
Sorted by year.
</p>
</td></tr>
<tr><td><code id="fs_+3A_at">at</code></td>
<td>
<p>a list containing the named yearly vectors of the estimated selection
coefficients. Sorted by year.
</p>
</td></tr>
<tr><td><code id="fs_+3A_npar">npar</code></td>
<td>
<p>the number of parameters in the model for the estimates selection
coefficients.
</p>
</td></tr>
<tr><td><code id="fs_+3A_nyear">nyear</code></td>
<td>
<p>the number of years with estimates of selection.
</p>
</td></tr>
<tr><td><code id="fs_+3A_method">method</code></td>
<td>
<p>defines what optimalization algorithm to be used in the maximization of the
loglikelihood. Alternatives are: &quot;Nelder-Mead&quot;, &quot;BFGS&quot; (default), &quot;CG&quot;,
&quot;L-BFGS-B&quot; and &quot;SANN&quot;. Not all are applicable here. See <code>?optim</code> for details.
</p>
</td></tr>
<tr><td><code id="fs_+3A_control">control</code></td>
<td>
<p>a list of control parameters for the maximization of the likelihood.
<code>maxit</code> sets the maximum number of iterations to use before convergence
and <code>reltol</code> sets the relative threshold for improvement in the likelihood
which desides whether to continue maximation or end. See <code>?optim</code>
for details.
</p>
</td></tr>
<tr><td><code id="fs_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to optim for the maximization of the
loglikelihood. See <code>?optim</code> for options.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fs</code> is used internally in <code>lmf</code> when estimating temporal coefficients
of selection, but given the right data can be executed as a standalone. The input
to the arguments At and at are estimated within <code>lmf</code> by correctly combining
estimates of coefficients and variance-covariance within each age class and year
to a estimate for each year.
</p>
<p><code>fs</code> used <code>optim</code> for the numerical maximization of the
log likelihood function <code>lnL.M</code>. Problems of non-positive definite matrices
appearing as maximas, due to numerical rounding, are solved with <code>nearPD</code>,
which implement the smallest possible numerical changes of some componets of the
matrices to achive positive definiteness. These changes does not affect the
results in any significant way.
</p>
<p>Engen et al. 2012 describe the maximum likelihood method in details.
</p>


<h3>Value</h3>

<p><code>fs</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>convergence</code></td>
<td>
<p>&quot;yes&quot; indicates that the numerical maximation of the
likelihood successfully converged before reaching the iteration limit <code>maxit</code>.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations of the function in the numerical
maximation of the likelihood.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the estimated temporal covariance matrix (fluctuating selection).</p>
</td></tr>
<tr><td><code>aM</code></td>
<td>
<p>the estimated temporal mean selection coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmf">lmf</a></code>, <code><a href="#topic+lnL.M">lnL.M</a></code>, <code><a href="#topic+nearPD">nearPD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Extract At and at
At &lt;- lmf.1$At
at &lt;- lmf.1$at
#Estimate temporal selection coefficients
flusel &lt;- fs(At = At, at = at, npar = 3, nyear = 7, method = "BFGS",
  control = list(maxit = 500, reltol = sqrt(.Machine$double.eps)))
#View output
str(flusel)
flusel
</code></pre>

<hr>
<h2 id='inv'>
Calculate the inverse of a matrix
</h2><span id='topic+inv'></span>

<h3>Description</h3>

<p>Calculates the inverse of a symmetric positive definite matrix from its
Cholesky composition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_+3A_a">a</code></td>
<td>
<p>a symmetric positive definite matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an interface to the LAPACK routine DPOTRI implemented in the function
<code>chol2inv</code>. The function calculates cholesky decomposition of the given
matrix and inputs this into <code>chol2inv</code>.
</p>


<h3>Value</h3>

<p>The inverse of the given matrix.
</p>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Anderson. E. et al. 1999. LAPACK Users' Guide. Third Edition.
SIAM [Available online at: http://www.netlib.org/lapack/lug/lapack_lug.html].
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a></code>, <code><a href="base.html#topic+chol2inv">chol2inv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example matrix
mat &lt;- matrix(c(1, 0.5, -3, 0.5, 3, 0.5, -3, 0.5, 12), ncol = 3)
#Show that it is positive definite
eigen(mat)$values
#Calculate inverse
inv(mat)
</code></pre>

<hr>
<h2 id='lm.extract'>
Extract linear regression components
</h2><span id='topic+lm.extract'></span>

<h3>Description</h3>

<p><code>lm.extract</code> fit a linear model and extract coefficients,
unscaled covariance matrix, residual variance, fitted values, residuals, degrees of freedom, and
leverage and cook's distance for each data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.extract(formula, data, na.action = na.exclude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.extract_+3A_formula">formula</code></td>
<td>

<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a
symbolic description of the model to be fitted on the format <code>response ~ terms</code>.
</p>
</td></tr>
<tr><td><code id="lm.extract_+3A_data">data</code></td>
<td>

<p>a data set containing the variables in the model.
</p>
</td></tr>
<tr><td><code id="lm.extract_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicate what should happend when the data contain NAs. The
default is <code>na.exclude</code> (see <code>?na.fail</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lm.extract</code> works through calls to <code>lm</code>,  <code>residuals</code>, <code>predict</code>,
<code>df.residuals</code>, <code>deviance</code>, <code>vcov</code>, <code>lm.influence</code> and <code>cooks.distance</code>.
Consult these functions for further details. The function was written for internal
use with <code>lmf</code>, but can be executed as a standalone.
</p>


<h3>Value</h3>

<p><code>lm.extract</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>ajt</code></td>
<td>
<p>a named vector of coefficients</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>the residuals</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted values</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>the degrees of freedom</p>
</td></tr>
<tr><td><code>sigma.djt</code></td>
<td>
<p>the residual standard error</p>
</td></tr>
<tr><td><code>Ajt.us</code></td>
<td>
<p>a named unscaled variance-covariance matrix</p>
</td></tr>
<tr><td><code>leverage</code></td>
<td>
<p>the estimated leverage for each data point. I.e. a vector
containing the diagonal of the 'hat' matrix (see <code>lm.influence?</code>)</p>
</td></tr>
<tr><td><code>cook</code></td>
<td>
<p>the estimated Cook's distance for each data point (see <code>cooks.distance?</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+summary.lm">summary.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulated data
xx &lt;- rnorm(n = 100, mean = 10, sd = 2)
yy &lt;- xx + 10 + rnorm(n = 100, 0, 2)
#Extract linear model components
extract &lt;- lm.extract(formula = yy ~ xx, data = data.frame(xx = xx, yy = yy))
str(extract)
#Plot the xx-yy relation
plot(xx, yy)
abline(a = extract$ajt[1], b = extract$ajt[2])
</code></pre>

<hr>
<h2 id='lmf'>
Fitting age-structured selection model
</h2><span id='topic+lmf'></span><span id='topic+print.lmf'></span>

<h3>Description</h3>

<p><code>lmf</code> fit linear models within each combination of year and age class and
estimates coefficients of selection using maximum likelihood procedures.
<code>lmf</code> is compatible with populations without age-structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmf(formula, age, year, data, na.action = na.exclude,
method = c("BFGS"), control = list(maxit = 500,
reltol = sqrt(.Machine$double.eps)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmf_+3A_formula">formula</code></td>
<td>

<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a
symbolic description of the model to be fitted when estimating coefficients of
selection. Format: response ~ terms. The detail of model
specification are given under 'Details'.
</p>
</td></tr>
<tr><td><code id="lmf_+3A_age">age</code></td>
<td>

<p>used to define the name of the age column in the data set. Use NULL
if no age data are available in the data set.
</p>
</td></tr>
<tr><td><code id="lmf_+3A_year">year</code></td>
<td>

<p>used to define the name of the year column in the data set.
</p>
</td></tr>
<tr><td><code id="lmf_+3A_data">data</code></td>
<td>

<p>data set with individual ids (optional), year of reproduction (year),
maternal age (age; may be omitted if a model without age is desired), 
number of female offspring (recruits), survival to the next reproductive
event (survival) and phenotypic measurements. Age classes should have a
natural order of increasing age. E.g. 1, 2, 3, ...
</p>
</td></tr>
<tr><td><code id="lmf_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicate what should happend when the data contain NAs. The
default is <code>na.exclude</code> (see <code>?na.fail</code>).
</p>
</td></tr>
<tr><td><code id="lmf_+3A_method">method</code></td>
<td>

<p>defines what optimalization algorithm to be used in the maximization of the
loglikelihood. Alternatives are: &quot;Nelder-Mead&quot;, &quot;BFGS&quot; (default), &quot;CG&quot;,
&quot;L-BFGS-B&quot; and &quot;SANN&quot;. Not all are applicable here. See <code>?optim</code> for details.
</p>
</td></tr>
<tr><td><code id="lmf_+3A_control">control</code></td>
<td>

<p>a list of control parameters for the maximization of the likelihood.
<code>maxit</code> sets the maximum number of iterations to use before convergence
and <code>reltol</code> sets the relative threshold for improvement in the
likelihood which desides whether to continue maximation or end.
See <code>?optim</code> for details.
</p>
</td></tr>
<tr><td><code id="lmf_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to optim for the maximization of the
loglikelihood. See <code>?optim</code> for options.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lmf</code> use formulas for model specification. These should be formatted as
decribed under arguments. Note however that your response should be specified
as a two-column matrix with the columns recruits and survival. The first column
should give the number of recruits that an individual produced a given year and
the second column should contain information on whether the individual survived
or not (1 or 0) to the next breeding season. These two columns will be used to
calculate the individual reproductive values (Wj) which the model will substitute
for the response in the age and year specific linear regressions
(i.e. <code>Wj ~ terms</code>).
</p>


<h3>Value</h3>

<p><code>lmf</code> returns an object of class &quot;lmf&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and
print a summary of the results. For construction of confidene intervals or
perform statistical inference on the parameters the function <code>boot.lmf</code> is used.
</p>
<p>An object of class &quot;lmf&quot; is a list containing the following components:
</p>
<table>
<tr><td><code>running.time</code></td>
<td>
<p>the total time used for computation.</p>
</td></tr>
<tr><td><code>optim.time</code></td>
<td>
<p>the time used for maximation of the loglikelihood.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>the number of parameters in the model.</p>
</td></tr>
<tr><td><code>uage</code></td>
<td>
<p>the unique age classes in the data set.</p>
</td></tr>
<tr><td><code>nage</code></td>
<td>
<p>the number of unique age classes in the data set.</p>
</td></tr>
<tr><td><code>maxage</code></td>
<td>
<p>the final age class.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>the estimated projection matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the deterministic multiplicative growth rate of the population.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the stable age distribution.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the vector of reproductive values for each age class.</p>
</td></tr>
<tr><td><code>uyear</code></td>
<td>
<p>the unique years in the data set.</p>
</td></tr>
<tr><td><code>nyear</code></td>
<td>
<p>the number of unique years in the data set.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations (counting individual-year).</p>
</td></tr>
<tr><td><code>nobs.age</code></td>
<td>
<p>the number of observations per age class.</p>
</td></tr>
<tr><td><code>indnr</code></td>
<td>
<p>assigned individual numbers (1:nobs).</p>
</td></tr>
<tr><td><code>ajt</code></td>
<td>
<p>a list containing the named vectors of the estimated selection
coefficient for each age class within each year. Sorted by age class and year.</p>
</td></tr>
<tr><td><code>Ajt.us</code></td>
<td>
<p>a list containing the named unscaled variance-covariance matrix for
each age class within each year. Sorted by age class and year.</p>
</td></tr>
<tr><td><code>sigma.djt</code></td>
<td>
<p>a list containing the vectors of residual standard errors from
the linear regression for each age class within each year.
Sorted by age class and year.</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>a list containing the vectors of degrees of freedom (dof) from the
linear regression for each age class within each year.
Sorted by age class and year.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>a list containing the vectors of residuals from the linear
regression for each age class within each year. Sorted by age class and year.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the vectors of fitted values from the linear
regression for each age class within each year. Sorted by age class and year.</p>
</td></tr>
<tr><td><code>leverage</code></td>
<td>
<p>a list containing the vectors of estimated leverage for each
data point from the linear regression for each age class within each year
(see <code>lm.influence?</code>). Sorted by age class and year.</p>
</td></tr>
<tr><td><code>cook</code></td>
<td>
<p>a list containing the vectors of estimated Cook's distance for each
data point from the linear regression for each age class within each year
(see <code>cooks.distance?</code>). Sorted by age class and year.</p>
</td></tr>
<tr><td><code>sigma2.dj</code></td>
<td>
<p>a list containing the demographic variance for each age class.
Sorted by age class.</p>
</td></tr>
<tr><td><code>sigma2.dj.dof</code></td>
<td>
<p>a list containing the degrees of freedom (dof) for the
demographic variance for each age class. Sorted by age class.</p>
</td></tr>
<tr><td><code>sigma2.dj.sd</code></td>
<td>
<p>a list containing the standard deviation (sd) for the
demographic variance for each age class. Sorted by age class.</p>
</td></tr>
<tr><td><code>sigma2.d</code></td>
<td>
<p>the total demographic variance of the population.</p>
</td></tr>
<tr><td><code>sigma2.d.dof</code></td>
<td>
<p>the degrees of freedom (dof) for the total demographic
variance of the population.</p>
</td></tr>
<tr><td><code>sigma2.d.sd</code></td>
<td>
<p>the standard deviation (sd) for the total demographic
variance of the population.</p>
</td></tr>
<tr><td><code>Ajt</code></td>
<td>
<p>a list containing the named variance-covariance matrix (scaled by
sigma2.dj) for each age class within each year. Sorted by age class and year.</p>
</td></tr>
<tr><td><code>at</code></td>
<td>
<p>a list containing the named vectors of the estimated selection
coefficient for each year. Sorted by year.</p>
</td></tr>
<tr><td><code>At</code></td>
<td>
<p>a list containing the named variance-covariance matrix (scaled by
sigma2.dj) for each year. Sorted by year.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>&quot;yes&quot; indicates that the numerical maximation of the
likelihood successfully converged before reaching the iteration limit <code>maxit</code>.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations of the function in the numerical
maximation of the likelihood.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the estimated temporal covariance matrix (fluctuating selection).</p>
</td></tr>
<tr><td><code>aM</code></td>
<td>
<p>the estimated temporal mean selection coefficients.</p>
</td></tr>
<tr><td><code>atC</code></td>
<td>
<p>the best linear predictor for the estimated yearly selection
coefficients (i.e. corrected for sampling errors).</p>
</td></tr>
<tr><td><code>Anf</code></td>
<td>
<p>the estimated temporal covariance matrix assuming no
fluctuating selection.</p>
</td></tr>
<tr><td><code>anf</code></td>
<td>
<p>the estimated temporal mean selection coefficients assuming
no fluctuating selection.</p>
</td></tr>
<tr><td><code>sigma2.e</code></td>
<td>
<p>the environmental variance of the population.</p>
</td></tr>
<tr><td><code>data.set</code></td>
<td>
<p>the data set used in the analyses with a column of individual
reproductive values addad</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+procomp">procomp</a></code>, <code><a href="#topic+promat">promat</a></code>, <code><a href="#topic+eigenl">eigenl</a></code>,
<code><a href="#topic+lm.extract">lm.extract</a></code>, <code><a href="#topic+fs">fs</a></code>, <code><a href="#topic+atCfn">atCfn</a></code>,
<code><a href="#topic+nfs">nfs</a></code>, <code><a href="#topic+boot.lmf">boot.lmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#View diagnostic plots
plot(lmf.1)
#View output
print(lmf.1)
#Print summary
summary(lmf.1)
</code></pre>

<hr>
<h2 id='lnL.M'>
Maximum likelihood function for temporal coefficients of selection
</h2><span id='topic+lnL.M'></span>

<h3>Description</h3>

<p><code>lnL.M</code> calculates the loglikelihood of the maximum likelihood function for
temporal coefficients of selection from Engen et al. 2012. Returns the estimate
of alpha for a given temporal variance-covariance matrix (M) if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnL.M(D, At, at, npar, ret.alphas = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnL.M_+3A_d">D</code></td>
<td>
<p>a vector with the non-zero elements of the upper triangular matrix
of the Cholesky decomposition of a temporal variance-covariance matrix M.
</p>
</td></tr>
<tr><td><code id="lnL.M_+3A_at">At</code></td>
<td>
<p>a list containing the named yearly variance-covariance matrices.
Sorted by year.
</p>
</td></tr>
<tr><td><code id="lnL.M_+3A_at">at</code></td>
<td>
<p>a list containing the named yearly vectors of the estimated selection
coefficients. Sorted by year.
</p>
</td></tr>
<tr><td><code id="lnL.M_+3A_npar">npar</code></td>
<td>
<p>the number of parameters in the model for the estimates selection
coefficients.
</p>
</td></tr>
<tr><td><code id="lnL.M_+3A_ret.alphas">ret.alphas</code></td>
<td>
<p>logical. If TRUE the function returns the vector with the
estimates of the temporal mean selection coefficients (alpha) for the given
temporal variance-covariance matrix M. FALSE (default) makes the function
return the loglikelihood for the given M.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function was developed for internal use in <code>fs</code>, but can be applied as
a standalone.
</p>
<p>The upper triangular matrix (D) of the Cholesky decomposition of M is defined
as <code>M = t(D)%*%D</code>.
</p>
<p>Details of the method is provided in Engen et al. 2012.
</p>


<h3>Value</h3>

<p><code>lnL.M</code> returns the loglikelihood estimate (for <code>ret.alpha = FALSE</code>)
or the temporal mean selection coefficients (for <code>ret.alpha = TRUE</code>) for a
given temporal variance-covariance matrix M.
</p>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmf">lmf</a></code>, <code><a href="#topic+fs">fs</a></code>, <code><a href="base.html#topic+chol">chol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Extract At and at
At &lt;- lmf.1$At
at &lt;- lmf.1$at
#Estimate D
D &lt;- as.vector(chol((Reduce('+', At) / length(At))))
D &lt;- D[D != 0]
#Estimate loglikelihood
lnL.M(D = D, At = At, at = at, npar = 3, ret.alphas = FALSE)
#Estimate temporal mean selection coefficients
lnL.M(D = D, At = At, at = at, npar = 3, ret.alphas = TRUE)
</code></pre>

<hr>
<h2 id='nearPD'>
Find nearest positive definite matrix
</h2><span id='topic+nearPD'></span>

<h3>Description</h3>

<p>Compute the nearest positive definite matrix to an approximate one,
typically a correlation or variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearPD(x, corr = FALSE, keepDiag = FALSE, do2eigen = TRUE, doSym = FALSE,
doDykstra = TRUE, only.values = FALSE, only.matrix = TRUE, eig.tol = 1e-06,
conv.tol = 1e-07, posd.tol = 1e-08, maxit = 100, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearPD_+3A_x">x</code></td>
<td>

<p>numeric <em>n * n</em> approximately positive definite matrix, typically an
approximation to a correlation or covariance matrix.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_corr">corr</code></td>
<td>
<p>logical indicating if the matrix should be a
<em>correlation</em> matrix.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_keepdiag">keepDiag</code></td>
<td>
<p>logical, generalizing <code>corr</code>: if <code>TRUE</code>, the
resulting matrix should have the same diagonal (<code><a href="base.html#topic+diag">diag</a>(x)</code>) as
the input matrix.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_do2eigen">do2eigen</code></td>
<td>
<p>logical indicating if a <code>posdefify</code>
eigen step should be applied to the result of the Higham algorithm.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_dosym">doSym</code></td>
<td>
<p>logical indicating if <code>X &lt;- (X + t(X))/2</code> should be done,
after <code>X &lt;- tcrossprod(Qd, Q)</code>. Some doubt if this is necessary.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_dodykstra">doDykstra</code></td>
<td>
<p>logical indicating if Dykstra's correction should be used;
true by default. If false, the algorithm is basically the direct fixpoint
iteration <code class="reqn">Y(k) = P_U(P_S(Y(k-1)))</code>.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_only.values">only.values</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result is just the vector
of eigen values of the approximating matrix.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_only.matrix">only.matrix</code></td>
<td>
<p>logical indicating if only the matrix should be returned.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_eig.tol">eig.tol</code></td>
<td>
<p>defines relative positiveness of eigenvalues compared to
largest one, <code class="reqn">\lambda_1</code>. Eigen values <code class="reqn">\lambda_k</code> are treated
as if zero when <code class="reqn">\lambda_k / \lambda_1 = eig.tol</code>.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_conv.tol">conv.tol</code></td>
<td>
<p>convergence tolerance for Higham algorithm.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_posd.tol">posd.tol</code></td>
<td>
<p>tolerance for enforcing positive definiteness (in the
final <code>posdefify</code> step when <code>do2eigen</code> is <code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations allowed.
</p>
</td></tr>
<tr><td><code id="nearPD_+3A_trace">trace</code></td>
<td>
<p>logical or integer specifying if convergence monitoring
should be traced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is identical to <code>nearPD</code> in package <span class="pkg">Matrix</span> as
far as the algorithmic method is concerned, but has an addition of the argument
<code>only.matrix</code> to ease its application within the function <code>fs</code>,
has lost the argument <code>ensureSymmetry</code> and have a small change in the
list returned when <code>only.matrix = FALSE</code>.
</p>
<p>Please see <code>nearPD</code> in package <span class="pkg">Matrix</span> for further details.
</p>


<h3>Value</h3>

<p><code>nearPD</code> returns a numeric vector of eigen values of
the approximating matrix if <code>only.values = TRUE</code>, returns the computed
positive definite matrix if <code>only.matrix = TRUE</code> and else returns a list
with the following componets:
</p>
<table>
<tr><td><code>mat</code></td>
<td>
<p>matrix of class &quot;dpoMatrix&quot;, the computed
positive-definite matrix.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>numeric vector of eigenvalues of <code>mat</code>.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>logical, just the argument <code>corr</code>.</p>
</td></tr>
<tr><td><code>normF</code></td>
<td>
<p>the Frobenius norm (<code><a href="base.html#topic+norm">norm</a>(x-X, "F")</code>) of the
difference between the original and the resulting matrix.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations needed.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical indicating if iterations converged.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jens Oehlschlaegel donated a first version. Subsequent
changes by the Matrix package authors and present modifications
by Thomas Kvalnes.
</p>


<h3>References</h3>

<p>Cheng, S.H. and Higham, N. 1998. A Modified Cholesky Algorithm Based
on a Symmetric Indefinite Factorization. SIAM Journal on Matrix Analysis and
Applications, 19, 1097-1110.
</p>
<p>Knol, D.L. and ten Berge, J.M.F. 1989. Least-squares approximation of an
improper correlation matrix by a proper one. Psychometrika, 54, 53-61.
</p>
<p>Higham, N. 2002. Computing the nearest correlation matrix - a problem
from finance. IMA Journal of Numerical Analysis, 22, 329-343.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fs">fs</a></code>, <code><a href="#topic+lmf">lmf</a></code>, <code><a href="Matrix.html#topic+nearPD">nearPD</a></code>,
<code><a href="sfsmisc.html#topic+posdefify">posdefify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulated non-positive definite (PD) matrix
nonPD &lt;- matrix(c(2.04e-03, 3.54e-05, 7.52e-03, 3.54e-05, 6.15e-07,
  1.30e-04, 7.52e-03, 1.30e-04, 2.76e-02), ncol = 3)
#View eigenvalues (PD = only positive eigenvalues)
eigen(nonPD)
#Calculate PD matrix
PD &lt;- nearPD(nonPD, only.matrix = TRUE)
PD
#View eigenvalues
eigen(PD)
#More thorough examples are given in the help pages for nearPD
 #in the Matrix package.
</code></pre>

<hr>
<h2 id='nfs'>
Estimate temporal coefficients of selection assuming no fluctuating selection
</h2><span id='topic+nfs'></span>

<h3>Description</h3>

<p><code>nfs</code> is a function which estimates the temporal covariance matrix
and the temporal mean alpha coefficients (i.e. directional
selection) under the assumption of no fluctuating selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nfs(At, at, npar, nyear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nfs_+3A_at">At</code></td>
<td>
<p>a list containing the named yearly variance-covariance matrices.
Sorted by year.
</p>
</td></tr>
<tr><td><code id="nfs_+3A_at">at</code></td>
<td>
<p>a list containing the named yearly vectors of the estimated selection
coefficients. Sorted by year.
</p>
</td></tr>
<tr><td><code id="nfs_+3A_npar">npar</code></td>
<td>
<p>the number of parameters in the model for the estimates selection
coefficients.
</p>
</td></tr>
<tr><td><code id="nfs_+3A_nyear">nyear</code></td>
<td>
<p>the number of years with estimates of selection.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nfs</code> is used internally in <code>lmf</code> when estimating temporal mean
coefficients of selection under the assumption of no fluctuating selection, but
given the right data can be executed as a standalone. The input to the
arguments At and at are estimated within <code>lmf</code> by correctly combining
estimates of coefficients and variance-covariance within each age class and year
to a estimate for each year.
</p>
<p>Engen et al. 2012 describe the method in details.
</p>


<h3>Value</h3>

<p><code>nfs</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>Anf</code></td>
<td>
<p>the estimated temporal covariance matrix under the assumption of
no flucutating selection.</p>
</td></tr>
<tr><td><code>anf</code></td>
<td>
<p>the estimated temporal mean selection coefficients under the
assumption of no fluctuating selection.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmf">lmf</a></code>, <code><a href="#topic+fs">fs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Extract At and at
At &lt;- lmf.1$At
at &lt;- lmf.1$at
#Estimate temporal selection coefficients under the assumption of no
  #fluctuating selection
noflusel &lt;- nfs(At = At, at = at, npar = 3, nyear = 7)
#View output
str(noflusel)
noflusel
</code></pre>

<hr>
<h2 id='plot.boot.lmf'>
Plotting function for class &quot;boot.lmf&quot;
</h2><span id='topic+plot.boot.lmf'></span>

<h3>Description</h3>

<p>Plots density plots for bootstrap replicates of parameters from objects
of class &quot;lmf&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot.lmf'
  ## S3 method for class 'boot.lmf'
plot(x, what = c("all"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.boot.lmf_+3A_x">x</code></td>
<td>
<p>an object of class &quot;boot.lmf&quot;.
</p>
</td></tr>
<tr><td><code id="plot.boot.lmf_+3A_what">what</code></td>
<td>
<p>what parameters is to be plotted. Options are &quot;projection&quot;,
&quot;alpha&quot; and &quot;all&quot;.
</p>
</td></tr>
<tr><td><code id="plot.boot.lmf_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to methods, such as
graphical parameters (see <code>par</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Density of parameters is calculated using the function <code>density</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.lmf">boot.lmf</a></code>, <code><a href="stats.html#topic+density">density</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Bootstrap parameters
b.1 &lt;- boot.lmf(object = lmf.1, nboot = 10, sig.dj = TRUE,
 what = "all", asim = "parametric")
#Density plot
plot(b.1)
</code></pre>

<hr>
<h2 id='plot.lmf'>
Plot diagnostics for an lmf object
</h2><span id='topic+plot.lmf'></span>

<h3>Description</h3>

<p>Plots four diagnostic plots for objects of class &quot;lmf&quot;: a plot of residuals against
fitted values, a Normal Q-Q plot, a Scale-Location plot of the square root of standardized
residuals against fitted values and a plot of standardized residuals against leverage with
indications of cooks distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmf'
  ## S3 method for class 'lmf'
plot(x, what = "total", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lmf_+3A_x">x</code></td>
<td>

<p>an object of class &quot;lmf&quot;.
</p>
</td></tr>
<tr><td><code id="plot.lmf_+3A_what">what</code></td>
<td>

<p>the part of the model for which diagnostic plots should be generated. Options are
'total' (default) for the overall plots and 'age-year' for plots for each separate linear
regression for each age within each year.
</p>
</td></tr>
<tr><td><code id="plot.lmf_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed through to plotting functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is constructed partly from modifications of script
from the <code>plot.lm</code> function in package <span class="pkg">stats</span>. See <code>?plot.lm</code>
for details on the plots provided.
</p>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmf">lmf</a></code>, <code><a href="stats.html#topic+plot.lm">plot.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Diagnostic plots across all age classes and years
par(mfrow = c(2, 2))
plot(lmf.1)
#Diagnostic plots for each age class within each year (the
#actual linear regressions)
par(mfrow = c(2, 2))
plot(lmf.1, what = "age-year")
</code></pre>

<hr>
<h2 id='projection'>
The projection matrix
</h2><span id='topic+projection'></span><span id='topic+procomp'></span><span id='topic+promat'></span>

<h3>Description</h3>

<p>Estimates the components of the projection matrix and constructs the matrix
given data on fecundity and survival in a age-structured population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procomp(a, uage)
promat(pc, nage)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projection_+3A_a">a</code></td>
<td>

<p>a data set with fecundity and survival of individuals with known age over
several years. Each individual can be represented once a year.
</p>
</td></tr>
<tr><td><code id="projection_+3A_uage">uage</code></td>
<td>

<p>the unique age classes in the data set.
</p>
</td></tr>
<tr><td><code id="projection_+3A_pc">pc</code></td>
<td>

<p>a matrix with columns age, fecundity and survival, i.e. the output from
running the function <code>procomp</code>.
</p>
</td></tr>
<tr><td><code id="projection_+3A_nage">nage</code></td>
<td>

<p>the number of unique age classes in the data set.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was made for internal use in <code>lmf</code>, but can be applied as a
standalone.
</p>
<p>The data set needs to contain the columns recruits (number of female offspring),
survival (1 if the individual survives to the next reproductive event and
0 if it dies) and age.
</p>
<p>The contruction of the projection matrix is divided into two functions for ease
of storing and handling the estimates.
</p>


<h3>Value</h3>

<p><code>procomp</code> returns a matrix with the components of the projection matrix having
columns age, fecundity and survival, while <code>promat</code> takes the output from
<code>procomp</code> and returns the projection matrix.
</p>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>References</h3>

<p>Caswell, H. 2000. Matrix Population Models, 2nd edn. Sinauer, Sunderland,
Massachusetts.
Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigenl">eigenl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#The uniue age classes
unique.age &lt;- unique(sparrowdata$age)
#Estimate the components of the projection matrix
projection.components &lt;- procomp(a = sparrowdata, uage = unique.age)
#View components
projection.components
#Set up the projection matrix
promat(pc = projection.components, nage = length(unique.age))
</code></pre>

<hr>
<h2 id='rmnorm'>
Generate random numbers from the multivariate normal distribution
</h2><span id='topic+rmnorm'></span>

<h3>Description</h3>

<p><code>rmnorm</code> generate random numbers from a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmnorm(n = 1, mean = rep(0, d), varcov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmnorm_+3A_n">n</code></td>
<td>
<p>the number of random vectors to be generated.
</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_mean">mean</code></td>
<td>
<p>a vector with means of length <em>d</em>.
</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_varcov">varcov</code></td>
<td>
<p>a variance-covariance matrix with dimentions <em>d * d</em>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a modification of the function <code>rmnorm</code> provided in <span class="pkg">mnormt</span>.
The function works around problems of non-positive definite
variance-covariance matrices due to numerical rounding by use of the
function <code>nearPD</code>. Furthermore, when only a single random vector
is generated, the function now returns a named random vector with names
inherited from the colum names of the variance-covariance matrix.
</p>


<h3>Value</h3>

<p>For n &gt; 1 <code>rmnorm</code> returns a matrix of <code>n</code> rows of random vectors,
while for n = 1 <code>rmnorm</code> returns a named random vector.
</p>


<h3>Author(s)</h3>

<p>Fortran code of SADMVN and most auxiliary functions by Alan Genz, some
additional auxiliary functions by people referred to within his program.
Porting to R and additional R code by Adelchi Azzalini, with current
modifications by Thomas Kvalnes.
</p>


<h3>References</h3>

<p>Genz, A. 1992. Numerical Computation of Multivariate Normal Probabilities.
Journal of Computational and Graphical Statiststics, 1, 141-149.
</p>
<p>Genz, A. 1993. Comparison of methods for the computation of multivariate
normal probabilities. Computing Science and Statistics, 25, 400-405.
</p>
<p>Genz, A.: Fortran code available at
http://www.math.wsu.edu/math/faculty/genz/software/fort77/mvn.f
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">Normal</a></code>, <code><a href="stats.html#topic+rnorm">rnorm</a></code>, <code><a href="mnormt.html#topic+rmnorm">rmnorm</a></code>,
<code><a href="#topic+nearPD">nearPD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Variance-covariance matrix
varcov &lt;- matrix(c(2.047737e-03, 3.540039e-05, 0.0075178920, 3.540039e-05,
6.122832e-07, 0.0001299661, 7.517892e-03, 1.299661e-04, 0.0276005740), ncol = 3)
#Set names
nam &lt;- c("a", "b", "c")
dimnames(varcov) &lt;- list(nam, nam)
#Check positive definiteness (all positive eigenvalues = positive definite)
eigen(varcov) $values
#Mean
mean &lt;- c(1, 0.3, 0.5)
#Generate n = 1 random vector
rmnorm(n = 1, mean = mean, varcov = varcov)
#Generate n = 10 random vectors
rmnorm(n = 10, mean = mean, varcov = varcov)
#Generate n = 1 random vectors when varcov is non-positive definite
#Non-positive definite varcov matrix
varcov2 &lt;- matrix(c(2.04e-03, 3.54e-05, 7.52e-03, 3.54e-05, 6.15e-07,
  1.30e-04, 7.52e-03, 1.30e-04, 2.76e-02), ncol = 3)
  dimnames(varcov2) &lt;- dimnames(varcov)
eigen(varcov2)
#Random vector
rmnorm(n = 1, mean = mean, varcov = varcov2)
</code></pre>

<hr>
<h2 id='se'>
Standard error
</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>Calculates the standard error of the values in <code>x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_x">x</code></td>
<td>
<p>a numeric vector.
</p>
</td></tr>
<tr><td><code id="se_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code> values
should be stripped before the computation proceeds.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard error of a length one vector is <code>NA</code> and if <code>x</code> is not
a vector an error will be printed.
</p>
<p>The standard error is defined as:
</p>
<p style="text-align: center;"><code class="reqn">SE = \sqrt{\frac{var(x)}{length(x)}}</code>
</p>



<h3>Value</h3>

<p>The standard error of <code>x</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+var">var</a></code>, <code><a href="base.html#topic+length">length</a></code>, <code><a href="base.html#topic+sqrt">sqrt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The standard error of samples with the same mean and standard deviation, but
  #of different sizes.
se(rnorm(n = 10, mean = 5, sd = 1))
se(rnorm(n = 100, mean = 5, sd = 1))
se(rnorm(n = 1000, mean = 5, sd = 1))
se(rnorm(n = 10000, mean = 5, sd = 1))
</code></pre>

<hr>
<h2 id='sparrowdata'>
House Sparrow data set
</h2><span id='topic+sparrowdata'></span>

<h3>Description</h3>

<p>A data set on a wild population of house sparrow <em>Passer domesticus</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sparrowdata)</code></pre>


<h3>Format</h3>

<p>A data frame with 116 observations on the following 7 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>unique individual identifier</p>
</dd>
<dt><code>year</code></dt><dd><p>the year of breeding</p>
</dd>
<dt><code>age</code></dt><dd><p>the age of the individual</p>
</dd>
<dt><code>survival</code></dt><dd><p>equals 1 if the individual survives, otherwise 0</p>
</dd>
<dt><code>recruits</code></dt><dd><p>the number of recruits produced, i.e. offspring that
survives to the next breeding season</p>
</dd>
<dt><code>weight</code></dt><dd><p>the body mass of the individuals at fledgling, i.e.
when the bird was ready to leave the nest</p>
</dd>
<dt><code>tars</code></dt><dd><p>the tarsus length of the individuals at fledgling, i.e.
when the bird was ready to leave the nest</p>
</dd>
</dl>



<h3>Details</h3>

<p>Further details on the data set is provided by Engen et al. 2012.
</p>


<h3>References</h3>

<p>Engen, S., Saether, B.-E., Kvalnes, T. and Jensen, H. 2012. Estimating fluctuating
selection in age-structured populations. Journal of Evolutionary Biology, 25, 1487-1499.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#View data
str(sparrowdata)
head(sparrowdata, 10)
</code></pre>

<hr>
<h2 id='summary.boot.lmf'>
Summarizing bootstraps of lmf fits
</h2><span id='topic+summary.boot.lmf'></span><span id='topic+print.summary.boot.lmf'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;boot.lmf&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'boot.lmf'
summary(object, ret.bootstraps = FALSE, ...)
  ## S3 method for class 'summary.boot.lmf'
print(x, digits = max(3, getOption("digits") - 3),
  signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.boot.lmf_+3A_object">object</code></td>
<td>
<p>an object of class &quot;boot.lmf&quot;.
empty
</p>
</td></tr>
<tr><td><code id="summary.boot.lmf_+3A_ret.bootstraps">ret.bootstraps</code></td>
<td>
<p>logical. If <code>TRUE</code> the bootstrap replicates are
returned in the output.
empty
</p>
</td></tr>
<tr><td><code id="summary.boot.lmf_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.boot.lmf&quot;.
empty
</p>
</td></tr>
<tr><td><code id="summary.boot.lmf_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.
empty
</p>
</td></tr>
<tr><td><code id="summary.boot.lmf_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, 'significance stars' are printed
for each coefficient.
</p>
</td></tr>
<tr><td><code id="summary.boot.lmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.boot.lmf</code> formats bootstrap replicates in a user-friendly way,
and formats the temporal coefficients and variance-covariance matrix into
easily read tables for hypothesis tests.
</p>


<h3>Value</h3>

<p>The function <code>summary.boot.lmf</code> computes and returns a list of summary
statistics of the bootstrap replicates of a fitted <code>lmf</code> model given
in <code>object</code>.
</p>
<p>An object of class &quot;summary.boot.lmf&quot; is a list containing at most the following
components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>the number of bootstrap replicates generated.</p>
</td></tr>
<tr><td><code>lest</code></td>
<td>
<p>the estimated projection matrix.</p>
</td></tr>
<tr><td><code>lboot.mean</code></td>
<td>
<p>the bootstrap mean projection matrix.</p>
</td></tr>
<tr><td><code>lbias</code></td>
<td>
<p>the bootstrap bias of the components of the projection matrix.</p>
</td></tr>
<tr><td><code>lboot.sd</code></td>
<td>
<p>the boostrap standard deviation of the components of the
projection matrix.</p>
</td></tr>
<tr><td><code>luv</code></td>
<td>
<p>the estimate, bootstrap mean, bias and standard deviation of the
deterministic multiplicative growth rate of the population <code class="reqn">(\lambda)</code>,
the stable age distribution (u) and the reproductive values (v).</p>
</td></tr>
<tr><td><code>sigma2.e</code></td>
<td>
<p>the estimate, bootstrap mean, bias and standard deviation of
the environmental variance of the population.</p>
</td></tr>
<tr><td><code>sigma2.dd</code></td>
<td>
<p>the estimate, bootstrap mean, bias and standard deviation of
the demographic variances (by age class and in total).</p>
</td></tr>
<tr><td><code>aM</code></td>
<td>
<p>the estimate, bootstrap mean, bias and standard deviation of the
estimated temporal mean selection coefficients.</p>
</td></tr>
<tr><td><code>Mest</code></td>
<td>
<p>the estimated temporal variance-covariance matrix (M).</p>
</td></tr>
<tr><td><code>Mboot.mean</code></td>
<td>
<p>the bootstrap mean temporal variance-covariance matrix.</p>
</td></tr>
<tr><td><code>Mbias</code></td>
<td>
<p>the bootstrap bias of the components of the temporal
variance-covariance matrix.</p>
</td></tr>
<tr><td><code>Mboot.sd</code></td>
<td>
<p>the boostrap standard deviation of the components of the
temporal variance-covariance matrix.</p>
</td></tr>
<tr><td><code>anf</code></td>
<td>
<p>the estimate, bootstrap mean, bias and standard deviation of the
estimated temporal mean selection coefficients under the assumption of no
fluctuating selection.</p>
</td></tr>
<tr><td><code>Anfest</code></td>
<td>
<p>the estimated temporal variance-covariance matrix under the
assumtion of no fluctuating selection.</p>
</td></tr>
<tr><td><code>Anfboot.mean</code></td>
<td>
<p>the bootstrap mean temporal variance-covariance matrix
under the assumption of no fluctuating selection.</p>
</td></tr>
<tr><td><code>Anfbias</code></td>
<td>
<p>the bootstrap bias of the components of the temporal
variance-covariance matrix under the assumption of no fluctuating selection.</p>
</td></tr>
<tr><td><code>Anfboot.sd</code></td>
<td>
<p>the boostrap standard deviation of the components of the
temporal variance-covariance matrix under the assumption of no
fluctuating selection.</p>
</td></tr>
<tr><td><code>coefficients.aH0aMboot</code></td>
<td>
<p>the estimated temporal mean selection
coefficients, with bootstrapped standard errors, number of
successes with regard to the null hypothesis and associated p-values. All
under the specified null hypothesis <code>H0exp</code> and the assumption of fluctuating
selection (<code>Hexp = "fs"</code>).</p>
</td></tr>
<tr><td><code>coefficients.aH0anfboot</code></td>
<td>
<p>the estimated temporal mean selection
coefficients under the assumtion of no fluctuating selection, with
bootstrapped standard errors, number of successes with regard to the null
hypothesis and associated p-values. All under the specified null hypothesis
<code>H0exp</code> and the assumption of no fluctuating selection
(<code>Hexp = "nfs"</code>).</p>
</td></tr>
<tr><td><code>coefficients.aH0Mnfboot</code></td>
<td>
<p>the estimated temporal components of the
variance-covariance matrix, with bootstrapped standard errors, number of
successes with regard to the null hypothesis and associated p-values. All
under the specified null hypothesis <code>H0exp</code> and the assumption of
directional selection (<code>Hexp = "ds"</code>).</p>
</td></tr>
<tr><td><code>lluvboot</code></td>
<td>
<p>the bootstrap replicates of the projection matrix (columns
f (fecundity) and s (survial)), lambda, the stable age distribution (u)
and the reproductive values (v). Numbers in the column names
indicate age class.</p>
</td></tr>
<tr><td><code>deboot</code></td>
<td>
<p>the bootstrap replicates of the demographic and environmental
variances. Numbers in the column names indicate age class.</p>
</td></tr>
<tr><td><code>atAboot</code></td>
<td>
<p>the bootstrap replicates of the yearly coefficients of
selection (at) and variance-covariance matrix (At). The first column indicate
boostrap number and the second the boostrapped year. The subsequent columns
contain coefficients (where (Intercept) (at) is the first coefficient), and components of the
variance-covariance matrix (where (Intercept)-(Intercept) (At) is the first
component (from the diagonal) of the matrix)</p>
</td></tr>
<tr><td><code>aMMboot</code></td>
<td>
<p>the bootstrap replicates of the temporal mean coefficients of
selection (aM) and variance-covariance matrix (M). The first columns
contain coefficients (where (Intercept) (a(M)) is the first coefficient), and
subsequent columns contain the components of the variance-covariance
matrix (where (Intercept)-(Intercept) (M) is the first
component (from the diagonal) of the matrix)</p>
</td></tr>
<tr><td><code>atCboot</code></td>
<td>
<p>the bootstrap replicates of the yearly coefficients of
selection (atC) corrected for sampling error. The first column indicate
boostrap number, the second the boostrapped year and the subsequent columns
contain the boostrapped coefficients.</p>
</td></tr>
<tr><td><code>anfAboot</code></td>
<td>
<p>the bootstrap replicates of the temporal mean coefficients of
selection (anf) and variance-covariance matrix under the assumption of no
fluctuating selection. The first columns contain coefficients
(where (Intercept) (a(M=0)) is the first coefficient), and
subsequent columns contain the components of the variance-covariance
matrix (where (Intercept)-(Intercept) (At(M=0)) is the first
component (from the diagonal) of the matrix)</p>
</td></tr>
<tr><td><code>H0aMboot</code></td>
<td>
<p>the bootstrap replicates of <code>aM</code> under the
specified null hypothesis <code>H0exp</code> and the assumption of fluctuating
selection (<code>Hexp = "fs"</code>).</p>
</td></tr>
<tr><td><code>H0anfboot</code></td>
<td>
<p>the bootstrap replicates of <code>anf</code> under the
specified null hypothesis <code>H0exp</code> and the assumption of no fluctuating
selection (<code>Hexp = "nfs"</code>).</p>
</td></tr>
<tr><td><code>H0atnfboot</code></td>
<td>
<p>the bootstrap replicates of <code>at</code> under the
specified null hypothesis <code>H0exp</code> and the assumption of directional
selection (<code>Hexp = "ds"</code>). These bootstrap replicates are used to
generate <code>H0Mnfboot</code>.</p>
</td></tr>
<tr><td><code>H0Mnfboot</code></td>
<td>
<p>the bootstrap replicates of <code>M</code> under the
specified null hypothesis <code>H0exp</code> and the assumption of directional
selection (<code>Hexp = "ds"</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmf">lmf</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+boot.lmf">boot.lmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Bootstrap parameters
b.1 &lt;- boot.lmf(object = lmf.1, nboot = 10, sig.dj = TRUE,
 what = "all", asim = "parametric")
#Summary
summary(b.1)
</code></pre>

<hr>
<h2 id='summary.lmf'>
Summarizing lmf fits
</h2><span id='topic+summary.lmf'></span><span id='topic+print.summary.lmf'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;lmf&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lmf'
summary(object, what.level = c("age", "year", "total"), ...)
  ## S3 method for class 'summary.lmf'
print(x, digits = max(3, getOption("digits") - 3),
  signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lmf_+3A_object">object</code></td>
<td>
<p>an object of class &quot;lmf&quot;.
</p>
</td></tr>
<tr><td><code id="summary.lmf_+3A_what.level">what.level</code></td>
<td>
<p>the lowest level of organisation at which parameters should
be summarized. Options are &quot;age&quot; to summarize from the level of specific age
classes, &quot;year&quot; to summarize from the level of years and &quot;total&quot; (default) to
summarize the temporal parameters.
</p>
</td></tr>
<tr><td><code id="summary.lmf_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.lmf&quot;.
</p>
</td></tr>
<tr><td><code id="summary.lmf_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.
</p>
</td></tr>
<tr><td><code id="summary.lmf_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, 'significance stars' are printed
for each coefficient.
</p>
</td></tr>
<tr><td><code id="summary.lmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.lmf</code> formats the coefficients, standard errors and
variance-covariance matrices into easily read tables. The tests of significance
of the coefficients of selection should be considered as suggestive and should
be interpreted with caution. For tests of signifcanse a robust approach is
provided through the function <code>boot.lmf</code>.
</p>


<h3>Value</h3>

<p>The function <code>summary.lmf</code> computes and returns a list of summary
statistics of the fitted <code>lmf</code> model given in <code>object</code>.
</p>
<p>An object of class &quot;summary.lmf&quot; is a list containing at most the following
components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>what.level</code></td>
<td>
<p>the lowest level of organisation at which parameters should
be summarized.</p>
</td></tr>
<tr><td><code>uage</code></td>
<td>
<p>the unique age classes in the data set.</p>
</td></tr>
<tr><td><code>nage</code></td>
<td>
<p>the number of unique age classes in the data set.</p>
</td></tr>
<tr><td><code>uyear</code></td>
<td>
<p>the unique years in the data set.</p>
</td></tr>
<tr><td><code>nyear</code></td>
<td>
<p>the number of unique years in the data set.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>the estimated projection matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the deterministic multiplicative growth rate of the population.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the stable age distribution.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the vector of reproductive values for each age class.</p>
</td></tr>
<tr><td><code>sigma2.e</code></td>
<td>
<p>the environmental variance of the population.</p>
</td></tr>
<tr><td><code>sigma2.dj</code></td>
<td>
<p>a list containing the demographic variance for each age class.
Sorted by age class.</p>
</td></tr>
<tr><td><code>sigma2.dj.dof</code></td>
<td>
<p>a list containing the degrees of freedom (dof) for the
demographic variance for each age class. Sorted by age class.</p>
</td></tr>
<tr><td><code>sigma2.dj.sd</code></td>
<td>
<p>a list containing the standard deviation (sd) for the
demographic variance for each age class. Sorted by age class.</p>
</td></tr>
<tr><td><code>sigma2.d</code></td>
<td>
<p>the total demographic variance of the population.</p>
</td></tr>
<tr><td><code>sigma2.d.dof</code></td>
<td>
<p>the degrees of freedom (dof) for the total demographic
variance of the population.</p>
</td></tr>
<tr><td><code>sigma2.d.sd</code></td>
<td>
<p>the standard deviation (sd) for the total demographic
variance of the population.</p>
</td></tr>
<tr><td><code>coefficients.ajt</code></td>
<td>
<p>the estimated selection coefficients for each age
class within each year, with standard errors, t values and p-values.</p>
</td></tr>
<tr><td><code>Ajt</code></td>
<td>
<p>a list containing the named variance-covariance matrix for each
age class within each year. Sorted by age class and year.</p>
</td></tr>
<tr><td><code>coefficients.at</code></td>
<td>
<p>the estimated selection coefficients within each year,
with standard errors, t values and p-values.</p>
</td></tr>
<tr><td><code>At</code></td>
<td>
<p>a list containing the named variance-covariance matrix for each
year. Sorted by year.</p>
</td></tr>
<tr><td><code>coefficients.atC</code></td>
<td>
<p>the estimated selection coefficients within each year
corrected for sampling error, with standard errors, t values and p-values.</p>
</td></tr>
<tr><td><code>coefficients.aM</code></td>
<td>
<p>the estimated temporal mean selection coefficients,
with standard errors, t values and p-values.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the estimated temporal covariance matrix (fluctuating selection).</p>
</td></tr>
<tr><td><code>coefficients.anf</code></td>
<td>
<p>the estimated temporal mean selection coefficients
under the assumtion of no fluctuating selection, with standard errors,
t values and p-values.</p>
</td></tr>
<tr><td><code>Anf</code></td>
<td>
<p>the estimated temporal covariance matrix assuming no
fluctuating selection.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kvalnes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmf">lmf</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+boot.lmf">boot.lmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data set from Engen et al. 2012
data(sparrowdata)
#Fit model
lmf.1 &lt;- lmf(formula = cbind(recruits, survival) ~ weight + tars,
               age = age, year = year, data = sparrowdata)
#Summary
summary(lmf.1)
#Summary from within years
summary(lmf.1, what.level = "year")
#Summary from within age classes
summary(lmf.1, what.level = "age")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
