<!DOCTYPE html><html><head><title>Help for package RobAStBase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RobAStBase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RobAStBase-package'>
<p>Robust Asymptotic Statistics</p></a></li>
<li><a href='#.merge.lists'><p>Merging Lists</p></a></li>
<li><a href='#ALEstimate-class'><p>ALEstimate-class.</p></a></li>
<li><a href='#BdStWeight-class'><p>Robust Weight classes for bounded, standardized weights</p></a></li>
<li><a href='#biastype-methods'><p>Methods for Function biastype  in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#BoundedWeight-class'><p>Robust Weight classes for bounded weights</p></a></li>
<li><a href='#checkIC'><p>Generic Function for Checking ICs</p></a></li>
<li><a href='#ComparePlot'><p>Wrapper function for function comparePlot</p></a></li>
<li><a href='#comparePlot-methods'><p>Compare - Plots</p></a></li>
<li><a href='#ContIC'><p>Generating function for ContIC-class</p></a></li>
<li><a href='#ContIC-class'><p>Influence curve of contamination type</p></a></li>
<li><a href='#ContNeighborhood'><p>Generating function for ContNeighborhood-class</p></a></li>
<li><a href='#ContNeighborhood-class'><p>Contamination Neighborhood</p></a></li>
<li><a href='#cutoff'><p>Generating function(s) for class 'cutoff'</p></a></li>
<li><a href='#cutoff-class'><p>Cutoff class for distance-distance plots</p></a></li>
<li><a href='#ddPlot-methods'><p> Methods for Function ddPlot in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#evalIC'><p>Generic function for evaluating ICs</p></a></li>
<li><a href='#FixRobModel'><p>Generating function for FixRobModel-class</p></a></li>
<li><a href='#FixRobModel-class'><p>Robust model with fixed (unconditional) neighborhood</p></a></li>
<li><a href='#generateIC'><p>Generic function for the generation of influence curves</p></a></li>
<li><a href='#generateIC.fct-methods'><p>Generic Function for making ICs consistent at a possibly different model</p></a></li>
<li><a href='#getBiasIC'><p>Generic function for the computation of the asymptotic bias for an IC</p></a></li>
<li><a href='#getBoundedIC'><p>getBoundedIC</p></a></li>
<li><a href='#getFiRisk'><p>Generic Function for Computation of Finite-Sample Risks</p></a></li>
<li><a href='#getRiskFctBV-methods'><p>Methods for Function getRiskFctBV  in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#getRiskIC'><p>Generic function for the computation of a risk for an IC</p></a></li>
<li><a href='#getweight-methods'><p>Generating weights</p></a></li>
<li><a href='#HampelWeight-class'><p>Robust Weight classes for weights of Hampel type</p></a></li>
<li><a href='#HampIC-class'><p>Influence curve of Hampel type</p></a></li>
<li><a href='#IC'><p>Generating function for IC-class</p></a></li>
<li><a href='#IC-class'><p>Influence curve</p></a></li>
<li><a href='#InfluenceCurve'><p>Generating function for InfluenceCurve-class</p></a></li>
<li><a href='#InfluenceCurve-class'><p>Influence curve</p></a></li>
<li><a href='#infoPlot'><p>Plot absolute and relative information</p></a></li>
<li><a href='#InfoPlot'><p>Wrapper function for information plot method</p></a></li>
<li><a href='#InfRobModel'><p>Generating function for InfRobModel-class</p></a></li>
<li><a href='#InfRobModel-class'><p>Robust model with infinitesimal (unconditional) neighborhood</p></a></li>
<li><a href='#internal_helpers_for_producing_grids_in_plots_RobAStBase'><p>Internal / Helper functions of package RobAStBase for grids in plot functions</p></a></li>
<li><a href='#internals_for_qqplot'><p>Internal functions for qqplot of package RobAStBase</p></a></li>
<li><a href='#internals_for_RobAStBase'><p>Internal / Helper functions of package RobAStBase</p></a></li>
<li><a href='#internals_for_RobAStBase_ddPlot'><p>Internal / Helper functions of package RobAStBase for ddPlot</p></a></li>
<li><a href='#internals_for_RobAStBase_plot'><p>Internal / Helper functions of package RobAStBase for plot functions</p></a></li>
<li><a href='#interpolRisk-class'><p>Interpolated Risks</p></a></li>
<li><a href='#kStepEstimate-class'><p>kStepEstimate-class.</p></a></li>
<li><a href='#kStepEstimator'><p>Function for the computation of k-step estimates</p></a></li>
<li><a href='#kStepEstimator.start-methods'><p> Methods for function kStepEstimator.start in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#locMEstimator'><p>Generic function for the computation of location M estimates</p></a></li>
<li><a href='#makeIC'><p>Generic Function for making ICs consistent at a possibly different model</p></a></li>
<li><a href='#masked-methods'><p>Masked Methods from Packages &lsquo;stats&rsquo; and &lsquo;graphics&rsquo; in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#MEstimate-class'><p>MEstimate-class.</p></a></li>
<li><a href='#movToRef-methods'><p>Methods for Functions moving from and to reference parameter in Package &lsquo;ROptEst&rsquo;</p></a></li>
<li><a href='#Neighborhood-class'><p>Neighborhood</p></a></li>
<li><a href='#normtype-methods'><p>Methods for Function normtype  in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#oneStepEstimator'><p>Function for the computation of one-step estimates</p></a></li>
<li><a href='#optIC'><p>Generic function for the computation of optimally robust ICs</p></a></li>
<li><a href='#OptionalInfluenceCurve-class'><p>Some helper Classes in package 'RobAStBase'</p></a></li>
<li><a href='#outlyingPlotIC'><p>Function outlyingPlotIC in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#plot-methods'><p> Methods for Function plot in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#PlotIC'><p>Wrapper function for plot method for IC</p></a></li>
<li><a href='#qqplot'><p>Methods for Function qqplot in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#rescaleFunction-methods'><p>Methods for Function rescaleFunction in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#returnlevelplot'><p>Methods for Function returnlevelplot in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#RobAStBaseMASK'><p>Masking of/by other functions in package &quot;RobAStBase&quot;</p></a></li>
<li><a href='#RobAStBaseOptions'><p>Function to change the global variables of the package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#RobAStControl-class'><p>Control classes in package RobAStBase</p></a></li>
<li><a href='#RobModel-class'><p>Robust model</p></a></li>
<li><a href='#RobWeight-class'><p>Robust Weight classes</p></a></li>
<li><a href='#samplesize-methods'><p>Methods for Function samplesize  in Package &lsquo;RobAStBase&rsquo;</p></a></li>
<li><a href='#TotalVarIC'><p>Generating function for TotalVarIC-class</p></a></li>
<li><a href='#TotalVarIC-class'><p>Influence curve of total variation type</p></a></li>
<li><a href='#TotalVarNeighborhood'><p>Generating function for TotalVarNeighborhood-class</p></a></li>
<li><a href='#TotalVarNeighborhood-class'><p>Total variation neighborhood</p></a></li>
<li><a href='#UncondNeighborhood-class'><p>Unconditional neighborhood</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-02</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Asymptotic Statistics</td>
</tr>
<tr>
<td>Description:</td>
<td>Base S4-classes and functions for robust asymptotic statistics.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4), methods, rrcov, distr(&ge; 2.8.0), distrEx(&ge; 2.8.0),
distrMod(&ge; 2.8.1), RandVar(&ge; 1.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ROptEst(&ge; 1.2.0), RUnit(&ge; 0.4.26)</td>
</tr>
<tr>
<td>Imports:</td>
<td>startupmsg, graphics, grDevices, stats</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/robast/">https://r-forge.r-project.org/projects/robast/</a></td>
</tr>
<tr>
<td>LastChangedDate:</td>
<td>{$LastChangedDate: 2024-02-02 07:13:47 +0100 (Fr, 02.
Feb 2024) $}</td>
</tr>
<tr>
<td>LastChangedRevision:</td>
<td>{$LastChangedRevision: 1267 $}</td>
</tr>
<tr>
<td>VCS/SVNRevision:</td>
<td>1236</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-02 07:03:26 UTC; kohlm</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl [cre, cph, aut],
  Peter Ruckdeschel [aut, cph],
  Mykhailo Pupashenko [ctb] (contributed wrapper functions for diagnostic
    plots),
  Gerald Kroisandt [ctb] (contributed testing routines),
  R Core Team [ctb, cph] (for source file 'format.perc')</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RobAStBase-package'>
Robust Asymptotic Statistics
</h2><span id='topic+RobAStBase-package'></span><span id='topic+RobAStBase'></span>

<h3>Description</h3>

<p>Base S4-classes and functions for robust asymptotic statistics.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> RobAStBase </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-02 </td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.4), methods, rrcov, distr(&gt;= 2.8.0), distrEx(&gt;= 2.8.0), distrMod(&gt;= 2.8.1),RandVar(&gt;= 1.2.0) </td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> ROptEst(&gt;= 1.2.0), RUnit(&gt;= 0.4.26) </td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> startupmsg, graphics, grDevices, stats </td>
</tr>
<tr>
 <td style="text-align: left;">
ByteCompile: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;">  latin1 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://r-forge.r-project.org/projects/robast/</td>
</tr>
<tr>
 <td style="text-align: left;">
VCS/SVNRevision: </td><td style="text-align: left;"> 1236 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Package versions</h3>

<p>Note: The first two numbers of package versions do not necessarily reflect
package-individual development, but rather are chosen for the
RobAStXXX family as a whole in order to ease updating &quot;depends&quot;
information.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
Maintainer: Matthias Kohl  <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth.
See also https://www.stamats.de/wp-content/uploads/2018/04/ThesisMKohl.pdf
</p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+0distr-package">distr-package</a></code>, 
<code><a href="distrEx.html#topic+0distrEx-package">distrEx-package</a></code>,
<code><a href="distrMod.html#topic+0distrMod-package">distrMod-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RobAStBase)
## some L2 differentiable parametric family from package distrMod, e.g.
B &lt;- BinomFamily(size = 25, prob = 0.25) 
## classical optimal IC
IC0 &lt;- optIC(model = B, risk = asCov())
plot(IC0) # plot IC
checkIC(IC0, B)
</code></pre>

<hr>
<h2 id='.merge.lists'>Merging Lists</h2><span id='topic+.merge.lists'></span>

<h3>Description</h3>

<p><code>.merge.lists</code> takes two lists and merges them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  .merge.lists(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".merge.lists_+3A_a">a</code></td>
<td>
<p>the first list</p>
</td></tr>
<tr><td><code id=".merge.lists_+3A_b">b</code></td>
<td>
<p>the second list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the merged list
</p>

<hr>
<h2 id='ALEstimate-class'>ALEstimate-class.</h2><span id='topic+ALEstimate-class'></span><span id='topic+MCALEstimate-class'></span><span id='topic+ML.ALEstimate-class'></span><span id='topic+CvMMD.ALEstimate-class'></span><span id='topic+pIC'></span><span id='topic+pIC+2CALEstimate-method'></span><span id='topic+pIC+2CMCEstimate-method'></span><span id='topic+pIC+2CMLEstimate-method'></span><span id='topic+pIC+2CCvMMDEstimate-method'></span><span id='topic+pIC+2CMCALEstimate-method'></span><span id='topic+pIC+2CML.ALEstimate-method'></span><span id='topic+pIC+2CCvMMD.ALEstimate-method'></span><span id='topic+asbias'></span><span id='topic+asbias+2CALEstimate-method'></span><span id='topic+show+2CALEstimate-method'></span><span id='topic+show+2CMCALEstimate-method'></span><span id='topic+confint+2CALEstimate+2Cmissing-method'></span><span id='topic+confint+2CALEstimate+2CsymmetricBias-method'></span><span id='topic+confint+2CALEstimate+2ConesidedBias-method'></span><span id='topic+confint+2CALEstimate+2CasymmetricBias-method'></span><span id='topic+.checkEstClassForParamFamily+2CANY+2CMLEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CANY+2CCvMMDEstimate-method'></span><span id='topic+getPIC'></span><span id='topic+getPIC+2CANY-method'></span><span id='topic+getPIC+2CMLEstimate-method'></span><span id='topic+getPIC+2CCvMMDEstimate-method'></span>

<h3>Description</h3>

<p>Class of asymptotically linear estimates.</p>


<h3>Details</h3>

<p>The (return value) class of an estimator is of class <code>ALEstimate</code>
if it is asymptotically linear; then it has an influence function
(implemented in slot <code>pIC</code>) and so all the diagnostics for influence
functions are available; in addition it is asymptotically normal, so
we can (easily) deduce asymptotic covariances, hence may use these
in confidence intervals; in particular, the return values of <code>kStepEstimator</code>
<code>oneStepEstimator</code> (and <code>roptest</code>, <code>robest</code>, <code>RMXEstimator</code>,
<code>MBREstimator</code>, <code>OBREstimator</code>, <code>OMSEstimator</code> in package
'ROptEst') are objects of (subclasses of) this class.
</p>
<p>As the return value of <code>CvMMDEEstimator</code> (or <code>MDEstimator</code> with
<code>CvMDist</code> or <code>CvMDist2</code> as distance) is asymptotically linear,
there is class <code>MCALEstimate</code> extending <code>MCEstimate</code> by
extra slots <code>pIC</code> and <code>asbias</code> (only filled optionally with
non-<code>NULL</code> values). Again all the diagnostics for influence
functions are then available. Classes <code>ML.ALEstimate</code> and
class <code>CvMMD.ALEstimate</code> are nominal subclasses of class
<code>MCALEstimate</code>, nominal in the sense that they have no extra slots,
but they might have particular methods later on.
</p>
<p>Helper method <code>getPIC</code> by means of the estimator class, and, in
case of estimators of class <code>CvMMDEstimate</code>, also the name
(in slot <code>name</code>) produces the (partial) influence function:
calling <code>.CvMMDCovariance</code> &ndash; either directly or through wrapper
<code>.CvMMDCovarianceWithMux</code>. This is used  in the corresponding
<code>.checkEstClassForParamFamily</code> method, which coerces <code>object</code> from
class <code>"MCEstimate"</code> to <code>"MCALEstimate"</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ALEstimate", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
name of the estimator. </p>
</dd>
<dt><code>estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
estimate. </p>
</dd>
<dt><code>estimate.call</code></dt><dd><p>Object of class <code>"call"</code>:
call by which estimate was produced.</p>
</dd>
<dt><code>samplesize</code></dt><dd><p> object of class <code>"numeric"</code> &mdash;
the samplesize (only complete cases are counted)
at which the estimate was evaluated. </p>
</dd>
<dt><code>completecases</code></dt><dd><p> object of class <code>"logical"</code> &mdash;
complete cases at which the estimate was evaluated. </p>
</dd>
<dt><code>asvar</code></dt><dd><p>object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the estimator. </p>
</dd>
<dt><code>asbias</code></dt><dd><p>Optional object of class <code>"numeric"</code>:
asymptotic bias. </p>
</dd>
<dt><code>pIC</code></dt><dd><p>Optional object of class <code>InfluenceCurve</code>:
influence curve. </p>
</dd>
<dt><code>nuis.idx</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>: 
indices of <code>estimate</code> belonging to the nuisance part. </p>
</dd>
<dt><code>fixed</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>:
the fixed and known part of the parameter</p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
<dt><code>trafo</code></dt><dd><p> object of class <code>"list"</code>:
a list with components <code>fct</code> and <code>mat</code> (see below). </p>
</dd>
<dt><code>untransformed.estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
untransformed estimate.</p>
</dd>
<dt><code>untransformed.asvar</code></dt><dd><p> object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the untransformed
estimator. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>ALEstimate</code> extends class <code>"Estimate"</code>, directly.
Class <code>MCALEstimate</code> extends classes
<code>"ALEstimate"</code>, and <code>"MCEstimate"</code> directly.
Class <code>ML.ALEstimate</code> extends classes
<code>"ALEstimate"</code>, and <code>"MLEstimate"</code> directly.
Class <code>CvM.ALEstimate</code> extends classes
<code>"ALEstimate"</code>, and <code>"CvMMDEstimate"</code> directly.
The last two classes are to be used for method dispatch, later;
they have an identical slot structure to class <code>MCALEstimate</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>pIC</dt><dd><p><code>signature(object = "ALEstimate")</code>: 
accessor function for slot <code>pIC</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ALEstimate")</code> </p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "ALEstimate", method = "missing")</code>: 
compute asymptotic (LAN-based) confidence interval neglecting any bias. </p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "ALEstimate", method = "symmetricBias")</code>: 
compute asymptotic (LAN-based) confidence interval incorporating bias
symmetrically. </p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "ALEstimate", method = "onesidedBias")</code>: 
compute asymptotic (LAN-based) confidence interval incorporating bias
one-sided; i.e., positive or negative, respectively. </p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "ALEstimate", method = "asymmetricBias")</code>: 
compute asymptotic (LAN-based) confidence interval incorporating bias
asymmetrically. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> and
Peter Ruckdeschel <a href="mailto:Peter.Ruckdeschel@uni-oldenburg.de">Peter.Ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+Estimate-class">Estimate-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## prototype
new("ALEstimate")

## data example
set.seed(123)
x &lt;- rgamma(50, scale = 0.5, shape = 3)

## parametric family of probability measures
G &lt;- GammaFamily(scale = 1, shape = 2)

mle &lt;- MLEstimator(x,G)
(picM &lt;- pIC(mle))

## Kolmogorov(-Smirnov) minimum distance estimator
ke &lt;- KolmogorovMDEstimator(x = x, ParamFamily = G)
pIC(ke) ## gives NULL

## von Mises minimum distance estimator with default mu

 ## to save time for CRAN
system.time(me &lt;- CvMMDEstimator(x = x, ParamFamily = G))
str(me@pIC) ## a call
system.time(pIC0 &lt;- pIC(me))
str(me@pIC) ## now filled



</code></pre>

<hr>
<h2 id='BdStWeight-class'>Robust Weight classes for bounded, standardized weights</h2><span id='topic+BdStWeight-class'></span><span id='topic+stand+2CBdStWeight-method'></span><span id='topic+stand+3C-+2CBdStWeight-method'></span>

<h3>Description</h3>

<p>Classes for bounded, robust, standardized weights.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("BdStWeight", ...)</code>; 
to fill slot <code>weight</code>, you will use the generating functions 
<code><a href="#topic+getweight">getweight</a></code> and <code><a href="#topic+minbiasweight">minbiasweight</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>; inherited from class <code>RobWeight</code>. </p>
</dd>
<dt><code>weight</code></dt><dd><p>Object of class <code>"function"</code> &mdash; the weight function; inherited from class <code>RobWeight</code>.</p>
</dd>
<dt><code>clip</code></dt><dd><p>Object of class <code>"numeric"</code> &mdash; clipping bound(s); inherited from class <code>BoundedWeight</code>.</p>
</dd>
<dt><code>stand</code></dt><dd><p>Object of class <code>"matrix"</code> &mdash; standardization.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"RobWeight"</code>, via class <code>"BoundedWeight"</code>.
Class <code>"BoundedWeight"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>stand</dt><dd><p><code>signature(object = "BdStWeight")</code>:
accessor function for slot <code>stand</code>. </p>
</dd>
<dt>stand&lt;-</dt><dd><p><code>signature(object = "BdStWeight", value = "matrix")</code>:
replacement function for slot <code>stand</code>. This replacement method 
should be used with great care, as the slot <code>weight</code> is not
simultaneously updated and hence, this may lead to inconsistent
objects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>.
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BoundedWeight-class">BoundedWeight-class</a></code>, <code><a href="#topic+RobWeight-class">RobWeight-class</a></code>,
<code><a href="#topic+IC">IC</a></code>, <code><a href="#topic+InfluenceCurve-class">InfluenceCurve-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## prototype
new("BdStWeight")
</code></pre>

<hr>
<h2 id='biastype-methods'>Methods for Function biastype  in Package &lsquo;RobAStBase&rsquo;</h2><span id='topic+biastype+2CinterpolRisk-method'></span><span id='topic+biastype'></span>

<h3>Description</h3>

<p>biastype-methods</p>


<h3>Methods</h3>


<dl>
<dt>biastype</dt><dd><p><code>signature(object = "interpolrisk")</code>:
returns the slot <code>biastype</code> of an object of class <code>"interpolrisk"</code>. </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>myrisk &lt;- MBRRisk(samplesize=100)
biastype(myrisk)
</code></pre>

<hr>
<h2 id='BoundedWeight-class'>Robust Weight classes for bounded weights</h2><span id='topic+BoundedWeight-class'></span><span id='topic+clip+2CBoundedWeight-method'></span><span id='topic+clip+3C-+2CBoundedWeight-method'></span>

<h3>Description</h3>

<p>Classes for bounded, robust weights.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("BoundedWeight", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>; inherited from class <code>RobWeight</code>. </p>
</dd>
<dt><code>weight</code></dt><dd><p>Object of class <code>"function"</code> &mdash; the weight function; inherited from class <code>RobWeight</code>.</p>
</dd>
<dt><code>clip</code></dt><dd><p>Object of class <code>"numeric"</code> &mdash; clipping bound(s).</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"RobWeight"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>clip</dt><dd><p><code>signature(x1 = "BoundedWeight")</code>:
accessor function for slot <code>clip</code>. </p>
</dd>
<dt>clip&lt;-</dt><dd><p><code>signature(object = "BoundedWeight", value = "numeric")</code>:
replacement function for slot <code>clip</code>. This replacement method 
should be used with great care, as the slot <code>weight</code> is not
simultaneously updated and hence, this may lead to inconsistent
objects. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>.
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RobWeight-class">RobWeight-class</a></code>, <code><a href="#topic+IC">IC</a></code>, <code><a href="#topic+InfluenceCurve-class">InfluenceCurve-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## prototype
new("BoundedWeight")
</code></pre>

<hr>
<h2 id='checkIC'>Generic Function for Checking ICs</h2><span id='topic+checkIC'></span><span id='topic+checkIC+2CIC+2Cmissing-method'></span><span id='topic+checkIC+2CIC+2CL2ParamFamily-method'></span>

<h3>Description</h3>

<p>Generic function for checking centering and Fisher
consistency of ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIC(IC, L2Fam, ...)
## S4 method for signature 'IC,missing'
checkIC(IC, out = TRUE, ..., diagnostic = FALSE)
## S4 method for signature 'IC,L2ParamFamily'
checkIC(IC, L2Fam, out = TRUE,..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIC_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"IC"</code> </p>
</td></tr>
<tr><td><code id="checkIC_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures. </p>
</td></tr>
<tr><td><code id="checkIC_+3A_out">out</code></td>
<td>
<p> logical: Should the values of the checks be printed out?</p>
</td></tr>
<tr><td><code id="checkIC_+3A_...">...</code></td>
<td>
<p> additional parameters </p>
</td></tr>
<tr><td><code id="checkIC_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code> and <code>out==TRUE</code>,
diagnostic information on the integration is printed; independent
of <code>out</code>, if <code>diagnostic==TRUE</code>, this information is
returned as attribute <code>diagnostic</code> of the return value. . </p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The precisions of the centering and the Fisher consistency
are computed.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="distrEx.html#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="distrEx.html#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p>The maximum deviation from the IC properties is returned.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- new("IC")
checkIC(IC1)
</code></pre>

<hr>
<h2 id='ComparePlot'>Wrapper function for function comparePlot</h2><span id='topic+ComparePlot'></span>

<h3>Description</h3>

<p>The wrapper <code>ComparePlot</code> (capital C!) takes most of arguments 
to function <code>comparePlot</code> (lower case c!) by default and gives a user 
possibility to run the function with low number of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ComparePlot(IC1, IC2,  y, ..., IC3 = NULL, IC4 = NULL,
    alpha.trsp = 100, with.legend = TRUE, rescale = FALSE,
    withCall = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComparePlot_+3A_ic1">IC1</code></td>
<td>
<p>object of class <code>IC</code></p>
</td></tr>
<tr><td><code id="ComparePlot_+3A_ic2">IC2</code></td>
<td>
<p>object of class <code>IC</code></p>
</td></tr>
<tr><td><code id="ComparePlot_+3A_ic3">IC3</code></td>
<td>
<p>object of class <code>IC</code></p>
</td></tr>
<tr><td><code id="ComparePlot_+3A_ic4">IC4</code></td>
<td>
<p>object of class <code>IC</code></p>
</td></tr>
<tr><td><code id="ComparePlot_+3A_y">y</code></td>
<td>
<p>optional data argument &mdash; for plotting
observations into the plot</p>
</td></tr>
<tr><td><code id="ComparePlot_+3A_...">...</code></td>
<td>
<p>additional parameters (in particular to be
passed on to <code>plot</code>)</p>
</td></tr>
<tr><td><code id="ComparePlot_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>the transparency argument (0 to 100)
for ploting the data</p>
</td></tr>
<tr><td><code id="ComparePlot_+3A_with.legend">with.legend</code></td>
<td>
<p>the flag for showing the legend of the
plot</p>
</td></tr>
<tr><td><code id="ComparePlot_+3A_rescale">rescale</code></td>
<td>
<p>the flag for rescaling the axes for better
view of the plot</p>
</td></tr>
<tr><td><code id="ComparePlot_+3A_withcall">withCall</code></td>
<td>
<p>the flag for the call output</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(retV)</code> where <code>retV</code> is the return value
of the respective call to the full-fledged function <code>comparePlot</code>
with the additional item <code>wrapcall</code> with the call
to the wrapper <code>ComparePlot</code> and <code>wrappedcall</code> the call to
to the full-fledged function <code>comparePlot</code>.
</p>


<h3>Details</h3>

<p>Calls <code>comparePlot</code> with suitably chosen defaults;
if <code>withCall == TRUE</code>, the call to
<code>comparePlot</code>, i.e., item <code>wrappedcall</code> of the (hidden)
return value, is printed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gamma
fam &lt;- GammaFamily()
rfam &lt;- InfRobModel(fam, ContNeighborhood(0.5))
IC1 &lt;- optIC(model = fam, risk = asCov())
IC2 &lt;- makeIC(list(function(x)sin(x),function(x)x^2), L2Fam = fam)
Y &lt;- distribution(fam)
y &lt;- r(Y)(100)
ComparePlot(IC1, IC2, y, withCall = TRUE)
</code></pre>

<hr>
<h2 id='comparePlot-methods'>Compare - Plots</h2><span id='topic+comparePlot'></span><span id='topic+comparePlot-methods'></span><span id='topic+comparePlot+2CIC+2CIC-method'></span>

<h3>Description</h3>

<p>Plots 2-4 influence curves to the same model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparePlot(obj1, obj2, ... )
## S4 method for signature 'IC,IC'
comparePlot(obj1, obj2, obj3 = NULL, obj4 = NULL, data = NULL,
                 ..., withSweave = getdistrOption("withSweave"),
                 forceSameModel = FALSE, main = FALSE, inner = TRUE,
                 sub = FALSE, col = par("col"), lwd = par("lwd"), lty,
                 col.inner = par("col.main"), cex.inner = 0.8,
                 bmar = par("mar")[1], tmar = par("mar")[3],
                 with.automatic.grid = TRUE, with.legend = FALSE,
                 legend = NULL, legend.bg = "white",
                 legend.location = "bottomright", legend.cex = 0.8,
                 withMBR = FALSE, MBRB = NA, MBR.fac = 2, col.MBR = par("col"),
                 lty.MBR = "dashed", lwd.MBR = 0.8, x.vec = NULL,
                 scaleX = FALSE, scaleX.fct, scaleX.inv, scaleY = FALSE,
                 scaleY.fct = pnorm, scaleY.inv = qnorm, scaleN = 9,
                 x.ticks = NULL, y.ticks = NULL, mfColRow = TRUE,
                 to.draw.arg = NULL,
                 cex.pts = 1, cex.pts.fun = NULL, col.pts = par("col"),
                 pch.pts = 19, cex.npts = 1, cex.npts.fun = NULL,
                 col.npts = par("col"), pch.npts = 20, jitter.fac = 1,
                 with.lab = FALSE, cex.lbs = 1, adj.lbs = c(0, 0),
                 col.lbs = col.pts, lab.pts = NULL, lab.font = NULL,
                 alpha.trsp = NA, which.lbs = NULL, which.Order = NULL,
                 which.nonlbs = NULL, attr.pre = FALSE, return.Order = FALSE,
                 withSubst = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparePlot-methods_+3A_obj1">obj1</code></td>
<td>
<p> object of class <code>"InfluenceCurve"</code> </p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_obj2">obj2</code></td>
<td>
<p> object of class <code>"InfluenceCurve"</code> to be compared with <code>obj1</code></p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_obj3">obj3</code></td>
<td>
<p> optional: object of class <code>"InfluenceCurve"</code> to be compared with <code>obj1</code></p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_obj4">obj4</code></td>
<td>
<p> optional: object of class <code>"InfluenceCurve"</code> to be compared with <code>obj1</code></p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_data">data</code></td>
<td>
<p>optional data argument &mdash; for plotting observations into the plot;</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_withsweave">withSweave</code></td>
<td>
<p>logical: if <code>TRUE</code> (for working with <code>Sweave</code>)
no extra device is opened</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_forcesamemodel">forceSameModel</code></td>
<td>
<p>logical; shall we check / enforce that the model
of the ICs <code>obj1</code>, <code>obj2</code>, <code>obj3</code>, and <code>obj4</code>
be the same? </p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_main">main</code></td>
<td>
<p>logical: is a main title to be used? or <br />
just as argument <code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_col">col</code></td>
<td>
<p>color[s] of ICs in arguments <code>obj1</code> [,...,<code>obj4</code>].</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_lwd">lwd</code></td>
<td>
<p>linewidth[s] of ICs in arguments <code>obj1</code> [,...,<code>obj4</code>].</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_lty">lty</code></td>
<td>
<p>line-type[s] of ICs in arguments <code>obj1</code> [,...,<code>obj4</code>].</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_inner">inner</code></td>
<td>
<p>logical: do panels have their own titles? or <br />
character vector of / cast to length 'number of plotted 
dimensions';
if argument <code>to.draw.arg</code> is used, this refers to 
a vector of length <code>length(to.draw.arg)</code>, the 
actually plotted dimensions. For further information, see also 
description of argument <code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr> 
<tr><td><code id="comparePlot-methods_+3A_sub">sub</code></td>
<td>
<p>logical: is a sub-title to be used? or <br />
just as argument <code>sub</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_tmar">tmar</code></td>
<td>
<p>top margin &ndash; useful for non-standard main title sizes</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_bmar">bmar</code></td>
<td>
<p>bottom margin &ndash; useful for non-standard sub title sizes</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_cex.inner">cex.inner</code></td>
<td>
<p>magnification to be used for inner titles relative
to the current setting of <code>cex</code>; as in 
<code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_col.inner">col.inner</code></td>
<td>
<p>character or integer code; color for the inner title</p>
</td></tr>              
<tr><td><code id="comparePlot-methods_+3A_with.automatic.grid">with.automatic.grid</code></td>
<td>
<p>logical; should a grid be plotted alongside
with the ticks of the axes, automatically? If <code>TRUE</code> a respective
call to <code>grid</code> in argument <code>panel.first</code> is ignored. </p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_with.legend">with.legend</code></td>
<td>
<p>logical; shall a legend be plotted?</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_legend">legend</code></td>
<td>
<p>either <code>NULL</code> or a list of length (number of plotted panels)
of items which can be used as argument <code>legend</code> in
command <code>legend</code>.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_legend.location">legend.location</code></td>
<td>
<p>a valid argument <code>x</code> for <code><a href="graphics.html#topic+legend">legend</a></code> &mdash;
the place where to put the legend on the last issued
plot</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_legend.bg">legend.bg</code></td>
<td>
<p>background color for the legend</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_legend.cex">legend.cex</code></td>
<td>
<p>magnification factor for the legend</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_withmbr">withMBR</code></td>
<td>
<p>logical; shall horizontal lines with min and max of MBRE be plotted for
comparison?</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_mbrb">MBRB</code></td>
<td>
<p>matrix (or <code>NA</code>); coerced by usual recycling rules to a
matrix with as many rows as plotted panels and with first column
the lower bounds and the second column the upper bounds for the
respective coordinates (ideally given by the MBR-IC).</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_mbr.fac">MBR.fac</code></td>
<td>
<p>positive factor; scales the bounds given by argument <code>MBRB</code></p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_col.mbr">col.MBR</code></td>
<td>
<p>color for the MBR lines; as usual <code>col</code>-argument;</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_lty.mbr">lty.MBR</code></td>
<td>
<p>line type for the MBR lines; as usual <code>lty</code>-argument;</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_lwd.mbr">lwd.MBR</code></td>
<td>
<p>line width for the MBR lines; as usual <code>lwd</code>-argument;</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_x.vec">x.vec</code></td>
<td>
<p>a numeric vector of grid points to evaluate the influence curve;
by default, <code>x.vec</code> is <code>NULL</code>; then the grid is
produced automatically according to the distribution of the IC.
<code>x.vec</code> can be useful for usage with a rescaling of the
x-axis to avoid that the evaluation points be selected too
unevenly (i.e. on an equally spaced grid in the original scale,
but then, after rescaling non-equally).
The grid has to be specified in original scale; i.e.; when used
with rescaling, it should be chosen non-equally spaced. </p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_scalex">scaleX</code></td>
<td>
<p>logical; shall X-axis be rescaled (by default according to the cdf of
the underlying distribution)?</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_scaley">scaleY</code></td>
<td>
<p>logical; shall Y-axis be rescaled (by default according to a probit scale)?</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_scalex.fct">scaleX.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the domain of the IC
to [0,1]; if <code>scaleX</code> is <code>TRUE</code> and <code>scaleX.fct</code> is
missing, the cdf of the underlying observation distribution.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_scalex.inv">scaleX.inv</code></td>
<td>
<p>the inverse function to <code>scale.fct</code>, i.e., an isotone,
vectorized function mapping [0,1] to the domain of the IC
such that for any <code>x</code> in the domain,<br />
<code>scaleX.inv(scaleX.fct(x))==x</code>; if <code>scaleX</code> is <code>TRUE</code>
and <code>scaleX.inv</code> is
missing, the quantile function of the underlying observation distribution.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_scaley.fct">scaleY.fct</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate the
range of the respective coordinate of the IC
to [0,1]; defaulting to the cdf of <code class="reqn">{\cal N}(0,1)</code>;
can also be a list of functions with one list element for each
of the panels to be plot. </p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_scaley.inv">scaleY.inv</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate
the range [0,1] into the range of the respective coordinate of the IC;
defaulting to the quantile function of  <code class="reqn">{\cal N}(0,1)</code>;
can also be a list of functions with one list element for each
of the panels to be plot. </p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_scalen">scaleN</code></td>
<td>
<p>integer; defaults to 9; on rescaled axes, number of x
and y ticks if drawn automatically;</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_x.ticks">x.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given x-ticks (on original scale);</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_y.ticks">y.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given y-ticks (on original scale);
can be a list with one (numeric or NULL) item per panel</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_mfcolrow">mfColRow</code></td>
<td>
<p>shall default partition in panels be used &mdash; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_to.draw.arg">to.draw.arg</code></td>
<td>
<p>Either <code>NULL</code> (default; 
everything is plotted) or a vector of either integers 
(the indices of the subplots to be drawn) or characters 
&mdash; the names of the subplots to be drawn: these
names are to be chosen either among the row names of 
the trafo matrix 
<code>rownames(trafo(eval(obj1@CallL2Fam)@param))</code> 
or if the last expression is <code>NULL</code> a 
vector <code>"dim&lt;dimnr&gt;"</code>, <code>dimnr</code> running through 
the number of rows of the trafo matrix.
</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_withsubst">withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and lables is used; otherwise no substitution is used. </p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_col.pts">col.pts</code></td>
<td>
<p>color of the points of the <code>data</code> argument plotted;
can be a vector or a matrix. More specifically, if argument <code>attr.pre</code>
is <code>TRUE</code>, it is recycled to fill a matrix of dimension <code>n</code> by
<code>nIC</code> (<code>n</code> the number of observations prior to any selection and
<code>nIC</code> the number of ICs plotted) where filling is done in order column
first. The columns are used for possibly different colors for the different
ICs from arguments <code>obj1</code>, <code>obj2</code>, and, possibly <code>obj3</code> and
<code>obj4</code>. The selection done via <code>which.lbs</code> and
<code>which.Order</code> is then done afterwards and on this matrix; in this case,
argument <code>col.npts</code> is ignored. If <code>attr.pre</code> is <code>FALSE</code>,
<code>col.pts</code> is recycled to fill a matrix of dimension <code>n.s</code> by
<code>nIC</code> where <code>n.s</code> is the number of observations selected for
labelling and refers to the index ordering after the selection.
Then argument <code>col.npts</code> deteremines the colors of the shown but
non-labelled observations as given in argument <code>which.nonlbs</code>.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_pch.pts">pch.pts</code></td>
<td>
<p>symbol of the points of the <code>data</code> argument plotted
(may be a vector of length <code>nIC</code> or a matrix, see <code>col.pts</code>).</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_cex.pts">cex.pts</code></td>
<td>
<p>size of the points of the <code>data</code> argument plotted
(may be a vector of length <code>nIC</code> or a matrix, see <code>col.pts</code>).</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_cex.pts.fun">cex.pts.fun</code></td>
<td>
<p>rescaling function for the size of the points to be plotted;
either <code>NULL</code> (default), then <code>log(1+abs(x))</code> is used for each of
the rescalings, or a function which is then used for each of the
rescalings, or a list of functions; if it is a function or a list of
functions, if necessary it is recylced to length <code>nIC * dim</code>
where <code>dim</code> is the number of dimensions of the pICs to be plotted; 
in the index of this list, <code>nIC</code> is incremented first; 
then <code>dim</code>.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_col.npts">col.npts</code></td>
<td>
<p>color of the non-labelled points of the <code>data</code> argument
plotted; (may be a vector of length <code>nIC</code> the number of plotted pICs,
i.e., one value for each pIC in arguments <code>obj1</code>, <code>obj2</code>, and,
if available, <code>obj3</code> and <code>obj4</code>, or it can be a matrix
<code>nnlb &lt;- sum(which.nonlbs)</code> by <code>nIC</code>,
<code>nnlb</code> the number of non-labelled observations.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_pch.npts">pch.npts</code></td>
<td>
<p>symbol of the non-labelled points of the <code>data</code> argument
plotted (may be a vector of length <code>nIC</code> or a matrix,
see <code>col.npts</code>).</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_cex.npts">cex.npts</code></td>
<td>
<p>size of the non-labelled points of the <code>data</code> argument
plotted (may be a vector of length <code>nIC</code> or a matrix, see
<code>col.npts</code>).</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_cex.npts.fun">cex.npts.fun</code></td>
<td>
<p>rescaling function for the size of the non-labelled points
to be plotted; either <code>NULL</code> (default), then <code>log(1+abs(x))</code>
is used for each of the rescalings, or a function which is then used
for each of the rescalings, or a list of functions; if it is a
function or a list of functions, if necessary it is recylced
to length <code>nIC * dim</code> where <code>dim</code> is the number of dimensions of
the pICs to be plotted;  in the index of this list,
<code>nIC</code> is incremented first; then <code>dim</code>.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_lab.pts">lab.pts</code></td>
<td>
<p>character or NULL; labels to be plotted to the observations;
can be a vector of length <code>n</code>, <code>n</code> the number of 
all observations prior to any selection with <code>which.lbs</code>,
<code>which.Order</code>; if <code>lab.pts</code> is <code>NULL</code>, 
observation indices are used.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_with.lab">with.lab</code></td>
<td>
<p>logical; shall labels be plotted to the observations?
(May be a vector of length <code>nIC</code>, see <code>col.pts</code>
&ndash; but not a matrix).</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_cex.lbs">cex.lbs</code></td>
<td>
<p>size of the labels; can be vectorized to an array
of dim nlbs x <code>nIC</code> x npnl where npnl
is the number of plotted panels and nlbs the number of
plotted labels; if it is a vector, it is recylced in order
labels then plotted ICs then panels.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_col.lbs">col.lbs</code></td>
<td>
<p>color of the labels; can be vectorized to a matrix
of dim nlbs x <code>nIC</code> as <code>col.pts</code>.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_adj.lbs">adj.lbs</code></td>
<td>
<p>adjustment of the labels; can be vectorized to an array of
dim 2 x <code>nIC</code> x npnl, npnl the number of plotted panels;
if it is a vector, it is recycled in order (x,y)-coords
then ICs then panels.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_lab.font">lab.font</code></td>
<td>
<p>font to be used for labels (may be a vector of length
<code>nIC</code>, see <code>with.lab</code>).</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.lbl</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the data-symbols to be plotted.
Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_jitter.fac">jitter.fac</code></td>
<td>
<p>jittering factor used in case of a <code>DiscreteDistribution</code>
for plotting points of the <code>data</code> argument in a jittered 
fashion (may be a vector of length 2, see <code>with.lab</code>).</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_attr.pre">attr.pre</code></td>
<td>
<p>logical; do graphical attributes for plotted data refer
to indices prior (<code>TRUE</code>) or posterior to selection
via arguments <code>which.lbs</code>, <code>which.Order</code>, <code>which.nonlbs</code>
(<code>FALSE</code>)? </p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_which.lbs">which.lbs</code></td>
<td>
<p>either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then no observation is excluded.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_which.order">which.Order</code></td>
<td>
<p>for each of the given ICs, we order the observations (descending)
according to the norm given by the corresponding <code>normtype(object)</code>;
then <code>which.Order</code> either is an integer vector with the indices of the <em>ordered</em>
observations (remaining after a possible reduction by argument <code>which.lbs</code>)
to be plotted into graph or <code>NULL</code> &mdash; then no (further) observation
is excluded.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_which.nonlbs">which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then all non-labelled
observations are plotted.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_return.order">return.Order</code></td>
<td>
<p>logical; if <code>TRUE</code>, a list of length maximally four
with order vectors is returned &mdash; one for the ordering w.r.t. each of
the given ICs; more specifically, the order of the (remaining) observations
given by their original index is returned (remaining means: after a possible
reduction by argument <code>which.lbs</code>, and ordering is according to the norm given by
<code>normtype(object)</code>);
othervise we return <code>invisible()</code> as usual.</p>
</td></tr>
<tr><td><code id="comparePlot-methods_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any parameters of <code>plot.default</code> may be passed on to this particular
<code>plot</code> method. 
</p>
<p>For main-, inner, and subtitles given as arguments <code>main</code>, 
<code>inner</code>, and <code>sub</code>, top and bottom margins are enlarged to 5 resp. 
6 by default but may also be specified by <code>tmar</code> / <code>bmar</code> arguments. 
If <code>main</code> / <code>inner</code> / <code>sub</code> are 
logical then if the respective argument is <code>FALSE</code> nothing is done/plotted, 
but if it is <code>TRUE</code>, we use a default main title taking up the calling 
arguments in case of <code>main</code>, default inner titles taking up the
class and (named) parameter slots of arguments in case of <code>inner</code>,
and a &quot;generated on &lt;data&gt;&quot;-tag in case of <code>sub</code>.
Of course, if <code>main</code> / <code>inner</code> / <code>sub</code> are <code>character</code>, this
is used for the title; in case of <code>inner</code> it is then checked whether it
has correct length. If argument <code>withSubst</code> is <code>TRUE</code>, in all title 
and axis lable arguments, the following patterns are substituted:
</p>

<dl>
<dt><code>"%C1"</code>,<code>"%C2"</code>,[<code>"%C3"</code>,][<code>"%C4"</code>]</dt><dd><p>class of argument 
<code>obj&lt;i&gt;</code>, i=1,..4</p>
</dd>
<dt><code>"%A1"</code>,<code>"%A2"</code>,[<code>"%A3"</code>,][<code>"%A4"</code>]</dt><dd><p>deparsed argument  
<code>obj&lt;i&gt;</code>, i=1,..4</p>
</dd>
<dt><code>"%D"</code></dt><dd><p>time/date-string when the plot was generated</p>
</dd>
</dl>

<p>If argument <code>...</code> contains argument <code>ylim</code>, this may either be
as in <code>plot.default</code> (i.e. a vector of length 2) or a vector of 
length 2*(number of plotted dimensions); in the case of longer length, 
these are the values for <code>ylim</code> for the plotted dimensions of the IC, 
one pair for each dimension.
</p>
<p>In addition, argument <code>...</code> may contain arguments <code>panel.first</code>,
<code>panel.last</code>, i.e., hook expressions to be evaluated at the very beginning
and at the very end of each panel (within the then valid coordinates).
To be able to use these hooks for each panel individually, they may also be
lists of expressions (of the same length as the number of panels and
run through in the same order as the panels).
</p>


<h3>Value</h3>

<p>An S3 object of class <code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>,
<code><a href="#topic+IC-class">IC-class</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ROptEst)){

N0 &lt;- NormLocationScaleFamily(mean=0, sd=1) 
N0.Rob1 &lt;- InfRobModel(center = N0, neighbor = ContNeighborhood(radius = 0.5))

IC1 &lt;- optIC(model = N0, risk = asCov())
IC2 &lt;- optIC(model = N0.Rob1, risk = asMSE())

comparePlot(IC1,IC2)

set.seed(12); data &lt;- r(N0)(20)
comparePlot(IC1, IC2, data=data, with.lab = TRUE,
            which.lbs = c(1:4,15:20),
            which.Order = 1:6,
            return.Order = TRUE)


## don't test to reduce check time on CRAN

## selection of subpanels for plotting
par(mfrow=c(1,1))
comparePlot(IC1, IC2 ,mfColRow = FALSE, to.draw.arg=c("mean"),
            panel.first= grid(),ylim=c(-4,4),xlim=c(-6,6))
## matrix-valued ylim
comparePlot(IC1, IC2, panel.first= grid(),ylim=c(-4,4,0,4),xlim=c(-6,6))

x &lt;- c(data,-12,10)
comparePlot(IC1, IC2, data=x, which.Order=10,
            panel.first= grid(), ylim=c(-4,4,0,4), xlim=c(-6,6))

Y &lt;- Chisq(df=1)* DiscreteDistribution(c(-1,1))
comparePlot(IC1, IC2, data=x, which.Order=10,
            scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
            scaleY = TRUE, scaleY.fct=p(Y), scaleY.inv=q.l(Y),
            panel.first= grid(), ylim=c(-4,4,0,4), xlim=c(-6,6))
comparePlot(IC1, IC2, data=x, which.Order=10,
            scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
            scaleY = TRUE, scaleY.fct=p(Y), scaleY.inv=q.l(Y),
            x.ticks = c(-Inf, -10, -1,0,1,10,Inf),
            y.ticks = c(-Inf, -5, -1,0,1,5,Inf),
            panel.first= grid(), ylim=c(-4,4,0,4), xlim=c(-6,6))

## with use of trafo-matrix:
G &lt;- GammaFamily(scale = 1, shape = 2)
## explicitely transforming to
## MASS parametrization:
mtrafo &lt;- function(x){
     nms0 &lt;- names(c(main(param(G)),nuisance(param(G))))
     nms &lt;- c("shape","rate")
     fval0 &lt;- c(x[2], 1/x[1])
     names(fval0) &lt;- nms
     mat0 &lt;- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
                     dimnames = list(nms,nms0))                          
     list(fval = fval0, mat = mat0)}
G2 &lt;- G
trafo(G2) &lt;- mtrafo
G2
G2.Rob1 &lt;- InfRobModel(center = G2, neighbor = ContNeighborhood(radius = 0.5))
system.time(IC1 &lt;- optIC(model = G2, risk = asCov()))
system.time(IC2 &lt;- optIC(model = G2.Rob1, risk = asMSE()))
system.time(IC2.i &lt;- optIC(model = G2.Rob1, risk = asMSE(normtype=InfoNorm())))
system.time(IC2.s &lt;- optIC(model = G2.Rob1, risk = asMSE(normtype=SelfNorm())))

comparePlot(IC1,IC2, IC2.i, IC2.s)


}
</code></pre>

<hr>
<h2 id='ContIC'>Generating function for ContIC-class</h2><span id='topic+ContIC'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"ContIC"</code>;
i.e., an influence curves <code class="reqn">\eta</code> of the form
</p>
<p style="text-align: center;"><code class="reqn">\eta = (A\Lambda - a)\min(1,b/|A\Lambda - a|)</code>
</p>

<p>with clipping bound <code class="reqn">b</code>, centering constant <code class="reqn">a</code> and
standardizing matrix <code class="reqn">A</code>. <code class="reqn">\Lambda</code> stands for
the L2 derivative of the corresponding L2 differentiable 
parametric family which can be created via <code>CallL2Fam</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ContIC(name, CallL2Fam = call("L2ParamFamily"), 
       Curve = EuclRandVarList(RealRandVariable(Map = c(function(x){x}), 
                                                Domain = Reals())), 
       Risks, Infos, clip = Inf, cent = 0, stand = as.matrix(1), 
       lowerCase = NULL, neighborRadius = 0, w = new("HampelWeight"),
       normtype = NormType(), biastype = symmetricBias(),
       modifyIC = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ContIC_+3A_name">name</code></td>
<td>
<p> object of class <code>"character"</code>. </p>
</td></tr>
<tr><td><code id="ContIC_+3A_calll2fam">CallL2Fam</code></td>
<td>
<p> object of class <code>"call"</code>:
creates an object of the underlying L2-differentiable 
parametric family. </p>
</td></tr>
<tr><td><code id="ContIC_+3A_curve">Curve</code></td>
<td>
<p> object of class <code>"EuclRandVarList"</code> </p>
</td></tr>
<tr><td><code id="ContIC_+3A_risks">Risks</code></td>
<td>
<p> object of class <code>"list"</code>: 
list of risks; cf. <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code>. </p>
</td></tr>
<tr><td><code id="ContIC_+3A_infos">Infos</code></td>
<td>
<p> matrix of characters with two columns 
named <code>method</code> and <code>message</code>: additional informations. </p>
</td></tr>
<tr><td><code id="ContIC_+3A_clip">clip</code></td>
<td>
<p> positive real: clipping bound. </p>
</td></tr>
<tr><td><code id="ContIC_+3A_cent">cent</code></td>
<td>
<p> real: centering constant </p>
</td></tr>
<tr><td><code id="ContIC_+3A_stand">stand</code></td>
<td>
<p> matrix: standardizing matrix </p>
</td></tr>
<tr><td><code id="ContIC_+3A_w">w</code></td>
<td>
<p> HampelWeight: weight object</p>
</td></tr>
<tr><td><code id="ContIC_+3A_lowercase">lowerCase</code></td>
<td>
<p> optional constant for lower case solution. </p>
</td></tr>
<tr><td><code id="ContIC_+3A_neighborradius">neighborRadius</code></td>
<td>
<p> radius of the corresponding (unconditional) 
contamination neighborhood. </p>
</td></tr>
<tr><td><code id="ContIC_+3A_biastype">biastype</code></td>
<td>
<p> BiasType: type of the bias</p>
</td></tr>
<tr><td><code id="ContIC_+3A_normtype">normtype</code></td>
<td>
<p> NormType: type of the norm</p>
</td></tr>
<tr><td><code id="ContIC_+3A_modifyic">modifyIC</code></td>
<td>
<p> object of class <code>"OptionalFunction"</code>:
function of four arguments: (1) <code>L2Fam</code> an L2 parametric family
(2) <code>IC</code> an optional influence curve, (3) <code>withMakeIC</code>
a logical argument whether to enforce the IC side conditions
by <code>makeIC</code>, and (4) <code>...</code> for arguments to be passed to
calls to <code>E</code> in <code>makeIC</code>. Returns an object of
class <code>"IC"</code>. This function is mainly used for internal
computations! </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"ContIC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC-class">IC-class</a></code>, <code><a href="#topic+ContIC">ContIC</a></code> , <code><a href="#topic+HampIC-class">HampIC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- ContIC()
plot(IC1)
</code></pre>

<hr>
<h2 id='ContIC-class'>Influence curve of contamination type</h2><span id='topic+ContIC-class'></span><span id='topic+CallL2Fam+3C-+2CContIC-method'></span><span id='topic+cent'></span><span id='topic+cent+2CContIC-method'></span><span id='topic+cent+3C-'></span><span id='topic+cent+3C-+2CContIC-method'></span><span id='topic+clip+2CContIC-method'></span><span id='topic+clip+3C-'></span><span id='topic+clip+3C-+2CContIC-method'></span><span id='topic+lowerCase+3C-'></span><span id='topic+lowerCase+3C-+2CContIC-method'></span><span id='topic+stand+3C-'></span><span id='topic+stand+3C-+2CContIC-method'></span><span id='topic+neighbor+2CContIC-method'></span><span id='topic+generateIC+2CContNeighborhood+2CL2ParamFamily-method'></span><span id='topic+show+2CContIC-method'></span>

<h3>Description</h3>

<p>Class of (partial) influence curves of contamination type; 
i.e., influence curves <code class="reqn">\eta</code> of the form
</p>
<p style="text-align: center;"><code class="reqn">\eta = (A\Lambda - a)\min(1,b/|A\Lambda - a|)</code>
</p>

<p>with clipping bound <code class="reqn">b</code>, centering constant <code class="reqn">a</code> and
standardizing matrix <code class="reqn">A</code>. <code class="reqn">\Lambda</code> stands for
the L2 derivative of the corresponding L2 differentiable 
parametric family created via the call in the slot <code>CallL2Fam</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ContIC", ...)</code>.
More frequently they are created via the generating function 
<code>ContIC</code>, respectively via the method <code>generateIC</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>CallL2Fam</code>:</dt><dd><p> object of class <code>"call"</code>:
creates an object of the underlying L2-differentiable 
parametric family. </p>
</dd>
<dt><code>name</code>:</dt><dd><p> object of class <code>"character"</code> </p>
</dd>
<dt><code>Curve</code>:</dt><dd><p> object of class <code>"EuclRandVarList"</code></p>
</dd>
<dt><code>modifyIC</code></dt><dd><p> object of class <code>"OptionalFunction"</code>:
function of four arguments: (1) <code>L2Fam</code> an L2 parametric family
(2) <code>IC</code> an optional influence curve, (3) <code>withMakeIC</code>
a logical argument whether to enforce the IC side conditions
by <code>makeIC</code>, and (4) <code>...</code> for arguments to be passed to
calls to <code>E</code> in <code>makeIC</code>. Returns an object of
class <code>"IC"</code>. This function is mainly used for internal
computations! </p>
</dd>
<dt><code>Risks</code>:</dt><dd><p> object of class <code>"list"</code>: 
list of risks; cf. <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code>. </p>
</dd>
<dt><code>Infos</code>:</dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
<dt><code>clip</code>:</dt><dd><p> object of class <code>"numeric"</code>: 
clipping bound. </p>
</dd>
<dt><code>cent</code>:</dt><dd><p> object of class <code>"numeric"</code>:
centering constant. </p>
</dd>
<dt><code>stand</code>:</dt><dd><p> object of class <code>"matrix"</code>:
standardizing matrix. </p>
</dd>
<dt><code>weight</code>:</dt><dd><p> object of class <code>"HampelWeight"</code>:
weight function </p>
</dd>
<dt><code>biastype</code>:</dt><dd><p> object of class <code>"BiasType"</code>:
bias type (symmetric/onsided/asymmetric) </p>
</dd>
<dt><code>normtype</code>:</dt><dd><p> object of class <code>"NormType"</code>:
norm type (Euclidean, information/self-standardized)</p>
</dd>
<dt><code>lowerCase</code>:</dt><dd><p> object of class <code>"OptionalNumeric"</code>:
optional constant for lower case solution. </p>
</dd>
<dt><code>neighborRadius</code>:</dt><dd><p> object of class <code>"numeric"</code>:
radius of the corresponding (unconditional) contamination 
neighborhood. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"HampIC"</code>, directly.<br />
Class <code>"IC"</code>, by class <code>"HampIC"</code>.<br />
Class <code>"InfluenceCurve"</code>, by class <code>"IC"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>CallL2Fam&lt;-</dt><dd><p><code>signature(object = "ContIC")</code>: 
replacement function for slot <code>CallL2Fam</code>. </p>
</dd>
<dt>cent</dt><dd><p><code>signature(object = "ContIC")</code>: 
accessor function for slot <code>cent</code>. </p>
</dd>
<dt>cent&lt;-</dt><dd><p><code>signature(object = "ContIC")</code>: 
replacement function for slot <code>cent</code>. </p>
</dd>
<dt>clip</dt><dd><p><code>signature(x1 = "ContIC")</code>:
accessor function for slot <code>clip</code>. </p>
</dd>
<dt>clip&lt;-</dt><dd><p><code>signature(object = "ContIC")</code>: 
replacement function for slot <code>clip</code>. </p>
</dd>
<dt>stand&lt;-</dt><dd><p><code>signature(object = "ContIC")</code>:
replacement function for slot <code>stand</code>. </p>
</dd>
<dt>lowerCase&lt;-</dt><dd><p><code>signature(object = "ContIC")</code>: 
replacement function for slot <code>lowerCase</code>. </p>
</dd>
<dt>neighbor</dt><dd><p><code>signature(object = "ContIC")</code>: 
generates an object of class <code>"ContNeighborhood"</code> with
radius given in slot <code>neighborRadius</code>. </p>
</dd>
<dt>generateIC</dt><dd><p><code>signature(neighbor = "ContNeighborhood", L2Fam = "L2ParamFamily")</code>:
generate an object of class <code>"ContIC"</code>. Rarely called directly. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ContIC")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC-class">IC-class</a></code>, <code><a href="#topic+ContIC">ContIC</a></code> <code><a href="#topic+HampIC-class">HampIC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- new("ContIC")
plot(IC1)
</code></pre>

<hr>
<h2 id='ContNeighborhood'>Generating function for ContNeighborhood-class</h2><span id='topic+ContNeighborhood'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"ContNeighborhood"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ContNeighborhood(radius = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ContNeighborhood_+3A_radius">radius</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"ContNeighborhood"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ContNeighborhood-class">ContNeighborhood-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ContNeighborhood()

## The function is currently defined as
function(radius = 0){ 
    new("ContNeighborhood", radius = radius) 
}
</code></pre>

<hr>
<h2 id='ContNeighborhood-class'>Contamination Neighborhood</h2><span id='topic+ContNeighborhood-class'></span>

<h3>Description</h3>

<p>Class of (unconditional) contamination neighborhoods.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ContNeighborhood", ...)</code>.
More frequently they are created via the generating function 
<code>ContNeighborhood</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;(uncond.) convex contamination neighborhood&rdquo;. </p>
</dd>
<dt><code>radius</code></dt><dd><p>Object of class <code>"numeric"</code>: 
neighborhood radius. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UncondNeighborhood"</code>, directly.<br />
Class <code>"Neighborhood"</code>, by class <code>"UncondNeighborhood"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;ContNeighborhood&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ContNeighborhood">ContNeighborhood</a></code>, <code><a href="#topic+UncondNeighborhood-class">UncondNeighborhood-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("ContNeighborhood")
</code></pre>

<hr>
<h2 id='cutoff'>Generating function(s) for class 'cutoff'</h2><span id='topic+cutoff'></span><span id='topic+cutoff.sememp'></span><span id='topic+cutoff.chisq'></span><span id='topic+cutoff.quant'></span>

<h3>Description</h3>

<p>Generating function(s) for class <code>cutoff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutoff(name = "empirical", body.fct0,
       cutoff.quantile  = 0.95,
       norm = NormType(), QF, nsim = 100000)
cutoff.sememp(cutoff.quantile = 0.95)
cutoff.chisq(cutoff.quantile = 0.95)
cutoff.quant(qfct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff_+3A_name">name</code></td>
<td>
<p>argument for name slot of <code>cutoff</code> object</p>
</td></tr>
<tr><td><code id="cutoff_+3A_body.fct0">body.fct0</code></td>
<td>
<p>a call generated by code wrapped to <code>substitute</code> resp. <code>quote</code>;
the body of the <code>fct</code> slot of the <code>cutoff</code> object</p>
</td></tr>
<tr><td><code id="cutoff_+3A_cutoff.quantile">cutoff.quantile</code></td>
<td>
<p>numeric (in [0,1]); the corresponding slot value for the <code>cutoff</code> object</p>
</td></tr>
<tr><td><code id="cutoff_+3A_norm">norm</code></td>
<td>
<p>an object of class <code>NormType</code> &ndash; the norm/distance by which to produce
the cutoff - value.</p>
</td></tr>
<tr><td><code id="cutoff_+3A_nsim">nsim</code></td>
<td>
<p> integer: the sample size used for determining the quantiles
of <code class="reqn">(x^\tau Q x)^{1/2}</code>  for <code class="reqn">x</code> multivariate standard
normal and <code class="reqn">Q</code> a corresponding quadratic form</p>
</td></tr>
<tr><td><code id="cutoff_+3A_qf">QF</code></td>
<td>
<p> a quadratic (positive semidefinite, symmetric) matrix used
as quadratic form </p>
</td></tr>
<tr><td><code id="cutoff_+3A_qfct">qfct</code></td>
<td>
<p> a (nominal) quantile function </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cutoff</code> generates a valid object of class <code>"cutoff"</code>.
As function slot <code>fct</code> may only have a formal argument <code>data</code>,
the other arguments to determine the cutoff value, i.e. <code>norm</code>, <code>QF</code>, <code>nsim</code>,
<code>cutoff.quantile</code>, <code>nsim</code> have to enter the scope of this
function by lexical scoping; now <code>cutoff.quantile</code>, <code>norm</code>, <code>QF</code>
are to be taken from the calling environment (not from the defining one),
so we have delay evaluation of the function body, which is why we assume
it to be given wrapped into <code>substitute</code>  resp. <code>quote</code>.
<code>body.fct0</code> is by default (i.e. if argument <code>body.fct0</code> is missing) set
to<br /> <code>quote(quantile(slot(norm,"fct")(data), cutoff.quantile))</code>, internally,
i.e.; to an empirical quantile of the corresponding norms.<br />
</p>
<p><code>cutoff.sememp()</code> is a helper function generating the theoretical (asymptotic)
quantile of (the square root of) a corresponding quadratic form, assuming multivariate
normality; to determine this quantile <code>nsim</code> simulations are used.<br />
</p>
<p><code>cutoff.chisq()</code> is a helper function generating the theoretical (asymptotic)
quantile of (the square root of) a (self-standardized) quadratic form, assuming multivariate
normality; i.e.; a corresponding quantile of a Chi-Square distribution.
</p>
<p><code>cutoff.quant()</code> is a helper function generating the theoretical quantile
corresponding to the quantile function <code>qfct</code>; if <code>qfct</code> is missing,
it searches the caller environment for an object <code>..ICloc</code>, and if this
exists it uses the respective model quantile function; the fallback is
<code>qnorm</code>. At any rate, if there is an object <code>..trf</code> in the scope of
the function it is used to transfer the quantile (after its evaluation).
</p>


<h3>Value</h3>

<p>Object of class <code>"cutoff"</code>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutoff-class">cutoff-class</a></code>, <code><a href="#topic+ddPlot">ddPlot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>cutoff()
cutoff.sememp()
cutoff.chisq()
</code></pre>

<hr>
<h2 id='cutoff-class'>Cutoff class for distance-distance plots</h2><span id='topic+cutoff-class'></span><span id='topic+cutoff.quantile+3C-+2Ccutoff-method'></span><span id='topic+cutoff.quantile+3C-'></span><span id='topic+cutoff.quantile+2Ccutoff-method'></span><span id='topic+cutoff.quantile'></span><span id='topic+name+2Ccutoff-method'></span><span id='topic+fct+2Ccutoff-method'></span>

<h3>Description</h3>

<p>Class of methods to determine cutoff point for distance-distance plots;
used to derive other cutoff methods later by method dispatch.
</p>


<h3>Objects from the Class</h3>

<p>Objects could in principle be created by calls of the form <code>new("cutoff", ...)</code>.
More frequently they are created via the generating function 
<code><a href="#topic+cutoff">cutoff</a></code>, respectively via the helper functions 
<code>cutoff.sememp</code> and <code>cutoff.chisq</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p> object of class <code>"character"</code>; defaults to <code>"empirical"</code>
in prototype; </p>
</dd>
<dt><code>fct</code>:</dt><dd><p> an object of of class <code>"function"</code>; 
for this class layer, this function 
must only have one argument <code>data</code> (which may
but need not be used to determine the cutoff point empirically);
in derived classes this restriction could be dropped, if corresponding
special methods for <code>ddPlot</code> are derived. Defaults to 
<code>function(data) quantile(data)</code>.</p>
</dd>
<dt><code>cutoff.quantile</code>:</dt><dd><p> Object of class <code>"numeric"</code>:
a probability (in [0,1]) to determine the respective quantile 
(empirical or theoretical) to plot the cutoff line; defaults
to <code>0.95</code> in prototype;</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>cutoff.quantile</dt><dd><p><code>signature(object = "cutoff")</code>: 
accessor function for slot <code>cutoff.quantile</code>. </p>
</dd>
<dt>cutoff.quantile&lt;-</dt><dd><p><code>signature(object = "cutoff")</code>: 
replacement function for slot <code>cutoff.quantile</code>. </p>
</dd>
<dt>fct</dt><dd><p><code>signature(object = "cutoff")</code>: 
accessor function for slot <code>fct</code>. </p>
</dd>
<dt>name</dt><dd><p><code>signature(object = "cutoff")</code>: 
accessor function for slot <code>name</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ddPlot">ddPlot</a></code>, <code><a href="#topic+outlyingPlotIC">outlyingPlotIC</a></code> <code><a href="#topic+cutoff">cutoff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cutoff()
</code></pre>

<hr>
<h2 id='ddPlot-methods'> Methods for Function ddPlot in Package &lsquo;RobAStBase&rsquo; </h2><span id='topic+ddPlot'></span><span id='topic+ddPlot-methods'></span><span id='topic+ddPlot+2Cmatrix-method'></span><span id='topic+ddPlot+2Cnumeric-method'></span><span id='topic+ddPlot+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>ddPlot-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddPlot(data, dist.x, dist.y, cutoff.x, cutoff.y, ...)
## S4 method for signature 'matrix'
ddPlot(data, dist.x = NormType(), dist.y  = NormType(),
       cutoff.x, cutoff.y, ...,
       cutoff.quantile.x = 0.95, cutoff.quantile.y = cutoff.quantile.x,
       transform.x, transform.y = transform.x,
       id.n, cex.pts = 1,lab.pts, jitter.pts = 0, alpha.trsp = NA, adj =0, cex.idn,
       col.idn, lty.cutoff, lwd.cutoff, col.cutoff, text.abline = TRUE,
       text.abline.x = NULL, text.abline.y = NULL,
       cex.abline = par("cex"), col.abline = col.cutoff,
       font.abline = par("font"), adj.abline = c(0,0),
       text.abline.x.x = NULL, text.abline.x.y = NULL, 
       text.abline.y.x = NULL, text.abline.y.y = NULL,
       text.abline.x.fmt.cx = "%7.2f", text.abline.x.fmt.qx = "%4.2f%%",
       text.abline.y.fmt.cy = "%7.2f", text.abline.y.fmt.qy = "%4.2f%%", 
	     jitter.fac, jitter.tol = .Machine$double.eps,doplot = TRUE)
## S4 method for signature 'numeric'
ddPlot(data, dist.x = NormType(), dist.y  = NormType(),
       cutoff.x, cutoff.y, ...,
       cutoff.quantile.x = 0.95, cutoff.quantile.y = cutoff.quantile.x,
       transform.x, transform.y = transform.x,
       id.n, cex.pts = 1,lab.pts, jitter.pts = 0, alpha.trsp = NA, adj =0, cex.idn,
       col.idn, lty.cutoff, lwd.cutoff, col.cutoff, text.abline = TRUE,
       text.abline.x = NULL, text.abline.y = NULL,
       cex.abline = par("cex"), col.abline = col.cutoff,
       font.abline = par("font"), adj.abline = c(0,0),
       text.abline.x.x = NULL, text.abline.x.y = NULL, 
       text.abline.y.x = NULL, text.abline.y.y = NULL,
       text.abline.x.fmt.cx = "%7.2f", text.abline.x.fmt.qx = "%4.2f%%",
       text.abline.y.fmt.cy = "%7.2f", text.abline.y.fmt.qy = "%4.2f%%",
	   jitter.fac, jitter.tol=.Machine$double.eps, doplot = TRUE)
## S4 method for signature 'data.frame'
ddPlot(data, dist.x = NormType(), dist.y  = NormType(),
       cutoff.x, cutoff.y, ...,
       cutoff.quantile.x = 0.95, cutoff.quantile.y = cutoff.quantile.x,
       transform.x, transform.y = transform.x,
       id.n, cex.pts = 1,lab.pts, jitter.pts = 0, alpha.trsp = NA, adj =0, cex.idn,
       col.idn, lty.cutoff, lwd.cutoff, col.cutoff, text.abline = TRUE,
       text.abline.x = NULL, text.abline.y = NULL,
       cex.abline = par("cex"), col.abline = col.cutoff,
       font.abline = par("font"), adj.abline = c(0,0),
       text.abline.x.x = NULL, text.abline.x.y = NULL, 
       text.abline.y.x = NULL, text.abline.y.y = NULL,
       text.abline.x.fmt.cx = "%7.2f", text.abline.x.fmt.qx = "%4.2f%%",
       text.abline.y.fmt.cy = "%7.2f", text.abline.y.fmt.qy = "%4.2f%%",
	   jitter.fac, jitter.tol=.Machine$double.eps, doplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddPlot-methods_+3A_data">data</code></td>
<td>
<p>data coercable to <code>matrix</code>; the data  at which to produce the <code>ddPlot</code>.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot.default</code>, <code>text</code>, and <code>abline</code></p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_dist.x">dist.x</code></td>
<td>
<p>object of class <code>NormType</code>; the distance for the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_dist.y">dist.y</code></td>
<td>
<p>object of class <code>NormType</code>; the distance for the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_cutoff.x">cutoff.x</code></td>
<td>
<p>object of class <code>cutoff</code>; the cutoff information for the <code>x</code> axis
(the vertical line discriminating 'good' and 'bad' points).</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_cutoff.y">cutoff.y</code></td>
<td>
<p>object of class <code>cutoff</code>; the cutoff information for the <code>y</code> axis
(the horizontal line discriminating 'good' and 'bad' points).</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_cutoff.quantile.x">cutoff.quantile.x</code></td>
<td>
<p>numeric; the cutoff quantile for the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_cutoff.quantile.y">cutoff.quantile.y</code></td>
<td>
<p>numeric; the cutoff quantile for the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_transform.x">transform.x</code></td>
<td>
<p>function; a transformation to be performed before determining  the
distances of the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_transform.y">transform.y</code></td>
<td>
<p>function; a transformation to be performed before determining  the
distances of the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_id.n">id.n</code></td>
<td>
<p>a set of indices (or a corresponding logical vector); to select a subset
of the data in argument <code>data</code>.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_cex.pts">cex.pts</code></td>
<td>
<p>the corresponding <code>cex</code> argument for plotted points.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_lab.pts">lab.pts</code></td>
<td>
<p>a vector of labels for the (unsubsetted) <code>data</code>.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_jitter.pts">jitter.pts</code></td>
<td>
<p>the corresponding <code>jitter</code> argument for plotted points;
may be a vector of length 2 &ndash; for separate factors for x- and y-coordinate.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.lbl</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the data-symbols to be plotted.
Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_adj">adj</code></td>
<td>
<p>the corresponding argument for <code><a href="graphics.html#topic+text">text</a></code> for
labelling the outliers.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_cex.idn">cex.idn</code></td>
<td>
<p>the corresponding <code>cex</code> argument for
<code><a href="graphics.html#topic+text">text</a></code> for labelling the outliers.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_col.idn">col.idn</code></td>
<td>
<p>the corresponding <code>col</code> argument for
<code><a href="graphics.html#topic+text">text</a></code> for labelling the outliers.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_lty.cutoff">lty.cutoff</code></td>
<td>
<p>the corresponding <code>lty</code> argument for
<code><a href="graphics.html#topic+abline">abline</a></code> for drawing the cutoff lines;
either one lty-value (one value or vector) or a list of length 2
of lty-values.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_lwd.cutoff">lwd.cutoff</code></td>
<td>
<p>(vector cast to length 2): the corresponding <code>lwd</code> argument for
<code><a href="graphics.html#topic+abline">abline</a></code> for drawing the cutoff lines.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_col.cutoff">col.cutoff</code></td>
<td>
<p>(vector cast to length 2): the corresponding <code>col</code> argument for
<code><a href="graphics.html#topic+abline">abline</a></code> for drawing the cutoff lines.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline">text.abline</code></td>
<td>
<p>vector of logicals (cast to length 2): shall text be added
to cutoff lines.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.x">text.abline.x</code></td>
<td>
<p>text to be added to cutoff lines in x direction; if <code>NULL</code>
(default) we use &ldquo;[pp] %-cutoff = [ff]&rdquo; where [pp] is the percentage up to 2 digits
and [ff] is the cutoff value up to 2 digits.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.y">text.abline.y</code></td>
<td>
<p>text to be added to cutoff lines in y direction; if <code>NULL</code>
(default) we use &ldquo;[pp] %-cutoff = [ff]&rdquo; where [pp] is the percentage up to 2 digits
and [ff] is the cutoff value up to 2 digits.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_cex.abline">cex.abline</code></td>
<td>
<p>vector of numerics (cast to length 2): cex-value for added cutoff text.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_col.abline">col.abline</code></td>
<td>
<p>vector of length 2: color for added cutoff text.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_font.abline">font.abline</code></td>
<td>
<p>vector of length 2: font for added cutoff text.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_adj.abline">adj.abline</code></td>
<td>
<p>cast to 2 x 2 matrix (by recycling rules): adjustment values for added cutoff text.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.x.y">text.abline.x.y</code></td>
<td>
<p>y-coordinate of text to be added to cutoff lines in x direction;
if <code>NULL</code> (default) set to mid of <code>mean(par("usr")[c(3,4)])</code>.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.y.x">text.abline.y.x</code></td>
<td>
<p>x-coordinate of text to be added to cutoff lines in y direction;
if <code>NULL</code> (default) set to mid of <code>mean(par("usr")[c(1,2)])</code>.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.x.x">text.abline.x.x</code></td>
<td>
<p>x-coordinate of text to be added to cutoff lines in x direction;
if <code>NULL</code> (default) set to 1.05 times the cutoff value.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.y.y">text.abline.y.y</code></td>
<td>
<p>y-coordinate of text to be added to cutoff lines in y direction;
if <code>NULL</code> (default) set to 1.05 times the cutoff value.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.x.fmt.cx">text.abline.x.fmt.cx</code></td>
<td>
<p>format string (see <code><a href="base.html#topic+sprintf">gettextf</a></code>) to format the cutoff value in label in x direction.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.x.fmt.qx">text.abline.x.fmt.qx</code></td>
<td>
<p>format string to format cutoff probability in label in x direction.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.y.fmt.cy">text.abline.y.fmt.cy</code></td>
<td>
<p>format string to format the cutoff value in label in y direction.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_text.abline.y.fmt.qy">text.abline.y.fmt.qy</code></td>
<td>
<p>format string to format cutoff probability in label in y direction.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_jitter.fac">jitter.fac</code></td>
<td>
<p>factor for jittering, see <code>jitter</code>;</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_jitter.tol">jitter.tol</code></td>
<td>
<p>threshold for jittering: if distance between points is smaller
than <code>jitter.tol</code>, points are considered replicates.</p>
</td></tr>
<tr><td><code id="ddPlot-methods_+3A_doplot">doplot</code></td>
<td>
<p>logical; shall a plot be produced? if <code>FALSE</code> only the return values are produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>matrix</code>-method calls <code>.ddPlot.MatNtNtCoCo</code>,
the <code>numeric</code>- and <code>data.frame</code>-methods coerce argument <code>data</code>
to <code>matrix</code> &mdash; the <code>numeric</code>-method by a call to <code>matrix(data, nrow=1)</code>,
in the  <code>data.frame</code>-methods by a call to <code>t(as.matrix(data))</code>.
</p>
<p>In arguments <code>text.abline.x</code> and <code>text.abline.y</code> the following 
patterns are substituted:
</p>

<dl>
<dt><code>"%qx"</code></dt><dd><p>cutoff-quantile in x-direction</p>
</dd>
<dt><code>"%qy"</code></dt><dd><p>cutoff-quantile in y-direction</p>
</dd>
<dt><code>"%cx"</code></dt><dd><p>cutoff-value in x-direction</p>
</dd>
<dt><code>"%cy"</code></dt><dd><p>cutoff-value in y-direction</p>
</dd>
</dl>



<h3>Value</h3>

<p>If argument <code>doplot</code> is <code>FALSE</code>:
A list (returned as <code>invisible()</code>) with items
</p>
<table>
<tr><td><code>id.x</code></td>
<td>
<p>the indices of (possibly transformed) data (within subset <code>id.n</code>) beyond the <code>x</code>-cutoff</p>
</td></tr>
<tr><td><code>id.y</code></td>
<td>
<p>the indices of (possibly transformed) data (within subset <code>id.n</code>) beyond the <code>y</code>-cutoff</p>
</td></tr>
<tr><td><code>id.xy</code></td>
<td>
<p>the indices of (possibly transformed) data (within subset <code>id.n</code>) beyond the <code>x</code>-cutoff and the <code>y</code>-cutoff</p>
</td></tr>
<tr><td><code>qtx</code></td>
<td>
<p>the quantiles of the distances of the (possibly transformed) data in <code>x</code> direction</p>
</td></tr>
<tr><td><code>qty</code></td>
<td>
<p>the quantiles of the distances of the (possibly transformed) data in <code>y</code> direction</p>
</td></tr>
<tr><td><code>cutoff.x.v</code></td>
<td>
<p>the cutoff value in <code>x</code> direction</p>
</td></tr>
<tr><td><code>cutoff.y.v</code></td>
<td>
<p>the cutoff value in <code>y</code> direction</p>
</td></tr>
</table>
<p>If argument <code>doplot</code> is <code>TRUE</code>:
An S3 object of class <code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
One item is <code>retV</code> which is the return value in case <code>doplot</code> is <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MX &lt;- matrix(rnorm(1500),nrow=6)
QM &lt;- matrix(rnorm(36),nrow=6); QM &lt;- QM %*% t(QM)
ddPlot(data=MX, dist.y=QFNorm(QuadF=PosSemDefSymmMatrix(QM)))
</code></pre>

<hr>
<h2 id='evalIC'>Generic function for evaluating ICs</h2><span id='topic+evalIC'></span>

<h3>Description</h3>

<p>Generic function for evaluating ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalIC(IC, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalIC_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"IC"</code> </p>
</td></tr>
<tr><td><code id="evalIC_+3A_x">x</code></td>
<td>
<p> numeric vector or matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p> The list of random variables contained in the slot <code>Curve</code> 
is evaluated at <code>x</code>. </p>


<h3>Value</h3>

<p> In case <code>x</code> is numeric a vector and in case <code>x</code> 
is matrix a matrix is returned. </p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC-class">IC-class</a></code></p>

<hr>
<h2 id='FixRobModel'>Generating function for FixRobModel-class</h2><span id='topic+FixRobModel'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"FixRobModel"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FixRobModel(center = ParamFamily(modifyParam = 
            function(theta) Norm(mean = theta)), neighbor = ContNeighborhood())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FixRobModel_+3A_center">center</code></td>
<td>
<p> object of class <code>"ProbFamily"</code> </p>
</td></tr>
<tr><td><code id="FixRobModel_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"UncondNeighborhood"</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"FixRobModel"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FixRobModel-class">FixRobModel-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(M1 &lt;- FixRobModel())

## The function is currently defined as
function(center = ParamFamily(), neighbor = ContNeighborhood()){
    new("FixRobModel", center = center, neighbor = neighbor)
}
</code></pre>

<hr>
<h2 id='FixRobModel-class'>Robust model with fixed (unconditional) neighborhood</h2><span id='topic+FixRobModel-class'></span><span id='topic+neighbor+3C-+2CFixRobModel-method'></span><span id='topic+show+2CFixRobModel-method'></span>

<h3>Description</h3>

<p>Class of robust models with fixed (unconditional) neighborhoods.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FixRobModel", ...)</code>.
More frequently they are created via the generating function 
<code>FixRobModel</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>center</code></dt><dd><p>Object of class <code>"ProbFamily"</code>. </p>
</dd>
<dt><code>neighbor</code></dt><dd><p>Object of class <code>"UncondNeighborhood"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"RobModel"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>neighbor&lt;-</dt><dd><p><code>signature(object = "FixRobModel")</code>: 
replacement function for slot <code>neighbor&lt;-</code> </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "FixRobModel")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+ProbFamily-class">ProbFamily-class</a></code>, <code><a href="#topic+UncondNeighborhood-class">UncondNeighborhood-class</a></code>,
<code><a href="#topic+FixRobModel">FixRobModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("FixRobModel")
</code></pre>

<hr>
<h2 id='generateIC'>Generic function for the generation of influence curves</h2><span id='topic+generateIC'></span>

<h3>Description</h3>

<p>This function is rarely called directly. It is used 
by other functions to create objects of class <code>"IC"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateIC(neighbor, L2Fam, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateIC_+3A_neighbor">neighbor</code></td>
<td>
<p> Object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="generateIC_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures. </p>
</td></tr>
<tr><td><code id="generateIC_+3A_...">...</code></td>
<td>
<p> additional parameters </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC-class">IC-class</a></code>, <code><a href="#topic+ContIC-class">ContIC-class</a></code>, <code><a href="#topic+TotalVarIC-class">TotalVarIC-class</a></code></p>

<hr>
<h2 id='generateIC.fct-methods'>Generic Function for making ICs consistent at a possibly different model</h2><span id='topic+generateIC.fct'></span><span id='topic+generateIC.fct-methods'></span><span id='topic+generateIC.fct+2CUncondNeighborhood+2CL2ParamFamily-method'></span>

<h3>Description</h3>

<p>Generic function for providing centering and Fisher consistency of ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateIC.fct(neighbor, L2Fam, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateIC.fct-methods_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"UncondNeighborhood"</code> </p>
</td></tr>
<tr><td><code id="generateIC.fct-methods_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures; may be missing. </p>
</td></tr>
<tr><td><code id="generateIC.fct-methods_+3A_...">...</code></td>
<td>
<p> additional parameters </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An IC at the model.</p>


<h3>Methods</h3>


<dl>
<dt>generateIC.fct</dt><dd><p><code>signature(IC = "UncondNeighborhood", L2Fam = "L2ParamFamily"</code>: ...</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+IC-class">IC-class</a></code></p>

<hr>
<h2 id='getBiasIC'>Generic function for the computation of the asymptotic bias for an IC</h2><span id='topic+getBiasIC'></span><span id='topic+getBiasIC-methods'></span><span id='topic+getBiasIC+2CIC+2CUncondNeighborhood-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the asymptotic bias for an IC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBiasIC(IC, neighbor, ...)

## S4 method for signature 'IC,UncondNeighborhood'
getBiasIC(IC, neighbor, L2Fam,
             biastype = symmetricBias(), normtype = NormType(),
             tol = .Machine$double.eps^0.25, numbeval = 1e5, withCheck = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBiasIC_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"InfluenceCurve"</code> </p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>"L2ParamFamily"</code>. </p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_biastype">biastype</code></td>
<td>
<p>object of class <code>"BiasType"</code></p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_normtype">normtype</code></td>
<td>
<p>object of class <code>"NormType"</code></p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_numbeval">numbeval</code></td>
<td>
<p>number of evalation points.</p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_withcheck">withCheck</code></td>
<td>
<p>logical: should a call to <code>checkIC</code> be done to
check accuracy (defaults to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_...">...</code></td>
<td>
<p> additional parameters to be passed to expectation <code>E</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bias of the IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>IC = &quot;IC&quot;, neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>determines the as. bias by random evaluation of the IC;
this random evaluation is done by the internal S4-method
<code>.evalBiasIC</code>; this latter dispatches according to
the signature <code>IC, neighbor, biastype</code>.<br />
For signature <code>IC="IC", neighbor = "ContNeighborhood",
        biastype = "BiasType"</code>, also an argument <code>normtype</code>
is used to be able to use self- or information standardizing
norms; besides this the signatures
<code>IC="IC", neighbor = "TotalVarNeighborhood",
        biastype = "BiasType"</code>,
<code>IC="IC", neighbor = "ContNeighborhood",
        biastype = "onesidedBias"</code>, and
<code>IC="IC", neighbor = "ContNeighborhood",
        biastype = "asymmetricBias"</code> are implemented.
</p>
</dd>
</dl>


<h3>Note</h3>

<p>This generic function is still under construction.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>
<p>Ruckdeschel, P. and Kohl, M. (2005) Computation of the Finite Sample Bias
of M-estimators on Neighborhoods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRiskIC-methods">getRiskIC-methods</a></code>, <code><a href="#topic+InfRobModel-class">InfRobModel-class</a></code></p>

<hr>
<h2 id='getBoundedIC'>getBoundedIC</h2><span id='topic+getBoundedIC'></span>

<h3>Description</h3>

<p>Generates a bounded influence curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBoundedIC(L2Fam, D=trafo(L2Fam@param), ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBoundedIC_+3A_l2fam">L2Fam</code></td>
<td>
<p>object of class <code>"L2ParamFamily"</code></p>
</td></tr>
<tr><td><code id="getBoundedIC_+3A_d">D</code></td>
<td>
<p>matrix with as many columns as <code>length(L2Fam@param)</code></p>
</td></tr>
<tr><td><code id="getBoundedIC_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>E</code></p>
</td></tr>
<tr><td><code id="getBoundedIC_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>(a bounded) pIC (to matrix <code>D</code>) given as object of class
<code>"EuclRandVariable"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>

<hr>
<h2 id='getFiRisk'>Generic Function for Computation of Finite-Sample Risks</h2><span id='topic+getFiRisk'></span><span id='topic+getFiRisk-methods'></span><span id='topic+getFiRisk+2CfiUnOvShoot+2CNorm+2CContNeighborhood-method'></span><span id='topic+getFiRisk+2CfiUnOvShoot+2CNorm+2CTotalVarNeighborhood-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of finite-sample risks.
This function is rarely called directly. It is used by 
other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFiRisk(risk, Distr, neighbor, ...)

## S4 method for signature 'fiUnOvShoot,Norm,ContNeighborhood'
getFiRisk(risk, Distr, 
          neighbor, clip, stand, sampleSize, Algo, cont)

## S4 method for signature 'fiUnOvShoot,Norm,TotalVarNeighborhood'
getFiRisk(risk, Distr, 
          neighbor, clip, stand, sampleSize, Algo, cont)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFiRisk_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getFiRisk_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getFiRisk_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getFiRisk_+3A_...">...</code></td>
<td>
<p> additional parameters. </p>
</td></tr>
<tr><td><code id="getFiRisk_+3A_clip">clip</code></td>
<td>
<p> positive real: clipping bound </p>
</td></tr>
<tr><td><code id="getFiRisk_+3A_stand">stand</code></td>
<td>
<p> standardizing constant/matrix. </p>
</td></tr>
<tr><td><code id="getFiRisk_+3A_samplesize">sampleSize</code></td>
<td>
<p> integer: sample size. </p>
</td></tr>
<tr><td><code id="getFiRisk_+3A_algo">Algo</code></td>
<td>
<p> &quot;A&quot; or &quot;B&quot;. </p>
</td></tr>
<tr><td><code id="getFiRisk_+3A_cont">cont</code></td>
<td>
<p> &quot;left&quot; or &quot;right&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the finite-sample under-/overshoot risk
is based on FFT. For more details we refer to Section 11.3 of Kohl (2005).
</p>


<h3>Value</h3>

<p>The finite-sample risk is computed.</p>


<h3>Methods</h3>


<dl>
<dt>risk = &quot;fiUnOvShoot&quot;, Distr = &quot;Norm&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>computes finite-sample under-/overshoot risk in methods for 
function <code>getFixRobIC</code>. </p>
</dd>
<dt>risk = &quot;fiUnOvShoot&quot;, Distr = &quot;Norm&quot;, neighbor = &quot;TotalVarNeighborhood&quot;</dt><dd> 
<p>computes finite-sample under-/overshoot risk in methods for 
function <code>getFixRobIC</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>
<p>Ruckdeschel, P. and Kohl, M. (2005) Computation of the Finite Sample Risk 
of M-estimators on Neighborhoods.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+fiRisk-class">fiRisk-class</a></code></p>

<hr>
<h2 id='getRiskFctBV-methods'>Methods for Function getRiskFctBV  in Package &lsquo;RobAStBase&rsquo;</h2><span id='topic+getRiskFctBV'></span><span id='topic+getRiskFctBV-methods'></span><span id='topic+getRiskFctBV+2CasGRisk+2CANY-method'></span><span id='topic+getRiskFctBV+2CasMSE+2CANY-method'></span><span id='topic+getRiskFctBV+2CinterpolRisk+2CANY-method'></span><span id='topic+getRiskFctBV+2CasSemivar+2ConesidedBias-method'></span><span id='topic+getRiskFctBV+2CasSemivar+2CasymmetricBias-method'></span>

<h3>Description</h3>

<p>getRiskFctBV for a given object of S4 class <code>asGRisk</code>
returns a function in bias and variance to compute the asymptotic
risk.</p>


<h3>Methods</h3>


<dl>
<dt>getRiskFctBV</dt><dd><p><code>signature(risk = "asGRisk", biastype = "ANY")</code>:
returns an error that the respective method is not yet implemented. </p>
</dd>
<dt>getRiskFctBV</dt><dd><p><code>signature(risk = "asMSE", biastype = "ANY")</code>:
returns a function with arguments <code>bias</code> and <code>variance</code>
to compute the asymptotic MSE for a given ALE at a situation where it has bias <code>bias</code>
(including the radius!) and variance <code>variance</code>. </p>
</dd>
<dt>getRiskFctBV</dt><dd><p><code>signature(risk = "asSemivar", biastype = "onesidedBias")</code>:
returns a function with arguments <code>bias</code> and <code>variance</code>
to compute the asymptotic semivariance error, i.e. <code class="reqn">E[(S_n-\theta)_+^2]</code>
resp. <code class="reqn">E[(S_n-\theta)_-^2]</code>, for a given ALE <code class="reqn">S_n</code>
at a  situation where it has one-sided bias <code>bias</code> (including the radius!)
and variance <code>variance</code>. </p>
</dd>
<dt>getRiskFctBV</dt><dd><p><code>signature(risk = "asSemivar", biastype = "asymmetricBias")</code>:
returns a function with arguments <code>bias</code> and <code>variance</code>
to compute the asymptotic semivariance error, i.e.
<code class="reqn">E[\nu_1 (S_n-\theta)_+^2+\nu_2(S_n-\theta)_-^2]</code>
for a given ALE <code class="reqn">S_n</code> at a situation where it has one-sided bias
<code>bias</code> (including the radius!) and variance <code>variance</code>. </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>myrisk &lt;- asMSE()
getRiskFctBV(myrisk)
</code></pre>

<hr>
<h2 id='getRiskIC'>Generic function for the computation of a risk for an IC</h2><span id='topic+getRiskIC'></span><span id='topic+getRiskIC-methods'></span><span id='topic+getRiskIC+2CIC+2CasCov+2Cmissing+2Cmissing-method'></span><span id='topic+getRiskIC+2CIC+2CasCov+2Cmissing+2CL2ParamFamily-method'></span><span id='topic+getRiskIC+2CIC+2CtrAsCov+2Cmissing+2Cmissing-method'></span><span id='topic+getRiskIC+2CIC+2CtrAsCov+2Cmissing+2CL2ParamFamily-method'></span><span id='topic+getRiskIC+2CIC+2CasBias+2CUncondNeighborhood+2Cmissing-method'></span><span id='topic+getRiskIC+2CIC+2CasBias+2CUncondNeighborhood+2CL2ParamFamily-method'></span><span id='topic+getRiskIC+2CIC+2CasMSE+2CUncondNeighborhood+2Cmissing-method'></span><span id='topic+getRiskIC+2CIC+2CasMSE+2CUncondNeighborhood+2CL2ParamFamily-method'></span><span id='topic+getRiskIC+2CTotalVarIC+2CasUnOvShoot+2CUncondNeighborhood+2Cmissing-method'></span><span id='topic+getRiskIC+2CIC+2CfiUnOvShoot+2CContNeighborhood+2Cmissing-method'></span><span id='topic+getRiskIC+2CIC+2CfiUnOvShoot+2CTotalVarNeighborhood+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of a risk for an IC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRiskIC(IC, risk, neighbor, L2Fam, ...)

## S4 method for signature 'IC,asCov,missing,missing'
getRiskIC(IC, risk,
    tol = .Machine$double.eps^0.25, withCheck = TRUE, ...)

## S4 method for signature 'IC,asCov,missing,L2ParamFamily'
getRiskIC(IC, risk, L2Fam,
    tol = .Machine$double.eps^0.25, withCheck = TRUE, ..., diagnostic = FALSE)

## S4 method for signature 'IC,trAsCov,missing,missing'
getRiskIC(IC, risk,
    tol = .Machine$double.eps^0.25, withCheck = TRUE, ...)

## S4 method for signature 'IC,trAsCov,missing,L2ParamFamily'
getRiskIC(IC, risk, L2Fam,
    tol = .Machine$double.eps^0.25, withCheck = TRUE, ...)

## S4 method for signature 'IC,asBias,UncondNeighborhood,missing'
getRiskIC(IC, risk, neighbor,
    tol = .Machine$double.eps^0.25, withCheck = TRUE, ...)

## S4 method for signature 'IC,asBias,UncondNeighborhood,L2ParamFamily'
getRiskIC(IC, risk, neighbor, L2Fam,
    tol = .Machine$double.eps^0.25, withCheck = TRUE, ...)

## S4 method for signature 'IC,asMSE,UncondNeighborhood,missing'
getRiskIC(IC, risk, neighbor,
    tol = .Machine$double.eps^0.25, withCheck = TRUE, ...)

## S4 method for signature 'IC,asMSE,UncondNeighborhood,L2ParamFamily'
getRiskIC(IC, risk, neighbor, L2Fam,
    tol = .Machine$double.eps^0.25, withCheck = TRUE, ...)

## S4 method for signature 'TotalVarIC,asUnOvShoot,UncondNeighborhood,missing'
getRiskIC(IC, risk, neighbor)

## S4 method for signature 'IC,fiUnOvShoot,ContNeighborhood,missing'
getRiskIC(IC, risk, neighbor, sampleSize, Algo = "A", cont = "left")

## S4 method for signature 'IC,fiUnOvShoot,TotalVarNeighborhood,missing'
getRiskIC(IC, risk, neighbor, sampleSize, Algo = "A", cont = "left")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRiskIC_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"InfluenceCurve"</code> </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>"L2ParamFamily"</code>. </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_...">...</code></td>
<td>
<p> additional parameters (e.g. to be passed to <code>E</code>). </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>  
<tr><td><code id="getRiskIC_+3A_samplesize">sampleSize</code></td>
<td>
<p> integer: sample size. </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_algo">Algo</code></td>
<td>
<p> &quot;A&quot; or &quot;B&quot;. </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_cont">cont</code></td>
<td>
<p> &quot;left&quot; or &quot;right&quot;. </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_withcheck">withCheck</code></td>
<td>
<p>logical: should a call to <code>checkIC</code> be done to
check accuracy (defaults to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>To make sure that the results are valid, it is recommended
to include an additional check of the IC properties of <code>IC</code> 
using <code>checkIC</code>.</p>


<h3>Value</h3>

<p>The risk of an IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>IC = &quot;IC&quot;, risk = &quot;asCov&quot;, neighbor = &quot;missing&quot;, L2Fam = &quot;missing&quot;</dt><dd> 
<p>asymptotic covariance of <code>IC</code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;asCov&quot;, neighbor = &quot;missing&quot;, L2Fam = &quot;L2ParamFamily&quot;</dt><dd> 
<p>asymptotic covariance of <code>IC</code> under <code>L2Fam</code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;trAsCov&quot;, neighbor = &quot;missing&quot;, L2Fam = &quot;missing&quot;</dt><dd> 
<p>asymptotic covariance of <code>IC</code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;trAsCov&quot;, neighbor = &quot;missing&quot;, L2Fam = &quot;L2ParamFamily&quot;</dt><dd> 
<p>asymptotic covariance of <code>IC</code> under <code>L2Fam</code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;asBias&quot;, neighbor = &quot;ContNeighborhood&quot;, L2Fam = &quot;missing&quot;</dt><dd> 
<p>asymptotic bias of <code>IC</code> under convex contaminations; uses method <code><a href="#topic+getBiasIC">getBiasIC</a></code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;asBias&quot;, neighbor = &quot;ContNeighborhood&quot;, L2Fam = &quot;L2ParamFamily&quot;</dt><dd> 
<p>asymptotic bias of <code>IC</code> under convex contaminations and <code>L2Fam</code>; uses method <code><a href="#topic+getBiasIC">getBiasIC</a></code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;asBias&quot;, neighbor = &quot;TotalVarNeighborhood&quot;, L2Fam = &quot;missing&quot;</dt><dd> 
<p>asymptotic bias of <code>IC</code> in case of total variation neighborhoods; uses method <code><a href="#topic+getBiasIC">getBiasIC</a></code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;asBias&quot;, neighbor = &quot;TotalVarNeighborhood&quot;, L2Fam = &quot;L2ParamFamily&quot;</dt><dd> 
<p>asymptotic bias of <code>IC</code> under <code>L2Fam</code> in case of total variation 
neighborhoods; uses method <code><a href="#topic+getBiasIC">getBiasIC</a></code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;asMSE&quot;, neighbor = &quot;UncondNeighborhood&quot;, L2Fam = &quot;missing&quot;</dt><dd> 
<p>asymptotic mean square error of <code>IC</code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;asMSE&quot;, neighbor = &quot;UncondNeighborhood&quot;, L2Fam = &quot;L2ParamFamily&quot;</dt><dd> 
<p>asymptotic mean square error of <code>IC</code> under <code>L2Fam</code>. </p>
</dd>
<dt>IC = &quot;TotalVarIC&quot;, risk = &quot;asUnOvShoot&quot;, neighbor = &quot;UncondNeighborhood&quot;, L2Fam = &quot;missing&quot;</dt><dd> 
<p>asymptotic under-/overshoot risk of <code>IC</code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;fiUnOvShoot&quot;, neighbor = &quot;ContNeighborhood&quot;, L2Fam = &quot;missing&quot;</dt><dd> 
<p>finite-sample under-/overshoot risk of <code>IC</code>. </p>
</dd>
<dt>IC = &quot;IC&quot;, risk = &quot;fiUnOvShoot&quot;, neighbor = &quot;TotalVarNeighborhood&quot;, L2Fam = &quot;missing&quot;</dt><dd> 
<p>finite-sample under-/overshoot risk of <code>IC</code>. </p>
</dd>
</dl>


<h3>Note</h3>

<p>This generic function is still under construction.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>
<p>Ruckdeschel, P. and Kohl, M. (2005) Computation of the Finite Sample Risk 
of M-estimators on Neighborhoods.
</p>


<h3>See Also</h3>

<p><code><a href="ROptEst.html#topic+getRiskIC">getRiskIC</a></code>, <code><a href="#topic+InfRobModel-class">InfRobModel-class</a></code></p>

<hr>
<h2 id='getweight-methods'>Generating weights</h2><span id='topic+getweight-methods'></span><span id='topic+getweight'></span><span id='topic+getweight+2CHampelWeight+2CContNeighborhood+2CBiasType-method'></span><span id='topic+getweight+2CHampelWeight+2CContNeighborhood+2ConesidedBias-method'></span><span id='topic+getweight+2CHampelWeight+2CContNeighborhood+2CasymmetricBias-method'></span><span id='topic+getweight+2CBdStWeight+2CTotalVarNeighborhood+2CBiasType-method'></span><span id='topic+minbiasweight-methods'></span><span id='topic+minbiasweight'></span><span id='topic+minbiasweight+2CHampelWeight+2CContNeighborhood+2CBiasType-method'></span><span id='topic+minbiasweight+2CHampelWeight+2CContNeighborhood+2ConesidedBias-method'></span><span id='topic+minbiasweight+2CHampelWeight+2CContNeighborhood+2CasymmetricBias-method'></span><span id='topic+minbiasweight+2CBdStWeight+2CTotalVarNeighborhood+2CBiasType-method'></span>

<h3>Description</h3>

<p>Generates weight functions of Hampel / BdSt type for different bias and norm types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getweight(Weight, neighbor, biastype, ...)
minbiasweight(Weight, neighbor, biastype, ...)
## S4 method for signature 'HampelWeight,ContNeighborhood,BiasType'
getweight(Weight, neighbor, biastype, normW)
## S4 method for signature 'HampelWeight,ContNeighborhood,BiasType'
minbiasweight(Weight, neighbor, biastype, normW)
## S4 method for signature 'HampelWeight,ContNeighborhood,onesidedBias'
getweight(Weight, neighbor, biastype, ...)
## S4 method for signature 'HampelWeight,ContNeighborhood,onesidedBias'
minbiasweight(Weight, neighbor, biastype, ...)
## S4 method for signature 'HampelWeight,ContNeighborhood,asymmetricBias'
getweight(Weight, neighbor, biastype, ...)
## S4 method for signature 'HampelWeight,ContNeighborhood,asymmetricBias'
minbiasweight(Weight, neighbor, biastype, ...)
## S4 method for signature 'BdStWeight,TotalVarNeighborhood,BiasType'
getweight(Weight, neighbor, biastype, ...)
## S4 method for signature 'BdStWeight,TotalVarNeighborhood,BiasType'
minbiasweight(Weight, neighbor, biastype, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getweight-methods_+3A_weight">Weight</code></td>
<td>
<p> Object of class <code>"RobWeight"</code>. </p>
</td></tr>
<tr><td><code id="getweight-methods_+3A_neighbor">neighbor</code></td>
<td>
<p> Object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getweight-methods_+3A_biastype">biastype</code></td>
<td>
<p> Object of class <code>"BiasType"</code>. </p>
</td></tr>
<tr><td><code id="getweight-methods_+3A_normw">normW</code></td>
<td>
<p> Object of class <code>"NormType"</code> &mdash; only for signature <code>HampelWeight,ContNeighborhood,BiasType</code>. </p>
</td></tr>
<tr><td><code id="getweight-methods_+3A_...">...</code></td>
<td>
<p>possibly additional (unused) arguments &mdash; like in a call to the less specific methods.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>These functions generate the weight function in slot <code>weight</code> in a corresp.
object of class <code>RobWeight</code> and descendants.</p>


<h3>Value</h3>

<p>Object of class <code>"HampelWeight"</code> resp. <code>"BdStWeight"</code></p>


<h3>Methods</h3>


<dl>
<dt>getweight</dt><dd><p><code>signature(Weight = "HampelWeight", neighbor = "ContNeighborhood", 
                       biastype = "BiasType")</code> with additional argument <code>biastype</code> of class 
<code>"BiasType"</code>: produces weight slot...</p>
</dd>
<dt>minbiasweight</dt><dd><p><code>signature(Weight = "HampelWeight", neighbor = "ContNeighborhood", 
                       biastype = "BiasType")</code> with additional argument <code>biastype</code> of class 
<code>"BiasType"</code>: produces weight slot...</p>
</dd>
<dt>getweight</dt><dd><p><code>signature(Weight = "HampelWeight", neighbor = "ContNeighborhood", 
                       biastype = "onesidedBias")</code>: produces weight slot...</p>
</dd>
<dt>minbiasweight</dt><dd><p><code>signature(Weight = "HampelWeight", neighbor = "ContNeighborhood", 
                       biastype = "onesidedBias")</code>: produces weight slot...</p>
</dd>
<dt>getweight</dt><dd><p><code>signature(Weight = "HampelWeight", neighbor = "ContNeighborhood", 
                       biastype = "asymmetricBias")</code>: produces weight slot...</p>
</dd>
<dt>minbiasweight</dt><dd><p><code>signature(Weight = "HampelWeight", neighbor = "ContNeighborhood", 
                       biastype = "asymmetricBias")</code>: produces weight slot...</p>
</dd>
<dt>getweight</dt><dd><p><code>signature(Weight = "BdStWeight", neighbor = "TotalVarNeighborhood", 
                       biastype = "BiasType")</code>: produces weight slot...</p>
</dd>
<dt>minbiasweight</dt><dd><p><code>signature(Weight = "BdStWeight", neighbor = "TotalVarNeighborhood", 
                       biastype = "BiasType")</code>: produces weight slot...</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BdStWeight-class">BdStWeight-class</a></code>,
<code><a href="#topic+HampelWeight-class">HampelWeight-class</a></code>,
<code><a href="#topic+IC-class">IC-class</a></code></p>

<hr>
<h2 id='HampelWeight-class'>Robust Weight classes for weights of Hampel type</h2><span id='topic+HampelWeight-class'></span><span id='topic+cent+2CHampelWeight-method'></span><span id='topic+cent+3C-+2CHampelWeight-method'></span>

<h3>Description</h3>

<p>Classes for weights of Hampel type.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("HampelWeight", ...)</code>;
to fill slot <code>weight</code>, you will use the generating functions 
<code><a href="#topic+getweight">getweight</a></code> and <code><a href="#topic+minbiasweight">minbiasweight</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>; inherited from class <code>RobWeight</code>. </p>
</dd>
<dt><code>weight</code></dt><dd><p>Object of class <code>"function"</code> &mdash; the weight function; inherited from class <code>RobWeight</code>.</p>
</dd>
<dt><code>clip</code></dt><dd><p>Object of class <code>"numeric"</code> &mdash; clipping bound(s); inherited from class <code>BoundedWeight</code>.</p>
</dd>
<dt><code>stand</code></dt><dd><p>Object of class <code>"matrix"</code> &mdash; standardization; inherited from class <code>BdStWeight</code>.</p>
</dd>
<dt><code>cent</code></dt><dd><p>Object of class <code>"numeric"</code> &mdash; centering.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"RobWeight"</code>, via class <code>"BoundedWeight"</code>.
Class <code>"BoundedWeight"</code>, via class <code>"BdStWeight"</code>.
Class <code>"BdStWeight"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>cent</dt><dd><p><code>signature(object = "HampelWeight")</code>:
accessor function for slot <code>cent</code>. </p>
</dd>
<dt>cent&lt;-</dt><dd><p><code>signature(object = "HampelWeight", value = "matrix")</code>:
replacement function for slot <code>cent</code>. This replacement method 
should be used with great care, as the slot <code>weight</code> is not
simultaneously updated and hence, this may lead to inconsistent
objects. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>.
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BdStWeight-class">BdStWeight-class</a></code>,
<code><a href="#topic+BoundedWeight-class">BoundedWeight-class</a></code>, <code><a href="#topic+RobWeight-class">RobWeight-class</a></code>,
<code><a href="#topic+IC">IC</a></code>, <code><a href="#topic+InfluenceCurve-class">InfluenceCurve-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## prototype
new("HampelWeight")
</code></pre>

<hr>
<h2 id='HampIC-class'>Influence curve of Hampel type</h2><span id='topic+HampIC-class'></span><span id='topic+lowerCase'></span><span id='topic+lowerCase+2CHampIC-method'></span><span id='topic+neighborRadius'></span><span id='topic+neighborRadius+2CANY-method'></span><span id='topic+neighborRadius+2CHampIC-method'></span><span id='topic+neighborRadius+3C-'></span><span id='topic+neighborRadius+3C-+2CHampIC-method'></span><span id='topic+stand'></span><span id='topic+stand+2CHampIC-method'></span><span id='topic+weight+2CHampIC-method'></span><span id='topic+biastype+2CHampIC-method'></span><span id='topic+normtype+2CHampIC-method'></span>

<h3>Description</h3>

<p>Class of (partial) influence curves of Hampel (= total variation or contamination) type;
used as common mother class for classes <code>ContIC</code> and <code>TotalVarIC</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("HampIC", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>CallL2Fam</code></dt><dd><p> object of class <code>"call"</code>:
creates an object of the underlying L2-differentiable
parametric family. </p>
</dd>
<dt><code>name</code></dt><dd><p> object of class <code>"character"</code> </p>
</dd>
<dt><code>Curve</code></dt><dd><p> object of class <code>"EuclRandVarList"</code></p>
</dd>
<dt><code>modifyIC</code></dt><dd><p> object of class <code>"OptionalFunction"</code>:
function of four arguments: (1) <code>L2Fam</code> an L2 parametric family
(2) <code>IC</code> an optional influence curve, (3) <code>withMakeIC</code>
a logical argument whether to enforce the IC side conditions
by <code>makeIC</code>, and (4) <code>...</code> for arguments to be passed to
calls to <code>E</code> in <code>makeIC</code>. Returns an object of
class <code>"IC"</code>. This function is mainly used for internal
computations! </p>
</dd>
<dt><code>Risks</code></dt><dd><p> object of class <code>"list"</code>:
list of risks; cf. <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code>. </p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
<dt><code>stand</code></dt><dd><p> object of class <code>"matrix"</code>:
standardizing matrix. </p>
</dd>
<dt><code>weight</code></dt><dd><p> object of class <code>"RobWeight"</code>:
weight function </p>
</dd>
<dt><code>biastype</code></dt><dd><p> object of class <code>"BiasType"</code>:
bias type (symmetric/onsided/asymmetric) </p>
</dd>
<dt><code>normtype</code></dt><dd><p> object of class <code>"NormType"</code>:
norm type (Euclidean, information/self-standardized)</p>
</dd>
<dt><code>lowerCase</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>:
optional constant for lower case solution. </p>
</dd>
<dt><code>neighborRadius</code></dt><dd><p> object of class <code>"numeric"</code>:
radius of the corresponding (unconditional) contamination
neighborhood. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"IC"</code>, directly.<br />
Class <code>"InfluenceCurve"</code>, by class <code>"IC"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>stand</dt><dd><p><code>signature(object = "HampIC")</code>:
accessor function for slot <code>stand</code>. </p>
</dd>
<dt>weight</dt><dd><p><code>signature(object = "HampIC")</code>:
accessor function for slot <code>weight</code>. </p>
</dd>
<dt>biastype</dt><dd><p><code>signature(object = "HampIC")</code>:
accessor function for slot <code>biastype</code>. </p>
</dd>
<dt>normtype</dt><dd><p><code>signature(object = "HampIC")</code>:
accessor function for slot <code>normtype</code>. </p>
</dd>
<dt>lowerCase</dt><dd><p><code>signature(object = "HampIC")</code>:
accessor function for slot <code>lowerCase</code>. </p>
</dd>
<dt>neighborRadius</dt><dd><p><code>signature(object = "HampIC")</code>:
accessor function for slot <code>neighborRadius</code>. </p>
</dd>
<dt>neighborRadius&lt;-</dt><dd><p><code>signature(object = "HampIC")</code>:
replacement function for slot <code>neighborRadius</code>. </p>
</dd>
<dt>neighborRadius</dt><dd><p><code>signature(object = "ANY")</code>:
returns <code>NULL</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Hampributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- new("HampIC")
plot(IC1)
</code></pre>

<hr>
<h2 id='IC'>Generating function for IC-class</h2><span id='topic+IC'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"IC"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC(name, Curve = EuclRandVarList(RealRandVariable(Map = list(function(x){x}), 
                                        Domain = Reals())), 
   Risks, Infos, CallL2Fam = call("L2ParamFamily"), modifyIC = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC_+3A_name">name</code></td>
<td>
<p> Object of class <code>"character"</code>; the name of the IC. </p>
</td></tr>
<tr><td><code id="IC_+3A_calll2fam">CallL2Fam</code></td>
<td>
<p> object of class <code>"call"</code>:
creates an object of the underlying L2-differentiable 
parametric family. </p>
</td></tr>
<tr><td><code id="IC_+3A_curve">Curve</code></td>
<td>
<p> object of class <code>"EuclRandVarList"</code>. </p>
</td></tr>
<tr><td><code id="IC_+3A_risks">Risks</code></td>
<td>
<p> object of class <code>"list"</code>: 
list of risks; cf. <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code>. </p>
</td></tr>
<tr><td><code id="IC_+3A_infos">Infos</code></td>
<td>
<p> matrix of characters with two columns 
named <code>method</code> and <code>message</code>: additional informations. </p>
</td></tr>
<tr><td><code id="IC_+3A_modifyic">modifyIC</code></td>
<td>
<p> object of class <code>"OptionalFunction"</code>:
function of four arguments: (1) <code>L2Fam</code> an L2 parametric family
(2) <code>IC</code> an optional influence curve, (3) <code>withMakeIC</code>
a logical argument whether to enforce the IC side conditions
by <code>makeIC</code>, and (4) <code>...</code> for arguments to be passed to
calls to <code>E</code> in <code>makeIC</code>. Returns an object of
class <code>"IC"</code>. This function is mainly used for internal
computations! </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- IC()
plot(IC1)
</code></pre>

<hr>
<h2 id='IC-class'>Influence curve</h2><span id='topic+IC-class'></span><span id='topic+CallL2Fam'></span><span id='topic+CallL2Fam+2CIC-method'></span><span id='topic+CallL2Fam+3C-'></span><span id='topic+CallL2Fam+3C-+2CIC-method'></span><span id='topic+modifyIC'></span><span id='topic+modifyIC+2CIC-method'></span><span id='topic+evalIC+2CIC+2Cnumeric-method'></span><span id='topic+evalIC+2CIC+2Cmatrix-method'></span><span id='topic+show+2CIC-method'></span>

<h3>Description</h3>

<p>Class of (partial) influence curves.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("IC", ...)</code>.
More frequently they are created via the generating function 
<code>IC</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>CallL2Fam</code></dt><dd><p>Object of class <code>"call"</code>:
creates an object of the underlying L2-differentiable 
parametric family. </p>
</dd>
<dt><code>modifyIC</code></dt><dd><p> object of class <code>"OptionalFunction"</code>:
function of four arguments: (1) <code>L2Fam</code> an L2 parametric family
(2) <code>IC</code> an optional influence curve, (3) <code>withMakeIC</code>
a logical argument whether to enforce the IC side conditions
by <code>makeIC</code>, and (4) <code>...</code> for arguments to be passed to
calls to <code>E</code> in <code>makeIC</code>. Returns an object of
class <code>"IC"</code>. This function is mainly used for internal
computations! </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>. </p>
</dd>
<dt><code>Curve</code></dt><dd><p>Object of class <code>"EuclRandVarList"</code>.</p>
</dd>
<dt><code>Risks</code></dt><dd><p>Object of class <code>"list"</code>: 
list of risks; cf. <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code>. </p>
</dd>
<dt><code>Infos</code></dt><dd><p>Object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"InfluenceCurve"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>CallL2Fam</dt><dd><p><code>signature(object = "IC")</code>: 
accessor function for slot <code>CallL2Fam</code>. </p>
</dd>
<dt>CallL2Fam&lt;-</dt><dd><p><code>signature(object = "IC")</code>: 
replacement function for slot <code>CallL2Fam</code>. </p>
</dd>
<dt>modifyIC</dt><dd><p><code>signature(object = "IC")</code>: 
accessor function for slot <code>modifyIC</code>. </p>
</dd>
<dt>checkIC</dt><dd><p><code>signature(IC = "IC", L2Fam = "missing")</code>: 
check centering and Fisher consistency of <code>IC</code> assuming
the L2-differentiable parametric family which can 
be generated via the slot <code>CallL2Fam</code> of <code>IC</code>. </p>
</dd>
<dt>checkIC</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2ParamFamily")</code>: 
check centering and Fisher consistency of <code>IC</code> assuming
the L2-differentiable parametric family <code>L2Fam</code>. </p>
</dd>
<dt>evalIC</dt><dd><p><code>signature(IC = "IC", x = "numeric")</code>: 
evaluate <code>IC</code> at <code>x</code>. </p>
</dd>
<dt>evalIC</dt><dd><p><code>signature(IC = "IC", x = "matrix")</code>: 
evaluate <code>IC</code> at the rows of <code>x</code>. </p>
</dd>
<dt>infoPlot</dt><dd><p><code>signature(object = "IC")</code>:
Plot absolute and relative information of <code>IC</code>. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "IC", y = "missing")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "IC")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InfluenceCurve-class">InfluenceCurve-class</a></code>, <code><a href="#topic+IC">IC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- new("IC")
plot(IC1)
</code></pre>

<hr>
<h2 id='InfluenceCurve'>Generating function for InfluenceCurve-class</h2><span id='topic+InfluenceCurve'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"InfluenceCurve"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InfluenceCurve(name, Curve = EuclRandVarList(EuclRandVariable(Domain = Reals())), 
            Risks, Infos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InfluenceCurve_+3A_name">name</code></td>
<td>
<p> character string: name of the influence curve </p>
</td></tr>
<tr><td><code id="InfluenceCurve_+3A_curve">Curve</code></td>
<td>
<p> object of class <code>"EuclRandVarList"</code> </p>
</td></tr>
<tr><td><code id="InfluenceCurve_+3A_risks">Risks</code></td>
<td>
<p> list of risks  </p>
</td></tr>
<tr><td><code id="InfluenceCurve_+3A_infos">Infos</code></td>
<td>
<p> matrix of characters with two columns
named <code>method</code> and <code>message</code>: additional informations </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"InfluenceCurve"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InfluenceCurve-class">InfluenceCurve-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>InfluenceCurve()

## The function is currently defined as
InfluenceCurve &lt;- function(name, Curve = EuclRandVarList(EuclRandVariable(Domain = Reals())), 
                           Risks, Infos){
    if(missing(name))
        name &lt;- "influence curve"
    if(missing(Risks))
        Risks &lt;- list()
    if(missing(Infos))
        Infos &lt;- matrix(c(character(0),character(0)), ncol=2,
                     dimnames=list(character(0), c("method", "message")))
    
    return(new("InfluenceCurve", name = name, Curve = Curve, 
               Risks = Risks, Infos = Infos))
}
</code></pre>

<hr>
<h2 id='InfluenceCurve-class'>Influence curve</h2><span id='topic+InfluenceCurve-class'></span><span id='topic+addInfo+3C-'></span><span id='topic+addInfo+3C-+2CInfluenceCurve-method'></span><span id='topic+addRisk+3C-'></span><span id='topic+addRisk+3C-+2CInfluenceCurve-method'></span><span id='topic+Curve'></span><span id='topic+Curve+2CInfluenceCurve-method'></span><span id='topic+Domain+2CInfluenceCurve-method'></span><span id='topic+Infos'></span><span id='topic+Infos+2CInfluenceCurve-method'></span><span id='topic+Infos+3C-'></span><span id='topic+Infos+3C-+2CInfluenceCurve-method'></span><span id='topic+Map+2CInfluenceCurve-method'></span><span id='topic+name+2CInfluenceCurve-method'></span><span id='topic+name+3C-+2CInfluenceCurve-method'></span><span id='topic+Range+2CInfluenceCurve-method'></span><span id='topic+Risks'></span><span id='topic+Risks+2CInfluenceCurve-method'></span><span id='topic+Risks+3C-'></span><span id='topic+Risks+3C-+2CInfluenceCurve-method'></span><span id='topic+show+2CInfluenceCurve-method'></span>

<h3>Description</h3>

<p>Class of influence curves (functions).</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("InfluenceCurve", ...)</code>.
More frequently they are created via the generating function 
<code>InfluenceCurve</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p> object of class <code>"character"</code> </p>
</dd>
<dt><code>Curve</code></dt><dd><p> object of class <code>"EuclRandVarList"</code> </p>
</dd>
<dt><code>Risks</code></dt><dd><p> object of class <code>"list"</code>: 
list of risks; cf. <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code>. </p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
accessor function for slot <code>name</code>. </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
replacement function for slot <code>name</code>. </p>
</dd>
<dt>Curve</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
accessor function for slot <code>Curve</code>. </p>
</dd>
<dt>Map</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
accessor function for slot <code>Map</code> of slot <code>Curve</code>. </p>
</dd>
<dt>Domain</dt><dd><p><code>signature(object = "InfluenceCurve")</code>:
accessor function for slot <code>Domain</code> of slot <code>Curve</code>. </p>
</dd>
<dt>Range</dt><dd><p><code>signature(object = "InfluenceCurve")</code>:
accessor function for slot <code>Range</code> of slot <code>Curve</code>. </p>
</dd>
<dt>Infos</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
accessor function for slot <code>Infos</code>. </p>
</dd>
<dt>Infos&lt;-</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
replacement function for slot <code>Infos</code>. </p>
</dd>
<dt>addInfo&lt;-</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
function to add an information to slot <code>Infos</code>. </p>
</dd>
<dt>Risks</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
accessor function for slot <code>Risks</code>. By means of internal
function <code>.evalListRec</code> recursively evaluates all non evaluated
calls and writes back the evaluated calls to the calling envirionment.</p>
</dd>
<dt>Risks&lt;-</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
replacement function for slot <code>Risks</code>. </p>
</dd>
<dt>addRisk&lt;-</dt><dd><p><code>signature(object = "InfluenceCurve")</code>: 
function to add a risk to slot <code>Risks</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "InfluenceCurve")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InfluenceCurve">InfluenceCurve</a></code>, <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("InfluenceCurve")
</code></pre>

<hr>
<h2 id='infoPlot'>Plot absolute and relative information</h2><span id='topic+infoPlot'></span><span id='topic+infoPlot-methods'></span><span id='topic+infoPlot+2CIC-method'></span>

<h3>Description</h3>

<p>Plot absolute and relative information of influence curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infoPlot(object,  ...)
## S4 method for signature 'IC'
infoPlot(object, data = NULL,
             ..., withSweave = getdistrOption("withSweave"),
             col = par("col"), lwd = par("lwd"), lty,
             colI = grey(0.5), lwdI = 0.7*par("lwd"), ltyI = "dotted",
             main = FALSE, inner = TRUE, sub = FALSE,
             col.inner = par("col.main"), cex.inner = 0.8,
             bmar = par("mar")[1], tmar = par("mar")[3],
             with.automatic.grid = TRUE,
             with.legend = TRUE, legend = NULL, legend.bg = "white",
             legend.location = "bottomright", legend.cex = 0.8,
             x.vec = NULL, scaleX = FALSE, scaleX.fct, scaleX.inv,
             scaleY = FALSE, scaleY.fct = pnorm, scaleY.inv=qnorm,
             scaleN = 9, x.ticks = NULL, y.ticks = NULL,
             mfColRow = TRUE, to.draw.arg = NULL,
             cex.pts = 1, cex.pts.fun = NULL, col.pts = par("col"),
             pch.pts = 19,
             cex.npts = 1, cex.npts.fun = NULL, col.npts = grey(.5),
             pch.npts = 20,
             jitter.fac = 1, with.lab = FALSE, cex.lbs = 1, adj.lbs = c(0, 0),
             col.lbs = col.pts, lab.pts = NULL, lab.font = NULL, alpha.trsp = NA,
             which.lbs = NULL, which.Order  = NULL, which.nonlbs = NULL,
             attr.pre = FALSE, return.Order = FALSE,
             ylab.abs = "absolute information",
             ylab.rel= "relative information",
             withSubst = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infoPlot_+3A_object">object</code></td>
<td>
<p>object of class <code>"InfluenceCurve"</code> </p>
</td></tr>
<tr><td><code id="infoPlot_+3A_data">data</code></td>
<td>
<p>optional data argument &mdash; for plotting observations into the plot;</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_withsweave">withSweave</code></td>
<td>
<p>logical: if <code>TRUE</code> (for working with <code>Sweave</code>) 
no extra device is opened</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_main">main</code></td>
<td>
<p>logical: is a main title to be used? or <br />
just as argument <code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_inner">inner</code></td>
<td>
<p>logical: do panels have their own titles? or <br />
character vector of / cast to length 'number of compared 
dimensions';
if argument <code>to.draw.arg</code> is used, this refers to 
a vector of length <code>1</code> (absolute information) 
<code>+ length(to.draw.arg)</code>, the actually plotted
relative informations. For further information, see  also
<code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr> 
<tr><td><code id="infoPlot_+3A_sub">sub</code></td>
<td>
<p>logical: is a sub-title to be used? or <br />
just as argument <code>sub</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_tmar">tmar</code></td>
<td>
<p>top margin &ndash; useful for non-standard main title sizes;
may be a vector with individual values for
each of the panels to be plotted. </p>
</td></tr>
<tr><td><code id="infoPlot_+3A_bmar">bmar</code></td>
<td>
<p>bottom margin &ndash; useful for non-standard sub title sizes;
may be a vector with individual values for
each of the panels to be plotted. </p>
</td></tr>
<tr><td><code id="infoPlot_+3A_col">col</code></td>
<td>
<p>color of IC in argument <code>object</code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_lwd">lwd</code></td>
<td>
<p>linewidth of IC in argument <code>object</code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_lty">lty</code></td>
<td>
<p>line-type of IC in argument <code>object</code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_coli">colI</code></td>
<td>
<p>color of the classically optimal IC.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_lwdi">lwdI</code></td>
<td>
<p>linewidth of the classically optimal IC.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_ltyi">ltyI</code></td>
<td>
<p>line-type of the classically optimal IC.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_cex.inner">cex.inner</code></td>
<td>
<p>magnification to be used for inner titles relative
to the current setting of <code>cex</code>; as in 
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_col.inner">col.inner</code></td>
<td>
<p>character or integer code; color for the inner title</p>
</td></tr>              
<tr><td><code id="infoPlot_+3A_with.automatic.grid">with.automatic.grid</code></td>
<td>
<p>logical; should a grid be plotted alongside
with the ticks of the axes, automatically? If <code>TRUE</code> a respective
call to <code>grid</code> in argument <code>panel.first</code> is ignored. </p>
</td></tr>
<tr><td><code id="infoPlot_+3A_with.legend">with.legend</code></td>
<td>
<p>logical; shall a legend be plotted?</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_legend">legend</code></td>
<td>
<p>either <code>NULL</code> or a list of length (number of plotted panels)
of items which can be used as argument <code>legend</code> in
command <code>legend</code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_legend.location">legend.location</code></td>
<td>
<p>a valid argument <code>x</code> for <code><a href="graphics.html#topic+legend">legend</a></code> &mdash;
the place where to put the legend on the last issued
plot &mdash; or a list of length (number of plotted panels) 
of such arguments, one for each plotted panel.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_legend.bg">legend.bg</code></td>
<td>
<p>background color for the legend</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_legend.cex">legend.cex</code></td>
<td>
<p>magnification factor for the legend</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_x.vec">x.vec</code></td>
<td>
<p>a numeric vector of grid points to evaluate the influence curve;
by default, <code>x.vec</code> is <code>NULL</code>; then the grid is
produced automatically according to the distribution of the IC.
<code>x.vec</code> can be useful for usage with a rescaling of the
x-axis to avoid that the evaluation points be selected too
unevenly (i.e. on an equally spaced grid in the original scale,
but then, after rescaling non-equally).
The grid has to be specified in original scale; i.e.; when used
with rescaling, it should be chosen non-equally spaced. </p>
</td></tr>
<tr><td><code id="infoPlot_+3A_scalex">scaleX</code></td>
<td>
<p>logical; shall X-axis be rescaled (by default according to the cdf of
the underlying distribution)?</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_scaley">scaleY</code></td>
<td>
<p>logical; shall Y-axis be rescaled for abs.info-plot
(by default according to a probit scale)?</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_scalex.fct">scaleX.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the domain of the IC
to [0,1]; if <code>scaleX</code> is <code>TRUE</code> and <code>scaleX.fct</code> is
missing, the cdf of the underlying observation distribution.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_scalex.inv">scaleX.inv</code></td>
<td>
<p>the inverse function to <code>scale.fct</code>, i.e., an isotone,
vectorized function mapping [0,1] to the domain of the IC
such that for any <code>x</code> in the domain,
<code>scaleX.inv(scaleX.fct(x))==x</code>; if <code>scaleX</code> is <code>TRUE</code>
and <code>scaleX.inv</code> is
missing, the quantile function of the underlying observation distribution. </p>
</td></tr>
<tr><td><code id="infoPlot_+3A_scaley.fct">scaleY.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the
range of the norm of the IC to [0,1]; defaulting
to the cdf of <code class="reqn">{\cal N}(0,1)</code>;
can also be a list of functions with one list element for each
of the panels to be plot.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_scaley.inv">scaleY.inv</code></td>
<td>
<p>an isotone, vectorized function mapping [0,1] into the range
of the norm of the IC; defaulting to the quantile function
of  <code class="reqn">{\cal N}(0,1)</code>;
can also be a list of functions with one list element for each
of the panels to be plot.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_scalen">scaleN</code></td>
<td>
<p>integer; defaults to 9; on rescaled axes, number of x
and y ticks if drawn automatically;</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_x.ticks">x.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given x-ticks (on original scale);</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_y.ticks">y.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given y-ticks (on original scale);
can be a list with one (numeric or NULL) item per panel</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_mfcolrow">mfColRow</code></td>
<td>
<p>shall default partition in panels be used &mdash; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="infoPlot_+3A_to.draw.arg">to.draw.arg</code></td>
<td>
<p>Either <code>NULL</code> (default; 
everything is plotted) or a vector making a selection
among the relative information plots; the absolute
information being plotted in any case. This
vector is either a vector of integers 
(the indices of the subplots to be drawn) or characters 
&mdash; the names of the subplots to be drawn: these
names are to be chosen either among the row names of 
the trafo matrix 
<code>rownames(trafo(eval(object@CallL2Fam)@param))</code> 
or if the last expression is <code>NULL</code> a 
vector <code>"dim&lt;dimnr&gt;"</code>, <code>dimnr</code> running through 
the number of rows of the trafo matrix.
</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_withsubst">withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and lables is used; otherwise no substitution is used. </p>
</td></tr>
<tr><td><code id="infoPlot_+3A_col.pts">col.pts</code></td>
<td>
<p>color of the points of the <code>data</code> argument plotted;
can be a vector or a matrix. More specifically, if argument <code>attr.pre</code>
is <code>TRUE</code>, it is recycled to fill a matrix of dimension <code>n</code> by 2
(<code>n</code> the number of observations prior to any selection) where filling
is done in order column first. The two columns are used for possibly
different colors for the actual IC from the argument and the classical
IC which is also shown. The selection done via <code>which.lbs</code> and
<code>which.Order</code> is then done afterwards and on this matrix;
argument <code>col.npts</code> is ignored in this case. If <code>attr.pre</code> is <code>FALSE</code>,
<code>col.pts</code> is recycled to fill a matrix of dimension <code>n.s</code> by 2
where <code>n.s</code> is the number of observations selected for labelling
and refers to the index ordering after the selection. Then argument
<code>col.npts</code> deteremines the colors of the shown but non-labelled
observations as given in argument <code>which.nonlbs</code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_pch.pts">pch.pts</code></td>
<td>
<p>symbol of the points of the <code>data</code> argument plotted
(may be a vector of length 2 or a matrix, see <code>col.pts</code>,
with argument <code>pch.npts</code> as counterpart).</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_cex.pts">cex.pts</code></td>
<td>
<p>size of the points of the <code>data</code> argument plotted
(may be a vector of length 2 or a matrix, see <code>col.pts</code>,
with argument <code>cex.npts</code> as counterpart).</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_cex.pts.fun">cex.pts.fun</code></td>
<td>
<p>rescaling function for the size of the points to be plotted;
either <code>NULL</code> (default), then <code>log(1+abs(x))</code> is used for each of
the rescalings, or a function which is then used for each of the
rescalings, or a list of functions; if it is a function or a list of
functions, if necessary it is recylced to length <code>2 * dim</code>
where <code>2</code> is for the classical IC and the IC in argument <code>object</code>
and <code>dim</code> is the number of dimensions of the pICs to be plotted;
in the index of this list, <code>2</code> is incremented first;
then <code>dim</code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_col.npts">col.npts</code></td>
<td>
<p>color of the non-labelled points of the <code>data</code> argument
plotted; (may be a vector of length 2, or it can be a matrix
<code>nnlb &lt;- sum(which.nonlbs)</code> by <code>2</code>,
<code>nnlb</code> the number of non-labelled shown observations.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_pch.npts">pch.npts</code></td>
<td>
<p>symbol of the non-labelled points of the <code>data</code> argument
plotted (may be a vector of length <code>2</code> or a matrix,
see <code>col.npts</code>).</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_cex.npts">cex.npts</code></td>
<td>
<p>size of the non-labelled points of the <code>data</code> argument
plotted (may be a vector of length <code>2</code> or a matrix, see
<code>col.npts</code>).</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_cex.npts.fun">cex.npts.fun</code></td>
<td>
<p>rescaling function for the size of the non-labelled points
to be plotted; either <code>NULL</code> (default), then <code>log(1+abs(x))</code>
is used for each of the rescalings, or a function which is then used
for each of the rescalings, or a list of functions; if it is a
function or a list of functions, if necessary it is recylced
to length <code>2 * dim</code> where <code>dim</code> is the number of dimensions of
the pICs to be plotted;  in the index of this list,
<code>2</code> is incremented first; then <code>dim</code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_attr.pre">attr.pre</code></td>
<td>
<p>logical; do graphical attributes for plotted data refer
to indices prior (<code>TRUE</code>) or posterior to selection
via arguments <code>which.lbs</code>, <code>which.Order</code>, <code>which.nonlbs</code>
(<code>FALSE</code>)? </p>
</td></tr>
<tr><td><code id="infoPlot_+3A_with.lab">with.lab</code></td>
<td>
<p>logical; shall labels be plotted to the observations?
(may be a vector of length 2, see <code>col.pts</code> &ndash; 
but not a matrix)</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_cex.lbs">cex.lbs</code></td>
<td>
<p>size of the labels; can be vectorized to an array
of dim nlbs x 2 x npnl where npnl is the number of plotted
panels and nlbs the number of plotted labels; if it is
a vector, it is recylced in order labels then ICs
[arg <code>IC</code>/classic] then panels.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_col.lbs">col.lbs</code></td>
<td>
<p>color of the labels; can be vectorized to a matrix
of dim nlbs x 2 as <code>col.pts</code>.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_adj.lbs">adj.lbs</code></td>
<td>
<p>adjustment of the labels; can be vectorized to an array
of dim 2 x 2 x npnl matrix, npnl the number of plotted panels;
if it is a vector, it is recycled in order (x,y)-coords then ICs
[arg <code>IC</code>/classic] then panels.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_lab.pts">lab.pts</code></td>
<td>
<p>character or NULL; labels to be plotted to the observations;
can be a vector of length <code>n</code>, <code>n</code> the number of 
all observations prior to any selection with <code>which.lbs</code>,
<code>which.Order</code>; if <code>lab.pts</code> is <code>NULL</code>, 
observation indices are used.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_lab.font">lab.font</code></td>
<td>
<p>font to be used for labels; (may be a vector of length 2, 
see <code>with.lab</code>).</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.nonlbl</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the number of panel data-symbols to 
be plotted. Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_jitter.fac">jitter.fac</code></td>
<td>
<p>jittering factor used in case of a <code>DiscreteDistribution</code>
for plotting points of the <code>data</code> argument in a jittered fashion
(may be a vector of length 2, see <code>with.lab</code>).</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_which.lbs">which.lbs</code></td>
<td>
<p>either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then no observation is excluded</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_which.order">which.Order</code></td>
<td>
<p>we order the observations (descending) according to the norm given by
<code>normtype(object)</code>; then <code>which.Order</code>
either is an integer vector with the indices of the <em>ordered</em>
observations (remaining after a possible reduction by argument <code>which.lbs</code>)
to be plotted into graph or <code>NULL</code> &mdash; then no (further) observation
is excluded.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_which.nonlbs">which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then all non-labelled
observations are plotted.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_return.order">return.Order</code></td>
<td>
<p>logical; if <code>TRUE</code>, a list of length two with order vectors
is returned &mdash; one for ordering w.r.t. the given IC, one for ordering w.r.t.
the classically optimal IC; more specifically, the order of the (remaining) observations
given by their original index is returned (remaining means: after a possible
reduction by argument <code>which.lbs</code>, and ordering is according to the norm given by
<code>normtype(object)</code>);
otherwise we return <code>invisible()</code> as usual.</p>
</td></tr>
<tr><td><code id="infoPlot_+3A_ylab.abs">ylab.abs</code></td>
<td>
<p>character; label to be used for y-axis in absolute information panel</p>
</td></tr> 
<tr><td><code id="infoPlot_+3A_ylab.rel">ylab.rel</code></td>
<td>
<p>character; label to be used for y-axis in relative information panel</p>
</td></tr> 
<tr><td><code id="infoPlot_+3A_...">...</code></td>
<td>
<p>further parameters for <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Absolute information is defined as the square of the length
of an IC. The relative information is defined as the 
absolute information of one component with respect to the 
absolute information of the whole IC; confer Section 8.1 
of Kohl (2005). <br />
</p>
<p>Any parameters of <code>plot.default</code> may be passed on to this particular
<code>plot</code> method. 
</p>
<p>For main-, inner, and subtitles given as arguments <code>main</code>, 
<code>inner</code>, and <code>sub</code>, top and bottom margins are enlarged to 5 resp. 
6 by default but may also be specified by <code>tmar</code> / <code>bmar</code> arguments. 
If <code>main</code> / <code>inner</code> / <code>sub</code> are 
logical then if the respective argument is <code>FALSE</code> nothing is done/plotted, 
but if it is <code>TRUE</code>, we use a default main title taking up the calling 
arguments in case of <code>main</code>, default inner titles taking up the
class and (named) parameter slots of arguments in case of <code>inner</code>,
and a &quot;generated on &lt;data&gt;&quot;-tag in case of <code>sub</code>.
Of course, if <code>main</code> / <code>inner</code> / <code>sub</code> are <code>character</code>, this
is used for the title; in case of <code>inner</code> it is then checked whether it
has correct length. If argument <code>withSubst</code> is <code>TRUE</code>, in all title 
and axis lable arguments, the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt><dd><p>class of argument <code>object</code></p>
</dd>
<dt><code>"%A"</code></dt><dd><p>deparsed argument  <code>object</code></p>
</dd>
<dt><code>"%D"</code></dt><dd><p>time/date-string when the plot was generated</p>
</dd>
</dl>

<p>If argument <code>...</code> contains argument <code>ylim</code>, this may either be
as in <code>plot.default</code> (i.e. a vector of length 2) or a vector of 
length 2*(number of plotted dimensions + e), where e is 1 or 0 depending
on whether absolute information is plotted or not; 
in the case of longer length, 
if e is 1, the first two elements are the values for <code>ylim</code> 
in panel &quot;Abs&quot;, while the last 2*(number of plotted dimensions)
are the values for <code>ylim</code> for the plotted dimensions of the IC, 
one pair for each dimension.
</p>
<p>Similarly, if argument <code>...</code> contains arguments <code>xaxt</code> or
<code>yaxt</code>, these may be vectorized, with one value for each of the panels
to be plotted. This is useful for stacking panels over each other, using
a common x-axis (see example below).
</p>
<p>The <code>...</code> argument may also contain an argument <code>withbox</code> which
if <code>TRUE</code> warrants that even if <code>xaxt</code> and <code>yaxt</code> both are
<code>FALSE</code>, a box is drawn around the respective panel.
</p>
<p>In addition, argument <code>...</code> may contain arguments <code>panel.first</code>,
<code>panel.last</code>, i.e., hook expressions to be evaluated at the very beginning
and at the very end of each panel (within the then valid coordinates).
To be able to use these hooks for each panel individually, they may also be
lists of expressions (of the same length as the number of panels and
run through in the same order as the panels).
</p>


<h3>Value</h3>

<p>An S3 object of class <code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- NormLocationScaleFamily(mean=0, sd=1) 
IC1 &lt;- optIC(model = N, risk = asCov())
infoPlot(IC1)

## don't run to reduce check time on CRAN

## selection of subpanels for plotting
par(mfrow=c(1,2))
infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","sd"))
infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","sd"), log="y")

infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","mean"), 
              panel.first= grid(), ylim = c(0,4), xlim = c(-6,6))
infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","mean"), 
              panel.first= grid(), ylim = c(0,4,-3,3), xlim = c(-6,6))

par(mfrow=c(1,3))
infoPlot(IC1, mfColRow = FALSE, panel.first= grid(),
         ylim = c(0,4,0,.3,0,.8), xlim=c(-6,6))
par(mfrow=c(1,1))

data &lt;- r(N)(20)
par(mfrow=c(1,3))
infoPlot(IC1, data=data, mfColRow = FALSE, panel.first= grid(),
         with.lab = TRUE, cex.pts=2,
         which.lbs = c(1:4,15:20), which.Order = 1:6,
         return.Order = TRUE)
infoPlot(IC1, data=data[1:10], mfColRow = FALSE, panel.first= grid(),
         with.lab = TRUE, cex.pts=0.7)
par(mfrow=c(1,1))

ICr &lt;- makeIC(list(function(x)sign(x),function(x)sign(abs(x)-qnorm(.75))),N)
data &lt;- r(N)(600)
data.c &lt;- c(data, 1000*data[1:30])
par(mfrow=c(3,1))
infoPlot(ICr, data=data.c, tmar=c(4.1,0,0), bmar=c(0,0,4.1),
         xaxt=c("n","n","s"), mfColRow = FALSE, panel.first= grid(),
         cex.pts=c(.9,.9), alpha.trsp=20, lwd=2, lwdI=1.5, col=3,
         col.pts=c(3,2), colI=2, pch.pts=c(20,20), inner=FALSE,
         scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
         scaleY=TRUE, scaleY.fct=function(x) pchisq(x,df=1),
         scaleY.inv=function(x)qchisq(x,df=1),legend.cex = 1.0)



</code></pre>

<hr>
<h2 id='InfoPlot'>Wrapper function for information plot method</h2><span id='topic+InfoPlot'></span>

<h3>Description</h3>

<p>The wrapper <code>InfoPlot</code> (captial I!) takes most of arguments to the plot 
method <code>infoPlot</code> (lower case i!) by default and gives a user possibility to run 
the function with low number of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  InfoPlot(IC, data, ..., alpha.trsp = 100,
    with.legend = TRUE, rescale = FALSE, withCall = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InfoPlot_+3A_ic">IC</code></td>
<td>
<p>object of class <code>IC</code></p>
</td></tr>
<tr><td><code id="InfoPlot_+3A_data">data</code></td>
<td>
<p>optional data argument &mdash; for plotting
observations into the plot</p>
</td></tr>
<tr><td><code id="InfoPlot_+3A_...">...</code></td>
<td>
<p>additional parameters (in particular to be
passed on to <code>plot</code>)</p>
</td></tr>
<tr><td><code id="InfoPlot_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>the transparency argument (0 to 100)
for ploting the data</p>
</td></tr>
<tr><td><code id="InfoPlot_+3A_with.legend">with.legend</code></td>
<td>
<p>the flag for showing the legend of the
plot</p>
</td></tr>
<tr><td><code id="InfoPlot_+3A_rescale">rescale</code></td>
<td>
<p>the flag for rescaling the axes for better
view of the plot</p>
</td></tr>
<tr><td><code id="InfoPlot_+3A_withcall">withCall</code></td>
<td>
<p>the flag for the call output</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(retV)</code> where <code>retV</code> is the return value
of the respective call to the full-fledged function <code>infoPlot</code>
with the additional item <code>wrapcall</code> with the call
to the wrapper <code>InfoPlot</code> and <code>wrappedcall</code> the call to
to the full-fledged function <code>infoPlot</code>.
</p>


<h3>Details</h3>

<p>Calls <code>infoPlot</code> with suitably chosen defaults. If
<code>withCall == TRUE</code>, the call to <code>infoPlot</code>, i.e.,
item <code>wrappedcall</code> of the (hidden) return value, is
returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gamma
fam  &lt;-  GammaFamily()
IC &lt;- optIC(model = fam, risk = asCov())
Y &lt;- distribution(fam)
data  &lt;-  r(Y)(500)
InfoPlot(IC, data, withCall = FALSE)
</code></pre>

<hr>
<h2 id='InfRobModel'>Generating function for InfRobModel-class</h2><span id='topic+InfRobModel'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"InfRobModel"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InfRobModel(center = L2ParamFamily(), neighbor = ContNeighborhood())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InfRobModel_+3A_center">center</code></td>
<td>
<p> object of class <code>"ProbFamily"</code> </p>
</td></tr>
<tr><td><code id="InfRobModel_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"UncondNeighborhood"</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"FixRobModel"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RobModel-class">RobModel-class</a></code>, <code><a href="#topic+FixRobModel-class">FixRobModel-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(M1 &lt;- InfRobModel())

## The function is currently defined as
function(center = L2ParamFamily(), neighbor = ContNeighborhood()){
    new("InfRobModel", center = center, neighbor = neighbor)
}
</code></pre>

<hr>
<h2 id='InfRobModel-class'>Robust model with infinitesimal (unconditional) neighborhood</h2><span id='topic+InfRobModel-class'></span><span id='topic+neighbor+3C-+2CInfRobModel-method'></span><span id='topic+show+2CInfRobModel-method'></span>

<h3>Description</h3>

<p>Class of robust models with infinitesimal (unconditional) neighborhoods;
i.e., the neighborhood is shrinking at a rate of <code class="reqn">\sqrt{n}</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("InfRobModel", ...)</code>.
More frequently they are created via the generating function 
<code>InfRobModel</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>center</code></dt><dd><p>Object of class <code>"ProbFamily"</code>. </p>
</dd>
<dt><code>neighbor</code></dt><dd><p>Object of class <code>"UncondNeighborhood"</code>. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"RobModel"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>neighbor&lt;-</dt><dd><p><code>signature(object = "InfRobModel")</code>: 
replacement function for slot <code>neighbor&lt;-</code> </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "InfRobModel")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+ProbFamily-class">ProbFamily-class</a></code>, <code><a href="#topic+UncondNeighborhood-class">UncondNeighborhood-class</a></code>,
<code><a href="#topic+InfRobModel">InfRobModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("InfRobModel")
</code></pre>

<hr>
<h2 id='internal_helpers_for_producing_grids_in_plots_RobAStBase'>Internal / Helper functions of package RobAStBase for grids in plot functions</h2><span id='topic+internal_helpers_for_producing_grids_in_plots_RobAStBase'></span><span id='topic+.getDimsTD'></span><span id='topic+.producePanelFirstS'></span><span id='topic+.producePanelFirstSn'></span>

<h3>Description</h3>

<p>These functions are internally used helper functions for <code><a href="#topic+plot">plot</a></code>,
<code><a href="#topic+infoPlot">infoPlot</a></code> <code><a href="#topic+comparePlot">comparePlot</a></code> in package <span class="pkg">RobAStBase</span>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDimsTD(L2Fam,to.draw.arg)
.producePanelFirstS(panelFirst,IC,to.draw.arg, isInfoPlot=FALSE,
                                x.ticks, scaleX, scaleX.fct,
                                y.ticks, scaleY, scaleY.fct)
.producePanelFirstSn(panelFirst, x.ticks, scaleX, scaleX.fct,
                                y.ticks, scaleY, scaleY.fct, logArg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_l2fam">L2Fam</code></td>
<td>
<p>the model at which the plot is produced (of class <code>L2ParamFamily</code>).</p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_panelfirst">panelFirst</code></td>
<td>
<p>argument <code>panel.first</code> to be mingled for grid plotting.</p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_x.ticks">x.ticks</code></td>
<td>
<p>numeric: coordinates in original scale of user-given ticks on x-axis.</p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_scalex">scaleX</code></td>
<td>
<p>logical; shall X-axis be rescaled (by default according to the cdf of
the underlying distribution)?</p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_scalex.fct">scaleX.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the domain of the IC
to [0,1]; if <code>scaleX</code> is <code>TRUE</code> and <code>scaleX.fct</code> is
missing, the cdf of the underlying observation distribution.</p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_y.ticks">y.ticks</code></td>
<td>
<p>numeric: coordinates in original scale of user-given ticks on y-axis.</p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_scaley">scaleY</code></td>
<td>
<p>logical; shall Y-axis be rescaled (by default according to a probit scale)?</p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_scaley.fct">scaleY.fct</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate the
range of the respective coordinate of the IC
to [0,1]; defaulting to the cdf of <code class="reqn">{\cal N}(0,1)</code>.</p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_to.draw.arg">to.draw.arg</code></td>
<td>
<p>Either <code>NULL</code> (default;
everything is plotted) or a vector of either integers
(the indices of the subplots to be drawn) or characters
&mdash; the names of the subplots to be drawn: these
names are to be chosen either among the row names of
the trafo matrix
<code>rownames(trafo(eval(x@CallL2Fam)@param))</code>
or if the last expression is <code>NULL</code> a
vector <code>"dim&lt;dimnr&gt;"</code>, <code>dimnr</code> running through
the number of rows of the trafo matrix.
</p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_ic">IC</code></td>
<td>
<p>object of class <code>"InfluenceCurve"</code> </p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_isinfoplot">isInfoPlot</code></td>
<td>
<p>logical; is this function to be used in <code>infoPlot</code> or
(<code>TRUE</code>) in another plot (<code>FALSE</code>)? </p>
</td></tr>
<tr><td><code id="internal_helpers_for_producing_grids_in_plots_RobAStBase_+3A_logarg">logArg</code></td>
<td>
<p>a character with <code>log</code>-arguments for  <code>plot</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.getDimsTD</code> computes the number of panels to be plotted.
<code>.producePanelFirstS</code> produces an unevaluated expression to be
used as argument <code>panel.first</code> in the diagnostic plots; i.e.;
knowing the actual tickmarks of the axis at the time of evaluation,
code is inserted to plot horizontal and vertical grid lines through
these tickmarks.
</p>

<hr>
<h2 id='internals_for_qqplot'>Internal functions for qqplot of package RobAStBase</h2><span id='topic+internals_for_qqplot'></span><span id='topic+.fadeColor'></span>

<h3>Description</h3>

<p>These functions are used internally by qqplot of package RobAStBase.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.fadeColor(col,x, bg = "white")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_qqplot_+3A_col">col</code></td>
<td>
<p>(a vector of) color(s)</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_x">x</code></td>
<td>
<p>a (numeric) vector of fading weights</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_bg">bg</code></td>
<td>
<p>a color (of length 1): the background color against which to fade</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.fadecolor</code> uses function <code>colorRamp</code> to interpolate between
color <code>col</code> and <code>bg</code>, at coordinate given by <code>x</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.fadecolor</code></td>
<td>
<p>a vector of (rgb) colors of same length as <code>x</code> containing
the corresponding colors <code>col</code> faded towards <code>white</code> according
to <code>colorRamp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ks.test">ks.test</a></code>, <code><a href="distr.html#topic+qqplot">qqplot</a></code>
,<code><a href="distr.html#topic+internals-qqplot">internals_qqplot</a></code>
,<code><a href="distrMod.html#topic+internals-qqplot">internals_qqplot</a></code>
, <code><a href="distrMod.html#topic+qqplot">qqplot</a></code>, <code><a href="#topic+qqplot">qqplot</a></code>
</p>

<hr>
<h2 id='internals_for_RobAStBase'>Internal / Helper functions of package RobAStBase</h2><span id='topic+internals_for_RobAStBase'></span><span id='topic+.eq'></span><span id='topic+.getDistr'></span><span id='topic+.evalListRec'></span><span id='topic+.msapply'></span><span id='topic+.fixInLiesInSupport'></span><span id='topic+.filterEargsWEargList'></span>

<h3>Description</h3>

<p>These functions are used internally by package RobAStBase.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.eq(x,y = 0*x, tol = 1e-7)
.getDistr(L2Fam)
.evalListRec(list0)
.msapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
.fixInLiesInSupport(IC, distr)
.filterEargsWEargList(dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_RobAStBase_+3A_x">x</code></td>
<td>
<p>a (numeric) vector</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_y">y</code></td>
<td>
<p>a (numeric) vector</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_tol">tol</code></td>
<td>
<p>numeric &mdash; tolerance</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_l2fam">L2Fam</code></td>
<td>
<p>object of class <code>L2ParamFamily</code></p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_list0">list0</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_x">X</code></td>
<td>
<p>like <code>sapply</code>: a vector (atomic or list) or an <code>expression</code> object. Other objects
(including classed objects) will be coerced by <code>base::as.list</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_fun">FUN</code></td>
<td>
<p>like <code>sapply</code>: the function to be applied to each element of <code>X</code>. See also <code><a href="base.html#topic+lapply">sapply</a></code></p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_...">...</code></td>
<td>
<p>like <code>sapply</code>: optional arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_simplify">simplify</code></td>
<td>
<p>like <code>sapply</code>: logical or character string;
should the result be simplified to a vector, matrix or higher dimensional array if possible? See also <code><a href="base.html#topic+lapply">sapply</a></code></p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_use.names">USE.NAMES</code></td>
<td>
<p>like <code>sapply</code>: logical; if <code>TRUE</code> and if <code>X</code> is character,
use <code>X</code> as names for the result unless it had names already.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_ic">IC</code></td>
<td>
<p>an object of class <code>IC</code>, i.e., it expects a slot <code>Curve</code> like an IC.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_distr">distr</code></td>
<td>
<p>a distribution</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_+3A_dots">dots</code></td>
<td>
<p>a list, obtained by <code>list(...)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.eq</code> checks equality of two vectors up to a given precision;
</p>
<p><code>.getDistr</code> produces a string with the class of the family and its parameter value;
</p>
<p><code>.evalListRec</code> recursively goes through the entries of a list, evaluating
each entry.
</p>
<p><code>.msapply</code> like <code>base::.sapply</code> but catches <code>NULL</code>/zero-length arguments <code>X</code>.
</p>
<p><code>.fixInLiesInSupport</code> inserts a check into the function(s) in the <code>Map</code> slot of
the influence curve (IC), whether the arguments at which the IC is to be evaluated lie
in the support of the distribution and accordingly either returns the function value
of the IC, or <code>0</code>; the check is done via  calling <code><a href="distr.html#topic+liesInSupport">liesInSupport</a></code>.
</p>
<p><code>.filterEargsWEargList</code> calls <code>distrEx::.filterEargs</code> to filter out of <code>dots</code> 
all relevant arguments for the integrators, <code>integrate</code>, <code>GLIntegrate</code>,
and <code>distrExIntegrate</code>; in addition, <code>.filterEargsWEargList</code> 
checks if an argument &quot;E.argList&quot; is hidden in the <code>dots</code> argument 
and if so, filters in its entries; in case of collisions with entries filtered
from <code>distrEx::.filterEargs</code>, it overwrites existing entries. In the 
end it returns a list with the filtered items.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.eq</code></td>
<td>
<p>(a vector of) <code>logical</code>.</p>
</td></tr>
<tr><td><code>.getDistr</code></td>
<td>
<p><code>character</code>.</p>
</td></tr>
<tr><td><code>.evalListRec</code></td>
<td>
<p>a list.</p>
</td></tr>
<tr><td><code>.msapply</code></td>
<td>
<p>as <code>base::sapply</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>

<hr>
<h2 id='internals_for_RobAStBase_ddPlot'>Internal / Helper functions of package RobAStBase for ddPlot</h2><span id='topic+internals_for_RobAStBase_ddPlot'></span><span id='topic+.ddPlot.MatNtNtCoCo'></span>

<h3>Description</h3>

<p>This function is an internally used helper function for <code><a href="#topic+ddPlot">ddPlot</a></code> in package <span class="pkg">RobAStBase</span>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ddPlot.MatNtNtCoCo(data, ..., dist.x = NormType(), dist.y  = NormType(),
cutoff.x = cutoff(norm = dist.x, cutoff.quantile  = cutoff.quantile.x),
cutoff.y = cutoff(norm = dist.y, cutoff.quantile  = cutoff.quantile.y),
cutoff.quantile.x = 0.95,  cutoff.quantile.y = cutoff.quantile.x,
transform.x,transform.y = transform.x, id.n, cex.pts = 1, lab.pts,
jitter.pts = 0, alpha.trsp = NA, adj =0,cex.idn = 1,col.idn = par("col"),
lty.cutoff,lwd.cutoff,col.cutoff = "red",text.abline = TRUE,
text.abline.x = NULL, text.abline.y = NULL,cex.abline = par("cex"), 
col.abline = col.cutoff,font.abline = par("font"), adj.abline = c(0,0),
text.abline.x.x = NULL, text.abline.x.y = NULL, text.abline.y.x = NULL, 
text.abline.y.y = NULL, text.abline.x.fmt.cx = "%7.2f",
text.abline.x.fmt.qx = "%4.2f%%", text.abline.y.fmt.cy = "%7.2f",
text.abline.y.fmt.qy = "%4.2f%%", jitter.fac = 10,
jitter.tol = .Machine$double.eps, doplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_data">data</code></td>
<td>
<p>data in <code>matrix</code> form (columns are observations; rows are variable
dimensions) at which to produce the <code>ddPlot</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot.default</code>, <code>text</code>, and <code>abline</code></p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_dist.x">dist.x</code></td>
<td>
<p>object of class <code>NormType</code>; the distance for the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_dist.y">dist.y</code></td>
<td>
<p>object of class <code>NormType</code>; the distance for the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_cutoff.x">cutoff.x</code></td>
<td>
<p>object of class <code>cutoff</code>; the cutoff information for the <code>x</code> axis
(the vertical line discriminating 'good' and 'bad' points).</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_cutoff.y">cutoff.y</code></td>
<td>
<p>object of class <code>cutoff</code>; the cutoff information for the <code>y</code> axis
(the horizontal line discriminating 'good' and 'bad' points).</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_cutoff.quantile.x">cutoff.quantile.x</code></td>
<td>
<p>numeric; the cutoff quantile for the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_cutoff.quantile.y">cutoff.quantile.y</code></td>
<td>
<p>numeric; the cutoff quantile for the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_transform.x">transform.x</code></td>
<td>
<p>function; a transformation to be performed before determining  the
distances of the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_transform.y">transform.y</code></td>
<td>
<p>function; a transformation to be performed before determining  the
distances of the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_id.n">id.n</code></td>
<td>
<p>a set of indices (or a corresponding logical vector); to select a subset
of the data in argument <code>data</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_cex.pts">cex.pts</code></td>
<td>
<p>the corresponding <code>cex</code> argument for plotted points.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_lab.pts">lab.pts</code></td>
<td>
<p>a vector of labels for the (unsubsetted) <code>data</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_jitter.pts">jitter.pts</code></td>
<td>
<p>the corresponding <code>jitter</code> argument for plotted points;
may be a vector of length 2 &ndash; for separate factors for x- and y-coordinate.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.lbl</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the data-symbols to be plotted.
Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_adj">adj</code></td>
<td>
<p>the corresponding argument for <code><a href="graphics.html#topic+text">text</a></code> for
labelling the outliers.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_cex.idn">cex.idn</code></td>
<td>
<p>the corresponding <code>cex</code> argument for
<code><a href="graphics.html#topic+text">text</a></code> for labelling the outliers.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_col.idn">col.idn</code></td>
<td>
<p>the corresponding <code>col</code> argument for
<code><a href="graphics.html#topic+text">text</a></code> for labelling the outliers.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_lty.cutoff">lty.cutoff</code></td>
<td>
<p>the corresponding <code>lty</code> argument for
<code><a href="graphics.html#topic+abline">abline</a></code> for drawing the cutoff lines;
either one lty-value (one value or vector) or a list of length 2
of lty-values.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_lwd.cutoff">lwd.cutoff</code></td>
<td>
<p>(vector cast to length 2): the corresponding <code>lwd</code> argument for
<code><a href="graphics.html#topic+abline">abline</a></code> for drawing the cutoff lines.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_col.cutoff">col.cutoff</code></td>
<td>
<p>(vector cast to length 2): the corresponding <code>col</code> argument for
<code><a href="graphics.html#topic+abline">abline</a></code> for drawing the cutoff lines.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline">text.abline</code></td>
<td>
<p>vector of logicals (cast to length 2): shall text be added
to cutoff lines.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.x">text.abline.x</code></td>
<td>
<p>text to be added to cutoff lines in x direction; if <code>NULL</code>
(default) we use &ldquo;[pp] %-cutoff = [ff]&rdquo; where [pp] is the percentag up to 2 digits
and [ff] is the cutoff value up to 2 digits.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.y">text.abline.y</code></td>
<td>
<p>text to be added to cutoff lines in y direction; if <code>NULL</code>
(default) we use &ldquo;[pp] %-cutoff = [ff]&rdquo; where [pp] is the percentag up to 2 digits
and [ff] is the cutoff value up to 2 digits.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_cex.abline">cex.abline</code></td>
<td>
<p>vector of numerics (cast to length 2): cex-value for added cutoff text.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_col.abline">col.abline</code></td>
<td>
<p>vector of length 2: color for added cutoff text.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_font.abline">font.abline</code></td>
<td>
<p>vector of length 2: font for added cutoff text.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_adj.abline">adj.abline</code></td>
<td>
<p>cast to 2 x 2 matrix (by recycling rules): adjustment values for added cutoff text.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.x.y">text.abline.x.y</code></td>
<td>
<p>y-coordinate of text to be added to cutoff lines in x direction;
if <code>NULL</code> (default) set to mid of <code>mean(par("usr")[c(3,4)])</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.y.x">text.abline.y.x</code></td>
<td>
<p>x-coordinate of text to be added to cutoff lines in y direction;
if <code>NULL</code> (default) set to mid of <code>mean(par("usr")[c(1,2)])</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.x.x">text.abline.x.x</code></td>
<td>
<p>x-coordinate of text to be added to cutoff lines in x direction;
if <code>NULL</code> (default) set to 1.05 times the cutoff value.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.y.y">text.abline.y.y</code></td>
<td>
<p>y-coordinate of text to be added to cutoff lines in y direction;
if <code>NULL</code> (default) set to 1.05 times the cutoff value.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.x.fmt.cx">text.abline.x.fmt.cx</code></td>
<td>
<p>format string (see <code><a href="base.html#topic+sprintf">gettextf</a></code>) to format the cutoff value in label in x direction.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.x.fmt.qx">text.abline.x.fmt.qx</code></td>
<td>
<p>format string to format cutoff probability in label in x direction.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.y.fmt.cy">text.abline.y.fmt.cy</code></td>
<td>
<p>format string to format the cutoff value in label in y direction.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_text.abline.y.fmt.qy">text.abline.y.fmt.qy</code></td>
<td>
<p>format string to format cutoff probability in label in y direction.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_jitter.fac">jitter.fac</code></td>
<td>
<p>factor for jittering, see <code>jitter</code>;</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_jitter.tol">jitter.tol</code></td>
<td>
<p>threshold for jittering: if distance between points is smaller
than <code>jitter.tol</code>, points are considered replicates.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_ddPlot_+3A_doplot">doplot</code></td>
<td>
<p>logical; shall a plot be produced? if <code>FALSE</code> only the return values are produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>performs the plotting for <code><a href="#topic+ddPlot">ddPlot</a></code> and <code><a href="#topic+outlyingPlotIC">outlyingPlotIC</a></code>;
all arguments except for <code>data</code> are optional. In case they are missing
default values are used as usual; for those arguments without default arguments,
we do
</p>

<dl>
<dt>transform.x</dt><dd><p>defaults to identity, internally</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>id.n</dt><dd><p>defaults to <code>1:ncol(data)</code>, internally</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>lab.pts</dt><dd><p>defaults to <code>(1:ncol(data))[id.n]</code>, internally</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>lwd.cutoff</dt><dd><p>defaults to argument <code>lwd</code>, if given, else to <code>par{lwd}</code>, internally</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>lty.cutoff</dt><dd><p>defaults to argument <code>lty</code>, if given, else to <code>par{lty}</code>, internally</p>
</dd></dl>
<p>.

</p>


<h3>Value</h3>

<p>a list (returned as <code>invisible()</code>) with items
</p>
<table>
<tr><td><code>id.x</code></td>
<td>
<p>the indices of (possibly transformed) data (within subset <code>id.n</code>) beyond the <code>x</code>-cutoff</p>
</td></tr>
<tr><td><code>id.y</code></td>
<td>
<p>the indices of (possibly transformed) data (within subset <code>id.n</code>) beyond the <code>y</code>-cutoff</p>
</td></tr>
<tr><td><code>id.xy</code></td>
<td>
<p>the indices of (possibly transformed) data (within subset <code>id.n</code>) beyond the <code>x</code>-cutoff and the <code>y</code>-cutoff</p>
</td></tr>
<tr><td><code>qtx</code></td>
<td>
<p>the quantiles of the distances of the (possibly transformed) data in <code>x</code> direction</p>
</td></tr>
<tr><td><code>qty</code></td>
<td>
<p>the quantiles of the distances of the (possibly transformed) data in <code>y</code> direction</p>
</td></tr>
<tr><td><code>cutoff.x.v</code></td>
<td>
<p>the cutoff value in <code>x</code> direction</p>
</td></tr>
<tr><td><code>cutoff.y.v</code></td>
<td>
<p>the cutoff value in <code>y</code> direction</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="#topic+ddPlot">ddPlot</a></code>, <code><a href="#topic+outlyingPlotIC">outlyingPlotIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>MX &lt;- matrix(rnorm(1500),nrow=6)
QM &lt;- matrix(rnorm(36),nrow=6); QM &lt;- QM %*% t(QM)
RobAStBase:::.ddPlot.MatNtNtCoCo(data=MX, 
        dist.y=QFNorm(QuadF=PosSemDefSymmMatrix(QM)),
        xlab="Norm.x",ylab="Norm.y", cex.idn = 1.3, offset=0,
        lwd=2, lwd.cutoff=4, lty=2, col.cutoff =2, col.idn="green",
        col = "blue", adj=0.4, pos=4,id.n = sample(1:200,size=100),
        lab.pts=letters,log="x", main="GA", sub="NO",cex.sub=0.2)
</code></pre>

<hr>
<h2 id='internals_for_RobAStBase_plot'>Internal / Helper functions of package RobAStBase for plot functions</h2><span id='topic+internals_for_RobAStBase_plot'></span><span id='topic+.rescalefct'></span><span id='topic+.plotRescaledAxis'></span><span id='topic+.legendCoord'></span><span id='topic+.SelectOrderData'></span><span id='topic+.makedotsP'></span><span id='topic+.makedotsLowLevel'></span><span id='topic+.cexscale'></span><span id='topic+.getX.vec'></span><span id='topic+.getXlimYlim'></span><span id='topic+.prepareTitles'></span><span id='topic+.getToDraw'></span><span id='topic+.preparePanelFirstLast'></span>

<h3>Description</h3>

<p>These functions are internally used helper functions for <code><a href="#topic+plot">plot</a></code>,
<code><a href="#topic+infoPlot">infoPlot</a></code> <code><a href="#topic+comparePlot">comparePlot</a></code> in package <span class="pkg">RobAStBase</span>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rescalefct(x, fct, scaleX = FALSE, scaleX.fct, scaleX.inv,
         scaleY = FALSE, scaleY.fct = pnorm,
         xlim, ylim, dots)
.plotRescaledAxis(scaleX, scaleX.fct, scaleX.inv, scaleY,scaleY.fct,
                  scaleY.inv, xlim, ylim, X, ypts = 400, n = 11,
                  finiteEndpoints = rep(FALSE,4),
                  x.ticks = NULL, y.ticks = NULL, withbox = TRUE)
.legendCoord(x, scaleX, scaleX.fct, scaleY, scaleY.fct)
.SelectOrderData(data, fct, which.lbs, which.Order, which.nonlbs = NULL)
.makedotsP(dots)
.makedotsLowLevel(dots)
.cexscale(y, y1=y, maxcex=4,mincex=0.05,cex, fun=NULL)
.getX.vec(distr, dims0, lty, x.vec, scaleX, scaleX.fct, scaleX.inv, xm, xM)
.getXlimYlim(dots,dotsP, dims0, xlim, ylim)
.prepareTitles(withSubst, presubArg2, presubArg3, dots, mainText,
               L2Fam, inner, dims0, dims, to.draw, trafO, obj, type, bmar, tmar)
.getToDraw(dims, trafO, L2Fam, to.draw.arg, Abs=NULL)
.preparePanelFirstLast(with.automatic.grid , dims0, pF.0, pL.0,
            logArg, scaleX, scaleY, x.ticks, y.ticks, scaleX.fct, scaleY.fct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_scalex">scaleX</code></td>
<td>
<p>logical; shall X-axis be rescaled (by default according to the cdf of
the underlying distribution)?</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_scaley">scaleY</code></td>
<td>
<p>logical; shall Y-axis be rescaled (by default according to a probit scale)?</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_scalex.fct">scaleX.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the domain of the IC
to [0,1]; if <code>scaleX</code> is <code>TRUE</code> and <code>scaleX.fct</code> is
missing, the cdf of the underlying observation distribution.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_scalex.inv">scaleX.inv</code></td>
<td>
<p>the inverse function to <code>scale.fct</code>, i.e., an isotone,
vectorized function mapping [0,1] to the domain of the IC
such that for any <code>x</code> in the domain,<br />
<code>scaleX.inv(scaleX.fct(x))==x</code>; if <code>scaleX</code> is <code>TRUE</code>
and <code>scaleX.inv</code> is
missing, the quantile function of the underlying observation distribution.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_scaley.fct">scaleY.fct</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate the
range of the respective coordinate of the IC
to [0,1]; defaulting to the cdf of <code class="reqn">{\cal N}(0,1)</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_scaley.inv">scaleY.inv</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate
the range [0,1] into the range of the respective coordinate of the IC;
defaulting to the quantile function of  <code class="reqn">{\cal N}(0,1)</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_fct">fct</code></td>
<td>
<p>for <code>.rescalefct</code>: (vectorized) function from reals to reals: function to produce y values.
for <code>.SelectOrderData</code>: (vectorized) function from data to reals:
function to produce the ordering.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_xlim">xlim</code></td>
<td>
<p>for one-panel plots: numeric vector of length 2: limits of the plotted x region (in original
scale), for multi-panel plots: can be matrix valued (with two columns and as many rows as panels).</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_ylim">ylim</code></td>
<td>
<p>for one-panel plots: numeric vector of length 2: limits of the plotted y region (in original
scale), for multi-panel plots: can be matrix valued (with two columns and as many rows as panels).</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_finiteendpoints">finiteEndpoints</code></td>
<td>
<p>a logical of length 4: are the  unscaled <code>xlim[1]</code>,
<code>xlim[2]</code>, <code>ylim[1]</code>, <code>ylim[2]</code> finite? </p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_x.ticks">x.ticks</code></td>
<td>
<p>numeric: coordinates in original scale of user-given ticks on x-axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_y.ticks">y.ticks</code></td>
<td>
<p>numeric: coordinates in original scale of user-given ticks on y-axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_n">n</code></td>
<td>
<p>integer: number of default ticks in x and y axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_x">X</code></td>
<td>
<p>numeric: x-values on [0,1]-scale from which to produce range of x axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_ypts">ypts</code></td>
<td>
<p>integer: number of y-points to be generated on [0,1] range to
produce y-axis.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_dots">dots</code></td>
<td>
<p>dots argument for later calls to <code>plot</code> which is manipulated
when using rescaling.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_x">x</code></td>
<td>
<p>coordinates of the legend placement to be rescaled when using a
scale transformation.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_data">data</code></td>
<td>
<p>numeric or data.frame containing numerics; observations to be plotted into
a graph.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_which.lbs">which.lbs</code></td>
<td>
<p>either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then no observation is excluded</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_which.order">which.Order</code></td>
<td>
<p>indices of the observations after ordering which are to be
plotted into the graph; more speficically, the indices are obtained after
a possible thin-out by <code>which.lbs</code> and after ordering in descending order
of the remaining observations. If this argument is <code>NULL</code> then no
(further) observation is excluded.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_which.nonlbs">which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then all non-labelled
observations are plotted.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_withbox">withbox</code></td>
<td>
<p>logical of length 1. If <code>TRUE</code>, even if <code>scaleX</code> and
<code>scaleY</code> are both <code>FALSE</code> and, simultaneously, <code>x.ticks</code> and
<code>y.ticks</code> are both <code>NULL</code>, a respective box is drawn around the
panel; otherwise no box is drawn in this case. </p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_y">y</code></td>
<td>
<p>input at which to compute <code>cex</code>-values (for these <code>y</code> values)</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_y1">y1</code></td>
<td>
<p>secondary input of <code>y</code>-values which is also used for
computaiton but not plotted itself at this <code>cex</code> value.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_maxcex">maxcex</code></td>
<td>
<p>maximal value for <code>cex</code></p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_mincex">mincex</code></td>
<td>
<p>minimal value for <code>cex</code></p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_cex">cex</code></td>
<td>
<p>basic factor for <code>cex</code></p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_fun">fun</code></td>
<td>
<p>(optional) function to compute the <code>cex</code>-values acc. to the
<code>y</code> and <code>y1</code>-values.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_l2fam">L2Fam</code></td>
<td>
<p>L2-Family</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_to.draw.arg">to.draw.arg</code></td>
<td>
<p>resp. argument from the user-interface of <code>comparePlot</code>,        
<code>infoPlot</code>, and the <code>plot</code>-method for ICs, i.e., either <code>NULL</code> 
(default; everything is plotted) or a vector of either integers (the indices 
of the subplots to be drawn) or characters &mdash; the names of the subplots 
to be drawn: these names are to be chosen either among the row names of 
the trafo matrix <code>rownames(trafo(eval(x@CallL2Fam)@param))</code> or if 
the last expression is <code>NULL</code> a vector <code>"dim&lt;dimnr&gt;"</code>, <code>dimnr</code> 
running through the number of rows of the trafo matrix.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_distr">distr</code></td>
<td>
<p>underlying distribution of the observations</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_dims0">dims0</code></td>
<td>
<p>number of panels to be plotted</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_lty">lty</code></td>
<td>
<p>the <code>lty</code> argument used in the user interface</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_x.vec">x.vec</code></td>
<td>
<p>the resp. argument from the user interface.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_xm">xm</code></td>
<td>
<p>minimal x-value</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_xm">xM</code></td>
<td>
<p>maximal x-value</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_dotsp">dotsP</code></td>
<td>
<p>the internal <code>dotsP</code>-variable to be changed (taking up
additional arguments for the calls to <code>plot</code>); see also Details 
section.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_withsubst">withSubst</code></td>
<td>
<p>should substitutions be made in titles?</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_presubarg2">presubArg2</code></td>
<td>
<p>title part</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_presubarg3">presubArg3</code></td>
<td>
<p>title part</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_maintext">mainText</code></td>
<td>
<p>text to be used for <code>main</code></p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_inner">inner</code></td>
<td>
<p>the resp. argument from the user interface.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_dims">dims</code></td>
<td>
<p>the dimension of the pIC</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_to.draw">to.draw</code></td>
<td>
<p>the actual numbers / names of the plotted panels.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_trafo">trafO</code></td>
<td>
<p>the parameter transformation of  <code>L2fam@param</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_obj">obj</code></td>
<td>
<p>the object from which to draw the name (of the plot).</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_type">type</code></td>
<td>
<p>for which type of plot should the titles be produced &ndash; <code>"info"</code>,
<code>"all"</code> or <code>compare</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_bmar">bmar</code></td>
<td>
<p>resp. argument from the user-interface of <code>comparePlot</code>, 
<code>infoPlot</code>, and the <code>plot</code>-method for ICs.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_tmar">tmar</code></td>
<td>
<p>resp. argument from the user-interface of <code>comparePlot</code>, 
<code>infoPlot</code>, and the <code>plot</code>-method for ICs.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_abs">Abs</code></td>
<td>
<p>additional text template used in <code>infoPlot</code>.</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_with.automatic.grid">with.automatic.grid</code></td>
<td>
<p>generate a grid automatically. </p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_pf.0">pF.0</code></td>
<td>
<p>the <code>panel.first</code> expression given by rhe user</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_pl.0">pL.0</code></td>
<td>
<p>the <code>panel.last</code> expression  given by rhe user</p>
</td></tr>
<tr><td><code id="internals_for_RobAStBase_plot_+3A_logarg">logArg</code></td>
<td>
<p>a character vector with <code>log</code>-arguments for <code>plot</code>
for each of the plotted panels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.rescalefct</code> rescales, if necessary, x and y axis for use in plot
functions. More specifically, if <code>scaleX</code> is <code>TRUE</code> rescales x,
if <code>scaleY</code> is <code>TRUE</code> rescales fct(x) (otherwise leaves them
unchanges); to this end uses trafos <code>scaleX.fct</code> with inverse
<code>scaleX.inv</code>, resp. <code>scaleY.fct</code>; it respects <code>xlim</code>
and  <code>ylim</code> (given in orig. scale), thins out the scaled values if
necessary and accordingly modifies  slots <code>xaxt</code>, <code>yaxt</code>, and
<code>axes</code> of argument <code>dots</code> to indicate the new axes have to be drawn;
using the  paradigm small letters to denote values on original scale and
capital letters on transformed scale, its return value is a list with
(thinned out) values of x and y, X and Y and modified dots.
</p>
<p><code>.plotRescaledAxis</code> plots rescaled axes according to logicals
<code>scaleX</code>, <code>scaleY</code>; to this end uses trafos <code>scaleX.fct</code> with
inverse <code>scale.inv</code>, resp. <code>scaleY.fct</code>, <code>scaleY.inv</code>;
it respects <code>xlim</code> and <code>ylim</code>. By default, ot produces the x axes according
to the values in argument <code>X</code>, and the y axes as an equidistant grid of
length <code>ypts</code> on [0,1] (on transformed scale); each of these axes, again
by default will have <code>n</code> tick values; these are however thinned out if
the come to lie too close to each other on transformed scale.
Instead of producing automatically chosen tick values, the user may explicitly
require x-ticks and y-ticks values on the axes, using arguments <code>x.ticks</code>
and <code>y-ticks</code>. This function has no return value.
</p>
<p><code>.legendCoord</code> produces, if needed (i.e., if coordinates are not
given as strings like <code>"bottomright"</code>), rescaled coordinates for the
placement of a legend.
</p>
<p><code>.SelectOrderData</code>, for data to be plotted into the graph,
performs two optional selections: a first selection on the unordered (original)
data (acc. to argument <code>which.lbs</code>) and a second selection according to
<code>which.Order</code> on the data remaining after the first selection and ordered
according to argument <code>fct</code>; the return value is a list with elements
<code>data</code>, ie., the selected/thinned out data, <code>y</code>, ie., the
values of  <code>fct(data)</code>, <code>ind</code>, ie., the indices of the selected data
in the original data (after possibly two selections), and <code>ind1</code> the
indices of the data selected by <code>which.lbs</code> in the original data; in 
addition also the non selected data, <code>data.ns</code>, the respective
y-values <code>y.ns</code> and the corresponding index elements <code>ind.ns</code> are
returned as list items.
</p>
<p><code>.makedotsP</code> and <code>.makedotsLowLevel</code> manipulate the <code>...</code>
argument, deleting certain items and selecting items which can be digested by
<code>plot</code>, returning the manipulated list.
</p>
<p><code>.cexscale</code> rescales the point sizes of the points to be plotted;
the unscaled sizes are given in argument <code>y</code>, <code>y1</code> in
case of several lines of points to be plotted may contain the
vector of the sizes of all points to be plotted in (e.g., including
those of the other lines of points). <code>maxcex</code> and <code>mincex</code>
are maximum and minimum of the raw rescaled sizes; <code>cex</code> is
a factor drawn from argument <code>cex.pts</code> by which the raw sizes
are rescaled before being returned. <code>fun</code> is the function
by which the rescaling is done; by default this argument is <code>NULL</code>
and in this case the function <code>log(1+abs(x))</code> is used.
</p>
<p><code>.getDimsTD</code> returns the number of different coordinates to be plotted.
</p>
<p><code>.producePanelFirstS</code> for each graphical panel inserts
(if needed) x and y tickmarks for user-specific axes
into a <code>panel.first</code> expression.
</p>
<p><code>.getX.vec</code> produces the x-grid (on original scale) for each of the panels
and decides whether to plot lines or points.
</p>
<p><code>.getXlimYlim</code> produces panel-wise <code>xlim</code> and <code>ylim</code> arguments
as well as left and right endpoints of the x-scalas.
</p>
<p><code>.prepareTitles</code> produces the titles for the panels.
</p>
<p><code>.getToDraw</code> computes which panels are to be drawn.
<code>.preparePanelFirstLast</code> prepares the <code>panel.first</code> and <code>panel.last</code>
expressions for each of the panels.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>

<hr>
<h2 id='interpolRisk-class'>Interpolated Risks</h2><span id='topic+interpolRisk-class'></span><span id='topic+OMSRRisk-class'></span><span id='topic+RMXRRisk-class'></span><span id='topic+MBRRisk-class'></span><span id='topic+OMSRRisk'></span><span id='topic+RMXRRisk'></span><span id='topic+MBRRisk'></span>

<h3>Description</h3>

<p>Class of risks for which algorithms dispatch to speed-up algorithms</p>


<h3>Usage</h3>

<pre><code class='language-R'>MBRRisk(samplesize=100)
OMSRRisk(samplesize=100)
RMXRRisk(samplesize=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolRisk-class_+3A_samplesize">samplesize</code></td>
<td>
<p>sample size at which to look at the risk.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of classes <code>OMSRRisk</code>, <code>MBRRisk</code>, and
<code>RMXRRisk</code> is to help to dispatch into speed-up algorithms later
in function <code>roptest</code>. In all these risks, we assume
convex contamination neighborhoods.
<code>OMSRRisk</code> stands for optimal MSE-robust estimation (where we assume
a radius r of <code>0.5</code>), <code>RMXRRisk</code> stands for optimal
optimally RMX-robust estimation and <code>MBRRisk</code> stands for optimal
Bias-robust estimation.
All these risks have an additional slot samplesize, defaulting to <code>100</code>,
and for which there is a replacement and an accessor method.
</p>


<h3>Objects from the Class</h3>

<p><code>interpolRisk</code> is a virtual class: No objects may be created from it.
the other classes are generated via generating functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
type of risk. (Inherited from <code>RiskType</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("OMSRRisk")
OMSRRisk()
RMXRRisk()
MBRRisk()
myrisk &lt;- MBRRisk(samplesize=100)
samplesize(myrisk)
samplesize(myrisk) &lt;- 20
</code></pre>

<hr>
<h2 id='kStepEstimate-class'>kStepEstimate-class.</h2><span id='topic+OptionalCall-class'></span><span id='topic+kStepEstimate-class'></span><span id='topic+steps'></span><span id='topic+steps+2CkStepEstimate-method'></span><span id='topic+ksteps'></span><span id='topic+ksteps+2CkStepEstimate-method'></span><span id='topic+uksteps'></span><span id='topic+uksteps+2CkStepEstimate-method'></span><span id='topic+ICList'></span><span id='topic+ICList+2CkStepEstimate-method'></span><span id='topic+pICList'></span><span id='topic+pICList+2CkStepEstimate-method'></span><span id='topic+robestCall'></span><span id='topic+robestCall+2CkStepEstimate-method'></span><span id='topic+start+2CkStepEstimate-method'></span><span id='topic+startval'></span><span id='topic+startval+2CkStepEstimate-method'></span><span id='topic+ustartval'></span><span id='topic+ustartval+2CkStepEstimate-method'></span><span id='topic+show+2CkStepEstimate-method'></span><span id='topic+timings'></span><span id='topic+timings+2CkStepEstimate-method'></span>

<h3>Description</h3>

<p>Class of asymptotically linear estimates.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("kStepEstimate", ...)</code>.
More frequently they are created via the generating function 
<code>kStepEstimator</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
name of the estimator. </p>
</dd>
<dt><code>estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
estimate. </p>
</dd>
<dt><code>estimate.call</code></dt><dd><p>Object of class <code>"call"</code>:
call by which estimate was produced.</p>
</dd>
<dt><code>samplesize</code></dt><dd><p> object of class <code>"numeric"</code> &mdash;
the samplesize (only complete cases are counted)
at which the estimate was evaluated. </p>
</dd>
<dt><code>completecases</code>:</dt><dd><p> object of class <code>"logical"</code> &mdash;
complete cases at which the estimate was evaluated. </p>
</dd>
<dt><code>asvar</code></dt><dd><p> object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the estimator. </p>
</dd>
<dt><code>asbias</code></dt><dd><p>Optional object of class <code>"numeric"</code>:
asymptotic bias. </p>
</dd>
<dt><code>pIC</code></dt><dd><p>Optional object of class <code>InfluenceCurve</code>:
influence curve. </p>
</dd>
<dt><code>nuis.idx</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>: 
indices of <code>estimate</code> belonging to the nuisance part. </p>
</dd>
<dt><code>fixed</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>:
the fixed and known part of the parameter.</p>
</dd>
<dt><code>steps</code></dt><dd><p>Object of class <code>"integer"</code>: number
of steps. </p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
<dt><code>trafo</code></dt><dd><p> object of class <code>"list"</code>:
a list with components <code>fct</code> and <code>mat</code> (see below). </p>
</dd>
<dt><code>untransformed.estimate</code>:</dt><dd><p>Object of class <code>"ANY"</code>:
untransformed estimate.</p>
</dd>
<dt><code>untransformed.asvar</code>:</dt><dd><p> object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the untransformed
estimator. </p>
</dd>
<dt><code>pICList</code></dt><dd><p>Optional object of class <code>"OptionalpICList"</code>:
the list of (intermediate) (partial) influence curves used;
only filled when called from <code>kStepEstimator</code> with argument
<code>withPICList==TRUE</code>. </p>
</dd>
<dt><code>ICList</code></dt><dd><p>Optional object of class <code>"OptionalpICList"</code>:
the list of (intermediate) (total) influence curves used;
only filled when called from <code>kStepEstimator</code> with argument
<code>withICList==TRUE</code>. </p>
</dd>
<dt><code>start</code></dt><dd><p>The argument <code>start</code> &mdash; of class <code>"StartClass"</code>
used in call to <code>kStepEstimator</code>. </p>
</dd>
<dt><code>startval</code></dt><dd><p>Object of class <code>matrix</code>:
the starting value with which the k-step Estimator was initialized
(in <code class="reqn">p</code>-space / transformed). </p>
</dd>
<dt><code>ustartval</code></dt><dd><p>Object of class <code>matrix</code>:
the starting value with which the k-step Estimator was initialized
(in <code class="reqn">k</code>-space / untransformed). </p>
</dd>
<dt><code>ksteps</code></dt><dd><p>Object of class <code>"OptionalMatrix"</code>:
the intermediate estimates (in <code class="reqn">p</code>-space) for the parameter;
only filled when called from <code>kStepEstimator</code>. </p>
</dd>
<dt><code>uksteps</code></dt><dd><p>Object of class <code>"OptionalMatrix"</code>:
the intermediate estimates (in <code class="reqn">k</code>-space) for the parameter;
only filled when called from <code>kStepEstimator</code>. </p>
</dd>
<dt><code>robestcall</code></dt><dd><p>Object of class <code>"OptionalCall"</code>, i.e.,
a <code>call</code> or <code>NULL</code>: only filled when called from <code>roptest</code>
in package <span class="pkg">ROptEst</span>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ALEstimate"</code>, directly.<br />
Class <code>"Estimate"</code>, by class <code>"ALEstimate"</code>
</p>


<h3>Methods</h3>


<dl>
<dt>steps</dt><dd><p><code>signature(object = "kStepEstimate")</code>: 
accessor function for slot <code>steps</code>. </p>
</dd>
<dt>ksteps</dt><dd><p><code>signature(object = "kStepEstimate")</code>:
accessor function for slot <code>ksteps</code>; has additional argument
<code>diff</code>, defaulting to <code>FALSE</code>; if the latter is <code>TRUE</code>,
the starting value from slot <code>startval</code> is prepended as first column;
otherwise we return the corresponding increments in each step. </p>
</dd>
<dt>uksteps</dt><dd><p><code>signature(object = "kStepEstimate")</code>:
accessor function for slot <code>uksteps</code>; has additional argument
<code>diff</code>, defaulting to <code>FALSE</code>; if the latter is <code>TRUE</code>,
the starting value from slot <code>ustartval</code> is prepended as first column;
otherwise we return the corresponding increments in each step. </p>
</dd>
<dt>start</dt><dd><p><code>signature(object = "kStepEstimate")</code>:
accessor function for slot <code>start</code>. </p>
</dd>
<dt>startval</dt><dd><p><code>signature(object = "kStepEstimate")</code>:
accessor function for slot <code>startval</code>. </p>
</dd>
<dt>ustartval</dt><dd><p><code>signature(object = "kStepEstimate")</code>:
accessor function for slot <code>startval</code>. </p>
</dd>
<dt>ICList</dt><dd><p><code>signature(object = "kStepEstimate")</code>:
accessor function for slot <code>ICList</code>. </p>
</dd>
<dt>pICList</dt><dd><p><code>signature(object = "kStepEstimate")</code>:
accessor function for slot <code>pICList</code>. </p>
</dd>
<dt>robestCall</dt><dd><p><code>signature(object = "kStepEstimate")</code>:
accessor function for slot <code>robestCall</code>. </p>
</dd>
<dt>timings</dt><dd><p><code>signature(object = "kStepEstimate")</code>:
accessor function for attribute <code>"timings"</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "kStepEstimate")</code>: a show method; </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> and
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenurg.de">peter.ruckdeschel@uni-oldenurg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ALEstimate-class">ALEstimate-class</a></code></p>

<hr>
<h2 id='kStepEstimator'>Function for the computation of k-step estimates</h2><span id='topic+kStepEstimator'></span>

<h3>Description</h3>

<p>Function for the computation of k-step estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kStepEstimator(x, IC, start = NULL, steps = 1L,
      useLast = getRobAStBaseOption("kStepUseLast"),
      withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
      IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
      withICList = getRobAStBaseOption("withICList"),
      withPICList = getRobAStBaseOption("withPICList"),
      na.rm = TRUE, startArgList = NULL, ...,
      withLogScale = TRUE, withEvalAsVar = TRUE,
      withMakeIC = FALSE, E.argList = NULL, diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kStepEstimator_+3A_x">x</code></td>
<td>
<p> sample </p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"IC"</code> </p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_start">start</code></td>
<td>
<p> initial estimate (for full parameter,i.e. in dimension <code class="reqn">k</code> respective
joint length of main and nuisance part of the parameter):
either a numerical value, or an object of class <code>"Estimate"</code> or
a function producing either a numerical value, or an object of class <code>"Estimate"</code>
when evaluated at <code>x,...</code>; if missing or <code>NULL</code>, we use slot <code>startPar</code>
of the L2family <code>L2Fam</code> from within <code>IC</code></p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_steps">steps</code></td>
<td>
<p> integer: number of steps </p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_uselast">useLast</code></td>
<td>
<p> which parameter estimate (initial estimate or
k-step estimate) shall be used to fill the slots <code>pIC</code>,
<code>asvar</code> and <code>asbias</code> of the return value. </p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_withupdateinker">withUpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>, shall
the parameter be updated on <code class="reqn">{\rm ker}(D)</code>?</p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_ic.updateinker">IC.UpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>,
the IC to be used for this; if <code>NULL</code> the result of <code>getboundedIC(L2Fam,D)</code> is taken;
this IC will then be projected onto <code class="reqn">{\rm ker}(D)</code>.</p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_startarglist">startArgList</code></td>
<td>
<p>a list of arguments to be given to argument <code>start</code> if the latter
is a function; this list by default already starts with two unnamed items,
the sample <code>x</code>, and the model <code>eval(CallL2Fam(IC))</code>.</p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_withpiclist">withPICList</code></td>
<td>
<p>logical: shall slot <code>pICList</code> of return value
be filled?</p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_withiclist">withICList</code></td>
<td>
<p>logical: shall slot <code>ICList</code> of return value
be filled?</p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_...">...</code></td>
<td>
<p> additional parameters </p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_withlogscale">withLogScale</code></td>
<td>
<p>logical; if <code>TRUE</code>, a scale component (if existing
and found with name <code>scalename</code>) is computed on log-scale and
backtransformed afterwards (default). This avoids crossing 0. </p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_withevalasvar">withEvalAsVar</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), tells R to evaluate
the asymptotic variance or just to produces a call to do so.</p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_e.arglist">E.argList</code></td>
<td>
<p><code>NULL</code> (default) or a named list of arguments to be passed
to calls to <code>E</code> from <code>kStepEstimator</code>; potential clashes with
arguments of the same name in <code>...</code> are resolved by inserting
the items of argument list <code>E.argList</code> as named items to the argument
lists, so in case of collisions the item of <code>E.argList</code> overwrites the
existing one from <code>...</code>.</p>
</td></tr>
<tr><td><code id="kStepEstimator_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>,
diagnostic information on the performed integrations is gathered and
shipped out as an attribute <code>diagnostic</code> of the return value
of <code>kStepEstimator</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an initial estimation <code>start</code>, a sample <code>x</code> 
and an influence curve <code>IC</code> the corresponding k-step
estimator is computed.
</p>
<p>The default value of argument <code>useLast</code> is set by the
global option <code>kStepUseLast</code> which by default is set to 
<code>FALSE</code>. In case of general models <code>useLast</code> 
remains unchanged during the computations. However, if 
slot <code>CallL2Fam</code> of <code>IC</code> generates an object of 
class <code>"L2GroupParamFamily"</code> the value of <code>useLast</code> 
is changed to <code>TRUE</code>.
Explicitly setting <code>useLast</code> to <code>TRUE</code> should
be done with care as in this situation the influence curve
is re-computed using the value of the one-step estimate
which may take quite a long time depending on the model.
</p>
<p>If <code>useLast</code> is set to <code>TRUE</code> and slot <code>modifyIC</code> 
of <code>IC</code> is filled with some function (which can be 
used to re-compute the IC for a different parameter), the 
computation of <code>asvar</code>, <code>asbias</code> and <code>IC</code> is 
based on the k-step estimate.
</p>
<p>Timings for the several substeps are available as attribute
<code>timings</code> of the return value.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="distrEx.html#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="distrEx.html#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code>.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC-class">IC-class</a></code>, <code><a href="#topic+kStepEstimate-class">kStepEstimate-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## don't run to reduce check time on CRAN

if(require(ROptEst)){
## 1. generate a contaminated sample
ind &lt;- rbinom(100, size=1, prob=0.05)
x &lt;- rnorm(100, mean=0, sd=(1-ind) + ind*9)

## 2. Kolmogorov(-Smirnov) minimum distance estimator
(est0 &lt;- MDEstimator(x=x, NormLocationScaleFamily()))

## 3. k-step estimation: radius known
N1 &lt;- NormLocationScaleFamily(mean=estimate(est0)["mean"], sd=estimate(est0)["sd"])
N1.Rob &lt;- InfRobModel(center = N1, neighbor = ContNeighborhood(radius = 0.5))
IC1 &lt;- optIC(model = N1.Rob, risk = asMSE())
(est1 &lt;- kStepEstimator(x, IC1, est0, steps = 3, withPIC = TRUE))
estimate(est1)
ksteps(est1)
pICList(est1)
start(est1)
attr(est1,"timings")

## a transformed model
tfct &lt;- function(x){
    nms0 &lt;- c("mean","sd")
    nms  &lt;- "comb"
    fval0 &lt;- x[1]+2*x[2]
    names(fval0) &lt;- nms
    mat0 &lt;- matrix(c(1,2), nrow = 1, dimnames = list(nms,nms0))
    return(list(fval = fval0, mat = mat0))
}

N1.traf &lt;- N1; trafo(N1.traf) &lt;- tfct
N1R.traf &lt;- N1.Rob; trafo(N1R.traf) &lt;- tfct
IC1.traf &lt;- optIC(model = N1R.traf, risk = asMSE())
(est0.traf &lt;- MDEstimator(x, N1.traf))
(est1.traf &lt;- kStepEstimator(x, IC1.traf, est0, steps = 3,
                withIC = TRUE, withPIC = TRUE, withUpdateInKer = FALSE))
(est1a.traf &lt;- kStepEstimator(x, IC1.traf, est0, steps = 3,
                withIC = TRUE, withPIC = TRUE, withUpdateInKer = TRUE))
estimate(est1.traf)
ksteps(est1.traf)
pICList(est1.traf)
startval(est1.traf)

untransformed.estimate(est1.traf)
uksteps(est1.traf)
ICList(est1.traf)
ustartval(est1.traf)

estimate(est1a.traf)
ksteps(est1a.traf)
pICList(est1a.traf)
startval(est1a.traf)

untransformed.estimate(est1a.traf)
uksteps(est1a.traf)
ICList(est1a.traf)
ustartval(est1a.traf)
}

</code></pre>

<hr>
<h2 id='kStepEstimator.start-methods'> Methods for function kStepEstimator.start in Package &lsquo;RobAStBase&rsquo; </h2><span id='topic+kStepEstimator.start-methods'></span><span id='topic+kStepEstimator.start'></span><span id='topic+kStepEstimator.start+2Cnumeric-method'></span><span id='topic+kStepEstimator.start+2CEstimate-method'></span><span id='topic+kStepEstimator.start+2Cfunction-method'></span>

<h3>Description</h3>

<p>kStepEstimator.start-methods; these are called from within
<code>kStepEstimator</code> to produce a numeric value of for the starting estimator
in the end.</p>


<h3>Usage</h3>

<pre><code class='language-R'>kStepEstimator.start(start, ...)
## S4 method for signature 'numeric'
kStepEstimator.start(start, nrvalues, ...)
## S4 method for signature 'Estimate'
kStepEstimator.start(start, nrvalues, ...)
## S4 method for signature 'function'
kStepEstimator.start(start, x, nrvalues, na.rm, L2Fam, startList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kStepEstimator.start-methods_+3A_start">start</code></td>
<td>
<p>the start slot of an object of class <code>kStepEstimator</code></p>
</td></tr>
<tr><td><code id="kStepEstimator.start-methods_+3A_nrvalues">nrvalues</code></td>
<td>
<p>numeric; dimension <code class="reqn">k</code> of the original model, i.e.;
length of the untransformed parameter, or joint length of
main and nuisance part of the parameter.</p>
</td></tr>
<tr><td><code id="kStepEstimator.start-methods_+3A_x">x</code></td>
<td>
<p>the data at which the starting estimator is to be evaluated.</p>
</td></tr>
<tr><td><code id="kStepEstimator.start-methods_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="kStepEstimator.start-methods_+3A_startlist">startList</code></td>
<td>
<p>a list of arguments to be given to the call to <code>start</code>
if this is a function;</p>
</td></tr>
<tr><td><code id="kStepEstimator.start-methods_+3A_l2fam">L2Fam</code></td>
<td>
<p>the parametric famliy;</p>
</td></tr>
<tr><td><code id="kStepEstimator.start-methods_+3A_...">...</code></td>
<td>
<p>further arguments for <code>kStepEstimator.start</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with the corresponding value of the start estimator
(in <code class="reqn">k</code> space)</p>


<h3>Methods</h3>


<dl>
<dt>kStepEstimator.start</dt><dd><p><code>signature(start = "numeric")</code>:
returns the unchanged argument <code>start</code> if it has the correct length;
otherwise throws an error.</p>
</dd>
<dt>kStepEstimator.start</dt><dd><p><code>signature(start = "Estimate")</code>:
returns slot  <code>untransformed.estimate</code> of <code>start</code> if it is not
<code>NULL</code>, and else slot <code>estimate</code> if the latter has dimension
<code>nrvalues</code>.</p>
</dd>
<dt>kStepEstimator.start</dt><dd><p><code>signature(start = "function")</code>:
returns <code>kStepEstimator.start(do.call(start, args=c(list(x,L2Fam),startList)</code>
where, if <code>na.rm == TRUE</code>,
beforehand <code>x</code> has been modified to <code>x &lt;- complete.cases(x)</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kStepEstimator">kStepEstimator</a></code>,<code><a href="#topic+ALEstimate-class">ALEstimate-class</a></code></p>

<hr>
<h2 id='locMEstimator'>Generic function for the computation of location M estimates</h2><span id='topic+locMEstimator'></span><span id='topic+locMEstimator-methods'></span><span id='topic+locMEstimator+2Cnumeric+2CInfluenceCurve-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of location M estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locMEstimator(x, IC, ...)

## S4 method for signature 'numeric,InfluenceCurve'
locMEstimator(x, IC, eps = .Machine$double.eps^0.5, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locMEstimator_+3A_x">x</code></td>
<td>
<p> sample </p>
</td></tr>
<tr><td><code id="locMEstimator_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"InfluenceCurve"</code> </p>
</td></tr>
<tr><td><code id="locMEstimator_+3A_...">...</code></td>
<td>
<p> additional parameters </p>
</td></tr>
<tr><td><code id="locMEstimator_+3A_eps">eps</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>  
<tr><td><code id="locMEstimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Given some sample <code>x</code> and some influence curve <code>IC</code>
an M estimate is computed by solving the corresponding 
M equation. </p>


<h3>Value</h3>

<p>Object of class <code>"MEstimate"</code></p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;numeric&quot;, IC = &quot;InfluenceCurve&quot;</dt><dd><p> univariate location. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1964) Robust estimation of a location parameter. 
Ann. Math. Stat. <b>35</b>: 73&ndash;101.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InfluenceCurve-class">InfluenceCurve-class</a></code>, <code><a href="#topic+MEstimate-class">MEstimate-class</a></code> </p>

<hr>
<h2 id='makeIC'>Generic Function for making ICs consistent at a possibly different model</h2><span id='topic+makeIC'></span><span id='topic+makeIC-methods'></span><span id='topic+makeIC+2CIC+2Cmissing-method'></span><span id='topic+makeIC+2CIC+2CL2ParamFamily-method'></span><span id='topic+makeIC+2Clist+2CL2ParamFamily-method'></span><span id='topic+makeIC+2Cfunction+2CL2ParamFamily-method'></span>

<h3>Description</h3>

<p>Generic function for providing centering and Fisher consistency of ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeIC(IC, L2Fam, ...)
## S4 method for signature 'IC,L2ParamFamily'
makeIC(IC, L2Fam, ..., diagnostic = FALSE)
## S4 method for signature 'list,L2ParamFamily'
makeIC(IC, L2Fam, forceIC = TRUE, name, Risks,
                  Infos, modifyIC = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'function,L2ParamFamily'
makeIC(IC, L2Fam, forceIC = TRUE, name, 
                  Risks, Infos, modifyIC = NULL, ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeIC_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"IC"</code> for signature <code>IC="IC"</code>, respectively
a list of functions in one argument for signature <code>IC="list"</code>, respectively
a function in one argument for signature <code>IC="function"</code>.</p>
</td></tr>
<tr><td><code id="makeIC_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures; may be missing,
in which case it is replaced by the family in slot <code>CallL2Fam</code>
of <code>IC</code>. </p>
</td></tr>
<tr><td><code id="makeIC_+3A_forceic">forceIC</code></td>
<td>
<p> logical; shall centeredness and Fisher consistency be enforced
applying an affine linear transformation?</p>
</td></tr>
<tr><td><code id="makeIC_+3A_name">name</code></td>
<td>
<p> Object of class <code>"character"</code>; the name of the IC </p>
</td></tr>
<tr><td><code id="makeIC_+3A_risks">Risks</code></td>
<td>
<p> object of class <code>"list"</code>: 
list of risks; cf. <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code>. </p>
</td></tr>
<tr><td><code id="makeIC_+3A_infos">Infos</code></td>
<td>
<p> matrix of characters with two columns 
named <code>method</code> and <code>message</code>: additional informations. </p>
</td></tr>
<tr><td><code id="makeIC_+3A_modifyic">modifyIC</code></td>
<td>
<p> object of class <code>"OptionalFunction"</code>:
function of four arguments: (1) <code>L2Fam</code> an L2 parametric family
(2) <code>IC</code> an optional influence curve, (3) <code>withMakeIC</code>
a logical argument whether to enforce the IC side conditions
by <code>makeIC</code>, and (4) <code>...</code> for arguments to be passed to
calls to <code>E</code> in <code>makeIC</code>. Returns an object of
class <code>"IC"</code>. This function is mainly used for internal
computations! </p>
</td></tr>
<tr><td><code id="makeIC_+3A_...">...</code></td>
<td>
<p> additional parameters to be passed to expectation <code>E</code> </p>
</td></tr>
<tr><td><code id="makeIC_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>,
diagnostic information on the integration is printed and returned
as attribute <code>diagnostic</code> of the return value. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>IC</code> is transformed affinely such that the transformed IC
satisfies the defining side conditions of an IC, i.e., centeredness and
Fisher consistency:
</p>
<p style="text-align: center;"><code class="reqn">\mathop{\bm{E}}[{\rm IC}]=0</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathop{\bm{E}}[{\rm IC}\,\Lambda^\tau]= D</code>
</p>

<p>where <code class="reqn">\Lambda</code> is the L2 derivative of the model and D is
the Jacobian of transformation <code>trafo</code>.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="distrEx.html#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="distrEx.html#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p>An IC of class <code>"IC"</code> at the model.</p>


<h3>Methods</h3>


<dl>
<dt>makeIC</dt><dd><p><code>signature(IC = "IC", L2Fam = "missing"</code>: creates 
an object of class <code>"IC"</code> at the parametric model of its own
slot <code>CallL2Fam</code>; enforces IC conditions 
centeredness and Fisher consistency, applying an affine linear 
transformation.</p>
</dd>
<dt>makeIC</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2ParamFamily"</code>: creates 
an object of class <code>"IC"</code> at the parametric model <code>L2Fam</code>; 
enforces IC conditions centeredness and Fisher consistency, 
applying an affine linear transformation.</p>
</dd>
<dt>makeIC</dt><dd><p><code>signature(IC = "list", L2Fam = "L2ParamFamily"</code>: creates 
an object of class <code>"IC"</code> out of a list of functions given by argument 
<code>IC</code> at the parametric model <code>L2Fam</code>; 
enforces IC conditions centeredness and Fisher consistency, 
applying an affine linear transformation.</p>
</dd>
<dt>makeIC</dt><dd><p><code>signature(IC = "function", L2Fam = "L2ParamFamily"</code>: creates 
an object of class <code>"IC"</code> out of a function given by argument 
<code>IC</code> at the parametric model <code>L2Fam</code>; 
enforces IC conditions centeredness and Fisher consistency, 
applying an affine linear transformation.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## default IC
IC1 &lt;- new("IC")

## L2-differentiable parametric family
B &lt;- BinomFamily(13, 0.3)

## check IC properties
checkIC(IC1, B)

## make IC
IC2 &lt;- makeIC(IC1, B)

## check IC properties
checkIC(IC2)

## slot modifyIC is filled in case of IC2
IC3 &lt;- modifyIC(IC2)(BinomFamily(13, 0.2), IC2)
checkIC(IC3)
## identical to
checkIC(IC3, BinomFamily(13, 0.2))

IC4 &lt;- makeIC(sin, B)
checkIC(IC4)

(IC5 &lt;- makeIC(list(function(x)x^3), B, name="a try"))
plot(IC5)
checkIC(IC5)

## don't run to reduce check time on CRAN

N0 &lt;- NormLocationScaleFamily()
IC6 &lt;- makeIC(list(sin,cos),N0)
plot(IC6)
checkIC(IC6)

getRiskIC(IC6,risk=trAsCov())$trAsCov$value
getRiskIC(IC6,risk=asBias(),neighbor=ContNeighborhood())$asBias$value


</code></pre>

<hr>
<h2 id='masked-methods'>Masked Methods from Packages &lsquo;stats&rsquo; and &lsquo;graphics&rsquo; in Package &lsquo;RobAStBase&rsquo; </h2><span id='topic+maskedMethods'></span><span id='topic+clip'></span><span id='topic+clip-methods'></span><span id='topic+start-methods'></span><span id='topic+clip+2CANY-method'></span><span id='topic+start'></span><span id='topic+start+2CANY-method'></span>

<h3>Description</h3>

<p>masked methods from packages <span class="pkg">stats</span> and <span class="pkg">graphics</span></p>


<h3>Usage</h3>

<pre><code class='language-R'>clip(x1,...)
## S4 method for signature 'ANY'
clip(x1,x2,y1,y2)
start(x,...)
## S4 method for signature 'ANY'
start(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="masked-methods_+3A_x">x</code>, <code id="masked-methods_+3A_...">...</code></td>
<td>
<p>see <code><a href="stats.html#topic+start">start</a></code>.</p>
</td></tr>
<tr><td><code id="masked-methods_+3A_x1">x1</code>, <code id="masked-methods_+3A_x2">x2</code>, <code id="masked-methods_+3A_y1">y1</code>, <code id="masked-methods_+3A_y2">y2</code></td>
<td>
<p>see <code><a href="graphics.html#topic+clip">clip</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to make accessible the otherwise masked functions
<code><a href="stats.html#topic+start">start</a></code>, <code><a href="graphics.html#topic+clip">clip</a></code>, we generate
corresponding S4-methods.
</p>


<h3>Value</h3>

<p>see <code><a href="stats.html#topic+start">start</a></code>, <code><a href="graphics.html#topic+clip">clip</a></code>
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>

<hr>
<h2 id='MEstimate-class'>MEstimate-class.</h2><span id='topic+MEstimate-class'></span><span id='topic+Mroot'></span><span id='topic+Mroot+2CMEstimate-method'></span><span id='topic+show+2CMEstimate-method'></span>

<h3>Description</h3>

<p>Class of asymptotically linear estimates.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MEstimate", ...)</code>.
More frequently they are created via the generating function 
<code>locMEstimator</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
name of the estimator. </p>
</dd>
<dt><code>estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
estimate. </p>
</dd>
<dt><code>samplesize</code></dt><dd><p>Object of class <code>"numeric"</code>:
sample size. </p>
</dd>
<dt><code>asvar</code></dt><dd><p>Optional object of class <code>"matrix"</code>:
asymptotic variance. </p>
</dd>
<dt><code>asbias</code></dt><dd><p>Optional object of class <code>"numeric"</code>:
asymptotic bias. </p>
</dd>
<dt><code>pIC</code></dt><dd><p>Optional object of class <code>InfluenceCurve</code>:
influence curve. </p>
</dd>
<dt><code>nuis.idx</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>: 
indices of <code>estimate</code> belonging to the nuisance part. </p>
</dd>
<dt><code>Mroot</code></dt><dd><p>Object of class <code>"numeric"</code>: value of
the M equation at the estimate. </p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ALEstimate"</code>, directly.<br />
Class <code>"Estimate"</code>, by class <code>"ALEstimate"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>Mroot</dt><dd><p><code>signature(object = "MEstimate")</code>: 
accessor function for slot <code>Mroot</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "MEstimate")</code> </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ALEstimate-class">ALEstimate-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## prototype
new("MEstimate")
</code></pre>

<hr>
<h2 id='movToRef-methods'>Methods for Functions moving from and to reference parameter in Package &lsquo;ROptEst&rsquo; </h2><span id='topic+moveL2Fam2RefParam-methods'></span><span id='topic+moveICBackFromRefParam-methods'></span><span id='topic+moveICBackFromRefParam'></span><span id='topic+moveL2Fam2RefParam'></span><span id='topic+moveL2Fam2RefParam+2CL2ParamFamily-method'></span><span id='topic+moveL2Fam2RefParam+2CL2LocationFamily-method'></span><span id='topic+moveL2Fam2RefParam+2CL2ScaleFamily-method'></span><span id='topic+moveL2Fam2RefParam+2CL2LocationScaleFamily-method'></span><span id='topic+moveICBackFromRefParam+2CIC+2CL2ParamFamily-method'></span><span id='topic+moveICBackFromRefParam+2CIC+2CL2LocationFamily-method'></span><span id='topic+moveICBackFromRefParam+2CIC+2CL2ScaleFamily-method'></span><span id='topic+moveICBackFromRefParam+2CIC+2CL2LocationScaleFamily-method'></span><span id='topic+moveICBackFromRefParam+2CHampIC+2CL2ParamFamily-method'></span>

<h3>Description</h3>

<p>In <code>optIC</code> a gain in accuracy can be obtained when computing
the optimally-robust ICs at a reference parameter of the model (instead of an
arbtirary one). To this end, <code>moveL2Fam2RefParam</code> moved the model to
the reference parameter and <code>moveICBackFromRefParam</code> moves the obtained
optimal IC back to the original parameter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>moveL2Fam2RefParam(L2Fam, ...)
       moveICBackFromRefParam(IC, L2Fam,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movToRef-methods_+3A_l2fam">L2Fam</code></td>
<td>
<p>object of class <code>L2ParamFamily</code></p>
</td></tr>
<tr><td><code id="movToRef-methods_+3A_ic">IC</code></td>
<td>
<p>IC of class <code>HampIC</code></p>
</td></tr>
<tr><td><code id="movToRef-methods_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>moveL2Fam2RefParam</code> and <code>moveICBackFromRefParam</code> are used
internally in functions <code>robest</code> and <code>roptest</code> to compute the
optimally robust influence function according to the arguments given to them.</p>


<h3>Value</h3>

<table>
<tr><td><code>moveL2Fam2RefParam</code></td>
<td>
<p>the L2 Family transformed to reference parameter.</p>
</td></tr>
<tr><td><code>moveICBackFromRefParam</code></td>
<td>
<p>the backtransformed IC.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>moveL2Fam2RefParam</dt><dd><p><code>signature(L2Fam = "L2ParamFamily")</code>:
returns <code>L2Fam</code> unchanged. </p>
</dd>
<dt>moveL2Fam2RefParam</dt><dd><p><code>signature(L2Fam = "L2LocationFamily")</code>:
moves <code>L2Fam</code> to location <code>0</code>. </p>
</dd>
<dt>moveL2Fam2RefParam</dt><dd><p><code>signature(L2Fam = "L2ScaleFamily")</code>:
moves <code>L2Fam</code> to location <code>0</code> and scale <code>1</code>. </p>
</dd>
<dt>moveL2Fam2RefParam</dt><dd><p><code>signature(L2Fam = "L2LocationScaleFamily")</code>:
moves <code>L2Fam</code> to location <code>0</code> and scale <code>1</code>. </p>
</dd>
<dt>moveL2Fam2RefParam</dt><dd><p><code>signature(L2Fam = "L2LocationUnknownScaleFamily")</code>:
moves <code>L2Fam</code> to location <code>0</code> and scale <code>1</code>. </p>
</dd>
<dt>moveL2Fam2RefParam</dt><dd><p><code>signature(L2Fam = "L2ScaleUnknownLocationFamily")</code>:
moves <code>L2Fam</code> to location <code>0</code> and scale <code>1</code>. </p>
</dd>
<dt>moveICBackFromRefParam</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2ParamFamily")</code>:
returns <code>IC</code> unchanged. </p>
</dd>
<dt>moveICBackFromRefParam</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2LocationFamily")</code>:
moves IC in <code>IC</code> back to original location in <code>L2Fam</code>. </p>
</dd>
<dt>moveICBackFromRefParam</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2ScaleFamily")</code>:
moves IC in <code>IC</code> back to original location and scale in <code>L2Fam</code>,
rescaling risk where necessary. </p>
</dd>
<dt>moveICBackFromRefParam</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2LocationScaleFamily")</code>:
moves IC in <code>IC</code> back to original location and scale in <code>L2Fam</code>,
rescaling risk where necessary. </p>
</dd>
<dt>moveICBackFromRefParam</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2LocationUnknownScaleFamily")</code>:
moves IC in <code>IC</code> back to original location and scale in <code>L2Fam</code>,
rescaling risk where necessary. </p>
</dd>
<dt>moveICBackFromRefParam</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2ScaleUnknownLocationFamily")</code>:
moves IC in <code>IC</code> back to original location and scale in <code>L2Fam</code>,
rescaling risk where necessary. </p>
</dd>
<dt>moveICBackFromRefParam</dt><dd><p><code>signature(IC = "HampIC", L2Fam = "L2ParamFamily")</code>:
moves IC in <code>IC</code> back to original location and scale in <code>L2Fam</code>
(and in addition changes Lagrange multipliers accordingly),
rescaling risk where necessary. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>

<hr>
<h2 id='Neighborhood-class'>Neighborhood</h2><span id='topic+Neighborhood-class'></span><span id='topic+radius'></span><span id='topic+radius+2CNeighborhood-method'></span><span id='topic+radius+3C-'></span><span id='topic+radius+3C-+2CNeighborhood-method'></span><span id='topic+show+2CNeighborhood-method'></span><span id='topic+type+2CNeighborhood-method'></span>

<h3>Description</h3>

<p>Class of neighborhoods of families of probability measures.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>: 
type of the neighborhood. </p>
</dd>
<dt><code>radius</code></dt><dd><p>Object of class <code>"numeric"</code>:
neighborhood radius. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>type</dt><dd><p><code>signature(object = "Neighborhood")</code>: 
accessor function for slot <code>type</code>. </p>
</dd>
<dt>radius</dt><dd><p><code>signature(object = "Neighborhood")</code>: 
accessor function for slot <code>radius</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Neighborhood")</code></p>
</dd>
<dt>radius&lt;-</dt><dd><p><code>signature(object = "Neighborhood")</code>:
replacement function for slot <code>radius</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+ProbFamily-class">ProbFamily-class</a></code></p>

<hr>
<h2 id='normtype-methods'>Methods for Function normtype  in Package &lsquo;RobAStBase&rsquo;</h2><span id='topic+normtype+2CinterpolRisk-method'></span><span id='topic+normtype'></span>

<h3>Description</h3>

<p>normtype-methods</p>


<h3>Methods</h3>


<dl>
<dt>normtype</dt><dd><p><code>signature(object = "interpolrisk")</code>:
returns the slot <code>normtype</code> of an object of class <code>"interpolrisk"</code>. </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>myrisk &lt;- MBRRisk(samplesize=100)
normtype(myrisk)
</code></pre>

<hr>
<h2 id='oneStepEstimator'>Function for the computation of one-step estimates</h2><span id='topic+oneStepEstimator'></span>

<h3>Description</h3>

<p>Function for the computation of one-step estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneStepEstimator(x, IC, start = NULL,
      useLast = getRobAStBaseOption("kStepUseLast"),
      withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
      IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
      na.rm = TRUE, startArgList = NULL, withMakeIC = FALSE, ...,
      E.argList = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneStepEstimator_+3A_x">x</code></td>
<td>
<p> sample </p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"InfluenceCurve"</code> </p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_start">start</code></td>
<td>
<p> initial estimate (for full parameter,i.e. in dimension <code class="reqn">k</code> respective
joint length of main and nuisance part of the parameter):
either a numerical value, or an object of class <code>"Estimate"</code> or
a function producing either a numerical value, or an object of class <code>"Estimate"</code>
when evaluated at <code>x,...</code>; if missing or <code>NULL</code>, we use slot <code>startPar</code>
of the L2family <code>L2Fam</code> from within <code>IC</code>.</p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_uselast">useLast</code></td>
<td>
<p> which parameter estimate (initial estimate or
one-step estimate) shall be used to fill the slots <code>pIC</code>,
<code>asvar</code> and <code>asbias</code> of the return value. </p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_withupdateinker">withUpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>, shall
the parameter be updated on <code class="reqn">{\rm ker}(D)</code>?</p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_ic.updateinker">IC.UpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>,
the IC to be used for this; if <code>NULL</code> the result of <code>getboundedIC(L2Fam,D)</code> is taken;
this IC will then be projected onto <code class="reqn">{\rm ker}(D)</code>.</p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_startarglist">startArgList</code></td>
<td>
<p>a list of arguments to be given to argument <code>start</code> if the latter
is a function; this list by default already starts with two unnamed items,
the sample <code>x</code>, and the model <code>eval(CallL2Fam(IC))</code>; in case <code>IC</code>
is not of class <code>IC</code>, the model argument <code>L2Fam</code> will be set
to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_...">...</code></td>
<td>
<p> additional arguments </p>
</td></tr>
<tr><td><code id="oneStepEstimator_+3A_e.arglist">E.argList</code></td>
<td>
<p><code>NULL</code> (default) or a named list of arguments to be passed
to calls to <code>E</code> from <code>kStepEstimator</code>; potential clashes with
arguments of the same name in <code>...</code> are resolved by inserting
the items of argument list <code>E.argList</code> as named items  to the
argument lists, so in case of collisions the item of <code>E.argList</code> overwrites the
existing one from <code>...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an initial estimation <code>start</code>, a sample <code>x</code> 
and an influence curve <code>IC</code> the corresponding one-step
estimator is computed.
</p>
<p>In case <code>IC</code> is an object of class <code>"IC"</code>
the slots <code>asvar</code> and <code>asbias</code> of the return 
value are filled (based on the initial estimate).
</p>
<p>The default value of argument <code>useLast</code> is set by the
global option <code>kStepUseLast</code> which by default is set to 
<code>FALSE</code>. In case of general models <code>useLast</code> 
remains unchanged during the computations. However, if 
slot <code>CallL2Fam</code> of <code>IC</code> generates an object of 
class <code>"L2GroupParamFamily"</code> the value of <code>useLast</code> 
is changed to <code>TRUE</code>.
Explicitly setting <code>useLast</code> to <code>TRUE</code> should
be done with care as in this situation the influence curve
is re-computed using the value of the one-step estimate
which may take quite a long time depending on the model.
</p>
<p>If <code>useLast</code> is set to <code>TRUE</code> and slot <code>modifyIC</code> 
of <code>IC</code> is filled with some function (which can be 
used to re-compute the IC for a different parameter), the 
computation of <code>asvar</code>, <code>asbias</code> and <code>IC</code> is 
based on the one-step estimate.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InfluenceCurve-class">InfluenceCurve-class</a></code>, <code><a href="#topic+kStepEstimate-class">kStepEstimate-class</a></code> </p>

<hr>
<h2 id='optIC'>Generic function for the computation of optimally robust ICs</h2><span id='topic+optIC'></span><span id='topic+optIC-methods'></span><span id='topic+optIC+2CL2ParamFamily+2CasCov-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of optimally robust ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optIC(model, risk, ...)

## S4 method for signature 'L2ParamFamily,asCov'
optIC(model, risk, withMakeIC = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optIC_+3A_model">model</code></td>
<td>
<p> probability model. </p>
</td></tr>
<tr><td><code id="optIC_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="optIC_+3A_...">...</code></td>
<td>
<p> additional parameters (here used for <code>makeIC</code>,
resp. for <code>E</code>). </p>
</td></tr>
<tr><td><code id="optIC_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The classical optimal IC which ist optimal in sense of the Cramer-Rao bound
is computed.
</p>


<h3>Value</h3>

<p>Some optimally robust IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>model = &quot;L2ParamFamily&quot;, risk = &quot;asCov&quot;</dt><dd><p> computes
classical optimal influence curve for L2 differentiable 
parametric families.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InfluenceCurve-class">InfluenceCurve-class</a></code>, <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- BinomFamily(size = 25, prob = 0.25) 

## classical optimal IC
IC0 &lt;- optIC(model = B, risk = asCov())
plot(IC0) # plot IC
checkIC(IC0, B)
</code></pre>

<hr>
<h2 id='OptionalInfluenceCurve-class'>Some helper Classes in package 'RobAStBase'</h2><span id='topic+OptionalInfluenceCurve-class'></span><span id='topic+OptionalInfluenceCurveOrCall-class'></span><span id='topic+OptionalpICList-class'></span><span id='topic+StartClass-class'></span><span id='topic+pICList-class'></span><span id='topic+show+2CpICList-method'></span><span id='topic+show+2COptionalpICList-method'></span>

<h3>Description</h3>

<p>Some helper Classes in package 'RobAStBase':
Classes <code>OptionalInfluenceCurve</code>, <code>OptionalpICList</code>,
<code>StartClass</code>, <code>pICList</code></p>


<h3>Class Unions</h3>

<p><code>OptionalInfluenceCurve</code> is a class union of classes
<code>InfluenceCurve</code> and <code>NULL</code>;
<code>OptionalInfluenceCurveOrCall</code> is a class union of classes
<code>InfluenceCurve</code>, <code>call</code>, and <code>NULL</code> &mdash; it is the slot
class of slot <code>pIC</code> in <code>ALEstimate</code>;
<code>OptionalpICList</code> is a class union of classes
<code>pICList</code> and <code>NULL</code> &mdash; it is the slot
class of slot <code>pICList</code> in <code>kStepEstimate</code>;
<code>StartClass</code> is a class union of classes
<code>function</code>, <code>numeric</code> and <code>Estimate</code> &mdash; it is the slot
class of slot <code>start</code> in <code>kStepEstimate</code>.
</p>


<h3>List Classes</h3>

<p><code>pICList</code> is a descendant of class <code>list</code> which requires
its members &mdash;if any&mdash; to be of class <code>pIC</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "OptionalpICList")</code>:
particular show-method. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "pICList")</code>:
particular show-method. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>.
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InfluenceCurve">InfluenceCurve</a></code>, <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code></p>

<hr>
<h2 id='outlyingPlotIC'>Function outlyingPlotIC in Package &lsquo;RobAStBase&rsquo; </h2><span id='topic+outlyingPlotIC'></span>

<h3>Description</h3>

<p>outlyingPlotIC produces an outlyingness plot based on distances applied
to ICs</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlyingPlotIC(data,IC.x, IC.y = IC.x, dist.x = NormType(), dist.y, 
 cutoff.x = cutoff.sememp(0.95), cutoff.y = cutoff.chisq(0.95),  ...,
 cutoff.quantile.x = 0.95, cutoff.quantile.y = cutoff.quantile.x,
 id.n, cex.pts = 1, lab.pts, jitter.pts = 0, alpha.trsp = NA, adj, cex.idn,
 col.idn,  lty.cutoff,  lwd.cutoff,  col.cutoff, text.abline = TRUE,
 text.abline.x = NULL, text.abline.y = NULL, cex.abline = par("cex"),
 col.abline = col.cutoff, font.abline = par("font"), adj.abline = c(0,0),
 text.abline.x.x = NULL, text.abline.x.y = NULL, text.abline.y.x = NULL,
 text.abline.y.y = NULL, text.abline.x.fmt.cx = "%7.2f",
 text.abline.x.fmt.qx = "%4.2f%%", text.abline.y.fmt.cy = "%7.2f",
 text.abline.y.fmt.qy = "%4.2f%%", robCov.x = TRUE, robCov.y = TRUE,
 tf.x = NULL,tf.y = NULL, jitter.fac=10, jitter.tol=.Machine$double.eps,
 doplot = TRUE,
 main = gettext("Outlyingness \n by means of a distance-distance plot")
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlyingPlotIC_+3A_data">data</code></td>
<td>
<p>data coercable to <code>matrix</code>; the data  at which to produce the <code>ddPlot</code>.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_ic.x">IC.x</code></td>
<td>
<p>object of class   <code>IC</code> the influence curve to produce
the  distances for the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_ic.y">IC.y</code></td>
<td>
<p>object of class   <code>IC</code> the influence curve to produce
the  distances for the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot.default</code>, <code>text</code>, and <code>abline</code></p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_dist.x">dist.x</code></td>
<td>
<p>object of class <code>NormType</code>; the distance for the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_dist.y">dist.y</code></td>
<td>
<p>object of class <code>NormType</code>; the distance for the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_cutoff.x">cutoff.x</code></td>
<td>
<p>object of class <code>cutoff</code>; the cutoff information for the <code>x</code> axis
(the vertical line discriminating 'good' and 'bad' points).</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_cutoff.y">cutoff.y</code></td>
<td>
<p>object of class <code>cutoff</code>; the cutoff information for the <code>y</code> axis
(the horizontal line discriminating 'good' and 'bad' points).</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_cutoff.quantile.x">cutoff.quantile.x</code></td>
<td>
<p>numeric; the cutoff quantile for the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_cutoff.quantile.y">cutoff.quantile.y</code></td>
<td>
<p>numeric; the cutoff quantile for the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_id.n">id.n</code></td>
<td>
<p>a set of indices (or a corresponding logical vector); to select a subset
of the data in argument <code>data</code>.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_cex.pts">cex.pts</code></td>
<td>
<p>the corresponding <code>cex</code> argument for plotted points.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_lab.pts">lab.pts</code></td>
<td>
<p>a vector of labels for the (unsubsetted) <code>data</code>.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_jitter.pts">jitter.pts</code></td>
<td>
<p>the corresponding <code>jitter</code> argument for plotted points;
may be a vector of length 2 &ndash; for separate factors for x- and y-coordinate.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.lbl</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the data-symbols to be plotted.
Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_adj">adj</code></td>
<td>
<p>the corresponding argument for <code><a href="graphics.html#topic+text">text</a></code> for
labelling the outliers.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_cex.idn">cex.idn</code></td>
<td>
<p>the corresponding <code>cex</code> argument for
<code><a href="graphics.html#topic+text">text</a></code> for labelling the outliers.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_col.idn">col.idn</code></td>
<td>
<p>the corresponding <code>col</code> argument for
<code><a href="graphics.html#topic+text">text</a></code> for labelling the outliers.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_lty.cutoff">lty.cutoff</code></td>
<td>
<p>the corresponding <code>lty</code> argument for
<code><a href="graphics.html#topic+abline">abline</a></code> for drawing the cutoff lines.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_lwd.cutoff">lwd.cutoff</code></td>
<td>
<p>the corresponding <code>lwd</code> argument for
<code><a href="graphics.html#topic+abline">abline</a></code> for drawing the cutoff lines.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_col.cutoff">col.cutoff</code></td>
<td>
<p>the corresponding <code>col</code> argument for
<code><a href="graphics.html#topic+abline">abline</a></code> for drawing the cutoff lines.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline">text.abline</code></td>
<td>
<p>vector of logicals (cast to length 2): shall text be added
to cutoff lines.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.x">text.abline.x</code></td>
<td>
<p>text to be added to cutoff lines in x direction; if <code>NULL</code>
(default) we use &ldquo;[pp] %-cutoff = [ff]&rdquo; where [pp] is the percentage up to 2 digits
and [ff] is the cutoff value up to 2 digits.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.y">text.abline.y</code></td>
<td>
<p>text to be added to cutoff lines in y direction; if <code>NULL</code>
(default) we use &ldquo;[pp] %-cutoff = [ff]&rdquo; where [pp] is the percentage up to 2 digits
and [ff] is the cutoff value up to 2 digits.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_cex.abline">cex.abline</code></td>
<td>
<p>vector of numerics (cast to length 2): cex-value for added cutoff text.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_col.abline">col.abline</code></td>
<td>
<p>vector of length 2: color for added cutoff text.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_font.abline">font.abline</code></td>
<td>
<p>vector of length 2: font for added cutoff text.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_adj.abline">adj.abline</code></td>
<td>
<p>cast to 2 x 2 matrix (by recycling rules): adjustment values for added cutoff text.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.x.y">text.abline.x.y</code></td>
<td>
<p>y-coordinate of text to be added to cutoff lines in x direction;
if <code>NULL</code> (default) set to mid of <code>mean(par("usr")[c(3,4)])</code>.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.y.x">text.abline.y.x</code></td>
<td>
<p>x-coordinate of text to be added to cutoff lines in y direction;
if <code>NULL</code> (default) set to mid of <code>mean(par("usr")[c(1,2)])</code>.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.x.x">text.abline.x.x</code></td>
<td>
<p>x-coordinate of text to be added to cutoff lines in x direction;
if <code>NULL</code> (default) set to 1.05 times the cutoff value.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.y.y">text.abline.y.y</code></td>
<td>
<p>y-coordinate of text to be added to cutoff lines in y direction;
if <code>NULL</code> (default) set to 1.05 times the cutoff value.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.x.fmt.cx">text.abline.x.fmt.cx</code></td>
<td>
<p>format string (see <code><a href="base.html#topic+sprintf">gettextf</a></code>)
to format the cutoff value in label in x direction.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.x.fmt.qx">text.abline.x.fmt.qx</code></td>
<td>
<p>format string to format cutoff probability in label in x direction.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.y.fmt.cy">text.abline.y.fmt.cy</code></td>
<td>
<p>format string to format the cutoff value in label in y direction.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_text.abline.y.fmt.qy">text.abline.y.fmt.qy</code></td>
<td>
<p>format string to format cutoff probability in label in y direction.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_robcov.x">robCov.x</code></td>
<td>
<p>shall x-distances be based on MCD, i.e.,
robust covariances (TRUE) or on classical covariance be used?</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_robcov.y">robCov.y</code></td>
<td>
<p>shall y-distances be based on MCD, i.e.,
robust covariances (TRUE) or on classical covariance be used?</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_tf.x">tf.x</code></td>
<td>
<p>transformation for x axis: a function returning the
transformed x-coordinates when applied to the data;
if <code>tf.x</code> is <code>NULL</code> (default), internally this
is set to the evaluation function of the <code>IC.x</code>.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_tf.y">tf.y</code></td>
<td>
<p>transformation for y axis: a function returning the
transformed y-coordinates when applied to the data;
if <code>tf.x</code> is <code>NULL</code> (default), internally this
is set to the evaluation function of <code>IC.y</code>.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_jitter.fac">jitter.fac</code></td>
<td>
<p>factor for jittering, see <code><a href="base.html#topic+jitter">jitter</a></code>;</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_jitter.tol">jitter.tol</code></td>
<td>
<p>threshold for jittering: if distance between points is smaller
than <code>jitter.tol</code>, points are considered replicates.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_doplot">doplot</code></td>
<td>
<p>logical; shall a plot be produced? if <code>FALSE</code> only the return values are produced.</p>
</td></tr>
<tr><td><code id="outlyingPlotIC_+3A_main">main</code></td>
<td>
<p>the main title.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calls a corresponding <code><a href="#topic+ddPlot">ddPlot</a></code> method to produce the plot.
</p>


<h3>Value</h3>

<p>If argument <code>doplot</code> is <code>FALSE</code>:
A list (returned as <code>invisible()</code>) with items
</p>
<table>
<tr><td><code>id.x</code></td>
<td>
<p>the indices of (possibly transformed) data (within subset <code>id.n</code>) beyond the <code>x</code>-cutoff</p>
</td></tr>
<tr><td><code>id.y</code></td>
<td>
<p>the indices of (possibly transformed) data (within subset <code>id.n</code>) beyond the <code>y</code>-cutoff</p>
</td></tr>
<tr><td><code>id.xy</code></td>
<td>
<p>the indices of (possibly transformed) data (within subset <code>id.n</code>) beyond the <code>x</code>-cutoff and the <code>y</code>-cutoff</p>
</td></tr>
<tr><td><code>qtx</code></td>
<td>
<p>the quantiles of the distances of the (possibly transformed) data in <code>x</code> direction</p>
</td></tr>
<tr><td><code>qty</code></td>
<td>
<p>the quantiles of the distances of the (possibly transformed) data in <code>y</code> direction</p>
</td></tr>
<tr><td><code>cutoff.x.v</code></td>
<td>
<p>the cutoff value in <code>x</code> direction</p>
</td></tr>
<tr><td><code>cutoff.y.v</code></td>
<td>
<p>the cutoff value in <code>y</code> direction</p>
</td></tr>
</table>
<p>If argument <code>doplot</code> is <code>TRUE</code>:
An S3 object of class <code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.a list (returned as <code>invisible()</code>) with items;
one item is <code>retV</code> which is the return value in case <code>doplot</code> is <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>If you want to use the return value of <code>cutoff.quant()</code> for arguments
<code>cutoff.x</code> or <code>cutoff.y</code>, remember to set the arguments <code>tf.x</code>
resp. <code>tf.y</code> to the identity, i.e., <code>function(x)x</code>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ROptEst)){
## generates normal location and scale family with mean = -2 and sd = 3
N0 &lt;- NormLocationScaleFamily()
N0.IC0 &lt;- optIC(model = N0, risk = asCov())
N0.Rob1 &lt;- InfRobModel(center = N0, neighbor = ContNeighborhood(radius = 0.5))
N0.IC1 &lt;- optIC(model = N0.Rob1, risk = asMSE())
set.seed(123)
xn &lt;- c(rnorm(100),rcauchy(20)+20)
outlyingPlotIC(xn, IC.x=N0.IC0)
outlyingPlotIC(xn, IC.x=N0.IC1)

## example for usage with cutoff.quant()
classIC &lt;- optIC(NormLocationScaleFamily(mean = 3.3, sd = 0.67),
                  risk = asCov())
outlyingPlotIC(data = chem[-17], classIC, cex.pts = 3, jitter.fac = 1,
                cutoff.x = cutoff.quant(), tf.x =function(x)(x))
}
</code></pre>

<hr>
<h2 id='plot-methods'> Methods for Function plot in Package &lsquo;RobAStBase&rsquo; </h2><span id='topic+plot'></span><span id='topic+plot-methods'></span><span id='topic+plot+2CIC+2Cmissing-method'></span><span id='topic+plot+2CIC+2Cnumeric-method'></span>

<h3>Description</h3>

<p>plot-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(x, y, ...)
## S4 method for signature 'IC,missing'
plot(x, ..., withSweave = getdistrOption("withSweave"),
             main = FALSE, inner = TRUE, sub = FALSE,
             col.inner = par("col.main"), cex.inner = 0.8,
             bmar = par("mar")[1], tmar = par("mar")[3],
             with.automatic.grid = TRUE,
             with.legend = FALSE, legend = NULL, legend.bg = "white",
             legend.location = "bottomright", legend.cex = 0.8,
             withMBR = FALSE, MBRB = NA, MBR.fac = 2, col.MBR = par("col"),
             lty.MBR = "dashed", lwd.MBR = 0.8,
             x.vec = NULL, scaleX = FALSE, scaleX.fct, scaleX.inv,
             scaleY = FALSE, scaleY.fct = pnorm, scaleY.inv=qnorm,
             scaleN = 9, x.ticks = NULL, y.ticks = NULL,
             mfColRow = TRUE, to.draw.arg = NULL,
             withSubst = TRUE)
## S4 method for signature 'IC,numeric'
plot(x, y, ...,
                 cex.pts = 1, cex.pts.fun = NULL, col.pts = par("col"),
                 pch.pts = 19,
                 cex.npts = 1, cex.npts.fun = NULL, col.npts = par("col"),
                 pch.npts = 20,
                 jitter.fac = 1, with.lab = FALSE, cex.lbs = 1, adj.lbs = c(0,0),
                 col.lbs = col.pts, lab.pts = NULL, lab.font = NULL,
                 alpha.trsp = NA, which.lbs = NULL,
                 which.Order = NULL, which.nonlbs = NULL, attr.pre = FALSE,
                 return.Order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>"IC"</code>: IC to be plotted </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p> missing or numeric (a dataset, e.g.)</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_withsweave">withSweave</code></td>
<td>
<p>logical: if <code>TRUE</code> (for working with <code>Sweave</code>)
no extra device is opened</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_main">main</code></td>
<td>
<p>logical: is a main title to be used? or <br />
just as argument <code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_inner">inner</code></td>
<td>
<p>logical: do panels have their own titles? or <br />
character vector of inner titles/ cast to length 'number of plotted
dimensions';
if argument <code>to.draw.arg</code> is used, this refers to 
a vector of length <code>length(to.draw.arg)</code>, the 
actually plotted dimensions. For further information, see also 
description of argument <code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_sub">sub</code></td>
<td>
<p>logical: is a sub-title to be used? or <br />
just as argument <code>sub</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_tmar">tmar</code></td>
<td>
<p>top margin &ndash; useful for non-standard main title sizes</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_bmar">bmar</code></td>
<td>
<p>bottom margin &ndash; useful for non-standard sub title sizes</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_cex.inner">cex.inner</code></td>
<td>
<p>magnification to be used for inner titles relative
to the current setting of <code>cex</code>; as in
<code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_col.inner">col.inner</code></td>
<td>
<p>character or integer code; color for the inner title</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_with.automatic.grid">with.automatic.grid</code></td>
<td>
<p>logical; should a grid be plotted alongside
with the ticks of the axes, automatically? If <code>TRUE</code> a respective
call to <code>grid</code> in argument <code>panel.first</code> is ignored. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_with.legend">with.legend</code></td>
<td>
<p>logical; shall a legend be plotted?</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_legend">legend</code></td>
<td>
<p>either <code>NULL</code> or a list of length (number of plotted panels)
of items which can be used as argument <code>legend</code> in
command <code>legend</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_legend.location">legend.location</code></td>
<td>
<p>a valid argument <code>x</code> for <code><a href="graphics.html#topic+legend">legend</a></code> &mdash;
the place where to put the legend on the last issued
plot &mdash; or a list of length (number of plotted panels)
of such arguments, one for each plotted panel.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_legend.bg">legend.bg</code></td>
<td>
<p>background color for the legend</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_legend.cex">legend.cex</code></td>
<td>
<p>magnification factor for the legend</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_withmbr">withMBR</code></td>
<td>
<p>logical; shall horizontal lines with min and max of MBRE be plotted for
comparison?</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_mbrb">MBRB</code></td>
<td>
<p>matrix (or <code>NA</code>); coerced by usual recycling rules to a
matrix with as many rows as plotted panels and with first column
the lower bounds and the second column the upper bounds for the
respective coordinates (ideally given by the MBR-IC).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_mbr.fac">MBR.fac</code></td>
<td>
<p>positive factor; scales the bounds given by argument <code>MBRB</code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_col.mbr">col.MBR</code></td>
<td>
<p>color for the MBR lines; as usual <code>col</code>-argument;</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_lty.mbr">lty.MBR</code></td>
<td>
<p>line type for the MBR lines; as usual <code>lty</code>-argument;</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_lwd.mbr">lwd.MBR</code></td>
<td>
<p>line width for the MBR lines; as usual <code>lwd</code>-argument;</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_x.vec">x.vec</code></td>
<td>
<p>a numeric vector of grid points to evaluate the influence curve;
by default, <code>x.vec</code> is <code>NULL</code>; then the grid is
produced automatically according to the distribution of the IC.
<code>x.vec</code> can be useful for usage with a rescaling of the
x-axis to avoid that the evaluation points be selected too
unevenly (i.e. on an equally spaced grid in the original scale,
but then, after rescaling non-equally).
The grid has to be specified in original scale; i.e.; when used
with rescaling, it should be chosen non-equally spaced. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_scalex">scaleX</code></td>
<td>
<p>logical; shall X-axis be rescaled (by default according to the cdf of
the underlying distribution)?</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_scaley">scaleY</code></td>
<td>
<p>logical; shall Y-axis be rescaled (by default according to a probit scale)?</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_scalex.fct">scaleX.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the domain of the IC
to [0,1]; if <code>scaleX</code> is <code>TRUE</code> and <code>scaleX.fct</code> is
missing, the cdf of the underlying observation distribution;
can also be a list of functions with one list element for each
of the panels to be plot.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_scalex.inv">scaleX.inv</code></td>
<td>
<p>the inverse function to <code>scale.fct</code>, i.e., an isotone,
vectorized function mapping [0,1] to the domain of the IC
such that for any <code>x</code> in the domain,
<code>scaleX.inv(scaleX.fct(x))==x</code>; if <code>scaleX</code> is <code>TRUE</code>
and <code>scaleX.inv</code> is
missing, the quantile function of the underlying observation distribution;
can also be a list of functions with one list element for each
of the panels to be plot.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_scaley.fct">scaleY.fct</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate the
range of the respective coordinate of the IC
to [0,1]; defaulting to the cdf of <code class="reqn">{\cal N}(0,1)</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_scaley.inv">scaleY.inv</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate
the range [0,1] into the range of the respective coordinate of the IC;
defaulting to the quantile function of  <code class="reqn">{\cal N}(0,1)</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_scalen">scaleN</code></td>
<td>
<p>integer; defaults to 9; on rescaled axes, number of x
and y ticks if drawn automatically;</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_x.ticks">x.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given x-ticks (on original scale);</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y.ticks">y.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given y-ticks (on original scale);
can be a list with one (numeric or NULL) item per panel</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_mfcolrow">mfColRow</code></td>
<td>
<p>shall default partition in panels be used &mdash; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_to.draw.arg">to.draw.arg</code></td>
<td>
<p>Either <code>NULL</code> (default; 
everything is plotted) or a vector of either integers 
(the indices of the subplots to be drawn) or characters 
&mdash; the names of the subplots to be drawn: these
names are to be chosen either among the row names of 
the trafo matrix 
<code>rownames(trafo(eval(x@CallL2Fam)@param))</code> 
or if the last expression is <code>NULL</code> a 
vector <code>"dim&lt;dimnr&gt;"</code>, <code>dimnr</code> running through 
the number of rows of the trafo matrix.
</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_withsubst">withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and lables is used; otherwise no substitution is used. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_cex.pts">cex.pts</code></td>
<td>
<p>size of the points of the second argument plotted, can be a vector;
if argument <code>attr.pre</code> is <code>TRUE</code>, it is recycled to the length
of all observations and determines the sizes of all plotted symbols,
i.e., the selection is done within this argument; in this case argument
<code>col.npts</code> is ignored. If <code>attr.pre</code> is <code>FALSE</code>,
<code>cex.pts</code> is recycled to the number of the observations selected
for labelling and refers to the index ordering after the
selection. Then argument <code>cex.npts</code> deteremines the sizes
of the shown but non-labelled observations as given in argument
<code>which.nonlbs</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_cex.pts.fun">cex.pts.fun</code></td>
<td>
<p>rescaling function for the size of the points to be plotted;
either <code>NULL</code> (default), then <code>log(1+abs(x))</code> is used for each of
the rescalings, or a function which is then used for each of the
rescalings, or a list of functions; if it is a function or a list of
functions, if necessary it is recylced to length <code>dim</code>
where <code>dim</code> is the number of dimensions of the pICs to be plotted.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_col.pts">col.pts</code></td>
<td>
<p>color of the points of the second argument plotted, can
be a vector as in <code>cex.pts</code> (with <code>col.npts</code> as counterpart).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_pch.pts">pch.pts</code></td>
<td>
<p>symbol of the points of the second argument plotted, can
be a vector as in <code>cex.pts</code> (with <code>pch.npts</code> as counterpart).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_col.npts">col.npts</code></td>
<td>
<p>color of the non-labelled points of the <code>data</code> argument
plotted; (may be a vector).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_pch.npts">pch.npts</code></td>
<td>
<p>symbol of the non-labelled points of the <code>data</code> argument
plotted (may be a vector).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_cex.npts">cex.npts</code></td>
<td>
<p>size of the non-labelled points of the <code>data</code> argument
plotted (may be a vector).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_cex.npts.fun">cex.npts.fun</code></td>
<td>
<p>rescaling function for the size of the non-labelled points
to be plotted; either <code>NULL</code> (default), then <code>log(1+abs(x))</code>
is used for each of the rescalings, or a function which is then used
for each of the rescalings, or a list of functions; if it is a
function or a list of functions, if necessary it is recylced
to length <code>dim</code> where <code>dim</code> is the number of dimensions of
the pICs to be plotted.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_with.lab">with.lab</code></td>
<td>
<p>logical; shall labels be plotted to the observations?</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_cex.lbs">cex.lbs</code></td>
<td>
<p>size of the labels; can be vectorized to a matrix
of dim nlbs x npnl where npnl is the number of plotted
panels and nlbs the number of plotted labels; if it is
a vector, it is recylced in order label then panel.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_col.lbs">col.lbs</code></td>
<td>
<p>color of the labels; can be vectorized as <code>col.pts</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_adj.lbs">adj.lbs</code></td>
<td>
<p>adjustment of the labels; can be vectorized to a 2 x npnl
matrix, npnl the number of plotted panels;
if it is a vector, it is recycled in order (x,y)-coords
then panel.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_lab.pts">lab.pts</code></td>
<td>
<p>character or NULL; labels to be plotted to the observations; if <code>NULL</code>
observation indices;</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_lab.font">lab.font</code></td>
<td>
<p>font to be used for labels (of the observations).</p>
</td></tr>       
<tr><td><code id="plot-methods_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.lbl</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the data-symbols to be plotted.
Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_jitter.fac">jitter.fac</code></td>
<td>
<p>jittering factor used in case of a <code>DiscreteDistribution</code>
for plotting points of the second argument in a jittered fashion.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_attr.pre">attr.pre</code></td>
<td>
<p>logical; do graphical attributes for plotted data refer
to indices prior (<code>TRUE</code>) or posterior to selection
via arguments <code>which.lbs</code>, <code>which.Order</code>, <code>which.nonlbs</code>
(<code>FALSE</code>)? </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_which.lbs">which.lbs</code></td>
<td>
<p>either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then no observation is excluded</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_which.order">which.Order</code></td>
<td>
<p>we order the observations (descending) according to the norm given by
<code>normtype(object)</code>; then <code>which.Order</code>
either is an integer vector with the indices of the <em>ordered</em>
observations (remaining after a possible reduction by argument <code>which.lbs</code>)
to be plotted (with labels) into graph or <code>NULL</code> &mdash; then no (further)
observation is excluded.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_which.nonlbs">which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then all non-labelled
observations are plotted</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_return.order">return.Order</code></td>
<td>
<p>logical; if <code>TRUE</code>, an order vector
is returned; more specifically, the order of the (remaining) observations
given by their original index is returned (remaining means: after a possible
reduction by argument <code>which.lbs</code>, and ordering is according to the norm given by
<code>normtype(object)</code>);
otherwise we return <code>invisible()</code> as usual.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>further parameters for <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any parameters of <code>plot.default</code> may be passed on to this particular
<code>plot</code> method.
</p>
<p>We start describing the <code>IC,missing</code>-method:
For main-, inner, and subtitles given as arguments <code>main</code>,
<code>inner</code>, and <code>sub</code>, top and bottom margins are enlarged to 5 resp.
6 by default but may also be specified by <code>tmar</code> / <code>bmar</code> arguments.
If <code>main</code> / <code>inner</code> / <code>sub</code> are
logical then if the respective argument is <code>FALSE</code> nothing is done/plotted,
but if it is <code>TRUE</code>, we use a default main title taking up the calling
arguments in case of <code>main</code>, default inner titles taking up the
class and (named) parameter slots of arguments in case of <code>inner</code>,
and a &quot;generated on &lt;data&gt;&quot;-tag in case of <code>sub</code>.
Of course, if <code>main</code> / <code>inner</code> / <code>sub</code> are <code>character</code>, this
is used for the title; in case of <code>inner</code> it is then checked whether it
has correct length. If argument <code>withSubst</code> is <code>TRUE</code>, in all title 
and axis lable arguments, the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt><dd><p>class of argument <code>object</code></p>
</dd>
<dt><code>"%A"</code></dt><dd><p>deparsed argument  <code>object</code></p>
</dd>
<dt><code>"%D"</code></dt><dd><p>time/date-string when the plot was generated</p>
</dd>
</dl>

<p>If argument <code>...</code> contains argument <code>ylim</code>, this may either be
as in <code>plot.default</code> (i.e. a vector of length 2) or a vector of 
length 2*(number of plotted dimensions + 2), 
where the first two elements are the values for <code>ylim</code> 
in panel &quot;d&quot;,  the first two are for <code>ylim</code> resp. <code>xlim</code> 
for panels &quot;p&quot; and &quot;q&quot;, and the last 2*(number of plotted dimensions)
are the values for <code>ylim</code> for the plotted dimensions of the L2derivative, 
one pair for each dimension.
</p>
<p>The <code>IC,numeric</code>-method calls the <code>IC,missing</code>-method but in
addition plots the values of a dataset into the IC.
</p>
<p>In addition, argument <code>...</code> may contain arguments <code>panel.first</code>,
<code>panel.last</code>, i.e., hook expressions to be evaluated at the very beginning
and at the very end of each panel (within the then valid coordinates).
To be able to use these hooks for each panel individually, they may also be
lists of expressions (of the same length as the number of panels and
run through in the same order as the panels).
</p>


<h3>Value</h3>

<p>An S3 object of class <code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- new("IC")
plot(IC1)
plot(IC1, main = TRUE, panel.first= grid(),
     col = "blue", cex.main = 2, cex.inner = 1)

### selection of subpanels for plotting
N &lt;- NormLocationScaleFamily(mean=0, sd=1) 
IC2 &lt;- optIC(model = N, risk = asCov())
par(mfrow=c(1,1))
plot(IC2, main = TRUE, panel.first= grid(),
     col = "blue", cex.main = 2, cex.inner = 0.6,
     mfColRow = FALSE, to.draw.arg=c("sd"))

## xlim and ylim arguments
plot(IC2, main = TRUE, panel.first= grid(), 
     ylim=c(-3,3), xlim=c(-2,3))
plot(IC2, main = TRUE, panel.first= grid(), 
     ylim=c(-3,3,-1,3), xlim=c(-2,3),
     with.legend = TRUE)

data &lt;- r(N)(30)
plot(IC2, data, panel.first= grid(),
     ylim = c(-3,3,-1,3), xlim=c(-2,3),
     cex.pts = 3, pch.pts = 1:2, col.pts="green",
     with.lab = TRUE, which.lbs = c(1:4,15:20),
     which.Order = 1:6, return.Order = TRUE)
</code></pre>

<hr>
<h2 id='PlotIC'>Wrapper function for plot method for IC</h2><span id='topic+PlotIC'></span>

<h3>Description</h3>

<p>The wrapper <code>PlotIC</code> takes most of arguments to the <code>plot</code> 
method by default and gives a user possibility to run the function
with low number of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  PlotIC(IC, y, ..., alpha.trsp = 100, with.legend = TRUE,
    rescale = FALSE, withCall = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotIC_+3A_ic">IC</code></td>
<td>
<p>object of class <code>IC</code></p>
</td></tr>
<tr><td><code id="PlotIC_+3A_y">y</code></td>
<td>
<p>optional data argument &mdash; for plotting
observations into the plot</p>
</td></tr>
<tr><td><code id="PlotIC_+3A_...">...</code></td>
<td>
<p>additional parameters (in particular to be
passed on to <code>plot</code>)</p>
</td></tr>
<tr><td><code id="PlotIC_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>the transparency argument (0 to 100)
for ploting the data</p>
</td></tr>
<tr><td><code id="PlotIC_+3A_with.legend">with.legend</code></td>
<td>
<p>the flag for showing the legend of the
plot</p>
</td></tr>
<tr><td><code id="PlotIC_+3A_rescale">rescale</code></td>
<td>
<p>the flag for rescaling the axes for better
view of the plot</p>
</td></tr>
<tr><td><code id="PlotIC_+3A_withcall">withCall</code></td>
<td>
<p>the flag for the call output</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(retV)</code> where <code>retV</code> is the return value
of the respective call to the full-fledged plot method
with the additional item <code>wrapcall</code> with the call
to <code>PlotIC</code> and <code>wrappedcall</code> the call to
to the full-fledged plot method.
</p>


<h3>Details</h3>

<p>Calls <code>plot</code> with suitably chosen defaults; if
<code>withCall == TRUE</code>, the call to <code>plot</code>, i.e.,
item <code>wrappedcall</code> from the (hidden) return value, is
printed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gamma
fam &lt;- GammaFamily()
rfam &lt;- InfRobModel(fam, ContNeighborhood(0.5))
IC &lt;- optIC(model = fam, risk = asCov())
Y &lt;- distribution(fam)
y &lt;- r(Y)(1000)
PlotIC(IC, y, withCall = FALSE)
</code></pre>

<hr>
<h2 id='qqplot'>Methods for Function qqplot in Package &lsquo;RobAStBase&rsquo;</h2><span id='topic+qqplot'></span><span id='topic+qqplot-methods'></span><span id='topic+qqplot+2CANY+2CRobModel-method'></span><span id='topic+qqplot+2CANY+2CInfRobModel-method'></span><span id='topic+qqplot+2CANY+2CkStepEstimate-method'></span>

<h3>Description</h3>

<p>We generalize function <code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span> to
be applicable to distribution and probability model objects. In this context,
<code>qqplot</code> produces a QQ plot of data (argument <code>x</code>) against
a (model) distribution. For arguments <code>y</code> of class <code>RobModel</code>,
points at a high &ldquo;distance&rdquo; to the model
are plotted smaller. For arguments <code>y</code> of class <code>kStepEstimate</code>,
points at with low weight in the [p]IC are plotted bigger and their
color gets faded out slowly.
Graphical parameters may be given as arguments to <code>qqplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqplot(x, y, ...)
## S4 method for signature 'ANY,RobModel'
qqplot(x, y,
   n = length(x), withIdLine = TRUE, withConf = TRUE,
   withConf.pw  = withConf,  withConf.sim = withConf,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ..., distance = NormType(),
    n.adj = TRUE)
## S4 method for signature 'ANY,InfRobModel'
qqplot(x, y, n = length(x), withIdLine = TRUE, 
withConf = TRUE, withConf.pw = withConf, withConf.sim = withConf,
  plot.it = TRUE, xlab = deparse(substitute(x)), ylab =
  deparse(substitute(y)), ..., cex.pts.fun = NULL, n.adj = TRUE)
## S4 method for signature 'ANY,kStepEstimate'
qqplot(x, y,
   n = length(x), withIdLine = TRUE, withConf = TRUE,
   withConf.pw  = withConf,  withConf.sim = withConf,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ...,
    exp.cex2.lbs = -.15,
    exp.cex2.pts = -.35,
    exp.fadcol.lbs = 1.85,
    exp.fadcol.pts = 1.85,
    bg = "white")
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqplot_+3A_x">x</code></td>
<td>
<p>data to be checked for compatibility with distribution/model <code>y</code>.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_y">y</code></td>
<td>
<p>object of class <code>"RobModel"</code>, of class <code>"InfRobModel"</code> or of
class <code>"kStepEstimate"</code>.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_n">n</code></td>
<td>
<p>numeric; number of quantiles at which to do the comparison.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withidline">withIdLine</code></td>
<td>
<p>logical; shall line <code>y = x</code> be plotted in?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withconf">withConf</code></td>
<td>
<p>logical; shall confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withconf.pw">withConf.pw</code></td>
<td>
<p>logical; shall pointwise confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withconf.sim">withConf.sim</code></td>
<td>
<p>logical; shall simultaneous confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_plot.it">plot.it</code></td>
<td>
<p>logical; shall be plotted at all (inherited from <code><a href="stats.html#topic+qqnorm">qqplot</a></code>)?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_xlab">xlab</code></td>
<td>
<p>x-label</p>
</td></tr>
<tr><td><code id="qqplot_+3A_ylab">ylab</code></td>
<td>
<p>y-label</p>
</td></tr>
<tr><td><code id="qqplot_+3A_...">...</code></td>
<td>
<p>further parameters for method <code>qqplot</code> with signature
<code>ANY,ProbFamily</code> (see <code><a href="distrMod.html#topic+qqplot">qqplot</a></code>) or with function <code>plot</code></p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.pts.fun">cex.pts.fun</code></td>
<td>
<p>rescaling function for the size of the points to be plotted;
either <code>NULL</code> (default), then <code>log(1+abs(x))</code> is used,
or a function which is then used. </p>
</td></tr>
<tr><td><code id="qqplot_+3A_n.adj">n.adj</code></td>
<td>
<p>logical; shall sample size be adjusted for possible outliers according
to radius of the corresponding neighborhood?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_distance">distance</code></td>
<td>
<p>a function mapping observations <code>x</code> to the positive reals;
used to determine the size of the plotted points (the larger <code>distance(x)</code>,
the smaller the points are plotted.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_exp.cex2.lbs">exp.cex2.lbs</code></td>
<td>
<p>for objects <code>kStepEstimate</code> based on a [p]IC of class <code>HampIC</code>:
exponent for the weights of this [p]IC used to magnify the labels.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_exp.cex2.pts">exp.cex2.pts</code></td>
<td>
<p>for objects <code>kStepEstimate</code> based on a [p]IC of class <code>HampIC</code>:
exponent for the weights of this [p]IC used to magnify the symbols.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_exp.fadcol.lbs">exp.fadcol.lbs</code></td>
<td>
<p>for objects <code>kStepEstimate</code> based on a [p]IC of class <code>HampIC</code>:
exponent for the weights of this [p]IC used to find out-fading colors.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_exp.fadcol.pts">exp.fadcol.pts</code></td>
<td>
<p>for objects <code>kStepEstimate</code> based on a [p]IC of class <code>HampIC</code>:
exponent for the weights of this [p]IC used to find out-fading colors.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_bg">bg</code></td>
<td>
<p>background color to fade against</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>qqplot</dt><dd><p><code>signature(x = "ANY", y = "RobModel")</code>:
produces a QQ plot of a dataset <code>x</code> against the theoretical
quantiles of distribution of robust model <code>y</code>.</p>
</dd>
<dt>qqplot</dt><dd><p><code>signature(x = "ANY", y = "InfRobModel")</code>:
produces a QQ plot of a dataset <code>x</code> against the theoretical
quantiles of distribution of infinitesimally robust model <code>y</code>.</p>
</dd>
<dt>qqplot</dt><dd><p><code>signature(x = "ANY", y = "kStepEstimate")</code>:
produces a QQ plot of a dataset <code>x</code> against the theoretical
quantiles of the model distribution of model at which
the corresponding <code>kStepEstimate</code> <code>y</code> had been calibrated at.
By default, if the [p]IC of the <code>kStepEstimate</code> is of class
<code>HampIC</code>, i.e.; has a corresponding weight function,
points (and, if <code>with.lab==TRUE</code>, labels) are
scaled and faded according to this weight function. Corresponding
arguments <code>exp.cex2.pts</code> and <code>exp.fadcol.pts</code> control this
scaling and fading, respectively
(and analogously <code>exp.cex2.lbs</code> and <code>exp.fadcol.lbs</code> for the labels).
The choice of these arguments has to be done on a case-by-case basis.
Positive exponents induce fading, magnification with increasing weight,
for negative exponents the same is true for decreasing weight; higher
(absolute) values increase the speed of fading / magnification.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>As for function <code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span>: a
list with components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that were/would be plotted</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The corresponding quantiles of the second distribution,
<em>including <code><a href="base.html#topic+NA">NA</a></code>s</em>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span> &ndash; the standard QQ plot
function,  <code><a href="distr.html#topic+qqplot">qqplot</a></code> from package <span class="pkg">distr</span> for
comparisons of distributions, and
<code><a href="distrMod.html#topic+qqplot">qqplot</a></code> from package <span class="pkg">distrMod</span> (which
is called intermediately by this method), as well as
<code><a href="distr.html#topic+qqbounds">qqbounds</a></code>, used by <code>qqplot</code> to produce confidence
intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## \donttest to reduce check time

qqplot(rnorm(40, mean = 15, sd = sqrt(30)), Chisq(df=15))
RobM &lt;- InfRobModel(center = NormLocationFamily(mean=13,sd=sqrt(28)),
                    neighbor = ContNeighborhood(radius = 0.4))

x &lt;- rnorm(20, mean = 15, sd = sqrt(30))
qqplot(x, RobM)
qqplot(x, RobM, alpha.CI=0.9, add.points.CI=FALSE)

## further examples for ANY,kStepEstimator-method
## in example to roptest() in package ROptEst
</code></pre>

<hr>
<h2 id='rescaleFunction-methods'>Methods for Function rescaleFunction in Package &lsquo;RobAStBase&rsquo; </h2><span id='topic+rescaleFunction-methods'></span><span id='topic+rescaleFunction'></span><span id='topic+rescaleFunction+2CANY-method'></span>

<h3>Description</h3>

<p><code>rescaleFunction</code> provides the default rescaling for
a particular L2-Family for wrapper functions <code>PlotIC</code>, <code>ComparePlotIC</code>,
<code>InfoPlot</code>,  and <code>CniperPointPlot</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaleFunction(L2Fam, ...)
## S4 method for signature 'ANY'
rescaleFunction(L2Fam, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaleFunction-methods_+3A_l2fam">L2Fam</code></td>
<td>
<p>an object of class &quot;L2ParamFamily&quot; to be dispatched on. </p>
</td></tr>
<tr><td><code id="rescaleFunction-methods_+3A_...">...</code></td>
<td>
<p> further arguments for the particular methods not be
dispatched on. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rescaleFunction</code> is realized as an S4 method in order to be
able to provide default rescalings for (new) particular L2 Families ex post
to be used in the wrapper functions. </p>


<h3>Value</h3>

<p>a list with arguments needed for the rescaling by internal function
<code>.rescalefct</code>; more specifically it always
contains items <code>scaleX</code> and <code>scaleY</code>, and if <code>dataFlag==TRUE</code>,
also items <code>scaleX.fct</code>, <code>scaleX.inv</code>, <code>scaleY.fct</code>,
<code>scaleY.inv</code>, <code>x.ticks</code>, <code>y.ticks</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Mykhailo Pupashenko <a href="mailto:myhailo.pupashenko@gmail.com">myhailo.pupashenko@gmail.com</a></p>

<hr>
<h2 id='returnlevelplot'>Methods for Function returnlevelplot in Package &lsquo;RobAStBase&rsquo;</h2><span id='topic+returnlevelplot'></span><span id='topic+returnlevelplot-methods'></span><span id='topic+returnlevelplot+2CANY+2CRobModel-method'></span><span id='topic+returnlevelplot+2CANY+2CInfRobModel-method'></span><span id='topic+returnlevelplot+2CANY+2CkStepEstimate-method'></span>

<h3>Description</h3>

<p>We generalize function <code><a href="distrMod.html#topic+returnlevelplot">returnlevelplot</a></code> from package <span class="pkg">distrMod</span> to
be applicable to distribution and probability model objects. In this context,
<code>returnlevelplot</code> produces a rescaled QQ plot of data (argument <code>x</code>)
against a (model) distribution. For arguments <code>y</code> of class <code>RobModel</code>,
points at a high &ldquo;distance&rdquo; to the model
are plotted smaller. For arguments <code>y</code> of class <code>kStepEstimate</code>,
points at with low weight in the [p]IC are plotted bigger and their
color gets faded out slowly. This parallels the behaviour of the respective
<code>qqplot</code> methods.
Graphical parameters may be given as arguments to <code>returnlevelplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returnlevelplot(x, y, ...)
## S4 method for signature 'ANY,RobModel'
returnlevelplot(x, y,
   n = length(x), withIdLine = TRUE, withConf = TRUE,
   withConf.pw  = withConf,  withConf.sim = withConf,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ..., distance = NormType(),
    n.adj = TRUE)
## S4 method for signature 'ANY,InfRobModel'
returnlevelplot(x, y, n = length(x), withIdLine = TRUE,
withConf = TRUE, withConf.pw = withConf, withConf.sim = withConf,
  plot.it = TRUE, xlab = deparse(substitute(x)), ylab =
  deparse(substitute(y)), ..., cex.pts.fun = NULL, n.adj = TRUE)
## S4 method for signature 'ANY,kStepEstimate'
returnlevelplot(x, y,
   n = length(x), withIdLine = TRUE, withConf = TRUE,
   withConf.pw  = withConf,  withConf.sim = withConf,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ...,
    exp.cex2.lbs = -.15,
    exp.cex2.pts = -.35,
    exp.fadcol.lbs = 1.85,
    exp.fadcol.pts = 1.85,
    bg = "white")
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returnlevelplot_+3A_x">x</code></td>
<td>
<p>data to be checked for compatibility with distribution/model <code>y</code>.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_y">y</code></td>
<td>
<p>object of class <code>"RobModel"</code>, of class <code>"InfRobModel"</code> or of
class <code>"kStepEstimate"</code>.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_n">n</code></td>
<td>
<p>numeric; number of quantiles at which to do the comparison.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withidline">withIdLine</code></td>
<td>
<p>logical; shall line <code>y = x</code> be plotted in?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withconf">withConf</code></td>
<td>
<p>logical; shall confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withconf.pw">withConf.pw</code></td>
<td>
<p>logical; shall pointwise confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withconf.sim">withConf.sim</code></td>
<td>
<p>logical; shall simultaneous confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_plot.it">plot.it</code></td>
<td>
<p>logical; shall be plotted at all (inherited from
<code><a href="distrMod.html#topic+returnlevelplot">returnlevelplot</a></code>)?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_xlab">xlab</code></td>
<td>
<p>x-label</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_ylab">ylab</code></td>
<td>
<p>y-label</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_...">...</code></td>
<td>
<p>further parameters for method <code>returnlevelplot</code> with signature
<code>ANY,ProbFamily</code> (see <code><a href="distrMod.html#topic+returnlevelplot">returnlevelplot</a></code>) or with function
<code>plot</code></p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_cex.pts.fun">cex.pts.fun</code></td>
<td>
<p>rescaling function for the size of the points to be plotted;
either <code>NULL</code> (default), then <code>log(1+abs(x))</code> is used,
or a function which is then used. </p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_n.adj">n.adj</code></td>
<td>
<p>logical; shall sample size be adjusted for possible outliers according
to radius of the corresponding neighborhood?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_distance">distance</code></td>
<td>
<p>a function mapping observations <code>x</code> to the positive reals;
used to determine the size of the plotted points (the larger <code>distance(x)</code>,
the smaller the points are plotted.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_exp.cex2.lbs">exp.cex2.lbs</code></td>
<td>
<p>for objects <code>kStepEstimate</code> based on a [p]IC of class <code>HampIC</code>:
exponent for the weights of this [p]IC used to magnify the labels.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_exp.cex2.pts">exp.cex2.pts</code></td>
<td>
<p>for objects <code>kStepEstimate</code> based on a [p]IC of class <code>HampIC</code>:
exponent for the weights of this [p]IC used to magnify the symbols.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_exp.fadcol.lbs">exp.fadcol.lbs</code></td>
<td>
<p>for objects <code>kStepEstimate</code> based on a [p]IC of class <code>HampIC</code>:
exponent for the weights of this [p]IC used to find out-fading colors.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_exp.fadcol.pts">exp.fadcol.pts</code></td>
<td>
<p>for objects <code>kStepEstimate</code> based on a [p]IC of class <code>HampIC</code>:
exponent for the weights of this [p]IC used to find out-fading colors.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_bg">bg</code></td>
<td>
<p>background color to fade against</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>returnlevelplot</dt><dd><p><code>signature(x = "ANY", y = "RobModel")</code>:
produces a QQ plot of a dataset <code>x</code> against the theoretical
quantiles of distribution of robust model <code>y</code>.</p>
</dd>
<dt>returnlevelplot</dt><dd><p><code>signature(x = "ANY", y = "InfRobModel")</code>:
produces a QQ plot of a dataset <code>x</code> against the theoretical
quantiles of distribution of infinitesimally robust model <code>y</code>.</p>
</dd>
<dt>returnlevelplot</dt><dd><p><code>signature(x = "ANY", y = "kStepEstimate")</code>:
produces a QQ plot of a dataset <code>x</code> against the theoretical
quantiles of the model distribution of model at which
the corresponding <code>kStepEstimate</code> <code>y</code> had been calibrated at.
By default, if the [p]IC of the <code>kStepEstimate</code> is of class
<code>HampIC</code>, i.e.; has a corresponding weight function,
points (and, if <code>withLab==TRUE</code>, labels) are
scaled and faded according to this weight function. Corresponding
arguments <code>exp.cex2.pts</code> and <code>exp.fadcol.pts</code> control this
scaling and fading, respectively
(and analogously <code>exp.cex2.lbs</code> and <code>exp.fadcol.lbs</code> for the labels).
The choice of these arguments has to be done on a case-by-case basis.
Positive exponents induce fading, magnification with increasing weight,
for negative exponents the same is true for decreasing weight; higher
(absolute) values increase the speed of fading / magnification.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>As for function <code><a href="distrMod.html#topic+returnlevelplot">returnlevelplot</a></code> from package <span class="pkg">stats</span>.
</p>


<h3>Note</h3>

<p>The confidence bands given in our version of the return level plot differ
from the ones given in package <span class="pkg">ismev</span>. We use non-parametric bands,
hence also allow for non-parametric deviances from the model, whereas in
in package <span class="pkg">ismev</span> they are based on profiling, hence only check for
variability within the parametric class.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>ismev: An   Introduction to Statistical Modeling of Extreme Values. R package
version 1.39. https://CRAN.R-project.org/package=ismev; original S functions
written by Janet E. Heffernan with R port and R documentation provided by
Alec G. Stephenson. (2012).
</p>
<p>Coles, S. (2001). <em>An introduction
to statistical modeling of extreme values.</em> London: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span> &ndash; the standard QQ plot
function,  <code><a href="distrMod.html#topic+returnlevelplot">returnlevelplot</a></code> from package <span class="pkg">distrMod</span> (which
is called intermediately by this method), as well as
<code><a href="distr.html#topic+qqbounds">qqbounds</a></code>, used by <code>returnlevelplot</code> to produce confidence
intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>returnlevelplot(rnorm(40, mean = 15, sd = sqrt(30)), Chisq(df=15))
RobM &lt;- InfRobModel(center = NormLocationFamily(mean=13,sd=sqrt(28)),
                    neighbor = ContNeighborhood(radius = 0.4))

## \donttest to reduce check time
x &lt;- rnorm(20, mean = 15, sd = sqrt(30))
returnlevelplot(x, RobM)
returnlevelplot(x, RobM, alpha.CI=0.9, add.points.CI=FALSE)

## further examples for ANY,kStepEstimator-method
## in example to roptest() in package ROptEst
</code></pre>

<hr>
<h2 id='RobAStBaseMASK'>Masking of/by other functions in package &quot;RobAStBase&quot;</h2><span id='topic+RobAStBaseMASK'></span><span id='topic+MASKING'></span>

<h3>Description</h3>

<p>Provides information on the (intended) masking of
and (non-intended) masking by other other functions in package <span class="pkg">RobAStBase</span></p>


<h3>Usage</h3>

<pre><code class='language-R'>RobAStBaseMASK(library = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RobAStBaseMASK_+3A_library">library</code></td>
<td>
<p>a character vector with path names of R libraries, or <code>NULL</code>.
The default value of <code>NULL</code> corresponds to all libraries
currently known.  If the default is used, the loaded packages
are searched before the libraries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>RobAStBaseMASK()
</code></pre>

<hr>
<h2 id='RobAStBaseOptions'>Function to change the global variables of the package &lsquo;RobAStBase&rsquo; </h2><span id='topic+RobAStBaseOptions'></span><span id='topic+getRobAStBaseOption'></span><span id='topic+kStepUseLast'></span><span id='topic+modifyICwarn'></span><span id='topic+withUpdateInKer'></span><span id='topic+IC.UpdateInKer'></span><span id='topic+all.verbose'></span><span id='topic+withICList'></span><span id='topic+withPICList'></span><span id='topic+modifyICwarn'></span>

<h3>Description</h3>

<p>With <code>RobAStBaseOptions</code> you can inspect and change 
the global variables of the package <span class="pkg">RobAStBase</span>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>RobAStBaseOptions(...)
getRobAStBaseOption(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RobAStBaseOptions_+3A_...">...</code></td>
<td>
<p> any options can be defined, using name = value or by passing a list of such tagged values. </p>
</td></tr>
<tr><td><code id="RobAStBaseOptions_+3A_x">x</code></td>
<td>
<p> a character string holding an option name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RobAStBaseOptions()</code> returns a list of the global variables.<br />
<code>RobAStBaseOptions(x)</code> returns the global variable <var>x</var>.<br />
<code>getRobAStBaseOption(x)</code> returns the global variable <var>x</var>.<br />
<code>RobAStBaseOptions(x=y)</code> sets the value of the global variable <var>x</var> to <var>y</var>.
</p>


<h3>Global Options</h3>


<dl>
<dt>kStepUseLast:</dt><dd><p> The default value of argument <code>kStepUseLast</code> is
<code>FALSE</code>. Explicitly setting <code>kStepUseLast</code> to <code>TRUE</code> should
be done with care as in this situation the influence curve in case of
<code>oneStepEstimator</code> and <code>kStepEstimator</code> is re-computed using 
the value of the one- resp. k-step estimate which may take quite a long 
time depending on the model. </p>
</dd>
<dt>withUpdateInKer:</dt><dd><p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>, shall
the parameter be updated on <code class="reqn">{\rm ker}(D)</code>? Defaults to <code>FALSE</code>.</p>
</dd>
<dt>IC.UpdateInKer:</dt><dd><p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>,
the IC to be used for this; if <code>NULL</code> the result of <code>getboundedIC(L2Fam,D)</code> is taken;
this IC will then be projected onto <code class="reqn">{\rm ker}(D)</code>; defaults to <code>NULL</code>.</p>
</dd>
<dt>all.verbose:</dt><dd><p>argument <code>verbose</code> passed on by default to many calls of
<code>optIC</code>, <code>radiusminimaxIC</code>, <code>getinfRobIC</code> etc.; well suited
for testing purposes. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>withPICList:</dt><dd><p>logical: shall slot <code>pICList</code> of return value of <code>kStepEstimator</code>
be filled? Defaults to <code>FALSE</code>.</p>
</dd>
<dt>withICList:</dt><dd><p>logical: shall slot <code>ICList</code> of return value of <code>kStepEstimator</code>
be filled? Defaults to <code>FALSE</code>.</p>
</dd>
<dt>modifyICwarn:</dt><dd><p>logical: should a (warning) information be added if <code>modifyIC</code>
is applied and hence some optimality information could no longer be valid? Defaults to
<code>TRUE</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>, <code><a href="base.html#topic+options">getOption</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>RobAStBaseOptions()
RobAStBaseOptions("kStepUseLast")
RobAStBaseOptions("kStepUseLast" = TRUE)
# or
RobAStBaseOptions(kStepUseLast = 1e-6)
getRobAStBaseOption("kStepUseLast")
</code></pre>

<hr>
<h2 id='RobAStControl-class'>Control classes in package RobAStBase</h2><span id='topic+RobAStControl-class'></span><span id='topic+name+2CRobAStControl-method'></span><span id='topic+name+3C-+2CRobAStControl-method'></span>

<h3>Description</h3>

<p>Control classes in package <span class="pkg">RobAStBase</span>.</p>


<h3>Objects from the Class</h3>

<p>This class is virtual; that is no objects may be created.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
name of the control object. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "RobAStControl")</code>: 
accessor function for slot <code>name</code>. </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "RobAStControl", value = "character")</code>: 
replacement function for slot <code>name</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>

<hr>
<h2 id='RobModel-class'>Robust model</h2><span id='topic+RobModel-class'></span><span id='topic+center'></span><span id='topic+center+2CRobModel-method'></span><span id='topic+center+3C-'></span><span id='topic+center+3C-+2CRobModel-method'></span><span id='topic+name+2CRobModel-method'></span><span id='topic+neighbor'></span><span id='topic+neighbor+2CRobModel-method'></span><span id='topic+neighbor+3C-'></span><span id='topic+neighbor+3C-+2CRobModel-method'></span><span id='topic+trafo+2CRobModel+2Cmissing-method'></span><span id='topic+trafo+3C-+2CRobModel-method'></span>

<h3>Description</h3>

<p>Class of robust models. A robust model consists 
of  family of probability measures <code>center</code> and a 
neighborhood <code>neighbor</code> about this family.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>center</code></dt><dd><p>Object of class <code>"ProbFamily"</code> </p>
</dd>
<dt><code>neighbor</code></dt><dd><p>Object of class <code>"Neighborhood"</code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>center</dt><dd><p><code>signature(object = "RobModel")</code>: 
accessor function for slot <code>center</code>. </p>
</dd>
<dt>center&lt;-</dt><dd><p><code>signature(object = "RobModel")</code>: 
replacement function for slot <code>center</code>. </p>
</dd>
<dt>neighbor</dt><dd><p><code>signature(object = "RobModel")</code>: 
accessor function for slot <code>neighbor</code>. </p>
</dd>
<dt>neighbor&lt;-</dt><dd><p><code>signature(object = "RobModel")</code>: 
replacement function for slot <code>neighbor</code>. </p>
</dd>
<dt>trafo</dt><dd><p><code>signature(object = "RobModel", param = "missing")</code>:
accessor function for slot <code>trafo</code> of slot <code>center</code>. </p>
</dd>
<dt>trafo&lt;-</dt><dd><p><code>signature(object = "RobModel")</code>:
replacement function for slot <code>trafo</code>
of slot <code>center</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+ProbFamily-class">ProbFamily-class</a></code>, <code><a href="#topic+Neighborhood-class">Neighborhood-class</a></code></p>

<hr>
<h2 id='RobWeight-class'>Robust Weight classes</h2><span id='topic+RobWeight-class'></span><span id='topic+name+2CRobWeight-method'></span><span id='topic+name+3C-+2CRobWeight-method'></span><span id='topic+weight'></span><span id='topic+weight+2CRobWeight-method'></span><span id='topic+weight+3C-'></span><span id='topic+weight+3C--methods'></span><span id='topic+weight+3C-+2CRobWeight-method'></span>

<h3>Description</h3>

<p>Classes for robust weights.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("RobWeight", ...)</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>. </p>
</dd>
<dt><code>weight</code></dt><dd><p>Object of class <code>"function"</code> &mdash; the weight function.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "RobWeight")</code>: 
accessor function for slot <code>name</code>. </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "RobWeight")</code>: 
replacement function for slot <code>name</code>. </p>
</dd>
<dt>weight</dt><dd><p><code>signature(object = "RobWeight")</code>: 
accessor function for slot <code>weight</code>. </p>
</dd>
<dt>weight&lt;-</dt><dd><p><code>signature(object = "RobWeight")</code>: 
replacement function for slot <code>weight</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InfluenceCurve-class">InfluenceCurve-class</a></code>, <code><a href="#topic+IC">IC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## prototype
new("RobWeight")
</code></pre>

<hr>
<h2 id='samplesize-methods'>Methods for Function samplesize  in Package &lsquo;RobAStBase&rsquo;</h2><span id='topic+samplesize+2CinterpolRisk-method'></span><span id='topic+samplesize'></span><span id='topic+samplesize+3C-+2CinterpolRisk-method'></span><span id='topic+samplesize+3C-'></span>

<h3>Description</h3>

<p>samplesize-methods</p>


<h3>Methods</h3>


<dl>
<dt>samplesize</dt><dd><p><code>signature(object = "interpolrisk")</code>:
returns the slot <code>samplesize</code> of an object of class <code>"interpolrisk"</code>. </p>
</dd>
<dt>samplesize&lt;-</dt><dd><p><code>signature(object = "interpolrisk", value = "ANY")</code>:
modifies the slot <code>samplesize</code> of an object of class <code>"interpolrisk"</code>. </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>myrisk &lt;- MBRRisk(samplesize=100)
samplesize(myrisk)
samplesize(myrisk) &lt;- 20
</code></pre>

<hr>
<h2 id='TotalVarIC'>Generating function for TotalVarIC-class</h2><span id='topic+TotalVarIC'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"TotalVarIC"</code>;
i.e., an influence curves <code class="reqn">\eta</code> of the form
</p>
<p style="text-align: center;"><code class="reqn">\eta = c \vee A\Lambda \wedge d</code>
</p>

<p>with lower clipping bound <code class="reqn">c</code>, upper clipping bound <code class="reqn">d</code> and
standardizing matrix <code class="reqn">A</code>. <code class="reqn">\Lambda</code> stands for
the L2 derivative of the corresponding L2 differentiable 
parametric family which can be created via <code>CallL2Fam</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TotalVarIC(name, CallL2Fam = call("L2ParamFamily"), 
           Curve = EuclRandVarList(RealRandVariable(Map = c(function(x) {x}), 
                                                    Domain = Reals())), 
           Risks, Infos, clipLo = -Inf, clipUp = Inf, stand = as.matrix(1), 
           lowerCase = NULL, neighborRadius = 0, w = new("BdStWeight"),
           normtype = NormType(), biastype = symmetricBias(),
           modifyIC = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TotalVarIC_+3A_name">name</code></td>
<td>
<p> object of class <code>"character"</code>. </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_calll2fam">CallL2Fam</code></td>
<td>
<p> object of class <code>"call"</code>:
creates an object of the underlying L2-differentiable 
parametric family. </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_curve">Curve</code></td>
<td>
<p> object of class <code>"EuclRandVarList"</code>. </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_risks">Risks</code></td>
<td>
<p> object of class <code>"list"</code>: 
list of risks; cf. <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code>. </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_infos">Infos</code></td>
<td>
<p> matrix of characters with two columns 
named <code>method</code> and <code>message</code>: additional informations. </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_cliplo">clipLo</code></td>
<td>
<p> negative real: lower clipping bound. </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_clipup">clipUp</code></td>
<td>
<p> positive real: lower clipping bound. </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_stand">stand</code></td>
<td>
<p> matrix: standardizing matrix </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_w">w</code></td>
<td>
<p> BdStWeight: weight object</p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_lowercase">lowerCase</code></td>
<td>
<p> optional constant for lower case solution. </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_neighborradius">neighborRadius</code></td>
<td>
<p> radius of the corresponding (unconditional) 
contamination neighborhood. </p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_biastype">biastype</code></td>
<td>
<p> BiasType: type of the bias</p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_normtype">normtype</code></td>
<td>
<p> NormType: type of the norm</p>
</td></tr>
<tr><td><code id="TotalVarIC_+3A_modifyic">modifyIC</code></td>
<td>
<p> object of class <code>"OptionalFunction"</code>:
function of four arguments: (1) <code>L2Fam</code> an L2 parametric family
(2) <code>IC</code> an optional influence curve, (3) <code>withMakeIC</code>
a logical argument whether to enforce the IC side conditions
by <code>makeIC</code>, and (4) <code>...</code> for arguments to be passed to
calls to <code>E</code> in <code>makeIC</code>. Returns an object of
class <code>"IC"</code>. This function is mainly used for internal
computations! </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"TotalVarIC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC-class">IC-class</a></code>, <code><a href="#topic+ContIC">ContIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- TotalVarIC()
plot(IC1)
</code></pre>

<hr>
<h2 id='TotalVarIC-class'>Influence curve of total variation type</h2><span id='topic+TotalVarIC-class'></span><span id='topic+CallL2Fam+3C-+2CTotalVarIC-method'></span><span id='topic+clipLo'></span><span id='topic+clip+2CTotalVarIC-method'></span><span id='topic+clipLo+2CTotalVarIC-method'></span><span id='topic+clipLo+3C-'></span><span id='topic+clipLo+3C-+2CTotalVarIC-method'></span><span id='topic+clipUp'></span><span id='topic+clipUp+2CTotalVarIC-method'></span><span id='topic+clipUp+3C-'></span><span id='topic+clipUp+3C-+2CTotalVarIC-method'></span><span id='topic+lowerCase+3C-+2CTotalVarIC-method'></span><span id='topic+neighbor+2CTotalVarIC-method'></span><span id='topic+show+2CTotalVarIC-method'></span><span id='topic+stand+3C-+2CTotalVarIC-method'></span><span id='topic+generateIC+2CTotalVarNeighborhood+2CL2ParamFamily-method'></span>

<h3>Description</h3>

<p>Class of (partial) influence curves of total variation type.
i.e., an influence curves <code class="reqn">\eta</code> of the form
</p>
<p style="text-align: center;"><code class="reqn">\eta = c \vee A\Lambda \wedge d</code>
</p>

<p>with lower clipping bound <code class="reqn">c</code>, upper clipping bound <code class="reqn">d</code> and
standardizing matrix <code class="reqn">A</code>. <code class="reqn">\Lambda</code> stands for
the L2 derivative of the corresponding L2 differentiable 
parametric family which can be created via <code>CallL2Fam</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("TotalVarIC", ...)</code>.
More frequently they are created via the generating function 
<code>TotalVarIC</code>, respectively via the method <code>generateIC</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>CallL2Fam</code></dt><dd><p> object of class <code>"call"</code>:
creates an object of the underlying L2-differentiable 
parametric family. </p>
</dd>
<dt><code>name</code></dt><dd><p> object of class <code>"character"</code>. </p>
</dd>
<dt><code>Curve</code></dt><dd><p> object of class <code>"EuclRandVarList"</code>.</p>
</dd>
<dt><code>modifyIC</code></dt><dd><p> object of class <code>"OptionalFunction"</code>:
function of four arguments: (1) <code>L2Fam</code> an L2 parametric family
(2) <code>IC</code> an optional influence curve, (3) <code>withMakeIC</code>
a logical argument whether to enforce the IC side conditions
by <code>makeIC</code>, and (4) <code>...</code> for arguments to be passed to
calls to <code>E</code> in <code>makeIC</code>. Returns an object of
class <code>"IC"</code>. This function is mainly used for internal
computations! </p>
</dd>
<dt><code>Risks</code></dt><dd><p> object of class <code>"list"</code>:
list of risks; cf. <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code>. </p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
<dt><code>clipLo</code></dt><dd><p> object of class <code>"numeric"</code>: 
lower clipping bound. </p>
</dd>
<dt><code>clipUp</code></dt><dd><p> object of class <code>"numeric"</code>: 
upper clipping bound. </p>
</dd>
<dt><code>stand</code></dt><dd><p> object of class <code>"matrix"</code>:
standardizing matrix. </p>
</dd>
<dt><code>weight</code></dt><dd><p> object of class <code>"BdStWeight"</code>:
weight function </p>
</dd>
<dt><code>biastype</code></dt><dd><p> object of class <code>"BiasType"</code>:
bias type (symmetric/onsided/asymmetric) </p>
</dd>
<dt><code>normtype</code></dt><dd><p> object of class <code>"NormType"</code>:
norm type (Euclidean, information/self-standardized)</p>
</dd>
<dt><code>neighborRadius</code></dt><dd><p> object of class <code>"numeric"</code>:
radius of the corresponding (unconditional) contamination 
neighborhood. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"HampIC"</code>, directly.<br />
Class <code>"IC"</code>, by class <code>"HampIC"</code>.<br />
Class <code>"InfluenceCurve"</code>, by class <code>"IC"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>CallL2Fam&lt;-</dt><dd><p><code>signature(object = "TotalVarIC")</code>: 
replacement function for slot <code>CallL2Fam</code>. </p>
</dd>
<dt>clipLo</dt><dd><p><code>signature(object = "TotalVarIC")</code>: 
accessor function for slot <code>clipLo</code>. </p>
</dd>
<dt>clipLo&lt;-</dt><dd><p><code>signature(object = "TotalVarIC")</code>: 
replacement function for slot <code>clipLo</code>. </p>
</dd>
<dt>clipUp</dt><dd><p><code>signature(object = "TotalVarIC")</code>: 
accessor function for slot <code>clipUp</code>. </p>
</dd>
<dt>clipUp&lt;-</dt><dd><p><code>signature(object = "TotalVarIC")</code>: 
replacement function for slot <code>clipUp</code>. </p>
</dd>
<dt>clip</dt><dd><p><code>signature(x1 = "TotalVarIC")</code>:
returns <code>clipUp-clipLo</code>. </p>
</dd>
<dt>stand&lt;-</dt><dd><p><code>signature(object = "TotalVarIC")</code>:
replacement function for slot <code>stand</code>. </p>
</dd>
<dt>lowerCase&lt;-</dt><dd><p><code>signature(object = "TotalVarIC")</code>:
replacement function for slot <code>lowerCase</code>. </p>
</dd>
<dt>neighbor</dt><dd><p><code>signature(object = "TotalVarIC")</code>: 
generates an object of class <code>"TotalVarNeighborhood"</code> with
radius given in slot <code>neighborRadius</code>. </p>
</dd>
<dt>generateIC</dt><dd><p><code>signature(neighbor = "TotalVarNeighborhood", L2Fam = "L2ParamFamily")</code>:
generate an object of class <code>"TotalVarIC"</code>. Rarely called directly. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "TotalVarIC")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC-class">IC-class</a></code>, <code><a href="#topic+ContIC">ContIC</a></code>, <code><a href="#topic+HampIC-class">HampIC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- new("TotalVarIC")
plot(IC1)
</code></pre>

<hr>
<h2 id='TotalVarNeighborhood'>Generating function for TotalVarNeighborhood-class</h2><span id='topic+TotalVarNeighborhood'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"TotalVarNeighborhood"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TotalVarNeighborhood(radius = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TotalVarNeighborhood_+3A_radius">radius</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"ContNeighborhood"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TotalVarNeighborhood-class">TotalVarNeighborhood-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>TotalVarNeighborhood()

## The function is currently defined as
function(radius = 0){ 
    new("TotalVarNeighborhood", radius = radius) 
}
</code></pre>

<hr>
<h2 id='TotalVarNeighborhood-class'>Total variation neighborhood</h2><span id='topic+TotalVarNeighborhood-class'></span>

<h3>Description</h3>

<p>Class of (unconditional) total variation neighborhoods.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("TotalVarNeighborhood", ...)</code>.
More frequently they are created via the generating function 
<code>TotalVarNeighborhood</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;(uncond.) total variation neighborhood&rdquo;. </p>
</dd>
<dt><code>radius</code></dt><dd><p>Object of class <code>"numeric"</code>:
neighborhood radius. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UncondNeighborhood"</code>, directly.<br />
Class <code>"Neighborhood"</code>, by class <code>"UncondNeighborhood"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;TotalVarNeighborhood&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TotalVarNeighborhood">TotalVarNeighborhood</a></code>, <code><a href="#topic+UncondNeighborhood-class">UncondNeighborhood-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("TotalVarNeighborhood")
</code></pre>

<hr>
<h2 id='UncondNeighborhood-class'>Unconditional neighborhood</h2><span id='topic+UncondNeighborhood-class'></span>

<h3>Description</h3>

<p>Class of unconditonal (errors-in-variables) neighborhoods.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
type of the neighborhood. </p>
</dd>
<dt><code>radius</code></dt><dd><p>Object of class <code>"numeric"</code>:
neighborhood radius. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Neighborhood"</code>, directly.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Neighborhood-class">Neighborhood-class</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
