<!DOCTYPE html><html lang="en"><head><title>Help for package cogirt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cogirt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cogirt-package'><p>cogirt: Cognitive Testing Using Item Response Theory</p></a></li>
<li><a href='#cog_cat'><p>Administer Cognitive Tests Using Computerized Adaptive Testing</p></a></li>
<li><a href='#cog_cat_sim'><p>Perform Simulated Computerized Adaptive Testing</p></a></li>
<li><a href='#cog_irt'><p>Fit Item Response Theory Models with Optional Contrast Effects</p></a></li>
<li><a href='#cpt'><p>CPT Data</p></a></li>
<li><a href='#deriv_lambda'><p>Derivatives and Information for Lambda</p></a></li>
<li><a href='#deriv_nu'><p>Derivatives and Information for Nu</p></a></li>
<li><a href='#deriv_omega'><p>Derivatives and Information for Omega</p></a></li>
<li><a href='#dich_response_model'><p>Dichotomous Response Model</p></a></li>
<li><a href='#dich_response_sim'><p>Simulate Dichotomous Response Model</p></a></li>
<li><a href='#ex1'><p>Simulated Data for a Unidimensional Two-Parameter Item Response Model</p></a></li>
<li><a href='#ex2'><p>Simulated Data for a Signal Detection Weighted IRT Model</p></a></li>
<li><a href='#ex3'><p>Simulated Data for a Signal Detection Weighted IRT Model with an Experimental</p>
Design</a></li>
<li><a href='#ex4'><p>Simulated Data for a Unidimensional Two-Parameter Item Response Model</p>
with Two Measurement Occasions</a></li>
<li><a href='#ex5'><p>Simulated Single Subject Data for a Signal Detection Weighted IRT Model with</p>
an Experimental Design</a></li>
<li><a href='#flanker'><p>Flanker Data</p></a></li>
<li><a href='#lrt'><p>Method of anova for cogirt S3</p></a></li>
<li><a href='#mhmc_mc'><p>MHMC Parameter Estimates for Multiple Chains</p></a></li>
<li><a href='#mhmc_sc'><p>MHMC Parameter Estimates for Single Chain</p></a></li>
<li><a href='#mhrm'><p>MHRM Parameter Estimates for Multiple Chains</p></a></li>
<li><a href='#nback'><p>N-Back Data</p></a></li>
<li><a href='#plot.cog_cat_sim'><p>Method of Plot for Simulated Adaptive Testing Using cogirt S3</p></a></li>
<li><a href='#plot.cog_irt'><p>Method of Plot for cogirt S3</p></a></li>
<li><a href='#plt'><p>PLT Data</p></a></li>
<li><a href='#sopt'><p>SOPT Data</p></a></li>
<li><a href='#sternberg'><p>Sternberg Data</p></a></li>
<li><a href='#summary.cog_cat_sim'><p>Method of Summary for cog_cat_sim S3</p></a></li>
<li><a href='#summary.cog_irt'><p>Method of Summary for cog_irt S3</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cognitive Testing Using Item Response Theory</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Psychometrically analyze latent individual differences related to tasks, interventions, or maturational/aging effects in the context of experimental or longitudinal cognitive research using methods first described by Thomas et al. (2020) &lt;<a href="https://doi.org/10.1177%2F0013164420919898">doi:10.1177/0013164420919898</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, abind, mvtnorm, parallel, coda, numDeriv, grDevices,
graphics, stats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-07 05:39:50 UTC; mlthom</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Thomas [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Thomas &lt;michael.l.thomas@colostate.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-07 10:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='cogirt-package'>cogirt: Cognitive Testing Using Item Response Theory</h2><span id='topic+cogirt'></span><span id='topic+cogirt-package'></span>

<h3>Description</h3>

<p>Psychometrically analyze latent individual differences related to tasks, interventions, or maturational/aging effects in the context of experimental or longitudinal cognitive research using methods first described by Thomas et al. (2020) <a href="https://doi.org/10.1177/0013164420919898">doi:10.1177/0013164420919898</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Thomas <a href="mailto:michael.l.thomas@colostate.edu">michael.l.thomas@colostate.edu</a>
</p>

<hr>
<h2 id='cog_cat'>Administer Cognitive Tests Using Computerized Adaptive Testing</h2><span id='topic+cog_cat'></span>

<h3>Description</h3>

<p>This function accepts an RDA file or a list containing selected objects and
returns omega estimates, the standard error of omega, and the optimal next
condition to administer for single-subject computerized adaptive testing.
Adaptive testing is guided by D-optimality (see Segall, 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cog_cat(rda = NULL, obj_fun = NULL, int_par = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cog_cat_+3A_rda">rda</code></td>
<td>
<p>An RDA file (or list) containing y, kappa, gamma, lambda,
condition, omega_mu, omega_sigma2, zeta_mu, zeta_sigma2, nu_mu, and
nu_sigma2. y should be a 1 by IJ row vector. All items not administered
should have NA values in y. See package documentation for definitions and
dimensions of these other objects.</p>
</td></tr>
<tr><td><code id="cog_cat_+3A_obj_fun">obj_fun</code></td>
<td>
<p>A function that calculates predictions and log-likelihood
values for the selected model (character).</p>
</td></tr>
<tr><td><code id="cog_cat_+3A_int_par">int_par</code></td>
<td>
<p>Intentional parameters. That is, the parameters to optimize
precision (scalar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements for omega parameter estimates (omega1),
standard error of the estimates (se_omega), and the next condition to
administer (next_condition).
</p>


<h3>References</h3>

<p>Segall, D. O. (2009). Principles of Multidimensional Adaptive Testing. In W.
J. van der Linden &amp; C. A. W. Glas (Eds.), <em>Elements of Adaptive Testing</em>
(pp. 57-75). https://doi.org/10.1007/978-0-387-85461-8_3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rda = ex5
rda$y[which(!rda$condition %in% c(3))] &lt;- NA
cog_cat(rda = rda, obj_fun = dich_response_model, int_par = 1)

</code></pre>

<hr>
<h2 id='cog_cat_sim'>Perform Simulated Computerized Adaptive Testing</h2><span id='topic+cog_cat_sim'></span>

<h3>Description</h3>

<p>This function performs simulated adapting testing using the D-optimality
criterion (Segall, 2009) which allows the user to focus on a subset of
intentional abilities (or traits).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cog_cat_sim(
  data = NULL,
  model = NULL,
  guessing = NULL,
  contrast_codes = NULL,
  num_conditions = NULL,
  num_contrasts = NULL,
  constraints = NULL,
  key = NULL,
  omega = NULL,
  item_disc = NULL,
  item_int = NULL,
  conditions = NULL,
  int_par = NULL,
  start_conditions = NULL,
  max_conditions = Inf,
  omit_conditions = NULL,
  min_se = -Inf,
  link = "probit",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cog_cat_sim_+3A_data">data</code></td>
<td>
<p>A matrix of item responses (K by IJ). Rows should contain
dichotomous responses (1 or 0) for the items indexed by each column.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_model">model</code></td>
<td>
<p>An IRT model name. The options are &quot;1p&quot; for the one-parameter
model, &quot;2p&quot; for the two-parameter model, &quot;3p&quot; for the three-parameter model,
or &quot;sdt&quot; for a signal detection-weighted model.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_guessing">guessing</code></td>
<td>
<p>Either a single numeric guessing value or a matrix of item
guessing parameters (IJ by 1). This argument is only used when model = '3p'.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_contrast_codes">contrast_codes</code></td>
<td>
<p>Either a matrix of contrast codes (JM by MN) or the
name in quotes of a R stats contrast function (i.e., &quot;contr.helmert&quot;,
&quot;contr.poly&quot;, &quot;contr.sum&quot;, &quot;contr.treatment&quot;, or &quot;contr.SAS&quot;). If using the R
stats contrast function items in the data matrix must be arranged by
condition.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_num_conditions">num_conditions</code></td>
<td>
<p>The total number of possible conditions (required if
using the R stats contrast function or when constraints = TRUE).</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_num_contrasts">num_contrasts</code></td>
<td>
<p>The number of contrasts, including intercept (required
if using the R stats contrast function or when constraints = TRUE).</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_constraints">constraints</code></td>
<td>
<p>Either a logical (TRUE or FALSE) indicating that item
parameters should be constrained to be equal over the J conditions, or a 1 by
I vector of items that should be constrained to be equal across conditions.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_key">key</code></td>
<td>
<p>An item key vector where 1 indicates a target and 2 indicates
a distractor (IJ). Required when model = 'sdt'.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_omega">omega</code></td>
<td>
<p>A matrix of true omega parameters if known. These are
estimated using the complete data if not supplied by the user.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_item_disc">item_disc</code></td>
<td>
<p>A matrix of item discrimination parameters if known. These
are estimated using the complete data if not supplied by the user.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_item_int">item_int</code></td>
<td>
<p>A matrix of item intercept parameters if known. These are
estimated using the complete data if not supplied by the user.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_conditions">conditions</code></td>
<td>
<p>A list of experimental conditions that the adaptive testing
algorithm will choose from. The word &quot;conditions&quot; here refers to a
single item or a group of items that should be administered together before
the next iteration of adaptive testing. For cognitive experiments, multiple
conditions can be assigned the same experimental level (e.g., memory load
level).</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_int_par">int_par</code></td>
<td>
<p>The index of the intentional parameters, i.e., the column
of the experimental effects matrix (omega) that should be optimized.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_start_conditions">start_conditions</code></td>
<td>
<p>A vector of condition(s) completed prior to
the onset of adaptive testing.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_max_conditions">max_conditions</code></td>
<td>
<p>The maximum number of conditions to administer before
terminating adaptive testing. If max_conditions is specified, min_se should
not be. Note that this is the number of additional conditions to administer
beyond the starting conditions.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_omit_conditions">omit_conditions</code></td>
<td>
<p>A vector of conditions to be omitted from the
simulation.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_min_se">min_se</code></td>
<td>
<p>The minimum standard error of estimate needed to terminate
adaptive testing. If min_se is specified, max_conditions should not be.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_link">link</code></td>
<td>
<p>The name (&quot;logit&quot; or &quot;probit&quot;) of the link function to be used in
the model.</p>
</td></tr>
<tr><td><code id="cog_cat_sim_+3A_verbose">verbose</code></td>
<td>
<p>Logical (TRUE or FALSE) indicating whether to print progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements with the model used (model), true omega
parameters (omega), various simulation parameters, final omega estimates
(omega1) and information matrices (info1_omega), ongoing estimates of omega
(ongoing_omega_est) and standard error of the estimates (ongoing_se_omega),
and completed conditions (completed_conditions).
</p>


<h3>References</h3>

<p>Segall, D. O. (2009). Principles of Multidimensional Adaptive Testing. In W.
J. van der Linden &amp; C. A. W. Glas (Eds.), <em>Elements of Adaptive Testing</em>
(pp. 57-75). https://doi.org/10.1007/978-0-387-85461-8_3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim_res &lt;- cog_cat_sim(data = ex3$y, model = 'sdt', guessing = NULL,
                       contrast_codes = "contr.poly", num_conditions = 10,
                       num_contrasts = 2, constraints = NULL, key = ex3$key,
                       omega = ex3$omega, item_disc = ex3$lambda,
                       item_int = ex3$nu, conditions = ex3$condition,
                       int_par = c(1, 2), start_conditions = 3,
                       max_conditions = 3, link = "probit")
summary(sim_res)
plot(sim_res)


</code></pre>

<hr>
<h2 id='cog_irt'>Fit Item Response Theory Models with Optional Contrast Effects</h2><span id='topic+cog_irt'></span>

<h3>Description</h3>

<p>This function estimates item response theory (IRT) model parameters. Users
can optionally estimate person parameters that account for experimental or
longitudinal contrast effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cog_irt(
  data = NULL,
  model = NULL,
  guessing = NULL,
  contrast_codes = NULL,
  num_conditions = NULL,
  num_contrasts = NULL,
  constraints = NULL,
  key = NULL,
  link = "probit",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cog_irt_+3A_data">data</code></td>
<td>
<p>A matrix of item responses (K by IJ). Rows should contain each
subject's dichotomous responses (1 or 0) for the items indexed by each
column.</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_model">model</code></td>
<td>
<p>An IRT model name. The options are &quot;1p&quot; for the one-parameter
model, &quot;2p&quot; for the two parameter model, &quot;3p&quot; for the three-parameter model,
or &quot;sdt&quot; for the signal detection-weighted model.</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_guessing">guessing</code></td>
<td>
<p>Either a single numeric guessing value or a matrix of item
guessing parameters (IJ by 1). This argument is only used when model = '3p'.</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_contrast_codes">contrast_codes</code></td>
<td>
<p>Either a matrix of contrast codes (JM by MN) or the
name in quotes of a R stats contrast function (i.e., &quot;contr.helmert&quot;,
&quot;contr.poly&quot;, &quot;contr.sum&quot;, &quot;contr.treatment&quot;, or &quot;contr.SAS&quot;). If using the R
stats contrast function items in the data matrix must be arranged by
condition.</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_num_conditions">num_conditions</code></td>
<td>
<p>The number of conditions (required if using the R stats
contrast function or when constraints = TRUE).</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_num_contrasts">num_contrasts</code></td>
<td>
<p>The number of contrasts including intercept (required if
using the R stats contrast function or when constraints = TRUE).</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_constraints">constraints</code></td>
<td>
<p>Either a logical (TRUE or FALSE) indicating that item
parameters should be constrained to be equal over the J conditions or a 1 by
I vector of items that should be constrained to be equal across conditions.</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_key">key</code></td>
<td>
<p>An item key vector where 1 indicates target and 2 indicates
distractor (IJ). Required when model = 'sdt'.</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_link">link</code></td>
<td>
<p>The name (&quot;logit&quot; or &quot;probit&quot;) of the link function to be used in
the model.</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_verbose">verbose</code></td>
<td>
<p>Logical (TRUE or FALSE) indicating whether to print progress.</p>
</td></tr>
<tr><td><code id="cog_irt_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements for all parameters estimated (omega1, nu1,
and/or lambda1), information values for all parameters estimated
(info1_omega, info1_nu, and/or info1_lambda), the model log-likelihood value
(log_lik), and the total number of estimated parameters (par) in the model.
</p>


<h3>Dimensions</h3>

<p>I = Number of items per condition; J = Number of conditions or time points;
K = Number of examinees; M Number of ability (or trait) dimensions; N Number
of contrast effects (including intercept).
</p>


<h3>References</h3>

<p>Embretson S. E., &amp; Reise S. P. (2000). <em>Item response theory for
psychologists.</em> Mahwah, N.J.: L. Erlbaum Associates.
</p>
<p>Thomas, M. L., Brown, G. G., Patt, V. M., &amp; Duffy, J. R. (2021). Latent
variable modeling and adaptive testing for experimental cognitive
psychopathology research.  <em>Educational and Psychological Measurement,
81</em>(1), 155-181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nback_fit_contr &lt;- cog_irt(data = nback$y, model = "sdt",
                           contrast_codes = "contr.poly", key = nback$key,
                           num_conditions = length(unique(nback$condition)),
                           num_contrasts = 2)
plot(nback_fit_contr)


</code></pre>

<hr>
<h2 id='cpt'>CPT Data</h2><span id='topic+cpt'></span>

<h3>Description</h3>

<p>CPT task accuracy data collected from an online experiment. The
condition vector indicates backward mask onset (50, 100, 150, or 200 ms).The
key indicates whether items are targets (1) or distractors (2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpt
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>key</dt><dd><p>Item key vector where 1 indicates target and 2 indicates
distractor (IJ)</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
</dl>


<hr>
<h2 id='deriv_lambda'>Derivatives and Information for Lambda</h2><span id='topic+deriv_lambda'></span>

<h3>Description</h3>

<p>This function calculates the matrix of first partial derivatives, the matrix
of second partial derivatives, and matrix of posterior and Fisher information
for the posterior distribution with respect to alpha (discrimination) based
on the slope-intercept form of the 1-, 2-, or 3-P item response theory model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_lambda(
  y = NULL,
  omega = NULL,
  gamma = NULL,
  lambda = NULL,
  zeta = NULL,
  kappa = NULL,
  nu = NULL,
  lambda_mu = NULL,
  lambda_sigma2 = NULL,
  link = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deriv_lambda_+3A_y">y</code></td>
<td>
<p>Item response matrix (K by IJ).</p>
</td></tr>
<tr><td><code id="deriv_lambda_+3A_omega">omega</code></td>
<td>
<p>Contrast effects matrix (K by
MN).</p>
</td></tr>
<tr><td><code id="deriv_lambda_+3A_gamma">gamma</code></td>
<td>
<p>Contrast codes matrix (JM by MN).</p>
</td></tr>
<tr><td><code id="deriv_lambda_+3A_lambda">lambda</code></td>
<td>
<p>Item slope matrix (IJ by JM).</p>
</td></tr>
<tr><td><code id="deriv_lambda_+3A_zeta">zeta</code></td>
<td>
<p>Specific effects matrix (K by
JM).</p>
</td></tr>
<tr><td><code id="deriv_lambda_+3A_kappa">kappa</code></td>
<td>
<p>Item guessing matrix  (IJ by 1). Defaults to 0.</p>
</td></tr>
<tr><td><code id="deriv_lambda_+3A_nu">nu</code></td>
<td>
<p>Item intercept matrix  (IJ by 1).</p>
</td></tr>
<tr><td><code id="deriv_lambda_+3A_lambda_mu">lambda_mu</code></td>
<td>
<p>Mean prior for lambda (1 by JM)</p>
</td></tr>
<tr><td><code id="deriv_lambda_+3A_lambda_sigma2">lambda_sigma2</code></td>
<td>
<p>Covariance prior for lambda (JM by JM)</p>
</td></tr>
<tr><td><code id="deriv_lambda_+3A_link">link</code></td>
<td>
<p>Choose between &quot;logit&quot; or &quot;probit&quot; link functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements fpd (1 by JM vector of first partial derivatives
for alpha), spd (JM by JM matrix of second partial derivatives for alpha),
post_info (JM by JM posterior information matrix for alpha), and fisher_info
(JM by JM Fisher information matrix for alpha). Within each of these
elements, there are sub-elements for all IJ items
</p>


<h3>Dimensions</h3>

<p>I = Number of items per condition; J = Number of conditions; K = Number of
examinees; M Number of ability (or trait) dimensions; N Number of contrasts
(should include intercept).
</p>


<h3>A Note About Model Notation</h3>

<p>The function converts GLLVM notation to the more typical IRT notation used by
Segall (1996) for ease of referencing formulas (with the exception of using
the slope-intercept form of the item response model).
</p>


<h3>References</h3>

<p>Carlson, J. E. (1987). Multidimensional Item Response Theory Estimation: A
computer program (Reprot No. ONR87-2). The American College Testing Program.
https://apps.dtic.mil/sti/pdfs/ADA197160.pdf
</p>
<p>Segall, D. O. (1996). Multidimensional adaptive testing.
<em>Psychometrika, 61(2)</em>, 331-354. https://doi.org/10.1007/BF02294343
</p>
<p>Segall, D. O. (2009). Principles of Multidimensional Adaptive Testing. In W.
J. van der Linden &amp; C. A. W. Glas (Eds.), <em>Elements of Adaptive Testing</em>
(pp. 57-75). https://doi.org/10.1007/978-0-387-85461-8_3
</p>

<hr>
<h2 id='deriv_nu'>Derivatives and Information for Nu</h2><span id='topic+deriv_nu'></span>

<h3>Description</h3>

<p>This function calculates the matrix of first partial derivatives, the matrix
of second partial derivatives, and matrix of posterior and Fisher information
for the posterior distribution with respect to nu (easiness) based on the
slope-intercept form of the 1-, 2-, or 3-P item response theory model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_nu(
  y = NULL,
  omega = NULL,
  gamma = NULL,
  lambda = NULL,
  zeta = NULL,
  nu = NULL,
  kappa = NULL,
  nu_mu = NULL,
  nu_sigma2 = NULL,
  link = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deriv_nu_+3A_y">y</code></td>
<td>
<p>Item response matrix (K by IJ).</p>
</td></tr>
<tr><td><code id="deriv_nu_+3A_omega">omega</code></td>
<td>
<p>Contrast effects matrix (K by
MN).</p>
</td></tr>
<tr><td><code id="deriv_nu_+3A_gamma">gamma</code></td>
<td>
<p>Contrast codes matrix (JM by MN).</p>
</td></tr>
<tr><td><code id="deriv_nu_+3A_lambda">lambda</code></td>
<td>
<p>Item slope matrix (IJ by JM).</p>
</td></tr>
<tr><td><code id="deriv_nu_+3A_zeta">zeta</code></td>
<td>
<p>Specific effects matrix (K by
JM).</p>
</td></tr>
<tr><td><code id="deriv_nu_+3A_nu">nu</code></td>
<td>
<p>Item intercept matrix  (IJ by 1).</p>
</td></tr>
<tr><td><code id="deriv_nu_+3A_kappa">kappa</code></td>
<td>
<p>Item guessing matrix  (IJ by 1). Defaults to 0.</p>
</td></tr>
<tr><td><code id="deriv_nu_+3A_nu_mu">nu_mu</code></td>
<td>
<p>Mean prior for nu (1 by 1)</p>
</td></tr>
<tr><td><code id="deriv_nu_+3A_nu_sigma2">nu_sigma2</code></td>
<td>
<p>Covariance prior for nu (1 by 1)</p>
</td></tr>
<tr><td><code id="deriv_nu_+3A_link">link</code></td>
<td>
<p>Choose between &quot;logit&quot; or &quot;probit&quot; link functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements fpd (1 by 1 vector of first partial derivatives
for nu), spd (1 by 1 matrix of second partial derivatives for nu),
post_info (1 by 1 posterior information matrix for nu), and fisher_info
(1 by 1) Fisher information matrix for nu). Within each of these
elements, there are sub-elements for all IJ items.
</p>


<h3>Dimensions</h3>

<p>I = Number of items per condition; J = Number of conditions; K = Number of
examinees; M Number of ability (or trait) dimensions; N Number of contrasts
(should include intercept).
</p>


<h3>A Note About Model Notation</h3>

<p>The function converts GLLVM notation to the more typical IRT notation used by
Segall (1996) for ease of referencing formulas (with the exception of using
the slope-intercept form of the item response model).
</p>


<h3>References</h3>

<p>Carlson, J. E. (1987). Multidimensional Item Response Theory Estimation: A
computer program (Reprot No. ONR87-2). The American College Testing Program.
https://apps.dtic.mil/sti/pdfs/ADA197160.pdf
</p>
<p>Segall, D. O. (1996). Multidimensional adaptive testing.
<em>Psychometrika, 61(2)</em>, 331-354. https://doi.org/10.1007/BF02294343
</p>
<p>Segall, D. O. (2009). Principles of Multidimensional Adaptive Testing. In W.
J. van der Linden &amp; C. A. W. Glas (Eds.), <em>Elements of Adaptive Testing</em>
(pp. 57-75). https://doi.org/10.1007/978-0-387-85461-8_3
</p>

<hr>
<h2 id='deriv_omega'>Derivatives and Information for Omega</h2><span id='topic+deriv_omega'></span>

<h3>Description</h3>

<p>This function calculates the matrix of first partial derivatives, the matrix
of second partial derivatives, and matrix of posterior and Fisher information
for the posterior distribution with respect to omega (ability) based on the
slope-intercept form of the 1-, 2-, or 3-parameter item response theory
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_omega(
  y = NULL,
  omega = NULL,
  gamma = NULL,
  lambda = NULL,
  zeta = NULL,
  nu = NULL,
  kappa = NULL,
  omega_mu = NULL,
  omega_sigma2 = NULL,
  zeta_mu = NULL,
  zeta_sigma2 = NULL,
  est_zeta = TRUE,
  link = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deriv_omega_+3A_y">y</code></td>
<td>
<p>Item response matrix (K by IJ).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_omega">omega</code></td>
<td>
<p>Contrast effects matrix (K by
MN).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_gamma">gamma</code></td>
<td>
<p>Contrast codes matrix (JM by MN).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_lambda">lambda</code></td>
<td>
<p>Item slope matrix (IJ by JM).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_zeta">zeta</code></td>
<td>
<p>Specific effects matrix (K by
JM).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_nu">nu</code></td>
<td>
<p>Item intercept matrix  (IJ by 1).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_kappa">kappa</code></td>
<td>
<p>Item guessing matrix  (IJ by 1). Defaults to 0.</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_omega_mu">omega_mu</code></td>
<td>
<p>Mean prior for omega (1 by MN).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_omega_sigma2">omega_sigma2</code></td>
<td>
<p>Covariance prior for omega (MN by MN).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_zeta_mu">zeta_mu</code></td>
<td>
<p>Mean prior for zeta (1 by JM).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_zeta_sigma2">zeta_sigma2</code></td>
<td>
<p>Covariance prior for zeta (JM by JM).</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_est_zeta">est_zeta</code></td>
<td>
<p>Logical indicating whether or not to estimate zeta
derivatives</p>
</td></tr>
<tr><td><code id="deriv_omega_+3A_link">link</code></td>
<td>
<p>Choose between &quot;logit&quot; or &quot;probit&quot; link functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements fpd (1 by MN vector of first partial derivatives
for omega), spd (MN by MN matrix of second partial derivatives for omega),
post_info (MN by MN posterior information matrix for omega), and fisher_info
(MN by MN Fisher information matrix for omega). Within each of these
elements, there are sub-elements for all K examinees.
</p>


<h3>Dimensions</h3>

<p>I = Number of items per condition; J = Number of conditions; K = Number of
examinees; M Number of ability (or trait) dimensions; N Number of contrasts
(should include intercept).
</p>


<h3>A Note About Model Notation</h3>

<p>The function converts GLLVM notation to the more typical IRT notation used by
Segall (1996) for ease of referencing formulas (with the exception of using
the slope-intercept form of the item response model).
</p>


<h3>References</h3>

<p>Segall, D. O. (1996). Multidimensional adaptive testing.
<em>Psychometrika, 61(2)</em>, 331-354. https://doi.org/10.1007/BF02294343
</p>
<p>Segall, D. O. (2009). Principles of Multidimensional Adaptive Testing. In W.
J. van der Linden &amp; C. A. W. Glas (Eds.), <em>Elements of Adaptive Testing</em>
(pp. 57-75). https://doi.org/10.1007/978-0-387-85461-8_3
</p>

<hr>
<h2 id='dich_response_model'>Dichotomous Response Model</h2><span id='topic+dich_response_model'></span>

<h3>Description</h3>

<p>This function calculates predictions and log-likelihood values for a
dichotomous response model framed using generalized latent variable modeling
(GLVM; Skrondal &amp; Rabe-Hesketh, 2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dich_response_model(
  y = NULL,
  omega = NULL,
  gamma = NULL,
  lambda = NULL,
  zeta = NULL,
  nu = NULL,
  kappa = NULL,
  link = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dich_response_model_+3A_y">y</code></td>
<td>
<p>Item response matrix (K by IJ).</p>
</td></tr>
<tr><td><code id="dich_response_model_+3A_omega">omega</code></td>
<td>
<p>Contrast effects matrix (K by
MN).</p>
</td></tr>
<tr><td><code id="dich_response_model_+3A_gamma">gamma</code></td>
<td>
<p>Contrast codes matrix (JM by MN).</p>
</td></tr>
<tr><td><code id="dich_response_model_+3A_lambda">lambda</code></td>
<td>
<p>Item slope matrix (IJ by JM).</p>
</td></tr>
<tr><td><code id="dich_response_model_+3A_zeta">zeta</code></td>
<td>
<p>Specific effects matrix (K by
JM).</p>
</td></tr>
<tr><td><code id="dich_response_model_+3A_nu">nu</code></td>
<td>
<p>Item intercept matrix  (IJ by 1).</p>
</td></tr>
<tr><td><code id="dich_response_model_+3A_kappa">kappa</code></td>
<td>
<p>Item guessing matrix  (IJ by 1).</p>
</td></tr>
<tr><td><code id="dich_response_model_+3A_link">link</code></td>
<td>
<p>Choose between &quot;logit&quot; or &quot;probit&quot; link functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p = response probability matrix (K by IJ); yhatstar = latent response
variate matrix (K by IJ); loglikelihood = model log-likelihood (scalar).
</p>


<h3>Dimensions</h3>

<p>I = Number of items per condition; J = Number of conditions; K = Number of
examinees; M Number of ability (or trait) dimensions; N Number of contrasts
(should include intercept).
</p>


<h3>References</h3>

<p>Skrondal, A., &amp; Rabe-Hesketh, S. (2004). <em>Generalized latent variable
modeling: Multilevel, longitudinal, and structural equation models</em>. Boca
Raton: Chapman &amp; Hall/CRC.
</p>

<hr>
<h2 id='dich_response_sim'>Simulate Dichotomous Response Model</h2><span id='topic+dich_response_sim'></span>

<h3>Description</h3>

<p>This function calculates the matrix of first partial derivatives, the matrix
of second partial derivatives, and the information matrix for the posterior
distribution with respect to theta (ability) based on theslope-intercept form
of the item response theory model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dich_response_sim(
  I = NULL,
  J = NULL,
  K = NULL,
  M = NULL,
  N = NULL,
  omega = NULL,
  omega_mu = NULL,
  omega_sigma2 = NULL,
  gamma = NULL,
  lambda = NULL,
  lambda_mu = NULL,
  lambda_sigma2 = NULL,
  nu = NULL,
  nu_mu = NULL,
  nu_sigma2 = NULL,
  zeta = NULL,
  zeta_mu = NULL,
  zeta_sigma2 = NULL,
  kappa = NULL,
  key = NULL,
  link = "probit"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dich_response_sim_+3A_i">I</code></td>
<td>
<p>Number of items per condition.</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_j">J</code></td>
<td>
<p>Number of conditions.</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_k">K</code></td>
<td>
<p>Number of examinees</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_m">M</code></td>
<td>
<p>Number of ability (or trait) dimensions.</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_n">N</code></td>
<td>
<p>Number of contrasts (should include intercept).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_omega">omega</code></td>
<td>
<p>Contrast effects matrix (K by
MN).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_omega_mu">omega_mu</code></td>
<td>
<p>Vector of means for the examinee-level effects of the
experimental manipulation (1 by MN).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_omega_sigma2">omega_sigma2</code></td>
<td>
<p>Covariance matrix for the examinee-level effects of the
experimental manipulation (MN by MN).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_gamma">gamma</code></td>
<td>
<p>Contrast codes matrix (JM by MN).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_lambda">lambda</code></td>
<td>
<p>Item slope matrix (IJ by JM).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_lambda_mu">lambda_mu</code></td>
<td>
<p>Vector of means for the item slope parameters (1 by JM)</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_lambda_sigma2">lambda_sigma2</code></td>
<td>
<p>Covariance matrix for the item slope parameters (JM
by JM)</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_nu">nu</code></td>
<td>
<p>Item intercept matrix  (K by IJ).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_nu_mu">nu_mu</code></td>
<td>
<p>Mean of the item intercept parameters (scalar).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_nu_sigma2">nu_sigma2</code></td>
<td>
<p>Variance of the item intercept parameters (scalar).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_zeta">zeta</code></td>
<td>
<p>Specific effects matrix (K by
JM).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_zeta_mu">zeta_mu</code></td>
<td>
<p>Vector of means for the condition-level effects nested within
examinees (1 by JM).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_zeta_sigma2">zeta_sigma2</code></td>
<td>
<p>Covariance matrix for the condition-level effects nested
within examinees (JM by JM).</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_kappa">kappa</code></td>
<td>
<p>kappa    Item guessing matrix  (IJ by 1). If kappa is not
provided, parameter values are set to 0.</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_key">key</code></td>
<td>
<p>Option key where  1 indicates target and 2 indicates distractor.</p>
</td></tr>
<tr><td><code id="dich_response_sim_+3A_link">link</code></td>
<td>
<p>Choose between logit or probit link functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y = simulated response matrix; yhatstar = simulated latent response
probability matrix; [simulation_parameters]
</p>


<h3>References</h3>

<p>Skrondal, A., &amp; Rabe-Hesketh, S. (2004). <em>Generalized latent variable
modeling: Multilevel, longitudinal, and structural equation models</em>. Boca
Raton: Chapman &amp; Hall/CRC.
</p>
<p>Thomas, M. L., Brown, G. G., Gur, R. C., Moore, T. M., Patt,
V. M., Risbrough, V. B., &amp; Baker, D. G. (2018). A signal detection-item
response theory model for evaluating neuropsychological measures.
<em>Journal of Clinical and Experimental Neuropsychology, 40(8)</em>, 745-760.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1

I &lt;- 100
J &lt;- 1
K &lt;- 250
M &lt;- 1
N &lt;- 1
omega_mu &lt;- matrix(data = 0, nrow = 1, ncol = M * N)
omega_sigma2 &lt;- diag(x = 1, nrow = M * N)
gamma &lt;- diag(x = 1, nrow = J * M, ncol = M * N)
lambda_mu &lt;- matrix(data = 1, nrow = 1, ncol = M)
lambda_sigma2 &lt;- diag(x = 0.25, nrow = M)
zeta_mu &lt;- matrix(data = rep(x = 0, times = M * J), nrow = 1, ncol = J * M)
zeta_sigma2 &lt;- diag(x = 0, nrow = J * M, ncol = J * M)
nu_mu &lt;- matrix(data = 0, nrow = 1, ncol = 1)
nu_sigma2 &lt;- matrix(data = 1, nrow = 1, ncol = 1)
set.seed(624)
ex1 &lt;- dich_response_sim(I = I, J = J, K = K, M = M, N = N,
                         omega_mu = omega_mu, omega_sigma2 = omega_sigma2,
                         gamma = gamma, lambda_mu = lambda_mu,
                         lambda_sigma2 = lambda_sigma2, nu_mu = nu_mu,
                         nu_sigma2 = nu_sigma2, zeta_mu = zeta_mu,
                         zeta_sigma2 = zeta_sigma2)

# Example 2

I &lt;- 100
J &lt;- 1
K &lt;- 50
M &lt;- 2
N &lt;- 1
omega_mu &lt;- matrix(data = c(3.50, 1.00), nrow = 1, ncol = M * N)
omega_sigma2 &lt;- diag(x = c(0.90, 0.30), nrow = M * N)
gamma &lt;- diag(x = 1, nrow = J * M, ncol = M * N)
key &lt;- rbinom(n = I * J, size = 1, prob = .7) + 1
measure_weights &lt;-
  matrix(data = c(0.5, -1.0, 0.5, 1.0), nrow = 2, ncol = M, byrow = TRUE)
lambda &lt;- matrix(data = 0, nrow = I * J, ncol = J * M)
for(j in 1:J) {
  lambda[(1 + (j - 1) * I):(j * I), (1 + (j - 1) * M):(j * M)] &lt;-
    measure_weights[key, ][(1 + (j - 1) * I):(j * I), ]
}
zeta_mu &lt;- matrix(data = rep(x = 0, times = M * J), nrow = 1, ncol = J * M)
zeta_sigma2 &lt;- diag(x = 0, nrow = J * M, ncol = J * M)
nu_mu &lt;- matrix(data = 0, nrow = 1, ncol = 1)
nu_sigma2 &lt;- matrix(data = .2, nrow = 1, ncol = 1)
set.seed(624)
ex2 &lt;- dich_response_sim(I = I, J = J, K = K, M = M, N = N,
                         omega_mu = omega_mu, omega_sigma2 = omega_sigma2,
                         gamma = gamma, lambda = lambda, nu_mu = nu_mu,
                         nu_sigma2 = nu_sigma2, zeta_mu = zeta_mu,
                         zeta_sigma2 = zeta_sigma2, key = key)

# Example 3

I &lt;- 20
J &lt;- 10
K &lt;- 50
M &lt;- 2
N &lt;- 2
omega_mu &lt;- matrix(data = c(2.50, -2.00, 0.50, 0.00), nrow = 1, ncol = M * N)
omega_sigma2 &lt;- diag(x = c(0.90, 0.70, 0.30, 0.10), nrow = M * N)
contrast_codes &lt;- cbind(1, contr.poly(n = J))[, 1:N]
gamma &lt;- matrix(data = 0, nrow = J * M, ncol = M * N)
for(j in 1:J) {
  for(m in 1:M) {
    gamma[(m + M * (j - 1)), (((m - 1) * N + 1):((m - 1) * N + N))] &lt;-
      contrast_codes[j, ]
  }
}
key &lt;- rbinom(n = I * J, size = 1, prob = .7) + 1
measure_weights &lt;-
  matrix(data = c(0.5, -1.0, 0.5, 1.0), nrow = 2, ncol = M, byrow = TRUE)
lambda &lt;- matrix(data = 0, nrow = I * J, ncol = J * M)
for(j in 1:J) {
  lambda[(1 + (j - 1) * I):(j * I), (1 + (j - 1) * M):(j * M)] &lt;-
    measure_weights[key, ][(1 + (j - 1) * I):(j * I), ]
}
zeta_mu &lt;- matrix(data = rep(x = 0, times = M * J), nrow = 1, ncol = J * M)
zeta_sigma2 &lt;- diag(x = 0.2, nrow = J * M, ncol = J * M)
nu_mu &lt;- matrix(data = c(0.00), nrow = 1, ncol = 1)
nu_sigma2 &lt;- matrix(data = c(0.20), nrow = 1, ncol = 1)
set.seed(624)
ex3 &lt;- dich_response_sim(I = I, J = J, K = K, M = M, N = N,
                         omega_mu = omega_mu, omega_sigma2 = omega_sigma2,
                         gamma = gamma, lambda = lambda, nu_mu = nu_mu,
                         nu_sigma2 = nu_sigma2, zeta_mu = zeta_mu,
                         zeta_sigma2 = zeta_sigma2, key = key)

# Example 4

I &lt;- 25
J &lt;- 2
K &lt;- 200
M &lt;- 1
N &lt;- 2
omega_mu &lt;- matrix(data = c(1, -2), nrow = 1, ncol = M * N)
omega_sigma2 &lt;- diag(x = c(1.00, 0.25), nrow = M * N)
contrast_codes &lt;- cbind(1, contr.treatment(n = J))[, 1:N]
gamma &lt;- matrix(data = 0, nrow = J * M, ncol = M * N)
for(j in 1:J) {
  for(m in 1:M) {
    gamma[(m + M * (j - 1)), (((m - 1) * N + 1):((m - 1) * N + N))] &lt;-
    contrast_codes[j, ]
  }
}
lambda &lt;- matrix(data = 0, nrow = I * J, ncol = J * M)
lam_vals &lt;- rnorm(I, 1.5, .23)
for (j in 1:J) {
  lambda[(1 + (j - 1) * I):(j * I), (1 + (j - 1) * M):(j * M)] &lt;- lam_vals
}
zeta_mu &lt;- matrix(data = rep(x = 0, times = M * J), nrow = 1, ncol = J * M)
zeta_sigma2 &lt;- diag(x = 0.2, nrow = J * M, ncol = J * M)
nu &lt;- matrix(data = rnorm(n = I, mean = 0, sd = 2), nrow = I * J, ncol = 1)
set.seed(624)
ex4 &lt;- dich_response_sim(I = I, J = J, K = K, M = M, N = N,
                         omega_mu = omega_mu, omega_sigma2 = omega_sigma2,
                         gamma = gamma, lambda = lambda, nu = nu,
                         zeta_mu = zeta_mu, zeta_sigma2 = zeta_sigma2)

# Example 5

I &lt;- 20
J &lt;- 10
K &lt;- 1
M &lt;- 2
N &lt;- 2
omega_mu &lt;- matrix(data = c(2.50, -2.00, 0.50, 0.00), nrow = 1, ncol = M * N)
omega_sigma2 &lt;- diag(x = c(0.90, 0.70, 0.30, 0.10), nrow = M * N)
contrast_codes &lt;- cbind(1, contr.poly(n = J))[, 1:N]
gamma &lt;- matrix(data = 0, nrow = J * M, ncol = M * N)
for(j in 1:J) {
  for(m in 1:M) {
    gamma[(m + M * (j - 1)), (((m - 1) * N + 1):((m - 1) * N + N))] &lt;-
      contrast_codes[j, ]
  }
}
key &lt;- rbinom(n = I * J, size = 1, prob = .7) + 1
measure_weights &lt;-
  matrix(data = c(0.5, -1.0, 0.5, 1.0), nrow = 2, ncol = M, byrow = TRUE)
lambda &lt;- matrix(data = 0, nrow = I * J, ncol = J * M)
for(j in 1:J) {
  lambda[(1 + (j - 1) * I):(j * I), (1 + (j - 1) * M):(j * M)] &lt;-
    measure_weights[key, ][(1 + (j - 1) * I):(j * I), ]
}
zeta_mu &lt;- matrix(data = rep(x = 0, times = M * J), nrow = 1, ncol = J * M)
zeta_sigma2 &lt;- diag(x = 0.2, nrow = J * M, ncol = J * M)
nu_mu &lt;- matrix(data = c(0.00), nrow = 1, ncol = 1)
nu_sigma2 &lt;- matrix(data = c(0.20), nrow = 1, ncol = 1)
set.seed(624)
ex5 &lt;- dich_response_sim(I = I, J = J, K = K, M = M, N = N,
                         omega_mu = omega_mu, omega_sigma2 = omega_sigma2,
                         gamma = gamma, lambda = lambda, nu_mu = nu_mu,
                         nu_sigma2 = nu_sigma2, zeta_mu = zeta_mu,
                         zeta_sigma2 = zeta_sigma2, key = key)

</code></pre>

<hr>
<h2 id='ex1'>Simulated Data for a Unidimensional Two-Parameter Item Response Model</h2><span id='topic+ex1'></span>

<h3>Description</h3>

<p>Data and parameters were simulated based on example 1 provided for the
sim_dich_response.R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex1
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>ystar</dt><dd><p>Matrix of latent response variates.</p>
</dd>
<dt>omega</dt><dd><p>Subject-level effects of the experimental manipulation.</p>
</dd>
<dt>omega_mu</dt><dd><p>Vector of means for the subject-level effects of the
experimental manipulation (1 by K * M).</p>
</dd>
<dt>omega_sigma2</dt><dd><p>Covariance matrix for the subject-level effects of the
experimental manipulation (K * M by K * M).</p>
</dd>
<dt>gamma</dt><dd><p>Contrast codes matrix.</p>
</dd>
<dt>lambda</dt><dd><p>Matrix of item slope parameters.</p>
</dd>
<dt>lambda_mu</dt><dd><p>Vector of means for the item slope parameters
(1 by JM).</p>
</dd>
<dt>lambda_sigma2</dt><dd><p>Covariance matrix for the item slope parameters
(JM by JM).</p>
</dd>
<dt>nu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_mu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_sigma2</dt><dd><p>Variance of the item intercept parameters (scalar).</p>
</dd>
<dt>zeta</dt><dd><p>Condition-level prediction errors.</p>
</dd>
<dt>zeta_mu</dt><dd><p>Vector of means for the condition-level prediction errors
(1 by J * M).</p>
</dd>
<dt>zeta_sigma2</dt><dd><p>Covariance matrix for the condition-level prediction
errors (J * M by J * M).</p>
</dd>
<dt>kappa</dt><dd><p>Item guessing matrix  (K by IJ).</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
<dt>key</dt><dd><p>Item key vector where 1 indicates target and 2 indicates
distractor (IJ)</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='ex2'>Simulated Data for a Signal Detection Weighted IRT Model</h2><span id='topic+ex2'></span>

<h3>Description</h3>

<p>Data and parameters were simulated based on example 2 provided for the
sim_dich_response.R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex2
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>ystar</dt><dd><p>Matrix of latent response variates.</p>
</dd>
<dt>omega</dt><dd><p>Subject-level effects of the experimental manipulation.</p>
</dd>
<dt>omega_mu</dt><dd><p>Vector of means for the subject-level effects of the
experimental manipulation (1 by K * M).</p>
</dd>
<dt>omega_sigma2</dt><dd><p>Covariance matrix for the subject-level effects of the
experimental manipulation (K * M by K * M).</p>
</dd>
<dt>gamma</dt><dd><p>Contrast codes matrix.</p>
</dd>
<dt>lambda</dt><dd><p>Matrix of item slope parameters.</p>
</dd>
<dt>lambda_mu</dt><dd><p>Vector of means for the item slope parameters
(1 by JM).</p>
</dd>
<dt>lambda_sigma2</dt><dd><p>Covariance matrix for the item slope parameters
(JM by JM).</p>
</dd>
<dt>nu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_mu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_sigma2</dt><dd><p>Variance of the item intercept parameters (scalar).</p>
</dd>
<dt>zeta</dt><dd><p>Condition-level prediction errors.</p>
</dd>
<dt>zeta_mu</dt><dd><p>Vector of means for the condition-level prediction errors
(1 by J * M).</p>
</dd>
<dt>zeta_sigma2</dt><dd><p>Covariance matrix for the condition-level prediction
errors (J * M by J * M).</p>
</dd>
<dt>kappa</dt><dd><p>Item guessing matrix  (K by IJ).</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
<dt>key</dt><dd><p>Item key vector where 1 indicates target and 2 indicates
distractor (IJ)</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='ex3'>Simulated Data for a Signal Detection Weighted IRT Model with an Experimental
Design</h2><span id='topic+ex3'></span>

<h3>Description</h3>

<p>Data and parameters were simulated based on example 3 provided for the
sim_dich_response.R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex3
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>ystar</dt><dd><p>Matrix of latent response variates.</p>
</dd>
<dt>omega</dt><dd><p>Subject-level effects of the experimental manipulation.</p>
</dd>
<dt>omega_mu</dt><dd><p>Vector of means for the subject-level effects of the
experimental manipulation (1 by K * M).</p>
</dd>
<dt>omega_sigma2</dt><dd><p>Covariance matrix for the subject-level effects of the
experimental manipulation (K * M by K * M).</p>
</dd>
<dt>gamma</dt><dd><p>Contrast codes matrix.</p>
</dd>
<dt>lambda</dt><dd><p>Matrix of item slope parameters.</p>
</dd>
<dt>lambda_mu</dt><dd><p>Vector of means for the item slope parameters
(1 by JM).</p>
</dd>
<dt>lambda_sigma2</dt><dd><p>Covariance matrix for the item slope parameters
(JM by JM).</p>
</dd>
<dt>nu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_mu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_sigma2</dt><dd><p>Variance of the item intercept parameters (scalar).</p>
</dd>
<dt>zeta</dt><dd><p>Condition-level prediction errors.</p>
</dd>
<dt>zeta_mu</dt><dd><p>Vector of means for the condition-level prediction errors
(1 by J * M).</p>
</dd>
<dt>zeta_sigma2</dt><dd><p>Covariance matrix for the condition-level prediction
errors (J * M by J * M).</p>
</dd>
<dt>kappa</dt><dd><p>Item guessing matrix  (K by IJ).</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
<dt>key</dt><dd><p>Item key vector where 1 indicates target and 2 indicates
distractor (IJ)</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='ex4'>Simulated Data for a Unidimensional Two-Parameter Item Response Model
with Two Measurement Occasions</h2><span id='topic+ex4'></span>

<h3>Description</h3>

<p>Data and parameters were simulated based on example 4 provided for the
sim_dich_response.R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex4
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>ystar</dt><dd><p>Matrix of latent response variates.</p>
</dd>
<dt>omega</dt><dd><p>Subject-level effects of the experimental manipulation.</p>
</dd>
<dt>omega_mu</dt><dd><p>Vector of means for the subject-level effects of the
experimental manipulation (1 by K * M).</p>
</dd>
<dt>omega_sigma2</dt><dd><p>Covariance matrix for the subject-level effects of the
experimental manipulation (K * M by K * M).</p>
</dd>
<dt>gamma</dt><dd><p>Contrast codes matrix.</p>
</dd>
<dt>lambda</dt><dd><p>Matrix of item slope parameters.</p>
</dd>
<dt>lambda_mu</dt><dd><p>Vector of means for the item slope parameters
(1 by JM).</p>
</dd>
<dt>lambda_sigma2</dt><dd><p>Covariance matrix for the item slope parameters
(JM by JM).</p>
</dd>
<dt>nu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_mu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_sigma2</dt><dd><p>Variance of the item intercept parameters (scalar).</p>
</dd>
<dt>zeta</dt><dd><p>Condition-level prediction errors.</p>
</dd>
<dt>zeta_mu</dt><dd><p>Vector of means for the condition-level prediction errors
(1 by J * M).</p>
</dd>
<dt>zeta_sigma2</dt><dd><p>Covariance matrix for the condition-level prediction
errors (J * M by J * M).</p>
</dd>
<dt>kappa</dt><dd><p>Item guessing matrix  (K by IJ).</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
<dt>key</dt><dd><p>Item key vector where 1 indicates target and 2 indicates
distractor (IJ)</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='ex5'>Simulated Single Subject Data for a Signal Detection Weighted IRT Model with
an Experimental Design</h2><span id='topic+ex5'></span>

<h3>Description</h3>

<p>Data and parameters were simulated based on example 5 provided for the
sim_dich_response.R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex5
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>ystar</dt><dd><p>Matrix of latent response variates.</p>
</dd>
<dt>omega</dt><dd><p>Subject-level effects of the experimental manipulation.</p>
</dd>
<dt>omega_mu</dt><dd><p>Vector of means for the subject-level effects of the
experimental manipulation (1 by K * M).</p>
</dd>
<dt>omega_sigma2</dt><dd><p>Covariance matrix for the subject-level effects of the
experimental manipulation (K * M by K * M).</p>
</dd>
<dt>gamma</dt><dd><p>Contrast codes matrix.</p>
</dd>
<dt>lambda</dt><dd><p>Matrix of item slope parameters.</p>
</dd>
<dt>lambda_mu</dt><dd><p>Vector of means for the item slope parameters
(1 by JM).</p>
</dd>
<dt>lambda_sigma2</dt><dd><p>Covariance matrix for the item slope parameters
(JM by JM).</p>
</dd>
<dt>nu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_mu</dt><dd><p>Mean of the item intercept parameters (scalar).</p>
</dd>
<dt>nu_sigma2</dt><dd><p>Variance of the item intercept parameters (scalar).</p>
</dd>
<dt>zeta</dt><dd><p>Condition-level prediction errors.</p>
</dd>
<dt>zeta_mu</dt><dd><p>Vector of means for the condition-level prediction errors
(1 by J * M).</p>
</dd>
<dt>zeta_sigma2</dt><dd><p>Covariance matrix for the condition-level prediction
errors (J * M by J * M).</p>
</dd>
<dt>kappa</dt><dd><p>Item guessing matrix  (K by IJ).</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
<dt>key</dt><dd><p>Item key vector where 1 indicates target and 2 indicates
distractor (IJ)</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='flanker'>Flanker Data</h2><span id='topic+flanker'></span>

<h3>Description</h3>

<p>Flanker task accuracy data collected from an online experiment. The
condition vector indicates level of congruency (&quot;congruent, incongruent_part,
incongruent_all, neutral).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flanker
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
</dl>


<hr>
<h2 id='lrt'>Method of anova for cogirt S3</h2><span id='topic+lrt'></span>

<h3>Description</h3>

<p>This function compares fit of models produced by cogirt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrt(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lrt_+3A_object">object</code></td>
<td>
<p>An object of class 'cogirt'.</p>
</td></tr>
<tr><td><code id="lrt_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;anova&quot;.
</p>

<hr>
<h2 id='mhmc_mc'>MHMC Parameter Estimates for Multiple Chains</h2><span id='topic+mhmc_mc'></span>

<h3>Description</h3>

<p>This function calculates MHMC parameter estimates for multiple chains. See
documentation for mhmc_sc.R for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhmc_mc(
  chains = NULL,
  y = y,
  obj_fun = NULL,
  link = NULL,
  est_omega = TRUE,
  est_lambda = TRUE,
  est_zeta = TRUE,
  est_nu = TRUE,
  omega0 = NULL,
  gamma0 = NULL,
  lambda0 = NULL,
  zeta0 = NULL,
  nu0 = NULL,
  kappa0 = NULL,
  omega_mu = NULL,
  omega_sigma2 = NULL,
  lambda_mu = NULL,
  lambda_sigma2 = NULL,
  zeta_mu = NULL,
  zeta_sigma2 = NULL,
  nu_mu = NULL,
  nu_sigma2 = NULL,
  burn = NULL,
  thin = NULL,
  min_tune = NULL,
  tune_int = NULL,
  max_tune = NULL,
  niter = NULL,
  psrf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mhmc_mc_+3A_chains">chains</code></td>
<td>
<p>Number of chains in the MHMC sampler (scalar).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_y">y</code></td>
<td>
<p>Item response matrix (K by IJ).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_obj_fun">obj_fun</code></td>
<td>
<p>A function that calculates predictions and log-likelihood
values for the selected model (character).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_link">link</code></td>
<td>
<p>Choose between &quot;logit&quot; or &quot;probit&quot; link functions.</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_est_omega">est_omega</code></td>
<td>
<p>Determines whether omega is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_est_lambda">est_lambda</code></td>
<td>
<p>Determines whether nu is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_est_zeta">est_zeta</code></td>
<td>
<p>Determines whether zeta is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_est_nu">est_nu</code></td>
<td>
<p>Determines whether nu is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_omega0">omega0</code></td>
<td>
<p>Starting or known values for omega (K by MN).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_gamma0">gamma0</code></td>
<td>
<p>Starting or known values for gamma (JM by MN).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_lambda0">lambda0</code></td>
<td>
<p>Starting or known values for lambda (IJ by JM).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_zeta0">zeta0</code></td>
<td>
<p>Starting or known values for  zeta (K by JM).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_nu0">nu0</code></td>
<td>
<p>Starting or known values for nu (IJ by 1).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_kappa0">kappa0</code></td>
<td>
<p>Starting or known values for kappa (1 by IJ).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_omega_mu">omega_mu</code></td>
<td>
<p>Mean prior for omega (1 by MN).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_omega_sigma2">omega_sigma2</code></td>
<td>
<p>Covariance prior for omega (MN by MN).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_lambda_mu">lambda_mu</code></td>
<td>
<p>Mean prior for lambda (1 by JM)</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_lambda_sigma2">lambda_sigma2</code></td>
<td>
<p>Covariance prior for lambda (JM by JM)</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_zeta_mu">zeta_mu</code></td>
<td>
<p>Mean prior for zeta (1 by JM).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_zeta_sigma2">zeta_sigma2</code></td>
<td>
<p>Covariance prior for zeta (JM by JM).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_nu_mu">nu_mu</code></td>
<td>
<p>Mean prior for nu (1 by 1)</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_nu_sigma2">nu_sigma2</code></td>
<td>
<p>Covariance prior for nu (1 by 1)</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_burn">burn</code></td>
<td>
<p>Number of iterations at the beginning of an MCMC run to discard
(scalar).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_thin">thin</code></td>
<td>
<p>Determines every nth observation retained (scalar).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_min_tune">min_tune</code></td>
<td>
<p>Determines when tunning begins (scalar).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_tune_int">tune_int</code></td>
<td>
<p>MHMC tuning interval (scalar).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_max_tune">max_tune</code></td>
<td>
<p>Determines when tunning ends (scalar).</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_niter">niter</code></td>
<td>
<p>Number of iterations of the MHMC sampler.</p>
</td></tr>
<tr><td><code id="mhmc_mc_+3A_psrf">psrf</code></td>
<td>
<p>Estimate potential scale reduction factor (logical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements omega_draws (draws from every saved iteration of
the MHMC sampler), omegaEAP (expected a posteriori estimates for omega),
omegaPSD (posterior standard deviation estimates for omega), omega_psrf
(potential scale reduction factor for omega), nuEAP (expected a posteriori
estimates for nu), nuPSD (posterior standard deviation estimates for nu),
nu_psrf (potential scale reduction factor for nu), zetaEAP (expected a
posteriori estimates for zeta), zetaPSD (posterior standard deviation
estimates for zeta), zeta_psrf (potential scale reduction factor for zeta).
</p>

<hr>
<h2 id='mhmc_sc'>MHMC Parameter Estimates for Single Chain</h2><span id='topic+mhmc_sc'></span>

<h3>Description</h3>

<p>This function uses the Metropolis-Hastings algorithm for a single chain to
calculate parameter estimates using the Markov Chain Monte Carlo method. The
method implemented follows Patz and Junker (1999). The approach to tuning the
scale and covariance matrix follows BDA and SAS 9.2 User Guide,
2nd Ed. &quot;The MCMC Procedure: Tuning the Proposal Distribution&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhmc_sc(
  y = y,
  obj_fun = NULL,
  link = NULL,
  est_omega = TRUE,
  est_lambda = TRUE,
  est_zeta = TRUE,
  est_nu = TRUE,
  omega0 = NULL,
  gamma0 = NULL,
  lambda0 = NULL,
  zeta0 = NULL,
  nu0 = NULL,
  kappa0 = NULL,
  omega_mu = NULL,
  omega_sigma2 = NULL,
  lambda_mu = NULL,
  lambda_sigma2 = NULL,
  zeta_mu = NULL,
  zeta_sigma2 = NULL,
  nu_mu = NULL,
  nu_sigma2 = NULL,
  burn = NULL,
  thin = NULL,
  min_tune = NULL,
  tune_int = NULL,
  max_tune = NULL,
  niter = NULL,
  weight = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mhmc_sc_+3A_y">y</code></td>
<td>
<p>Item response matrix (K by IJ).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_obj_fun">obj_fun</code></td>
<td>
<p>A function that calculates predictions and log-likelihood
values for the selected model (character).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_link">link</code></td>
<td>
<p>Choose between &quot;logit&quot; or &quot;probit&quot; link functions.</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_est_omega">est_omega</code></td>
<td>
<p>Determines whether omega is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_est_lambda">est_lambda</code></td>
<td>
<p>Determines whether nu is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_est_zeta">est_zeta</code></td>
<td>
<p>Determines whether zeta is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_est_nu">est_nu</code></td>
<td>
<p>Determines whether nu is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_omega0">omega0</code></td>
<td>
<p>Starting or known values for omega (K by MN).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_gamma0">gamma0</code></td>
<td>
<p>Starting or known values for gamma (JM by MN).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_lambda0">lambda0</code></td>
<td>
<p>Starting or known values for lambda (IJ by JM).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_zeta0">zeta0</code></td>
<td>
<p>Starting or known values for  zeta (K by JM).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_nu0">nu0</code></td>
<td>
<p>Starting or known values for nu (IJ by 1).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_kappa0">kappa0</code></td>
<td>
<p>Starting or known values for kappa (K by IJ).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_omega_mu">omega_mu</code></td>
<td>
<p>Mean prior for omega (1 by MN).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_omega_sigma2">omega_sigma2</code></td>
<td>
<p>Covariance prior for omega (MN by MN).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_lambda_mu">lambda_mu</code></td>
<td>
<p>Mean prior for lambda (1 by JM)</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_lambda_sigma2">lambda_sigma2</code></td>
<td>
<p>Covariance prior for lambda (JM by JM)</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_zeta_mu">zeta_mu</code></td>
<td>
<p>Mean prior for zeta (1 by JM).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_zeta_sigma2">zeta_sigma2</code></td>
<td>
<p>Covariance prior for zeta (JM by JM).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_nu_mu">nu_mu</code></td>
<td>
<p>Mean prior for nu (1 by 1).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_nu_sigma2">nu_sigma2</code></td>
<td>
<p>Covariance prior for nu (1 by 1).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_burn">burn</code></td>
<td>
<p>Number of iterations at the beginning of an MCMC run to discard
(scalar).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_thin">thin</code></td>
<td>
<p>Determines every nth observation retained (scalar).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_min_tune">min_tune</code></td>
<td>
<p>Determines when tunning begins (scalar).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_tune_int">tune_int</code></td>
<td>
<p>MHMC tuning interval (scalar).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_max_tune">max_tune</code></td>
<td>
<p>Determines when tunning ends (scalar).</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_niter">niter</code></td>
<td>
<p>Number of iterations of the MHMC sampler.</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_weight">weight</code></td>
<td>
<p>Determines the weight of old versus new covariance matrix.</p>
</td></tr>
<tr><td><code id="mhmc_sc_+3A_verbose">verbose</code></td>
<td>
<p>Print progress of MHMC sampler.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements omega_draws (list of (niter - burn) / thin draws
for K by MN omega matrix), lambda_draws (list of (niter - burn) / thin draws
for IJ by JM lambda matrix), zeta_draws (list of (niter - burn) / thin draws
for K by JM zeta matrix), nu_draws (list of (niter - burn) / thin draws
for IJ by 1 nu matrix), cand_o_var (list of K final MN by MN candidate
proposal covariance matrices for omega for each examinee), cand_l_var (list
of IJ final JM by JM candidate proposal covariance matrices for lambda for
each item), cand_z_var (list of final JM by JM candidate proposal covariance
matrices for zeta for all examinees), and cand_n_var (list of IJ final scalar
candidate proposal variances for nu for all items).
</p>


<h3>References</h3>

<p>Patz, R. J., &amp; Junker, B. W. (1999). A Straightforward Approach to Markov
Chain Monte Carlo Methods for Item Response Models. Journal of Educational
and Behavioral Statistics, 24(2), 146.
</p>

<hr>
<h2 id='mhrm'>MHRM Parameter Estimates for Multiple Chains</h2><span id='topic+mhrm'></span>

<h3>Description</h3>

<p>This function calculates mhrm parameter estimates for multiple chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhrm(
  y = y,
  obj_fun = NULL,
  link = NULL,
  est_omega = TRUE,
  est_lambda = TRUE,
  est_zeta = TRUE,
  est_nu = TRUE,
  omega0 = NULL,
  gamma0 = NULL,
  lambda0 = NULL,
  zeta0 = NULL,
  nu0 = NULL,
  kappa0 = NULL,
  omega_mu = NULL,
  omega_sigma2 = NULL,
  lambda_mu = NULL,
  lambda_sigma2 = NULL,
  zeta_mu = NULL,
  zeta_sigma2 = NULL,
  nu_mu = NULL,
  nu_sigma2 = NULL,
  constraints = NULL,
  J = NULL,
  M = NULL,
  N = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mhrm_+3A_y">y</code></td>
<td>
<p>Item response matrix (K by IJ).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_obj_fun">obj_fun</code></td>
<td>
<p>A function that calculates predictions and log-likelihood
values for the selected model (character).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_link">link</code></td>
<td>
<p>Choose between &quot;logit&quot; or &quot;probit&quot; link functions.</p>
</td></tr>
<tr><td><code id="mhrm_+3A_est_omega">est_omega</code></td>
<td>
<p>Determines whether omega is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_est_lambda">est_lambda</code></td>
<td>
<p>Determines whether lambda is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_est_zeta">est_zeta</code></td>
<td>
<p>Determines whether zeta is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_est_nu">est_nu</code></td>
<td>
<p>Determines whether nu is estimated (logical).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_omega0">omega0</code></td>
<td>
<p>Starting values for omega.</p>
</td></tr>
<tr><td><code id="mhrm_+3A_gamma0">gamma0</code></td>
<td>
<p>Either a matrix of contrast codes (JM by MN)
or the name in quotes of the desired R stats contrast function (i.e.,
&quot;contr.helmert&quot;, &quot;contr.poly&quot;, &quot;contr.sum&quot;, &quot;contr.treatment&quot;, or
&quot;contr.SAS&quot;). If using the R stats contrast function the user must also
specify J, M, and N, as well as ensure that items in y are arranged so that
the first set of I items correspond to the first level if the contrast, the
next set of I items correspond to the second level of the contrast, etc. For
example, in an experiment with two conditions (i.e., J = 2) where the user
requests two contrasts (i.e., N = 2) from the &quot;contr.treatment&quot; function, the
first set of I items will all receive a contrast code of 0 and the second set
of I items will all receive a contrast code of 1. In an experiment with three
conditions (i.e., J = 3) where the user requests three contrasts (i.e.,
N = 3) from the &quot;contr.poly&quot; function, first set of I items will receive the
lowest value code for linear and quadratic contrasts, the second set of I
items will all receive the middle value code for linear and quadratic
contrasts, and the last set of I items will all receive the highest value
code for linear and quadratic contrasts.</p>
</td></tr>
<tr><td><code id="mhrm_+3A_lambda0">lambda0</code></td>
<td>
<p>Item slope matrix (IJ by JM).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_zeta0">zeta0</code></td>
<td>
<p>Starting values for zeta.</p>
</td></tr>
<tr><td><code id="mhrm_+3A_nu0">nu0</code></td>
<td>
<p>Starting values for nu (IJ by 1).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_kappa0">kappa0</code></td>
<td>
<p>Item guessing matrix  (IJ by 1).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_omega_mu">omega_mu</code></td>
<td>
<p>Vector of means prior for omega (1 by MN).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_omega_sigma2">omega_sigma2</code></td>
<td>
<p>Covariance matrix prior for omega (MN by MN).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_lambda_mu">lambda_mu</code></td>
<td>
<p>Mean prior for lambda (1 by JM)</p>
</td></tr>
<tr><td><code id="mhrm_+3A_lambda_sigma2">lambda_sigma2</code></td>
<td>
<p>Covariance prior for lambda (JM by JM)</p>
</td></tr>
<tr><td><code id="mhrm_+3A_zeta_mu">zeta_mu</code></td>
<td>
<p>Vector of means prior for zeta (1 by JM).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_zeta_sigma2">zeta_sigma2</code></td>
<td>
<p>Covariance matrix prior for zeta (JM by JM).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_nu_mu">nu_mu</code></td>
<td>
<p>Prior mean for nu (scalar).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_nu_sigma2">nu_sigma2</code></td>
<td>
<p>Prior variance for nu (scalar).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_constraints">constraints</code></td>
<td>
<p>Item parameter constraints.</p>
</td></tr>
<tr><td><code id="mhrm_+3A_j">J</code></td>
<td>
<p>Number of conditions (required if using the R stats contrast
function).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_m">M</code></td>
<td>
<p>Number of ability (or trait) dimensions (required if using the R
stats contrast function).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_n">N</code></td>
<td>
<p>Number of contrasts including intercept (required if using the R
stats contrast function).</p>
</td></tr>
<tr><td><code id="mhrm_+3A_verbose">verbose</code></td>
<td>
<p>Logical (TRUE or FALSE) indicating whether to print progress.</p>
</td></tr>
<tr><td><code id="mhrm_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements for all parameters estimated, information values
for all parameters estimated, and the model log-likelihood value.
</p>


<h3>References</h3>

<p>Cai, L. (2010). High-dimensional exploratory item factor analysis by a
Metropolis-Hastings Robbins-Monro algorithm. <em>Psychometrika, 75(1)</em>,
33-57.
</p>
<p>Cai, L. (2010). Metropolis-Hastings Robbins-Monro algorithm for confirmatory
item factor analysis. <em>Journal of Educational and Behavioral Statistics,
35(3)</em>, 307-335.
</p>

<hr>
<h2 id='nback'>N-Back Data</h2><span id='topic+nback'></span>

<h3>Description</h3>

<p>N-Back task accuracy data collected from an online experiment. The condition
vector indicates working memory load level (1-back, 2-back, 3-back, or
4-back). The key indicates whether items are targets (1) or distractors (2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nback
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>key</dt><dd><p>Item key vector where 1 indicates target and 2 indicates
distractor (IJ)</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
</dl>


<hr>
<h2 id='plot.cog_cat_sim'>Method of Plot for Simulated Adaptive Testing Using cogirt S3</h2><span id='topic+plot.cog_cat_sim'></span>

<h3>Description</h3>

<p>This function produces plots for standard errors for
cog_cat_sim results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cog_cat_sim'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cog_cat_sim_+3A_x">x</code></td>
<td>
<p>An object of class 'cog_cat_sim'.</p>
</td></tr>
<tr><td><code id="plot.cog_cat_sim_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a base R plot displayed in the graphics device.
It does not return any value to the R environment.
</p>

<hr>
<h2 id='plot.cog_irt'>Method of Plot for cogirt S3</h2><span id='topic+plot.cog_irt'></span>

<h3>Description</h3>

<p>This function produces plots for parameter estimates produced for various
cogirt models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cog_irt'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cog_irt_+3A_x">x</code></td>
<td>
<p>An x of class 'cog_irt'.</p>
</td></tr>
<tr><td><code id="plot.cog_irt_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a base R plot displayed in the graphics device.
It does not return any value to the R environment.
</p>

<hr>
<h2 id='plt'>PLT Data</h2><span id='topic+plt'></span>

<h3>Description</h3>

<p>Probabilistic Learning Task (SOPT) accuracy data collected from an online
experiment. The condition vector indicates feedback consistency (90
70
vector indicates which side was rewarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>targ</dt><dd><p>Item targ left vs. right vector (IJ)</p>
</dd>
<dt>fdbk</dt><dd><p>Item fdbk left vs. right vector (IJ)</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
</dl>


<hr>
<h2 id='sopt'>SOPT Data</h2><span id='topic+sopt'></span>

<h3>Description</h3>

<p>Self-Ordered Pointing Task (SOPT) accuracy data collected from an online
experiment. The condition vector indicates working memory load level (3, 6,
9, or 12 items).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sopt
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
</dl>


<hr>
<h2 id='sternberg'>Sternberg Data</h2><span id='topic+sternberg'></span>

<h3>Description</h3>

<p>Sternberg task accuracy data collected from an online experiment. The
condition vector indicates working memory load level (2, 4, 6, 8, 10, or 12
items).The key indicates whether items are targets (1) or distractors (2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sternberg
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>y</dt><dd><p>Matrix of dichotomous responses.</p>
</dd>
<dt>key</dt><dd><p>Item key vector where 1 indicates target and 2 indicates
distractor (IJ)</p>
</dd>
<dt>condition</dt><dd><p>Condition vector indiciting distinct conditions or time
points.</p>
</dd>
</dl>


<hr>
<h2 id='summary.cog_cat_sim'>Method of Summary for cog_cat_sim S3</h2><span id='topic+summary.cog_cat_sim'></span>

<h3>Description</h3>

<p>This function provides summary statistics for simulated computerized adaptive
testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cog_cat_sim'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cog_cat_sim_+3A_object">object</code></td>
<td>
<p>An object of class 'cog_cat_sim'.</p>
</td></tr>
<tr><td><code id="summary.cog_cat_sim_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return a value to the R environment. Instead,
it prints a comprehensive summary of the simulated computerized adaptive
testing results to the console. The output includes model name and simulation
settings as well as summary statistics for each parameter of interest. The
function is intended for interactive use.
</p>

<hr>
<h2 id='summary.cog_irt'>Method of Summary for cog_irt S3</h2><span id='topic+summary.cog_irt'></span>

<h3>Description</h3>

<p>This function provides summary statistics for cogirt models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cog_irt'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cog_irt_+3A_object">object</code></td>
<td>
<p>An object of class 'cog_irt'.</p>
</td></tr>
<tr><td><code id="summary.cog_irt_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return a value to the R environment. Instead,
it prints a detailed summary of the specified IRT model to the console. The
output includes the type of IRT model (e.g., One-Parameter, Two-Parameter,
etc.), the number of subjects and items in the dataset, the log-likelihood of
the model, and summary statistics (mean, standard deviation, median standard
error, and reliability) for estimated parameters. The function is intended
for interactive use to review the results of the fitted model.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
