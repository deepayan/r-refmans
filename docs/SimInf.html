<!DOCTYPE html><html><head><title>Help for package SimInf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimInf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SimInf'><p>A Framework for Data-Driven Stochastic Disease Spread Simulations</p></a></li>
<li><a href='#abc'><p>Approximate Bayesian computation</p></a></li>
<li><a href='#as.data.frame.SimInf_abc'><p>Coerce to data frame</p></a></li>
<li><a href='#as.data.frame.SimInf_events'><p>Coerce events to a data frame</p></a></li>
<li><a href='#as.data.frame.SimInf_indiv_events'><p>Coerce to data frame</p></a></li>
<li><a href='#boxplot,SimInf_model-method'><p>Box plot of number of individuals in each compartment</p></a></li>
<li><a href='#C_code'><p>Extract the C code from a <code>SimInf_model</code> object</p></a></li>
<li><a href='#continue'><p>Run more generations of ABC SMC</p></a></li>
<li><a href='#distance_matrix'><p>Create a distance matrix between nodes for spatial models</p></a></li>
<li><a href='#edge_properties_to_matrix'><p>Convert an edge list with properties to a matrix</p></a></li>
<li><a href='#events'><p>Extract the events from a <code>SimInf_model</code> object</p></a></li>
<li><a href='#events_SEIR'><p>Example data to initialize events for the &lsquo;SEIR&rsquo; model</p></a></li>
<li><a href='#events_SIR'><p>Example data to initialize events for the &lsquo;SIR&rsquo; model</p></a></li>
<li><a href='#events_SIS'><p>Example data to initialize events for the &lsquo;SIS&rsquo; model</p></a></li>
<li><a href='#events_SISe'><p>Example data to initialize events for the &lsquo;SISe&rsquo; model</p></a></li>
<li><a href='#events_SISe3'><p>Example data to initialize events for the &lsquo;SISe3&rsquo; model</p></a></li>
<li><a href='#gdata'><p>Extract global data from a <code>SimInf_model</code> object</p></a></li>
<li><a href='#gdata&lt;-'><p>Set a global data parameter for a <code>SimInf_model</code> object</p></a></li>
<li><a href='#get_individuals'><p>Extract individuals from <code>SimInf_indiv_events</code></p></a></li>
<li><a href='#indegree'><p>Determine in-degree for each node in a model</p></a></li>
<li><a href='#individual_events'><p>Individual events</p></a></li>
<li><a href='#ldata'><p>Extract local data from a node</p></a></li>
<li><a href='#logLik,SimInf_pfilter-method'><p>Log likelihood</p></a></li>
<li><a href='#mparse'><p>Model parser to define new models to run in <code>SimInf</code></p></a></li>
<li><a href='#n_generations'><p>Determine the number of generations</p></a></li>
<li><a href='#n_nodes'><p>Determine the number of nodes in a model</p></a></li>
<li><a href='#nodes'><p>Example data with spatial distribution of nodes</p></a></li>
<li><a href='#outdegree'><p>Determine out-degree for each node in a model</p></a></li>
<li><a href='#package_skeleton'><p>Create a package skeleton from a <code>SimInf_model</code></p></a></li>
<li><a href='#pairs,SimInf_model-method'><p>Scatterplot of number of individuals in each compartment</p></a></li>
<li><a href='#pfilter'><p>Bootstrap particle filter</p></a></li>
<li><a href='#plot,SimInf_abc-method'><p>Display the ABC posterior distribution</p></a></li>
<li><a href='#plot,SimInf_events-method'><p>Display the distribution of scheduled events over time</p></a></li>
<li><a href='#plot,SimInf_indiv_events-method'><p>Display the distribution of individual events over time</p></a></li>
<li><a href='#plot,SimInf_model-method'><p>Display the outcome from a simulated trajectory</p></a></li>
<li><a href='#plot,SimInf_pfilter-method'><p>Diagnostic plot of a particle filter object</p></a></li>
<li><a href='#prevalence'><p>Generic function to calculate prevalence from trajectory data</p></a></li>
<li><a href='#prevalence,SimInf_model-method'><p>Calculate prevalence from a model object with trajectory data</p></a></li>
<li><a href='#punchcard&lt;-'><p>Set a template for where to record result during a simulation</p></a></li>
<li><a href='#run'><p>Run the SimInf stochastic simulation algorithm</p></a></li>
<li><a href='#SEIR'><p>Create an <abbr><span class="acronym">SEIR</span></abbr> model</p></a></li>
<li><a href='#SEIR-class'><p>Definition of the &lsquo;SEIR&rsquo; model</p></a></li>
<li><a href='#select_matrix'><p>Extract the select matrix from a <code>SimInf_model</code> object</p></a></li>
<li><a href='#select_matrix&lt;-'><p>Set the select matrix for a <code>SimInf_model</code> object</p></a></li>
<li><a href='#set_num_threads'><p>Specify the number of threads that SimInf should use</p></a></li>
<li><a href='#shift_matrix'><p>Extract the shift matrix from a <code>SimInf_model</code> object</p></a></li>
<li><a href='#shift_matrix&lt;-'><p>Set the shift matrix for a <code>SimInf_model</code> object</p></a></li>
<li><a href='#show,SimInf_abc-method'><p>Print summary of a <code>SimInf_abc</code> object</p></a></li>
<li><a href='#show,SimInf_events-method'><p>Brief summary of <code>SimInf_events</code></p></a></li>
<li><a href='#show,SimInf_indiv_events-method'><p>Print summary of a <code>SimInf_indiv_events</code> object</p></a></li>
<li><a href='#show,SimInf_model-method'><p>Brief summary of <code>SimInf_model</code></p></a></li>
<li><a href='#show,SimInf_pfilter-method'><p>Brief summary of a <code>SimInf_pfilter</code> object</p></a></li>
<li><a href='#SimInf_abc-class'><p>Class <code>"SimInf_abc"</code></p></a></li>
<li><a href='#SimInf_events'><p>Create a <code>SimInf_events</code> object</p></a></li>
<li><a href='#SimInf_events-class'><p>Class <code>"SimInf_events"</code></p></a></li>
<li><a href='#SimInf_indiv_events-class'><p>Class <code>"SimInf_indiv_events"</code></p></a></li>
<li><a href='#SimInf_model'><p>Create a <code>SimInf_model</code></p></a></li>
<li><a href='#SimInf_model-class'><p>Class <code>"SimInf_model"</code></p></a></li>
<li><a href='#SimInf_pfilter-class'><p>Class <code>"SimInf_pfilter"</code></p></a></li>
<li><a href='#SIR'><p>Create an <abbr><span class="acronym">SIR</span></abbr> model</p></a></li>
<li><a href='#SIR-class'><p>Definition of the <abbr><span class="acronym">SIR</span></abbr> model</p></a></li>
<li><a href='#SIS'><p>Create an <abbr><span class="acronym">SIS</span></abbr> model</p></a></li>
<li><a href='#SIS-class'><p>Definition of the <abbr><span class="acronym">SIS</span></abbr> model</p></a></li>
<li><a href='#SISe'><p>Create a SISe model</p></a></li>
<li><a href='#SISe_sp'><p>Create a <code>SISe_sp</code> model</p></a></li>
<li><a href='#SISe_sp-class'><p>Definition of the <code>SISe_sp</code> model</p></a></li>
<li><a href='#SISe-class'><p>Definition of the <code>SISe</code> model</p></a></li>
<li><a href='#SISe3'><p>Create a <code>SISe3</code> model</p></a></li>
<li><a href='#SISe3_sp'><p>Create an <code>SISe3_sp</code> model</p></a></li>
<li><a href='#SISe3_sp-class'><p>Definition of the &lsquo;SISe3_sp&rsquo; model</p></a></li>
<li><a href='#SISe3-class'><p>Definition of the &lsquo;SISe3&rsquo; model</p></a></li>
<li><a href='#summary,SimInf_abc-method'><p>Detailed summary of a <code>SimInf_abc</code> object</p></a></li>
<li><a href='#summary,SimInf_events-method'><p>Detailed summary of a <code>SimInf_events</code> object</p></a></li>
<li><a href='#summary,SimInf_indiv_events-method'><p>Detailed summary of a <code>SimInf_indiv_events</code> object</p></a></li>
<li><a href='#summary,SimInf_model-method'><p>Detailed summary of a <code>SimInf_model</code> object</p></a></li>
<li><a href='#summary,SimInf_pfilter-method'><p>Detailed summary of a <code>SimInf_pfilter</code> object</p></a></li>
<li><a href='#trajectory'><p>Generic function to extract data from a simulated trajectory</p></a></li>
<li><a href='#trajectory,SimInf_model-method'><p>Extract data from a simulated trajectory</p></a></li>
<li><a href='#trajectory,SimInf_pfilter-method'><p>Extract filtered trajectory from running a particle filter</p></a></li>
<li><a href='#u0'><p>Get the initial compartment state</p></a></li>
<li><a href='#u0_SEIR'><p>Example data to initialize the &lsquo;SEIR&rsquo; model</p></a></li>
<li><a href='#u0_SIR'><p>Example data to initialize the &lsquo;SIR&rsquo; model</p></a></li>
<li><a href='#u0_SIS'><p>Example data to initialize the &lsquo;SIS&rsquo; model</p></a></li>
<li><a href='#u0_SISe'><p>Example data to initialize the &lsquo;SISe&rsquo; model</p></a></li>
<li><a href='#u0_SISe3'><p>Example data to initialize the &lsquo;SISe3&rsquo; model</p></a></li>
<li><a href='#u0&lt;-'><p>Update the initial compartment state u0 in each node</p></a></li>
<li><a href='#v0&lt;-'><p>Update the initial continuous state v0 in each node</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Framework for Data-Driven Stochastic Disease Spread
Simulations</td>
</tr>
<tr>
<td>Version:</td>
<td>9.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an efficient and very flexible framework to
    conduct data-driven epidemiological modeling in realistic large
    scale disease spread simulations. The framework integrates
    infection dynamics in subpopulations as continuous-time Markov
    chains using the Gillespie stochastic simulation algorithm and
    incorporates available data such as births, deaths and movements
    as scheduled events at predefined time-points. Using C code for
    the numerical solvers and 'OpenMP' (if available) to divide work
    over multiple processors ensures high performance when simulating
    a sample outcome. One of our design goals was to make the package
    extendable and enable usage of the numerical solvers from other R
    extension packages in order to facilitate complex epidemiological
    research. The package contains template models and can be extended
    with user-defined models. For more details see the paper by
    Widgren, Bauer, Eriksson and Engblom (2019)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v091.i12">doi:10.18637/jss.v091.i12</a>&gt;. The package also provides
    functionality to fit models to time series data using the
    Approximate Bayesian Computation Sequential Monte Carlo
    ('ABC-SMC') algorithm of Toni and others (2009)
    &lt;<a href="https://doi.org/10.1098%2Frsif.2008.0172">doi:10.1098/rsif.2008.0172</a>&gt;.</td>
</tr>
<tr>
<td>Acknowledgements:</td>
<td>This software has been made possible by support from
the Swedish Research Council within the UPMARC Linnaeus center
of Excellence (Pavol Bauer, Robin Eriksson, and Stefan
Engblom), the Swedish Research Council Formas (Stefan Engblom
and Stefan Widgren), the Swedish Board of Agriculture (Stefan
Widgren), the Swedish strategic research program eSSENCE
(Stefan Widgren), and in the framework of the Full Force
project, supported by funding from the European Union’s Horizon
2020 Research and Innovation programme under grant agreement No
773830: One Health European Joint Programme (Stefan Widgren).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stewid/SimInf">https://github.com/stewid/SimInf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stewid/SimInf/issues">https://github.com/stewid/SimInf/issues</a></td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU Scientific Library (GSL)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, graphics, grDevices, MASS, methods, stats, utils,
Matrix (&ge; 1.3-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Collate:</td>
<td>'C-generator.R' 'check_arguments.R' 'init.R' 'valid.R'
'classes.R' 'SimInf_model.R' 'SEIR.R' 'SIR.R' 'SIS.R' 'SISe.R'
'SISe3.R' 'SISe3_sp.R' 'SISe_sp.R' 'SimInf-package.R'
'SimInf.R' 'SimInf_events.R' 'SimInf_indiv_events.R' 'run.R'
'density_ratio.R' 'abc.R' 'degree.R' 'distance.R'
'distributions.R' 'edge_properties.R' 'match_compartments.R'
'mparse.R' 'n.R' 'openmp.R' 'package_skeleton.R' 'pfilter.R'
'plot.R' 'prevalence.R' 'print.R' 'punchcard.R' 'trajectory.R'
'u0.R' 'v0.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>utils, knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-20 13:32:03 UTC; stefan</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Widgren <a href="https://orcid.org/0000-0001-5745-2284"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Robin Eriksson <a href="https://orcid.org/0000-0002-4291-712X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Stefan Engblom <a href="https://orcid.org/0000-0002-3614-1732"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Pavol Bauer <a href="https://orcid.org/0000-0003-4328-7171"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Thomas Rosendal <a href="https://orcid.org/0000-0002-6576-9668"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ivana Rodriguez Ewerlöf
    <a href="https://orcid.org/0000-0002-9678-9813"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Attractive Chaos [cph] (Author of 'kvec.h'.)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Widgren &lt;stefan.widgren@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-20 13:50:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='SimInf'>A Framework for Data-Driven Stochastic Disease Spread Simulations</h2><span id='topic+SimInf'></span><span id='topic+SimInf-package'></span>

<h3>Description</h3>

<p>The SimInf package provides a flexible framework for data-driven
spatio-temporal disease spread modeling, designed to efficiently
handle population demographics and network data. The framework
integrates infection dynamics in each subpopulation as
continuous-time Markov chains (CTMC) using the Gillespie
stochastic simulation algorithm (SSA) and incorporates available
data such as births, deaths or movements as scheduled events. A
scheduled event is used to modify the state of a subpopulation at
a predefined time-point.
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+SimInf_model-class">SimInf_model</a></code> is central and provides the
basis for the framework. A <code><a href="#topic+SimInf_model-class">SimInf_model</a></code>
object supplies the state-change matrix, the dependency graph, the
scheduled events, and the initial state of the system.
</p>
<p>All predefined models in SimInf have a generating function, with
the same name as the model, for example <code><a href="#topic+SIR">SIR</a></code>.
</p>
<p>A model can also be created from a model specification using the
<code><a href="#topic+mparse">mparse</a></code> method.
</p>
<p>After a model is created, a simulation is started with a call to
the <code><a href="#topic+run">run</a></code> method and if execution is successful, it
returns a modified <code><a href="#topic+SimInf_model-class">SimInf_model</a></code> object with a
single stochastic solution trajectory attached to it.
</p>
<p>SimInf provides several utility functions to inspect simulated
data, for example, <code>show</code>, <code>summary</code> and <code>plot</code>.
To facilitate custom analysis, it provides the
<code><a href="#topic+trajectory+2CSimInf_model-method">trajectory,SimInf_model-method</a></code> and
<code><a href="#topic+prevalence">prevalence</a></code> methods.
</p>
<p>One of our design goal was to make SimInf extendable and enable
usage of the numerical solvers from other R extension packages in
order to facilitate complex epidemiological research.  To support
this, SimInf has functionality to generate the required C and R
code from a model specification, see
<code><a href="#topic+package_skeleton">package_skeleton</a></code>
</p>


<h3>References</h3>

<p>S. Widgren, P. Bauer, R. Eriksson and S. Engblom. <span class="pkg">SimInf</span>: An R Package for Data-Driven Stochastic Disease Spread Simulations. <em>Journal of Statistical Software</em>, <strong>91</strong>(12), 1&ndash;42. <a href="https://doi.org/10.18637/jss.v091.i12">doi:10.18637/jss.v091.i12</a>. An updated version of this paper is available as a vignette in the package.
</p>

<hr>
<h2 id='abc'>Approximate Bayesian computation</h2><span id='topic+abc'></span><span id='topic+abc+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Approximate Bayesian computation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abc(
  model,
  priors = NULL,
  npart = NULL,
  ninit = NULL,
  distance = NULL,
  tolerance = NULL,
  ...,
  verbose = getOption("verbose", FALSE),
  post_gen = NULL
)

## S4 method for signature 'SimInf_model'
abc(
  model,
  priors = NULL,
  npart = NULL,
  ninit = NULL,
  distance = NULL,
  tolerance = NULL,
  ...,
  verbose = getOption("verbose", FALSE),
  post_gen = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abc_+3A_model">model</code></td>
<td>
<p>The <code>SimInf_model</code> object to generate data from.</p>
</td></tr>
<tr><td><code id="abc_+3A_priors">priors</code></td>
<td>
<p>The priors for the parameters to fit. Each prior is
specified with a formula notation, for example, <code>beta ~
uniform(0, 1)</code> specifies that beta is uniformly distributed
between 0 and 1. Use <code>c()</code> to provide more than one
prior, for example, <code>c(beta ~ uniform(0, 1), gamma ~
normal(10, 1))</code>. The following distributions are supported:
<code>gamma</code>, <code>normal</code> and <code>uniform</code>. All parameters
in <code>priors</code> must be only in either <code>gdata</code> or
<code>ldata</code>.</p>
</td></tr>
<tr><td><code id="abc_+3A_npart">npart</code></td>
<td>
<p>An integer <code>(&gt;1)</code> specifying the number of
particles to approximate the posterior with.</p>
</td></tr>
<tr><td><code id="abc_+3A_ninit">ninit</code></td>
<td>
<p>Specify a positive integer (&gt;<code>npart</code>) to
adaptively select a sequence of tolerances using the algorithm
of Simola and others (2021). The initial tolerance is
adaptively selected by sampling <code>ninit</code> draws from the
prior and then retain the <code>npart</code> particles with the
smallest distances. Note there must be enough initial
particles to satisfactorily explore the parameter space, see
Simola and others (2021). If the <code>tolerance</code> parameter is
specified, then <code>ninit</code> must be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="abc_+3A_distance">distance</code></td>
<td>
<p>A function for calculating the summary statistics
for a simulated trajectory. For each particle, the function
must determine the distance and return that information. The
first argument, <code>result</code>, passed to the <code>distance</code>
function is the result from a <code>run</code> of the model with one
trajectory attached to it. The second argument,
<code>generation</code>, to <code>distance</code> is an integer with the
generation of the particle(s). Further arguments that can
passed to the <code>distance</code> function comes from <code>...</code>
in the <code>abc</code> function. Depending on the underlying model
structure, data for one or more particles have been generated
in each call to <code>distance</code>. If the <code>model</code> only
contains one node and all the parameters to fit are in
<code>ldata</code>, then that node will be replicated and each of
the replicated nodes represent one particle in the trajectory
(see &lsquo;Examples&rsquo;). On the other hand if the model
contains multiple nodes or the parameters to fit are contained
in <code>gdata</code>, then the trajectory in the <code>result</code>
argument represents one particle. The function can return a
numeric matrix (number of particles <code class="reqn">\times</code> number of
summary statistics). Or, if the distance contains one summary
statistic, a numeric vector with the length equal to the
number of particles. Note that when using adaptive tolerance
selection, only one summary statistic can be used, i.e., the
function must return a matrix (number of particles
<code class="reqn">\times</code> 1) or a numeric vector.</p>
</td></tr>
<tr><td><code id="abc_+3A_tolerance">tolerance</code></td>
<td>
<p>A numeric matrix (number of summary statistics
<code class="reqn">\times</code> number of generations) where each column contains
the tolerances for a generation and each row contains a
sequence of gradually decreasing tolerances. Can also be a
numeric vector if there is only one summary statistic. The
tolerance determines the number of generations of ABC-SMC to
run. If the <code>ninit</code> parameter is specified, then
<code>tolerance</code> must be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="abc_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fn</code>.</p>
</td></tr>
<tr><td><code id="abc_+3A_verbose">verbose</code></td>
<td>
<p>prints diagnostic messages when <code>TRUE</code>. The
default is to retrieve the global option <code>verbose</code> and
use <code>FALSE</code> if it is not set.</p>
</td></tr>
<tr><td><code id="abc_+3A_post_gen">post_gen</code></td>
<td>
<p>An optional function that, if non-NULL, is applied
after each completed generation. The function must accept one
argument of type <code>SimInf_abc</code> with the current state of
the fitting process. This function can be useful to, for
example, save and inspect intermediate results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SimInf_abc</code> object.
</p>


<h3>References</h3>

<p>T. Toni, D. Welch, N. Strelkowa, A. Ipsen, and M. P. H. Stumpf. Approximate Bayesian computation scheme for parameter inference and model selection in dynamical systems. <em>Journal of the Royal Society Interface</em> <strong>6</strong>, 187&ndash;202, 2009. <a href="https://doi.org/10.1098/rsif.2008.0172">doi:10.1098/rsif.2008.0172</a>
</p>
<p>U. Simola, J. Cisewski-Kehe, M. U. Gutmann, J. Corander. Adaptive Approximate Bayesian Computation Tolerance Selection. <em>Bayesian Analysis</em>, <strong>16</strong>(2), 397&ndash;423, 2021. doi: 10.1214/20-BA1211
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Let us consider an SIR model in a closed population with N = 100
## individuals of whom one is initially infectious and the rest are
## susceptible. First, generate one realisation (with a specified
## seed) from the model with known parameters \code{beta = 0.16} and
## \code{gamma = 0.077}. Then, use \code{abc} to infer the (known)
## parameters from the simulated data.
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model and plot the number of infectious.
set.seed(22)
infectious &lt;- trajectory(run(model), "I")$I
plot(infectious, type = "s")

## The distance function to accept or reject a proposal. Each node
## in the simulated trajectory (contained in the 'result' object)
## represents one proposal.
distance &lt;- function(result, ...) {
    ## Extract the time-series of infectious in each node as a
    ## data.frame.
    sim &lt;- trajectory(result, "I")

    ## Split the 'sim' data.frame by node and calculate the sum of the
    ## squared distance at each time-point for each node.
    dist &lt;- tapply(sim$I, sim$node, function(sim_infectious) {
        sum((infectious - sim_infectious)^2)
    })

    ## Return the distance for each node. Each proposal will be
    ## accepted or rejected depending on if the distance is less than
    ## the tolerance for the current generation.
    dist
}

## Fit the model parameters using ABC-SMC and adaptive tolerance
## selection. The priors for the parameters are specified using a
## formula notation. Here we use a uniform distribtion for each
## parameter with lower bound = 0 and upper bound = 1. Note that we
## use a low number particles here to keep the run-time of the example
## short. In practice you would want to use many more to ensure better
## approximations.
fit &lt;- abc(model = model,
           priors = c(beta ~ uniform(0, 1), gamma ~ uniform(0, 1)),
           npart = 100,
           ninit = 1000,
           distance = distance,
           verbose = TRUE)

## Print a brief summary.
fit

## Display the ABC posterior distribution.
plot(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.data.frame.SimInf_abc'>Coerce to data frame</h2><span id='topic+as.data.frame.SimInf_abc'></span>

<h3>Description</h3>

<p>Coerce to data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimInf_abc'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.SimInf_abc_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.SimInf_abc_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>

<hr>
<h2 id='as.data.frame.SimInf_events'>Coerce events to a data frame</h2><span id='topic+as.data.frame.SimInf_events'></span>

<h3>Description</h3>

<p>Coerce events to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimInf_events'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.SimInf_events_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.SimInf_events_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>

<hr>
<h2 id='as.data.frame.SimInf_indiv_events'>Coerce to data frame</h2><span id='topic+as.data.frame.SimInf_indiv_events'></span>

<h3>Description</h3>

<p>Coerce to data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimInf_indiv_events'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.SimInf_indiv_events_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.SimInf_indiv_events_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>

<hr>
<h2 id='boxplot+2CSimInf_model-method'>Box plot of number of individuals in each compartment</h2><span id='topic+boxplot+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Produce box-and-whisker plot(s) of the number of individuals in
each model compartment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_model'
boxplot(x, compartments = NULL, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot+2B2CSimInf_model-method_+3A_x">x</code></td>
<td>
<p>The <code>model</code> to plot</p>
</td></tr>
<tr><td><code id="boxplot+2B2CSimInf_model-method_+3A_compartments">compartments</code></td>
<td>
<p>specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. <code>compartments = c('S', 'I', 'R')</code>,
or as a formula e.g. <code>compartments = ~S+I+R</code> (see
&lsquo;Examples&rsquo;). Default (<code>compartments=NULL</code>)
includes all compartments.</p>
</td></tr>
<tr><td><code id="boxplot+2B2CSimInf_model-method_+3A_index">index</code></td>
<td>
<p>indices specifying the nodes to include when plotting
data. Default <code>index = NULL</code> include all nodes in the
model.</p>
</td></tr>
<tr><td><code id="boxplot+2B2CSimInf_model-method_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot produced.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an 'SIR' model with 10 nodes and initialise
## it with 99 susceptible individuals and one infected
## individual. Let the model run over 100 days.
model &lt;- SIR(u0 = data.frame(S = rep(99, 10),
                             I = rep(1, 10),
                             R = rep(0, 10)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the model and save the result.
result &lt;- run(model)

## Create a boxplot that includes all compartments in all nodes.
boxplot(result)

## Create a boxplot that includes the S and I compartments in
## nodes 1 and 2.
boxplot(result, ~S+I, 1:2)
</code></pre>

<hr>
<h2 id='C_code'>Extract the C code from a <code>SimInf_model</code> object</h2><span id='topic+C_code'></span>

<h3>Description</h3>

<p>Extract the C code from a <code>SimInf_model</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_code(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C_code_+3A_model">model</code></td>
<td>
<p>The <code>SimInf_model</code> object to extract the C code
from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with C code for the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the model parser to create a 'SimInf_model' object that
## expresses an SIR model, where 'b' is the transmission rate and
## 'g' is the recovery rate.
model &lt;- mparse(transitions = c("S -&gt; b*S*I/(S+I+R) -&gt; I", "I -&gt; g*I -&gt; R"),
                compartments = c("S", "I", "R"),
                gdata = c(b = 0.16, g = 0.077),
                u0 = data.frame(S = 99, I = 1, R = 0),
                tspan = 1:10)

## View the C code.
C_code(model)
</code></pre>

<hr>
<h2 id='continue'>Run more generations of ABC SMC</h2><span id='topic+continue'></span><span id='topic+continue+2CSimInf_abc-method'></span>

<h3>Description</h3>

<p>Run more generations of ABC SMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continue(object, ...)

## S4 method for signature 'SimInf_abc'
continue(
  object,
  tolerance = NULL,
  ...,
  verbose = getOption("verbose", FALSE),
  post_gen = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continue_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_abc</code> to continue from.</p>
</td></tr>
<tr><td><code id="continue_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the
<code>SimInf_abc@fn</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_tolerance">tolerance</code></td>
<td>
<p>A numeric matrix (number of summary statistics
<code class="reqn">\times</code> number of generations) where each column contains
the tolerances for a generation and each row contains a
sequence of gradually decreasing tolerances. Can also be a
numeric vector if there is only one summary statistic. The
tolerance determines the number of generations of ABC-SMC to
run.</p>
</td></tr>
<tr><td><code id="continue_+3A_verbose">verbose</code></td>
<td>
<p>prints diagnostic messages when <code>TRUE</code>. The
default is to retrieve the global option <code>verbose</code> and
use <code>FALSE</code> if it is not set.</p>
</td></tr>
<tr><td><code id="continue_+3A_post_gen">post_gen</code></td>
<td>
<p>An optional function that, if non-NULL, is applied
after each completed generation. The function must accept one
argument of type <code>SimInf_abc</code> with the current state of
the fitting process. This function can be useful to, for
example, save and inspect intermediate results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SimInf_abc</code> object.
</p>

<hr>
<h2 id='distance_matrix'>Create a distance matrix between nodes for spatial models</h2><span id='topic+distance_matrix'></span>

<h3>Description</h3>

<p>Calculate the euclidian distances beween coordinates for all
coordinates within the cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_matrix(x, y, cutoff, min_dist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_matrix_+3A_x">x</code></td>
<td>
<p>Projected x coordinate</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_y">y</code></td>
<td>
<p>Projected y coordinate</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_cutoff">cutoff</code></td>
<td>
<p>The distance cutoff</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_min_dist">min_dist</code></td>
<td>
<p>The minimum distance to separate two nodes.  If
the coordinates for two nodes are identical, the min_dist must
be assigned or an error is raised.  Default is NULL i.e. to
raise an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dgCMatrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a grid 10 x 10 and place one node in each cell
## separated by 100m.
nodes &lt;- expand.grid(x = (0:9) * 100, y = (0:9) * 100)
plot(y ~ x, nodes)

## Define the cutoff to only include neighbors within 300m.
d &lt;- distance_matrix(x = nodes$x, y = nodes$y, cutoff = 300)

## View the first 10 rows and columns in the distance matrix
d[1:10, 1:10]
</code></pre>

<hr>
<h2 id='edge_properties_to_matrix'>Convert an edge list with properties to a matrix</h2><span id='topic+edge_properties_to_matrix'></span>

<h3>Description</h3>

<p>A utility function to facilitate preparing edge properties for
<code>ldata</code> in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_properties_to_matrix(edges, n_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_properties_to_matrix_+3A_edges">edges</code></td>
<td>
<p>a <code>data.frame</code> with properties assigned for each
edge 'from' &ndash;&gt; 'to', for example, weight or count. The
<code>data.frame</code> must contain the columns '<code>from</code>' and
'<code>to</code>' with valid indices to the nodes (1 &lt;= index &lt;=
n_nodes).</p>
</td></tr>
<tr><td><code id="edge_properties_to_matrix_+3A_n_nodes">n_nodes</code></td>
<td>
<p>the total number of nodes in the model. The
resulting matrix will have the number of columns equal to
<code>n_nodes</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The edge properties will be converted to a matrix where each row
in <code>edges</code> will become a sequence of (index, value_1,
value_2, ..., value_n) where 'index' is the zero-based index of
the <code>from</code> node. The reason for a zero-based index is to
facilitate it's usage in C code. The sequence will be added to the
'to' column in the matrix. There will always be at least one stop
value=-1 in each column. All other values in the matrix will be
set to <code>NaN</code>. See &lsquo;Examples&rsquo;.
</p>


<h3>Value</h3>

<p>a numeric matrix with the number of rows equal to
<code>max(table(edges$to)) * (ncol(edges) - 1) + 1</code> and the
number of columns equal to <code>n_nodes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Let us consider the following edge properties.
edges &lt;- data.frame(
    from  = c(  2,    3,     4,  1,   4,    5,   1,   3,   1,   3),
    to    = c(  1,    1,     1,  2,   3,    3,   4,   4,   5,   5),
    rate  = c(0.2, 0.01,  0.79,  1, 0.2, 0.05, 0.2, 0.8, 0.2, 0.8),
    count = c(  5,    5,     5, 50,  10,   10,   5,   5,   5,   5))

## Converting the edge properties into a matrix
edge_properties_to_matrix(edges, 6)

## Gives the following output. The first column contains first the
## properties for the edge from = 2 --&gt; to = 1, where the first
## row is the zero-based index of from, i.e., 1. The second row
## contains the rate=0.2 and the third row count=5. On the fourth
## row starts the next sequence with the values in the second row
## in the edges data.frame. The stop value in the first column is
## on row 10. As can be seen in column 6, there are no edge
## properties for node=6.
##        [,1] [,2]  [,3] [,4] [,5] [,6]
##  [1,]  1.00    0  3.00  0.0  0.0   -1
##  [2,]  0.20    1  0.20  0.2  0.2  NaN
##  [3,]  5.00   50 10.00  5.0  5.0  NaN
##  [4,]  2.00   -1  4.00  2.0  2.0  NaN
##  [5,]  0.01  NaN  0.05  0.8  0.8  NaN
##  [6,]  5.00  NaN 10.00  5.0  5.0  NaN
##  [7,]  3.00  NaN -1.00 -1.0 -1.0  NaN
##  [8,]  0.79  NaN   NaN  NaN  NaN  NaN
##  [9,]  5.00  NaN   NaN  NaN  NaN  NaN
## [10,] -1.00  NaN   NaN  NaN  NaN  NaN
</code></pre>

<hr>
<h2 id='events'>Extract the events from a <code>SimInf_model</code> object</h2><span id='topic+events'></span><span id='topic+events+2CSimInf_model-method'></span><span id='topic+events+2CSimInf_indiv_events-method'></span>

<h3>Description</h3>

<p>Extract the scheduled events from a <code>SimInf_model</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events(object, ...)

## S4 method for signature 'SimInf_model'
events(object, ...)

## S4 method for signature 'SimInf_indiv_events'
events(object, time = NULL, target = NULL, age = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="events_+3A_object">object</code></td>
<td>
<p>The <code>model</code> to extract the events from.</p>
</td></tr>
<tr><td><code id="events_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the generated events.</p>
</td></tr>
<tr><td><code id="events_+3A_time">time</code></td>
<td>
<p>Only used when object is of class
<code>SimInf_indiv_events</code> object. All events that occur after
&lsquo;time&rsquo; are included. Default is <code>NULL</code> which means
to extract the events after the minimum time-point in the
<code>SimInf_indiv_events</code> object.</p>
</td></tr>
<tr><td><code id="events_+3A_target">target</code></td>
<td>
<p>Only used when object is of class
<code>SimInf_indiv_events</code> object. The SimInf model ('SEIR',
'SIR', 'SIS', 'SISe3', 'SISe3_sp', 'SISe', or 'SISe_sp') to
target the events and u0 for. The default, <code>NULL</code>,
creates events but they might have to be post-processed to fit
the specific use case.</p>
</td></tr>
<tr><td><code id="events_+3A_age">age</code></td>
<td>
<p>Only used when object is of class
<code>SimInf_indiv_events</code> object. Integer vector with break
points in days for the ageing events.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+SimInf_events-class">SimInf_events</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model that includes scheduled events.
model &lt;- SIR(u0     = u0_SIR(),
             tspan  = 1:(4 * 365),
             events = events_SIR(),
             beta   = 0.16,
             gamma  = 0.077)

## Extract the scheduled events from the model and display summary
summary(events(model))

## Extract the scheduled events from the model and plot them
plot(events(model))
</code></pre>

<hr>
<h2 id='events_SEIR'>Example data to initialize events for the &lsquo;SEIR&rsquo; model</h2><span id='topic+events_SEIR'></span>

<h3>Description</h3>

<p>Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the <code><a href="#topic+SEIR-class">SEIR</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events_SEIR()
</code></pre>


<h3>Details</h3>

<p>Example data to initialize scheduled events (see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>) for a population of 1600 nodes
and demonstrate the <code><a href="#topic+SEIR-class">SEIR</a></code> model. The dataset
contains 466692 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: &lsquo;Exit&rsquo;
events remove individuals from the population (n = 182535),
&lsquo;Enter&rsquo; events add individuals to the population (n =
182685), and &lsquo;External transfer&rsquo; events move individuals
between nodes in the population (n = 101472). The vignette
contains a detailed description of how scheduled events operate on
a model.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SEIR' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 &lt;- u0_SEIR()
u0$I[1] &lt;- 1
tspan &lt;- seq(from = 1, to = 4*365, by = 1)
model &lt;- SEIR(u0      = u0,
              tspan   = tspan,
              events  = events_SEIR(),
              beta    = 0.16,
              epsilon = 0.25,
              gamma   = 0.01)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)
plot(result)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
</code></pre>

<hr>
<h2 id='events_SIR'>Example data to initialize events for the &lsquo;SIR&rsquo; model</h2><span id='topic+events_SIR'></span>

<h3>Description</h3>

<p>Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the <code><a href="#topic+SIR-class">SIR</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events_SIR()
</code></pre>


<h3>Details</h3>

<p>Example data to initialize scheduled events (see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>) for a population of 1600 nodes
and demonstrate the <code><a href="#topic+SIR-class">SIR</a></code> model. The dataset
contains 466692 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: &lsquo;Exit&rsquo;
events remove individuals from the population (n = 182535),
&lsquo;Enter&rsquo; events add individuals to the population (n =
182685), and &lsquo;External transfer&rsquo; events move individuals
between nodes in the population (n = 101472). The vignette
contains a detailed description of how scheduled events operate on
a model.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 &lt;- u0_SIR()
u0$I[1] &lt;- 1
tspan &lt;- seq(from = 1, to = 4*365, by = 1)
model &lt;- SIR(u0     = u0,
             tspan  = tspan,
             events = events_SIR(),
             beta   = 0.16,
             gamma  = 0.01)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)
plot(result)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
</code></pre>

<hr>
<h2 id='events_SIS'>Example data to initialize events for the &lsquo;SIS&rsquo; model</h2><span id='topic+events_SIS'></span>

<h3>Description</h3>

<p>Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the <code><a href="#topic+SIS-class">SIS</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events_SIS()
</code></pre>


<h3>Details</h3>

<p>Example data to initialize scheduled events (see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>) for a population of 1600 nodes
and demonstrate the <code><a href="#topic+SIS-class">SIS</a></code> model. The dataset
contains 466692 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: &lsquo;Exit&rsquo;
events remove individuals from the population (n = 182535),
&lsquo;Enter&rsquo; events add individuals to the population (n =
182685), and &lsquo;External transfer&rsquo; events move individuals
between nodes in the population (n = 101472). The vignette
contains a detailed description of how scheduled events operate on
a model.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIS' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 &lt;- u0_SIS()
u0$I[1] &lt;- 1
tspan &lt;- seq(from = 1, to = 4*365, by = 1)
model &lt;- SIS(u0     = u0,
             tspan  = tspan,
             events = events_SIS(),
             beta   = 0.16,
             gamma  = 0.01)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)
plot(result)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
</code></pre>

<hr>
<h2 id='events_SISe'>Example data to initialize events for the &lsquo;SISe&rsquo; model</h2><span id='topic+events_SISe'></span>

<h3>Description</h3>

<p>Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the <code><a href="#topic+SISe-class">SISe</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events_SISe()
</code></pre>


<h3>Details</h3>

<p>Example data to initialize scheduled events (see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>) for a population of 1600 nodes
and demonstrate the <code><a href="#topic+SISe-class">SISe</a></code> model. The dataset
contains 466692 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: &lsquo;Exit&rsquo;
events remove individuals from the population (n = 182535),
&lsquo;Enter&rsquo; events add individuals to the population (n =
182685), and &lsquo;External transfer&rsquo; events move individuals
between nodes in the population (n = 101472). The vignette
contains a detailed description of how scheduled events operate on
a model.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SISe' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 &lt;- u0_SISe()
u0$I[1] &lt;- 1
tspan &lt;- seq(from = 1, to = 4*365, by = 1)
model &lt;- SISe(u0 = u0, tspan = tspan, events = events_SISe(),
              phi = 0, upsilon = 1.8e-2, gamma = 0.1, alpha = 1,
              beta_t1 = 1.0e-1, beta_t2 = 1.0e-1, beta_t3 = 1.25e-1,
              beta_t4 = 1.25e-1, end_t1 = 91, end_t2 = 182,
              end_t3 = 273, end_t4 = 365, epsilon = 0)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
</code></pre>

<hr>
<h2 id='events_SISe3'>Example data to initialize events for the &lsquo;SISe3&rsquo; model</h2><span id='topic+events_SISe3'></span>

<h3>Description</h3>

<p>Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the <code><a href="#topic+SISe3-class">SISe3</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(events_SISe3)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code>
</p>


<h3>Details</h3>

<p>Example data to initialize scheduled events (see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>) for a population of 1600 nodes
and demonstrate the <code><a href="#topic+SISe3-class">SISe3</a></code> model. The dataset
contains 783773 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: &lsquo;Exit&rsquo;
events remove individuals from the population (n = 182535),
&lsquo;Enter&rsquo; events add individuals to the population (n =
182685), &lsquo;Internal transfer&rsquo; events move individuals
between compartmens within one node e.g. ageing (n = 317081), and
&lsquo;External transfer&rsquo; events move individuals between nodes
in the population (n = 101472). The vignette contains a detailed
description of how scheduled events operate on a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SISe3' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
data("u0_SISe3", package = "SimInf")
data("events_SISe3", package = "SimInf")
u0_SISe3$I_1[1] &lt;- 1
tspan &lt;- seq(from = 1, to = 4*365, by = 1)
model &lt;- SISe3(u0 = u0_SISe3, tspan = tspan, events = events_SISe3,
               phi = rep(0, nrow(u0_SISe3)), upsilon_1 = 1.8e-2,
               upsilon_2 = 1.8e-2, upsilon_3 = 1.8e-2,
               gamma_1 = 0.1, gamma_2 = 0.1, gamma_3 = 0.1,
               alpha = 1, beta_t1 = 1.0e-1, beta_t2 = 1.0e-1,
               beta_t3 = 1.25e-1, beta_t4 = 1.25e-1, end_t1 = 91,
               end_t2 = 182, end_t3 = 273, end_t4 = 365, epsilon = 0)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
</code></pre>

<hr>
<h2 id='gdata'>Extract global data from a <code>SimInf_model</code> object</h2><span id='topic+gdata'></span><span id='topic+gdata+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>The global data is a numeric vector that is common to all nodes.
The global data vector is passed as an argument to the transition
rate functions and the post time step function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdata(model)

## S4 method for signature 'SimInf_model'
gdata(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdata_+3A_model">model</code></td>
<td>
<p>The <code>model</code> to get global data from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Set 'beta' to a new value
gdata(model, "beta") &lt;- 2

## Extract the global data vector that is common to all nodes
gdata(model)
</code></pre>

<hr>
<h2 id='gdata+26lt+3B-'>Set a global data parameter for a <code>SimInf_model</code> object</h2><span id='topic+gdata+3C-'></span><span id='topic+gdata+3C-+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>The global data is a numeric vector that is common to all nodes.
The global data vector is passed as an argument to the transition
rate functions and the post time step function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdata(model, parameter) &lt;- value

## S4 replacement method for signature 'SimInf_model'
gdata(model, parameter) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdata+2B26lt+2B3B-_+3A_model">model</code></td>
<td>
<p>The <code>model</code> to set a global model parameter for.</p>
</td></tr>
<tr><td><code id="gdata+2B26lt+2B3B-_+3A_parameter">parameter</code></td>
<td>
<p>The name of the parameter to set.</p>
</td></tr>
<tr><td><code id="gdata+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>SimInf_model</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Set 'beta' to a new value
gdata(model, "beta") &lt;- 2

## Extract the global data vector that is common to all nodes
gdata(model)
</code></pre>

<hr>
<h2 id='get_individuals'>Extract individuals from <code>SimInf_indiv_events</code></h2><span id='topic+get_individuals'></span><span id='topic+get_individuals+2CSimInf_indiv_events-method'></span>

<h3>Description</h3>

<p>Lookup individuals, in which node they are located and their age
at a specified time-point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_individuals(x, time = NULL)

## S4 method for signature 'SimInf_indiv_events'
get_individuals(x, time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_individuals_+3A_x">x</code></td>
<td>
<p>an individual events object of class
<code>SimInf_indiv_events</code>.</p>
</td></tr>
<tr><td><code id="get_individuals_+3A_time">time</code></td>
<td>
<p>the time-point for the lookup of individuals. Default
is <code>NULL</code> which means to extract the individuals at the
minimum time-point in the events object <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with the columns <code>id</code>,
<code>node</code>, and <code>age</code>.
</p>

<hr>
<h2 id='indegree'>Determine in-degree for each node in a model</h2><span id='topic+indegree'></span>

<h3>Description</h3>

<p>The number of nodes with inward <em>external transfer</em> events to
each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indegree(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indegree_+3A_model">model</code></td>
<td>
<p>determine in-degree for each node in the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with in-degree for each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an 'SIR' model with 1600 nodes and initialize
## it with example data.
model &lt;- SIR(u0 = u0_SIR(), tspan = 1:1460, events = events_SIR(),
             beta   = 0.16, gamma  = 0.077)

## Display indegree for each node in the model.
plot(indegree(model))
</code></pre>

<hr>
<h2 id='individual_events'>Individual events</h2><span id='topic+individual_events'></span>

<h3>Description</h3>

<p>In many countries, individual-based livestock data are collected
to enable contact tracing during disease outbreaks. However, the
livestock databases are not always structured in such a way that
relevant information for disease spread simulations is easily
retrieved. The aim of this function is to facilitate cleaning
livestock event data and prepare it for usage in SimInf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>individual_events(events)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="individual_events_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> with the columns <code>id</code>, <code>event</code>,
<code>time</code>, <code>node</code>, and <code>dest</code> to define the events, see
<code>details</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>events</code> in <code>individual_events</code> must be a
<code>data.frame</code> with the following columns:
</p>

<ul>
<li> <p><strong>id:</strong> an integer or character identifier of the individual.
</p>
</li>
<li> <p><strong>event:</strong> four event types are supported: <em>exit</em>,
<em>enter</em>, <em>internal transfer</em>, and <em>external
transfer</em>.  When assigning the events, they can either be
coded as a numerical value or a character string: <em>exit;</em>
<code>0</code> or <code>'exit'</code>, <em>enter;</em> <code>1</code> or
<code>'enter'</code>, <em>internal transfer;</em> <code>2</code> or
<code>'intTrans'</code>, and <em>external transfer;</em> <code>3</code> or
<code>'extTrans'</code>.
</p>
</li>
<li> <p><strong>time:</strong> an integer, character, or date (of class <code>Date</code>)
for when the event occured. If it's a character it must be
able to coerce to <code>Date</code>.
</p>
</li>
<li> <p><strong>node:</strong> an integer or character identifier of the source node.
</p>
</li>
<li> <p><strong>dest:</strong> an integer or character identifier of the destination
node for movement events, and 'dest' will be replaced with
<code>NA</code> for non-movement events.
</p>
</li></ul>



<h3>Value</h3>

<p><a href="#topic+SimInf_indiv_events-class">SimInf_indiv_events</a>
</p>

<hr>
<h2 id='ldata'>Extract local data from a node</h2><span id='topic+ldata'></span><span id='topic+ldata+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>The local data is a numeric vector that is specific to a node.
The local data vector is passed as an argument to the transition
rate functions and the post time step function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldata(model, node)

## S4 method for signature 'SimInf_model'
ldata(model, node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldata_+3A_model">model</code></td>
<td>
<p>The <code>model</code> to get local data from.</p>
</td></tr>
<tr><td><code id="ldata_+3A_node">node</code></td>
<td>
<p>index to node to extract local data from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an 'SISe' model with 1600 nodes.
model &lt;- SISe(u0 = u0_SISe(), tspan = 1:100, events = events_SISe(),
              phi = 0, upsilon = 1.8e-2, gamma = 0.1, alpha = 1,
              beta_t1 = 1.0e-1, beta_t2 = 1.0e-1, beta_t3 = 1.25e-1,
              beta_t4 = 1.25e-1, end_t1 = c(91, 101), end_t2 = c(182, 185),
              end_t3 = c(273, 275), end_t4 = c(365, 360), epsilon = 0)

## Display local data from the first two nodes.
ldata(model, node = 1)
ldata(model, node = 2)
</code></pre>

<hr>
<h2 id='logLik+2CSimInf_pfilter-method'>Log likelihood</h2><span id='topic+logLik+2CSimInf_pfilter-method'></span>

<h3>Description</h3>

<p>Extract the estimated log likelihood from a <code>SimInf_pfilter</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_pfilter'
logLik(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik+2B2CSimInf_pfilter-method_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_pfilter</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the estimated log likelihood.
</p>

<hr>
<h2 id='mparse'>Model parser to define new models to run in <code>SimInf</code></h2><span id='topic+mparse'></span>

<h3>Description</h3>

<p>Describe your model in a logical way in R. <code>mparse</code> creates a
<code><a href="#topic+SimInf_model-class">SimInf_model</a></code> object with your model
definition that is ready to <code><a href="#topic+run">run</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mparse(
  transitions = NULL,
  compartments = NULL,
  ldata = NULL,
  gdata = NULL,
  u0 = NULL,
  v0 = NULL,
  tspan = NULL,
  events = NULL,
  E = NULL,
  N = NULL,
  pts_fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mparse_+3A_transitions">transitions</code></td>
<td>
<p>character vector containing transitions on the
form <code>"X -&gt; ... -&gt; Y"</code>. The left (right) side is the
initial (final) state and the propensity is written in between
the <code>-&gt;</code>-signs. The special symbol <code>@</code> is reserved
for the empty set. For example, <code>transitions =
c("S -&gt; k1*S*I -&gt; I", "I -&gt; k2*I -&gt; R")</code> expresses a SIR
model.</p>
</td></tr>
<tr><td><code id="mparse_+3A_compartments">compartments</code></td>
<td>
<p>contains the names of the involved
compartments, for example, <code>compartments = c("S", "I",
"R")</code>.</p>
</td></tr>
<tr><td><code id="mparse_+3A_ldata">ldata</code></td>
<td>
<p>optional data for the nodes. Can be specified either
as a numeric matrix where column <code>ldata[, j]</code> contains
the local data vector for the node <code>j</code> or as a
<code>data.frame</code> with one row per node. If it's specified as
a matrix, it must have row names to identify the parameters in
the transitions. If it's specified as a data.frame, each
column is one parameter. The local data vector is passed as an
argument to the transition rate functions and the post time
step function.</p>
</td></tr>
<tr><td><code id="mparse_+3A_gdata">gdata</code></td>
<td>
<p>optional data that are common to all nodes in the
model. Can be specified either as a named numeric vector or as
as a one-row data.frame. The names are used to identify the
parameters in the transitions. The global data vector is
passed as an argument to the transition rate functions and the
post time step function.</p>
</td></tr>
<tr><td><code id="mparse_+3A_u0">u0</code></td>
<td>
<p>A <code>data.frame</code> (or an object that can be coerced to
a <code>data.frame</code> with <code>as.data.frame</code>) with the
initial state i.e. the number of individuals in each
compartment in each node when the simulation starts..</p>
</td></tr>
<tr><td><code id="mparse_+3A_v0">v0</code></td>
<td>
<p>optional data with the initial continuous state in each
node. Can be specified either as a <code>data.frame</code> with one
row per node or as a numeric matrix where column <code>v0[,
j]</code> contains the initial state vector for the node
<code>j</code>. If <code>v0</code> is specified as a <code>data.frame</code>,
each column is one parameter. If <code>v0</code> is specified as a
matrix, the row names identify the parameters. The 'v' vector
is passed as an argument to the transition rate functions and
the post time step function. The continuous state can be
updated in the post time step function.</p>
</td></tr>
<tr><td><code id="mparse_+3A_tspan">tspan</code></td>
<td>
<p>A vector (length &gt;= 1) of increasing time points
where the state of each node is to be returned. Can be either
an <code>integer</code> or a <code>Date</code> vector. A <code>Date</code>
vector is coerced to a numeric vector as days, where
<code>tspan[1]</code> becomes the day of the year of the first year
of <code>tspan</code>. The dates are added as names to the numeric
vector.</p>
</td></tr>
<tr><td><code id="mparse_+3A_events">events</code></td>
<td>
<p>A <code>data.frame</code> with the scheduled
events. Default is <code>NULL</code> i.e. no scheduled events in the
model.</p>
</td></tr>
<tr><td><code id="mparse_+3A_e">E</code></td>
<td>
<p>matrix to handle scheduled events, see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>. Default is <code>NULL</code>
i.e. no scheduled events in the model.</p>
</td></tr>
<tr><td><code id="mparse_+3A_n">N</code></td>
<td>
<p>matrix to handle scheduled events, see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>. Default is <code>NULL</code>
i.e. no scheduled events in the model.</p>
</td></tr>
<tr><td><code id="mparse_+3A_pts_fun">pts_fun</code></td>
<td>
<p>optional character vector with C code for the post
time step function. The C code should contain only the body of
the function i.e. the code between the opening and closing
curly brackets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+SimInf_model-class">SimInf_model</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Use the model parser to create a 'SimInf_model' object that
## expresses an SIR model, where 'beta' is the transmission rate
## and 'gamma' is the recovery rate.
model  &lt;- mparse(transitions = c("S -&gt; beta*S*I/(S+I+R) -&gt; I",
                                 "I -&gt; gamma*I -&gt; R"),
                 compartments = c("S", "I", "R"),
                 gdata = c(beta = 0.16, gamma = 0.077),
                 u0 = data.frame(S = 100, I = 1, R = 0),
                 tspan = 1:100)

## Run and plot the result
set.seed(22)
result &lt;- run(model)
plot(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='n_generations'>Determine the number of generations</h2><span id='topic+n_generations'></span><span id='topic+n_generations+2CSimInf_abc-method'></span>

<h3>Description</h3>

<p>Determine the number of generations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_generations(object)

## S4 method for signature 'SimInf_abc'
n_generations(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_generations_+3A_object">object</code></td>
<td>
<p>the <code>SimInf_abc</code> object to determine the number
of generations for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer with the number of generations.
</p>

<hr>
<h2 id='n_nodes'>Determine the number of nodes in a model</h2><span id='topic+n_nodes'></span><span id='topic+n_nodes+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Determine the number of nodes in a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_nodes(model)

## S4 method for signature 'SimInf_model'
n_nodes(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_nodes_+3A_model">model</code></td>
<td>
<p>the <code>model</code> object to extract the number of
nodes from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of nodes in the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an 'SIR' model with 100 nodes, with 99 susceptible,
## 1 infected and 0 recovered in each node.
u0 &lt;- data.frame(S = rep(99, 100), I = rep(1, 100), R = rep(0, 100))
model &lt;- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Display the number of nodes in the model.
n_nodes(model)
</code></pre>

<hr>
<h2 id='nodes'>Example data with spatial distribution of nodes</h2><span id='topic+nodes'></span>

<h3>Description</h3>

<p>Example data to initialize a population of 1600 nodes and
demonstrate various models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nodes)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 &lt;- u0_SIR()
u0$I[1] &lt;- 1
tspan &lt;- seq(from = 1, to = 4*365, by = 1)
model &lt;- SIR(u0     = u0,
             tspan  = tspan,
             events = events_SIR(),
             beta   = 0.16,
             gamma  = 0.077)

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)

## Determine nodes with one or more infected individuals in the
## trajectory. Extract the 'I' compartment and check for any
## infected individuals in each node.
infected &lt;- colSums(trajectory(result, ~ I, format = "matrix")) &gt; 0

## Display infected nodes in 'blue' and non-infected nodes in 'yellow'.
data("nodes", package = "SimInf")
col &lt;- ifelse(infected, "blue", "yellow")
plot(y ~ x, nodes, col = col, pch = 20, cex = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='outdegree'>Determine out-degree for each node in a model</h2><span id='topic+outdegree'></span>

<h3>Description</h3>

<p>The number nodes that are connected with <em>external transfer</em>
events from each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outdegree(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outdegree_+3A_model">model</code></td>
<td>
<p>determine out-degree for each node in the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with out-degree for each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an 'SIR' model with 1600 nodes and initialize
## it with example data.
model &lt;- SIR(u0 = u0_SIR(), tspan = 1:1460, events = events_SIR(),
             beta   = 0.16, gamma  = 0.077)

## Display outdegree for each node in the model.
plot(outdegree(model))
</code></pre>

<hr>
<h2 id='package_skeleton'>Create a package skeleton from a <code>SimInf_model</code></h2><span id='topic+package_skeleton'></span>

<h3>Description</h3>

<p>Describe your model in a logical way in R, then <code>mparse</code>
creates a <code><a href="#topic+SimInf_model-class">SimInf_model</a></code> object with your model
definition that can be installed as an add-on R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>package_skeleton(
  model,
  name = NULL,
  path = ".",
  author = NULL,
  email = NULL,
  maintainer = NULL,
  license = "GPL-3"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="package_skeleton_+3A_model">model</code></td>
<td>
<p>The <code>model</code> <code><a href="#topic+SimInf_model-class">SimInf_model</a></code>
object with your model to create the package skeleton from.</p>
</td></tr>
<tr><td><code id="package_skeleton_+3A_name">name</code></td>
<td>
<p>Character string with the package name. It should
contain only (ASCII) letters, numbers and dot, have at least
two characters and start with a letter and not end in a dot.
The package name is also used for the class name of the model
and the directory name of the package.</p>
</td></tr>
<tr><td><code id="package_skeleton_+3A_path">path</code></td>
<td>
<p>Path to put the package directory in. Default is '.'
i.e. the current directory.</p>
</td></tr>
<tr><td><code id="package_skeleton_+3A_author">author</code></td>
<td>
<p>Author of the package.</p>
</td></tr>
<tr><td><code id="package_skeleton_+3A_email">email</code></td>
<td>
<p>Email of the package maintainer.</p>
</td></tr>
<tr><td><code id="package_skeleton_+3A_maintainer">maintainer</code></td>
<td>
<p>Maintainer of the package.</p>
</td></tr>
<tr><td><code id="package_skeleton_+3A_license">license</code></td>
<td>
<p>License of the package. Default is 'GPL-3'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code>NULL</code>.
</p>


<h3>References</h3>

<p>Read the <em>Writing R Extensions</em> manual for more
details.
</p>
<p>Once you have created a <em>source</em> package you need to install
it: see the <em>R Installation and Administration</em> manual,
<code><a href="utils.html#topic+INSTALL">INSTALL</a></code> and <code><a href="utils.html#topic+install.packages">install.packages</a></code>.
</p>

<hr>
<h2 id='pairs+2CSimInf_model-method'>Scatterplot of number of individuals in each compartment</h2><span id='topic+pairs+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>A matrix of scatterplots with the number of individuals in each
compartment is produced. The <code>ij</code>th scatterplot contains
<code>x[,i]</code> plotted against <code>x[,j]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_model'
pairs(x, compartments = NULL, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs+2B2CSimInf_model-method_+3A_x">x</code></td>
<td>
<p>The <code>model</code> to plot</p>
</td></tr>
<tr><td><code id="pairs+2B2CSimInf_model-method_+3A_compartments">compartments</code></td>
<td>
<p>specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. <code>compartments = c('S', 'I', 'R')</code>,
or as a formula e.g. <code>compartments = ~S+I+R</code> (see
&lsquo;Examples&rsquo;). Default (<code>compartments=NULL</code>)
includes all compartments.</p>
</td></tr>
<tr><td><code id="pairs+2B2CSimInf_model-method_+3A_index">index</code></td>
<td>
<p>indices specifying the nodes to include when plotting
data. Default <code>index = NULL</code> include all nodes in the
model.</p>
</td></tr>
<tr><td><code id="pairs+2B2CSimInf_model-method_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot produced.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 10 nodes and initialise
## it with 99 susceptible individuals and one infected
## individual. Let the model run over 100 days.
model &lt;- SIR(u0 = data.frame(S = rep(99, 10),
                             I = rep(1, 10),
                             R = rep(0, 10)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the model and save the result.
result &lt;- run(model)

## Create a scatter plot that includes all compartments in all
## nodes.
pairs(result)

## Create a scatter plot that includes the S and I compartments in
## nodes 1 and 2.
pairs(result, ~S+I, 1:2)
</code></pre>

<hr>
<h2 id='pfilter'>Bootstrap particle filter</h2><span id='topic+pfilter'></span><span id='topic+pfilter+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>The bootstrap filtering algorithm. Systematic resampling is
performed at each observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfilter(model, obs_process, data, npart)

## S4 method for signature 'SimInf_model'
pfilter(model, obs_process, data, npart)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfilter_+3A_model">model</code></td>
<td>
<p>The <code>SimInf_model</code> object to simulate data from.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_obs_process">obs_process</code></td>
<td>
<p>Specification of the stochastic observation
process. The <code>obs_process</code> can be specified as a
<code>formula</code> if the model contains only one node and there
is only one data point for each <code>time</code> in <code>data</code>.
The left hand side of the formula must match a column name in
the <code>data</code> data.frame and the right hand side of the
formula is a character specifying the distribution of the
observation process, for example, <code>Iobs ~ poisson(I)</code>.
The following distributions are supported: <code>x ~
binomial(size, prob)</code>, <code>x ~ poisson(rate)</code> and <code>x ~
uniform(min, max)</code>. The observation process can also be a
function to evaluate the probability density of the
observations given the simulated states. The first argument
passed to the <code>obs_process</code> function is the result from a
run of the model and it contains one trajectory with simulated
data for a time-point. The second argument to the
<code>obs_process</code> function is a <code>data.frame</code> containing
the rows for the specific time-point that the function is
called for. Note that the function must return the log of the
density.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> holding the time series data.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_npart">npart</code></td>
<td>
<p>An integer with the number of particles (&gt; 1) to use
at each timestep.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SimInf_pfilter</code> object.
</p>


<h3>References</h3>

<p>N. J. Gordon, D. J. Salmond, and A. F. M. Smith. Novel Approach to Nonlinear/Non-Gaussian Bayesian State Estimation. <em>Radar and Signal Processing, IEE Proceedings F</em>, <strong>140</strong>(2) 107&ndash;113, 1993. <a href="https://doi.org/10.1049/ip-f-2.1993.0015">doi:10.1049/ip-f-2.1993.0015</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Let us consider an SIR model in a closed population with N = 100
## individuals of whom one is initially infectious and the rest are
## susceptible. First, generate one realisation (with a specified
## seed) from the model with known parameters 'beta = 0.16' and
## 'gamma = 0.077'. Then, use 'pfilter' to apply the bootstrap
## particle algorithm on the simulated data.
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = seq(1, 100, by = 3),
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model to generate simulated observed data for the
## number of infected individuals.
set.seed(22)
infected &lt;- trajectory(run(model), "I")[, c("time", "I")]
colnames(infected) &lt;- c("time", "Iobs")

## Use a Poison observation process for the infected individuals, such
## that 'Iobs ~ poison(I + 1e-6)'. A small constant '1e-6' is added to
## prevent numerical errors, since the simulated counts 'I' could be
## zero, which would result in the Poisson rate parameter being zero,
## which violates the conditions of the Poisson distribution. Use 1000
## particles.
pf &lt;- pfilter(model,
              obs_process = Iobs ~ poisson(I + 1e-6),
              data = infected,
              npart = 1000)

## Print a brief summary.
pf

## Compare the number infected 'I' in the filtered trajectory with the
## infected 'Iobs' in the observed data.
plot(pf, ~I)
lines(Iobs ~ time, infected, col = "blue", lwd = 2, type = "s")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot+2CSimInf_abc-method'>Display the ABC posterior distribution</h2><span id='topic+plot+2CSimInf_abc-method'></span>

<h3>Description</h3>

<p>Display the ABC posterior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_abc'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSimInf_abc-method_+3A_x">x</code></td>
<td>
<p>The <code>SimInf_abc</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_abc-method_+3A_y">y</code></td>
<td>
<p>The generation to plot. The default is to display the
last generation.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_abc-method_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot.</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CSimInf_events-method'>Display the distribution of scheduled events over time</h2><span id='topic+plot+2CSimInf_events-method'></span>

<h3>Description</h3>

<p>Display the distribution of scheduled events over time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_events'
plot(x, frame.plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSimInf_events-method_+3A_x">x</code></td>
<td>
<p>The events data to plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_events-method_+3A_frame.plot">frame.plot</code></td>
<td>
<p>Draw a frame around each plot. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_events-method_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CSimInf_indiv_events-method'>Display the distribution of individual events over time</h2><span id='topic+plot+2CSimInf_indiv_events-method'></span>

<h3>Description</h3>

<p>Display the distribution of individual events over time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_indiv_events'
plot(x, frame.plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSimInf_indiv_events-method_+3A_x">x</code></td>
<td>
<p>The individual events data to plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_indiv_events-method_+3A_frame.plot">frame.plot</code></td>
<td>
<p>a logical indicating whether a box should be
drawn around the plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_indiv_events-method_+3A_...">...</code></td>
<td>
<p>Other graphical parameters that are passed on to the
plot function.</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CSimInf_model-method'>Display the outcome from a simulated trajectory</h2><span id='topic+plot+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Plot either the median and the quantile range of the counts in all
nodes, or plot the counts in specified nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_model'
plot(
  x,
  y,
  level = 1,
  index = NULL,
  range = 0.5,
  type = "s",
  lwd = 2,
  frame.plot = FALSE,
  legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_x">x</code></td>
<td>
<p>The <code>model</code> to plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_y">y</code></td>
<td>
<p>Character vector or formula with the compartments in the
model to include in the plot. Default includes all
compartments in the model. Can also be a formula that
specifies the compartments that define the cases with a
disease or that have a specific characteristic (numerator),
and the compartments that define the entire population of
interest (denominator). The left-hand-side of the formula
defines the cases, and the right-hand-side defines the
population, for example, <code>I~S+I+R</code> in a &lsquo;SIR&rsquo;
model (see &lsquo;Examples&rsquo;). The <code>.</code>  (dot) is expanded
to all compartments, for example, <code>I~.</code>  is expanded to
<code>I~S+I+R</code> in a &lsquo;SIR&rsquo; model (see
&lsquo;Examples&rsquo;).</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_level">level</code></td>
<td>
<p>The level at which the prevalence is calculated at
each time point in <code>tspan</code>. 1 (population prevalence):
calculates the proportion of the individuals (cases) in the
population. 2 (node prevalence): calculates the proportion of
nodes with at least one case. 3 (within-node prevalence):
calculates the proportion of cases within each node. Default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_index">index</code></td>
<td>
<p>Indices specifying the nodes to include when plotting
data. Plot one line for each node. Default (<code>index =
NULL</code>) is to extract data from all nodes and plot the median
count for the specified compartments.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_range">range</code></td>
<td>
<p>Show the quantile range of the count in each
compartment. Default is to show the interquartile range
i.e. the middle 50% of the count in transparent color. The
median value is shown in the same color. Use <code>range =
0.95</code> to show the middle 95% of the count. To display
individual lines for each node, specify <code>range = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_type">type</code></td>
<td>
<p>The type of plot to draw. The default <code>type =
"s"</code> draws stair steps. See base plot for other values.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_lwd">lwd</code></td>
<td>
<p>The line width. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_frame.plot">frame.plot</code></td>
<td>
<p>a logical indicating whether a box should be
drawn around the plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_legend">legend</code></td>
<td>
<p>a logical indicating whether a legend for the
compartments should be added to the plot. A legend is not
drawn for a prevalence plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_model-method_+3A_...">...</code></td>
<td>
<p>Other graphical parameters that are passed on to the
plot function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 100 nodes and initialise
## it with 990 susceptible individuals and 10 infected
## individuals in each node. Run the model over 100 days.
model &lt;- SIR(u0 = data.frame(S = rep(990, 100),
                             I = rep(10, 100),
                             R = rep(0, 100)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the model and save the result.
result &lt;- run(model)

## Plot the median and interquartile range of the number
## of susceptible, infected and recovered individuals.
plot(result)

## Plot the median and the middle 95\
## number of susceptible, infected and recovered individuals.
plot(result, range = 0.95)

## Plot the median and interquartile range of the  number
## of infected individuals.
plot(result, "I")

## Use the formula notation instead to plot the median and
## interquartile range of the number of infected individuals.
plot(result, ~I)

## Plot the number of susceptible, infected
## and recovered individuals in the first
## three nodes.
plot(result, index = 1:3, range = FALSE)

## Use plot type line instead.
plot(result, index = 1:3, range = FALSE, type = "l")

## Plot the number of infected individuals in the first node.
plot(result, "I", index = 1, range = FALSE)

## Plot the proportion of infected individuals (cases)
## in the population.
plot(result, I ~ S + I + R)

## Plot the proportion of nodes with infected individuals.
plot(result, I ~ S + I + R, level = 2)

## Plot the median and interquartile range of the proportion
## of infected individuals in each node
plot(result, I ~ S + I + R, level = 3)

## Plot the proportion of infected individuals in the first
## three nodes.
plot(result, I ~ S + I + R, level = 3, index = 1:3, range = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot+2CSimInf_pfilter-method'>Diagnostic plot of a particle filter object</h2><span id='topic+plot+2CSimInf_pfilter-method'></span>

<h3>Description</h3>

<p>Diagnostic plot of a particle filter object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_pfilter'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSimInf_pfilter-method_+3A_x">x</code></td>
<td>
<p>The <code>SimInf_pfilter</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_pfilter-method_+3A_y">y</code></td>
<td>
<p>If y is <code>NULL</code> or missing (default), the filtered
trajectory (top) and the effective sample size (bottom) are
displayed. If <code>y</code> is a character vector or a formula, the
plot function for a <code>SimInf_model</code> object is called with
the filtered trajectory, see
<code><a href="#topic+plot+2CSimInf_model-method">plot,SimInf_model-method</a></code> for more details about
the specification a plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimInf_pfilter-method_+3A_...">...</code></td>
<td>
<p>Other graphical parameters that are passed on to the
plot function.</p>
</td></tr>
</table>

<hr>
<h2 id='prevalence'>Generic function to calculate prevalence from trajectory data</h2><span id='topic+prevalence'></span>

<h3>Description</h3>

<p>Calculate the proportion of individuals with disease in the
population, or the proportion of nodes with at least one diseased
individual, or the proportion of individuals with disease in each
node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prevalence(model, formula, level = 1, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prevalence_+3A_model">model</code></td>
<td>
<p>The <code>model</code> with trajectory data to calculate
the prevalence from.</p>
</td></tr>
<tr><td><code id="prevalence_+3A_formula">formula</code></td>
<td>
<p>A formula that specifies the compartments that
define the cases with a disease or that have a specific
characteristic (numerator), and the compartments that define
the entire population of interest (denominator). The
left-hand-side of the formula defines the cases, and the
right-hand-side defines the population, for example,
<code>I~S+I+R</code> in a &lsquo;SIR&rsquo; model (see
&lsquo;Examples&rsquo;). The <code>.</code>  (dot) is expanded to all
compartments, for example, <code>I~.</code>  is expanded to
<code>I~S+I+R</code> in a &lsquo;SIR&rsquo; model (see
&lsquo;Examples&rsquo;). The formula can also contain a condition
(indicated by <code>|</code>) for each node and time step to further
control the population to include in the calculation, for
example, <code>I ~ . | R == 0</code> to calculate the prevalence
when the recovered is zero in a &lsquo;SIR&rsquo; model. The
condition must evaluate to <code>TRUE</code> or <code>FALSE</code> in each
node and time step. Note that if the denominator is zero, the
prevalence is <code>NaN</code>.</p>
</td></tr>
<tr><td><code id="prevalence_+3A_level">level</code></td>
<td>
<p>The level at which the prevalence is calculated at
each time point in <code>tspan</code>. 1 (population prevalence):
calculates the proportion of the individuals (cases) in the
population. 2 (node prevalence): calculates the proportion of
nodes with at least one case. 3 (within-node prevalence):
calculates the proportion of cases within each node. Default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="prevalence_+3A_index">index</code></td>
<td>
<p>indices specifying the subset of nodes to include
when extracting data. Default (<code>index = NULL</code>) is to
extract data from all nodes.</p>
</td></tr>
<tr><td><code id="prevalence_+3A_...">...</code></td>
<td>
<p>Additional arguments, see
<code><a href="#topic+prevalence+2CSimInf_model-method">prevalence,SimInf_model-method</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='prevalence+2CSimInf_model-method'>Calculate prevalence from a model object with trajectory data</h2><span id='topic+prevalence+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Calculate the proportion of individuals with disease in the
population, or the proportion of nodes with at least one diseased
individual, or the proportion of individuals with disease in each
node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_model'
prevalence(model, formula, level, index, format = c("data.frame", "matrix"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prevalence+2B2CSimInf_model-method_+3A_model">model</code></td>
<td>
<p>The <code>model</code> with trajectory data to calculate
the prevalence from.</p>
</td></tr>
<tr><td><code id="prevalence+2B2CSimInf_model-method_+3A_formula">formula</code></td>
<td>
<p>A formula that specifies the compartments that
define the cases with a disease or that have a specific
characteristic (numerator), and the compartments that define
the entire population of interest (denominator). The
left-hand-side of the formula defines the cases, and the
right-hand-side defines the population, for example,
<code>I~S+I+R</code> in a &lsquo;SIR&rsquo; model (see
&lsquo;Examples&rsquo;). The <code>.</code>  (dot) is expanded to all
compartments, for example, <code>I~.</code>  is expanded to
<code>I~S+I+R</code> in a &lsquo;SIR&rsquo; model (see
&lsquo;Examples&rsquo;). The formula can also contain a condition
(indicated by <code>|</code>) for each node and time step to further
control the population to include in the calculation, for
example, <code>I ~ . | R == 0</code> to calculate the prevalence
when the recovered is zero in a &lsquo;SIR&rsquo; model. The
condition must evaluate to <code>TRUE</code> or <code>FALSE</code> in each
node and time step. Note that if the denominator is zero, the
prevalence is <code>NaN</code>.</p>
</td></tr>
<tr><td><code id="prevalence+2B2CSimInf_model-method_+3A_level">level</code></td>
<td>
<p>The level at which the prevalence is calculated at
each time point in <code>tspan</code>. 1 (population prevalence):
calculates the proportion of the individuals (cases) in the
population. 2 (node prevalence): calculates the proportion of
nodes with at least one case. 3 (within-node prevalence):
calculates the proportion of cases within each node. Default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="prevalence+2B2CSimInf_model-method_+3A_index">index</code></td>
<td>
<p>indices specifying the subset of nodes to include
when extracting data. Default (<code>index = NULL</code>) is to
extract data from all nodes.</p>
</td></tr>
<tr><td><code id="prevalence+2B2CSimInf_model-method_+3A_format">format</code></td>
<td>
<p>The default (<code>format = "data.frame"</code>) is to
generate a <code>data.frame</code> with one row per time-step with
the prevalence. Using <code>format = "matrix"</code> returns the
result as a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> if <code>format = "data.frame"</code>, else
a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an 'SIR' model with 6 nodes and initialize
## it to run over 10 days.
u0 &lt;- data.frame(S = 100:105, I = c(0, 1, 0, 2, 0, 3), R = rep(0, 6))
model &lt;- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)

## Determine the proportion of infected individuals (cases)
## in the population at the time-points in 'tspan'.
prevalence(result, I ~ S + I + R)

## Identical result is obtained with the shorthand 'I~.'
prevalence(result, I ~ .)

## Determine the proportion of nodes with infected individuals at
## the time-points in 'tspan'.
prevalence(result, I ~ S + I + R, level = 2)

## Determine the proportion of infected individuals in each node
## at the time-points in 'tspan'.
prevalence(result, I ~ S + I + R, level = 3)

## Determine the proportion of infected individuals in each node
## at the time-points in 'tspan' when the number of recovered is
## zero.
prevalence(result, I ~ S + I + R | R == 0, level = 3)
</code></pre>

<hr>
<h2 id='punchcard+26lt+3B-'>Set a template for where to record result during a simulation</h2><span id='topic+punchcard+3C-'></span><span id='topic+punchcard+3C-+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Using a sparse result matrix can save a lot of memory if the model
contains many nodes and time-points, but where only a few of the
data points are of interest for post-processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>punchcard(model) &lt;- value

## S4 replacement method for signature 'SimInf_model'
punchcard(model) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="punchcard+2B26lt+2B3B-_+3A_model">model</code></td>
<td>
<p>The <code>model</code> to set a template for where to
record result.</p>
</td></tr>
<tr><td><code id="punchcard+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A <code>data.frame</code> that specify the nodes,
time-points and compartments to record the number of
individuals at <code>tspan</code>. Use <code>NULL</code> to reset the
model to record the number of inidividuals in each compartment
in every node at each time-point in tspan.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using a sparse result matrix can save a lot of memory if the model
contains many nodes and time-points, but where only a few of the
data points are of interest for post-processing. To use this
feature, a template has to be defined for which data points to
record. This is done using a <code>data.frame</code> that specifies the
time-points (column &lsquo;time&rsquo;) and nodes (column
&lsquo;node&rsquo;) to record the state of the compartments, see
&lsquo;Examples&rsquo;. The specified time-points, nodes and
compartments must exist in the model, or an error is raised. Note
that specifying a template only affects which data-points are
recorded for post-processing, it does not affect how the solver
simulates the trajectory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 6 nodes and initialize it to run over 10 days.
u0 &lt;- data.frame(S = 100:105, I = 1:6, R = rep(0, 6))
model &lt;- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Run the model.
result &lt;- run(model)

## Display the trajectory with data for every node at each
## time-point in tspan.
trajectory(result)

## Assume we are only interested in nodes '2' and '4' at the
## time-points '3' and '5'
df &lt;- data.frame(time = c(3, 5, 3, 5),
                 node = c(2, 2, 4, 4),
                 S = c(TRUE, TRUE, TRUE, TRUE),
                 I = c(TRUE, TRUE, TRUE, TRUE),
                 R = c(TRUE, TRUE, TRUE, TRUE))
punchcard(model) &lt;- df
result &lt;- run(model)
trajectory(result)

## We can also specify to record only some of the compartments in
## each time-step.
df &lt;- data.frame(time = c(3, 5, 3, 5),
                 node = c(2, 2, 4, 4),
                 S = c(FALSE, TRUE, TRUE, TRUE),
                 I = c(TRUE, FALSE, TRUE, FALSE),
                 R = c(TRUE, FALSE, TRUE, TRUE))
punchcard(model) &lt;- df
result &lt;- run(model)
trajectory(result)

## A shortcut to specify to record all of the compartments in
## each time-step is to only inlude node and time.
df &lt;- data.frame(time = c(3, 5, 3, 5),
                 node = c(2, 2, 4, 4))
punchcard(model) &lt;- df
result &lt;- run(model)
trajectory(result)

## It is possible to use an empty 'data.frame' to specify
## that no data-points should be recorded for the trajectory.
punchcard(model) &lt;- data.frame()
result &lt;- run(model)
trajectory(result)

## Use 'NULL' to reset the model to record data for every node at
## each time-point in tspan.
punchcard(model) &lt;- NULL
result &lt;- run(model)
trajectory(result)
</code></pre>

<hr>
<h2 id='run'>Run the SimInf stochastic simulation algorithm</h2><span id='topic+run'></span><span id='topic+run+2CSimInf_model-method'></span><span id='topic+run+2CSEIR-method'></span><span id='topic+run+2CSIR-method'></span><span id='topic+run+2CSIS-method'></span><span id='topic+run+2CSISe-method'></span><span id='topic+run+2CSISe3-method'></span><span id='topic+run+2CSISe3_sp-method'></span><span id='topic+run+2CSISe_sp-method'></span><span id='topic+run+2CSimInf_abc-method'></span>

<h3>Description</h3>

<p>Run the SimInf stochastic simulation algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run(model, ...)

## S4 method for signature 'SimInf_model'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SEIR'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SIR'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SIS'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SISe'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SISe3'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SISe3_sp'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SISe_sp'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SimInf_abc'
run(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_+3A_model">model</code></td>
<td>
<p>The SimInf model to run.</p>
</td></tr>
<tr><td><code id="run_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="run_+3A_solver">solver</code></td>
<td>
<p>Which numerical solver to utilize. Default is 'ssm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+SimInf_model">SimInf_model</a></code> object with result from
simulation.
</p>


<h3>References</h3>

<p>S. Widgren, P. Bauer, R. Eriksson and S. Engblom. <span class="pkg">SimInf</span>: An R Package for Data-Driven Stochastic Disease Spread Simulations. <em>Journal of Statistical Software</em>, <strong>91</strong>(12), 1&ndash;42. <a href="https://doi.org/10.18637/jss.v091.i12">doi:10.18637/jss.v091.i12</a>. An updated version of this paper is available as a vignette in the package.
</p>
<p>P. Bauer, S. Engblom and S. Widgren. Fast Event-Based Epidemiological Simulations on National Scales. <em>International Journal of High Performance Computing Applications</em>, <strong>30</strong>(4), 438&ndash;453, 2016. doi: 10.1177/1094342016635723
</p>
<p>P. Bauer and S. Engblom. Sensitivity Estimation and Inverse Problems in Spatial Stochastic Models of Chemical Kinetics. In: A. Abdulle, S. Deparis, D. Kressner, F. Nobile and M. Picasso (eds.), <em>Numerical Mathematics and Advanced Applications - ENUMATH 2013</em>, pp. 519&ndash;527, Lecture Notes in Computational Science and Engineering, vol 103. Springer, Cham, 2015. <a href="https://doi.org/10.1007/978-3-319-10705-9_51">doi:10.1007/978-3-319-10705-9_51</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 10 nodes and initialise
## it to run over 100 days.
model &lt;- SIR(u0 = data.frame(S = rep(99, 10),
                             I = rep(1, 10),
                             R = rep(0, 10)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the model and save the result.
result &lt;- run(model)

## Plot the proportion of susceptible, infected and recovered
## individuals.
plot(result)
</code></pre>

<hr>
<h2 id='SEIR'>Create an <abbr><span class="acronym">SEIR</span></abbr> model</h2><span id='topic+SEIR'></span>

<h3>Description</h3>

<p>Create an <abbr><span class="acronym">SEIR</span></abbr> model to be used by the simulation
framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEIR(u0, tspan, events = NULL, beta = NULL, epsilon = NULL, gamma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SEIR_+3A_u0">u0</code></td>
<td>
<p>A <code>data.frame</code> with the initial state in each node
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="SEIR_+3A_tspan">tspan</code></td>
<td>
<p>A vector (length &gt;= 1) of increasing time points
where the state of each node is to be returned. Can be either
an <code>integer</code> or a <code>Date</code> vector. A <code>Date</code>
vector is coerced to a numeric vector as days, where
<code>tspan[1]</code> becomes the day of the year of the first year
of <code>tspan</code>. The dates are added as names to the numeric
vector.</p>
</td></tr>
<tr><td><code id="SEIR_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> with the scheduled events, see
<code><a href="#topic+SimInf_model">SimInf_model</a></code>.</p>
</td></tr>
<tr><td><code id="SEIR_+3A_beta">beta</code></td>
<td>
<p>A numeric vector with the transmission rate from
susceptible to infected where each node can have a different
beta value. The vector must have length 1 or <code>nrow(u0)</code>.
If the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.</p>
</td></tr>
<tr><td><code id="SEIR_+3A_epsilon">epsilon</code></td>
<td>
<p>A numeric vector with the incubation rate from
exposed to infected where each node can have a different
epsilon value. The vector must have length 1 or
<code>nrow(u0)</code>.  If the vector has length 1, but the model
contains more nodes, the epsilon value is repeated in all
nodes.</p>
</td></tr>
<tr><td><code id="SEIR_+3A_gamma">gamma</code></td>
<td>
<p>A numeric vector with the recovery rate from infected
to recovered where each node can have a different gamma
value. The vector must have length 1 or <code>nrow(u0)</code>. If
the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <abbr><span class="acronym">SEIR</span></abbr> model contains four compartments; number of
susceptible (S), number of exposed (E) (those who have been
infected but are not yet infectious), number of infectious (I),
and number of recovered (R).  Moreover, it has three state
transitions,
</p>
<p style="text-align: center;"><code class="reqn">S \stackrel{\beta S I / N}{\longrightarrow} E</code>
</p>

<p style="text-align: center;"><code class="reqn">E \stackrel{\epsilon E}{\longrightarrow} I</code>
</p>

<p style="text-align: center;"><code class="reqn">I \stackrel{\gamma I}{\longrightarrow} R</code>
</p>

<p>where <code class="reqn">\beta</code> is the transmission rate, <code class="reqn">\epsilon</code> is the
incubation rate, <code class="reqn">\gamma</code> is the recovery rate, and
<code class="reqn">N=S+E+I+R</code>.
</p>
<p>The argument <code>u0</code> must be a <code>data.frame</code> with one row for
each node with the following columns:
</p>

<dl>
<dt>S</dt><dd><p>The number of sucsceptible in each node</p>
</dd>
<dt>E</dt><dd><p>The number of exposed in each node</p>
</dd>
<dt>I</dt><dd><p>The number of infected in each node</p>
</dd>
<dt>R</dt><dd><p>The number of recovered in each node</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="#topic+SimInf_model">SimInf_model</a></code> of class <code>SEIR</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a SEIR model object.
model &lt;- SEIR(u0 = data.frame(S = 99, E = 0, I = 1, R = 0),
              tspan = 1:100,
              beta = 0.16,
              epsilon = 0.25,
              gamma = 0.077)

## Run the SEIR model and plot the result.
set.seed(3)
result &lt;- run(model)
plot(result)
</code></pre>

<hr>
<h2 id='SEIR-class'>Definition of the &lsquo;SEIR&rsquo; model</h2><span id='topic+SEIR-class'></span>

<h3>Description</h3>

<p>Class to handle the SEIR <code><a href="#topic+SimInf_model">SimInf_model</a></code>.
</p>

<hr>
<h2 id='select_matrix'>Extract the select matrix from a <code>SimInf_model</code> object</h2><span id='topic+select_matrix'></span><span id='topic+select_matrix+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Utility function to extract <code>events@E</code> from a
<code>SimInf_model</code> object, see <code><a href="#topic+SimInf_events-class">SimInf_events</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_matrix(model)

## S4 method for signature 'SimInf_model'
select_matrix(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_matrix_+3A_model">model</code></td>
<td>
<p>The <code>model</code> to extract the select matrix
<code>E</code> from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Extract the select matrix from the model
select_matrix(model)
</code></pre>

<hr>
<h2 id='select_matrix+26lt+3B-'>Set the select matrix for a <code>SimInf_model</code> object</h2><span id='topic+select_matrix+3C-'></span><span id='topic+select_matrix+3C-+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Utility function to set <code>events@E</code> in a <code>SimInf_model</code>
object, see <code><a href="#topic+SimInf_events-class">SimInf_events</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_matrix(model) &lt;- value

## S4 replacement method for signature 'SimInf_model'
select_matrix(model) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_matrix+2B26lt+2B3B-_+3A_model">model</code></td>
<td>
<p>The <code>model</code> to set the select matrix for.</p>
</td></tr>
<tr><td><code id="select_matrix+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Set the select matrix
select_matrix(model) &lt;- matrix(c(1, 0, 0, 1, 1, 1, 0, 0, 1), nrow = 3)

## Extract the select matrix from the model
select_matrix(model)
</code></pre>

<hr>
<h2 id='set_num_threads'>Specify the number of threads that SimInf should use</h2><span id='topic+set_num_threads'></span>

<h3>Description</h3>

<p>Set the number of threads to be used in SimInf code that is
parallelized with OpenMP (if available). The number of threads is
initialized when SimInf is first loaded in the R session using
optional envioronment variables (see &lsquo;Details&rsquo;). It is also
possible to specify the number of threads by calling
<code>set_num_threads</code>. If the environment variables that affect
the number of threads change, then <code>set_num_threads</code> must be
called again for it to take effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_num_threads(threads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_num_threads_+3A_threads">threads</code></td>
<td>
<p>integer with maximum number of threads to use in
functions that are parallelized with OpenMP (if
available). Default is NULL, i.e. to use all available
processors and then check for limits in the environment
varibles (see &lsquo;Details&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>omp_get_num_procs()</code> function is used to determine the
number of processors that are available to the device at the time
the routine is called. The number of threads is then limited by
<code>omp_get_thread_limit()</code> and the current values of the
environmental variables (if set)
</p>

<ul>
<li><p><code>Sys.getenv("OMP_THREAD_LIMIT")</code>
</p>
</li>
<li><p><code>Sys.getenv("OMP_NUM_THREADS")</code>
</p>
</li>
<li><p><code>Sys.getenv("SIMINF_NUM_THREADS")</code>
</p>
</li></ul>

<p>Additionally, the maximum number of threads can be controlled by
the <code>threads</code> argument, given that its value is not above any
of the limits described above.
</p>


<h3>Value</h3>

<p>The previous value is returned (invisible).
</p>

<hr>
<h2 id='shift_matrix'>Extract the shift matrix from a <code>SimInf_model</code> object</h2><span id='topic+shift_matrix'></span><span id='topic+shift_matrix+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Utility function to extract the shift matrix <code>events@N</code> from
a <code>SimInf_model</code> object, see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_matrix(model)

## S4 method for signature 'SimInf_model'
shift_matrix(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_matrix_+3A_model">model</code></td>
<td>
<p>The <code>model</code> to extract the shift matrix
<code>events@N</code> from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mtrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Extract the shift matrix from the model
shift_matrix(model)
</code></pre>

<hr>
<h2 id='shift_matrix+26lt+3B-'>Set the shift matrix for a <code>SimInf_model</code> object</h2><span id='topic+shift_matrix+3C-'></span><span id='topic+shift_matrix+3C-+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Utility function to set <code>events@N</code> in a <code>SimInf_model</code>
object, see <code><a href="#topic+SimInf_events-class">SimInf_events</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_matrix(model) &lt;- value

## S4 replacement method for signature 'SimInf_model'
shift_matrix(model) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_matrix+2B26lt+2B3B-_+3A_model">model</code></td>
<td>
<p>The <code>model</code> to set the shift matrix
<code>events@N</code>.</p>
</td></tr>
<tr><td><code id="shift_matrix+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SimInf_model</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Set the shift matrix
shift_matrix(model) &lt;- matrix(c(2, 1, 0), nrow = 3)

## Extract the shift matrix from the model
shift_matrix(model)
</code></pre>

<hr>
<h2 id='show+2CSimInf_abc-method'>Print summary of a <code>SimInf_abc</code> object</h2><span id='topic+show+2CSimInf_abc-method'></span>

<h3>Description</h3>

<p>Print summary of a <code>SimInf_abc</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_abc'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSimInf_abc-method_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_abc</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(object)</code>.
</p>

<hr>
<h2 id='show+2CSimInf_events-method'>Brief summary of <code>SimInf_events</code></h2><span id='topic+show+2CSimInf_events-method'></span>

<h3>Description</h3>

<p>Shows the number of scheduled events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_events'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSimInf_events-method_+3A_object">object</code></td>
<td>
<p>The SimInf_events <code>object</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (invisible 'NULL').
</p>

<hr>
<h2 id='show+2CSimInf_indiv_events-method'>Print summary of a <code>SimInf_indiv_events</code> object</h2><span id='topic+show+2CSimInf_indiv_events-method'></span>

<h3>Description</h3>

<p>Print summary of a <code>SimInf_indiv_events</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_indiv_events'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSimInf_indiv_events-method_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_indiv_events</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(object)</code>.
</p>

<hr>
<h2 id='show+2CSimInf_model-method'>Brief summary of <code>SimInf_model</code></h2><span id='topic+show+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Brief summary of <code>SimInf_model</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_model'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSimInf_model-method_+3A_object">object</code></td>
<td>
<p>The SimInf_model <code>object</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (invisible 'NULL').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an 'SIR' model with 10 nodes and initialise
## it to run over 100 days.
model &lt;- SIR(u0 = data.frame(S = rep(99, 10),
                             I = rep(1, 10),
                             R = rep(0, 10)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Brief summary of the model
model

## Run the model and save the result
result &lt;- run(model)

## Brief summary of the result. Note that 'U' and 'V' are
## non-empty after running the model.
result
</code></pre>

<hr>
<h2 id='show+2CSimInf_pfilter-method'>Brief summary of a <code>SimInf_pfilter</code> object</h2><span id='topic+show+2CSimInf_pfilter-method'></span>

<h3>Description</h3>

<p>Brief summary of a <code>SimInf_pfilter</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_pfilter'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSimInf_pfilter-method_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_pfilter</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(object)</code>.
</p>

<hr>
<h2 id='SimInf_abc-class'>Class <code>"SimInf_abc"</code></h2><span id='topic+SimInf_abc-class'></span>

<h3>Description</h3>

<p>Class <code>"SimInf_abc"</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>The <code>SimInf_model</code> object to estimate parameters
in.</p>
</dd>
<dt><code>priors</code></dt><dd><p>A <code>data.frame</code> containing the four columns
<code>parameter</code>, <code>distribution</code>, <code>p1</code> and
<code>p2</code>. The column <code>parameter</code> gives the name of the
parameter referred to in the model. The column
<code>distribution</code> contains the name of the prior
distribution. Valid distributions are 'gamma', 'normal' or
'uniform'. The column <code>p1</code> is a numeric vector with the
first hyperparameter for each prior: 'gamma') shape, 'normal')
mean, and 'uniform') lower bound. The column <code>p2</code> is a
numeric vector with the second hyperparameter for each prior:
'gamma') rate, 'normal') standard deviation, and 'uniform')
upper bound.</p>
</dd>
<dt><code>target</code></dt><dd><p>Character vector (<code>gdata</code> or <code>ldata</code>) that
determines if the ABC-SMC method estimates parameters in
<code>model@gdata</code> or in <code>model@ldata</code>.</p>
</dd>
<dt><code>pars</code></dt><dd><p>Index to the parameters in <code>target</code>.</p>
</dd>
<dt><code>nprop</code></dt><dd><p>An integer vector with the number of simulated
proposals in each generation.</p>
</dd>
<dt><code>fn</code></dt><dd><p>A function for calculating the summary statistics for the
simulated trajectory and determine the distance for each
particle, see <code><a href="#topic+abc">abc</a></code> for more details.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>A numeric matrix (number of summary statistics
<code class="reqn">\times</code> number of generations) where each column contains
the tolerances for a generation and each row contains a
sequence of gradually decreasing tolerances.</p>
</dd>
<dt><code>x</code></dt><dd><p>A numeric array (number of particles <code class="reqn">\times</code> number
of parameters <code class="reqn">\times</code> number of generations) with the
parameter values for the accepted particles in each
generation. Each row is one particle.</p>
</dd>
<dt><code>weight</code></dt><dd><p>A numeric matrix (number of particles <code class="reqn">\times</code>
number of generations) with the weights for the particles
<code>x</code> in the corresponding generation.</p>
</dd>
<dt><code>distance</code></dt><dd><p>A numeric array (number of particles <code class="reqn">\times</code>
number of summary statistics <code class="reqn">\times</code> number of
generations) with the distance for the particles <code>x</code> in
each generation. Each row contains the distance for a particle
and each column contains the distance for a summary statistic.</p>
</dd>
<dt><code>ess</code></dt><dd><p>A numeric vector with the effective sample size (ESS) in
each generation. The effective sample size is computed as
</p>
<p style="text-align: center;"><code class="reqn">\left(\sum_{i=1}^N\!(w_{g}^{(i)})^2\right)^{-1},</code>
</p>
<p> where <code class="reqn">w_{g}^{(i)}</code> is the
normalized weight of particle <code class="reqn">i</code> in generation <code class="reqn">g</code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+abc">abc</a></code> and <code><a href="#topic+continue">continue</a></code>.
</p>

<hr>
<h2 id='SimInf_events'>Create a <code><a href="#topic+SimInf_events-class">SimInf_events</a></code> object</h2><span id='topic+SimInf_events'></span>

<h3>Description</h3>

<p>The argument events must be a <code>data.frame</code> with the following
columns:
</p>

<dl>
<dt>event</dt><dd>
<p>Four event types are supported by the current solvers:
<em>exit</em>, <em>enter</em>, <em>internal transfer</em>, and
<em>external transfer</em>.  When assigning the events, they can
either be coded as a numerical value or a character string:
<em>exit;</em> <code>0</code> or <code>'exit'</code>, <em>enter;</em> <code>1</code>
or <code>'enter'</code>, <em>internal transfer;</em> <code>2</code> or
<code>'intTrans'</code>, and <em>external transfer;</em> <code>3</code> or
<code>'extTrans'</code>.  Internally in <span class="pkg">SimInf</span>, the event type
is coded as a numerical value.
</p>
</dd>
<dt>time</dt><dd>
<p>When the event occurs i.e., the event is processed when time
is reached in the simulation. Can be either an <code>integer</code>
or a <code>Date</code> vector.  A <code>Date</code> vector is coerced to a
numeric vector as days, where <code>t0</code> determines the offset
to match the time of the events to the model <code>tspan</code>
vector.
</p>
</dd>
<dt>node</dt><dd>
<p>The node that the event operates on. Also the source node for
an <em>external transfer</em> event.
1 &lt;= <code>node[i]</code> &lt;= Number of nodes.
</p>
</dd>
<dt>dest</dt><dd>
<p>The destination node for an <em>external transfer</em> event
i.e., individuals are moved from <code>node</code> to <code>dest</code>,
where 1 &lt;= <code>dest[i]</code> &lt;= Number of nodes.  Set <code>event
    = 0</code> for the other event types.  <code>dest</code> is an integer
vector.
</p>
</dd>
<dt>n</dt><dd>
<p>The number of individuals affected by the event. n[i] &gt;= 0.
</p>
</dd>
<dt>proportion</dt><dd>
<p>If <code>n[i]</code> equals zero, the number of individuals affected
by <code>event[i]</code> is calculated by sampling the number of
individuals from a binomial distribution using the
<code>proportion[i]</code> and the number of individuals in the
compartments. Numeric vector.  0 &lt;= proportion[i] &lt;= 1.
</p>
</dd>
<dt>select</dt><dd>
<p>To process an <code>event[i]</code>, the compartments affected by
the event are specified with <code>select[i]</code> together with
the matrix <code>E</code>, where <code>select[i]</code> determines which
column in <code>E</code> to use.  The specific individuals affected
by the event are sampled from the compartments corresponding
to the non-zero entries in the specified column in <code>E[,
    select[i]]</code>, where <code>select</code> is an integer vector.
</p>
</dd>
<dt>shift</dt><dd>
<p>Determines how individuals in <em>internal transfer</em> and
<em>external transfer</em> events are shifted to enter another
compartment.  The sampled individuals are shifted according to
column <code>shift[i]</code> in matrix <code>N</code> i.e., <code>N[,
    shift[i]]</code>, where <code>shift</code> is an integer vector.  See
above for a description of <code>N</code>. Unsued for the other
event types.
</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>SimInf_events(E = NULL, N = NULL, events = NULL, t0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimInf_events_+3A_e">E</code></td>
<td>
<p>Each row corresponds to one compartment in the model. The
non-zero entries in a column indicates the compartments to
include in an event.  For the <em>exit</em>, <em>internal
transfer</em> and <em>external transfer</em> events, a non-zero
entry indicate the compartments to sample individuals from.
For the <em>enter</em> event, all individuals enter first
non-zero compartment. <code>E</code> is sparse matrix of class
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="SimInf_events_+3A_n">N</code></td>
<td>
<p>Determines how individuals in <em>internal transfer</em>
and <em>external transfer</em> events are shifted to enter
another compartment.  Each row corresponds to one compartment
in the model.  The values in a column are added to the current
compartment of sampled individuals to specify the destination
compartment, for example, a value of <code>1</code> in an entry
means that sampled individuals in this compartment are moved
to the next compartment.  Which column to use for each event
is specified by the <code>shift</code> vector (see below).  <code>N</code>
is an integer matrix.</p>
</td></tr>
<tr><td><code id="SimInf_events_+3A_events">events</code></td>
<td>
<p>A <code>data.frame</code> with events.</p>
</td></tr>
<tr><td><code id="SimInf_events_+3A_t0">t0</code></td>
<td>
<p>If <code>events$time</code> is a <code>Date</code> vector, then
<code>t0</code> determines the offset to match the time of the
events to the model <code>tspan</code> vector, see details. If
<code>events$time</code> is a numeric vector, then <code>t0</code> must be
<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S4 class <code>SimInf_events</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Let us illustrate how movement events can be used to transfer
## individuals from one node to another.  Use the built-in SIR
## model and start with 2 nodes where all individuals are in the
## first node (100 per compartment).
u0 &lt;- data.frame(S = c(100, 0), I = c(100, 0), R = c(100, 0))

## Then create 300 movement events to transfer all individuals,
## one per day, from the first node to the second node. Use the
## fourth column in the select matrix where all compartments
## can be sampled with equal weight.
events &lt;- data.frame(event      = rep("extTrans", 300),
                     time       = 1:300,
                     node       = 1,
                     dest       = 2,
                     n          = 1,
                     proportion = 0,
                     select     = 4,
                     shift      = 0)

## Create an SIR model without disease transmission to
## demonstrate the events.
model &lt;- SIR(u0      = u0,
             tspan  = 1:300,
             events = events,
             beta   = 0,
             gamma  = 0)

## Run the model and plot the number of individuals in
## the second node.  As can be seen in the figure, all
## indivuduals have been moved to the second node when
## t = 300.
plot(run(model), index = 1:2, range = FALSE)

## Let us now double the weight to sample from the 'I'
## compartment and rerun the model.
model@events@E[2, 4] &lt;- 2
plot(run(model), index = 1:2, range = FALSE)

## And much larger weight to sample from the I compartment.
model@events@E[2, 4] &lt;- 10
plot(run(model), index = 1:2, range = FALSE)

## Increase the weight for the R compartment.
model@events@E[3, 4] &lt;- 4
plot(run(model), index = 1:2, range = FALSE)
</code></pre>

<hr>
<h2 id='SimInf_events-class'>Class <code>"SimInf_events"</code></h2><span id='topic+SimInf_events-class'></span>

<h3>Description</h3>

<p>Class to hold data for scheduled events to modify the discrete
state of individuals in a node at a pre-defined time t.
</p>


<h3>Slots</h3>


<dl>
<dt><code>E</code></dt><dd><p>Each row corresponds to one compartment in the model. The
non-zero entries in a column indicates the compartments to
include in an event.  For the <em>exit</em>, <em>internal
transfer</em> and <em>external transfer</em> events, a non-zero
entry indicate the compartments to sample individuals from.
For the <em>enter</em> event, all individuals enter first
non-zero compartment. <code>E</code> is sparse matrix of class
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</dd>
<dt><code>N</code></dt><dd><p>Determines how individuals in <em>internal transfer</em> and
<em>external transfer</em> events are shifted to enter another
compartment.  Each row corresponds to one compartment in the
model.  The values in a column are added to the current
compartment of sampled individuals to specify the destination
compartment, for example, a value of <code>1</code> in an entry
means that sampled individuals in this compartment are moved
to the next compartment.  Which column to use for each event
is specified by the <code>shift</code> vector (see below).  <code>N</code>
is an integer matrix.</p>
</dd>
<dt><code>event</code></dt><dd><p>Type of event: 0) <em>exit</em>, 1) <em>enter</em>, 2)
<em>internal transfer</em>, and 3) <em>external transfer</em>.
Other values are reserved for future event types and not
supported by the current solvers. Integer vector.</p>
</dd>
<dt><code>time</code></dt><dd><p>Time of when the event occurs i.e., the event is
processed when time is reached in the simulation.  <code>time</code>
is an integer vector.</p>
</dd>
<dt><code>node</code></dt><dd><p>The node that the event operates on. Also the source
node for an <em>external transfer</em> event.  Integer vector.
1 &lt;= <code>node[i]</code> &lt;= Number of nodes.</p>
</dd>
<dt><code>dest</code></dt><dd><p>The destination node for an <em>external transfer</em>
event i.e., individuals are moved from <code>node</code> to
<code>dest</code>, where 1 &lt;= <code>dest[i]</code> &lt;= Number of nodes.
Set <code>event = 0</code> for the other event types.  <code>dest</code>
is an integer vector.</p>
</dd>
<dt><code>n</code></dt><dd><p>The number of individuals affected by the event. Integer
vector.  n[i] &gt;= 0.</p>
</dd>
<dt><code>proportion</code></dt><dd><p>If <code>n[i]</code> equals zero, the number of
individuals affected by <code>event[i]</code> is calculated by
sampling the number of individuals from a binomial
distribution using the <code>proportion[i]</code> and the number of
individuals in the compartments. Numeric vector.  0 &lt;=
proportion[i] &lt;= 1.</p>
</dd>
<dt><code>select</code></dt><dd><p>To process <code>event[i]</code>, the compartments affected
by the event are specified with <code>select[i]</code> together with
the matrix <code>E</code>, where <code>select[i]</code> determines which
column in <code>E</code> to use.  The specific individuals affected
by the event are proportionally sampled from the compartments
corresponding to the non-zero entries in the specified column
in <code>E[, select[i]]</code>, where <code>select</code> is an integer
vector.</p>
</dd>
<dt><code>shift</code></dt><dd><p>Determines how individuals in <em>internal transfer</em>
and <em>external transfer</em> events are shifted to enter
another compartment.  The sampled individuals are shifted
according to column <code>shift[i]</code> in matrix <code>N</code> i.e.,
<code>N[, shift[i]]</code>, where <code>shift</code> is an integer vector.
See above for a description of <code>N</code>. Unsued for the other
event types.</p>
</dd>
</dl>

<hr>
<h2 id='SimInf_indiv_events-class'>Class <code>"SimInf_indiv_events"</code></h2><span id='topic+SimInf_indiv_events-class'></span>

<h3>Description</h3>

<p>Class <code>"SimInf_indiv_events"</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>id</code></dt><dd><p>an integer or character identifier of the individual.</p>
</dd>
<dt><code>event</code></dt><dd><p>four event types are supported: <em>exit</em>,
<em>enter</em>, <em>internal transfer</em>, and <em>external
transfer</em>.  When assigning the events, they can either be
coded as a numerical value or a character string: <em>exit;</em>
<code>0</code> or <code>'exit'</code>, <em>enter;</em> <code>1</code> or
<code>'enter'</code>, <em>internal transfer;</em> <code>2</code> or
<code>'intTrans'</code>, and <em>external transfer;</em> <code>3</code> or
<code>'extTrans'</code>.</p>
</dd>
<dt><code>time</code></dt><dd><p>an integer, character, or date (of class <code>Date</code>)
for when the event occured. If it's a character it must be
able to coerce to <code>Date</code>.</p>
</dd>
<dt><code>node</code></dt><dd><p>an integer or character identifier of the source node.</p>
</dd>
<dt><code>dest</code></dt><dd><p>an integer or character identifier of the destination
node.</p>
</dd>
</dl>

<hr>
<h2 id='SimInf_model'>Create a <code>SimInf_model</code></h2><span id='topic+SimInf_model'></span>

<h3>Description</h3>

<p>Create a <code>SimInf_model</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimInf_model(
  G,
  S,
  tspan,
  events = NULL,
  ldata = NULL,
  gdata = NULL,
  U = NULL,
  u0 = NULL,
  v0 = NULL,
  V = NULL,
  E = NULL,
  N = NULL,
  C_code = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimInf_model_+3A_g">G</code></td>
<td>
<p>Dependency graph that indicates the transition rates that
need to be updated after a given state transition has occured.
A non-zero entry in element <code>G[i, i]</code> indicates that
transition rate <code>i</code> needs to be recalculated if the state
transition <code>j</code> occurs. Sparse matrix (<code class="reqn">Nt \times Nt</code>)
of object class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_s">S</code></td>
<td>
<p>Each column corresponds to a transition, and execution of
state transition <code>j</code> amounts to adding the <code>S[, j]</code>
to the state vector of the node where the state transition
occurred.  Sparse matrix (<code class="reqn">Nc \times Nt</code>) of object class
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_tspan">tspan</code></td>
<td>
<p>A vector (length &gt;= 1) of increasing time points
where the state of each node is to be returned. Can be either
an <code>integer</code> or a <code>Date</code> vector. A <code>Date</code>
vector is coerced to a numeric vector as days, where
<code>tspan[1]</code> becomes the day of the year of the first year
of <code>tspan</code>. The dates are added as names to the numeric
vector.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_events">events</code></td>
<td>
<p>A <code>data.frame</code> with the scheduled events.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_ldata">ldata</code></td>
<td>
<p>local data for the nodes. Can either be specified as
a <code>data.frame</code> with one row per node. Or as a matrix
where each column <code>ldata[, j]</code> contains the local data
vector for the node <code>j</code>. The local data vector is passed
as an argument to the transition rate functions and the post
time step function.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_gdata">gdata</code></td>
<td>
<p>A numeric vector with global data that is common to
all nodes. The global data vector is passed as an argument to
the transition rate functions and the post time step function.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_u">U</code></td>
<td>
<p>The result matrix with the number of individuals in each
disease state in every node (<code class="reqn">N_n N_c \times</code>
<code>length(tspan)</code>).  <code>U[, j]</code> contains the number of
individuals in each disease state at
<code>tspan[j]</code>. <code>U[1:Nc, j]</code> contains the state of node
<code>1</code> at <code>tspan[j]</code>. <code>U[(Nc + 1):(2 * Nc), j]</code>
contains the state of node <code>2</code> at <code>tspan[j]</code> etc.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_u0">u0</code></td>
<td>
<p>The initial state vector. Either a matrix (<code class="reqn">N_c
\times N_n</code>) or a a <code>data.frame</code> with the number of
individuals in each compartment in every node.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_v0">v0</code></td>
<td>
<p>The initial continuous state vector in every node.
(<code>dim(ldata)[1]</code> <code class="reqn">\times N_N</code>). The continuous state
vector is updated by the specific model during the simulation
in the post time step function.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_v">V</code></td>
<td>
<p>The result matrix for the real-valued continous
compartment state (<code class="reqn">N_n</code><code>dim(ldata)[1]</code> <code class="reqn">\times</code>
<code>length(tspan)</code>).  <code>V[, j]</code> contains the real-valued
state of the system at <code>tspan[j]</code>.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_e">E</code></td>
<td>
<p>Sparse matrix to handle scheduled events, see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_n">N</code></td>
<td>
<p>Sparse matrix to handle scheduled events, see
<code><a href="#topic+SimInf_events-class">SimInf_events</a></code>.</p>
</td></tr>
<tr><td><code id="SimInf_model_+3A_c_code">C_code</code></td>
<td>
<p>Character vector with optional model C code. If
non-empty, the C code is written to a temporary C-file when
the <code>run</code> method is called.  The temporary C-file is
compiled and the resulting DLL is dynamically loaded. The DLL
is unloaded and the temporary files are removed after running
the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+SimInf_model-class">SimInf_model</a>
</p>

<hr>
<h2 id='SimInf_model-class'>Class <code>"SimInf_model"</code></h2><span id='topic+SimInf_model-class'></span>

<h3>Description</h3>

<p>Class to handle data for the <code>SimInf_model</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>G</code></dt><dd><p>Dependency graph that indicates the transition rates that
need to be updated after a given state transition has occured.
A non-zero entry in element <code>G[i, i]</code> indicates that
transition rate <code>i</code> needs to be recalculated if the state
transition <code>j</code> occurs. Sparse matrix (<code class="reqn">Nt \times Nt</code>)
of object class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</dd>
<dt><code>S</code></dt><dd><p>Each column corresponds to a state transition, and
execution of state transition <code>j</code> amounts to adding the
<code>S[, j]</code> column to the state vector <code>u[, i]</code> of node
<em>i</em> where the transition occurred. Sparse matrix (<code class="reqn">Nc
\times Nt</code>) of object class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</dd>
<dt><code>U</code></dt><dd><p>The result matrix with the number of individuals in each
compartment in every node. <code>U[, j]</code> contains the number
of individuals in each compartment at
<code>tspan[j]</code>. <code>U[1:Nc, j]</code> contains the number of
individuals in node 1 at <code>tspan[j]</code>. <code>U[(Nc + 1):(2
* Nc), j]</code> contains the number of individuals in node 2 at
<code>tspan[j]</code> etc. Integer matrix (<code class="reqn">N_n N_c \times</code>
<code>length(tspan)</code>).</p>
</dd>
<dt><code>U_sparse</code></dt><dd><p>If the model was configured to write the solution
to a sparse matrix (<code>dgCMatrix</code>) the <code>U_sparse</code>
contains the data and <code>U</code> is empty. The layout of the
data in <code>U_sparse</code> is identical to <code>U</code>. Please note
that <code>U_sparse</code> is numeric and <code>U</code> is integer.</p>
</dd>
<dt><code>V</code></dt><dd><p>The result matrix for the real-valued continuous
state. <code>V[, j]</code> contains the real-valued state of the
system at <code>tspan[j]</code>. Numeric matrix
(<code class="reqn">N_n</code><code>dim(ldata)[1]</code> <code class="reqn">\times</code>
<code>length(tspan)</code>).</p>
</dd>
<dt><code>V_sparse</code></dt><dd><p>If the model was configured to write the solution
to a sparse matrix (<code>dgCMatrix</code>) the <code>V_sparse</code>
contains the data and <code>V</code> is empty. The layout of the
data in <code>V_sparse</code> is identical to <code>V</code>.</p>
</dd>
<dt><code>ldata</code></dt><dd><p>A matrix with local data for the nodes. The column
<code>ldata[, j]</code> contains the local data vector for the node
<code>j</code>. The local data vector is passed as an argument to
the transition rate functions and the post time step function.</p>
</dd>
<dt><code>gdata</code></dt><dd><p>A numeric vector with global data that is common to
all nodes.  The global data vector is passed as an argument to
the transition rate functions and the post time step function.</p>
</dd>
<dt><code>tspan</code></dt><dd><p>A vector of increasing time points where the state of
each node is to be returned.</p>
</dd>
<dt><code>u0</code></dt><dd><p>The initial state vector (<code class="reqn">N_c \times N_n</code>) with the
number of individuals in each compartment in every node.</p>
</dd>
<dt><code>v0</code></dt><dd><p>The initial value for the real-valued continuous state.
Numeric matrix (<code>dim(ldata)[1]</code> <code class="reqn">\times N_n</code>).</p>
</dd>
<dt><code>events</code></dt><dd><p>Scheduled events <code><a href="#topic+SimInf_events-class">SimInf_events</a></code></p>
</dd>
<dt><code>C_code</code></dt><dd><p>Character vector with optional model C code. If
non-empty, the C code is written to a temporary C-file when
the <code>run</code> method is called.  The temporary C-file is
compiled and the resulting DLL is dynamically loaded. The DLL
is unloaded and the temporary files are removed after running
the model.</p>
</dd>
</dl>

<hr>
<h2 id='SimInf_pfilter-class'>Class <code>"SimInf_pfilter"</code></h2><span id='topic+SimInf_pfilter-class'></span>

<h3>Description</h3>

<p>Class <code>"SimInf_pfilter"</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>A <code>SimInf_model</code> object with one filtered
trajectory attached.</p>
</dd>
<dt><code>npart</code></dt><dd><p>An integer with the number of particles that was used
at each timestep.</p>
</dd>
<dt><code>loglik</code></dt><dd><p>The estimated log likelihood.</p>
</dd>
<dt><code>ess</code></dt><dd><p>A numeric vector with the effective sample size (ESS).
The effective sample size is computed as
</p>
<p style="text-align: center;"><code class="reqn">\left(\sum_{i=1}^N\!(w_{t}^{i})^2\right)^{-1},</code>
</p>
<p> where <code class="reqn">w_{t}^{i}</code> is the normalized
weight of particle <code class="reqn">i</code> at time <code class="reqn">t</code>.</p>
</dd>
</dl>

<hr>
<h2 id='SIR'>Create an <abbr><span class="acronym">SIR</span></abbr> model</h2><span id='topic+SIR'></span>

<h3>Description</h3>

<p>Create an <abbr><span class="acronym">SIR</span></abbr> model to be used by the simulation
framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SIR(u0, tspan, events = NULL, beta = NULL, gamma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SIR_+3A_u0">u0</code></td>
<td>
<p>A <code>data.frame</code> with the initial state in each node
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="SIR_+3A_tspan">tspan</code></td>
<td>
<p>A vector (length &gt;= 1) of increasing time points
where the state of each node is to be returned. Can be either
an <code>integer</code> or a <code>Date</code> vector. A <code>Date</code>
vector is coerced to a numeric vector as days, where
<code>tspan[1]</code> becomes the day of the year of the first year
of <code>tspan</code>. The dates are added as names to the numeric
vector.</p>
</td></tr>
<tr><td><code id="SIR_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> with the scheduled events, see
<code><a href="#topic+SimInf_model">SimInf_model</a></code>.</p>
</td></tr>
<tr><td><code id="SIR_+3A_beta">beta</code></td>
<td>
<p>A numeric vector with the transmission rate from
susceptible to infected where each node can have a different
beta value. The vector must have length 1 or <code>nrow(u0)</code>.
If the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.</p>
</td></tr>
<tr><td><code id="SIR_+3A_gamma">gamma</code></td>
<td>
<p>A numeric vector with the recovery rate from infected
to recovered where each node can have a different gamma
value. The vector must have length 1 or <code>nrow(u0)</code>. If
the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <abbr><span class="acronym">SIR</span></abbr> model contains three compartments; number of
susceptible (S), number of infectious (I), and number of
recovered (R).  Moreover, it has two state transitions,
</p>
<p style="text-align: center;"><code class="reqn">S \stackrel{\beta S I / N}{\longrightarrow} I</code>
</p>

<p style="text-align: center;"><code class="reqn">I \stackrel{\gamma I}{\longrightarrow} R</code>
</p>

<p>where <code class="reqn">\beta</code> is the transmission rate, <code class="reqn">\gamma</code> is the
recovery rate, and <code class="reqn">N=S+I+R</code>.
</p>
<p>The argument <code>u0</code> must be a <code>data.frame</code> with one row for
each node with the following columns:
</p>

<dl>
<dt>S</dt><dd><p>The number of sucsceptible in each node</p>
</dd>
<dt>I</dt><dd><p>The number of infected in each node</p>
</dd>
<dt>R</dt><dd><p>The number of recovered in each node</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="#topic+SimInf_model">SimInf_model</a></code> of class <code>SIR</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model object.
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model and plot the result.
set.seed(22)
result &lt;- run(model)
plot(result)
</code></pre>

<hr>
<h2 id='SIR-class'>Definition of the <abbr><span class="acronym">SIR</span></abbr> model</h2><span id='topic+SIR-class'></span>

<h3>Description</h3>

<p>Class to handle the <abbr><span class="acronym">SIR</span></abbr> <code><a href="#topic+SimInf_model">SimInf_model</a></code>.
</p>


<h3>Details</h3>

<p>The <abbr><span class="acronym">SIR</span></abbr> model contains three compartments; number of
susceptible (S), number of infectious (I), and number of
recovered (R).  Moreover, it has two state transitions,
</p>
<p style="text-align: center;"><code class="reqn">S \stackrel{\beta S I / N}{\longrightarrow} I</code>
</p>

<p style="text-align: center;"><code class="reqn">I \stackrel{\gamma I}{\longrightarrow} R</code>
</p>

<p>where <code class="reqn">\beta</code> is the transmission rate, <code class="reqn">\gamma</code> is the
recovery rate, and <code class="reqn">N=S+I+R</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model object.
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model and plot the result.
set.seed(22)
result &lt;- run(model)
plot(result)
</code></pre>

<hr>
<h2 id='SIS'>Create an <abbr><span class="acronym">SIS</span></abbr> model</h2><span id='topic+SIS'></span>

<h3>Description</h3>

<p>Create an <abbr><span class="acronym">SIS</span></abbr> model to be used by the simulation
framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SIS(u0, tspan, events = NULL, beta = NULL, gamma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SIS_+3A_u0">u0</code></td>
<td>
<p>A <code>data.frame</code> with the initial state in each node
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="SIS_+3A_tspan">tspan</code></td>
<td>
<p>A vector (length &gt;= 1) of increasing time points
where the state of each node is to be returned. Can be either
an <code>integer</code> or a <code>Date</code> vector. A <code>Date</code>
vector is coerced to a numeric vector as days, where
<code>tspan[1]</code> becomes the day of the year of the first year
of <code>tspan</code>. The dates are added as names to the numeric
vector.</p>
</td></tr>
<tr><td><code id="SIS_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> with the scheduled events, see
<code><a href="#topic+SimInf_model">SimInf_model</a></code>.</p>
</td></tr>
<tr><td><code id="SIS_+3A_beta">beta</code></td>
<td>
<p>A numeric vector with the transmission rate from
susceptible to infected where each node can have a different
beta value. The vector must have length 1 or <code>nrow(u0)</code>.
If the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.</p>
</td></tr>
<tr><td><code id="SIS_+3A_gamma">gamma</code></td>
<td>
<p>A numeric vector with the recovery rate from infected
to recovered where each node can have a different gamma
value. The vector must have length 1 or <code>nrow(u0)</code>. If
the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <abbr><span class="acronym">SIS</span></abbr> model contains two compartments; number of
susceptible (S), and number of infectious (I).  Moreover, it has
two state transitions, </p>
<p style="text-align: center;"><code class="reqn">S \stackrel{\beta S I /
N}{\longrightarrow} I</code>
</p>
 <p style="text-align: center;"><code class="reqn">I
\stackrel{\gamma I}{\longrightarrow} S</code>
</p>
<p> where
<code class="reqn">\beta</code> is the transmission rate, <code class="reqn">\gamma</code> is the recovery
rate, and <code class="reqn">N=S+I</code>.
</p>
<p>The argument <code>u0</code> must be a <code>data.frame</code> with one row for
each node with the following columns:
</p>

<dl>
<dt>S</dt><dd><p>The number of sucsceptible in each node</p>
</dd>
<dt>I</dt><dd><p>The number of infected in each node</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="#topic+SimInf_model">SimInf_model</a></code> of class <code>SIS</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIS model object.
model &lt;- SIS(u0 = data.frame(S = 99, I = 1),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIS model and plot the result.
set.seed(22)
result &lt;- run(model)
plot(result)
</code></pre>

<hr>
<h2 id='SIS-class'>Definition of the <abbr><span class="acronym">SIS</span></abbr> model</h2><span id='topic+SIS-class'></span>

<h3>Description</h3>

<p>Class to handle the <abbr><span class="acronym">SIS</span></abbr> <code><a href="#topic+SimInf_model">SimInf_model</a></code>.
</p>


<h3>Details</h3>

<p>The <abbr><span class="acronym">SIS</span></abbr> model contains two compartments; number of
susceptible (S), and number of infectious (I).  Moreover, it has
two state transitions, </p>
<p style="text-align: center;"><code class="reqn">S \stackrel{\beta S I /
N}{\longrightarrow} I</code>
</p>
 <p style="text-align: center;"><code class="reqn">I
\stackrel{\gamma I}{\longrightarrow} S</code>
</p>
<p> where
<code class="reqn">\beta</code> is the transmission rate, <code class="reqn">\gamma</code> is the recovery
rate, and <code class="reqn">N=S+I</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIS model object.
model &lt;- SIS(u0 = data.frame(S = 99, I = 1),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIS model and plot the result.
set.seed(22)
result &lt;- run(model)
plot(result)
</code></pre>

<hr>
<h2 id='SISe'>Create a SISe model</h2><span id='topic+SISe'></span>

<h3>Description</h3>

<p>Create an &lsquo;SISe&rsquo; model to be used by the simulation
framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SISe(
  u0,
  tspan,
  events = NULL,
  phi = NULL,
  upsilon = NULL,
  gamma = NULL,
  alpha = NULL,
  beta_t1 = NULL,
  beta_t2 = NULL,
  beta_t3 = NULL,
  beta_t4 = NULL,
  end_t1 = NULL,
  end_t2 = NULL,
  end_t3 = NULL,
  end_t4 = NULL,
  epsilon = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SISe_+3A_u0">u0</code></td>
<td>
<p>A <code>data.frame</code> with the initial state in each node
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="SISe_+3A_tspan">tspan</code></td>
<td>
<p>A vector (length &gt;= 1) of increasing time points
where the state of each node is to be returned. Can be either
an <code>integer</code> or a <code>Date</code> vector. A <code>Date</code>
vector is coerced to a numeric vector as days, where
<code>tspan[1]</code> becomes the day of the year of the first year
of <code>tspan</code>. The dates are added as names to the numeric
vector.</p>
</td></tr>
<tr><td><code id="SISe_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> with the scheduled events, see
<code><a href="#topic+SimInf_model">SimInf_model</a></code>.</p>
</td></tr>
<tr><td><code id="SISe_+3A_phi">phi</code></td>
<td>
<p>A numeric vector with the initial environmental
infectious pressure in each node. Will be repeated to the
length of nrow(u0). Default is NULL which gives 0 in each
node.</p>
</td></tr>
<tr><td><code id="SISe_+3A_upsilon">upsilon</code></td>
<td>
<p>Indirect transmission rate of the environmental
infectious pressure</p>
</td></tr>
<tr><td><code id="SISe_+3A_gamma">gamma</code></td>
<td>
<p>The recovery rate from infected to susceptible</p>
</td></tr>
<tr><td><code id="SISe_+3A_alpha">alpha</code></td>
<td>
<p>Shed rate from infected individuals</p>
</td></tr>
<tr><td><code id="SISe_+3A_beta_t1">beta_t1</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 1.</p>
</td></tr>
<tr><td><code id="SISe_+3A_beta_t2">beta_t2</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 2.</p>
</td></tr>
<tr><td><code id="SISe_+3A_beta_t3">beta_t3</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 3.</p>
</td></tr>
<tr><td><code id="SISe_+3A_beta_t4">beta_t4</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 4.</p>
</td></tr>
<tr><td><code id="SISe_+3A_end_t1">end_t1</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 1 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe_+3A_end_t2">end_t2</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 2 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe_+3A_end_t3">end_t3</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 3 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe_+3A_end_t4">end_t4</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 4 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe_+3A_epsilon">epsilon</code></td>
<td>
<p>The background environmental infectious pressure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;SISe&rsquo; model contains two compartments; number of
susceptible (S) and number of infectious (I). Additionally, it
contains an environmental compartment to model shedding of a
pathogen to the environment. Consequently, the model has two state
transitions,
</p>
<p style="text-align: center;"><code class="reqn">S \stackrel{\upsilon \varphi S}{\longrightarrow} I</code>
</p>

<p style="text-align: center;"><code class="reqn">I \stackrel{\gamma I}{\longrightarrow} S</code>
</p>

<p>where the transition rate per unit of time from susceptible to
infected is proportional to the concentration of the environmental
contamination <code class="reqn">\varphi</code> in each node. Moreover, the
transition rate from infected to susceptible is the recovery rate
<code class="reqn">\gamma</code>, measured per individual and per unit of
time. Finally, the environmental infectious pressure in each node
is evolved by,
</p>
<p style="text-align: center;"><code class="reqn">\frac{d\varphi(t)}{dt} = \frac{\alpha I(t)}{N(t)} - \beta(t)
\varphi(t) + \epsilon</code>
</p>

<p>where <code class="reqn">\alpha</code> is the average shedding rate of the pathogen to
the environment per infected individual and <code class="reqn">N = S + I</code> the
size of the node. The seasonal decay and removal of the pathogen
is captured by <code class="reqn">\beta(t)</code>. It is also possible to include a
small background infectious pressure <code class="reqn">\epsilon</code> to allow for
other indirect sources of environmental contamination. The
environmental infectious pressure <code class="reqn">\varphi(t)</code> in each
node is evolved each time unit by the Euler forward method. The
value of <code class="reqn">\varphi(t)</code> is saved at the time-points
specified in <code>tspan</code>.
</p>
<p>The argument <code>u0</code> must be a <code>data.frame</code> with one row for
each node with the following columns:
</p>

<dl>
<dt>S</dt><dd><p>The number of sucsceptible in each node</p>
</dd>
<dt>I</dt><dd><p>The number of infected in each node</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>SISe</code>
</p>


<h3>Beta</h3>

<p>The time dependent beta is divided into four intervals of the year
</p>
<pre>
where 0 &lt;= day &lt; 365

Case 1: END_1 &lt; END_2 &lt; END_3 &lt; END_4
INTERVAL_1 INTERVAL_2     INTERVAL_3     INTERVAL_4     INTERVAL_1
[0, END_1) [END_1, END_2) [END_2, END_3) [END_3, END_4) [END_4, 365)

Case 2: END_3 &lt; END_4 &lt; END_1 &lt; END_2
INTERVAL_3 INTERVAL_4     INTERVAL_1     INTERVAL_2     INTERVAL_3
[0, END_3) [END_3, END_4) [END_4, END_1) [END_1, END_2) [END_2, 365)

Case 3: END_4 &lt; END_1 &lt; END_2 &lt; END_3
INTERVAL_4 INTERVAL_1     INTERVAL_2     INTERVAL_3     INTERVAL_4
[0, END_4) [END_4, END_1) [END_1, END_2) [END_2, END_3) [END_3, 365)
</pre>

<hr>
<h2 id='SISe_sp'>Create a <code>SISe_sp</code> model</h2><span id='topic+SISe_sp'></span>

<h3>Description</h3>

<p>Create a <code>SISe_sp</code> model to be used by the simulation
framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SISe_sp(
  u0,
  tspan,
  events = NULL,
  phi = NULL,
  upsilon = NULL,
  gamma = NULL,
  alpha = NULL,
  beta_t1 = NULL,
  beta_t2 = NULL,
  beta_t3 = NULL,
  beta_t4 = NULL,
  end_t1 = NULL,
  end_t2 = NULL,
  end_t3 = NULL,
  end_t4 = NULL,
  coupling = NULL,
  distance = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SISe_sp_+3A_u0">u0</code></td>
<td>
<p>A <code>data.frame</code> with the initial state in each node
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_tspan">tspan</code></td>
<td>
<p>A vector (length &gt;= 1) of increasing time points
where the state of each node is to be returned. Can be either
an <code>integer</code> or a <code>Date</code> vector. A <code>Date</code>
vector is coerced to a numeric vector as days, where
<code>tspan[1]</code> becomes the day of the year of the first year
of <code>tspan</code>. The dates are added as names to the numeric
vector.</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> with the scheduled events, see
<code><a href="#topic+SimInf_model">SimInf_model</a></code>.</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_phi">phi</code></td>
<td>
<p>A numeric vector with the initial environmental
infectious pressure in each node. Will be repeated to the
length of nrow(u0). Default is NULL which gives 0 in each
node.</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_upsilon">upsilon</code></td>
<td>
<p>Indirect transmission rate of the environmental
infectious pressure</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_gamma">gamma</code></td>
<td>
<p>The recovery rate from infected to susceptible</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_alpha">alpha</code></td>
<td>
<p>Shed rate from infected individuals</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_beta_t1">beta_t1</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 1.</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_beta_t2">beta_t2</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 2.</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_beta_t3">beta_t3</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 3.</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_beta_t4">beta_t4</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 4.</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_end_t1">end_t1</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 1 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_end_t2">end_t2</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 2 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_end_t3">end_t3</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 3 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_end_t4">end_t4</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 4 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_coupling">coupling</code></td>
<td>
<p>The coupling between neighboring nodes</p>
</td></tr>
<tr><td><code id="SISe_sp_+3A_distance">distance</code></td>
<td>
<p>The distance matrix between neighboring nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SISe_sp</code> model contains two compartments; number of
susceptible (S) and number of infectious (I). Additionally, it
contains an environmental compartment to model shedding of a
pathogen to the environment. Moreover, it also includes a spatial
coupling of the environmental contamination among proximal nodes
to capture between-node spread unrelated to moving infected
individuals. Consequently, the model has two state transitions,
</p>
<p style="text-align: center;"><code class="reqn">S \stackrel{\upsilon \varphi S}{\longrightarrow} I</code>
</p>

<p style="text-align: center;"><code class="reqn">I \stackrel{\gamma I}{\longrightarrow} S</code>
</p>

<p>where the transition rate per unit of time from susceptible to
infected is proportional to the concentration of the environmental
contamination <code class="reqn">\varphi</code> in each node. Moreover, the
transition rate from infected to susceptible is the recovery rate
<code class="reqn">\gamma</code>, measured per individual and per unit of
time. Finally, the environmental infectious pressure in each node
is evolved by,
</p>
<p style="text-align: center;"><code class="reqn">\frac{d \varphi_i(t)}{dt} = \frac{\alpha I_{i}(t)}{N_i(t)} +
\sum_k{\frac{\varphi_k(t) N_k(t) - \varphi_i(t) N_i(t)}{N_i(t)}
\cdot \frac{D}{d_{ik}}} - \beta(t) \varphi_i(t)</code>
</p>

<p>where <code class="reqn">\alpha</code> is the average shedding rate of the pathogen to
the environment per infected individual and <code class="reqn">N = S + I</code> the
size of the node. Next comes the spatial coupling among proximal
nodes, where <code class="reqn">D</code> is the rate of the local spread and
<code class="reqn">d_{ik}</code> the distance between holdings <code class="reqn">i</code> and
<code class="reqn">k</code>. The seasonal decay and removal of the pathogen is
captured by <code class="reqn">\beta(t)</code>. The environmental infectious pressure
<code class="reqn">\varphi(t)</code> in each node is evolved each time unit by
the Euler forward method. The value of <code class="reqn">\varphi(t)</code> is
saved at the time-points specified in <code>tspan</code>.
</p>
<p>The argument <code>u0</code> must be a <code>data.frame</code> with one row for
each node with the following columns:
</p>

<dl>
<dt>S</dt><dd><p>The number of sucsceptible</p>
</dd>
<dt>I</dt><dd><p>The number of infected</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>SISe_sp</code>
</p>


<h3>Beta</h3>

<p>The time dependent beta is divided into four intervals of the year
</p>
<pre>
where 0 &lt;= day &lt; 365

Case 1: END_1 &lt; END_2 &lt; END_3 &lt; END_4
INTERVAL_1 INTERVAL_2     INTERVAL_3     INTERVAL_4     INTERVAL_1
[0, END_1) [END_1, END_2) [END_2, END_3) [END_3, END_4) [END_4, 365)

Case 2: END_3 &lt; END_4 &lt; END_1 &lt; END_2
INTERVAL_3 INTERVAL_4     INTERVAL_1     INTERVAL_2     INTERVAL_3
[0, END_3) [END_3, END_4) [END_4, END_1) [END_1, END_2) [END_2, 365)

Case 3: END_4 &lt; END_1 &lt; END_2 &lt; END_3
INTERVAL_4 INTERVAL_1     INTERVAL_2     INTERVAL_3     INTERVAL_4
[0, END_4) [END_4, END_1) [END_1, END_2) [END_2, END_3) [END_3, 365)
</pre>

<hr>
<h2 id='SISe_sp-class'>Definition of the <code>SISe_sp</code> model</h2><span id='topic+SISe_sp-class'></span>

<h3>Description</h3>

<p>Class to handle the <code>SISe_sp</code> <code><a href="#topic+SimInf_model">SimInf_model</a></code>.
</p>

<hr>
<h2 id='SISe-class'>Definition of the <code>SISe</code> model</h2><span id='topic+SISe-class'></span>

<h3>Description</h3>

<p>Class to handle the SISe <code><a href="#topic+SimInf_model">SimInf_model</a></code>.
</p>

<hr>
<h2 id='SISe3'>Create a <code>SISe3</code> model</h2><span id='topic+SISe3'></span>

<h3>Description</h3>

<p>Create a <code>SISe3</code> model to be used by the simulation
framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SISe3(
  u0,
  tspan,
  events = NULL,
  phi = NULL,
  upsilon_1 = NULL,
  upsilon_2 = NULL,
  upsilon_3 = NULL,
  gamma_1 = NULL,
  gamma_2 = NULL,
  gamma_3 = NULL,
  alpha = NULL,
  beta_t1 = NULL,
  beta_t2 = NULL,
  beta_t3 = NULL,
  beta_t4 = NULL,
  end_t1 = NULL,
  end_t2 = NULL,
  end_t3 = NULL,
  end_t4 = NULL,
  epsilon = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SISe3_+3A_u0">u0</code></td>
<td>
<p>A <code>data.frame</code> with the initial state in each node
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="SISe3_+3A_tspan">tspan</code></td>
<td>
<p>A vector (length &gt;= 1) of increasing time points
where the state of each node is to be returned. Can be either
an <code>integer</code> or a <code>Date</code> vector. A <code>Date</code>
vector is coerced to a numeric vector as days, where
<code>tspan[1]</code> becomes the day of the year of the first year
of <code>tspan</code>. The dates are added as names to the numeric
vector.</p>
</td></tr>
<tr><td><code id="SISe3_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> with the scheduled events, see
<code><a href="#topic+SimInf_model">SimInf_model</a></code>.</p>
</td></tr>
<tr><td><code id="SISe3_+3A_phi">phi</code></td>
<td>
<p>A numeric vector with the initial environmental
infectious pressure in each node. Will be repeated to the
length of nrow(u0). Default is NULL which gives 0 in each
node.</p>
</td></tr>
<tr><td><code id="SISe3_+3A_upsilon_1">upsilon_1</code></td>
<td>
<p>Indirect transmission rate of the environmental
infectious pressure in age category 1</p>
</td></tr>
<tr><td><code id="SISe3_+3A_upsilon_2">upsilon_2</code></td>
<td>
<p>Indirect transmission rate of the environmental
infectious pressure in age category 2</p>
</td></tr>
<tr><td><code id="SISe3_+3A_upsilon_3">upsilon_3</code></td>
<td>
<p>Indirect transmission rate of the environmental
infectious pressure in age category 3</p>
</td></tr>
<tr><td><code id="SISe3_+3A_gamma_1">gamma_1</code></td>
<td>
<p>The recovery rate from infected to susceptible for
age category 1</p>
</td></tr>
<tr><td><code id="SISe3_+3A_gamma_2">gamma_2</code></td>
<td>
<p>The recovery rate from infected to susceptible for
age category 2</p>
</td></tr>
<tr><td><code id="SISe3_+3A_gamma_3">gamma_3</code></td>
<td>
<p>The recovery rate from infected to susceptible for
age category 3</p>
</td></tr>
<tr><td><code id="SISe3_+3A_alpha">alpha</code></td>
<td>
<p>Shed rate from infected individuals</p>
</td></tr>
<tr><td><code id="SISe3_+3A_beta_t1">beta_t1</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 1.</p>
</td></tr>
<tr><td><code id="SISe3_+3A_beta_t2">beta_t2</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 2.</p>
</td></tr>
<tr><td><code id="SISe3_+3A_beta_t3">beta_t3</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 3.</p>
</td></tr>
<tr><td><code id="SISe3_+3A_beta_t4">beta_t4</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 4.</p>
</td></tr>
<tr><td><code id="SISe3_+3A_end_t1">end_t1</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 1 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe3_+3A_end_t2">end_t2</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 2 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe3_+3A_end_t3">end_t3</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 3 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe3_+3A_end_t4">end_t4</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 4 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe3_+3A_epsilon">epsilon</code></td>
<td>
<p>The background environmental infectious pressure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SISe3</code> model contains two compartments in three age
categories; number of susceptible (S_1, S_2, S_3) and number of
infectious (I_1, I_2, I_3). Additionally, it contains an
environmental compartment to model shedding of a pathogen to the
environment. Consequently, the model has six state transitions,
</p>
<p style="text-align: center;"><code class="reqn">S_1 \stackrel{\upsilon_1 \varphi S_1}{\longrightarrow} I_1</code>
</p>

<p style="text-align: center;"><code class="reqn">I_1 \stackrel{\gamma_1 I_1}{\longrightarrow} S_1</code>
</p>

<p style="text-align: center;"><code class="reqn">S_2 \stackrel{\upsilon_2 \varphi S_2}{\longrightarrow} I_2</code>
</p>

<p style="text-align: center;"><code class="reqn">I_2 \stackrel{\gamma_2 I_2}{\longrightarrow} S_2</code>
</p>

<p style="text-align: center;"><code class="reqn">S_3 \stackrel{\upsilon_3 \varphi S_3}{\longrightarrow} I_3</code>
</p>

<p style="text-align: center;"><code class="reqn">I_3 \stackrel{\gamma_3 I_3}{\longrightarrow} S_3</code>
</p>

<p>where the transition rate per unit of time from susceptible to
infected is proportional to the concentration of the environmental
contamination <code class="reqn">\varphi</code> in each node. Moreover, the
transition rate from infected to susceptible is the recovery rate
<code class="reqn">\gamma_1, \gamma_2, \gamma_3</code>, measured per individual and
per unit of time. Finally, the environmental infectious pressure
in each node is evolved by,
</p>
<p style="text-align: center;"><code class="reqn">\frac{d\varphi(t)}{dt} = \frac{\alpha \left(I_1(t) + I_2(t)
+ I_3(t)\right)}{N(t)} - \beta(t) \varphi(t) + \epsilon</code>
</p>

<p>where <code class="reqn">\alpha</code> is the average shedding rate of the pathogen to
the environment per infected individual and <code class="reqn">N = S_1 + S_2 +
S_3 + I_1 + I_2 + I_3</code> the size of the node. The seasonal decay
and removal of the pathogen is captured by <code class="reqn">\beta(t)</code>. It is
also possible to include a small background infectious pressure
<code class="reqn">\epsilon</code> to allow for other indirect sources of
environmental contamination. The environmental infectious pressure
<code class="reqn">\varphi(t)</code> in each node is evolved each time unit by
the Euler forward method. The value of <code class="reqn">\varphi(t)</code> is
saved at the time-points specified in <code>tspan</code>.
</p>
<p>The argument <code>u0</code> must be a <code>data.frame</code> with one row for
each node with the following columns:
</p>

<dl>
<dt>S_1</dt><dd><p>The number of sucsceptible in age category 1</p>
</dd>
<dt>I_1</dt><dd><p>The number of infected in age category 1</p>
</dd>
<dt>S_2</dt><dd><p>The number of sucsceptible in age category 2</p>
</dd>
<dt>I_2</dt><dd><p>The number of infected in age category 2</p>
</dd>
<dt>S_3</dt><dd><p>The number of sucsceptible in age category 3</p>
</dd>
<dt>I_3</dt><dd><p>The number of infected in age category 3</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>SISe3</code>
</p>


<h3>Beta</h3>

<p>The time dependent beta is divided into four intervals of the year
</p>
<pre>
where 0 &lt;= day &lt; 365

Case 1: END_1 &lt; END_2 &lt; END_3 &lt; END_4
INTERVAL_1 INTERVAL_2     INTERVAL_3     INTERVAL_4     INTERVAL_1
[0, END_1) [END_1, END_2) [END_2, END_3) [END_3, END_4) [END_4, 365)

Case 2: END_3 &lt; END_4 &lt; END_1 &lt; END_2
INTERVAL_3 INTERVAL_4     INTERVAL_1     INTERVAL_2     INTERVAL_3
[0, END_3) [END_3, END_4) [END_4, END_1) [END_1, END_2) [END_2, 365)

Case 3: END_4 &lt; END_1 &lt; END_2 &lt; END_3
INTERVAL_4 INTERVAL_1     INTERVAL_2     INTERVAL_3     INTERVAL_4
[0, END_4) [END_4, END_1) [END_1, END_2) [END_2, END_3) [END_3, 365)
</pre>

<hr>
<h2 id='SISe3_sp'>Create an <code>SISe3_sp</code> model</h2><span id='topic+SISe3_sp'></span>

<h3>Description</h3>

<p>Create an <code>SISe3_sp</code> model to be used by the simulation
framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SISe3_sp(
  u0,
  tspan,
  events = NULL,
  phi = NULL,
  upsilon_1 = NULL,
  upsilon_2 = NULL,
  upsilon_3 = NULL,
  gamma_1 = NULL,
  gamma_2 = NULL,
  gamma_3 = NULL,
  alpha = NULL,
  beta_t1 = NULL,
  beta_t2 = NULL,
  beta_t3 = NULL,
  beta_t4 = NULL,
  end_t1 = NULL,
  end_t2 = NULL,
  end_t3 = NULL,
  end_t4 = NULL,
  distance = NULL,
  coupling = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SISe3_sp_+3A_u0">u0</code></td>
<td>
<p>A <code>data.frame</code> with the initial state in each node
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_tspan">tspan</code></td>
<td>
<p>A vector (length &gt;= 1) of increasing time points
where the state of each node is to be returned. Can be either
an <code>integer</code> or a <code>Date</code> vector. A <code>Date</code>
vector is coerced to a numeric vector as days, where
<code>tspan[1]</code> becomes the day of the year of the first year
of <code>tspan</code>. The dates are added as names to the numeric
vector.</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> with the scheduled events, see
<code><a href="#topic+SimInf_model">SimInf_model</a></code>.</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_phi">phi</code></td>
<td>
<p>A numeric vector with the initial environmental
infectious pressure in each node. Will be repeated to the
length of nrow(u0). Default is NULL which gives 0 in each
node.</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_upsilon_1">upsilon_1</code></td>
<td>
<p>Indirect transmission rate of the environmental
infectious pressure in age category 1</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_upsilon_2">upsilon_2</code></td>
<td>
<p>Indirect transmission rate of the environmental
infectious pressure in age category 2</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_upsilon_3">upsilon_3</code></td>
<td>
<p>Indirect transmission rate of the environmental
infectious pressure in age category 3</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_gamma_1">gamma_1</code></td>
<td>
<p>The recovery rate from infected to susceptible for
age category 1</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_gamma_2">gamma_2</code></td>
<td>
<p>The recovery rate from infected to susceptible for
age category 2</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_gamma_3">gamma_3</code></td>
<td>
<p>The recovery rate from infected to susceptible for
age category 3</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_alpha">alpha</code></td>
<td>
<p>Shed rate from infected individuals</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_beta_t1">beta_t1</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 1.</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_beta_t2">beta_t2</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 2.</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_beta_t3">beta_t3</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 3.</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_beta_t4">beta_t4</code></td>
<td>
<p>The decay of the environmental infectious pressure
in interval 4.</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_end_t1">end_t1</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 1 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_end_t2">end_t2</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 2 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_end_t3">end_t3</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 3 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_end_t4">end_t4</code></td>
<td>
<p>vector with the non-inclusive day of the year that
ends interval 4 in each node. Will be repeated to the length
of nrow(u0).</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_distance">distance</code></td>
<td>
<p>The distance matrix between neighboring nodes</p>
</td></tr>
<tr><td><code id="SISe3_sp_+3A_coupling">coupling</code></td>
<td>
<p>The coupling between neighboring nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SISe3_sp</code> model contains two compartments in three age
categories; number of susceptible (S_1, S_2, S_3) and number of
infectious (I_1, I_2, I_3). Additionally, it contains an
environmental compartment to model shedding of a pathogen to the
environment. Moreover, it also includes a spatial coupling of the
environmental contamination among proximal nodes to capture
between-node spread unrelated to moving infected
individuals. Consequently, the model has six state transitions,
</p>
<p style="text-align: center;"><code class="reqn">S_1 \stackrel{\upsilon_1 \varphi S_1}{\longrightarrow} I_1</code>
</p>

<p style="text-align: center;"><code class="reqn">I_1 \stackrel{\gamma_1 I_1}{\longrightarrow} S_1</code>
</p>

<p style="text-align: center;"><code class="reqn">S_2 \stackrel{\upsilon_2 \varphi S_2}{\longrightarrow} I_2</code>
</p>

<p style="text-align: center;"><code class="reqn">I_2 \stackrel{\gamma_2 I_2}{\longrightarrow} S_2</code>
</p>

<p style="text-align: center;"><code class="reqn">S_3 \stackrel{\upsilon_3 \varphi S_3}{\longrightarrow} I_3</code>
</p>

<p style="text-align: center;"><code class="reqn">I_3 \stackrel{\gamma_3 I_3}{\longrightarrow} S_3</code>
</p>

<p>where the transition rate per unit of time from susceptible to
infected is proportional to the concentration of the environmental
contamination <code class="reqn">\varphi</code> in each node. Moreover, the
transition rate from infected to susceptible is the recovery rate
<code class="reqn">\gamma_1, \gamma_2, \gamma_3</code>, measured per individual and
per unit of time. Finally, the environmental infectious pressure
in each node is evolved by,
</p>
<p style="text-align: center;"><code class="reqn">\frac{d \varphi_i(t)}{dt} = \frac{\alpha \left(I_{i,1}(t) +
I_{i,2}(t) + I_{i,3}(t)\right)}{N_i(t)} +
\sum_k{\frac{\varphi_k(t) N_k(t) - \varphi_i(t) N_i(t)}{N_i(t)}
\cdot \frac{D}{d_{ik}}} - \beta(t) \varphi_i(t)</code>
</p>

<p>where <code class="reqn">\alpha</code> is the average shedding rate of the pathogen to
the environment per infected individual and <code class="reqn">N = S_1 + S_2 +
S_3 + I_1 + I_2 + I_3</code> the size of the node. Next comes the
spatial coupling among proximal nodes, where <code class="reqn">D</code> is the rate
of the local spread and <code class="reqn">d_{ik}</code> the distance between holdings
<code class="reqn">i</code> and <code class="reqn">k</code>. The seasonal decay and removal of the
pathogen is captured by <code class="reqn">\beta(t)</code>. The environmental
infectious pressure <code class="reqn">\varphi(t)</code> in each node is
evolved each time unit by the Euler forward method. The value of
<code class="reqn">\varphi(t)</code> is saved at the time-points specified in
<code>tspan</code>.
</p>
<p>The argument <code>u0</code> must be a <code>data.frame</code> with one row for
each node with the following columns:
</p>

<dl>
<dt>S_1</dt><dd><p>The number of sucsceptible in age category 1</p>
</dd>
<dt>I_1</dt><dd><p>The number of infected in age category 1</p>
</dd>
<dt>S_2</dt><dd><p>The number of sucsceptible in age category 2</p>
</dd>
<dt>I_2</dt><dd><p>The number of infected in age category 2</p>
</dd>
<dt>S_3</dt><dd><p>The number of sucsceptible in age category 3</p>
</dd>
<dt>I_3</dt><dd><p>The number of infected in age category 3</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>SISe3_sp</code>
</p>


<h3>Beta</h3>

<p>The time dependent beta is divided into four intervals of the year
</p>
<pre>
where 0 &lt;= day &lt; 365

Case 1: END_1 &lt; END_2 &lt; END_3 &lt; END_4
INTERVAL_1 INTERVAL_2     INTERVAL_3     INTERVAL_4     INTERVAL_1
[0, END_1) [END_1, END_2) [END_2, END_3) [END_3, END_4) [END_4, 365)

Case 2: END_3 &lt; END_4 &lt; END_1 &lt; END_2
INTERVAL_3 INTERVAL_4     INTERVAL_1     INTERVAL_2     INTERVAL_3
[0, END_3) [END_3, END_4) [END_4, END_1) [END_1, END_2) [END_2, 365)

Case 3: END_4 &lt; END_1 &lt; END_2 &lt; END_3
INTERVAL_4 INTERVAL_1     INTERVAL_2     INTERVAL_3     INTERVAL_4
[0, END_4) [END_4, END_1) [END_1, END_2) [END_2, END_3) [END_3, 365)
</pre>

<hr>
<h2 id='SISe3_sp-class'>Definition of the &lsquo;SISe3_sp&rsquo; model</h2><span id='topic+SISe3_sp-class'></span>

<h3>Description</h3>

<p>Class to handle the SISe3_sp <code><a href="#topic+SimInf_model">SimInf_model</a></code> model.
</p>

<hr>
<h2 id='SISe3-class'>Definition of the &lsquo;SISe3&rsquo; model</h2><span id='topic+SISe3-class'></span>

<h3>Description</h3>

<p>Class to handle the SISe3 <code><a href="#topic+SimInf_model">SimInf_model</a></code> model.
</p>

<hr>
<h2 id='summary+2CSimInf_abc-method'>Detailed summary of a <code>SimInf_abc</code> object</h2><span id='topic+summary+2CSimInf_abc-method'></span>

<h3>Description</h3>

<p>Detailed summary of a <code>SimInf_abc</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_abc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CSimInf_abc-method_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_abc</code> object</p>
</td></tr>
<tr><td><code id="summary+2B2CSimInf_abc-method_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (invisible 'NULL').
</p>

<hr>
<h2 id='summary+2CSimInf_events-method'>Detailed summary of a <code>SimInf_events</code> object</h2><span id='topic+summary+2CSimInf_events-method'></span>

<h3>Description</h3>

<p>Shows the number of scheduled events and the number of scheduled
events per event type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_events'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CSimInf_events-method_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_events</code> object</p>
</td></tr>
<tr><td><code id="summary+2B2CSimInf_events-method_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (invisible 'NULL').
</p>

<hr>
<h2 id='summary+2CSimInf_indiv_events-method'>Detailed summary of a <code>SimInf_indiv_events</code> object</h2><span id='topic+summary+2CSimInf_indiv_events-method'></span>

<h3>Description</h3>

<p>Detailed summary of a <code>SimInf_indiv_events</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_indiv_events'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CSimInf_indiv_events-method_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_indiv_events</code> object</p>
</td></tr>
<tr><td><code id="summary+2B2CSimInf_indiv_events-method_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (invisible 'NULL').
</p>

<hr>
<h2 id='summary+2CSimInf_model-method'>Detailed summary of a <code>SimInf_model</code> object</h2><span id='topic+summary+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Detailed summary of a <code>SimInf_model</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_model'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CSimInf_model-method_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_model</code> object</p>
</td></tr>
<tr><td><code id="summary+2B2CSimInf_model-method_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (invisible 'NULL').
</p>

<hr>
<h2 id='summary+2CSimInf_pfilter-method'>Detailed summary of a <code>SimInf_pfilter</code> object</h2><span id='topic+summary+2CSimInf_pfilter-method'></span>

<h3>Description</h3>

<p>Detailed summary of a <code>SimInf_pfilter</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_pfilter'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CSimInf_pfilter-method_+3A_object">object</code></td>
<td>
<p>The <code>SimInf_pfilter</code> object.</p>
</td></tr>
<tr><td><code id="summary+2B2CSimInf_pfilter-method_+3A_...">...</code></td>
<td>
<p>Unused additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(NULL)</code>.
</p>

<hr>
<h2 id='trajectory'>Generic function to extract data from a simulated trajectory</h2><span id='topic+trajectory'></span>

<h3>Description</h3>

<p>Generic function to extract data from a simulated trajectory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trajectory(model, compartments = NULL, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trajectory_+3A_model">model</code></td>
<td>
<p>the object to extract the trajectory from.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_compartments">compartments</code></td>
<td>
<p>specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. <code>compartments = c('S', 'I', 'R')</code>,
or as a formula e.g. <code>compartments = ~S+I+R</code> (see
&lsquo;Examples&rsquo;). Default (<code>compartments=NULL</code>) is to
extract the number of individuals in each compartment i.e. the
data from all discrete state compartments in the model. In
models that also have continuous state variables e.g. the
<code>SISe</code> model, they are also included.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_index">index</code></td>
<td>
<p>indices specifying the subset of nodes to include
when extracting data. Default (<code>index = NULL</code>) is to
extract data from all nodes.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_...">...</code></td>
<td>
<p>Additional arguments, see
<code><a href="#topic+trajectory+2CSimInf_model-method">trajectory,SimInf_model-method</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='trajectory+2CSimInf_model-method'>Extract data from a simulated trajectory</h2><span id='topic+trajectory+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Extract the number of individuals in each compartment in every
node after generating a single stochastic trajectory with
<code><a href="#topic+run">run</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_model'
trajectory(model, compartments, index, format = c("data.frame", "matrix"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trajectory+2B2CSimInf_model-method_+3A_model">model</code></td>
<td>
<p>the <code>SimInf_model</code> object to extract the result
from.</p>
</td></tr>
<tr><td><code id="trajectory+2B2CSimInf_model-method_+3A_compartments">compartments</code></td>
<td>
<p>specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. <code>compartments = c('S', 'I', 'R')</code>,
or as a formula e.g. <code>compartments = ~S+I+R</code> (see
&lsquo;Examples&rsquo;). Default (<code>compartments=NULL</code>) is to
extract the number of individuals in each compartment i.e. the
data from all discrete state compartments in the model. In
models that also have continuous state variables e.g. the
<code>SISe</code> model, they are also included.</p>
</td></tr>
<tr><td><code id="trajectory+2B2CSimInf_model-method_+3A_index">index</code></td>
<td>
<p>indices specifying the subset of nodes to include
when extracting data. Default (<code>index = NULL</code>) is to
extract data from all nodes.</p>
</td></tr>
<tr><td><code id="trajectory+2B2CSimInf_model-method_+3A_format">format</code></td>
<td>
<p>the default (<code>format = "data.frame"</code>) is to
generate a <code>data.frame</code> with one row per node and
time-step with the number of individuals in each
compartment. Using <code>format = "matrix"</code> returns the result
as a matrix, which is the internal format (see
&lsquo;Details&rsquo;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> if <code>format = "data.frame"</code>, else
a matrix.
</p>


<h3>Internal format of the discrete state variables</h3>

<p>Description of the layout of the internal matrix (<code>U</code>)
that is returned if <code>format = "matrix"</code>. <code>U[, j]</code>
contains the number of individuals in each compartment at
<code>tspan[j]</code>. <code>U[1:Nc, j]</code> contains the number of
individuals in node 1 at <code>tspan[j]</code>. <code>U[(Nc + 1):(2
    * Nc), j]</code> contains the number of individuals in node 2 at
<code>tspan[j]</code> etc, where <code>Nc</code> is the number of
compartments in the model. The dimension of the matrix is
<code class="reqn">N_n N_c \times</code> <code>length(tspan)</code> where <code class="reqn">N_n</code> is
the number of nodes.
</p>


<h3>Internal format of the continuous state variables</h3>

<p>Description of the layout of the matrix that is returned if
<code>format = "matrix"</code>. The result matrix for the
real-valued continuous state. <code>V[, j]</code> contains the
real-valued state of the system at <code>tspan[j]</code>. The
dimension of the matrix is <code class="reqn">N_n</code><code>dim(ldata)[1]</code>
<code class="reqn">\times</code> <code>length(tspan)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an 'SIR' model with 6 nodes and initialize
## it to run over 10 days.
u0 &lt;- data.frame(S = 100:105, I = 1:6, R = rep(0, 6))
model &lt;- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)

## Extract the number of individuals in each compartment at the
## time-points in 'tspan'.
trajectory(result)

## Extract the number of recovered individuals in the first node
## at the time-points in 'tspan'.
trajectory(result, compartments = "R", index = 1)

## Extract the number of recovered individuals in the first and
## third node at the time-points in 'tspan'.
trajectory(result, compartments = "R", index = c(1, 3))

## Create an 'SISe' model with 6 nodes and initialize
## it to run over 10 days.
u0 &lt;- data.frame(S = 100:105, I = 1:6)
model &lt;- SISe(u0 = u0, tspan = 1:10, phi = rep(0, 6),
    upsilon = 0.02, gamma = 0.1, alpha = 1, epsilon = 1.1e-5,
    beta_t1 = 0.15, beta_t2 = 0.15, beta_t3 = 0.15, beta_t4 = 0.15,
    end_t1 = 91, end_t2 = 182, end_t3 = 273, end_t4 = 365)

## Run the model
result &lt;- run(model)

## Extract the continuous state variable 'phi' which represents
## the environmental infectious pressure.
trajectory(result, "phi")
</code></pre>

<hr>
<h2 id='trajectory+2CSimInf_pfilter-method'>Extract filtered trajectory from running a particle filter</h2><span id='topic+trajectory+2CSimInf_pfilter-method'></span>

<h3>Description</h3>

<p>Extract filtered trajectory from running a particle filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimInf_pfilter'
trajectory(model, compartments, index, format = c("data.frame", "matrix"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trajectory+2B2CSimInf_pfilter-method_+3A_model">model</code></td>
<td>
<p>the <code>SimInf_pfilter</code> object to extract the
result from.</p>
</td></tr>
<tr><td><code id="trajectory+2B2CSimInf_pfilter-method_+3A_compartments">compartments</code></td>
<td>
<p>specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. <code>compartments = c('S', 'I', 'R')</code>,
or as a formula e.g. <code>compartments = ~S+I+R</code> (see
&lsquo;Examples&rsquo;). Default (<code>compartments=NULL</code>) is to
extract the number of individuals in each compartment i.e. the
data from all discrete state compartments in the model. In
models that also have continuous state variables e.g. the
<code>SISe</code> model, they are also included.</p>
</td></tr>
<tr><td><code id="trajectory+2B2CSimInf_pfilter-method_+3A_index">index</code></td>
<td>
<p>indices specifying the subset of nodes to include
when extracting data. Default (<code>index = NULL</code>) is to
extract data from all nodes.</p>
</td></tr>
<tr><td><code id="trajectory+2B2CSimInf_pfilter-method_+3A_format">format</code></td>
<td>
<p>the default (<code>format = "data.frame"</code>) is to
generate a <code>data.frame</code> with one row per node and
time-step with the number of individuals in each
compartment. Using <code>format = "matrix"</code> returns the result
as a matrix, which is the internal format (see
&lsquo;Details&rsquo; in
<code><a href="#topic+trajectory+2CSimInf_model-method">trajectory,SimInf_model-method</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> if <code>format = "data.frame"</code>, else
a matrix.
</p>

<hr>
<h2 id='u0'>Get the initial compartment state</h2><span id='topic+u0'></span><span id='topic+u0+2CSimInf_model-method'></span><span id='topic+u0+2CSimInf_indiv_events-method'></span>

<h3>Description</h3>

<p>Get the initial compartment state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u0(object, ...)

## S4 method for signature 'SimInf_model'
u0(object, ...)

## S4 method for signature 'SimInf_indiv_events'
u0(object, time = NULL, target = NULL, age = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u0_+3A_object">object</code></td>
<td>
<p>The object to get the initial compartment state
<code>u0</code> from.</p>
</td></tr>
<tr><td><code id="u0_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="u0_+3A_time">time</code></td>
<td>
<p>the time-point that will be used to create u0. If left
empty (the default), the earliest time among the events will
be used.</p>
</td></tr>
<tr><td><code id="u0_+3A_target">target</code></td>
<td>
<p>the SimInf model ('SEIR', 'SIR', 'SIS', 'SISe3',
'SISe3_sp', 'SISe', or 'SISe_sp') to target the events and u0
for. The default, <code>NULL</code>, creates an <code>u0</code>, but where
the compartments might have to be renamed and post-processed
to fit the specific use case.</p>
</td></tr>
<tr><td><code id="u0_+3A_age">age</code></td>
<td>
<p>FIXME.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with the initial compartment state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model object.
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Get the initial compartment state.
u0(model)
</code></pre>

<hr>
<h2 id='u0_SEIR'>Example data to initialize the &lsquo;SEIR&rsquo; model</h2><span id='topic+u0_SEIR'></span>

<h3>Description</h3>

<p>Example data to initialize a population of 1600 nodes and
demonstrate the <code><a href="#topic+SEIR-class">SEIR</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u0_SEIR()
</code></pre>


<h3>Details</h3>

<p>A <code>data.frame</code> with the number of individuals in the
&lsquo;S&rsquo;, &lsquo;E&rsquo;, &lsquo;I&rsquo; and &lsquo;R&rsquo; compartments in
1600 nodes. Note that the &lsquo;E&rsquo;, &lsquo;I&rsquo; and &lsquo;R&rsquo;
compartments are zero.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SEIR' model with 1600 nodes and initialize it to
## run over 4*365 days and record data at weekly time-points.
## Add ten infected individuals to the first node.
u0 &lt;- u0_SEIR()
u0$I[1] &lt;- 10
tspan &lt;- seq(from = 1, to = 4*365, by = 7)
model &lt;- SEIR(u0      = u0,
              tspan   = tspan,
              events  = events_SEIR(),
              beta    = 0.16,
              epsilon = 0.25,
              gamma   = 0.01)

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)
plot(result)

## Summarize trajectory
summary(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='u0_SIR'>Example data to initialize the &lsquo;SIR&rsquo; model</h2><span id='topic+u0_SIR'></span>

<h3>Description</h3>

<p>Example data to initialize a population of 1600 nodes and
demonstrate the <code><a href="#topic+SIR-class">SIR</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u0_SIR()
</code></pre>


<h3>Details</h3>

<p>A <code>data.frame</code> with the number of individuals in the
&lsquo;S&rsquo;, &lsquo;I&rsquo; and &lsquo;R&rsquo; compartments in 1600
nodes. Note that the &lsquo;I&rsquo; and &lsquo;R&rsquo; compartments are
zero.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 &lt;- u0_SIR()
u0$I[1] &lt;- 1
tspan &lt;- seq(from = 1, to = 4*365, by = 1)
model &lt;- SIR(u0     = u0,
             tspan  = tspan,
             events = events_SIR(),
             beta   = 0.16,
             gamma  = 0.01)

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)
plot(result)

## Summarize trajectory
summary(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='u0_SIS'>Example data to initialize the &lsquo;SIS&rsquo; model</h2><span id='topic+u0_SIS'></span>

<h3>Description</h3>

<p>Example data to initialize a population of 1600 nodes and
demonstrate the <code><a href="#topic+SIS-class">SIS</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u0_SIS()
</code></pre>


<h3>Details</h3>

<p>A <code>data.frame</code> with the number of individuals in the
&lsquo;S&rsquo;, and &lsquo;I&rsquo; compartments in 1600 nodes. Note that
the &lsquo;I&rsquo; compartment is zero.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIS' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 &lt;- u0_SIS()
u0$I[1] &lt;- 1
tspan &lt;- seq(from = 1, to = 4*365, by = 1)
model &lt;- SIS(u0     = u0,
             tspan  = tspan,
             events = events_SIS(),
             beta   = 0.16,
             gamma  = 0.01)

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)
plot(result)

## Summarize trajectory
summary(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='u0_SISe'>Example data to initialize the &lsquo;SISe&rsquo; model</h2><span id='topic+u0_SISe'></span>

<h3>Description</h3>

<p>Example data to initialize a population of 1600 nodes and
demonstrate the <code><a href="#topic+SISe-class">SISe</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u0_SISe()
</code></pre>


<h3>Details</h3>

<p>A <code>data.frame</code> with the number of individuals in the
&lsquo;S&rsquo; and &lsquo;I&rsquo; compartments in 1600 nodes. Note that
the &lsquo;I&rsquo; compartment is zero.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SISe' model with 1600 nodes and initialize it to
## run over 4*365 days and record data at weekly time-points.

## Load the initial population and add ten infected individuals to
## the first node.
u0 &lt;- u0_SISe()
u0$I[1] &lt;- 10

## Define 'tspan' to run the simulation over 4*365 and record the
## state of the system at weekly time-points.
tspan &lt;- seq(from = 1, to = 4*365, by = 7)

## Load scheduled events for the population of nodes with births,
## deaths and between-node movements of individuals.
events &lt;- events_SISe()

## Create an 'SISe' model
model &lt;- SISe(u0 = u0, tspan = tspan, events = events_SISe(),
              phi = 0, upsilon = 1.8e-2, gamma = 0.1, alpha = 1,
              beta_t1 = 1.0e-1, beta_t2 = 1.0e-1, beta_t3 = 1.25e-1,
              beta_t4 = 1.25e-1, end_t1 = 91, end_t2 = 182,
              end_t3 = 273, end_t4 = 365, epsilon = 0)

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)

## Summarize trajectory
summary(result)

## Plot the proportion of nodes with at least one infected
## individual.
plot(result, I~S+I, level = 2, type = "l")

## End(Not run)
</code></pre>

<hr>
<h2 id='u0_SISe3'>Example data to initialize the &lsquo;SISe3&rsquo; model</h2><span id='topic+u0_SISe3'></span>

<h3>Description</h3>

<p>Example data to initialize a population of 1600 nodes and
demonstrate the <code><a href="#topic+SISe3-class">SISe3</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(u0_SISe3)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code>
</p>


<h3>Details</h3>

<p>A <code>data.frame</code> with the number of individuals in the
&lsquo;S_1&rsquo;, &lsquo;S_2&rsquo;, &lsquo;S_3&rsquo;, &lsquo;I_1&rsquo;,
&lsquo;I_2&rsquo; and &lsquo;I_3&rsquo; compartments in 1600 nodes. Note
that the &lsquo;I_1&rsquo;, &lsquo;I_2&rsquo; and &lsquo;I_3&rsquo; compartments
are zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SISe3' model with 1600 nodes and initialize it to
## run over 4*365 days and record data at weekly time-points.

## Load the initial population and add ten infected individuals to
## I_1 in the first node.
u0 &lt;- u0_SISe3
u0$I_1[1] &lt;- 10

## Define 'tspan' to run the simulation over 4*365 and record the
## state of the system at weekly time-points.
tspan &lt;- seq(from = 1, to = 4*365, by = 7)

## Load scheduled events for the population of nodes with births,
## deaths and between-node movements of individuals.
events &lt;- events_SISe3

## Create a 'SISe3' model
model &lt;- SISe3(u0 = u0, tspan = tspan, events = events,
               phi = rep(0, nrow(u0)), upsilon_1 = 1.8e-2,
               upsilon_2 = 1.8e-2, upsilon_3 = 1.8e-2,
               gamma_1 = 0.1, gamma_2 = 0.1, gamma_3 = 0.1,
               alpha = 1, beta_t1 = 1.0e-1, beta_t2 = 1.0e-1,
               beta_t3 = 1.25e-1, beta_t4 = 1.25e-1, end_t1 = 91,
               end_t2 = 182, end_t3 = 273, end_t4 = 365, epsilon = 0)

## Run the model to generate a single stochastic trajectory.
result &lt;- run(model)

## Summarize trajectory
summary(result)

## Plot the proportion of nodes with at least one infected
## individual.
plot(result, I_1 + I_2 + I_3 ~ ., level = 2, type = "l")

## End(Not run)
</code></pre>

<hr>
<h2 id='u0+26lt+3B-'>Update the initial compartment state u0 in each node</h2><span id='topic+u0+3C-'></span><span id='topic+u0+3C-+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Update the initial compartment state u0 in each node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u0(model) &lt;- value

## S4 replacement method for signature 'SimInf_model'
u0(model) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u0+2B26lt+2B3B-_+3A_model">model</code></td>
<td>
<p>The model to update the initial compartment state
<code>u0</code>.</p>
</td></tr>
<tr><td><code id="u0+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A <code>data.frame</code> with the initial state in each
node. Each row is one node, and the number of rows in
<code>u0</code> must match the number of nodes in <code>model</code>. Only
the columns in <code>u0</code> with a name that matches a
compartment in the <code>model</code> will be used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an SIR model object.
model &lt;- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model and plot the result.
set.seed(22)
result &lt;- run(model)
plot(result)

## Update u0 and run the model again
u0(model) &lt;- data.frame(S = 990, I = 10, R = 0)
result &lt;- run(model)
plot(result)
</code></pre>

<hr>
<h2 id='v0+26lt+3B-'>Update the initial continuous state v0 in each node</h2><span id='topic+v0+3C-'></span><span id='topic+v0+3C-+2CSimInf_model-method'></span>

<h3>Description</h3>

<p>Update the initial continuous state v0 in each node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v0(model) &lt;- value

## S4 replacement method for signature 'SimInf_model'
v0(model) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v0+2B26lt+2B3B-_+3A_model">model</code></td>
<td>
<p>The model to update the initial continuous state
<code>v0</code>.</p>
</td></tr>
<tr><td><code id="v0+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A <code>data.frame</code> with the initial continuosu state in
each node. Each row is one node, and the number of rows in
<code>v0</code> must match the number of nodes in <code>model</code>. Only
the columns in <code>v0</code> with a name that matches a continuous
state in <code>v0</code> in the <code>model</code> will be used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an 'SISe' model with no infected individuals and no
## infectious pressure (phi = 0, epsilon = 0).
model &lt;- SISe(u0 = data.frame(S = 100, I = 0), tspan = 1:100,
              phi = 0, upsilon = 0.02, gamma = 0.1, alpha = 1,
              epsilon = 0, beta_t1 = 0.15, beta_t2 = 0.15,
              beta_t3 = 0.15, beta_t4 = 0.15, end_t1 = 91,
              end_t2 = 182, end_t3 = 273, end_t4 = 365)

## Run the 'SISe' model and plot the result.
set.seed(22)
result &lt;- run(model)
plot(result)

## Update the infectious pressure 'phi' in 'v0' and run
## the model again.
v0(model) &lt;- data.frame(phi = 1)
result &lt;- run(model)
plot(result)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
