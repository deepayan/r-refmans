<!DOCTYPE html><html><head><title>Help for package pscore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pscore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.preparePredict'><p>Internal function to prepare data for prediction</p></a></li>
<li><a href='#BioDB'><p>Biomarker Thresholds Database</p></a></li>
<li><a href='#CompositeData'><p>An constructor function for the S4 CompositeData class</p></a></li>
<li><a href='#CompositeData-class'><p>A S4 class to represent data for creating a composite</p></a></li>
<li><a href='#CompositeReady'><p>An constructor function for the S4 CompositeReady class</p></a></li>
<li><a href='#CompositeReady-class'><p>An S4 class to represent composite ready data</p></a></li>
<li><a href='#dropData'><p>Drop unnecessary data from a MahalanobisComposite object.</p></a></li>
<li><a href='#factorComposite'><p>Score Data Using a Factor Model</p></a></li>
<li><a href='#ldensity'><p>Density Plot for a Long Dataset</p></a></li>
<li><a href='#mahalanobisComposite'><p>Score Data Using the Mahalanobis Distance</p></a></li>
<li><a href='#MahalanobisScores-class'><p>An S4 class to represent composite scores based on Mahalanobis distance</p></a></li>
<li><a href='#MetSSS'><p>Score the MetSSS</p></a></li>
<li><a href='#MetSSS_model'><p>MetSSS Model</p></a></li>
<li><a href='#predictCS'><p>Internal function to prepare data for prediction</p></a></li>
<li><a href='#prepareComposite'><p>Prepare distance scores on data in preparation for composite scoring</p></a></li>
<li><a href='#sumComposite'><p>Score Data Using a simple sum</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Standardizing Physiological Composite Risk Endpoints</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://score-project.org">https://score-project.org</a>, <a href="https://github.com/JWiley/score-project">https://github.com/JWiley/score-project</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JWiley/score-project/issues">https://github.com/JWiley/score-project/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a number of functions to
  simplify and automate the scoring, comparison, and evaluation of
  different ways of creating composites of data.  It is particularly
  aimed at facilitating the creation of physiological composites of
  metabolic syndrome symptom score (MetSSS) and allostatic load (AL).
  Provides a wrapper to calculate the MetSSS on new data using the
  Healthy Hearts formula. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2, reshape2, lavaan, JWileymisc (&ge; 1.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Collate:</td>
<td>'MetSSS.R' 'MetSSS_model.R' 'methods.R' 'misc.R' 'classes.R'
'composite.R' 'onLoad.R' 'predictions.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-13 21:39:47 UTC; jwile</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua F. Wiley <a href="https://orcid.org/0000-0002-0271-6702"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua F. Wiley &lt;jwiley.psych@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-13 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.preparePredict'>Internal function to prepare data for prediction</h2><span id='topic+.preparePredict'></span>

<h3>Description</h3>

<p>Internal function to prepare data for prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.preparePredict(object, newdata, groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".preparePredict_+3A_object">object</code></td>
<td>
<p>An object of S4 class &ldquo;MahalanobisScores&rdquo;,
&ldquo;SumScores&rdquo;, or &ldquo;FactorScores&rdquo; containing
a model and results to be used to get predictions on new data.</p>
</td></tr>
<tr><td><code id=".preparePredict_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with identical variable names as was used
to build the initial model.</p>
</td></tr>
<tr><td><code id=".preparePredict_+3A_groups">groups</code></td>
<td>
<p>A vector with the same length as the data frame in <code>newdata</code>,
has rows, containing the groups each row belongs to.  See <code>CompositeData</code>
for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class &ldquo;CompositeReady&rdquo;
</p>

<hr>
<h2 id='BioDB'>Biomarker Thresholds Database</h2><span id='topic+BioDB'></span>

<h3>Description</h3>

<p>This data set lists the clinical high risk thresholds for a variety of biomarkers
</p>


<h3>Format</h3>

<p>a <code>list</code>.
</p>


<h3>Source</h3>

<p>Various publications
</p>

<hr>
<h2 id='CompositeData'>An constructor function for the S4 CompositeData class</h2><span id='topic+CompositeData'></span>

<h3>Description</h3>

<p>An constructor function for the S4 CompositeData class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompositeData(rawdata, groups, thresholds, higherisbetter, k, rawtrans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompositeData_+3A_rawdata">rawdata</code></td>
<td>
<p>A data frame with at least one row and column</p>
</td></tr>
<tr><td><code id="CompositeData_+3A_groups">groups</code></td>
<td>
<p>an optional character vector. If omitted defaults to
a character vector of all &ldquo;one&rdquo;s.</p>
</td></tr>
<tr><td><code id="CompositeData_+3A_thresholds">thresholds</code></td>
<td>
<p>an optional named list where names match the names in groups.
If using defaults for groups, should name it &ldquo;one&rdquo;.</p>
</td></tr>
<tr><td><code id="CompositeData_+3A_higherisbetter">higherisbetter</code></td>
<td>
<p>an optional logical vector</p>
</td></tr>
<tr><td><code id="CompositeData_+3A_k">k</code></td>
<td>
<p>an optional integer, the number of columns in the raw data</p>
</td></tr>
<tr><td><code id="CompositeData_+3A_rawtrans">rawtrans</code></td>
<td>
<p>A list of functions to transform the raw data (and thresholds).
This list should be in the same order as the variables.  For variables
that should not be transformed, use: <code>function(x) x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class &ldquo;CompositeData&rdquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## no custom raw data transformations
d &lt;- CompositeData(mtcars[, c("mpg", "hp", "wt", "qsec")],
  thresholds = list(one = with(mtcars, c(
    mpg = max(mpg),
    hp = max(hp),
    wt = min(wt),
    qsec = min(qsec)))
  ),
  higherisbetter = c(TRUE, TRUE, FALSE, FALSE))

## square root transform qsec
d &lt;- CompositeData(mtcars[, c("mpg", "hp", "wt", "qsec")],
  thresholds = list(one = with(mtcars, c(
    mpg = max(mpg),
    hp = max(hp),
    wt = min(wt),
    qsec = min(qsec)))
  ),
  higherisbetter = c(TRUE, TRUE, FALSE, FALSE),
  rawtrans = list(
    mpg = function(x) x,
    hp = function(x) x,
    wt = function(x) x,
    qsec = sqrt))

## cleanup
rm(d)
</code></pre>

<hr>
<h2 id='CompositeData-class'>A S4 class to represent data for creating a composite</h2><span id='topic+CompositeData-class'></span>

<h3>Description</h3>

<p>A S4 class to represent data for creating a composite
</p>


<h3>Slots</h3>


<dl>
<dt><code>rawdata</code></dt><dd><p>A data frame of the data to be used for the composite scores</p>
</dd>
<dt><code>groups</code></dt><dd><p>A character string, the same length as the number of rows of
the data indicating to which group each row belong.  May be all the same
if only one group present in the data.</p>
</dd>
<dt><code>thresholds</code></dt><dd><p>A list with as many elements as there are unique
groups in the data, and where each element is a vector the same
length as the number of columns in the data frame, indicating the
reference thresholds for each variable, by group (all the same if only
one group).</p>
</dd>
<dt><code>higherisbetter</code></dt><dd><p>A logical vector the same length as the number of
columns in the data frame, indicating whether higher is better for
each variable (if <code>TRUE</code>) and otherwise (if <code>FALSE</code>) that
lower is better, indicating that variable should be reversed.</p>
</dd>
<dt><code>k</code></dt><dd><p>The number of variables as an integer.</p>
</dd>
<dt><code>rawtrans</code></dt><dd><p>A list of functions to transform the raw data (and thresholds).</p>
</dd>
</dl>

<hr>
<h2 id='CompositeReady'>An constructor function for the S4 CompositeReady class</h2><span id='topic+CompositeReady'></span>

<h3>Description</h3>

<p>An constructor function for the S4 CompositeReady class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompositeReady(
  data,
  covmat,
  sigma,
  standardize,
  use.prethreshold,
  distances,
  distanceDensity,
  winsorizedValues,
  better,
  rawdata,
  groups,
  thresholds,
  higherisbetter,
  k,
  rawtrans
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompositeReady_+3A_data">data</code></td>
<td>
<p>A data frame of the ready to use data</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_covmat">covmat</code></td>
<td>
<p>A covariance matrix of the data</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_sigma">sigma</code></td>
<td>
<p>A vector of the standard deviations of each variable</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_standardize">standardize</code></td>
<td>
<p>A logical whether the data were standardized or not</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_use.prethreshold">use.prethreshold</code></td>
<td>
<p>A logical value whether to calculate covariance matrix
based on the data after winsorizing, but before applying the threshold.
Defaults to <code>FALSE</code>, so that covariances are calculated after thresholds
(if any) are applied.</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_distances">distances</code></td>
<td>
<p>A data frame of the distance scores</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_distancedensity">distanceDensity</code></td>
<td>
<p>A ggplot2 graph of the densities of each distance score.
If not passed, generated automatically from the data.</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_winsorizedvalues">winsorizedValues</code></td>
<td>
<p>A data frame indicating the values used (if any) for winsorization.
Should have one row for each variable in the dataset.</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_better">better</code></td>
<td>
<p>A logical vector the same length as the number of columns in the distance scores
indicating whether higher or lower values are better for each.</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_rawdata">rawdata</code></td>
<td>
<p>A data frame with at least one row and column</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_groups">groups</code></td>
<td>
<p>an optional character vector. If omitted defaults to
a character vector of all &ldquo;one&rdquo;s.</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_thresholds">thresholds</code></td>
<td>
<p>an optional named list where names match the names in groups.
If using defaults for groups, should name it &ldquo;a&rdquo;.</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_higherisbetter">higherisbetter</code></td>
<td>
<p>an optional logical vector</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_k">k</code></td>
<td>
<p>an optional integer, the number of columns in the raw data</p>
</td></tr>
<tr><td><code id="CompositeReady_+3A_rawtrans">rawtrans</code></td>
<td>
<p>A list of functions to transform the raw data (and thresholds).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class &ldquo;CompositeReady&rdquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#make me!
</code></pre>

<hr>
<h2 id='CompositeReady-class'>An S4 class to represent composite ready data</h2><span id='topic+CompositeReady-class'></span>

<h3>Description</h3>

<p>An S4 class to represent composite ready data
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>A data frame ready for use to generate composite scores</p>
</dd>
<dt><code>covmat</code></dt><dd><p>A covariance matrix</p>
</dd>
<dt><code>sigma</code></dt><dd><p>The standard deviation of each variable</p>
</dd>
<dt><code>standardize</code></dt><dd><p>A logical value whether standardization was applied</p>
</dd>
<dt><code>distances</code></dt><dd><p>A data frame of the distance scores</p>
</dd>
<dt><code>distanceDensity</code></dt><dd><p>A ggplot2 density graph</p>
</dd>
<dt><code>winsorizedValues</code></dt><dd><p>A data frame of the values at which each variable was winsorized.
If percentile is 0, that means no winsorization, and values will simply be min and max.</p>
</dd>
<dt><code>better</code></dt><dd><p>A logical value whether better scores than threshold were allowed</p>
</dd>
<dt><code>use.prethreshold</code></dt><dd><p>A logical value whether covariance matrix was calculated from
pre threshold but post winsorizing data.</p>
</dd>
</dl>

<hr>
<h2 id='dropData'>Drop unnecessary data from a MahalanobisComposite object.</h2><span id='topic+dropData'></span>

<h3>Description</h3>

<p>This function removes graphs and other sensitive data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropData_+3A_object">object</code></td>
<td>
<p>A MahalanobisComposite object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MahalanobisComposite object with some slots replaced with missing values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make me!!!
</code></pre>

<hr>
<h2 id='factorComposite'>Score Data Using a Factor Model</h2><span id='topic+factorComposite'></span>

<h3>Description</h3>

<p>Create a composite using a Factor Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorComposite(
  object,
  type = c("onefactor", "secondorderfactor", "bifactor"),
  factors = list(NA_character_)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorComposite_+3A_object">object</code></td>
<td>
<p>An object of class <code>CompositeReady</code></p>
</td></tr>
<tr><td><code id="factorComposite_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of factor model to use</p>
</td></tr>
<tr><td><code id="factorComposite_+3A_factors">factors</code></td>
<td>
<p>A named list where names are the factor names and each
element is a character string of the indicator names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class <code>FactorScores</code>.
</p>


<h3>See Also</h3>

<p>Other composite: 
<code><a href="#topic+mahalanobisComposite">mahalanobisComposite</a>()</code>,
<code><a href="#topic+sumComposite">sumComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example creates distances for the built in mtcars data
# see ?mtcars for more details
# The distances are calculated from the "best" in the dataset
# First we create an appropriate CompositeData class object
# higher mpg &amp; hp are better and lower wt &amp; qsec are better
d &lt;- CompositeData(mtcars[, c("mpg", "hp", "wt", "qsec")],
  thresholds = list(one = with(mtcars, c(
    mpg = max(mpg),
    hp = max(hp),
    wt = min(wt),
    qsec = min(qsec)))
  ),
  higherisbetter = c(TRUE, TRUE, FALSE, FALSE))

# create the distance scores
# and the composite
# covariance matrix will be calculated from the data
# and data will be standardized to unit variance by default
dres &lt;- prepareComposite(d)

# see a density plot of the distance scores
dres@distanceDensity
# regular summary of distance scores
summary(dres@distances)

# examine covariance matrix
round(dres@covmat,2)

# now we can create the composite based on summing the (standardized)
# distances from our defined thresholds
# by default, distances are squared, then summed, and then square rooted
# to be back on the original scale
fcomp &lt;- factorComposite(dres, type = "onefactor")

# view a histogram of the composite scores
fcomp@scoreHistogram

# summarize the composite scores
summary(fcomp@scores)

## Not run: 
# we can also fit a second-order factor model
# there are not enough indicators to identify the factor
# and so lavaan gives us warning messages
fcomp2 &lt;- factorComposite(dres, type = "secondorderfactor",
  factors = list(speed = c("hp", "qsec")))

# view a histogram of the composite scores
fcomp2@scoreHistogram

# summarize the composite scores
summary(fcomp2@scores)

# compare one and second-order factor model scores
plot(fcomp@scores, fcomp2@scores)

# cleanup
rm(d, dres, fcomp, fcomp2)

## End(Not run)
</code></pre>

<hr>
<h2 id='ldensity'>Density Plot for a Long Dataset</h2><span id='topic+ldensity'></span>

<h3>Description</h3>

<p>Internal function only, not meant for general use
Simple wrapper around ggplot2 functionaly to create
density plots, potentially for many variables and coloured by group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldensity(data, melt = FALSE, x, facet, g, hist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldensity_+3A_data">data</code></td>
<td>
<p>A dataset (or melt()ed dataset)</p>
</td></tr>
<tr><td><code id="ldensity_+3A_melt">melt</code></td>
<td>
<p>Logical whether to melt() dataset</p>
</td></tr>
<tr><td><code id="ldensity_+3A_x">x</code></td>
<td>
<p>name of variable for density</p>
</td></tr>
<tr><td><code id="ldensity_+3A_facet">facet</code></td>
<td>
<p>A variable to use for facetting</p>
</td></tr>
<tr><td><code id="ldensity_+3A_g">g</code></td>
<td>
<p>A variable to use for grouping/colouring.  If <code>melt=TRUE</code>, this is
used as id.var as well.</p>
</td></tr>
<tr><td><code id="ldensity_+3A_hist">hist</code></td>
<td>
<p>Logical whether to make a density plot or histogram (if TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple facetted plot
pscore:::ldensity(mtcars, TRUE)
# simple coloured plot
pscore:::ldensity(mtcars, x = "mpg", g = "cyl")
</code></pre>

<hr>
<h2 id='mahalanobisComposite'>Score Data Using the Mahalanobis Distance</h2><span id='topic+mahalanobisComposite'></span>

<h3>Description</h3>

<p>Create a composite using the Mahalanobis Distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobisComposite(object, ncomponents, pca)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahalanobisComposite_+3A_object">object</code></td>
<td>
<p>An object of class <code>CompositeReady</code></p>
</td></tr>
<tr><td><code id="mahalanobisComposite_+3A_ncomponents">ncomponents</code></td>
<td>
<p>the number of components to use from the
principal component analysis. If missing, defaults to the
number of columns in the data.</p>
</td></tr>
<tr><td><code id="mahalanobisComposite_+3A_pca">pca</code></td>
<td>
<p>An optional PCA object from princomp to use.
If not passed, will be calculated from the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class <code>MahalanobisScores</code>.
</p>


<h3>See Also</h3>

<p>Other composite: 
<code><a href="#topic+factorComposite">factorComposite</a>()</code>,
<code><a href="#topic+sumComposite">sumComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example creates distances for the built in mtcars data
# see ?mtcars for more details
# The distances are calculated from the "best" in the dataset
# First we create an appropriate CompositeData class object
# higher mpg &amp; hp are better and lower wt &amp; qsec are better
d &lt;- CompositeData(mtcars[, c("mpg", "hp", "wt", "qsec")],
  thresholds = list(one = with(mtcars, c(
    mpg = max(mpg),
    hp = max(hp),
    wt = min(wt),
    qsec = min(qsec)))
  ),
  higherisbetter = c(TRUE, TRUE, FALSE, FALSE))

# create the distance scores
# and the composite
# covariance matrix will be calculated from the data
# and data will be standardized to unit variance by default
dres &lt;- prepareComposite(d)

# see a density plot of the distance scores
dres@distanceDensity
# regular summary of distance scores
summary(dres@distances)

# examine covariance matrix
round(dres@covmat,2)

# now we can create the composite based on mahalanobis distances
# from our defined thresholds
mcomp &lt;- mahalanobisComposite(dres, 1)

# view a histogram of the composite scores
mcomp@scoreHistogram

# summarize the composite scores
summary(mcomp@scores)

# check the screeplot and loadings
mcomp@screePlot
mcomp@loadingGraph
# examine the loadings as a table
mcomp@loadingTable

# one component is adequate to explain these data
# to be safe can pick first two and re-run model

# use only first two components
mcomp2 &lt;- mahalanobisComposite(dres, ncomponents = 2)

# view a histogram of the updated composite scores
mcomp2@scoreHistogram

# summarize the composite scores
summary(mcomp2@scores)

# compare using all versus two components
plot(mcomp@scores, mcomp2@scores)

# cleanup
rm(d, dres, mcomp, mcomp2)
</code></pre>

<hr>
<h2 id='MahalanobisScores-class'>An S4 class to represent composite scores based on Mahalanobis distance</h2><span id='topic+MahalanobisScores-class'></span><span id='topic+SumScores-class'></span><span id='topic+FactorScores-class'></span>

<h3>Description</h3>

<p>An S4 class to represent composite scores based on Mahalanobis distance
</p>
<p>An S4 class to represent composite scores based on summing
</p>
<p>An S4 class to represent composite scores based on (confirmatory) factor analysis
</p>


<h3>Slots</h3>


<dl>
<dt><code>scores</code></dt><dd><p>A vector of the final scores</p>
</dd>
<dt><code>scoreHistogram</code></dt><dd><p>A histogram of the final scores</p>
</dd>
<dt><code>screePlot</code></dt><dd><p>A screeplot from the PCA</p>
</dd>
<dt><code>loadingGraph</code></dt><dd><p>A graph of the component loadings</p>
</dd>
<dt><code>loadingTable</code></dt><dd><p>A table of all the component loadings</p>
</dd>
<dt><code>pca</code></dt><dd><p>Prinicipal component analysis results. A list (coercied from princomp output).</p>
</dd>
<dt><code>ncomponents</code></dt><dd><p>The number of components of the PCA to be used.</p>
</dd>
<dt><code>CompositeReady</code></dt><dd><p>The original CompositeReady class object passed in</p>
</dd>
<dt><code>scores</code></dt><dd><p>A vector of the final scores</p>
</dd>
<dt><code>scoreHistogram</code></dt><dd><p>A histogram of the final scores</p>
</dd>
<dt><code>transform</code></dt><dd><p>A character string of the type of transformation applied</p>
</dd>
<dt><code>type</code></dt><dd><p>A character string indicating whether data were summed or averaged</p>
</dd>
<dt><code>trans</code></dt><dd><p>A list of functions to transform data and backtransform it</p>
</dd>
<dt><code>systems</code></dt><dd><p>A list with as many elements as there are systems where
each element is a character vector containing the variable names for
each system.  If all variables belong to one system, a list with one
element that is missing.</p>
</dd>
<dt><code>CompositeReady</code></dt><dd><p>The original CompositeReady class object passed in</p>
</dd>
<dt><code>scores</code></dt><dd><p>A vector of the final scores</p>
</dd>
<dt><code>scoreHistogram</code></dt><dd><p>A histogram of the final scores</p>
</dd>
<dt><code>factorScores</code></dt><dd><p>A data frame with all factor score predictions</p>
</dd>
<dt><code>type</code></dt><dd><p>A character string indicating the type of factor model used</p>
</dd>
<dt><code>factors</code></dt><dd><p>A list with as many elements as there are specific factors,
where each element is a character vector of the variables for
a specific factor</p>
</dd>
<dt><code>Fit</code></dt><dd><p>A fitted model object from lavaan.</p>
</dd>
<dt><code>CompositeReady</code></dt><dd><p>The original CompositeReady class object passed in</p>
</dd>
</dl>

<hr>
<h2 id='MetSSS'>Score the MetSSS</h2><span id='topic+MetSSS'></span>

<h3>Description</h3>

<p>Function requires systolic and diastolic blood pressure,
triglycerides, waist circumference, HDL cholesterol,
blood glucose, and sex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetSSS(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MetSSS_+3A_input">input</code></td>
<td>
<p>data passed on as <code>newdata</code> to <code><a href="#topic+predictCS">predictCS</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- data.frame(
  sbp = c(122, 102.5),
  dbp = c(76.5, 64),
  trigs = c(1.47, 1.27),
  hdl = c(2.22, 1.59),
  waist = c(71, 91),
  glucose = c(5.16, 5.82),
  sex = c("Female", "Male"))

MetSSS(mydata)
</code></pre>

<hr>
<h2 id='MetSSS_model'>MetSSS Model</h2><span id='topic+MetSSS_model'></span>

<h3>Description</h3>

<p>Simple example model that predicts hours of watching TV from age and marital status
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetSSS_model
</code></pre>


<h3>Format</h3>

<p>an object from <code><a href="#topic+mahalanobisComposite">mahalanobisComposite</a></code>
</p>


<h3>Source</h3>

<p>Healthy Hearts Study
</p>

<hr>
<h2 id='predictCS'>Internal function to prepare data for prediction</h2><span id='topic+predictCS'></span>

<h3>Description</h3>

<p>Internal function to prepare data for prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictCS(object, newdata, groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictCS_+3A_object">object</code></td>
<td>
<p>An object of S4 class &ldquo;MahalanobisScores&rdquo;,
&ldquo;SumScores&rdquo;, or &ldquo;FactorScores&rdquo; containing
a model and results to be used to get predictions on new data.</p>
</td></tr>
<tr><td><code id="predictCS_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with identical variable names as was used
to build the initial model.</p>
</td></tr>
<tr><td><code id="predictCS_+3A_groups">groups</code></td>
<td>
<p>A vector with the same length as the data frame in <code>newdata</code>,
has rows, containing the groups each row belongs to.  See <code>CompositeData</code>
for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class &ldquo;CompositeReady&rdquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- CompositeData(mtcars[, c("mpg", "hp", "wt", "disp")],
                   thresholds = list(one = with(mtcars, c(
                                     mpg = max(mpg),
                                     hp = max(hp),
                                     wt = min(wt),
                                     disp = min(disp)))),
                   higherisbetter = c(TRUE, TRUE, FALSE, FALSE))
## create the distance scores
## and prepare to create the composite
dres &lt;- prepareComposite(d)

## create composite based on summing the (standardized)
scomp &lt;- sumComposite(dres, "square", "sum")
## use model to generate predictions on new data
predictCS(scomp,
          newdata = mtcars[1, c("mpg", "hp", "wt", "qsec")],
          groups = "one")

## create composite based on mahalanobis distances
mcomp &lt;- mahalanobisComposite(dres)
## use model to generate predictions on new data
predictCS(mcomp,
          newdata = mtcars[1, c("mpg", "hp", "wt", "qsec")],
          groups = "one")
## note in this too simple example, there are negative variance estimates
## create composite based on factor scores
fcomp &lt;- factorComposite(dres, type = "onefactor")
## use model to generate predictions on new data
predictCS(fcomp,
          newdata = mtcars[1:5, c("mpg", "hp", "wt", "disp")],
          groups = rep("one", 5))
</code></pre>

<hr>
<h2 id='prepareComposite'>Prepare distance scores on data in preparation for composite scoring</h2><span id='topic+prepareComposite'></span>

<h3>Description</h3>

<p>Prepare distance scores on data in preparation for composite scoring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareComposite(
  object,
  winsorize = 0,
  values,
  better = TRUE,
  covmat,
  standardize = TRUE,
  use.prethreshold = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareComposite_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;CompositeData&rsquo;.</p>
</td></tr>
<tr><td><code id="prepareComposite_+3A_winsorize">winsorize</code></td>
<td>
<p>Whether to winsorize the data or not.  Defaults to <code>FALSE</code>.
If not <code>FALSE</code>, the percentile to winsorize at.  For example, .01 would be
the .01 and the 1 - .01 percentiles.</p>
</td></tr>
<tr><td><code id="prepareComposite_+3A_values">values</code></td>
<td>
<p>The values to use for winsorization.  Optional.  If specified, preempts
the percentiles given by winsorize.</p>
</td></tr>
<tr><td><code id="prepareComposite_+3A_better">better</code></td>
<td>
<p>Logical indicating whether &ldquo;better&rdquo; values than the threshold
are allowed. Defaults to <code>TRUE</code>.
#' @param object An DistanceScores class object</p>
</td></tr>
<tr><td><code id="prepareComposite_+3A_covmat">covmat</code></td>
<td>
<p>The covariance matrix to use.  If missing,
austomatically calculated from the data.</p>
</td></tr>
<tr><td><code id="prepareComposite_+3A_standardize">standardize</code></td>
<td>
<p>A logical value whether to standardize the data or not.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="prepareComposite_+3A_use.prethreshold">use.prethreshold</code></td>
<td>
<p>A logical value whether to calculate covariance matrix
based on the data after winsorizing, but before applying the threshold.
Defaults to <code>FALSE</code>, so that covariances are calculated after thresholds
(if any) are applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class &ldquo;CompositeReady&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example creates distances for the built in mtcars data
# see ?mtcars for more details
# The distances are calculated from the "best" in the dataset
# First we create an appropriate CompositeData class object
# higher mpg &amp; hp are better and lower wt &amp; qsec are better
d &lt;- CompositeData(mtcars[, c("mpg", "hp", "wt", "qsec")],
  thresholds = list(one = with(mtcars, c(
    mpg = max(mpg),
    hp = max(hp),
    wt = min(wt),
    qsec = min(qsec)))
  ),
  higherisbetter = c(TRUE, TRUE, FALSE, FALSE),
  rawtrans = list(
    mpg = function(x) x,
    hp = function(x) x,
    wt = function(x) x,
    qsec = sqrt))


# create the distance scores
dres &lt;- prepareComposite(d)

# see a density plot of the distance scores
dres@distanceDensity
# regular summary of distance scores
summary(dres@distances)

# examine covariance matrix
round(dres@covmat,2)
# cleanup
rm(d, dres)

</code></pre>

<hr>
<h2 id='sumComposite'>Score Data Using a simple sum</h2><span id='topic+sumComposite'></span>

<h3>Description</h3>

<p>Create a composite using summation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumComposite(
  object,
  transform = c("square", "abs", "none"),
  type = c("sum", "mean"),
  systems
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumComposite_+3A_object">object</code></td>
<td>
<p>An object of class <code>CompositeReady</code></p>
</td></tr>
<tr><td><code id="sumComposite_+3A_transform">transform</code></td>
<td>
<p>A character string indicating the type of transformation to use.
One of &ldquo;square&rdquo;, &ldquo;abs&rdquo;, or &ldquo;none&rdquo;, which either sums the raw data,
sums the squared data and then takes the square root, or sums the absolute values of the
data.</p>
</td></tr>
<tr><td><code id="sumComposite_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of aggregation to use.
One of &ldquo;sum&rdquo; or &ldquo;mean&rdquo;.</p>
</td></tr>
<tr><td><code id="sumComposite_+3A_systems">systems</code></td>
<td>
<p>An optional list where each element is a character vector of the
variable names within a particular system.  If given, scores are first averaged
within a system, before being aggregated across systems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class <code>SumScores</code>.
</p>


<h3>See Also</h3>

<p>Other composite: 
<code><a href="#topic+factorComposite">factorComposite</a>()</code>,
<code><a href="#topic+mahalanobisComposite">mahalanobisComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example creates distances for the built in mtcars data
# see ?mtcars for more details
# The distances are calculated from the "best" in the dataset
# First we create an appropriate CompositeData class object
# higher mpg &amp; hp are better and lower wt &amp; qsec are better
d &lt;- CompositeData(mtcars[, c("mpg", "hp", "wt", "qsec")],
  thresholds = list(one = with(mtcars, c(
    mpg = max(mpg),
    hp = max(hp),
    wt = min(wt),
    qsec = min(qsec)))
  ),
  higherisbetter = c(TRUE, TRUE, FALSE, FALSE))

# create the distance scores
# and the composite
# covariance matrix will be calculated from the data
# and data will be standardized to unit variance by default
dres &lt;- prepareComposite(d)

# see a density plot of the distance scores
dres@distanceDensity
# regular summary of distance scores
summary(dres@distances)

# examine covariance matrix
round(dres@covmat,2)

# now we can create the composite based on summing the (standardized)
# distances from our defined thresholds
# by default, distances are squared, then summed, and then square rooted
# to be back on the original scale
scomp &lt;- sumComposite(dres, "square", "sum")

# view a histogram and summary of the composite scores
scomp@scoreHistogram
summary(scomp@scores)

# calculate average (mean) instead of sum
scomp2 &lt;- sumComposite(dres, "square", "mean")

# view a histogram and summary of the composite scores
scomp2@scoreHistogram
summary(scomp2@scores)

# scores are still the same (just different scaling)
plot(scomp@scores, scomp2@scores)

# first average scores within a system, then sum
# within a system, scores are always averaged, never summed
scomp3 &lt;- sumComposite(dres, "square", "sum",
  systems = list(
    environment = c("mpg"),
    performance = c("hp", "qsec", "wt")))

# view a histogram and summary of the composite scores
scomp3@scoreHistogram
summary(scomp3@scores)

# compare all three scores
# because of the different number of indicators within each system
# there is a re-weighting for S3
plot(data.frame(S1 = scomp@scores, S2 = scomp2@scores, S3 = scomp3@scores))

# cleanup
rm(d, dres, scomp, scomp2, scomp3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
