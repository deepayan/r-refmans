<!DOCTYPE html><html><head><title>Help for package navigation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {navigation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute_coverage'><p>Compute Coverage</p></a></li>
<li><a href='#compute_mean_orientation_err'><p>Compute mean orientation error</p></a></li>
<li><a href='#compute_mean_position_err'><p>Compute mean position error</p></a></li>
<li><a href='#compute_nees'><p>Compute Normalized Estimation Errror Squared (NEES)</p></a></li>
<li><a href='#example_1_traj_ellipsoidal'><p>Example trajectory 1 in ellipsoidal coordinates</p></a></li>
<li><a href='#example_1_traj_ned'><p>Example trajectory 1 in NED coordinates</p></a></li>
<li><a href='#example_2_traj_ellipsoidal'><p>Example trajectory 2 in ellipsoidal coordinates</p></a></li>
<li><a href='#example_2_traj_ned'><p>Example trajectory 2 in NED coordinates</p></a></li>
<li><a href='#lemniscate_traj_ned'><p>Lemniscate trajectory in NED coordinates</p></a></li>
<li><a href='#make_sensor'><p>Construct a <code>sensor</code> object</p></a></li>
<li><a href='#make_timing'><p>Construct a <code>timing</code> object</p></a></li>
<li><a href='#make_trajectory'><p>Construct a <code>trajectory</code> object</p></a></li>
<li><a href='#navigation'><p>Runs &quot;IMU model evaluation&quot; or &quot;INS-GPS-Baro integrated navigation (sensor fusion)&quot;</p></a></li>
<li><a href='#plot_imu_err_with_cov'><p>Plot IMU error with covariances</p></a></li>
<li><a href='#plot_nav_states_with_cov'><p>Plot navigation states with covariance</p></a></li>
<li><a href='#plot.coverage.stat'><p>Plot multiple <code>coverage.stat</code> objects</p></a></li>
<li><a href='#plot.navigation'><p>Plot a <code>navigation</code> object</p></a></li>
<li><a href='#plot.navigation.stat'><p>Plot multiple <code>navigation.stat</code> objects</p></a></li>
<li><a href='#plot.nees.stat'><p>Plot multiple <code>nees.stat</code> objects</p></a></li>
<li><a href='#plot.trajectory'><p>Plot a <code>trajectory</code> object</p></a></li>
<li><a href='#print.sensor'><p>Print a <code>sensor</code> object parameters (name, frequency and error model)</p></a></li>
<li><a href='#print.trajectory'><p>Print trajectory Objects</p></a></li>
<li><a href='#X_ellips2ned'><p>Transform position from ellipsoidal to NED coordinates</p></a></li>
<li><a href='#X_ned2ellips'><p>Transform position from NED to ellipsoidal coordinates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyze the Impact of Sensor Error Modelling on Navigation
Performance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lionel Voirol &lt;lionelvoirol@hotmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the framework presented in Cucci, D. A., Voirol, L., Khaghani, M. and Guerrier, S. (2023) &lt;<a href="https://doi.org/10.1109%2FTIM.2023.3267360">doi:10.1109/TIM.2023.3267360</a>&gt; which allows to analyze the impact of sensor error modeling on the performance of integrated navigation (sensor fusion) based on inertial measurement unit (IMU), Global Positioning System (GPS), and barometer data.
             The framework relies on Monte Carlo simulations in which a Vanilla Extended Kalman filter is coupled with realistic and user-configurable noise generation mechanisms to recover a reference trajectory from noisy measurements. 
             The evaluation of several statistical metrics of the solution, aggregated over hundreds of simulated realizations, provides reasonable estimates of the expected performances of the system in real-world conditions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), plotly, magrittr, simts</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>expm, rbenchmark, leaflet, MASS, pbmcapply, Rcpp (&ge; 0.8.0),
RcppArmadillo (&ge; 0.2.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SMAC-Group/navigation">https://github.com/SMAC-Group/navigation</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SMAC-Group/navigation/issues">https://github.com/SMAC-Group/navigation/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-16 09:06:11 UTC; lionel</td>
</tr>
<tr>
<td>Author:</td>
<td>Davide A. Cucci [aut],
  Lionel Voirol [aut, cre],
  Mehran Khaghani [aut],
  Stéphane Guerrier [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-16 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute_coverage'>Compute Coverage</h2><span id='topic+compute_coverage'></span>

<h3>Description</h3>

<p>Compute Empirical Coverage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_coverage(
  sols,
  alpha = 0.95,
  step = 100,
  idx = 1:6,
  progressbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_coverage_+3A_sols">sols</code></td>
<td>
<p>The set of solutions returned by the <code>navigation</code> function</p>
</td></tr>
<tr><td><code id="compute_coverage_+3A_alpha">alpha</code></td>
<td>
<p>size of the confidence interval</p>
</td></tr>
<tr><td><code id="compute_coverage_+3A_step">step</code></td>
<td>
<p>Step</p>
</td></tr>
<tr><td><code id="compute_coverage_+3A_idx">idx</code></td>
<td>
<p>Components of the states to be considered (default: position and orientation)</p>
</td></tr>
<tr><td><code id="compute_coverage_+3A_progressbar">progressbar</code></td>
<td>
<p>A <code>boolean</code> specifying whether or not to show a progress bar. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a <code>coverage.stat</code> object which contains the empirical coverage of the navigation solutions.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned, system = "ned")
timing &lt;- make_timing(
  nav.start = 0, # time at which to begin filtering
  nav.end = 20,
  freq.imu = 100,
  # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1, # GNSS frequency
  freq.baro = 1,
  # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 10,
  # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 15
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) + 
AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) + 
AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 5 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "1",
  # order of the Taylor expansion of the matrix exponential
  # used to compute Phi and Q matrices
  compute_PhiQ_each_n = 20,
  # compute new Phi and Q matrices
  # every n IMU steps (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
) # keep one covariance every second
coverage &lt;- compute_coverage(res, alpha = 0.7, step = 100, idx = 1:6)
plot(coverage)
</code></pre>

<hr>
<h2 id='compute_mean_orientation_err'>Compute mean orientation error</h2><span id='topic+compute_mean_orientation_err'></span>

<h3>Description</h3>

<p>Compute the mean orientation error (|| log(A^T * B) ||)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_mean_orientation_err(sols, step = 1, t0 = NULL, tend = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_mean_orientation_err_+3A_sols">sols</code></td>
<td>
<p>The set of solutions returned by the <code>navigation</code> function</p>
</td></tr>
<tr><td><code id="compute_mean_orientation_err_+3A_step">step</code></td>
<td>
<p>do it for one sample out of <code>step</code></p>
</td></tr>
<tr><td><code id="compute_mean_orientation_err_+3A_t0">t0</code></td>
<td>
<p>Start time for RMS calculation (default: beginning)</p>
</td></tr>
<tr><td><code id="compute_mean_orientation_err_+3A_tend">tend</code></td>
<td>
<p>Start time for RMS calculation (default: end)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a <code>navigation.stat</code> object which contains the mean orientation error over the fused trajectories.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned, system = "ned")
timing &lt;- make_timing(
  nav.start = 0,
  # time at which to begin filtering
  nav.end = 20,
  freq.imu = 100,
  # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1, # GNSS frequency
  freq.baro = 1,
  # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 10,
  # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 15
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) +
  AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) +
  AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalman filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 5 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "1",
  # order of the Taylor expansion of the matrix exponential
  # used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10,
  # compute new Phi and Q matrices every n IMU steps (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
) # keep one covariance every second


oe &lt;- compute_mean_orientation_err(res, step = 25)
plot(oe)

</code></pre>

<hr>
<h2 id='compute_mean_position_err'>Compute mean position error</h2><span id='topic+compute_mean_position_err'></span>

<h3>Description</h3>

<p>Compute the mean position error (norm of 3D NED error)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_mean_position_err(sols, step = 1, t0 = NULL, tend = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_mean_position_err_+3A_sols">sols</code></td>
<td>
<p>The set of solutions returned by the <code>navigation</code> function</p>
</td></tr>
<tr><td><code id="compute_mean_position_err_+3A_step">step</code></td>
<td>
<p>do it for one sample out of <code>step</code></p>
</td></tr>
<tr><td><code id="compute_mean_position_err_+3A_t0">t0</code></td>
<td>
<p>Start time for RMS calculation (default: beginning)</p>
</td></tr>
<tr><td><code id="compute_mean_position_err_+3A_tend">tend</code></td>
<td>
<p>Start time for RMS calculation (default: end)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a <code>navigation.stat</code> object which contains the mean position error over the fused trajectories.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned, system = "ned")
timing &lt;- make_timing(
  nav.start = 0,
  # time at which to begin filtering
  nav.end = 20,
  freq.imu = 100,
  # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1,
  # GNSS frequency
  freq.baro = 1,
  # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 10,
  # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 15
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) +
  AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) +
  AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 5 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "2",
  # order of the Taylor expansion of the matrix exponential 
  # used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10,
  # compute new Phi and Q matrices every n IMU steps 
  # (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
) # keep one covariance every second


pe &lt;- compute_mean_position_err(res, step = 25)
plot(pe)
</code></pre>

<hr>
<h2 id='compute_nees'>Compute Normalized Estimation Errror Squared (NEES)</h2><span id='topic+compute_nees'></span>

<h3>Description</h3>

<p>Compute Normalized Estimation Errror Squared (NEES)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_nees(sols, step = 50, idx = 1:6, progressbar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_nees_+3A_sols">sols</code></td>
<td>
<p>The set of solutions returned by the <code>navigation</code> function</p>
</td></tr>
<tr><td><code id="compute_nees_+3A_step">step</code></td>
<td>
<p>do it for one sample out of <code>step</code></p>
</td></tr>
<tr><td><code id="compute_nees_+3A_idx">idx</code></td>
<td>
<p>Components of the states to be considered (default: position and orientation)</p>
</td></tr>
<tr><td><code id="compute_nees_+3A_progressbar">progressbar</code></td>
<td>
<p>A <code>boolean</code> specifying whether or not to show a progress bar. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a <code>nees.stat</code> object which contains the  Normalized Estimation Error Squared.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned, 
system = "ned")
timing &lt;- make_timing(
  nav.start = 0, # time at which to begin filtering
  nav.end = 30,
  freq.imu = 100,
  # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1,
  # GNSS frequency
  freq.baro = 1,
  # barometer frequency 
  # (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 20, 
  # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 25
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) + 
AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) + 
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) + 
AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(name = "imu", 
frequency = timing$freq.imu, 
error_model1 = acc.mdl, 
error_model2 = gyr.mdl)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl, error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 5 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "4",
  # order of the Taylor expansion of the matrix exponential
  #  used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10, 
  # compute new Phi and Q matrices every n IMU steps
  #  (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
) # keep one covariance every second
nees &lt;- compute_nees(res, idx = 1:6, step = 100)
plot(nees)
</code></pre>

<hr>
<h2 id='example_1_traj_ellipsoidal'>Example trajectory 1 in ellipsoidal coordinates</h2><span id='topic+example_1_traj_ellipsoidal'></span>

<h3>Description</h3>

<p>Example trajectory 1 in ellipsoidal coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_1_traj_ellipsoidal
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 6000 rows and 7 columns.
</p>

<hr>
<h2 id='example_1_traj_ned'>Example trajectory 1 in NED coordinates</h2><span id='topic+example_1_traj_ned'></span>

<h3>Description</h3>

<p>Example trajectory 1 in NED coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_1_traj_ned
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 6000 rows and 7 columns.
</p>

<hr>
<h2 id='example_2_traj_ellipsoidal'>Example trajectory 2 in ellipsoidal coordinates</h2><span id='topic+example_2_traj_ellipsoidal'></span>

<h3>Description</h3>

<p>Example trajectory 2 in ellipsoidal coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_2_traj_ellipsoidal
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 12001 rows and 7 columns.
</p>

<hr>
<h2 id='example_2_traj_ned'>Example trajectory 2 in NED coordinates</h2><span id='topic+example_2_traj_ned'></span>

<h3>Description</h3>

<p>Example trajectory 2 in NED coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_2_traj_ned
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 12001 rows and 7 columns.
</p>

<hr>
<h2 id='lemniscate_traj_ned'>Lemniscate trajectory in NED coordinates</h2><span id='topic+lemniscate_traj_ned'></span>

<h3>Description</h3>

<p>Lemniscate trajectory in NED coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lemniscate_traj_ned
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 60001 rows and 7 columns.
</p>

<hr>
<h2 id='make_sensor'>Construct a <code>sensor</code> object</h2><span id='topic+make_sensor'></span>

<h3>Description</h3>

<p>Construct a <code>sensor</code> object for IMU, GPS, and Baro from error model of class <code>ts.model</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sensor(
  name,
  frequency = 1,
  error_model1 = NULL,
  error_model2 = NULL,
  error_model3 = NULL,
  error_model4 = NULL,
  error_data1 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_sensor_+3A_name">name</code></td>
<td>
<p>Name of the sensor</p>
</td></tr>
<tr><td><code id="make_sensor_+3A_frequency">frequency</code></td>
<td>
<p>Frequency associated with the error model</p>
</td></tr>
<tr><td><code id="make_sensor_+3A_error_model1">error_model1</code></td>
<td>
<p>Error model of class <code>ts.model</code> for either accelerometer (as part of imu), horizontal components of GPS position, or Barometer</p>
</td></tr>
<tr><td><code id="make_sensor_+3A_error_model2">error_model2</code></td>
<td>
<p>Error model of class <code>ts.model</code> for either gyroscope (as part of imu) or vertical component of GPS position</p>
</td></tr>
<tr><td><code id="make_sensor_+3A_error_model3">error_model3</code></td>
<td>
<p>Error model of class <code>ts.model</code> for horizontal components of GPS velocity</p>
</td></tr>
<tr><td><code id="make_sensor_+3A_error_model4">error_model4</code></td>
<td>
<p>Error model of class <code>ts.model</code> for vertical component of GPS velocity</p>
</td></tr>
<tr><td><code id="make_sensor_+3A_error_data1">error_data1</code></td>
<td>
<p>Vector of error observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sensor</code> containing sensor name and its additive error model along with the frequency associated to that model
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># IMU:
imu.freq &lt;- 250
acc.mdl &lt;- WN(sigma2 = 1.535466e-04) + RW(gamma2 = 1.619511e-10)
gyr.mdl &lt;- WN(sigma2 = 1.711080e-03) + RW(gamma2 = 1.532765e-13)
imu.mdl &lt;- make_sensor(
  name = "imu",
  frequency = imu.freq,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)

# GPS:
gps.freq &lt;- 1
gps.mdl.pos.hor &lt;- WN(sigma2 = 2^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 4^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.04^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.06^2)
gps.mdl &lt;- make_sensor(
  name = "gps", frequency = gps.freq,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)

# Baro:
baro.freq &lt;- 1
baro.mdl &lt;- WN(sigma2 = 0.5^2)
baro.mdl &lt;- make_sensor(
  name = "baro",
  frequency = baro.freq,
  error_model1 = baro.mdl
)

</code></pre>

<hr>
<h2 id='make_timing'>Construct a <code>timing</code> object</h2><span id='topic+make_timing'></span>

<h3>Description</h3>

<p>Construct a <code>timing</code> object controlling the timing and frequencies for navigation, making sure about the consistency and feasibility of provided information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_timing(
  nav.start = NULL,
  nav.end = NULL,
  freq.imu = NULL,
  freq.gps = NULL,
  freq.baro = NULL,
  gps.out.start = NULL,
  gps.out.end = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_timing_+3A_nav.start">nav.start</code></td>
<td>
<p>Time at which navigation starts</p>
</td></tr>
<tr><td><code id="make_timing_+3A_nav.end">nav.end</code></td>
<td>
<p>Time at which navigation ends</p>
</td></tr>
<tr><td><code id="make_timing_+3A_freq.imu">freq.imu</code></td>
<td>
<p>Frequency of generated IMU data (and hence that of navigation)</p>
</td></tr>
<tr><td><code id="make_timing_+3A_freq.gps">freq.gps</code></td>
<td>
<p>Frequency of generated GPS data</p>
</td></tr>
<tr><td><code id="make_timing_+3A_freq.baro">freq.baro</code></td>
<td>
<p>Frequency of generated Baro data</p>
</td></tr>
<tr><td><code id="make_timing_+3A_gps.out.start">gps.out.start</code></td>
<td>
<p>Time at which GPS outage starts</p>
</td></tr>
<tr><td><code id="make_timing_+3A_gps.out.end">gps.out.end</code></td>
<td>
<p>Time at which GPS outage ends</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>timing</code> containing sensor name and its additive error model along with the frequency associated to that model
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timing &lt;- make_timing(
  nav.start = 0,
  nav.end = 50,
  freq.imu = 10,
  freq.gps = 1,
  freq.baro = 1e-5,
  gps.out.start = 25.1,
  gps.out.end = 45
)

</code></pre>

<hr>
<h2 id='make_trajectory'>Construct a <code>trajectory</code> object</h2><span id='topic+make_trajectory'></span>

<h3>Description</h3>

<p>Create a <code>trajectory</code> object from simple matrix input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_trajectory(
  data,
  system = "ellipsoidal",
  start_time = NULL,
  name = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_trajectory_+3A_data">data</code></td>
<td>
<p>A multiple-column <code>matrix</code>. The first column corresponds to the measurment time (in seconds); columns 2, 3 and 4 corresponds to the positions (with the order lat, long and alt (in rad) if ellipsoidal coord or x_N, x_E and x_D for NED coord); columns 5, 6 and 7 (optional) corresponds to the attitude (with the order roll, pitch and yaw); columns 8, 9 and 10 (optional) corresponds to the velocity along the same axes are columns 2, 3 and 4.</p>
</td></tr>
<tr><td><code id="make_trajectory_+3A_system">system</code></td>
<td>
<p>A <code>string</code> corresponding to the coordinate system (possible choices: <code>ellipsoidal</code> or <code>ned</code>) considered.</p>
</td></tr>
<tr><td><code id="make_trajectory_+3A_start_time">start_time</code></td>
<td>
<p>A <code>string</code> (optional) corresponding to the start time for the trajectory.</p>
</td></tr>
<tr><td><code id="make_trajectory_+3A_name">name</code></td>
<td>
<p>A <code>string</code> (optional) corresponding to the name of the dataset.</p>
</td></tr>
<tr><td><code id="make_trajectory_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>trajectory</code>.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
dat &lt;- cbind(
  seq(from = 0, to = 60 * 60, length.out = n),
  46.204391 * pi / 180 + cumsum(rnorm(n)) / 10^5,
  6.143158 * pi / 180 + cumsum(rnorm(n)) / 10^5,
  375 + cumsum(rnorm(n))
)
traj &lt;- make_trajectory(data = dat, name = "My cool data")
traj
plot(traj)
</code></pre>

<hr>
<h2 id='navigation'>Runs &quot;IMU model evaluation&quot; or &quot;INS-GPS-Baro integrated navigation (sensor fusion)&quot;</h2><span id='topic+navigation'></span>

<h3>Description</h3>

<p>This function performs of the two following main tasks, base on the provided input. If a reference trajectory (<code>traj.ref</code>) is provided, it generates sensor data (IMU, GPS, Baro) corrupted by additive errors according to <code>snsr.mdl</code>, and performs navigation using <code>KF.mdl</code> as the sensor error model within the Kalman filter to evaluate how this particular model performs when navigating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>navigation(
  traj.ref,
  timing,
  snsr.mdl,
  KF.mdl,
  g = 9.8056,
  num.runs = 1,
  results.system = "ned",
  x_o = NULL,
  noProgressBar = FALSE,
  IC = NULL,
  imu_data = NULL,
  gps_data = NULL,
  baro_data = NULL,
  input.seed = 0,
  PhiQ_method = "exact",
  P_subsampling = 1,
  compute_PhiQ_each_n = 1,
  parallel.ncores = detectCores(all.tests = FALSE, logical = TRUE),
  tmpdir = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="navigation_+3A_traj.ref">traj.ref</code></td>
<td>
<p>A <code>trajectory</code> object (see the documentation for <code>make_trajectory</code>), serving as the reference trajectory for generating sensor data and evaluating the error in navigation once performed. Only position and attitude data are required/considered, and velocity will be calculated from position.</p>
</td></tr>
<tr><td><code id="navigation_+3A_timing">timing</code></td>
<td>
<p>A <code>timing</code> object (see the documentation for <code>make_timing</code>) containing timing information such as start and end of navigation.</p>
</td></tr>
<tr><td><code id="navigation_+3A_snsr.mdl">snsr.mdl</code></td>
<td>
<p>A <code>sensor</code> object (see the documentation for <code>make_sensor</code>) containing additive sensor error model to generate realistic sensor data.</p>
</td></tr>
<tr><td><code id="navigation_+3A_kf.mdl">KF.mdl</code></td>
<td>
<p>A <code>sensor</code> object (see the documentation for <code>make_sensor</code>) containing additive sensor error model to be used within the Kalman filter for navigation.</p>
</td></tr>
<tr><td><code id="navigation_+3A_g">g</code></td>
<td>
<p>Gravitational acceleration.</p>
</td></tr>
<tr><td><code id="navigation_+3A_num.runs">num.runs</code></td>
<td>
<p>Number of times the sensor data generation and navigation is performed (Monte-Carlo simulation).</p>
</td></tr>
<tr><td><code id="navigation_+3A_results.system">results.system</code></td>
<td>
<p>The coordinate system (<code>ned</code>/<code>ellipsoidal</code>) in which the results are reported (see the documentation for <code>make_trajectory</code>).</p>
</td></tr>
<tr><td><code id="navigation_+3A_x_o">x_o</code></td>
<td>
<p>Origin of the fixed <code>ned</code> frame.</p>
</td></tr>
<tr><td><code id="navigation_+3A_noprogressbar">noProgressBar</code></td>
<td>
<p>A <code>bolean</code> specifying if there should not be a progress bar.</p>
</td></tr>
<tr><td><code id="navigation_+3A_ic">IC</code></td>
<td>
<p>Initial conditions. See the examples for the format.</p>
</td></tr>
<tr><td><code id="navigation_+3A_imu_data">imu_data</code></td>
<td>
<p>IMU data. See the examples for the format.</p>
</td></tr>
<tr><td><code id="navigation_+3A_gps_data">gps_data</code></td>
<td>
<p>GPS data. See the examples for the format.</p>
</td></tr>
<tr><td><code id="navigation_+3A_baro_data">baro_data</code></td>
<td>
<p>Baro data. See the examples for the format.</p>
</td></tr>
<tr><td><code id="navigation_+3A_input.seed">input.seed</code></td>
<td>
<p>Seed for the random number generator. Actual seed is computed as <code>input.seed * num.runs + run</code></p>
</td></tr>
<tr><td><code id="navigation_+3A_phiq_method">PhiQ_method</code></td>
<td>
<p>String that specify the method to compute Phi and Q matrices, can be &quot;exact&quot; or the order of the Taylor expansions to use.</p>
</td></tr>
<tr><td><code id="navigation_+3A_p_subsampling">P_subsampling</code></td>
<td>
<p>(memory optimization) store only one sample of the P matrix each <code>P_subsampling</code> time instants.</p>
</td></tr>
<tr><td><code id="navigation_+3A_compute_phiq_each_n">compute_PhiQ_each_n</code></td>
<td>
<p>Specify the interval of IMU measurements between each computation of PhiQ.</p>
</td></tr>
<tr><td><code id="navigation_+3A_parallel.ncores">parallel.ncores</code></td>
<td>
<p>The number of cores to be used for parallel Monte-Carlo runs.</p>
</td></tr>
<tr><td><code id="navigation_+3A_tmpdir">tmpdir</code></td>
<td>
<p>Where to store temporary navigation output. It should not be mapped on a filesystem which lives in RAM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code>navigation</code> class containing the reference trajectory, fused trajectory, sensor data, covariance matrix, and time.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned, system = "ned")
timing &lt;- make_timing(
  nav.start = 0, # time at which to begin filtering
  nav.end = 15,
  freq.imu = 100, # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1, # GNSS frequency
  freq.baro = 1, # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 8, # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 13
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) +
  AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) +
  AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 5 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "1",
  # order of the Taylor expansion of the matrix exponential
  # used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10,
  # compute new Phi and Q matrices every n IMU steps (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
) # keep one covariance every second

</code></pre>

<hr>
<h2 id='plot_imu_err_with_cov'>Plot IMU error with covariances</h2><span id='topic+plot_imu_err_with_cov'></span>

<h3>Description</h3>

<p>this function plots the estimated IMU errors with covariance of a solution computed with the <code>navigation</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_imu_err_with_cov(sol, idx = 1, error = TRUE, step = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_imu_err_with_cov_+3A_sol">sol</code></td>
<td>
<p>The set of solutions returned by the <code>navigation</code> function</p>
</td></tr>
<tr><td><code id="plot_imu_err_with_cov_+3A_idx">idx</code></td>
<td>
<p>Which Monte-Carlo solution to plot</p>
</td></tr>
<tr><td><code id="plot_imu_err_with_cov_+3A_error">error</code></td>
<td>
<p>Whether to plot the error with respect to the reference or the estimated values</p>
</td></tr>
<tr><td><code id="plot_imu_err_with_cov_+3A_step">step</code></td>
<td>
<p>Plot one time out of <code>step</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the estimated IMU errors with covariance.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned,
 system = "ned")
plot(traj)
timing &lt;- make_timing(
  nav.start = 0, # time at which to begin filtering
  nav.end = 20,
  freq.imu = 100, 
  # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1, 
  # GNSS frequency
  freq.baro = 1, 
  # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 10, # to simulate a GNSS outage, set a time before nav.end
  gps.out.end =15
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) +
  AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) +
  AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 5 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "2",
  # order of the Taylor expansion of the matrix exponential used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10,
  # compute new Phi and Q matrices every n IMU steps (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
)
plot_imu_err_with_cov(res, error=FALSE)

</code></pre>

<hr>
<h2 id='plot_nav_states_with_cov'>Plot navigation states with covariance</h2><span id='topic+plot_nav_states_with_cov'></span>

<h3>Description</h3>

<p>this function plots the navigation states with estimated covariance of a solution computed with the <code>navigation</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_nav_states_with_cov(sol, idx = 1, cov_idx = 1, error = TRUE, step = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_nav_states_with_cov_+3A_sol">sol</code></td>
<td>
<p>The set of solutions returned by the <code>navigation</code> function</p>
</td></tr>
<tr><td><code id="plot_nav_states_with_cov_+3A_idx">idx</code></td>
<td>
<p>Which Monte-Carlo solution to plot (can be a vector)</p>
</td></tr>
<tr><td><code id="plot_nav_states_with_cov_+3A_cov_idx">cov_idx</code></td>
<td>
<p>Which Monte-Carlo solution to use for confidence intervals</p>
</td></tr>
<tr><td><code id="plot_nav_states_with_cov_+3A_error">error</code></td>
<td>
<p>Wether to plot the error with respect to the refefence or the estimated values</p>
</td></tr>
<tr><td><code id="plot_nav_states_with_cov_+3A_step">step</code></td>
<td>
<p>Plot one time out of <code>step</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the navigation states with the estimated covariance.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned,
 system = "ned")
plot(traj)
timing &lt;- make_timing(
  nav.start = 0, # time at which to begin filtering
  nav.end = 20,
  freq.imu = 100, 
  # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1, # GNSS frequency
  freq.baro = 1, 
  # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 10, 
  # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 15
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) +
  AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) +
  AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 5 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "2",
  # order of the Taylor expansion of the matrix exponential used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10,
  # compute new Phi and Q matrices every n IMU steps (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
)
plot_nav_states_with_cov(res, idx = 1:5, error = TRUE)

</code></pre>

<hr>
<h2 id='plot.coverage.stat'>Plot multiple <code>coverage.stat</code> objects</h2><span id='topic+plot.coverage.stat'></span>

<h3>Description</h3>

<p>plot multiple coverages alltogether
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coverage.stat'
plot(..., legend = NA, title = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.coverage.stat_+3A_...">...</code></td>
<td>
<p>coverage, e.g., computed with <code>compute_coverage</code></p>
</td></tr>
<tr><td><code id="plot.coverage.stat_+3A_legend">legend</code></td>
<td>
<p>Legend of the plot.</p>
</td></tr>
<tr><td><code id="plot.coverage.stat_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the empirical coverage.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned, system = "ned")
plot(traj)
timing &lt;- make_timing(
  nav.start = 0, # time at which to begin filtering
  nav.end = 30,
  freq.imu = 100, # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1, # GNSS frequency
  freq.baro = 1, # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 20, # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 25
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) +
  AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) +
  AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 5 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "2",
  # order of the Taylor expansion of the matrix exponential used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10,
  # compute new Phi and Q matrices every n IMU steps (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
)
# Empirical coverage
coverage &lt;- compute_coverage(res, alpha = 0.7, step = 100, idx = 1:6)
plot(coverage)

</code></pre>

<hr>
<h2 id='plot.navigation'>Plot a <code>navigation</code> object</h2><span id='topic+plot.navigation'></span>

<h3>Description</h3>

<p>This function enables the visualization of a <code>navigation</code> object, both in 2d and in 3d. The function therefore enables
the comparison of the true trajectory with emulated trajectories. One can also plot the analysis of the error of the trajectories
by comparing the <code>L2</code> norm of the difference between emulated trajectories and the true trajectory over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'navigation'
plot(
  x,
  true_col = "#2980b9",
  col_fused_trans = "#EA5D0073",
  col_fused_full = "#EA5D00FF",
  plot_mean_traj = TRUE,
  plot_baro = TRUE,
  baro_col = "black",
  emu_to_plot = 1,
  plot3d = FALSE,
  plot_CI = FALSE,
  time_interval = 5,
  col_50 = "#E74C3C4D",
  col_95 = "#F5B0414D",
  col_50_brd = "#E74C3C",
  col_95_brd = "#F5B041",
  error_analysis = FALSE,
  emu_for_covmat = 1,
  nsim = 1000,
  col_traj_error = "#1C12F54D",
  time_interval_simu = 0.5,
  seed = 123,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.navigation_+3A_x">x</code></td>
<td>
<p>A <code>navigation</code> object</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_true_col">true_col</code></td>
<td>
<p>The color of the true trajectory</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_col_fused_trans">col_fused_trans</code></td>
<td>
<p>The color of the emulated trajectories</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_col_fused_full">col_fused_full</code></td>
<td>
<p>The color of the mean trajectory of the emulated trajectories</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_plot_mean_traj">plot_mean_traj</code></td>
<td>
<p>A Boolean indicating whether or not to plot the mean mean trajectory of the emulated trajectories. Default is <code>True</code></p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_plot_baro">plot_baro</code></td>
<td>
<p>A Boolean indicating whether or not to plot the barometer datapoint in tha Up coordinates plot. Default is <code>True</code></p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_baro_col">baro_col</code></td>
<td>
<p>The color of the barometer datapoints</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_emu_to_plot">emu_to_plot</code></td>
<td>
<p>The emulated trajectory for which to plot confidence ellipses on the North-East coordinates plot</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_plot3d">plot3d</code></td>
<td>
<p>A Boolean indicating whether or not to plot the 3d plot of the trajectory</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_plot_ci">plot_CI</code></td>
<td>
<p>A Boolean indicating whether or not to plot the confidence intervals for both 2d plots</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_time_interval">time_interval</code></td>
<td>
<p>A value in seconds indicating the interval at which to plot the CI on the North-East coordinates plot</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_col_50">col_50</code></td>
<td>
<p>The color for the 50% confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_col_95">col_95</code></td>
<td>
<p>The color for the 95% confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_col_50_brd">col_50_brd</code></td>
<td>
<p>The color for the 50% confidence intervals borders.</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_col_95_brd">col_95_brd</code></td>
<td>
<p>The color for the 95% confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_error_analysis">error_analysis</code></td>
<td>
<p>A Boolean indicating whether or not to display an error analysis plot of the emulated trajectories</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_emu_for_covmat">emu_for_covmat</code></td>
<td>
<p>The emulated trajectory for which to use the var-cov matrix in order to simulate data and compute the CI of the error</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_nsim">nsim</code></td>
<td>
<p>An integer indicating the number of trajectories simulated in order to compute the CI</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_col_traj_error">col_traj_error</code></td>
<td>
<p>The color for the trajectory estimation error</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_time_interval_simu">time_interval_simu</code></td>
<td>
<p>time interval simu</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_seed">seed</code></td>
<td>
<p>A seed for plotting</p>
</td></tr>
<tr><td><code id="plot.navigation_+3A_...">...</code></td>
<td>
<p>additional plotting argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2D or 3D plot of the trajectory with the fused trajectories.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned, system = "ned")
plot(traj)
timing &lt;- make_timing(
  nav.start = 0, # time at which to begin filtering
  nav.end = 20,
  freq.imu = 100, # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1, # GNSS frequency
  freq.baro = 1, # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 5, # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 15
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) +
  AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) +
  AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 1 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "3",
  # order of the Taylor expansion of the matrix exponential used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10,
  # compute new Phi and Q matrices every n IMU steps (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
)
plot(res)
# 3D plot
plot(res, plot3d = TRUE)
plot(res, error_analysis = TRUE)
</code></pre>

<hr>
<h2 id='plot.navigation.stat'>Plot multiple <code>navigation.stat</code> objects</h2><span id='topic+plot.navigation.stat'></span>

<h3>Description</h3>

<p>plot multiple stats alltogether
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'navigation.stat'
plot(..., legend = NA, title = NA, xlim = c(NA, NA), ylim = c(NA, NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.navigation.stat_+3A_...">...</code></td>
<td>
<p>navigation statistics, e.g., computed with <code>compute_mean_position_err</code></p>
</td></tr>
<tr><td><code id="plot.navigation.stat_+3A_legend">legend</code></td>
<td>
<p>The legend</p>
</td></tr>
<tr><td><code id="plot.navigation.stat_+3A_title">title</code></td>
<td>
<p>The title</p>
</td></tr>
<tr><td><code id="plot.navigation.stat_+3A_xlim">xlim</code></td>
<td>
<p>xlim</p>
</td></tr>
<tr><td><code id="plot.navigation.stat_+3A_ylim">ylim</code></td>
<td>
<p>ylim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the position or orientation error.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned, system = "ned")
plot(traj)
timing &lt;- make_timing(
  nav.start = 0, # time at which to begin filtering
  nav.end = 15,
  freq.imu = 100, # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1, # GNSS frequency
  freq.baro = 1, # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 8, # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 13
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) +
  AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) +
  AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 1 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "2",
  # order of the Taylor expansion of the matrix exponential used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10,
  # compute new Phi and Q matrices every n IMU steps (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
)
# Mean orientation error
pe &lt;- compute_mean_position_err(res, step = 25)
plot(pe)

</code></pre>

<hr>
<h2 id='plot.nees.stat'>Plot multiple <code>nees.stat</code> objects</h2><span id='topic+plot.nees.stat'></span>

<h3>Description</h3>

<p>plot multiple <code>nees.stat</code> objects alltogether
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nees.stat'
plot(..., alpha = 0.95, legend = NA, title = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nees.stat_+3A_...">...</code></td>
<td>
<p>NEES, e.g., computed with <code>compute_nees</code></p>
</td></tr>
<tr><td><code id="plot.nees.stat_+3A_alpha">alpha</code></td>
<td>
<p>for the confidence interval plot</p>
</td></tr>
<tr><td><code id="plot.nees.stat_+3A_legend">legend</code></td>
<td>
<p>legend of the plot.</p>
</td></tr>
<tr><td><code id="plot.nees.stat_+3A_title">title</code></td>
<td>
<p>title of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produce a plot of the  Normalized Estimation Error Squared (NEES) for the <code>nees.stat</code> object provided.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lemniscate_traj_ned")
head(lemniscate_traj_ned)
traj &lt;- make_trajectory(data = lemniscate_traj_ned, system = "ned")
plot(traj)
timing &lt;- make_timing(
  nav.start = 0, # time at which to begin filtering
  nav.end = 30,
  freq.imu = 100, # frequency of the IMU, can be slower wrt trajectory frequency
  freq.gps = 1, # GNSS frequency
  freq.baro = 1, # barometer frequency (to disable, put it very low, e.g. 1e-5)
  gps.out.start = 20, # to simulate a GNSS outage, set a time before nav.end
  gps.out.end = 25
)
# create sensor for noise data generation
snsr.mdl &lt;- list()
# this uses a model for noise data generation
acc.mdl &lt;- WN(sigma2 = 5.989778e-05) +
  AR1(phi = 9.982454e-01, sigma2 = 1.848297e-10) +
  AR1(phi = 9.999121e-01, sigma2 = 2.435414e-11) +
  AR1(phi = 9.999998e-01, sigma2 = 1.026718e-12)
gyr.mdl &lt;- WN(sigma2 = 1.503793e-06) +
  AR1(phi = 9.968999e-01, sigma2 = 2.428980e-11) +
  AR1(phi = 9.999001e-01, sigma2 = 1.238142e-12)
snsr.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
# RTK-like GNSS
gps.mdl.pos.hor &lt;- WN(sigma2 = 0.025^2)
gps.mdl.pos.ver &lt;- WN(sigma2 = 0.05^2)
gps.mdl.vel.hor &lt;- WN(sigma2 = 0.01^2)
gps.mdl.vel.ver &lt;- WN(sigma2 = 0.02^2)
snsr.mdl$gps &lt;- make_sensor(
  name = "gps",
  frequency = timing$freq.gps,
  error_model1 = gps.mdl.pos.hor,
  error_model2 = gps.mdl.pos.ver,
  error_model3 = gps.mdl.vel.hor,
  error_model4 = gps.mdl.vel.ver
)
# Barometer
baro.mdl &lt;- WN(sigma2 = 0.5^2)
snsr.mdl$baro &lt;- make_sensor(
  name = "baro",
  frequency = timing$freq.baro,
  error_model1 = baro.mdl
)
# define sensor for Kalmna filter
KF.mdl &lt;- list()
# make IMU sensor
KF.mdl$imu &lt;- make_sensor(
  name = "imu",
  frequency = timing$freq.imu,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
KF.mdl$gps &lt;- snsr.mdl$gps
KF.mdl$baro &lt;- snsr.mdl$baro
# perform navigation simulation
num.runs &lt;- 2 # number of Monte-Carlo simulations
res &lt;- navigation(
  traj.ref = traj,
  timing = timing,
  snsr.mdl = snsr.mdl,
  KF.mdl = KF.mdl,
  num.runs = num.runs,
  noProgressBar = TRUE,
  PhiQ_method = "1",
  # order of the Taylor expansion of the matrix exponential used to compute Phi and Q matrices
  compute_PhiQ_each_n = 10,
  # compute new Phi and Q matrices every n IMU steps (execution time optimization)
  parallel.ncores = 1,
  P_subsampling = timing$freq.imu
)

nees &lt;- compute_nees(res, idx = 1:6, step = 100)
plot(nees)


</code></pre>

<hr>
<h2 id='plot.trajectory'>Plot a <code>trajectory</code> object</h2><span id='topic+plot.trajectory'></span>

<h3>Description</h3>

<p>Plot a <code>trajectory</code> object in 2D or 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trajectory'
plot(
  x,
  threeD = FALSE,
  col = "#2980b9",
  col_start = "#e67e22",
  col_end = "#e67e22",
  pch_points_start = 15,
  pch_points_end = 16,
  cex_points = 1.5,
  add_altitude = TRUE,
  n_split = 6,
  plot_end_points = TRUE,
  add_title = TRUE,
  threeD_line_width = 4,
  threeD_line_color = "#008080",
  threeD_col_grad = FALSE,
  threeD_grad_start = "#008080",
  threeD_grad_end = "#ab53cf",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.trajectory_+3A_x">x</code></td>
<td>
<p>A <code>trajectory</code> object</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_threed">threeD</code></td>
<td>
<p>A <code>boolean</code> indicating whether the plot should be 3D or 2D (default <code>FALSE</code>, 2D).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_col">col</code></td>
<td>
<p>A <code>string</code> corresponding to the color of the line used for 2D trajectory (default <code>"blue4"</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_col_start">col_start</code></td>
<td>
<p>A <code>string</code> corresponding to the color of the point used to denote the beginning of a 2D trajectory (default <code>"green3"</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_col_end">col_end</code></td>
<td>
<p>A <code>string</code> corresponding to the color of the point used to denote the end of a 2D trajectory (default <code>"red2"</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_pch_points_start">pch_points_start</code></td>
<td>
<p>A <code>numeric</code> corresponding to the symbol (pch) of the points used to denote the beginning of a 2D trajectory (default <code>15</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_pch_points_end">pch_points_end</code></td>
<td>
<p>A <code>numeric</code> corresponding to the symbol (pch) of the points used to denote the end of a 2D trajectory (default <code>16</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_cex_points">cex_points</code></td>
<td>
<p>A <code>numeric</code> corresponding to the size (cex) of the points used to denote the beginning and the end of a 2D trajectory (default <code>1.5</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_add_altitude">add_altitude</code></td>
<td>
<p>A <code>boolean</code> to indicate if the altitude should be plotted in 2D trajectory in NED system (default <code>TRUE</code>; altitude is plotted).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_n_split">n_split</code></td>
<td>
<p>A <code>numeric</code> for the number of ticks in 2D plot with altitude profile, if NULL no ticks are added (default = <code>6</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_plot_end_points">plot_end_points</code></td>
<td>
<p>A <code>boolean</code> to indicate if points should be plotted at the beginning and the end of a 2D trajectory (default <code>TRUE</code>; points are plotted).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_add_title">add_title</code></td>
<td>
<p>A <code>boolean</code> or <code>string</code>. If a <code>boolean</code> is used it indicates if a title should be added to 2D trajectory (only active if name of trajectory exist); if a <code>string</code> is used it corresponds to the title (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_threed_line_width">threeD_line_width</code></td>
<td>
<p>A <code>numeric</code> corresponding to the width of the line for a 3D trajectory (default <code>4</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_threed_line_color">threeD_line_color</code></td>
<td>
<p>A <code>string</code> corresponding to the hex color code of the line used for a 3D trajectory (default <code>"#008080"</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_threed_col_grad">threeD_col_grad</code></td>
<td>
<p>A <code>boolean</code> to indicate if a color gradient should be used for a 3D trajectory (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_threed_grad_start">threeD_grad_start</code></td>
<td>
<p>A <code>string</code> corresponding to the hex color code for the start of the gradient (default <code>"#008080"</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_threed_grad_end">threeD_grad_end</code></td>
<td>
<p>A <code>string</code> corresponding to the hex color code for the end of the gradient (default <code>"#ab53cf"</code>).</p>
</td></tr>
<tr><td><code id="plot.trajectory_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trajectory plot.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
set.seed(123)
dat &lt;- cbind(
  seq(from = 0, to = 60 * 60, length.out = n),
  46.204391 * pi / 180 + cumsum(rnorm(n)) / 10^5,
  6.143158 * pi / 180 + cumsum(rnorm(n)) / 10^5,
  375 + cumsum(rnorm(n))
)
traj &lt;- make_trajectory(data = dat, name = "My cool data")
plot(traj)
plot(traj, threeD = TRUE)
plot(traj,
  threeD = TRUE, threeD_line_width = 8,
  threeD_line_color = "#e74c3c"
)
plot(traj,
  threeD = TRUE,
  threeD_col_grad = TRUE
)
plot(traj,
  threeD = TRUE, threeD_col_grad = TRUE,
  threeD_grad_start = "#e74c3c",
  threeD_grad_end = "#d68910"
)

traj &lt;- make_trajectory(data = dat, name = "My cool data", system = "ned")
plot(traj)
plot(traj, col = "orange2", col_start = "pink", col_end = "purple")
plot(traj, pch_points_start = 15, cex_points = 3)
plot(traj, plot_end_points = FALSE)
plot(traj, plot_end_points = FALSE, add_title = FALSE)
</code></pre>

<hr>
<h2 id='print.sensor'>Print a <code>sensor</code> object parameters (name, frequency and error model)</h2><span id='topic+print.sensor'></span>

<h3>Description</h3>

<p>Print method for a <code>sensor</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sensor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sensor_+3A_x">x</code></td>
<td>
<p>A <code>sensor</code> object.</p>
</td></tr>
<tr><td><code id="print.sensor_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print the <code>sensor</code> object name and specifications in the console.
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># IMU:
imu.freq &lt;- 250
acc.mdl &lt;- WN(sigma2 = 1.535466e-04) + RW(gamma2 = 1.619511e-10)
gyr.mdl &lt;- WN(sigma2 = 1.711080e-03) + RW(gamma2 = 1.532765e-13)
imu.mdl &lt;- make_sensor(
  name = "imu",
  frequency = imu.freq,
  error_model1 = acc.mdl,
  error_model2 = gyr.mdl
)
print(imu.mdl)

</code></pre>

<hr>
<h2 id='print.trajectory'>Print trajectory Objects</h2><span id='topic+print.trajectory'></span>

<h3>Description</h3>

<p>Pretty formatting for <code>trajectory</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trajectory'
print(x, obs = 5L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.trajectory_+3A_x">x</code></td>
<td>
<p>A <code>trajectory</code> object.</p>
</td></tr>
<tr><td><code id="print.trajectory_+3A_obs">obs</code></td>
<td>
<p>A <code>integer</code> the specifies how many from the beginning and end of the data set to show.</p>
</td></tr>
<tr><td><code id="print.trajectory_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print <code>trajectory</code> objects.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier, Mehran Khaghani, and Lionel Voirol
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
dat &lt;- cbind(
  seq(from = 0, to = 60 * 60, length.out = n),
  46.204391 * pi / 180 + cumsum(rnorm(n)) / 10^5,
  6.143158 * pi / 180 + cumsum(rnorm(n)) / 10^5,
  375 + cumsum(rnorm(n))
)
traj &lt;- make_trajectory(data = dat, name = "My cool data")
traj
</code></pre>

<hr>
<h2 id='X_ellips2ned'>Transform position from ellipsoidal to NED coordinates</h2><span id='topic+X_ellips2ned'></span>

<h3>Description</h3>

<p>Transform position from ellipsoidal coordinates to a fixed Cartesian NED frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X_ellips2ned(x, x_o = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X_ellips2ned_+3A_x">x</code></td>
<td>
<p>An object of class <code>trajectory</code> in &quot;ellipsoidal&quot; system or a matrix of position data with latitude, longitude, and altitude</p>
</td></tr>
<tr><td><code id="X_ellips2ned_+3A_x_o">x_o</code></td>
<td>
<p>Origin of the fixed Cartesian NED frame expressed in ellipsoidal coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>trajectory</code> in &quot;NED&quot; system or a matrix of position data with x_N, x_E, and x_D, according to the type of input <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(navigation)
data("example_1_traj_ellipsoidal")
traj_ellips &lt;- make_trajectory(example_1_traj_ellipsoidal, system = "ellipsoidal")
plot(traj_ellips)
plot(traj_ellips, threeD = TRUE)
traj_ned &lt;- X_ellips2ned(traj_ellips, x_o = example_1_traj_ellipsoidal[1, -1])
plot(traj_ned)

</code></pre>

<hr>
<h2 id='X_ned2ellips'>Transform position from NED to ellipsoidal coordinates</h2><span id='topic+X_ned2ellips'></span>

<h3>Description</h3>

<p>Transform position from a fixed Cartesian NED frame to ellipsoidal coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X_ned2ellips(x, x_o = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X_ned2ellips_+3A_x">x</code></td>
<td>
<p>An object of class <code>trajectory</code> in &quot;NED&quot; system or a matrix of position data with x_N, x_E, and x_D</p>
</td></tr>
<tr><td><code id="X_ned2ellips_+3A_x_o">x_o</code></td>
<td>
<p>Origin of the fixed Cartesian NED frame expressed in ellipsoidal coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>trajectory</code> in &quot;ellipsoidal&quot; system or a matrix of position data with latitude, longitude, and altitude, according to the type of input <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Davide Cucci, Lionel Voirol, Mehran Khaghani, Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_1_traj_ned")
traj_ned &lt;- make_trajectory(example_1_traj_ned, system = "ned")
plot(traj_ned)
traj_ellips &lt;- X_ned2ellips(traj_ned, x_o = example_1_traj_ellipsoidal[1, -1])
plot(traj_ellips, threeD = FALSE)
plot(traj_ellips, threeD = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
