<!DOCTYPE html><html lang="en"><head><title>Help for package scregclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scregclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#scregclust-package'><p>scregclust: Reconstructing the Regulatory Programs of Target Genes in scRNA-Seq Data</p></a></li>
<li><a href='#alloc_array'><p>Allocate 3d-array and fill with matrix along first dimension</p></a></li>
<li><a href='#available_results'><p>Extract final configurations into a data frame</p></a></li>
<li><a href='#cluster_overlap'><p>Create a table of module overlap for two clusterings</p></a></li>
<li><a href='#coef_nnls'><p>Compute NNLS coefficients</p></a></li>
<li><a href='#coef_ols'><p>Compute OLS coefficients</p></a></li>
<li><a href='#coef_ridge'><p>Compute ridge regression coefficients</p></a></li>
<li><a href='#compute_adjusted_rand_index'><p>Compute Hubert's and Arabie's Adjusted Rand index</p></a></li>
<li><a href='#compute_rand_index'><p>Compute the Rand index</p></a></li>
<li><a href='#coop_lasso'><p>ADMM algorithm for solving the group-penalized least squares problem</p></a></li>
<li><a href='#count_table'><p>Format count table nicely</p></a></li>
<li><a href='#fast_cor'><p>Fast computation of correlation</p></a></li>
<li><a href='#find_module_sizes'><p>Determine module sizes</p></a></li>
<li><a href='#get_avg_num_regulators'><p>Get the average number of active regulators per module</p></a></li>
<li><a href='#get_num_final_configs'><p>Return the number of final configurations</p></a></li>
<li><a href='#get_rand_indices'><p>Compute Rand indices</p></a></li>
<li><a href='#get_regulator_list'><p>Return list of regulator genes</p></a></li>
<li><a href='#get_target_gene_modules'><p>Extract target gene modules for given penalization parameters</p></a></li>
<li><a href='#jaccard_indicator'><p>Compute indicator matrix of pairwise distances smaller than threshold</p></a></li>
<li><a href='#jaccard_indicator_comp'><p>Perform the computations for thresholded Jaccard distance</p></a></li>
<li><a href='#kmeanspp'><p>Perform the k-means++ algorithm</p></a></li>
<li><a href='#kmeanspp_init'><p>Determine initial centers for the kmeans++ algorithm</p></a></li>
<li><a href='#plot_module_count_helper'><p>Plot average silhouette scores and average predictive <code class="reqn">R^2</code></p></a></li>
<li><a href='#plot_regulator_network'><p>Plotting the regulatory table from scregclust as a directed graph</p></a></li>
<li><a href='#plot_silhouettes'><p>Plot individual silhouette scores</p></a></li>
<li><a href='#progstr'><p>Quick'n'dirty progress bar</p></a></li>
<li><a href='#remove_empty_modules'><p>Remove empty modules</p></a></li>
<li><a href='#reset_array'><p>Reset input 3d-array by filling matrix along first dimension</p></a></li>
<li><a href='#scregclust'><p>Uncover gene modules and their regulatory programs from single-cell data</p></a></li>
<li><a href='#scregclust_format'><p>Package data before clustering</p></a></li>
<li><a href='#split_sample'><p>Split Sample</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Reconstructing the Regulatory Programs of Target Genes in
scRNA-Seq Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the scregclust algorithm
  described in Larsson, Held, et al. (2024) &lt;<a href="https://doi.org/10.1038%2Fs41467-024-53954-3">doi:10.1038/s41467-024-53954-3</a>&gt;
  which reconstructs regulatory programs of target genes in scRNA-seq data.
  Target genes are clustered into modules and each module is associated with a linear
  model describing the regulatory program.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, stats, methods, utils, reshape, igraph, graphics,
grid, cli, prettyunits, ggplot2, rlang, Rcpp (&ge; 1.0.8)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), Seurat (&ge; 5.0.0),
glmGamPoi, hdf5r</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://scmethods.github.io/scregclust/">https://scmethods.github.io/scregclust/</a>,
<a href="https://github.com/scmethods/scregclust/">https://github.com/scmethods/scregclust/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/scmethods/scregclust/issues">https://github.com/scmethods/scregclust/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-06 14:06:57 UTC; felixheld</td>
</tr>
<tr>
<td>Author:</td>
<td>Felix Held <a href="https://orcid.org/0000-0002-7679-7752"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Ida Larsson <a href="https://orcid.org/0000-0001-5422-4243"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Sven Nelander <a href="https://orcid.org/0000-0003-1758-1262"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  André Armatowski [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felix Held &lt;felix.held@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-06 14:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='scregclust-package'>scregclust: Reconstructing the Regulatory Programs of Target Genes in scRNA-Seq Data</h2><span id='topic+scregclust-package'></span>

<h3>Description</h3>

<p>Implementation of the scregclust algorithm described in Larsson, Held, et al. (2024) <a href="https://doi.org/10.1038/s41467-024-53954-3">doi:10.1038/s41467-024-53954-3</a> which reconstructs regulatory programs of target genes in scRNA-seq data. Target genes are clustered into modules and each module is associated with a linear model describing the regulatory program.
</p>


<h3>Details</h3>

<p>Computational methods for the scregclust algorithm
</p>


<h3>Author(s)</h3>

<p>Ida Larsson, Felix Held, Sven Nelander
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://scmethods.github.io/scregclust/">https://scmethods.github.io/scregclust/</a>
</p>
</li>
<li> <p><a href="https://github.com/scmethods/scregclust/">https://github.com/scmethods/scregclust/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/scmethods/scregclust/issues">https://github.com/scmethods/scregclust/issues</a>
</p>
</li></ul>


<hr>
<h2 id='alloc_array'>Allocate 3d-array and fill with matrix along first dimension</h2><span id='topic+alloc_array'></span>

<h3>Description</h3>

<p>Allocate 3d-array and fill with matrix along first dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alloc_array(input, n_cl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alloc_array_+3A_input">input</code></td>
<td>
<p>the matrix of size <code style="white-space: pre;">&#8288;n_obs x n_genes&#8288;</code></p>
</td></tr>
<tr><td><code id="alloc_array_+3A_n_cl">n_cl</code></td>
<td>
<p>the size of the three-dimensional array's first dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The allocated and filled array of size <code style="white-space: pre;">&#8288;n_cl x n_obs x n_genes&#8288;</code>
</p>

<hr>
<h2 id='available_results'>Extract final configurations into a data frame</h2><span id='topic+available_results'></span>

<h3>Description</h3>

<p>Extract final configurations into a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_results(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="available_results_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>scregclust</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing penalization parameters and
final configurations for those penalizations.
</p>

<hr>
<h2 id='cluster_overlap'>Create a table of module overlap for two clusterings</h2><span id='topic+cluster_overlap'></span>

<h3>Description</h3>

<p>Compares two clusterings and creates a table of overlap between them.
Module labels do not have to match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_overlap(k1, k2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_overlap_+3A_k1">k1</code></td>
<td>
<p>First clustering</p>
</td></tr>
<tr><td><code id="cluster_overlap_+3A_k2">k2</code></td>
<td>
<p>Second clustering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix showing the module overlap with the labels of <code>k1</code> in
the columns and the labels of <code>k2</code> in the rows.
</p>

<hr>
<h2 id='coef_nnls'>Compute NNLS coefficients</h2><span id='topic+coef_nnls'></span>

<h3>Description</h3>

<p>Computes non-negative least squares coefficients with a matrix
right hand side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_nnls(x, y, eps = 1e-12, max_iter = 1000L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_nnls_+3A_x">x</code></td>
<td>
<p>Coefficient matrix (p x n matrix)</p>
</td></tr>
<tr><td><code id="coef_nnls_+3A_y">y</code></td>
<td>
<p>Right hand side (p x m matrix)</p>
</td></tr>
<tr><td><code id="coef_nnls_+3A_eps">eps</code></td>
<td>
<p>Convergence tolerance</p>
</td></tr>
<tr><td><code id="coef_nnls_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>The estimated coefficient matrix</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>A vector containing the number of iterations needed
for the <code>i</code>-th column in <code>y</code> in the <code>i</code>-th entry.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Duy Khuong Nguyen and Tu Bao Ho. Accelerated anti-lopsided algorithm
for nonnegative least squares. International Journal of Data Science
and Analytics, 3(1):23–34, 2017.
</p>
<p>Adapted from <a href="https://github.com/khuongnd/nnls_antilopsided">https://github.com/khuongnd/nnls_antilopsided</a>
</p>

<hr>
<h2 id='coef_ols'>Compute OLS coefficients</h2><span id='topic+coef_ols'></span>

<h3>Description</h3>

<p>If the design matrix has full column-rank, then use the normal
least squares estimate. Otherwise, use the Moore-Penrose inverse
to compute the least squares estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_ols(y, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_ols_+3A_y">y</code></td>
<td>
<p>Target vector (n x 1)/matrix (n x m)</p>
</td></tr>
<tr><td><code id="coef_ols_+3A_x">x</code></td>
<td>
<p>Design matrix (n x p)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of OLS coefficients
</p>

<hr>
<h2 id='coef_ridge'>Compute ridge regression coefficients</h2><span id='topic+coef_ridge'></span>

<h3>Description</h3>

<p>Compute ridge regression coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_ridge(y, x, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_ridge_+3A_y">y</code></td>
<td>
<p>Target vector (n x 1)/matrix (n x m)</p>
</td></tr>
<tr><td><code id="coef_ridge_+3A_x">x</code></td>
<td>
<p>Design matrix (n x p)</p>
</td></tr>
<tr><td><code id="coef_ridge_+3A_lambda">lambda</code></td>
<td>
<p>Positive parameter for ridge penalty</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of ridge regression coefficients
</p>

<hr>
<h2 id='compute_adjusted_rand_index'>Compute Hubert's and Arabie's Adjusted Rand index</h2><span id='topic+compute_adjusted_rand_index'></span>

<h3>Description</h3>

<p>Compute Hubert's and Arabie's Adjusted Rand index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_adjusted_rand_index(k1, k2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_adjusted_rand_index_+3A_k1">k1</code></td>
<td>
<p>First clustering as vector of integers</p>
</td></tr>
<tr><td><code id="compute_adjusted_rand_index_+3A_k2">k2</code></td>
<td>
<p>Second clustering as vector of integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Adjusted Rand index as a numeric value
</p>


<h3>References</h3>

<p>Lawrence Hubert and Phipps Arabie (1985). &quot;Comparing partitions&quot;.
Journal of Classification. 2 (1): 193–218. DOI:10.1007/BF01908075
</p>

<hr>
<h2 id='compute_rand_index'>Compute the Rand index</h2><span id='topic+compute_rand_index'></span>

<h3>Description</h3>

<p>Compute the Rand index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_rand_index(k1, k2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_rand_index_+3A_k1">k1</code></td>
<td>
<p>First clustering as vector of integers</p>
</td></tr>
<tr><td><code id="compute_rand_index_+3A_k2">k2</code></td>
<td>
<p>Second clustering as vector of integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Rand index as a numeric value
</p>


<h3>References</h3>

<p>W. M. Rand (1971). &quot;Objective criteria for the evaluation of clustering
methods&quot;. Journal of the American Statistical Association 66 (336): 846–850.
DOI:10.2307/2284239
</p>

<hr>
<h2 id='coop_lasso'>ADMM algorithm for solving the group-penalized least squares problem</h2><span id='topic+coop_lasso'></span>

<h3>Description</h3>

<p>Implements estimation of the coop-lasso problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coop_lasso(
  y,
  x,
  lambda,
  weights,
  beta_0 = NULL,
  rho_0 = 0.2,
  alpha_0 = 1.5,
  n_update = 2L,
  eps_corr = 0.2,
  max_iter = 1000L,
  eps_rel = 1e-08,
  eps_abs = 1e-12,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coop_lasso_+3A_y">y</code></td>
<td>
<p>Target (n x m)</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_x">x</code></td>
<td>
<p>Design matrix (n x p)</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_lambda">lambda</code></td>
<td>
<p>Penalization parameter</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_weights">weights</code></td>
<td>
<p>A specific weight for each group (typically this is
<code style="white-space: pre;">&#8288;sqrt(group size)&#8288;</code>).</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_beta_0">beta_0</code></td>
<td>
<p>Initial value for coefficients, allowing for warm start.
Can be set to NULL, which results in the initial <code>beta</code>
being a zero matrix.</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_rho_0">rho_0</code></td>
<td>
<p>Initial ADMM step-size</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_alpha_0">alpha_0</code></td>
<td>
<p>Initial ADMM relaxation parameter</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_n_update">n_update</code></td>
<td>
<p>Number of steps in-between updates of the
step-size/adaptation parameters</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_eps_corr">eps_corr</code></td>
<td>
<p>Lower bound for the correlation in the step-size
update steps</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_eps_rel">eps_rel</code></td>
<td>
<p>Relative tolerance for convergence check</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_eps_abs">eps_abs</code></td>
<td>
<p>Absolute tolerance for convergence check</p>
</td></tr>
<tr><td><code id="coop_lasso_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not information about the optimization process
should be printed to the terminal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>The coefficients at convergence</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
</table>


<h3>References</h3>

<p>Xu et al. (2017) Adaptive relaxed ADMM: Convergence theory and
practical implementation. DOI 10.1109/CVPR.2017.765
</p>

<hr>
<h2 id='count_table'>Format count table nicely</h2><span id='topic+count_table'></span>

<h3>Description</h3>

<p>Format count table nicely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_table(counts, title, row_names, col_width = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_table_+3A_counts">counts</code></td>
<td>
<p>a list of count vectors with <code>1 + n_cl</code> entries each.
<code>NA</code> values are replaced with <code>-</code></p>
</td></tr>
<tr><td><code id="count_table_+3A_title">title</code></td>
<td>
<p>title above the table</p>
</td></tr>
<tr><td><code id="count_table_+3A_row_names">row_names</code></td>
<td>
<p>a vector of row names, one for each count vector</p>
</td></tr>
<tr><td><code id="count_table_+3A_col_width">col_width</code></td>
<td>
<p>minimum width for columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string formatted as a table
</p>

<hr>
<h2 id='fast_cor'>Fast computation of correlation</h2><span id='topic+fast_cor'></span>

<h3>Description</h3>

<p>This uses a more memory-intensive but much faster algorithm than
the built-in <code>cor</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_cor(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_cor_+3A_x">x</code></td>
<td>
<p>first input matrix</p>
</td></tr>
<tr><td><code id="fast_cor_+3A_y">y</code></td>
<td>
<p>second input matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the correlation between the columns of <code>x</code> and <code>y</code>.
</p>


<h3>Value</h3>

<p>Correlations matrix between the columns of <code>x</code> and <code>y</code>
</p>

<hr>
<h2 id='find_module_sizes'>Determine module sizes</h2><span id='topic+find_module_sizes'></span>

<h3>Description</h3>

<p>Determine module sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_module_sizes(module, n_modules)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_module_sizes_+3A_module">module</code></td>
<td>
<p>Vector of module indices</p>
</td></tr>
<tr><td><code id="find_module_sizes_+3A_n_modules">n_modules</code></td>
<td>
<p>Total number of modules</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector containing the name of the module (its index or
<code>"Noise"</code>) and the number of elements in that module
</p>

<hr>
<h2 id='get_avg_num_regulators'>Get the average number of active regulators per module</h2><span id='topic+get_avg_num_regulators'></span>

<h3>Description</h3>

<p>Get the average number of active regulators per module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_avg_num_regulators(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_avg_num_regulators_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>scRegClust</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the average number of active regulators
per module for each penalization parameter.
</p>

<hr>
<h2 id='get_num_final_configs'>Return the number of final configurations</h2><span id='topic+get_num_final_configs'></span>

<h3>Description</h3>

<p>Returns the number of final configurations per penalization parameter in an
scRegClust object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_num_final_configs(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_num_final_configs_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>scRegClust</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector containing the number of final configurations
for each penalization parameter.
</p>

<hr>
<h2 id='get_rand_indices'>Compute Rand indices</h2><span id='topic+get_rand_indices'></span>

<h3>Description</h3>

<p>Compute Rand indices for fitted scregclust object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rand_indices(fit, groundtruth, adjusted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_rand_indices_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>scregclust</code></p>
</td></tr>
<tr><td><code id="get_rand_indices_+3A_groundtruth">groundtruth</code></td>
<td>
<p>A known clustering of the target genes (integer vector)</p>
</td></tr>
<tr><td><code id="get_rand_indices_+3A_adjusted">adjusted</code></td>
<td>
<p>If TRUE, the Adjusted Rand index is computed. Otherwise the
ordinary Rand index is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the Rand indices. Since there can
be more than one final configuration for some penalization
parameters, Rand indices are averaged for each fixed penalization
parameter. Returned are the mean, standard deviation and number
of final configurations that were averaged.
</p>


<h3>References</h3>

<p>W. M. Rand (1971). &quot;Objective criteria for the evaluation of clustering
methods&quot;. Journal of the American Statistical Association 66 (336): 846–850.
DOI:10.2307/2284239
</p>
<p>Lawrence Hubert and Phipps Arabie (1985). &quot;Comparing partitions&quot;.
Journal of Classification. 2 (1): 193–218. DOI:10.1007/BF01908075
</p>

<hr>
<h2 id='get_regulator_list'>Return list of regulator genes</h2><span id='topic+get_regulator_list'></span>

<h3>Description</h3>

<p>Return list of regulator genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regulator_list(mode = c("TF", "kinase"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_regulator_list_+3A_mode">mode</code></td>
<td>
<p>Determines which genes are considered to be regulators.
Currently supports TF=transcription factors and kinases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of gene symbols
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scregclust_format">scregclust_format()</a></code>
</p>

<hr>
<h2 id='get_target_gene_modules'>Extract target gene modules for given penalization parameters</h2><span id='topic+get_target_gene_modules'></span>

<h3>Description</h3>

<p>Extract target gene modules for given penalization parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_target_gene_modules(fit, penalization = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_target_gene_modules_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>scregclust</code></p>
</td></tr>
<tr><td><code id="get_target_gene_modules_+3A_penalization">penalization</code></td>
<td>
<p>A numeric vector of penalization parameters.
The penalization parameters specified here must have
been used used during fitting of the <code>fit</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists of final target modules. One list for each
parameter in <code>penalization</code>. The lists contain the modules of
target genes for each final configuration.
</p>

<hr>
<h2 id='jaccard_indicator'>Compute indicator matrix of pairwise distances smaller than threshold</h2><span id='topic+jaccard_indicator'></span>

<h3>Description</h3>

<p>Computes the Jaccard distance between rows of a matrix and returns a
sparse symmetric indicator matrix containing the entries with a distance
of less than a given upper bound. Note that the diagonal is always 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard_indicator(x, upper_bnd = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jaccard_indicator_+3A_x">x</code></td>
<td>
<p>the input matrix with vectors to be compared in the rows.</p>
</td></tr>
<tr><td><code id="jaccard_indicator_+3A_upper_bnd">upper_bnd</code></td>
<td>
<p>pairs with a Jaccard distance below this upper bound are
returned as 1 while all others receive the entry 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors describing a sparse lower triangular pattern matrix
</p>
<table role = "presentation">
<tr><td><code>i</code></td>
<td>
<p>Row indices</p>
</td></tr>
<tr><td><code>j</code></td>
<td>
<p>Column indices</p>
</td></tr>
</table>

<hr>
<h2 id='jaccard_indicator_comp'>Perform the computations for thresholded Jaccard distance</h2><span id='topic+jaccard_indicator_comp'></span>

<h3>Description</h3>

<p>Perform the computations for thresholded Jaccard distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard_indicator_comp(gs, eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jaccard_indicator_comp_+3A_gs">gs</code></td>
<td>
<p>a list of integer vectors, one for each row, giving the column
indices of the non-zero elements of the row or <code>NULL</code> if the
whole row is empty.</p>
</td></tr>
<tr><td><code id="jaccard_indicator_comp_+3A_eps">eps</code></td>
<td>
<p>an upper bound on the Jaccard distance (<code>1 - eps</code> becomes a
lower bound on the Jaccard similarity)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is optimized for sparse matrices and computes the pairwise
Jaccard distances between the rows of the input matrix. Note that the
actual distance is not saved. Instead, a threshold (<code>eps</code>) is supplied
and an indicator matrix is returned, with a one indicating that the
distance is smaller than <code>eps</code> (equivalently, the Jaccard similarity
is larger than <code>1 - eps</code>).
</p>


<h3>Value</h3>

<p>A list with row and column indices in the #row x #row indicator
matrix specifying which rows in the original matrix had a distance
of at most <code>eps</code>.
</p>

<hr>
<h2 id='kmeanspp'>Perform the k-means++ algorithm</h2><span id='topic+kmeanspp'></span>

<h3>Description</h3>

<p>Performs the k-means++ algorithm to cluster the rows of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeanspp(x, n_cluster, n_init_clusterings = 10L, n_max_iter = 10L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmeanspp_+3A_x">x</code></td>
<td>
<p>Input matrix (n x p)</p>
</td></tr>
<tr><td><code id="kmeanspp_+3A_n_cluster">n_cluster</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code id="kmeanspp_+3A_n_init_clusterings">n_init_clusterings</code></td>
<td>
<p>Number of repeated random initializations
to perform</p>
</td></tr>
<tr><td><code id="kmeanspp_+3A_n_max_iter">n_max_iter</code></td>
<td>
<p>Number of maximum iterations to perform in the k-means
algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation is repeated
</p>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+kmeans">stats::kmeans</a></code>.
</p>


<h3>References</h3>

<p>David Arthur and Sergei Vassilvitskii. K-Means++: The advantages
of careful seeding. In Proceedings of the Eighteenth Annual ACM-SIAM
Symposium on Discrete Algorithms, SODA '07, pages 1027––1035.
Society for Industrial and Applied Mathematics, 2007.
</p>

<hr>
<h2 id='kmeanspp_init'>Determine initial centers for the kmeans++ algorithm</h2><span id='topic+kmeanspp_init'></span>

<h3>Description</h3>

<p>Determine initial centers for the kmeans++ algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeanspp_init(n_cluster, x = NULL, dm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmeanspp_init_+3A_x">x</code></td>
<td>
<p>data matrix to be clustered</p>
</td></tr>
<tr><td><code id="kmeanspp_init_+3A_dm">dm</code></td>
<td>
<p>distance matrix (between rows of x; of class &quot;dist&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Row indices of initial cluster centers of x
</p>

<hr>
<h2 id='plot_module_count_helper'>Plot average silhouette scores and average predictive <code class="reqn">R^2</code></h2><span id='topic+plot_module_count_helper'></span>

<h3>Description</h3>

<p>Plot average silhouette scores and average predictive <code class="reqn">R^2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_module_count_helper(list_of_fits, penalization)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_module_count_helper_+3A_list_of_fits">list_of_fits</code></td>
<td>
<p>A list of <code>scregclust</code> objects each fit to the same
dataset across a variety of module counts (varying
<code>n_modules</code> while running <code><a href="#topic+scregclust">scregclust</a></code>).</p>
</td></tr>
<tr><td><code id="plot_module_count_helper_+3A_penalization">penalization</code></td>
<td>
<p>Either a single numeric value requesting the results
for the same penalty parameter across all fits in
<code>list_of_fits</code>, or one for each individual fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot showing the average silhouette score and the
average predictive <code class="reqn">R^2</code>
</p>

<hr>
<h2 id='plot_regulator_network'>Plotting the regulatory table from scregclust as a directed graph</h2><span id='topic+plot_regulator_network'></span>

<h3>Description</h3>

<p>Plotting the regulatory table from scregclust as a directed graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_regulator_network(
  output,
  arrow_size = 0.3,
  edge_scaling = 30,
  no_links = 6,
  col = c("gray80", "#FC7165", "#BD828C", "#9D8A9F", "#7D92B2", "#BDA88C", "#FCBD65",
    "#F2BB90", "#E7B9BA", "#BDB69C", "#92B27D", "#9B8BA5", "#9D7DB2", "#94A5BF")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_regulator_network_+3A_output">output</code></td>
<td>
<p>Object of type <code>scregclust_output</code> from a fit of the
scregclust algorithm.</p>
</td></tr>
<tr><td><code id="plot_regulator_network_+3A_arrow_size">arrow_size</code></td>
<td>
<p>Size of arrow head</p>
</td></tr>
<tr><td><code id="plot_regulator_network_+3A_edge_scaling">edge_scaling</code></td>
<td>
<p>Scaling factor for edge width</p>
</td></tr>
<tr><td><code id="plot_regulator_network_+3A_no_links">no_links</code></td>
<td>
<p>Threshold value (0-10) for number of edges to show,
higher value = more stringent threshold = less edges</p>
</td></tr>
<tr><td><code id="plot_regulator_network_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graph with gene modules and regulators as nodes
</p>

<hr>
<h2 id='plot_silhouettes'>Plot individual silhouette scores</h2><span id='topic+plot_silhouettes'></span>

<h3>Description</h3>

<p>Plot individual silhouette scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_silhouettes(list_of_fits, penalization, final_config = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_silhouettes_+3A_list_of_fits">list_of_fits</code></td>
<td>
<p>A list of <code>scregclust</code> objects each fit to the same
dataset across a variety of module counts (varying
<code>n_modules</code> when running <code><a href="#topic+scregclust">scregclust</a></code>).</p>
</td></tr>
<tr><td><code id="plot_silhouettes_+3A_penalization">penalization</code></td>
<td>
<p>Either a single numeric value requesting the results
for the same penalty parameter across all fits in
<code>list_of_fits</code>, or one for each individual fit.</p>
</td></tr>
<tr><td><code id="plot_silhouettes_+3A_final_config">final_config</code></td>
<td>
<p>The final configuration that should be visualized.
Either a single number to be used for all fits in
<code>list_of_fits</code>, or one for each individual fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot showing the the silhouette scores for each
supplied fit.
</p>

<hr>
<h2 id='progstr'>Quick'n'dirty progress bar</h2><span id='topic+progstr'></span>

<h3>Description</h3>

<p>Creates a progress bar and returns it as a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progstr(step, n_steps, name, finished = FALSE, progress_length = 20L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="progstr_+3A_step">step</code></td>
<td>
<p>current step being worked on</p>
</td></tr>
<tr><td><code id="progstr_+3A_n_steps">n_steps</code></td>
<td>
<p>total number of steps</p>
</td></tr>
<tr><td><code id="progstr_+3A_name">name</code></td>
<td>
<p>name of the process</p>
</td></tr>
<tr><td><code id="progstr_+3A_finished">finished</code></td>
<td>
<p>whether the process is finished</p>
</td></tr>
<tr><td><code id="progstr_+3A_progress_length">progress_length</code></td>
<td>
<p>length of the progress bar in ascii signs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string formatted as a progress bar
</p>

<hr>
<h2 id='remove_empty_modules'>Remove empty modules</h2><span id='topic+remove_empty_modules'></span>

<h3>Description</h3>

<p>Remove empty modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_empty_modules(module)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_empty_modules_+3A_module">module</code></td>
<td>
<p>Vector of module indices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only iterates through modules with positive index, leaving the noise
module untouched.
</p>


<h3>Value</h3>

<p>The updated vector of module indices with empty modules removed.
</p>

<hr>
<h2 id='reset_array'>Reset input 3d-array by filling matrix along first dimension</h2><span id='topic+reset_array'></span>

<h3>Description</h3>

<p>Reset input 3d-array by filling matrix along first dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_array(arr, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reset_array_+3A_arr">arr</code></td>
<td>
<p>The 3d-array of dimension <code style="white-space: pre;">&#8288;n_cl x n_obs x n_genes&#8288;</code></p>
</td></tr>
<tr><td><code id="reset_array_+3A_input">input</code></td>
<td>
<p>The matrix of size <code style="white-space: pre;">&#8288;n_obs x n_genes&#8288;</code></p>
</td></tr>
</table>

<hr>
<h2 id='scregclust'>Uncover gene modules and their regulatory programs from single-cell data</h2><span id='topic+scregclust'></span>

<h3>Description</h3>

<p>Use the scRegClust algorithm to determine gene modules and their
regulatory programs from single-cell data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scregclust(
  expression,
  genesymbols,
  is_regulator,
  penalization,
  n_modules,
  initial_target_modules = NULL,
  sample_assignment = NULL,
  center = TRUE,
  split1_proportion = 0.5,
  total_proportion = 1,
  split_indices = NULL,
  prior_indicator = NULL,
  prior_genesymbols = NULL,
  prior_baseline = 1e-06,
  prior_weight = 0.5,
  min_module_size = 0L,
  allocate_per_obs = TRUE,
  noise_threshold = 0.025,
  n_cycles = 50L,
  use_kmeanspp_init = TRUE,
  n_initializations = 50L,
  max_optim_iter = 10000L,
  tol_coop_rel = 1e-08,
  tol_coop_abs = 1e-12,
  tol_nnls = 1e-04,
  compute_predictive_r2 = TRUE,
  compute_silhouette = FALSE,
  nowarnings = FALSE,
  verbose = TRUE,
  quick_mode = FALSE,
  quick_mode_percent = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scregclust_+3A_expression">expression</code></td>
<td>
<p><code style="white-space: pre;">&#8288;p x n&#8288;</code> matrix of pre-processed single cell expression
data with <code>p</code> rows of genes and <code>n</code> columns of cells.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_genesymbols">genesymbols</code></td>
<td>
<p>A vector of gene names corresponding to rows of
<code>expression</code>. Has to be of length <code>p</code>.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_is_regulator">is_regulator</code></td>
<td>
<p>An indicator vector where <code>1</code> indicates that the
corresponding row in <code>expression</code> is a candidate
regulator. All other rows represent target genes.
Has to be of length <code>p</code>.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_penalization">penalization</code></td>
<td>
<p>Sparsity penalty related to the amount of regulators
associated with each module. Either a single positive
number or a vector of positive numbers.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_n_modules">n_modules</code></td>
<td>
<p>Requested number of modules (integer).
If this is provided without specifying <code>initial_target_modules</code>,
then an initial module allocation is performed on the
cross-correlation matrix of targets and genes on the first
dataset after data splitting.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_initial_target_modules">initial_target_modules</code></td>
<td>
<p>The initial assignment of target genes to
modules of length <code>sum(is_regulator == 0L)</code>.
If this is not specified, then see <code>n_modules</code> regarding
module initialization. If provided, <code>use_kmeanspp_init</code>
and <code>n_initializations</code> are ignored.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_sample_assignment">sample_assignment</code></td>
<td>
<p>A vector of sample assignment for each cell, can
be used to perform the data splitting with
stratification. Has to be of length <code>n</code>.
No stratification if <code>NULL</code> is supplied.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_center">center</code></td>
<td>
<p>Whether or not genes should be centered within each subgroup
defined in <code>sample_assignment</code>.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_split1_proportion">split1_proportion</code></td>
<td>
<p>The proportion to use for the first dataset during
data splitting. The proportion for the second
dataset is <code>1 - split1_proportion</code>. If stratification
with <code>sample_assignment</code> is used, then the proportion
of each strata is controlled.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_total_proportion">total_proportion</code></td>
<td>
<p>Can be used to only use a proportion of the supplied
observations. The proportion of the first dataset
during data splitting in relation to the full
dataset will be
<code>total_proportion * split1_proportion</code>.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_split_indices">split_indices</code></td>
<td>
<p>Can be used to provide an explicit data split. If this
is supplied then <code>split1_proportion</code>, and
<code>total_proportion</code> are ignored.
Note that if <code>sample_assigment</code> is provided and
<code>center == TRUE</code>, then subgroup centering will be
performed as in the case of random splitting.
A vector of length <code>n</code> containing entries 1 for cells
in the first data split, 2 for cells in the second
data split and <code>NA</code> for cells that should be excluded
from the computations.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_prior_indicator">prior_indicator</code></td>
<td>
<p>An indicator matrix (sparse or dense) of size <code style="white-space: pre;">&#8288;q x q&#8288;</code>
that indicates whether there is a known functional
relationship between two genes. Ideally, this is
supplied as a sparse matrix (<code>sparseMatrix</code>
in the <code>Matrix</code> package). If not, then the matrix
is converted to one.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_prior_genesymbols">prior_genesymbols</code></td>
<td>
<p>A vector of gene names of length q corresponding
to the rows/columns in <code>prior_indicator</code>. Does not
have to be the same as <code>genesymbols</code>, but only
useful if there is overlap.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_prior_baseline">prior_baseline</code></td>
<td>
<p>A positive baseline for the network prior. The larger
this parameter is, the less impact the network prior
will have.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_prior_weight">prior_weight</code></td>
<td>
<p>A number between 0 and 1 indicating the strength of the
prior in relation to the data. 0 ignores the prior and
makes the algorithm completely data-driven. 1 uses only
the prior during module allocation.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_min_module_size">min_module_size</code></td>
<td>
<p>Minimum required size of target genes in a module.
Smaller modules are emptied.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_allocate_per_obs">allocate_per_obs</code></td>
<td>
<p>Whether module allocation should be performed for
each observation in the second data split separately.
If <code>FALSE</code>, target genes are allocated into modules
on the aggregate sum of squares across all
observations in the second data split.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_noise_threshold">noise_threshold</code></td>
<td>
<p>Threshold for the best <code class="reqn">R^2</code> of a target gene
before it gets identified as noise.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_n_cycles">n_cycles</code></td>
<td>
<p>Number of maximum algorithmic cycles.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_use_kmeanspp_init">use_kmeanspp_init</code></td>
<td>
<p>Use kmeans++ for module initialization if
<code>initial_target_modules</code> is a single integer;
otherwise use kmeans with random initial cluster
centers</p>
</td></tr>
<tr><td><code id="scregclust_+3A_n_initializations">n_initializations</code></td>
<td>
<p>Number of kmeans(++) initialization runs.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_max_optim_iter">max_optim_iter</code></td>
<td>
<p>Maximum number of iterations during optimization
in the coop-Lasso and NNLS steps.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_tol_coop_rel">tol_coop_rel</code></td>
<td>
<p>Relative convergence tolerance during optimization
in the coop-Lasso step.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_tol_coop_abs">tol_coop_abs</code></td>
<td>
<p>Absolute convergence tolerance during optimization
in the coop-Lasso step.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_tol_nnls">tol_nnls</code></td>
<td>
<p>Convergence tolerance during optimization in the NNLS step.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_compute_predictive_r2">compute_predictive_r2</code></td>
<td>
<p>Whether to compute predictive <code class="reqn">R^2</code> per
module as well as regulator importance.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_compute_silhouette">compute_silhouette</code></td>
<td>
<p>Whether to compute silhouette scores for each
target gene.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_nowarnings">nowarnings</code></td>
<td>
<p>When turned on then no warning messages are shown.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print progress.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_quick_mode">quick_mode</code></td>
<td>
<p>Whether to use a reduced number of noise targets to speed
up computations.</p>
</td></tr>
<tr><td><code id="scregclust_+3A_quick_mode_percent">quick_mode_percent</code></td>
<td>
<p>A number in [0, 1) indicating the amount of
noise targets to use in the re-allocation process
if <code>quick_mode = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with S3 class <code>scregclust</code> containing
</p>
<table role = "presentation">
<tr><td><code>penalization</code></td>
<td>
<p>The supplied <code>penalization</code> parameters</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>A list of result lists (each with S3 class
<code>scregclust_result</code>), one for each supplied <code>penalization</code>
parameter. See below.</p>
</td></tr>
<tr><td><code>initial_target_modules</code></td>
<td>
<p>Initial allocation of target genes into
modules.</p>
</td></tr>
<tr><td><code>split_indices</code></td>
<td>
<p>either verbatim the vector given as input or
a vector encoding the splits as NA = not included,
1 = split 1 or 2 = split 2. Allows reproducibility
of data splits.</p>
</td></tr>
</table>
<p>For each supplied penalization parameter, <code>results</code> contains a list with
</p>

<ul>
<li><p> the current <code>penalization</code> parameter,
</p>
</li>
<li><p> the supplied <code>genesymbols</code> after filtering (as used during fitting),
</p>
</li>
<li><p> the supplied <code>is_regulator</code> vector after filtering (as used during
fitting),
</p>
</li>
<li><p> the number of fitted modules <code>n_modules</code>,
</p>
</li>
<li><p> whether the current run <code>converged</code> to a single configuration (as a
boolean),
</p>
</li>
<li><p> as well as an <code>output</code> object containing the numeric results for each
final configuration.
</p>
</li></ul>

<p>It is possible that the algorithm ends in a finite cycle of configurations
instead of a unique final configuration.
Therefore, <code>output</code> is a list with each element itself being a list
with the following contents:
</p>

<dl>
<dt><code>reg_table</code></dt><dd><p>a regulator table, a matrix of weights for each
regulator and module</p>
</dd>
<dt><code>module</code></dt><dd><p>vector of same length as <code>genesymbols</code> containing the
module assignments for all genes with regulators
marked as <code>NA</code>. Genes considered noise are marked as <code>-1</code>.</p>
</dd>
<dt><code>module_all</code></dt><dd><p>same as <code>module</code>, however, genes that were marked as
noise (-1 in <code>module</code>) are assigned to the
module in which it has the largest <code class="reqn">R^2</code>,
even if it is below <code>noise_threshold</code>.</p>
</dd>
<dt><code>r2</code></dt><dd><p>matrix of predictive <code class="reqn">R^2</code> value for each target gene and
module</p>
</dd>
<dt><code>best_r2</code></dt><dd><p>vector of best predictive <code class="reqn">R^2</code> for each gene
(regulators marked with NA)</p>
</dd>
<dt><code>best_r2_idx</code></dt><dd><p>module index corresponding to best predictive
<code class="reqn">R^2</code> for each gene (regulators marked with NA)</p>
</dd>
<dt><code>r2_module</code></dt><dd><p>a vector of predictive <code class="reqn">R^2</code> values for each
module (included if <code>compute_predictive_r2 == TRUE</code>)</p>
</dd>
<dt><code>importance</code></dt><dd><p>a matrix of importance values for each regulator (rows)
and module (columns) (included if
<code>compute_predictive_r2 == TRUE</code>)</p>
</dd>
<dt><code>r2_cross_module_per_target</code></dt><dd><p>a matrix of cross module <code class="reqn">R^2</code>
values for each target gene (rows)
and each module (columns) (included
if <code>compute_silhouette == TRUE</code>)</p>
</dd>
<dt><code>silhouette</code></dt><dd><p>a vector of silhouette scores for each target gene
(included if <code>compute_silhouette == TRUE</code>)</p>
</dd>
<dt><code>models</code></dt><dd><p>regulator selection for each module as a matrix with
regulators in rows and modules in columns</p>
</dd>
<dt><code>signs</code></dt><dd><p>regulator signs for each module as a matrix with
regulators in rows and modules in columns</p>
</dd>
<dt><code>weights</code></dt><dd><p>average regulator coefficient for each module</p>
</dd>
<dt><code>coeffs</code></dt><dd><p>list of regulator coefficient matrices for each module
for all target genes as re-estimated in the NNLS step</p>
</dd>
<dt><code>sigmas</code></dt><dd><p>matrix of residual variances, one per target gene
in each module; derived from the residuals in NNLS step</p>
</dd>
</dl>


<hr>
<h2 id='scregclust_format'>Package data before clustering</h2><span id='topic+scregclust_format'></span>

<h3>Description</h3>

<p>Package data before clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scregclust_format(expression_matrix, mode = c("TF", "kinase"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scregclust_format_+3A_expression_matrix">expression_matrix</code></td>
<td>
<p>The p x n gene expression matrix with gene symbols
as rownames.</p>
</td></tr>
<tr><td><code id="scregclust_format_+3A_mode">mode</code></td>
<td>
<p>Determines which genes are considered to be regulators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with
</p>
<table role = "presentation">
<tr><td><code>genesymbols</code></td>
<td>
<p>The gene symbols extracted from the expression matrix</p>
</td></tr>
<tr><td><code>sample_assignment</code></td>
<td>
<p>A vector filled with <code>1</code>'s of the same length as
there are columns in the gene expression matrix.</p>
</td></tr>
<tr><td><code>is_regulator</code></td>
<td>
<p>Whether a gene is considered to be a regulator or not,
determined dependent on <code>mode</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get_regulator_list">get_regulator_list()</a></code>
</p>

<hr>
<h2 id='split_sample'>Split Sample</h2><span id='topic+split_sample'></span>

<h3>Description</h3>

<p>Splits sample in train and test set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_sample(
  z,
  stratification,
  is_regulator,
  split_indices,
  split1_proportion,
  total_proportion,
  center
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_sample_+3A_z">z</code></td>
<td>
<p>matrix of single cell data with rows as genes and columns as cells.</p>
</td></tr>
<tr><td><code id="split_sample_+3A_stratification">stratification</code></td>
<td>
<p>a vector by which the sampling will be stratified
of length <code>ncol(z)</code></p>
</td></tr>
<tr><td><code id="split_sample_+3A_is_regulator">is_regulator</code></td>
<td>
<p>an indicator vector, telling which rows in <code>z</code> are
candidate regulators</p>
</td></tr>
<tr><td><code id="split_sample_+3A_split_indices">split_indices</code></td>
<td>
<p>a vector of given split indices. can be <code>NULL</code></p>
</td></tr>
<tr><td><code id="split_sample_+3A_split1_proportion">split1_proportion</code></td>
<td>
<p>proportion to include in first data split</p>
</td></tr>
<tr><td><code id="split_sample_+3A_total_proportion">total_proportion</code></td>
<td>
<p>proportion of data to include overall in splitting</p>
</td></tr>
<tr><td><code id="split_sample_+3A_center">center</code></td>
<td>
<p>TRUE if data should be row-centered. Set to FALSE otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table role = "presentation">
<tr><td><code>z1_reg</code></td>
<td>
<p>first data split, TF-part</p>
</td></tr>
<tr><td><code>z2_reg</code></td>
<td>
<p>second data split, TF-part</p>
</td></tr>
<tr><td><code>z1_target</code></td>
<td>
<p>first data split, non-TF part</p>
</td></tr>
<tr><td><code>z2_target</code></td>
<td>
<p>second data split, non-TF part</p>
</td></tr>
<tr><td><code>split_indices</code></td>
<td>
<p>either verbatim the vector given as input or
a vector encoding the splits as NA = not included,
1 = split 1 or 2 = split 2. Allows reproducibility
of data splits.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
