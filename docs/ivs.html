<!DOCTYPE html><html lang="en"><head><title>Help for package ivs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ivs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ivs-package'><p>ivs: Interval Vectors</p></a></li>
<li><a href='#allen-relation-count'><p>Count relations from Allen's Interval Algebra</p></a></li>
<li><a href='#allen-relation-detect'><p>Detect relations from Allen's Interval Algebra</p></a></li>
<li><a href='#allen-relation-detect-pairwise'><p>Pairwise detect relations from Allen's Interval Algebra</p></a></li>
<li><a href='#allen-relation-locate'><p>Locate relations from Allen's Interval Algebra</p></a></li>
<li><a href='#is_iv'><p>Is <code>x</code> an iv?</p></a></li>
<li><a href='#iv'><p>Create an interval vector</p></a></li>
<li><a href='#iv_align'><p>Align after locating relationships</p></a></li>
<li><a href='#iv_diff'><p>Diff a vector to create an interval vector</p></a></li>
<li><a href='#iv_format'><p>Formatting</p></a></li>
<li><a href='#iv_pairwise_span'><p>Pairwise span</p></a></li>
<li><a href='#iv_span'><p>Span</p></a></li>
<li><a href='#iv-accessors'><p>Access the start or end of an interval vector</p></a></li>
<li><a href='#iv-containers'><p>Containers</p></a></li>
<li><a href='#iv-genericity'><p>Proxy and restore</p></a></li>
<li><a href='#iv-groups'><p>Group overlapping intervals</p></a></li>
<li><a href='#iv-set-pairwise'><p>Pairwise set operations</p></a></li>
<li><a href='#iv-set-pairwise-deprecated'><p>Pairwise set operations</p></a></li>
<li><a href='#iv-sets'><p>Set operations</p></a></li>
<li><a href='#iv-sets-deprecated'><p>Set operations</p></a></li>
<li><a href='#iv-splits'><p>Splits</p></a></li>
<li><a href='#new_iv'><p>Construct a new iv</p></a></li>
<li><a href='#relation-count'><p>Count relationships between two ivs</p></a></li>
<li><a href='#relation-detect'><p>Detect a relationship between two ivs</p></a></li>
<li><a href='#relation-detect-pairwise'><p>Pairwise detect a relationship between two ivs</p></a></li>
<li><a href='#relation-locate'><p>Locate relationships between two ivs</p></a></li>
<li><a href='#vector-count'><p>Count relationships between a vector and an iv</p></a></li>
<li><a href='#vector-detect'><p>Detect relationships between a vector and an iv</p></a></li>
<li><a href='#vector-detect-pairwise'><p>Pairwise detect relationships between a vector and an iv</p></a></li>
<li><a href='#vector-locate'><p>Locate relationships between a vector and an iv</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Interval Vectors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a library for generic interval manipulations using a
    new interval vector class. Capabilities include: locating various
    kinds of relationships between two interval vectors, merging overlaps
    within a single interval vector, splitting an interval vector on its
    overlapping endpoints, and applying set theoretical operations on
    interval vectors. Many of the operations in this package were inspired
    by James Allen's interval algebra, Allen (1983)
    &lt;<a href="https://doi.org/10.1145%2F182.358434">doi:10.1145/182.358434</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DavisVaughan/ivs">https://github.com/DavisVaughan/ivs</a>,
<a href="https://davisvaughan.github.io/ivs/">https://davisvaughan.github.io/ivs/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DavisVaughan/ivs/issues">https://github.com/DavisVaughan/ivs/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glue (&ge; 1.6.2), lifecycle (&ge; 1.0.3), rlang (&ge; 1.1.0), vctrs
(&ge; 0.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64 (&ge; 4.0.5), clock (&ge; 0.6.0), covr, dplyr (&ge; 1.1.0),
knitr, rmarkdown, testthat (&ge; 3.0.0), tidyr (&ge; 1.1.4)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-17 01:30:55 UTC; davis</td>
</tr>
<tr>
<td>Author:</td>
<td>Davis Vaughan [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Davis Vaughan &lt;davis@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-17 11:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ivs-package'>ivs: Interval Vectors</h2><span id='topic+ivs'></span><span id='topic+ivs-package'></span>

<h3>Description</h3>

<p>Provides a library for generic interval manipulations using a new interval vector class. Capabilities include: locating various kinds of relationships between two interval vectors, merging overlaps within a single interval vector, splitting an interval vector on its overlapping endpoints, and applying set theoretical operations on interval vectors. Many of the operations in this package were inspired by James Allen's interval algebra, Allen (1983) <a href="https://doi.org/10.1145/182.358434">doi:10.1145/182.358434</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DavisVaughan/ivs">https://github.com/DavisVaughan/ivs</a>
</p>
</li>
<li> <p><a href="https://davisvaughan.github.io/ivs/">https://davisvaughan.github.io/ivs/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DavisVaughan/ivs/issues">https://github.com/DavisVaughan/ivs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='allen-relation-count'>Count relations from Allen's Interval Algebra</h2><span id='topic+allen-relation-count'></span><span id='topic+iv_count_relates'></span>

<h3>Description</h3>

<p><code>iv_count_relates()</code> is similar to <code><a href="#topic+iv_count_overlaps">iv_count_overlaps()</a></code>, but it counts a
specific set of relations developed by James Allen in the paper:
<a href="http://cse.unl.edu/~choueiry/Documents/Allen-CACM1983.pdf">Maintaining Knowledge about Temporal Intervals</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_count_relates(
  needles,
  haystack,
  ...,
  type,
  missing = "equals",
  no_match = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allen-relation-count_+3A_needles">needles</code>, <code id="allen-relation-count_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>Interval vectors used for relation matching.
</p>

<ul>
<li><p> Each element of <code>needles</code> represents the interval to search for.
</p>
</li>
<li> <p><code>haystack</code> represents the intervals to search in.
</p>
</li></ul>

<p>Prior to comparison, <code>needles</code> and <code>haystack</code> are coerced to the same type.</p>
</td></tr>
<tr><td><code id="allen-relation-count_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="allen-relation-count_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The type of relationship to find. See the Allen's Interval Algebra section
for a complete description of each type. One of:
</p>

<ul>
<li> <p><code>"precedes"</code>
</p>
</li>
<li> <p><code>"preceded-by"</code>
</p>
</li>
<li> <p><code>"meets"</code>
</p>
</li>
<li> <p><code>"met-by"</code>
</p>
</li>
<li> <p><code>"overlaps"</code>
</p>
</li>
<li> <p><code>"overlapped-by"</code>
</p>
</li>
<li> <p><code>"starts"</code>
</p>
</li>
<li> <p><code>"started-by"</code>
</p>
</li>
<li> <p><code>"during"</code>
</p>
</li>
<li> <p><code>"contains"</code>
</p>
</li>
<li> <p><code>"finishes"</code>
</p>
</li>
<li> <p><code>"finished-by"</code>
</p>
</li>
<li> <p><code>"equals"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="allen-relation-count_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / "equals" / "error"]&#8288;</code>
</p>
<p>Handling of missing intervals in <code>needles</code>.
</p>

<ul>
<li> <p><code>"equals"</code> considers missing intervals in <code>needles</code> as exactly equal
to missing intervals in <code>haystack</code> when determining if there is a
matching relationship between them.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any intervals in <code>needles</code> are missing.
</p>
</li>
<li><p> If a single integer value is provided, this represents the count returned
for a missing interval in <code>needles</code>. Use <code>0L</code> to force missing intervals
to never match.
</p>
</li></ul>
</td></tr>
<tr><td><code id="allen-relation-count_+3A_no_match">no_match</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / "error"]&#8288;</code>
</p>
<p>Handling of <code>needles</code> without a match.
</p>

<ul>
<li> <p><code>"error"</code> throws an error if any needles have zero matches.
</p>
</li>
<li><p> If a single integer is provided, this represents the count returned for
a needle with zero matches. The default value gives unmatched needles
a count of <code>0L</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector the same size as <code>needles</code>.
</p>


<h3>Allen's Interval Algebra</h3>

<p>The interval algebra developed by James Allen serves as a basis and
inspiration for <code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, <code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, and
<code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code>. The original algebra is composed of 13 relations
which have the following properties:
</p>

<ul>
<li><p> Distinct: No pair of intervals can be related by more than one <code>type</code>.
</p>
</li>
<li><p> Exhaustive: All pairs of intervals are described by one of the <code>type</code>s.
</p>
</li>
<li><p> Qualitative: No numeric intervals are considered. The relationships are
computed by purely qualitative means.
</p>
</li></ul>

<p>Take the notation that <code>x</code> and <code>y</code> represent two intervals. Now assume that
<code>x</code> can be represented as <code style="white-space: pre;">&#8288;[x_s, x_e)&#8288;</code>, where <code>x_s</code> is the start of the
interval and <code>x_e</code> is the end of it. Additionally, assume that <code>x_s &lt; x_e</code>.
With this notation, the 13 relations are as follows:
</p>

<ul>
<li> <p><em>Precedes</em>:
</p>
<p><code>x_e &lt; y_s</code>
</p>
</li>
<li> <p><em>Preceded-by</em>:
</p>
<p><code>x_s &gt; y_e</code>
</p>
</li>
<li> <p><em>Meets</em>:
</p>
<p><code>x_e == y_s</code>
</p>
</li>
<li> <p><em>Met-by</em>:
</p>
<p><code>x_s == y_e</code>
</p>
</li>
<li> <p><em>Overlaps</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e &gt; y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Overlapped-by</em>:
</p>
<p><code>(x_e &gt; y_e) &amp; (x_s &lt; y_e) &amp; (x_s &gt; y_s)</code>
</p>
</li>
<li> <p><em>Starts</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Started-by</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e &gt; y_e)</code>
</p>
</li>
<li> <p><em>Finishes</em>:
</p>
<p><code>(x_s &gt; y_s) &amp; (x_e == y_e)</code>
</p>
</li>
<li> <p><em>Finished-by</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e == y_e)</code>
</p>
</li>
<li> <p><em>During</em>:
</p>
<p><code>(x_s &gt; y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Contains</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e &gt; y_e)</code>
</p>
</li>
<li> <p><em>Equals</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e == y_e)</code>
</p>
</li></ul>

<p>Note that when <code>missing = "equals"</code>, missing intervals will only match
the <code>type = "equals"</code> relation. This ensures that the distinct property
of the algebra is maintained.
</p>


<h4>Connection to other functions</h4>

<p>Note that some of the above relations are fairly restrictive. For example,
<code>"overlaps"</code> only detects cases where <code>x</code> straddles <code>y_s</code>. It does not
consider the case where <code>x</code> and <code>y</code> are equal to be an overlap (as this
is <code>"equals"</code>) nor does it consider when <code>x</code> straddles <code>y_e</code> to be an
overlap (as this is <code>"overlapped-by"</code>). This makes the relations extremely
useful from a theoretical perspective, because they can be combined without
fear of duplicating relations, but they don't match our typical expectations
for what an &quot;overlap&quot; is.
</p>
<p><code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, <code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, and <code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code> use
more intuitive <code>type</code>s that aren't distinct, but typically match your
expectations better. They can each be expressed in terms of Allen's
relations:
</p>

<ul>
<li> <p><code>iv_locate_overlaps()</code>:
</p>

<ul>
<li> <p><code>"any"</code>:
</p>
<p><code>overlaps | overlapped-by | starts | started-by | finishes | finished-by | during | contains | equals</code>
</p>
</li>
<li> <p><code>"contains"</code>:
</p>
<p><code>contains | started-by | finished-by | equals</code>
</p>
</li>
<li> <p><code>"within"</code>:
</p>
<p><code>during | starts | finishes | equals</code>
</p>
</li>
<li> <p><code>"starts"</code>:
</p>
<p><code>starts | started-by | equals</code>
</p>
</li>
<li> <p><code>"ends"</code>:
</p>
<p><code>finishes | finished-by | equals</code>
</p>
</li>
<li> <p><code>"equals"</code>:
</p>
<p><code>equals</code>
</p>
</li></ul>

</li>
<li> <p><code>iv_locate_precedes()</code>:
</p>
<p><code>precedes | meets</code>
</p>
</li>
<li> <p><code>iv_locate_follows()</code>:
</p>
<p><code>preceded-by | met-by</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><a href="#topic+allen-relation-locate">Locating relations from Allen's Interval Algebra</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iv(1, 3)
y &lt;- iv(3, 4)

# `"precedes"` is strict, and doesn't let the endpoints match
iv_count_relates(x, y, type = "precedes")

# Since that is what `"meets"` represents
iv_count_relates(x, y, type = "meets")

# `"overlaps"` is a very specific type of overlap where an interval in
# `needles` straddles the start of an interval in `haystack`
x &lt;- iv_pairs(c(1, 4), c(1, 3), c(0, 3), c(2, 5))
y &lt;- iv(1, 4)

# It doesn't match equality, or when the starts match, or when the end
# of the interval in `haystack` is straddled instead
iv_count_relates(x, y, type = "overlaps")
</code></pre>

<hr>
<h2 id='allen-relation-detect'>Detect relations from Allen's Interval Algebra</h2><span id='topic+allen-relation-detect'></span><span id='topic+iv_relates'></span>

<h3>Description</h3>

<p><code>iv_relates()</code> is similar to <code><a href="#topic+iv_overlaps">iv_overlaps()</a></code>, but it detects a
specific set of relations developed by James Allen in the paper:
<a href="http://cse.unl.edu/~choueiry/Documents/Allen-CACM1983.pdf">Maintaining Knowledge about Temporal Intervals</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_relates(needles, haystack, ..., type, missing = "equals")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allen-relation-detect_+3A_needles">needles</code>, <code id="allen-relation-detect_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>Interval vectors used for relation matching.
</p>

<ul>
<li><p> Each element of <code>needles</code> represents the interval to search for.
</p>
</li>
<li> <p><code>haystack</code> represents the intervals to search in.
</p>
</li></ul>

<p>Prior to comparison, <code>needles</code> and <code>haystack</code> are coerced to the same type.</p>
</td></tr>
<tr><td><code id="allen-relation-detect_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="allen-relation-detect_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The type of relationship to find. See the Allen's Interval Algebra section
for a complete description of each type. One of:
</p>

<ul>
<li> <p><code>"precedes"</code>
</p>
</li>
<li> <p><code>"preceded-by"</code>
</p>
</li>
<li> <p><code>"meets"</code>
</p>
</li>
<li> <p><code>"met-by"</code>
</p>
</li>
<li> <p><code>"overlaps"</code>
</p>
</li>
<li> <p><code>"overlapped-by"</code>
</p>
</li>
<li> <p><code>"starts"</code>
</p>
</li>
<li> <p><code>"started-by"</code>
</p>
</li>
<li> <p><code>"during"</code>
</p>
</li>
<li> <p><code>"contains"</code>
</p>
</li>
<li> <p><code>"finishes"</code>
</p>
</li>
<li> <p><code>"finished-by"</code>
</p>
</li>
<li> <p><code>"equals"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="allen-relation-detect_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1) / "equals" / "error"]&#8288;</code>
</p>
<p>Handling of missing intervals in <code>needles</code>.
</p>

<ul>
<li> <p><code>"equals"</code> considers missing intervals in <code>needles</code> as exactly equal
to missing intervals in <code>haystack</code> when determining if there is a
matching relationship between them. Matched missing intervals in
<code>needles</code> result in a <code>TRUE</code> value in the result, and unmatched missing
intervals result in a <code>FALSE</code> value.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any intervals in <code>needles</code> are missing.
</p>
</li>
<li><p> If a single logical value is provided, this represents the value returned
in the result for intervals in <code>needles</code> that are missing. You can force
missing intervals to be unmatched by setting this to <code>FALSE</code>, and you
can force them to be propagated by setting this to <code>NA</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same size as <code>needles</code>.
</p>


<h3>Allen's Interval Algebra</h3>

<p>The interval algebra developed by James Allen serves as a basis and
inspiration for <code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, <code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, and
<code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code>. The original algebra is composed of 13 relations
which have the following properties:
</p>

<ul>
<li><p> Distinct: No pair of intervals can be related by more than one <code>type</code>.
</p>
</li>
<li><p> Exhaustive: All pairs of intervals are described by one of the <code>type</code>s.
</p>
</li>
<li><p> Qualitative: No numeric intervals are considered. The relationships are
computed by purely qualitative means.
</p>
</li></ul>

<p>Take the notation that <code>x</code> and <code>y</code> represent two intervals. Now assume that
<code>x</code> can be represented as <code style="white-space: pre;">&#8288;[x_s, x_e)&#8288;</code>, where <code>x_s</code> is the start of the
interval and <code>x_e</code> is the end of it. Additionally, assume that <code>x_s &lt; x_e</code>.
With this notation, the 13 relations are as follows:
</p>

<ul>
<li> <p><em>Precedes</em>:
</p>
<p><code>x_e &lt; y_s</code>
</p>
</li>
<li> <p><em>Preceded-by</em>:
</p>
<p><code>x_s &gt; y_e</code>
</p>
</li>
<li> <p><em>Meets</em>:
</p>
<p><code>x_e == y_s</code>
</p>
</li>
<li> <p><em>Met-by</em>:
</p>
<p><code>x_s == y_e</code>
</p>
</li>
<li> <p><em>Overlaps</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e &gt; y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Overlapped-by</em>:
</p>
<p><code>(x_e &gt; y_e) &amp; (x_s &lt; y_e) &amp; (x_s &gt; y_s)</code>
</p>
</li>
<li> <p><em>Starts</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Started-by</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e &gt; y_e)</code>
</p>
</li>
<li> <p><em>Finishes</em>:
</p>
<p><code>(x_s &gt; y_s) &amp; (x_e == y_e)</code>
</p>
</li>
<li> <p><em>Finished-by</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e == y_e)</code>
</p>
</li>
<li> <p><em>During</em>:
</p>
<p><code>(x_s &gt; y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Contains</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e &gt; y_e)</code>
</p>
</li>
<li> <p><em>Equals</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e == y_e)</code>
</p>
</li></ul>

<p>Note that when <code>missing = "equals"</code>, missing intervals will only match
the <code>type = "equals"</code> relation. This ensures that the distinct property
of the algebra is maintained.
</p>


<h4>Connection to other functions</h4>

<p>Note that some of the above relations are fairly restrictive. For example,
<code>"overlaps"</code> only detects cases where <code>x</code> straddles <code>y_s</code>. It does not
consider the case where <code>x</code> and <code>y</code> are equal to be an overlap (as this
is <code>"equals"</code>) nor does it consider when <code>x</code> straddles <code>y_e</code> to be an
overlap (as this is <code>"overlapped-by"</code>). This makes the relations extremely
useful from a theoretical perspective, because they can be combined without
fear of duplicating relations, but they don't match our typical expectations
for what an &quot;overlap&quot; is.
</p>
<p><code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, <code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, and <code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code> use
more intuitive <code>type</code>s that aren't distinct, but typically match your
expectations better. They can each be expressed in terms of Allen's
relations:
</p>

<ul>
<li> <p><code>iv_locate_overlaps()</code>:
</p>

<ul>
<li> <p><code>"any"</code>:
</p>
<p><code>overlaps | overlapped-by | starts | started-by | finishes | finished-by | during | contains | equals</code>
</p>
</li>
<li> <p><code>"contains"</code>:
</p>
<p><code>contains | started-by | finished-by | equals</code>
</p>
</li>
<li> <p><code>"within"</code>:
</p>
<p><code>during | starts | finishes | equals</code>
</p>
</li>
<li> <p><code>"starts"</code>:
</p>
<p><code>starts | started-by | equals</code>
</p>
</li>
<li> <p><code>"ends"</code>:
</p>
<p><code>finishes | finished-by | equals</code>
</p>
</li>
<li> <p><code>"equals"</code>:
</p>
<p><code>equals</code>
</p>
</li></ul>

</li>
<li> <p><code>iv_locate_precedes()</code>:
</p>
<p><code>precedes | meets</code>
</p>
</li>
<li> <p><code>iv_locate_follows()</code>:
</p>
<p><code>preceded-by | met-by</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><a href="#topic+relation-locate">Locating relationships</a>
</p>
<p><a href="#topic+allen-relation-locate">Locating relations from Allen's Interval Algebra</a>
</p>
<p><a href="#topic+allen-relation-detect-pairwise">Detecting relations from Allen's Interval Algebra pairwise</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iv(1, 3)
y &lt;- iv(3, 4)

# `"precedes"` is strict, and doesn't let the endpoints match
iv_relates(x, y, type = "precedes")

# Since that is what `"meets"` represents
iv_relates(x, y, type = "meets")

# `"overlaps"` is a very specific type of overlap where an interval in
# `needles` straddles the start of an interval in `haystack`
x &lt;- iv_pairs(c(1, 4), c(1, 3), c(0, 3), c(2, 5))
y &lt;- iv(1, 4)

# It doesn't match equality, or when the starts match, or when the end
# of the interval in `haystack` is straddled instead
iv_relates(x, y, type = "overlaps")
</code></pre>

<hr>
<h2 id='allen-relation-detect-pairwise'>Pairwise detect relations from Allen's Interval Algebra</h2><span id='topic+allen-relation-detect-pairwise'></span><span id='topic+iv_pairwise_relates'></span>

<h3>Description</h3>

<p><code>iv_pairwise_relates()</code> is similar to
<code><a href="#topic+iv_pairwise_overlaps">iv_pairwise_overlaps()</a></code>, but it detects a specific set of relations
developed by James Allen in the paper: <a href="http://cse.unl.edu/~choueiry/Documents/Allen-CACM1983.pdf">Maintaining Knowledge about Temporal Intervals</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_pairwise_relates(x, y, ..., type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allen-relation-detect-pairwise_+3A_x">x</code>, <code id="allen-relation-detect-pairwise_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>A pair of interval vectors.
</p>
<p>These will be recycled against each other and cast to the same type.</p>
</td></tr>
<tr><td><code id="allen-relation-detect-pairwise_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="allen-relation-detect-pairwise_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The type of relationship to find. See the Allen's Interval Algebra section
for a complete description of each type. One of:
</p>

<ul>
<li> <p><code>"precedes"</code>
</p>
</li>
<li> <p><code>"preceded-by"</code>
</p>
</li>
<li> <p><code>"meets"</code>
</p>
</li>
<li> <p><code>"met-by"</code>
</p>
</li>
<li> <p><code>"overlaps"</code>
</p>
</li>
<li> <p><code>"overlapped-by"</code>
</p>
</li>
<li> <p><code>"starts"</code>
</p>
</li>
<li> <p><code>"started-by"</code>
</p>
</li>
<li> <p><code>"during"</code>
</p>
</li>
<li> <p><code>"contains"</code>
</p>
</li>
<li> <p><code>"finishes"</code>
</p>
</li>
<li> <p><code>"finished-by"</code>
</p>
</li>
<li> <p><code>"equals"</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same size as the common size of <code>x</code> and <code>y</code>.
</p>


<h3>Allen's Interval Algebra</h3>

<p>The interval algebra developed by James Allen serves as a basis and
inspiration for <code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, <code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, and
<code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code>. The original algebra is composed of 13 relations
which have the following properties:
</p>

<ul>
<li><p> Distinct: No pair of intervals can be related by more than one <code>type</code>.
</p>
</li>
<li><p> Exhaustive: All pairs of intervals are described by one of the <code>type</code>s.
</p>
</li>
<li><p> Qualitative: No numeric intervals are considered. The relationships are
computed by purely qualitative means.
</p>
</li></ul>

<p>Take the notation that <code>x</code> and <code>y</code> represent two intervals. Now assume that
<code>x</code> can be represented as <code style="white-space: pre;">&#8288;[x_s, x_e)&#8288;</code>, where <code>x_s</code> is the start of the
interval and <code>x_e</code> is the end of it. Additionally, assume that <code>x_s &lt; x_e</code>.
With this notation, the 13 relations are as follows:
</p>

<ul>
<li> <p><em>Precedes</em>:
</p>
<p><code>x_e &lt; y_s</code>
</p>
</li>
<li> <p><em>Preceded-by</em>:
</p>
<p><code>x_s &gt; y_e</code>
</p>
</li>
<li> <p><em>Meets</em>:
</p>
<p><code>x_e == y_s</code>
</p>
</li>
<li> <p><em>Met-by</em>:
</p>
<p><code>x_s == y_e</code>
</p>
</li>
<li> <p><em>Overlaps</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e &gt; y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Overlapped-by</em>:
</p>
<p><code>(x_e &gt; y_e) &amp; (x_s &lt; y_e) &amp; (x_s &gt; y_s)</code>
</p>
</li>
<li> <p><em>Starts</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Started-by</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e &gt; y_e)</code>
</p>
</li>
<li> <p><em>Finishes</em>:
</p>
<p><code>(x_s &gt; y_s) &amp; (x_e == y_e)</code>
</p>
</li>
<li> <p><em>Finished-by</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e == y_e)</code>
</p>
</li>
<li> <p><em>During</em>:
</p>
<p><code>(x_s &gt; y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Contains</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e &gt; y_e)</code>
</p>
</li>
<li> <p><em>Equals</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e == y_e)</code>
</p>
</li></ul>

<p>Note that when <code>missing = "equals"</code>, missing intervals will only match
the <code>type = "equals"</code> relation. This ensures that the distinct property
of the algebra is maintained.
</p>


<h4>Connection to other functions</h4>

<p>Note that some of the above relations are fairly restrictive. For example,
<code>"overlaps"</code> only detects cases where <code>x</code> straddles <code>y_s</code>. It does not
consider the case where <code>x</code> and <code>y</code> are equal to be an overlap (as this
is <code>"equals"</code>) nor does it consider when <code>x</code> straddles <code>y_e</code> to be an
overlap (as this is <code>"overlapped-by"</code>). This makes the relations extremely
useful from a theoretical perspective, because they can be combined without
fear of duplicating relations, but they don't match our typical expectations
for what an &quot;overlap&quot; is.
</p>
<p><code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, <code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, and <code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code> use
more intuitive <code>type</code>s that aren't distinct, but typically match your
expectations better. They can each be expressed in terms of Allen's
relations:
</p>

<ul>
<li> <p><code>iv_locate_overlaps()</code>:
</p>

<ul>
<li> <p><code>"any"</code>:
</p>
<p><code>overlaps | overlapped-by | starts | started-by | finishes | finished-by | during | contains | equals</code>
</p>
</li>
<li> <p><code>"contains"</code>:
</p>
<p><code>contains | started-by | finished-by | equals</code>
</p>
</li>
<li> <p><code>"within"</code>:
</p>
<p><code>during | starts | finishes | equals</code>
</p>
</li>
<li> <p><code>"starts"</code>:
</p>
<p><code>starts | started-by | equals</code>
</p>
</li>
<li> <p><code>"ends"</code>:
</p>
<p><code>finishes | finished-by | equals</code>
</p>
</li>
<li> <p><code>"equals"</code>:
</p>
<p><code>equals</code>
</p>
</li></ul>

</li>
<li> <p><code>iv_locate_precedes()</code>:
</p>
<p><code>precedes | meets</code>
</p>
</li>
<li> <p><code>iv_locate_follows()</code>:
</p>
<p><code>preceded-by | met-by</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><a href="#topic+relation-locate">Locating relationships</a>
</p>
<p><a href="#topic+allen-relation-locate">Locating relations from Allen's Interval Algebra</a>
</p>
<p><a href="#topic+allen-relation-detect">Detecting relations from Allen's Interval Algebra</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iv_pairs(c(1, 3), c(3, 5))
y &lt;- iv_pairs(c(3, 4), c(6, 7))

# `"precedes"` is strict, and doesn't let the endpoints match
iv_pairwise_relates(x, y, type = "precedes")

# Since that is what `"meets"` represents
iv_pairwise_relates(x, y, type = "meets")

# `"during"` only matches when `x` is completely contained in `y`, and
# doesn't allow any endpoints to match
x &lt;- iv_pairs(c(1, 3), c(4, 5), c(8, 9))
y &lt;- iv_pairs(c(1, 4), c(3, 8), c(8, 9))

iv_pairwise_relates(x, y, type = "during")
</code></pre>

<hr>
<h2 id='allen-relation-locate'>Locate relations from Allen's Interval Algebra</h2><span id='topic+allen-relation-locate'></span><span id='topic+iv_locate_relates'></span>

<h3>Description</h3>

<p><code>iv_locate_relates()</code> is similar to <code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, but it locates a
specific set of relations developed by James Allen in the paper:
<a href="http://cse.unl.edu/~choueiry/Documents/Allen-CACM1983.pdf">Maintaining Knowledge about Temporal Intervals</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_locate_relates(
  needles,
  haystack,
  ...,
  type,
  missing = "equals",
  no_match = NA_integer_,
  remaining = "drop",
  multiple = "all",
  relationship = "none"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allen-relation-locate_+3A_needles">needles</code>, <code id="allen-relation-locate_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>Interval vectors used for relation matching.
</p>

<ul>
<li><p> Each element of <code>needles</code> represents the interval to search for.
</p>
</li>
<li> <p><code>haystack</code> represents the intervals to search in.
</p>
</li></ul>

<p>Prior to comparison, <code>needles</code> and <code>haystack</code> are coerced to the same type.</p>
</td></tr>
<tr><td><code id="allen-relation-locate_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="allen-relation-locate_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The type of relationship to find. See the Allen's Interval Algebra section
for a complete description of each type. One of:
</p>

<ul>
<li> <p><code>"precedes"</code>
</p>
</li>
<li> <p><code>"preceded-by"</code>
</p>
</li>
<li> <p><code>"meets"</code>
</p>
</li>
<li> <p><code>"met-by"</code>
</p>
</li>
<li> <p><code>"overlaps"</code>
</p>
</li>
<li> <p><code>"overlapped-by"</code>
</p>
</li>
<li> <p><code>"starts"</code>
</p>
</li>
<li> <p><code>"started-by"</code>
</p>
</li>
<li> <p><code>"during"</code>
</p>
</li>
<li> <p><code>"contains"</code>
</p>
</li>
<li> <p><code>"finishes"</code>
</p>
</li>
<li> <p><code>"finished-by"</code>
</p>
</li>
<li> <p><code>"equals"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="allen-relation-locate_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / "equals" / "drop" / "error"]&#8288;</code>
</p>
<p>Handling of missing intervals in <code>needles</code>.
</p>

<ul>
<li> <p><code>"equals"</code> considers missing intervals in <code>needles</code> as exactly equal
to missing intervals in <code>haystack</code> when determining if there is a
matching relationship between them.
</p>
</li>
<li> <p><code>"drop"</code> drops missing intervals in <code>needles</code> from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any intervals in <code>needles</code> are missing.
</p>
</li>
<li><p> If a single integer is provided, this represents the value returned in
the <code>haystack</code> column for intervals in <code>needles</code> that are missing.
</p>
</li></ul>
</td></tr>
<tr><td><code id="allen-relation-locate_+3A_no_match">no_match</code></td>
<td>
<p>Handling of <code>needles</code> without a match.
</p>

<ul>
<li> <p><code>"drop"</code> drops <code>needles</code> with zero matches from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any <code>needles</code> have zero matches.
</p>
</li>
<li><p> If a single integer is provided, this represents the value returned in
the <code>haystack</code> column for values of <code>needles</code> that have zero matches. The
default represents an unmatched needle with <code>NA</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="allen-relation-locate_+3A_remaining">remaining</code></td>
<td>
<p>Handling of <code>haystack</code> values that <code>needles</code> never matched.
</p>

<ul>
<li> <p><code>"drop"</code> drops remaining <code>haystack</code> values from the result.
Typically, this is the desired behavior if you only care when <code>needles</code>
has a match.
</p>
</li>
<li> <p><code>"error"</code> throws an error if there are any remaining <code>haystack</code>
values.
</p>
</li>
<li><p> If a single integer is provided (often <code>NA</code>), this represents the value
returned in the <code>needles</code> column for the remaining <code>haystack</code> values
that <code>needles</code> never matched. Remaining <code>haystack</code> values are always
returned at the end of the result.
</p>
</li></ul>
</td></tr>
<tr><td><code id="allen-relation-locate_+3A_multiple">multiple</code></td>
<td>
<p>Handling of <code>needles</code> with multiple matches. For each needle:
</p>

<ul>
<li> <p><code>"all"</code> returns all matches detected in <code>haystack</code>.
</p>
</li>
<li> <p><code>"any"</code> returns any match detected in <code>haystack</code> with no guarantees on
which match will be returned. It is often faster than <code>"first"</code> and
<code>"last"</code> if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>haystack</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>haystack</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="allen-relation-locate_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between
<code>needles</code> and <code>haystack</code>. If the expectations chosen from the list below
are invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>"none"</code> doesn't perform any relationship checks.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches at most 1 value in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches at most 1 value in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches any number of values in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches at most 1 value in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches at most 1 value in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches any number of values in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches any number of values in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches any number of values in <code>needles</code>.
</p>
</li></ul>

<p>This performs no checks, and is identical to <code>"none"</code>, but is provided to
allow you to be explicit about this relationship if you know it exists.
</p>
</li>
<li> <p><code>"warn-many-to-many"</code> doesn't assume there is any known relationship, but
will warn if <code>needles</code> and <code>haystack</code> have a many-to-many relationship
(which is typically unexpected), encouraging you to either take a closer
look at your inputs or make this relationship explicit by specifying
<code>"many-to-many"</code>.
</p>
</li></ul>

<p><code>relationship</code> is applied after <code>filter</code> and <code>multiple</code> to allow potential
multiple matches to be filtered out first.
</p>
<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>no_match</code> and <code>remaining</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing two integer columns named <code>needles</code> and <code>haystack</code>.
</p>


<h3>Allen's Interval Algebra</h3>

<p>The interval algebra developed by James Allen serves as a basis and
inspiration for <code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, <code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, and
<code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code>. The original algebra is composed of 13 relations
which have the following properties:
</p>

<ul>
<li><p> Distinct: No pair of intervals can be related by more than one <code>type</code>.
</p>
</li>
<li><p> Exhaustive: All pairs of intervals are described by one of the <code>type</code>s.
</p>
</li>
<li><p> Qualitative: No numeric intervals are considered. The relationships are
computed by purely qualitative means.
</p>
</li></ul>

<p>Take the notation that <code>x</code> and <code>y</code> represent two intervals. Now assume that
<code>x</code> can be represented as <code style="white-space: pre;">&#8288;[x_s, x_e)&#8288;</code>, where <code>x_s</code> is the start of the
interval and <code>x_e</code> is the end of it. Additionally, assume that <code>x_s &lt; x_e</code>.
With this notation, the 13 relations are as follows:
</p>

<ul>
<li> <p><em>Precedes</em>:
</p>
<p><code>x_e &lt; y_s</code>
</p>
</li>
<li> <p><em>Preceded-by</em>:
</p>
<p><code>x_s &gt; y_e</code>
</p>
</li>
<li> <p><em>Meets</em>:
</p>
<p><code>x_e == y_s</code>
</p>
</li>
<li> <p><em>Met-by</em>:
</p>
<p><code>x_s == y_e</code>
</p>
</li>
<li> <p><em>Overlaps</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e &gt; y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Overlapped-by</em>:
</p>
<p><code>(x_e &gt; y_e) &amp; (x_s &lt; y_e) &amp; (x_s &gt; y_s)</code>
</p>
</li>
<li> <p><em>Starts</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Started-by</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e &gt; y_e)</code>
</p>
</li>
<li> <p><em>Finishes</em>:
</p>
<p><code>(x_s &gt; y_s) &amp; (x_e == y_e)</code>
</p>
</li>
<li> <p><em>Finished-by</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e == y_e)</code>
</p>
</li>
<li> <p><em>During</em>:
</p>
<p><code>(x_s &gt; y_s) &amp; (x_e &lt; y_e)</code>
</p>
</li>
<li> <p><em>Contains</em>:
</p>
<p><code>(x_s &lt; y_s) &amp; (x_e &gt; y_e)</code>
</p>
</li>
<li> <p><em>Equals</em>:
</p>
<p><code>(x_s == y_s) &amp; (x_e == y_e)</code>
</p>
</li></ul>

<p>Note that when <code>missing = "equals"</code>, missing intervals will only match
the <code>type = "equals"</code> relation. This ensures that the distinct property
of the algebra is maintained.
</p>


<h4>Connection to other functions</h4>

<p>Note that some of the above relations are fairly restrictive. For example,
<code>"overlaps"</code> only detects cases where <code>x</code> straddles <code>y_s</code>. It does not
consider the case where <code>x</code> and <code>y</code> are equal to be an overlap (as this
is <code>"equals"</code>) nor does it consider when <code>x</code> straddles <code>y_e</code> to be an
overlap (as this is <code>"overlapped-by"</code>). This makes the relations extremely
useful from a theoretical perspective, because they can be combined without
fear of duplicating relations, but they don't match our typical expectations
for what an &quot;overlap&quot; is.
</p>
<p><code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, <code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, and <code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code> use
more intuitive <code>type</code>s that aren't distinct, but typically match your
expectations better. They can each be expressed in terms of Allen's
relations:
</p>

<ul>
<li> <p><code>iv_locate_overlaps()</code>:
</p>

<ul>
<li> <p><code>"any"</code>:
</p>
<p><code>overlaps | overlapped-by | starts | started-by | finishes | finished-by | during | contains | equals</code>
</p>
</li>
<li> <p><code>"contains"</code>:
</p>
<p><code>contains | started-by | finished-by | equals</code>
</p>
</li>
<li> <p><code>"within"</code>:
</p>
<p><code>during | starts | finishes | equals</code>
</p>
</li>
<li> <p><code>"starts"</code>:
</p>
<p><code>starts | started-by | equals</code>
</p>
</li>
<li> <p><code>"ends"</code>:
</p>
<p><code>finishes | finished-by | equals</code>
</p>
</li>
<li> <p><code>"equals"</code>:
</p>
<p><code>equals</code>
</p>
</li></ul>

</li>
<li> <p><code>iv_locate_precedes()</code>:
</p>
<p><code>precedes | meets</code>
</p>
</li>
<li> <p><code>iv_locate_follows()</code>:
</p>
<p><code>preceded-by | met-by</code>
</p>
</li></ul>




<h3>References</h3>

<p>Allen, James F. (26 November 1983). &quot;Maintaining knowledge about temporal
intervals&quot;. Communications of the ACM. 26 (11): 832â€“843.
</p>


<h3>See Also</h3>

<p><a href="#topic+relation-locate">Locating relationships</a>
</p>
<p><a href="#topic+allen-relation-detect">Detecting relations from Allen's Interval Algebra</a>
</p>
<p><a href="#topic+allen-relation-detect-pairwise">Detecting relations from Allen's Interval Algebra pairwise</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iv(1, 3)
y &lt;- iv(3, 4)

# `"precedes"` is strict, and doesn't let the endpoints match
iv_locate_relates(x, y, type = "precedes")

# Since that is what `"meets"` represents
iv_locate_relates(x, y, type = "meets")

# `"overlaps"` is a very specific type of overlap where an interval in
# `needles` straddles the start of an interval in `haystack`
x &lt;- iv_pairs(c(1, 4), c(1, 3), c(0, 3), c(2, 5))
y &lt;- iv(1, 4)

# It doesn't match equality, or when the starts match, or when the end
# of the interval in `haystack` is straddled instead
iv_locate_relates(x, y, type = "overlaps")
</code></pre>

<hr>
<h2 id='is_iv'>Is <code>x</code> an iv?</h2><span id='topic+is_iv'></span>

<h3>Description</h3>

<p><code>is_iv()</code> tests if <code>x</code> is an iv object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_iv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_iv_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[object]&#8288;</code>
</p>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_iv(1)
is_iv(new_iv(1, 2))
</code></pre>

<hr>
<h2 id='iv'>Create an interval vector</h2><span id='topic+iv'></span><span id='topic+iv_pairs'></span>

<h3>Description</h3>


<ul>
<li> <p><code>iv()</code> creates an interval vector from <code>start</code> and <code>end</code> vectors. This
is how you will typically create interval vectors, and is often used with
columns in a data frame.
</p>
</li>
<li> <p><code>iv_pairs()</code> creates an interval vector from <em>pairs</em>. This is often useful
for interactive testing, as it provides a more intuitive interface for
creating small interval vectors. It should generally not be used on a large
scale because it can be slow.
</p>
</li></ul>



<h4>Intervals</h4>

<p>Interval vectors are <em>right-open</em>, i.e. <code style="white-space: pre;">&#8288;[start, end)&#8288;</code>. This means that
<code>start &lt; end</code> is a requirement to generate an interval vector. In particular,
empty intervals with <code>start == end</code> are not allowed.
</p>
<p>Right-open intervals tend to be the most practically useful. For example,
<code style="white-space: pre;">&#8288;[2019-01-01 00:00:00, 2019-01-02 00:00:00)&#8288;</code> nicely encapsulates all times on
<code>2019-01-01</code>. With closed intervals, you'd have to attempt to specify this as
<code style="white-space: pre;">&#8288;2019-01-01 23:59:59&#8288;</code>, which is inconvenient and inaccurate, as it doesn't
capture fractional seconds.
</p>
<p>Right-open intervals also have the extremely nice technical property that
they create a closed algebra. Concretely, the complement of a vector of
right-open intervals and the union, intersection, or difference of two
vectors of right-open intervals will always result in another vector of
right-open intervals.
</p>



<h4>Missing intervals</h4>

<p>When creating interval vectors with <code>iv()</code>, if either bound is
<a href="vctrs.html#topic+vec_detect_complete">incomplete</a>, then both bounds are set to
their missing value.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>iv(start, end, ..., ptype = NULL, size = NULL)

iv_pairs(..., ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv_+3A_start">start</code>, <code id="iv_+3A_end">end</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>A pair of vectors to represent the bounds of the intervals.
</p>
<p>To be a valid interval vector, <code>start</code> must be strictly less than <code>end</code>.
</p>
<p>If either <code>start</code> or <code>end</code> are incomplete / missing, then both bounds will
be coerced to missing values.
</p>
<p><code>start</code> and <code>end</code> are recycled against each other and are cast to the same
type.</p>
</td></tr>
<tr><td><code id="iv_+3A_...">...</code></td>
<td>
<p>For <code>iv_pairs()</code>:
</p>
<p><code style="white-space: pre;">&#8288;[vector pairs]&#8288;</code>
</p>
<p>Vectors of size 2 representing intervals to include in the result.
</p>
<p>All inputs will be cast to the same type.
</p>
<p>For <code>iv()</code>:
</p>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="iv_+3A_ptype">ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype to force for the inner type of the resulting iv. If <code>NULL</code>,
this defaults to the common type of the inputs.</p>
</td></tr>
<tr><td><code id="iv_+3A_size">size</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / NULL]&#8288;</code>
</p>
<p>A size to force for the resulting iv. If <code>NULL</code>, this defaults to the
common size of the inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iv.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

set.seed(123)

x &lt;- tibble(
  start = as.Date("2019-01-01") + 1:5,
  end = start + sample(1:10, length(start), replace = TRUE)
)

# Typically you'll use `iv()` with columns of a data frame
mutate(x, iv = iv(start, end), .keep = "unused")

# `iv_pairs()` is useful for generating interval vectors interactively
iv_pairs(c(1, 5), c(2, 3), c(6, 10))
</code></pre>

<hr>
<h2 id='iv_align'>Align after locating relationships</h2><span id='topic+iv_align'></span>

<h3>Description</h3>

<p><code>iv_align()</code> will align/join <code>needles</code> and <code>haystack</code> together using a data
frame of <code>locations</code>. These <code>locations</code> are intended to be the output of one
of: <code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>, <code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, <code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code>,
<code><a href="#topic+iv_locate_relates">iv_locate_relates()</a></code>, or <code><a href="#topic+iv_locate_between">iv_locate_between()</a></code>.
</p>
<p>This is mainly a convenience function that slices both <code>needles</code> and
<code>haystack</code> according to those <code>locations</code>, and then stores the result
in a new two column data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_align(needles, haystack, ..., locations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv_align_+3A_needles">needles</code>, <code id="iv_align_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>Two vectors to align.</p>
</td></tr>
<tr><td><code id="iv_align_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="iv_align_+3A_locations">locations</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[two-column data frame]&#8288;</code>
</p>
<p>The data frame of locations returned from one of <code><a href="#topic+iv_locate_overlaps">iv_locate_overlaps()</a></code>,
<code><a href="#topic+iv_locate_precedes">iv_locate_precedes()</a></code>, <code><a href="#topic+iv_locate_follows">iv_locate_follows()</a></code>, <code><a href="#topic+iv_locate_relates">iv_locate_relates()</a></code>, or
<code><a href="#topic+iv_locate_between">iv_locate_between()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two column data frame with a <code style="white-space: pre;">&#8288;$needles&#8288;</code> column containing the
sliced version of <code>needles</code> and a <code style="white-space: pre;">&#8288;$haystack&#8288;</code> column containing the sliced
version of <code>haystack</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>needles &lt;- iv_pairs(c(1, 5), c(3, 7), c(10, 12))
haystack &lt;- iv_pairs(c(0, 2), c(4, 6))

locations &lt;- iv_locate_overlaps(needles, haystack)
iv_align(needles, haystack, locations = locations)

locations &lt;- iv_locate_overlaps(needles, haystack, no_match = "drop")
iv_align(needles, haystack, locations = locations)

needles &lt;- c(1, 15, 4, 11)
haystack &lt;- iv_pairs(c(1, 5), c(3, 7), c(10, 12))

locations &lt;- iv_locate_between(needles, haystack)
iv_align(needles, haystack, locations = locations)
</code></pre>

<hr>
<h2 id='iv_diff'>Diff a vector to create an interval vector</h2><span id='topic+iv_diff'></span>

<h3>Description</h3>

<p><code>iv_diff()</code> is a convenient way to generate an iv from a preexisting vector,
as long as that vector is in strictly increasing order. It returns an iv
that is 1 element shorter than <code>x</code> (unless <code>x</code> is already empty).
</p>
<p>It is particularly useful for creating an iv column from an existing column
inside of <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, but requires you to explicitly handle padding
in that case, see the examples.
</p>
<p>Missing values are allowed, and will be propagated to each side of the
resulting interval after applying the diff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_diff(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv_diff_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>A vector in strictly increasing order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>iv_diff()</code> is inspired by <code><a href="base.html#topic+diff">diff()</a></code>.
</p>


<h3>Value</h3>

<p>An iv using <code>x</code> as the inner type, with size equal to
<code>max(0L, vec_size(x) - 1L)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.Date("2019-01-01") + c(0, 5, 7, 10, 19)
x

# Notice how the boundaries don't overlap, because the closing `)` aligns
# with an opening `[`.
iv_diff(x)

# Like `iv()`, missing values propagate to both boundaries of the interval.
# Before missing value propagation was applied, it looked like this:
# [1, NA), [NA, 2), [2, 3)
x &lt;- c(1, NA, 2, 3)
iv_diff(x)

# Values in `x` must be in strictly increasing order to generate a valid
# interval vector
x &lt;- c(1, 0, 2, 2)
try(iv_diff(x))

x &lt;- c(1, NA, 0)
try(iv_diff(x))

# ---------------------------------------------------------------------------
# Use with `mutate()`

library(dplyr)

# `iv_diff()` is useful for converting a pre-existing column into an interval
# vector, but you'll need to apply padding to ensure that the size of the
# diff-ed result is the same as the number of rows in your data frame. There
# are two main ways to pad, which are explored below.
df &lt;- tibble(x = c(1, 3, 6))

# Pad with a known lower/upper bound
df %&gt;% mutate(iv = iv_diff(c(0, x)))
df %&gt;% mutate(iv = iv_diff(c(x, Inf)))

# Pad with a missing value, which results in a fully missing interval
df %&gt;% mutate(iv = iv_diff(c(NA, x)))
df %&gt;% mutate(iv = iv_diff(c(x, NA)))
</code></pre>

<hr>
<h2 id='iv_format'>Formatting</h2><span id='topic+iv_format'></span>

<h3>Description</h3>

<p><code>iv_format()</code> is an S3 generic intended as a developer tool for making a
custom class print nicely when stored in an iv. The default method simply
calls <code><a href="base.html#topic+format">format()</a></code>, and in many cases this is enough for most classes.
However, if your class automatically adds justification or padding when
formatting a single vector, you might need to implement an <code>iv_format()</code>
method to avoid that padding, since it often looks strange when nested
in an interval vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_format(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv_format_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>A vector to format. This will be called on the <code><a href="#topic+iv_start">iv_start()</a></code> and <code><a href="#topic+iv_end">iv_end()</a></code>
vectors of an iv.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, likely generated through a call to <code>format()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Numeric values get padding automatically through `format()`
x &lt;- c(1, 100)
format(x)

# This ends up looking strange in an iv, so an `iv_format()` method for
# numeric values is implemented which turns off that padding
iv_format(x)
</code></pre>

<hr>
<h2 id='iv_pairwise_span'>Pairwise span</h2><span id='topic+iv_pairwise_span'></span>

<h3>Description</h3>

<p><code>iv_pairwise_span()</code> computes the <em>pairwise</em> &quot;span&quot; between the i-th interval
of <code>x</code> and the i-th interval of <code>y</code>. The pairwise span of two intervals is
a new interval containing the minimum start and maximum end of the original
intervals. It is similar to <code><a href="#topic+iv_pairwise_set_union">iv_pairwise_set_union()</a></code>, except it fills across
gaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_pairwise_span(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv_pairwise_span_+3A_x">x</code>, <code id="iv_pairwise_span_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>A pair of interval vectors.
</p>
<p>These will be cast to the same type, and recycled against each other.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iv the same size and type as <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iv_pairs(c(1, 3), c(6, 8))
y &lt;- iv_pairs(c(5, 7), c(2, 3))

# Can't take the set union when there are gaps
try(iv_pairwise_set_union(x, y))

# But you can compute the span of the intervals
iv_pairwise_span(x, y)
</code></pre>

<hr>
<h2 id='iv_span'>Span</h2><span id='topic+iv_span'></span>

<h3>Description</h3>

<p><code>iv_span()</code> computes the span of an iv. The span is a single interval which
encompasses the entire range of the iv. It is similar to <code><a href="#topic+iv_groups">iv_groups()</a></code>, if
groups were also merged across gaps.
</p>
<p><code>iv_span()</code> is a <em>summary</em> function, like <code><a href="base.html#topic+min">min()</a></code> and <code><a href="base.html#topic+max">max()</a></code>, so it always
returns a size 1 iv, even for empty ivs. The <code>empty</code> argument can be used to
control what is returned in the empty case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_span(x, ..., missing = "propagate", empty = "missing")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv_span_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>An interval vector.</p>
</td></tr>
<tr><td><code id="iv_span_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="iv_span_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;["propagate" / "drop" / "error" / iv(1)]&#8288;</code>
</p>
<p>Handling of missing intervals in <code>x</code>.
</p>

<ul>
<li> <p><code>"propagate"</code> forces <code>iv_span()</code> to return a missing interval if any
missing intervals are detected in <code>x</code>.
</p>
</li>
<li> <p><code>"drop"</code> drops missing intervals before computing the span. If this
results in an empty vector, then <code>empty</code> will be applied.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any missing intervals are detected.
</p>
</li>
<li><p> If an iv of size 1 is supplied, then this is returned if any missing
intervals are detected. It is cast to the type of <code>x</code> before returning.
</p>
</li></ul>
</td></tr>
<tr><td><code id="iv_span_+3A_empty">empty</code></td>
<td>
<p><code style="white-space: pre;">&#8288;["missing" / "error" / iv(1)]&#8288;</code>
</p>
<p>Handling of empty <code>x</code> vectors.
</p>

<ul>
<li> <p><code>"missing"</code> forces <code>iv_span()</code> to return a missing interval if <code>x</code> is
empty.
</p>
</li>
<li> <p><code>"error"</code> throws an error if <code>x</code> is empty.
</p>
</li>
<li><p> If an iv of size 1 is supplied, then this is returned if <code>x</code> is empty. It
is cast to the type of <code>x</code> before returning.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>iv_span()</code> is currently limited by the fact that it calls <code><a href="base.html#topic+min">min()</a></code> and
<code><a href="base.html#topic+max">max()</a></code> internally, which doesn't work for all vector types that ivs
supports (mainly data frames). In the future, we hope to be able to leverage
<code>vctrs::vec_min()</code> and <code>vctrs::vec_max()</code>, which don't exist yet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iv_pairs(c(1, 5), c(2, 6), c(9, 10))

# The span covers the full range of values seen in `x`
iv_span(x)

# Compare against `iv_groups()`, which merges overlaps but doesn't merge
# across gaps
iv_groups(x)

x &lt;- iv_pairs(c(1, 3), c(NA, NA), c(5, 6), c(NA, NA))

# Because `iv_span()` is a summary function, if any missing intervals are
# present then it returns a missing interval by default
iv_span(x)

# Further control this with `missing`
iv_span(x, missing = "drop")
try(iv_span(x, missing = "error"))
iv_span(x, missing = iv(-1, 0))

x &lt;- iv(double(), double())

# If `x` is empty, then by default a missing interval is returned
iv_span(x)

# Control this with `empty`
try(iv_span(x, empty = "error"))
iv_span(x, empty = iv(-Inf, Inf))

# `empty` kicks in if `missing = "drop"` is used and all elements were
# missing
x &lt;- iv(c(NA, NA), c(NA, NA), ptype = double())
iv_span(x, missing = "drop", empty = iv(-Inf, Inf))
</code></pre>

<hr>
<h2 id='iv-accessors'>Access the start or end of an interval vector</h2><span id='topic+iv-accessors'></span><span id='topic+iv_start'></span><span id='topic+iv_end'></span>

<h3>Description</h3>


<ul>
<li> <p><code>iv_start()</code> accesses the start of an interval vector.
</p>
</li>
<li> <p><code>iv_end()</code> accesses the end of an interval vector.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>iv_start(x)

iv_end(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv-accessors_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>An interval vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The start or end of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- new_iv(1, 2)

iv_start(x)
iv_end(x)
</code></pre>

<hr>
<h2 id='iv-containers'>Containers</h2><span id='topic+iv-containers'></span><span id='topic+iv_containers'></span><span id='topic+iv_identify_containers'></span><span id='topic+iv_identify_container'></span><span id='topic+iv_locate_containers'></span>

<h3>Description</h3>

<p>This family of functions revolves around computing interval <em>containers</em>.
A container is defined as the widest interval that isn't contained by any
other interval.
</p>

<ul>
<li> <p><code>iv_containers()</code> returns all of the containers found within <code>x</code>.
</p>
</li>
<li> <p><code>iv_identify_containers()</code> identifies the containers that each interval in
<code>x</code> falls in. It replaces <code>x</code> with a list of the same size where each element
of the list contains the containers that the corresponding interval in <code>x</code>
falls in. This is particularly useful alongside <code><a href="tidyr.html#topic+unnest">tidyr::unnest()</a></code>.
</p>
</li>
<li> <p><code>iv_identify_container()</code> is similar in spirit to
<code>iv_identify_containers()</code>, but is useful when you suspect that each interval
in <code>x</code> is contained within exactly 1 container. It replaces <code>x</code> with an iv of
the same size where each interval is the container that the corresponding
interval in <code>x</code> falls in. If any interval falls in more than one container,
an error is thrown.
</p>
</li>
<li> <p><code>iv_locate_containers()</code> returns a two column data frame with a <code>key</code>
column containing the result of <code>iv_containers()</code> and a <code>loc</code> list-column
containing integer vectors that map each interval in <code>x</code> to the container
that it falls in.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>iv_containers(x)

iv_identify_containers(x)

iv_identify_container(x)

iv_locate_containers(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv-containers_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>An interval vector.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>iv_containers()</code>, an iv with the same type as <code>x</code>.
</p>
</li>
<li><p> For <code>iv_identify_containers()</code>, a list-of containing ivs with the same size
as <code>x</code>.
</p>
</li>
<li><p> For <code>iv_identify_container()</code>, an iv with the same type as <code>x</code>.
</p>
</li>
<li><p> For <code>iv_locate_containers()</code>, a two column data frame with a <code>key</code> column
containing the result of <code>iv_containers()</code> and a <code>loc</code> list-column containing
integer vectors.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
library(tidyr)

x &lt;- iv_pairs(
  c(4, 6),
  c(1, 5),
  c(2, 3),
  c(NA, NA),
  c(NA, NA),
  c(9, 12),
  c(9, 14)
)
x

# Containers are intervals which aren't contained in any other interval.
# They are always returned in ascending order.
# If any missing intervals are present, a single one is retained.
iv_containers(x)

# `iv_identify_container()` is useful alongside `group_by()` and
# `summarize()` if you know that each interval is contained within exactly
# 1 container
df &lt;- tibble(x = x)
df &lt;- mutate(df, container = iv_identify_container(x))
df

df %&gt;%
  group_by(container) %&gt;%
  summarize(n = n())

# If any interval is contained within multiple containers,
# then you can't use `iv_identify_container()`
y &lt;- c(x, iv_pairs(c(0, 3), c(8, 13)))
y

try(iv_identify_container(y))

# Instead, use `iv_identify_containers()` to identify every container
# that each interval falls in
df &lt;- tibble(y = y, container = iv_identify_containers(y))
df

# You can use `tidyr::unchop()` to see the containers that each interval
# falls in
df %&gt;%
  mutate(row = row_number(), .before = 1) %&gt;%
  unchop(container)

# A more programmatic interface to `iv_identify_containers()` is
# `iv_locate_containers()`, which returns the containers you get from
# `iv_containers()` alongside the locations in the input that they contain.
iv_locate_containers(y)
</code></pre>

<hr>
<h2 id='iv-genericity'>Proxy and restore</h2><span id='topic+iv-genericity'></span><span id='topic+iv_proxy'></span><span id='topic+iv_restore'></span>

<h3>Description</h3>


<ul>
<li> <p><code>iv_proxy()</code> is an S3 generic which allows you to write S3 methods for
iv extension types to ensure that they are treated like iv objects. The
input will be your iv extension object, <code>x</code>, and the return value should
be an iv object.
</p>
</li>
<li> <p><code>iv_restore()</code> is an S3 generic that dispatches off <code>to</code> that allows you
to restore a proxied iv extension type back to its original type. The
inputs will be a bare iv object, <code>x</code>, and your original iv extension
object, <code>to</code>, and the return value should correspond to <code>x</code> restored to
the type of <code>to</code>, if possible.
</p>
</li></ul>

<p>You typically <em>don't</em> need to create an <code>iv_proxy()</code> method if your class
directly extends iv through the <code>class</code> argument of <code><a href="#topic+new_iv">new_iv()</a></code>. You only
need to implement this if your class has a different structure than a
typical iv object. In particular, if <code>vctrs::field(x, "start")</code> and
<code>vctrs::field(x, "end")</code> don't return the <code>start</code> and <code>end</code> of the interval
vector respectively, then you probably need an <code>iv_proxy()</code> method.
</p>
<p>You typically <em>do</em> need an <code>iv_restore()</code> method for custom iv extensions.
If your class is simple, then you can generally just call your constructor,
like <code>new_my_iv()</code>, to restore the class and any additional attributes that
might be required. If your class doesn't use <code><a href="#topic+new_iv">new_iv()</a></code>, then an
<code>iv_restore()</code> method is mandatory, as this is one of the ways that ivs
detects that your class is compatible with ivs.
</p>
<p>This system allows you to use any <code style="white-space: pre;">&#8288;iv_*()&#8288;</code> function on your iv extension
object without having to define S3 methods for all of them.
</p>
<p>Note that the default method for <code>iv_proxy()</code> returns its input unchanged,
even if it isn't an iv. Each <code style="white-space: pre;">&#8288;iv_*()&#8288;</code> function does separate checking to
ensure that the proxy is a valid iv, or implements an alternate behavior if
no proxy method is implemented. In contrast, <code>iv_restore()</code> will error if a
method for <code>to</code> isn't registered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_proxy(x, ...)

iv_restore(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv-genericity_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>A vector.</p>
</td></tr>
<tr><td><code id="iv-genericity_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="iv-genericity_+3A_to">to</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The original vector to restore to.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>iv_proxy()</code> should return an iv object for further manipulation.
</p>
</li>
<li> <p><code>iv_restore()</code> should return an object of type <code>to</code>, if possible. In
some cases, it may be required to fall back to returning an iv object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (FALSE) {
# Registering S3 methods outside of a package doesn't always work quite
# right (like on the pkgdown site), so this code should only be run by a
# user reading the manual. If that is you, fear not! It should run just fine
# in your console.

library(vctrs)

new_nested_iv &lt;- function(iv) {
  fields &lt;- list(iv = iv)
  new_rcrd(fields, class = "nested_iv")
}

format.nested_iv &lt;- function(x, ...) {
  format(field(x, "iv"))
}

iv_proxy.nested_iv &lt;- function(x, ...) {
  field(x, "iv")
}

iv_restore.nested_iv &lt;- function(x, to, ...) {
  new_nested_iv(x)
}

iv &lt;- new_iv(c(1, 5), c(2, 7))

x &lt;- new_nested_iv(iv)
x

# Proxies, then accesses the `start` field
iv_start(x)

# Proxies, computes the complement to generate an iv,
# then restores to the original type
iv_set_complement(x)

}
</code></pre>

<hr>
<h2 id='iv-groups'>Group overlapping intervals</h2><span id='topic+iv-groups'></span><span id='topic+iv_groups'></span><span id='topic+iv_identify_group'></span><span id='topic+iv_locate_groups'></span>

<h3>Description</h3>

<p>This family of functions revolves around grouping overlapping intervals
within a single iv. When multiple overlapping intervals are grouped together
they result in a wider interval containing the smallest <code><a href="#topic+iv_start">iv_start()</a></code> and the
largest <code><a href="#topic+iv_end">iv_end()</a></code> of the overlaps.
</p>

<ul>
<li> <p><code>iv_groups()</code> merges all overlapping intervals found within <code>x</code>. The
resulting intervals are known as the &quot;groups&quot; of <code>x</code>.
</p>
</li>
<li> <p><code>iv_identify_group()</code> identifies the group that the current interval of <code>x</code>
falls in. This is particularly useful alongside <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.
</p>
</li>
<li> <p><code>iv_locate_groups()</code> returns a two column data frame with a <code>key</code> column
containing the result of <code>iv_groups()</code> and a <code>loc</code> list-column containing
integer vectors that map each interval in <code>x</code> to the group that it falls in.
</p>
</li></ul>

<p>Optionally, you can choose <em>not</em> to group abutting intervals together with
<code>abutting = FALSE</code>, which can be useful if you'd like to retain those
boundaries.
</p>


<h4>Minimal interval vectors</h4>

<p><code>iv_groups()</code> is particularly useful because it can generate a <em>minimal</em>
interval vector, which covers the range of an interval vector in the most
compact form possible. In particular, a minimal interval vector:
</p>

<ul>
<li><p> Has no overlapping intervals
</p>
</li>
<li><p> Has no abutting intervals
</p>
</li>
<li><p> Is ordered on both <code>start</code> and <code>end</code>
</p>
</li></ul>

<p>A minimal interval vector is allowed to have a single missing interval,
which is located at the end of the vector.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>iv_groups(x, ..., abutting = TRUE)

iv_identify_group(x, ..., abutting = TRUE)

iv_locate_groups(x, ..., abutting = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv-groups_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>An interval vector.</p>
</td></tr>
<tr><td><code id="iv-groups_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="iv-groups_+3A_abutting">abutting</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TRUE / FALSE]&#8288;</code>
</p>
<p>Should abutting intervals be grouped together?
</p>
<p>If <code>TRUE</code>, <code style="white-space: pre;">&#8288;[a, b)&#8288;</code> and <code style="white-space: pre;">&#8288;[b, c)&#8288;</code> will merge as <code style="white-space: pre;">&#8288;[a, c)&#8288;</code>. If <code>FALSE</code>, they
will be kept separate. To be a minimal interval vector, all abutting
intervals must be grouped together.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>iv_groups()</code>, an iv with the same type as <code>x</code>.
</p>
</li>
<li><p> For <code>iv_identify_group()</code>, an iv with the same type and size as <code>x</code>.
</p>
</li>
<li><p> For <code>iv_locate_groups()</code>, a two column data frame with a <code>key</code> column
containing the result of <code>iv_groups()</code> and a <code>loc</code> list-column containing
integer vectors.
</p>
</li></ul>



<h3>Graphical Representation</h3>

<p>Graphically, generating groups looks like:
</p>
<p><img src="../help/figures/groups.png" alt="groups.png" />
</p>
<p>With <code>abutting = FALSE</code>, intervals that touch aren't grouped:
</p>
<p><img src="../help/figures/groups-abutting-keep.png" alt="groups-abutting-keep.png" />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

x &lt;- iv_pairs(
  c(1, 5),
  c(2, 3),
  c(NA, NA),
  c(5, 6),
  c(NA, NA),
  c(9, 12),
  c(11, 14)
)
x

# Grouping removes all redundancy while still covering the full range
# of values that were originally represented. If any missing intervals
# are present, a single one is retained.
iv_groups(x)

# Abutting intervals are typically grouped together, but you can choose not
# to group them if you want to retain those boundaries
iv_groups(x, abutting = FALSE)

# `iv_identify_group()` is useful alongside `group_by()` and `summarize()`
df &lt;- tibble(x = x)
df &lt;- mutate(df, u = iv_identify_group(x))
df

df %&gt;%
  group_by(u) %&gt;%
  summarize(n = n())

# The real workhorse here is `iv_locate_groups()`, which returns
# the groups and information on which observations in `x` fall in which
# group
iv_locate_groups(x)
</code></pre>

<hr>
<h2 id='iv-set-pairwise'>Pairwise set operations</h2><span id='topic+iv-set-pairwise'></span><span id='topic+iv_pairwise_set_complement'></span><span id='topic+iv_pairwise_set_union'></span><span id='topic+iv_pairwise_set_intersect'></span><span id='topic+iv_pairwise_set_difference'></span><span id='topic+iv_pairwise_set_symmetric_difference'></span>

<h3>Description</h3>

<p>This family of functions performs <em>pairwise</em> set operations on two ivs.
Pairwise refers to the fact that the i-th interval of <code>x</code> is going to be
compared against the i-th interval of <code>y</code>. This is in contrast to their
counterparts, like <code><a href="#topic+iv_set_union">iv_set_union()</a></code>, which treat the entire vector of <code>x</code>
as a single set to be compared against all of <code>y</code>.
</p>
<p>The descriptions of these operations are the same as their non-pairwise
counterparts, but the ones here also have a number of restrictions due to
the fact that each must return an output that is the same size as its inputs:
</p>

<ul>
<li><p> For <code>iv_pairwise_set_complement()</code>, <code>x[i]</code> and <code>y[i]</code> can't overlap or
abut, as this would generate an empty complement.
</p>
</li>
<li><p> For <code>iv_pairwise_set_union()</code>, <code>x[i]</code> and <code>y[i]</code> can't be separated by a
gap. Use <code><a href="#topic+iv_pairwise_span">iv_pairwise_span()</a></code> if you want to force gaps to be filled
anyways.
</p>
</li>
<li><p> For <code>iv_pairwise_set_intersect()</code>, <code>x[i]</code> and <code>y[i]</code> must overlap,
otherwise an empty interval would be generated.
</p>
</li>
<li><p> For <code>iv_pairwise_set_difference()</code>, <code>x[i]</code> can't be completely contained
within <code>y[i]</code>, as that would generate an empty interval. Additionally,
<code>y[i]</code> can't be completely contained within <code>x[i]</code>, as that would result
in two distinct intervals for a single observation.
</p>
</li>
<li><p> For <code>iv_pairwise_set_symmetric_difference()</code>, <code>x[i]</code> and <code>y[i]</code> must share
exactly one endpoint, otherwise an empty interval or two distinct intervals
would be generated.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>iv_pairwise_set_complement(x, y)

iv_pairwise_set_union(x, y)

iv_pairwise_set_intersect(x, y)

iv_pairwise_set_difference(x, y)

iv_pairwise_set_symmetric_difference(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv-set-pairwise_+3A_x">x</code>, <code id="iv-set-pairwise_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>A pair of interval vectors.
</p>
<p>These will be cast to the same type, and recycled against each other.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iv the same size and type as <code>x</code> and <code>y</code>.
</p>


<h3>See Also</h3>

<p>The non-pairwise versions of these functions, such as
<code><a href="#topic+iv_set_union">iv_set_union()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iv_pairs(c(1, 3), c(6, 8))
y &lt;- iv_pairs(c(5, 7), c(2, 3))

iv_pairwise_set_complement(x, y)

z &lt;- iv_pairs(c(2, 5), c(4, 7))

iv_pairwise_set_union(x, z)

# Can't take the union when there are gaps
try(iv_pairwise_set_union(x, y))

# But you can force a union across gaps with `iv_pairwise_span()`
iv_pairwise_span(x, y)

iv_pairwise_set_intersect(x, z)

# Can't take an intersection of non-overlapping intervals
try(iv_pairwise_set_intersect(x, y))

iv_pairwise_set_difference(x, z)

# The pairwise symmetric difference function is fairly strict,
# and is only well defined when exactly one of the interval endpoints match
w &lt;- iv_pairs(c(1, 6), c(7, 8))
iv_pairwise_set_symmetric_difference(x, w)
</code></pre>

<hr>
<h2 id='iv-set-pairwise-deprecated'>Pairwise set operations</h2><span id='topic+iv-set-pairwise-deprecated'></span><span id='topic+iv_pairwise_complement'></span><span id='topic+iv_pairwise_union'></span><span id='topic+iv_pairwise_intersect'></span><span id='topic+iv_pairwise_difference'></span><span id='topic+iv_pairwise_symmetric_difference'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions are deprecated in favor of their <code>set_</code> prefixed equivalents.
</p>

<ul>
<li> <p><code>iv_pairwise_complement()</code> -&gt; <code><a href="#topic+iv_pairwise_set_complement">iv_pairwise_set_complement()</a></code>
</p>
</li>
<li> <p><code>iv_pairwise_union()</code> -&gt; <code><a href="#topic+iv_pairwise_set_union">iv_pairwise_set_union()</a></code>
</p>
</li>
<li> <p><code>iv_pairwise_intersect()</code> -&gt; <code><a href="#topic+iv_pairwise_set_intersect">iv_pairwise_set_intersect()</a></code>
</p>
</li>
<li> <p><code>iv_pairwise_difference()</code> -&gt; <code><a href="#topic+iv_pairwise_set_difference">iv_pairwise_set_difference()</a></code>
</p>
</li>
<li> <p><code>iv_pairwise_symmetric_difference()</code> -&gt; <code><a href="#topic+iv_pairwise_set_symmetric_difference">iv_pairwise_set_symmetric_difference()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>iv_pairwise_complement(x, y)

iv_pairwise_union(x, y)

iv_pairwise_intersect(x, y)

iv_pairwise_difference(x, y)

iv_pairwise_symmetric_difference(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv-set-pairwise-deprecated_+3A_x">x</code>, <code id="iv-set-pairwise-deprecated_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>A pair of interval vectors.
</p>
<p>These will be cast to the same type, and recycled against each other.</p>
</td></tr>
</table>

<hr>
<h2 id='iv-sets'>Set operations</h2><span id='topic+iv-sets'></span><span id='topic+iv_set_complement'></span><span id='topic+iv_set_union'></span><span id='topic+iv_set_intersect'></span><span id='topic+iv_set_difference'></span><span id='topic+iv_set_symmetric_difference'></span>

<h3>Description</h3>

<p>This family of functions treats ivs as sets. They always compute
the <a href="#topic+iv_groups">minimal</a> iv of each input and return a minimal iv.
</p>

<ul>
<li> <p><code>iv_set_complement()</code> takes the complement of the intervals in an iv. By
default, the minimum and maximum of the inputs define the bounds to take
the complement over, but this can be adjusted with <code>lower</code> and <code>upper</code>.
Missing intervals are always dropped in the complement.
</p>
</li>
<li> <p><code>iv_set_union()</code> answers the question, &quot;Which intervals are in <code>x</code> or <code>y</code>?&quot;
It is equivalent to combining the two vectors together and then calling
<code>iv_groups()</code>.
</p>
</li>
<li> <p><code>iv_set_intersect()</code> answers the question, &quot;Which intervals are in <code>x</code> and
<code>y</code>?&quot;
</p>
</li>
<li> <p><code>iv_set_difference()</code> answers the question, &quot;Which intervals are in <code>x</code> but
not <code>y</code>?&quot; Note that this is an asymmetrical difference.
</p>
</li>
<li> <p><code>iv_set_symmetric_difference()</code> answers the question, &quot;Which intervals are
in <code>x</code> or <code>y</code> but not both?&quot;
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>iv_set_complement(x, ..., lower = NULL, upper = NULL)

iv_set_union(x, y)

iv_set_intersect(x, y)

iv_set_difference(x, y)

iv_set_symmetric_difference(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv-sets_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>An interval vector.</p>
</td></tr>
<tr><td><code id="iv-sets_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="iv-sets_+3A_lower">lower</code>, <code id="iv-sets_+3A_upper">upper</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(1) / NULL]&#8288;</code>
</p>
<p>Bounds for the universe over which to compute the complement. These should
have the same type as the element type of the interval vector. It is
often useful to expand the universe to, say, <code>-Inf</code> to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="iv-sets_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>An interval vector.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>iv_set_complement()</code>, a vector of the same type as <code>x</code> containing the
complement.
</p>
</li>
<li><p> For all other set operations, a vector of the same type as the common type
of <code>x</code> and <code>y</code> containing the result.
</p>
</li></ul>



<h3>Graphical Representation</h3>

<p>Graphically, generating the complement looks like:
</p>
<p><img src="../help/figures/complement.png" alt="complement.png" />
</p>
<p>If you were to set <code>upper = 20</code> with these intervals, then you'd get one more
interval in the complement.
</p>
<p><img src="../help/figures/complement-upper.png" alt="complement-upper.png" />
</p>
<p>Generating the intersection between two ivs looks like:
</p>
<p><img src="../help/figures/intersect.png" alt="intersect.png" />
</p>


<h3>See Also</h3>

<p>The <em>pairwise</em> versions of these functions, such as
<code><a href="#topic+iv_pairwise_set_union">iv_pairwise_set_union()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iv_pairs(
  c(10, 12),
  c(0, 5),
  c(NA, NA),
  c(3, 6),
  c(-5, -2),
  c(NA, NA)
)
x

y &lt;- iv_pairs(
  c(2, 7),
  c(NA, NA),
  c(-3, -1),
  c(14, 15)
)
y

# Complement contains any values from `[-5, 12)` that aren't represented
# in these intervals. Missing intervals are dropped.
iv_set_complement(x)

# Expand out the "universe" of possible values
iv_set_complement(x, lower = -Inf)
iv_set_complement(x, lower = -Inf, upper = Inf)

# Which intervals are in x or y?
iv_set_union(x, y)

# Which intervals are in x and y?
iv_set_intersect(x, y)

# Which intervals are in x but not y?
iv_set_difference(x, y)

# Which intervals are in y but not x?
iv_set_difference(y, x)

# Missing intervals in x are kept if there aren't missing intervals in y
iv_set_difference(x, iv(1, 2))

# Which intervals are in x or y but not both?
iv_set_symmetric_difference(x, y)

# Missing intervals will be kept if they only appear on one side
iv_set_symmetric_difference(x, iv(1, 2))
iv_set_symmetric_difference(iv(1, 2), x)
</code></pre>

<hr>
<h2 id='iv-sets-deprecated'>Set operations</h2><span id='topic+iv-sets-deprecated'></span><span id='topic+iv_complement'></span><span id='topic+iv_union'></span><span id='topic+iv_intersect'></span><span id='topic+iv_difference'></span><span id='topic+iv_symmetric_difference'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions are deprecated in favor of their <code>set_</code> prefixed equivalents.
</p>

<ul>
<li> <p><code>iv_complement()</code> -&gt; <code><a href="#topic+iv_set_complement">iv_set_complement()</a></code>
</p>
</li>
<li> <p><code>iv_union()</code> -&gt; <code><a href="#topic+iv_set_union">iv_set_union()</a></code>
</p>
</li>
<li> <p><code>iv_intersect()</code> -&gt; <code><a href="#topic+iv_set_intersect">iv_set_intersect()</a></code>
</p>
</li>
<li> <p><code>iv_difference()</code> -&gt; <code><a href="#topic+iv_set_difference">iv_set_difference()</a></code>
</p>
</li>
<li> <p><code>iv_symmetric_difference()</code> -&gt; <code><a href="#topic+iv_set_symmetric_difference">iv_set_symmetric_difference()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>iv_complement(x, ..., lower = NULL, upper = NULL)

iv_union(x, y)

iv_intersect(x, y)

iv_difference(x, y)

iv_symmetric_difference(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv-sets-deprecated_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>An interval vector.</p>
</td></tr>
<tr><td><code id="iv-sets-deprecated_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="iv-sets-deprecated_+3A_lower">lower</code>, <code id="iv-sets-deprecated_+3A_upper">upper</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(1) / NULL]&#8288;</code>
</p>
<p>Bounds for the universe over which to compute the complement. These should
have the same type as the element type of the interval vector. It is
often useful to expand the universe to, say, <code>-Inf</code> to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="iv-sets-deprecated_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>An interval vector.</p>
</td></tr>
</table>

<hr>
<h2 id='iv-splits'>Splits</h2><span id='topic+iv-splits'></span><span id='topic+iv_splits'></span><span id='topic+iv_identify_splits'></span><span id='topic+iv_locate_splits'></span>

<h3>Description</h3>

<p>This family of functions revolves around splitting an iv on its endpoints,
which results in a new iv that is entirely disjoint (i.e. non-overlapping).
The intervals in the resulting iv are known as &quot;splits&quot;.
</p>

<ul>
<li> <p><code>iv_splits()</code> computes the disjoint splits for <code>x</code>.
</p>
</li>
<li> <p><code>iv_identify_splits()</code> identifies the splits that correspond to each
interval in <code>x</code>. It replaces <code>x</code> with a list of the same size where each
element of the list contains the splits that the corresponding interval in
<code>x</code> overlaps. This is particularly useful alongside <code><a href="tidyr.html#topic+unnest">tidyr::unnest()</a></code>.
</p>
</li>
<li> <p><code>iv_locate_splits()</code> returns a two column data frame with a <code>key</code> column
containing the result of <code>iv_splits()</code> and a <code>loc</code> list-column containing
integer vectors that map each interval in <code>x</code> to the splits that it overlaps.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>iv_splits(x, ..., on = NULL)

iv_identify_splits(x, ..., on = NULL)

iv_locate_splits(x, ..., on = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iv-splits_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>An interval vector.</p>
</td></tr>
<tr><td><code id="iv-splits_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="iv-splits_+3A_on">on</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector / NULL]&#8288;</code>
</p>
<p>An optional vector of additional values to split on.
</p>
<p>This should have the same type as <code>iv_start(x)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>iv_splits()</code>, an iv with the same type as <code>x</code>.
</p>
</li>
<li><p> For <code>iv_identify_splits()</code>, a list-of containing ivs with the same size as
<code>x</code>.
</p>
</li>
<li><p> For <code>iv_locate_splits()</code>, a two column data frame with a <code>key</code> column
of the same type as <code>x</code> and <code>loc</code> list-column containing integer vectors.
</p>
</li></ul>



<h3>Graphical Representation</h3>

<p>Graphically, generating splits looks like:
</p>
<p><img src="../help/figures/splits.png" alt="splits.png" />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)
library(dplyr)

# Guests to a party and their arrival/departure times
guests &lt;- tibble(
  arrive = as.POSIXct(
    c("2008-05-20 19:30:00", "2008-05-20 20:10:00", "2008-05-20 22:15:00"),
    tz = "UTC"
  ),
  depart = as.POSIXct(
    c("2008-05-20 23:00:00", "2008-05-21 00:00:00", "2008-05-21 00:30:00"),
    tz = "UTC"
  ),
  name = list(
    c("Mary", "Harry"),
    c("Diana", "Susan"),
    "Peter"
  )
)

guests &lt;- unnest(guests, name) %&gt;%
  mutate(iv = iv(arrive, depart), .keep = "unused")

guests

# You can determine the disjoint intervals at which people
# arrived/departed with `iv_splits()`
iv_splits(guests$iv)

# Say you'd like to determine who was at the party at any given time
# throughout the night
guests &lt;- mutate(guests, splits = iv_identify_splits(iv))
guests

# Unnest the splits to generate disjoint intervals for each guest
guests &lt;- guests %&gt;%
  unnest(splits) %&gt;%
  select(name, splits)

guests

# Tabulate who was there at any given time
guests %&gt;%
  summarise(n = n(), who = list(name), .by = splits)

# ---------------------------------------------------------------------------

x &lt;- iv_pairs(c(1, 5), c(4, 9), c(12, 15))
x

# You can provide additional singular values to split on with `on`
iv_splits(x, on = c(2, 13))
</code></pre>

<hr>
<h2 id='new_iv'>Construct a new iv</h2><span id='topic+new_iv'></span>

<h3>Description</h3>

<p><code>new_iv()</code> is a developer focused function for creating a new interval
vector. It does minimal checks on the inputs, for performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_iv(start, end, ..., class = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_iv_+3A_start">start</code>, <code id="new_iv_+3A_end">end</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>A pair of vectors to represent the bounds of the intervals.
</p>
<p>To be a valid interval vector, <code>start</code> must be strictly less than <code>end</code>,
or both <code>start</code> and <code>end</code> must be a missing value.</p>
</td></tr>
<tr><td><code id="new_iv_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[name-value pairs]&#8288;</code>
</p>
<p>Additional named attributes to attach to the result.</p>
</td></tr>
<tr><td><code id="new_iv_+3A_class">class</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code>
</p>
<p>The name of the subclass to create.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new iv object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_iv(1, 2)
</code></pre>

<hr>
<h2 id='relation-count'>Count relationships between two ivs</h2><span id='topic+relation-count'></span><span id='topic+iv_count_overlaps'></span><span id='topic+iv_count_precedes'></span><span id='topic+iv_count_follows'></span>

<h3>Description</h3>

<p>This family of functions counts different types of relationships between
two ivs. It works similar to <code><a href="base.html#topic+match">base::match()</a></code>, where <code>needles[i]</code> checks for
a relationship in all of <code>haystack</code>.
</p>

<ul>
<li> <p><code>iv_count_overlaps()</code> counts instances of a specific <code>type</code> of overlap
between the two ivs.
</p>
</li>
<li> <p><code>iv_count_precedes()</code> counts instances when <code>needles[i]</code> precedes (i.e.
comes before) any interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>iv_count_follows()</code> counts instances when <code>needles[i]</code> follows (i.e.
comes after) any interval in <code>haystack</code>.
</p>
</li></ul>

<p>These functions return an integer vector the same size as <code>needles</code>
containing a count of the times a particular relationship between the <code>i</code>-th
interval of <code>needles</code> and any interval of <code>haystack</code> occurred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_count_overlaps(
  needles,
  haystack,
  ...,
  type = "any",
  missing = "equals",
  no_match = 0L
)

iv_count_precedes(
  needles,
  haystack,
  ...,
  closest = FALSE,
  missing = "equals",
  no_match = 0L
)

iv_count_follows(
  needles,
  haystack,
  ...,
  closest = FALSE,
  missing = "equals",
  no_match = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relation-count_+3A_needles">needles</code>, <code id="relation-count_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>Interval vectors used for relation matching.
</p>

<ul>
<li><p> Each element of <code>needles</code> represents the interval to search for.
</p>
</li>
<li> <p><code>haystack</code> represents the intervals to search in.
</p>
</li></ul>

<p>Prior to comparison, <code>needles</code> and <code>haystack</code> are coerced to the same type.</p>
</td></tr>
<tr><td><code id="relation-count_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="relation-count_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The type of relationship to find. One of:
</p>

<ul>
<li> <p><code>"any"</code>: Finds any overlap whatsoever between an interval in <code>needles</code>
and an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"within"</code>: Finds when an interval in <code>needles</code> is completely within
(or equal to) an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"contains"</code>: Finds when an interval in <code>needles</code> completely contains
(or equals) an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"equals"</code>: Finds when an interval in <code>needles</code> is exactly equal to
an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"starts"</code>: Finds when the start of an interval in <code>needles</code> matches the
start of an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"ends"</code>: Finds when the end of an interval in <code>needles</code> matches the end
of an interval in <code>haystack</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="relation-count_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / "equals" / "error"]&#8288;</code>
</p>
<p>Handling of missing intervals in <code>needles</code>.
</p>

<ul>
<li> <p><code>"equals"</code> considers missing intervals in <code>needles</code> as exactly equal
to missing intervals in <code>haystack</code> when determining if there is a
matching relationship between them.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any intervals in <code>needles</code> are missing.
</p>
</li>
<li><p> If a single integer value is provided, this represents the count returned
for a missing interval in <code>needles</code>. Use <code>0L</code> to force missing intervals
to never match.
</p>
</li></ul>
</td></tr>
<tr><td><code id="relation-count_+3A_no_match">no_match</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / "error"]&#8288;</code>
</p>
<p>Handling of <code>needles</code> without a match.
</p>

<ul>
<li> <p><code>"error"</code> throws an error if any needles have zero matches.
</p>
</li>
<li><p> If a single integer is provided, this represents the count returned for
a needle with zero matches. The default value gives unmatched needles
a count of <code>0L</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="relation-count_+3A_closest">closest</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TRUE / FALSE]&#8288;</code>
</p>
<p>Should only the closest relationship be returned?
</p>
<p>If <code>TRUE</code>, will only return the closest interval(s) in <code>haystack</code> that
the current value of <code>needles</code> either precedes or follows. Note that
multiple intervals can still be returned if there are ties, which can
be resolved using <code>multiple</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector the same size as <code>needles</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+relation-locate">Locating relationships</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vctrs)

x &lt;- iv_pairs(
  as.Date(c("2019-01-05", "2019-01-10")),
  as.Date(c("2019-01-07", "2019-01-15")),
  as.Date(c("2019-01-20", "2019-01-31"))
)

y &lt;- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-04", "2019-01-08")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-10", "2019-01-20")),
  as.Date(c("2019-01-15", "2019-01-20"))
)

x
y

# Count the number of times `x` overlaps `y` at all
iv_count_overlaps(x, y)

# Count the number of times `y` is within an interval in `x`
iv_count_overlaps(y, x, type = "within")

# Count the number of times `x` precedes `y`
iv_count_precedes(x, y)

# ---------------------------------------------------------------------------

a &lt;- iv(c(1, NA), c(2, NA))
b &lt;- iv(c(NA, NA), c(NA, NA))

# Missing intervals are seen as exactly equal by default, so they are
# considered to overlap
iv_count_overlaps(a, b)

# If you'd like missing intervals to be treated as unmatched, set
# `missing = 0L`
iv_count_overlaps(a, b, missing = 0L)

# If you'd like to propagate missing intervals, set `missing = NA`
iv_count_overlaps(a, b, missing = NA)
</code></pre>

<hr>
<h2 id='relation-detect'>Detect a relationship between two ivs</h2><span id='topic+relation-detect'></span><span id='topic+iv_overlaps'></span><span id='topic+iv_precedes'></span><span id='topic+iv_follows'></span>

<h3>Description</h3>

<p>This family of functions detects different types of relationships between
two ivs. It works similar to <a href="base.html#topic+match">base::%in%</a>, where <code>needles[i]</code> checks for
a relationship in all of <code>haystack</code>.
</p>

<ul>
<li> <p><code>iv_overlaps()</code> detects a specific <code>type</code> of overlap between the two ivs.
</p>
</li>
<li> <p><code>iv_precedes()</code> detects if <code>needles[i]</code> precedes (i.e. comes before) any
interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>iv_follows()</code> detects if <code>needles[i]</code> follows (i.e. comes after) any
interval in <code>haystack</code>.
</p>
</li></ul>

<p>These functions return a logical vector the same size as <code>needles</code> containing
<code>TRUE</code> if the interval in <code>needles</code> has a matching relationship in
<code>haystack</code> and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_overlaps(needles, haystack, ..., type = "any", missing = "equals")

iv_precedes(needles, haystack, ..., missing = "equals")

iv_follows(needles, haystack, ..., missing = "equals")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relation-detect_+3A_needles">needles</code>, <code id="relation-detect_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>Interval vectors used for relation matching.
</p>

<ul>
<li><p> Each element of <code>needles</code> represents the interval to search for.
</p>
</li>
<li> <p><code>haystack</code> represents the intervals to search in.
</p>
</li></ul>

<p>Prior to comparison, <code>needles</code> and <code>haystack</code> are coerced to the same type.</p>
</td></tr>
<tr><td><code id="relation-detect_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="relation-detect_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The type of relationship to find. One of:
</p>

<ul>
<li> <p><code>"any"</code>: Finds any overlap whatsoever between an interval in <code>needles</code>
and an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"within"</code>: Finds when an interval in <code>needles</code> is completely within
(or equal to) an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"contains"</code>: Finds when an interval in <code>needles</code> completely contains
(or equals) an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"equals"</code>: Finds when an interval in <code>needles</code> is exactly equal to
an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"starts"</code>: Finds when the start of an interval in <code>needles</code> matches the
start of an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"ends"</code>: Finds when the end of an interval in <code>needles</code> matches the end
of an interval in <code>haystack</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="relation-detect_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1) / "equals" / "error"]&#8288;</code>
</p>
<p>Handling of missing intervals in <code>needles</code>.
</p>

<ul>
<li> <p><code>"equals"</code> considers missing intervals in <code>needles</code> as exactly equal
to missing intervals in <code>haystack</code> when determining if there is a
matching relationship between them. Matched missing intervals in
<code>needles</code> result in a <code>TRUE</code> value in the result, and unmatched missing
intervals result in a <code>FALSE</code> value.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any intervals in <code>needles</code> are missing.
</p>
</li>
<li><p> If a single logical value is provided, this represents the value returned
in the result for intervals in <code>needles</code> that are missing. You can force
missing intervals to be unmatched by setting this to <code>FALSE</code>, and you
can force them to be propagated by setting this to <code>NA</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same size as <code>needles</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+relation-locate">Locating relationships</a>
</p>
<p><a href="#topic+relation-detect-pairwise">Detecting relationships pairwise</a>
</p>
<p><a href="#topic+allen-relation-locate">Locating relations from Allen's Interval Algebra</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vctrs)

x &lt;- iv_pairs(
  as.Date(c("2019-01-05", "2019-01-10")),
  as.Date(c("2019-01-07", "2019-01-15")),
  as.Date(c("2019-01-20", "2019-01-31"))
)

y &lt;- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-04", "2019-01-08")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-10", "2019-01-20")),
  as.Date(c("2019-01-15", "2019-01-20"))
)

x
y

# Does each interval of `x` overlap `y` at all?
iv_overlaps(x, y)

# Which intervals of `y` are within an interval in `x`?
iv_overlaps(y, x, type = "within")

# ---------------------------------------------------------------------------

a &lt;- iv(c(1, NA), c(2, NA))
b &lt;- iv(c(NA, NA), c(NA, NA))

# Missing intervals are seen as exactly equal by default, so they are
# considered to overlap
iv_overlaps(a, b)

# If you'd like missing intervals to be treated as unmatched, set
# `missing = FALSE`
iv_overlaps(a, b, missing = FALSE)

# If you'd like to propagate missing intervals, set `missing = NA`
iv_overlaps(a, b, missing = NA)
</code></pre>

<hr>
<h2 id='relation-detect-pairwise'>Pairwise detect a relationship between two ivs</h2><span id='topic+relation-detect-pairwise'></span><span id='topic+iv_pairwise_overlaps'></span><span id='topic+iv_pairwise_precedes'></span><span id='topic+iv_pairwise_follows'></span>

<h3>Description</h3>

<p>This family of functions detects different types of relationships between
two ivs <em>pairwise</em>, where pairwise means that the i-th interval of
<code>x</code> is compared against the i-th interval of <code>y</code>. This is in contrast to
<code><a href="#topic+iv_overlaps">iv_overlaps()</a></code>, which works more like <a href="base.html#topic+match">base::%in%</a>.
</p>

<ul>
<li> <p><code>iv_pairwise_overlaps()</code> detects a specific <code>type</code> of overlap
between the i-th interval of <code>x</code> and the i-th interval of <code>y</code>.
</p>
</li>
<li> <p><code>iv_pairwise_precedes()</code> detects if the i-th interval of <code>x</code>
precedes (i.e. comes before) the i-th interval of <code>y</code>.
</p>
</li>
<li> <p><code>iv_pairwise_follows()</code> detects if the i-th interval of <code>x</code>
follows (i.e. comes after) the i-th interval of <code>y</code>.
</p>
</li></ul>

<p>These functions return a logical vector the same size as the common size of
<code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_pairwise_overlaps(x, y, ..., type = "any")

iv_pairwise_precedes(x, y)

iv_pairwise_follows(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relation-detect-pairwise_+3A_x">x</code>, <code id="relation-detect-pairwise_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>A pair of interval vectors.
</p>
<p>These will be recycled against each other and cast to the same type.</p>
</td></tr>
<tr><td><code id="relation-detect-pairwise_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="relation-detect-pairwise_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The type of relationship to find. One of:
</p>

<ul>
<li> <p><code>"any"</code>: Finds any overlap whatsoever between an interval in <code>needles</code>
and an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"within"</code>: Finds when an interval in <code>needles</code> is completely within
(or equal to) an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"contains"</code>: Finds when an interval in <code>needles</code> completely contains
(or equals) an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"equals"</code>: Finds when an interval in <code>needles</code> is exactly equal to
an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"starts"</code>: Finds when the start of an interval in <code>needles</code> matches the
start of an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"ends"</code>: Finds when the end of an interval in <code>needles</code> matches the end
of an interval in <code>haystack</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same size as the common size of <code>x</code> and <code>y</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+relation-locate">Locating relationships</a>
</p>
<p><a href="#topic+relation-detect">Detecting relationships</a>
</p>
<p><a href="#topic+allen-relation-locate">Locating relations from Allen's Interval Algebra</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vctrs)

x &lt;- iv_pairs(
  as.Date(c("2019-01-05", "2019-01-10")),
  as.Date(c("2019-01-07", "2019-01-15")),
  as.Date(c("2019-01-20", "2019-01-31"))
)

y &lt;- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-18", "2019-01-21"))
)

x
y

# Does the i-th interval of `x` overlap the i-th interval of `y`?
iv_pairwise_overlaps(x, y)

# Does the i-th interval of `x` contain the i-th interval of `y`?
iv_pairwise_overlaps(x, y, type = "contains")

# Does the i-th interval of `x` follow the i-th interval of `y`?
iv_pairwise_follows(x, y)

a &lt;- iv_pairs(c(1, 2), c(NA, NA), c(NA, NA))
b &lt;- iv_pairs(c(NA, NA), c(3, 4), c(NA, NA))

# Missing intervals always propagate
iv_pairwise_overlaps(a, b)
</code></pre>

<hr>
<h2 id='relation-locate'>Locate relationships between two ivs</h2><span id='topic+relation-locate'></span><span id='topic+iv_locate_overlaps'></span><span id='topic+iv_locate_precedes'></span><span id='topic+iv_locate_follows'></span>

<h3>Description</h3>

<p>This family of functions locates different types of relationships between
two ivs. It works similar to <code><a href="base.html#topic+match">base::match()</a></code>, where <code>needles[i]</code> checks for
a relationship in all of <code>haystack</code>. Unlike <code>match()</code>, <em>all</em> matching
relationships are returned, rather than just the first.
</p>

<ul>
<li> <p><code>iv_locate_overlaps()</code> locates a specific <code>type</code> of overlap between the two
ivs.
</p>
</li>
<li> <p><code>iv_locate_precedes()</code> locates where <code>needles[i]</code> precedes (i.e. comes
before) any interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>iv_locate_follows()</code> locates where <code>needles[i]</code> follows (i.e. comes
after) any interval in <code>haystack</code>.
</p>
</li></ul>

<p>These functions return a two column data frame. The <code>needles</code> column is an
integer vector pointing to locations in <code>needles</code>. The <code>haystack</code> column is
an integer vector pointing to locations in <code>haystack</code> with a matching
relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_locate_overlaps(
  needles,
  haystack,
  ...,
  type = "any",
  missing = "equals",
  no_match = NA_integer_,
  remaining = "drop",
  multiple = "all",
  relationship = "none"
)

iv_locate_precedes(
  needles,
  haystack,
  ...,
  closest = FALSE,
  missing = "equals",
  no_match = NA_integer_,
  remaining = "drop",
  multiple = "all",
  relationship = "none"
)

iv_locate_follows(
  needles,
  haystack,
  ...,
  closest = FALSE,
  missing = "equals",
  no_match = NA_integer_,
  remaining = "drop",
  multiple = "all",
  relationship = "none"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relation-locate_+3A_needles">needles</code>, <code id="relation-locate_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[iv]&#8288;</code>
</p>
<p>Interval vectors used for relation matching.
</p>

<ul>
<li><p> Each element of <code>needles</code> represents the interval to search for.
</p>
</li>
<li> <p><code>haystack</code> represents the intervals to search in.
</p>
</li></ul>

<p>Prior to comparison, <code>needles</code> and <code>haystack</code> are coerced to the same type.</p>
</td></tr>
<tr><td><code id="relation-locate_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="relation-locate_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The type of relationship to find. One of:
</p>

<ul>
<li> <p><code>"any"</code>: Finds any overlap whatsoever between an interval in <code>needles</code>
and an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"within"</code>: Finds when an interval in <code>needles</code> is completely within
(or equal to) an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"contains"</code>: Finds when an interval in <code>needles</code> completely contains
(or equals) an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"equals"</code>: Finds when an interval in <code>needles</code> is exactly equal to
an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"starts"</code>: Finds when the start of an interval in <code>needles</code> matches the
start of an interval in <code>haystack</code>.
</p>
</li>
<li> <p><code>"ends"</code>: Finds when the end of an interval in <code>needles</code> matches the end
of an interval in <code>haystack</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="relation-locate_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / "equals" / "drop" / "error"]&#8288;</code>
</p>
<p>Handling of missing intervals in <code>needles</code>.
</p>

<ul>
<li> <p><code>"equals"</code> considers missing intervals in <code>needles</code> as exactly equal
to missing intervals in <code>haystack</code> when determining if there is a
matching relationship between them.
</p>
</li>
<li> <p><code>"drop"</code> drops missing intervals in <code>needles</code> from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any intervals in <code>needles</code> are missing.
</p>
</li>
<li><p> If a single integer is provided, this represents the value returned in
the <code>haystack</code> column for intervals in <code>needles</code> that are missing.
</p>
</li></ul>
</td></tr>
<tr><td><code id="relation-locate_+3A_no_match">no_match</code></td>
<td>
<p>Handling of <code>needles</code> without a match.
</p>

<ul>
<li> <p><code>"drop"</code> drops <code>needles</code> with zero matches from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any <code>needles</code> have zero matches.
</p>
</li>
<li><p> If a single integer is provided, this represents the value returned in
the <code>haystack</code> column for values of <code>needles</code> that have zero matches. The
default represents an unmatched needle with <code>NA</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="relation-locate_+3A_remaining">remaining</code></td>
<td>
<p>Handling of <code>haystack</code> values that <code>needles</code> never matched.
</p>

<ul>
<li> <p><code>"drop"</code> drops remaining <code>haystack</code> values from the result.
Typically, this is the desired behavior if you only care when <code>needles</code>
has a match.
</p>
</li>
<li> <p><code>"error"</code> throws an error if there are any remaining <code>haystack</code>
values.
</p>
</li>
<li><p> If a single integer is provided (often <code>NA</code>), this represents the value
returned in the <code>needles</code> column for the remaining <code>haystack</code> values
that <code>needles</code> never matched. Remaining <code>haystack</code> values are always
returned at the end of the result.
</p>
</li></ul>
</td></tr>
<tr><td><code id="relation-locate_+3A_multiple">multiple</code></td>
<td>
<p>Handling of <code>needles</code> with multiple matches. For each needle:
</p>

<ul>
<li> <p><code>"all"</code> returns all matches detected in <code>haystack</code>.
</p>
</li>
<li> <p><code>"any"</code> returns any match detected in <code>haystack</code> with no guarantees on
which match will be returned. It is often faster than <code>"first"</code> and
<code>"last"</code> if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>haystack</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>haystack</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="relation-locate_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between
<code>needles</code> and <code>haystack</code>. If the expectations chosen from the list below
are invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>"none"</code> doesn't perform any relationship checks.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches at most 1 value in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches at most 1 value in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches any number of values in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches at most 1 value in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches at most 1 value in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches any number of values in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches any number of values in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches any number of values in <code>needles</code>.
</p>
</li></ul>

<p>This performs no checks, and is identical to <code>"none"</code>, but is provided to
allow you to be explicit about this relationship if you know it exists.
</p>
</li>
<li> <p><code>"warn-many-to-many"</code> doesn't assume there is any known relationship, but
will warn if <code>needles</code> and <code>haystack</code> have a many-to-many relationship
(which is typically unexpected), encouraging you to either take a closer
look at your inputs or make this relationship explicit by specifying
<code>"many-to-many"</code>.
</p>
</li></ul>

<p><code>relationship</code> is applied after <code>filter</code> and <code>multiple</code> to allow potential
multiple matches to be filtered out first.
</p>
<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>no_match</code> and <code>remaining</code>.</p>
</td></tr>
<tr><td><code id="relation-locate_+3A_closest">closest</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TRUE / FALSE]&#8288;</code>
</p>
<p>Should only the closest relationship be returned?
</p>
<p>If <code>TRUE</code>, will only return the closest interval(s) in <code>haystack</code> that
the current value of <code>needles</code> either precedes or follows. Note that
multiple intervals can still be returned if there are ties, which can
be resolved using <code>multiple</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing two integer columns named <code>needles</code> and <code>haystack</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+relation-detect">Detecting relationships</a>
</p>
<p><a href="#topic+relation-detect-pairwise">Detecting relationships pairwise</a>
</p>
<p><a href="#topic+allen-relation-locate">Locating relations from Allen's Interval Algebra</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iv_pairs(
  as.Date(c("2019-01-05", "2019-01-10")),
  as.Date(c("2019-01-07", "2019-01-15")),
  as.Date(c("2019-01-20", "2019-01-31"))
)

y &lt;- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-04", "2019-01-08")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-10", "2019-01-20")),
  as.Date(c("2019-01-15", "2019-01-20"))
)

x
y

# Find any overlap between `x` and `y`
loc &lt;- iv_locate_overlaps(x, y)
loc

iv_align(x, y, locations = loc)

# Find where `x` contains `y` and drop results when there isn't a match
loc &lt;- iv_locate_overlaps(x, y, type = "contains", no_match = "drop")
loc

iv_align(x, y, locations = loc)

# Find where `x` precedes `y`
loc &lt;- iv_locate_precedes(x, y)
loc

iv_align(x, y, locations = loc)

# Filter down to find only the closest interval in `y` of all the intervals
# where `x` preceded it
loc &lt;- iv_locate_precedes(x, y, closest = TRUE)

iv_align(x, y, locations = loc)

# Note that `closest` can result in duplicates if there is a tie.
# `2019-01-20` appears as an end date twice in `haystack`.
loc &lt;- iv_locate_follows(x, y, closest = TRUE)
loc

iv_align(x, y, locations = loc)

# Force just one of the ties to be returned by using `multiple`.
# Here we just request any of the ties, with no guarantee on which one.
loc &lt;- iv_locate_follows(x, y, closest = TRUE, multiple = "any")
loc

iv_align(x, y, locations = loc)

# ---------------------------------------------------------------------------

a &lt;- iv(NA, NA)
b &lt;- iv(c(NA, NA), c(NA, NA))

# By default, missing intervals in `needles` are seen as exactly equal to
# missing intervals in `haystack`, which means that they overlap
iv_locate_overlaps(a, b)

# If you'd like missing intervals in `needles` to always be considered
# unmatched, set `missing = NA`
iv_locate_overlaps(a, b, missing = NA)
</code></pre>

<hr>
<h2 id='vector-count'>Count relationships between a vector and an iv</h2><span id='topic+vector-count'></span><span id='topic+iv_count_between'></span><span id='topic+iv_count_includes'></span>

<h3>Description</h3>

<p>This family of functions counts different types of relationships between a
vector and an iv. It works similar to <code><a href="base.html#topic+match">base::match()</a></code>, where <code>needles[i]</code>
checks for a match in all of <code>haystack</code>.
</p>

<ul>
<li> <p><code>iv_count_between()</code> counts instances of when <code>needles</code>, a vector, falls
between the bounds of <code>haystack</code>, an iv.
</p>
</li>
<li> <p><code>iv_count_includes()</code> counts instances of when <code>needles</code>, an iv, includes
the values of <code>haystack</code>, a vector.
</p>
</li></ul>

<p>These functions return an integer vector the same size as <code>needles</code>
containing a count of the times where the <code>i</code>-th value of <code>needles</code> contained
a match in <code>haystack</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_count_between(needles, haystack, ..., missing = "equals", no_match = 0L)

iv_count_includes(needles, haystack, ..., missing = "equals", no_match = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector-count_+3A_needles">needles</code>, <code id="vector-count_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector, iv]&#8288;</code>
</p>
<p>For <code style="white-space: pre;">&#8288;iv_*_between()&#8288;</code>, <code>needles</code> should be a vector and <code>haystack</code> should be
an iv.
</p>
<p>For <code style="white-space: pre;">&#8288;iv_*_includes()&#8288;</code>, <code>needles</code> should be an iv and <code>haystack</code> should be
a vector.
</p>

<ul>
<li><p> Each element of <code>needles</code> represents the value / interval to match.
</p>
</li>
<li> <p><code>haystack</code> represents the values / intervals to match against.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vector-count_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vector-count_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / "equals" / "error"]&#8288;</code>
</p>
<p>Handling of missing values in <code>needles</code>.
</p>

<ul>
<li> <p><code>"equals"</code> considers missing values in <code>needles</code> as exactly equal
to missing values in <code>haystack</code> when determining if there is a
matching relationship between them.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any values in <code>needles</code> are missing.
</p>
</li>
<li><p> If a single integer value is provided, this represents the count returned
for a missing value in <code>needles</code>. Use <code>0L</code> to force missing values
to never match.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vector-count_+3A_no_match">no_match</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / "error"]&#8288;</code>
</p>
<p>Handling of <code>needles</code> without a match.
</p>

<ul>
<li> <p><code>"error"</code> throws an error if any needles have zero matches.
</p>
</li>
<li><p> If a single integer is provided, this represents the count returned for
a needle with zero matches. The default value gives unmatched needles
a count of <code>0L</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector the same size as <code>needles</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+vector-locate">Locating relationships between a vector and an iv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.Date(c("2019-01-05", "2019-01-10", "2019-01-07", "2019-01-20"))

y &lt;- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-04", "2019-01-08")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-10", "2019-01-20")),
  as.Date(c("2019-01-15", "2019-01-20"))
)

x
y

# Count the number of times `x` is between the intervals in `y`
iv_count_between(x, y)

# Count the number of times `y` includes a value from `x`
iv_count_includes(y, x)

# ---------------------------------------------------------------------------

a &lt;- c(1, NA)
b &lt;- iv(c(NA, NA), c(NA, NA))

# By default, missing values in `needles` are treated as being exactly
# equal to missing values in `haystack`, so the missing value in `a` is
# considered between the missing interval in `b`.
iv_count_between(a, b)
iv_count_includes(b, a)

# If you'd like to propagate missing values, set `missing = NA`
iv_count_between(a, b, missing = NA)
iv_count_includes(b, a, missing = NA)

# If you'd like missing values to be treated as unmatched, set
# `missing = 0L`
iv_count_between(a, b, missing = 0L)
iv_count_includes(b, a, missing = 0L)
</code></pre>

<hr>
<h2 id='vector-detect'>Detect relationships between a vector and an iv</h2><span id='topic+vector-detect'></span><span id='topic+iv_between'></span><span id='topic+iv_includes'></span>

<h3>Description</h3>

<p>This family of functions detects different types of relationships between a
vector and an iv. It works similar to <a href="base.html#topic+match">base::%in%</a>, where <code>needles[i]</code>
checks for a match in all of <code>haystack</code>.
</p>

<ul>
<li> <p><code>iv_between()</code> detects when <code>needles</code>, a vector, falls between the
bounds in <code>haystack</code>, an iv.
</p>
</li>
<li> <p><code>iv_includes()</code> detects when <code>needles</code>, an iv, includes the values
of <code>haystack</code>, a vector.
</p>
</li></ul>

<p>This function returns a logical vector the same size as <code>needles</code> containing
<code>TRUE</code> if the value in <code>needles</code> matches any value in <code>haystack</code> and <code>FALSE</code>
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_between(needles, haystack, ..., missing = "equals")

iv_includes(needles, haystack, ..., missing = "equals")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector-detect_+3A_needles">needles</code>, <code id="vector-detect_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector, iv]&#8288;</code>
</p>
<p>For <code style="white-space: pre;">&#8288;iv_*_between()&#8288;</code>, <code>needles</code> should be a vector and <code>haystack</code> should be
an iv.
</p>
<p>For <code style="white-space: pre;">&#8288;iv_*_includes()&#8288;</code>, <code>needles</code> should be an iv and <code>haystack</code> should be
a vector.
</p>

<ul>
<li><p> Each element of <code>needles</code> represents the value / interval to match.
</p>
</li>
<li> <p><code>haystack</code> represents the values / intervals to match against.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vector-detect_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vector-detect_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1) / "equals" / "error"]&#8288;</code>
</p>
<p>Handling of missing values in <code>needles</code>.
</p>

<ul>
<li> <p><code>"equals"</code> considers missing values in <code>needles</code> as exactly equal
to missing values in <code>haystack</code> when determining if there is a
matching relationship between them. Matched missing values in
<code>needles</code> result in a <code>TRUE</code> value in the result, and unmatched missing
values result in a <code>FALSE</code> value.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any values in <code>needles</code> are missing.
</p>
</li>
<li><p> If a single logical value is provided, this represents the value returned
in the result for values in <code>needles</code> that are missing. You can force
missing values to be unmatched by setting this to <code>FALSE</code>, and you
can force them to be propagated by setting this to <code>NA</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same size as <code>needles</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+relation-locate">Locating relationships</a>
</p>
<p><a href="#topic+vector-locate">Locating relationships between a vector and an iv</a>
</p>
<p><a href="#topic+vector-detect-pairwise">Pairwise detect relationships between a vector and an iv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.Date(c("2019-01-05", "2019-01-10", "2019-01-07", "2019-01-20"))

y &lt;- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-04", "2019-01-08")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-10", "2019-01-20")),
  as.Date(c("2019-01-15", "2019-01-20"))
)

x
y

# Detect if the i-th location in `x` is between any intervals in `y`
iv_between(x, y)

# Detect if the i-th location in `y` includes any value in `x`
iv_includes(y, x)

# ---------------------------------------------------------------------------

a &lt;- c(1, NA)
b &lt;- iv(c(NA, NA), c(NA, NA))

# By default, missing values in `needles` are treated as being exactly
# equal to missing values in `haystack`, so the missing value in `a` is
# considered between the missing interval in `b`.
iv_between(a, b)
iv_includes(b, a)

# If you'd like to propagate missing values, set `missing = NA`
iv_between(a, b, missing = NA)
iv_includes(b, a, missing = NA)

# If you'd like missing values to be treated as unmatched, set
# `missing = FALSE`
iv_between(a, b, missing = FALSE)
iv_includes(b, a, missing = FALSE)
</code></pre>

<hr>
<h2 id='vector-detect-pairwise'>Pairwise detect relationships between a vector and an iv</h2><span id='topic+vector-detect-pairwise'></span><span id='topic+iv_pairwise_between'></span><span id='topic+iv_pairwise_includes'></span>

<h3>Description</h3>

<p>This family of functions detects different types of relationships between a
vector and an iv <em>pairwise</em>. where pairwise means that the i-th value of <code>x</code>
is compared against the i-th value of <code>y</code>. This is in contrast to
<code><a href="#topic+iv_between">iv_between()</a></code>, which works more like <a href="base.html#topic+match">base::%in%</a>.
</p>

<ul>
<li> <p><code>iv_pairwise_between()</code> detects if the i-th value of <code>x</code>, a vector, falls
between the bounds of the i-th value of <code>y</code>, an iv.
</p>
</li>
<li> <p><code>iv_pairwise_includes()</code> detects if the i-th value of <code>x</code>, an iv, includes
the i-th value of <code>y</code>, a vector.
</p>
</li></ul>

<p>These functions return a logical vector the same size as the common size of
<code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_pairwise_between(x, y)

iv_pairwise_includes(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector-detect-pairwise_+3A_x">x</code>, <code id="vector-detect-pairwise_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector, iv]&#8288;</code>
</p>
<p>For <code>iv_pairwise_between()</code>, <code>x</code> must be a vector and <code>y</code> must be an iv.
</p>
<p>For <code>iv_pairwise_includes()</code>, <code>x</code> must be an iv and <code>y</code> must be a vector.
</p>
<p><code>x</code> and <code>y</code> will be recycled against each other.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same size as the common size of <code>x</code> and <code>y</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+relation-locate">Locating relationships</a>
</p>
<p><a href="#topic+vector-locate">Locating relationships between a vector and an iv</a>
</p>
<p><a href="#topic+vector-detect">Detecting relationships between a vector and an iv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.Date(c("2019-01-01", "2019-01-08", "2019-01-21"))

y &lt;- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-18", "2019-01-21"))
)

x
y

# Does the i-th value of `x` fall between the i-th interval of `y`?
iv_pairwise_between(x, y)

# Does the i-th interval of `y` include the i-th value of `x`?
iv_pairwise_includes(y, x)

a &lt;- c(1, NA, NA)
b &lt;- iv_pairs(c(NA, NA), c(3, 4), c(NA, NA))

# Missing intervals always propagate
iv_pairwise_between(a, b)
iv_pairwise_includes(b, a)
</code></pre>

<hr>
<h2 id='vector-locate'>Locate relationships between a vector and an iv</h2><span id='topic+vector-locate'></span><span id='topic+iv_locate_between'></span><span id='topic+iv_locate_includes'></span>

<h3>Description</h3>

<p>This family of functions locates different types of relationships between a
vector and an iv. It works similar to <code><a href="base.html#topic+match">base::match()</a></code>, where <code>needles[i]</code>
checks for a match in all of <code>haystack</code>. Unlike <code>match()</code>, <em>all</em> matches are
returned, rather than just the first.
</p>

<ul>
<li> <p><code>iv_locate_between()</code> locates where <code>needles</code>, a vector, falls between the
bounds of <code>haystack</code>, an iv.
</p>
</li>
<li> <p><code>iv_locate_includes()</code> locates where <code>needles</code>, an iv, includes the values
of <code>haystack</code>, a vector.
</p>
</li></ul>

<p>These functions return a two column data frame. The <code>needles</code> column is an
integer vector pointing to locations in <code>needles</code>. The <code>haystack</code> column is
an integer vector pointing to locations in <code>haystack</code> with a match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv_locate_between(
  needles,
  haystack,
  ...,
  missing = "equals",
  no_match = NA_integer_,
  remaining = "drop",
  multiple = "all",
  relationship = "none"
)

iv_locate_includes(
  needles,
  haystack,
  ...,
  missing = "equals",
  no_match = NA_integer_,
  remaining = "drop",
  multiple = "all",
  relationship = "none"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector-locate_+3A_needles">needles</code>, <code id="vector-locate_+3A_haystack">haystack</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector, iv]&#8288;</code>
</p>
<p>For <code style="white-space: pre;">&#8288;iv_*_between()&#8288;</code>, <code>needles</code> should be a vector and <code>haystack</code> should be
an iv.
</p>
<p>For <code style="white-space: pre;">&#8288;iv_*_includes()&#8288;</code>, <code>needles</code> should be an iv and <code>haystack</code> should be
a vector.
</p>

<ul>
<li><p> Each element of <code>needles</code> represents the value / interval to match.
</p>
</li>
<li> <p><code>haystack</code> represents the values / intervals to match against.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vector-locate_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vector-locate_+3A_missing">missing</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / "equals" / "drop" / "error"]&#8288;</code>
</p>
<p>Handling of missing values in <code>needles</code>.
</p>

<ul>
<li> <p><code>"equals"</code> considers missing values in <code>needles</code> as exactly equal
to missing values in <code>haystack</code> when determining if there is a
matching relationship between them.
</p>
</li>
<li> <p><code>"drop"</code> drops missing values in <code>needles</code> from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any values in <code>needles</code> are missing.
</p>
</li>
<li><p> If a single integer is provided, this represents the value returned in
the <code>haystack</code> column for values in <code>needles</code> that are missing.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vector-locate_+3A_no_match">no_match</code></td>
<td>
<p>Handling of <code>needles</code> without a match.
</p>

<ul>
<li> <p><code>"drop"</code> drops <code>needles</code> with zero matches from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any <code>needles</code> have zero matches.
</p>
</li>
<li><p> If a single integer is provided, this represents the value returned in
the <code>haystack</code> column for values of <code>needles</code> that have zero matches. The
default represents an unmatched needle with <code>NA</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vector-locate_+3A_remaining">remaining</code></td>
<td>
<p>Handling of <code>haystack</code> values that <code>needles</code> never matched.
</p>

<ul>
<li> <p><code>"drop"</code> drops remaining <code>haystack</code> values from the result.
Typically, this is the desired behavior if you only care when <code>needles</code>
has a match.
</p>
</li>
<li> <p><code>"error"</code> throws an error if there are any remaining <code>haystack</code>
values.
</p>
</li>
<li><p> If a single integer is provided (often <code>NA</code>), this represents the value
returned in the <code>needles</code> column for the remaining <code>haystack</code> values
that <code>needles</code> never matched. Remaining <code>haystack</code> values are always
returned at the end of the result.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vector-locate_+3A_multiple">multiple</code></td>
<td>
<p>Handling of <code>needles</code> with multiple matches. For each needle:
</p>

<ul>
<li> <p><code>"all"</code> returns all matches detected in <code>haystack</code>.
</p>
</li>
<li> <p><code>"any"</code> returns any match detected in <code>haystack</code> with no guarantees on
which match will be returned. It is often faster than <code>"first"</code> and
<code>"last"</code> if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>haystack</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>haystack</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vector-locate_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between
<code>needles</code> and <code>haystack</code>. If the expectations chosen from the list below
are invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>"none"</code> doesn't perform any relationship checks.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches at most 1 value in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches at most 1 value in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches any number of values in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches at most 1 value in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches at most 1 value in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches any number of values in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches any number of values in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches any number of values in <code>needles</code>.
</p>
</li></ul>

<p>This performs no checks, and is identical to <code>"none"</code>, but is provided to
allow you to be explicit about this relationship if you know it exists.
</p>
</li>
<li> <p><code>"warn-many-to-many"</code> doesn't assume there is any known relationship, but
will warn if <code>needles</code> and <code>haystack</code> have a many-to-many relationship
(which is typically unexpected), encouraging you to either take a closer
look at your inputs or make this relationship explicit by specifying
<code>"many-to-many"</code>.
</p>
</li></ul>

<p><code>relationship</code> is applied after <code>filter</code> and <code>multiple</code> to allow potential
multiple matches to be filtered out first.
</p>
<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>no_match</code> and <code>remaining</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing two integer columns named <code>needles</code> and <code>haystack</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+relation-locate">Locating relationships</a>
</p>
<p><a href="#topic+vector-detect">Detect relationships between a vector and an iv</a>
</p>
<p><a href="#topic+vector-detect-pairwise">Pairwise detect relationships between a vector and an iv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.Date(c("2019-01-05", "2019-01-10", "2019-01-07", "2019-01-20"))

y &lt;- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-04", "2019-01-08")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-10", "2019-01-20")),
  as.Date(c("2019-01-15", "2019-01-20"))
)

x
y

# Find any location where `x` is between the intervals in `y`
loc &lt;- iv_locate_between(x, y)
loc

iv_align(x, y, locations = loc)

# Find any location where `y` includes the values in `x`
loc &lt;- iv_locate_includes(y, x)
loc

iv_align(y, x, locations = loc)

# Drop values in `x` without a match
loc &lt;- iv_locate_between(x, y, no_match = "drop")
loc

iv_align(x, y, locations = loc)

# ---------------------------------------------------------------------------

a &lt;- c(1, NA)
b &lt;- iv(c(NA, NA), c(NA, NA))

# By default, missing values in `needles` are treated as being exactly
# equal to missing values in `haystack`, so the missing value in `a` is
# considered between the missing interval in `b`.
iv_locate_between(a, b)
iv_locate_includes(b, a)

# If you'd like missing values in `needles` to always be considered
# unmatched, set `missing = NA`
iv_locate_between(a, b, missing = NA)
iv_locate_includes(b, a, missing = NA)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
