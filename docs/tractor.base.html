<!DOCTYPE html><html><head><title>Help for package tractor.base</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tractor.base}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[,SparseArray,ANY,ANY-method'><p>Indexing methods</p></a></li>
<li><a href='#allEqual'><p>Test whether all elements of a vector are equal</p></a></li>
<li><a href='#asMriImage'><p>Creating MriImage objects from data</p></a></li>
<li><a href='#augmentedInfoPanel'><p>A simple interactive viewer for MriImage objects</p></a></li>
<li><a href='#createNeighbourhoodInfo'><p>Image neighbourhoods</p></a></li>
<li><a href='#createSliceGraphic'><p>Visualise MriImage objects</p></a></li>
<li><a href='#deduplicate'><p>Concatenate and deduplicate vectors</p></a></li>
<li><a href='#DicomMetadata-class'><p>The DicomMetadata class</p></a></li>
<li><a href='#embrace'><p>Combine similar strings into one</p></a></li>
<li><a href='#emptyMatrix'><p>The empty matrix</p></a></li>
<li><a href='#equivalent'><p>Test two numeric vectors for equivalence</p></a></li>
<li><a href='#fx'><p>Shorthand anonymous functions</p></a></li>
<li><a href='#getColourScale'><p>Obtaining colour scales</p></a></li>
<li><a href='#identifyImageFileNames'><p>Working with MRI images stored in various formats</p></a></li>
<li><a href='#implode'><p>Create a character string by concatenating the elements of a vector</p></a></li>
<li><a href='#indexList'><p>Extract one or more elements from a list</p></a></li>
<li><a href='#infix'><p>Resolve a variable to a default when NULL</p></a></li>
<li><a href='#isDeserialisable'><p>Reference object serialisation and deserialisation</p></a></li>
<li><a href='#locateExecutable'><p>Find or run an external executable file</p></a></li>
<li><a href='#mergeMriImages'><p>Merging MriImage objects</p></a></li>
<li><a href='#MriImage-class'><p>The MriImage class</p></a></li>
<li><a href='#newSparseArrayWithData'><p>Create a SparseArray object</p></a></li>
<li><a href='#nilObject'><p>The nil object</p></a></li>
<li><a href='#pluralise'><p>Number agreement with a vector</p></a></li>
<li><a href='#printLabelledValues'><p>Pretty print labelled information</p></a></li>
<li><a href='#promote'><p>Promote a vector to a single-column or single-row matrix</p></a></li>
<li><a href='#readDicomDirectory'><p>Read a directory of DICOM files</p></a></li>
<li><a href='#readDicomFile'><p>Read a DICOM file into a DicomMetadata object</p></a></li>
<li><a href='#resolvePath'><p>Functions for file name and path manipulation</p></a></li>
<li><a href='#resolveVector'><p>Miscellaneous vector functions</p></a></li>
<li><a href='#SerialisableObject-class'><p>The SerialisableObject class</p></a></li>
<li><a href='#sortDicomDirectories'><p>Sort a directory of DICOM files into series</p></a></li>
<li><a href='#SparseArray-class'><p>The SparseArray class</p></a></li>
<li><a href='#threadSafeTempFile'><p>Obtain thread-safe temporary file names</p></a></li>
<li><a href='#TractorObject-class'><p>The TractorObject class</p></a></li>
<li><a href='#where'><p>Compact conditional values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Read, Manipulate and Visualise Magnetic Resonance Images</td>
</tr>
<tr>
<td>Author:</td>
<td>Jon Clayden</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jon Clayden &lt;code@clayden.org&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, ore (&ge; 1.3.0), reportr, shades, RNifti</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mmand, loder, divest, jsonlite, yaml, tinytest</td>
</tr>
<tr>
<td>Enhances:</td>
<td>oro.nifti</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for working with magnetic resonance images. Reading and
    writing of popular file formats (DICOM, Analyze, NIfTI-1, NIfTI-2, MGH);
    interactive and non-interactive visualisation; flexible image manipulation;
    metadata and sparse image handling.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.tractor-mri.org.uk">https://www.tractor-mri.org.uk</a>, <a href="https://github.com/tractor/tractor">https://github.com/tractor/tractor</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tractor/tractor/issues">https://github.com/tractor/tractor/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-27 17:14:47 UTC; jon</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-27 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+2CSparseArray+2CANY+2CANY-method'>Indexing methods</h2><span id='topic++5B+2CSparseArray+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CSparseArray+2CANY+2CANY-method'></span><span id='topic++5B+2CMriImage+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CMriImage+2CANY+2Cmissing-method'></span><span id='topic++5B+2CMriImage+2Cmissing+2CANY-method'></span><span id='topic++5B+2CMriImage+2CANY+2CANY-method'></span><span id='topic++5B+2CMriImage+2CMriImage+2Cmissing-method'></span><span id='topic++5B+3C-+2CMriImage+2Cmissing+2Cmissing-method'></span><span id='topic++5B+3C-+2CMriImage+2CANY+2Cmissing-method'></span><span id='topic++5B+3C-+2CMriImage+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CMriImage+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CMriImage+2CMriImage+2Cmissing-method'></span>

<h3>Description</h3>

<p>Indexing methods for <code><a href="#topic+SparseArray">SparseArray</a></code> and <code><a href="#topic+MriImage">MriImage</a></code>
objects. For the latter class, arguments are passed to the equivalents for
<code>array</code> or <code><a href="#topic+SparseArray">SparseArray</a></code>, except where <code>i</code> is another
<code><a href="#topic+MriImage">MriImage</a></code> object, where its nonzero region will be used to
provide the indices. For <code><a href="#topic+SparseArray">SparseArray</a></code>, indexing may be blank,
or by numeric vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseArray,ANY,ANY'
x[i, j, ..., drop = TRUE]

## S4 replacement method for signature 'SparseArray,ANY,ANY'
x[i, j, ...] &lt;- value

## S4 method for signature 'MriImage,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'MriImage,ANY,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'MriImage,missing,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'MriImage,ANY,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'MriImage,MriImage,missing'
x[i, j, ..., drop = TRUE]

## S4 replacement method for signature 'MriImage,missing,missing'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'MriImage,ANY,missing'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'MriImage,missing,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'MriImage,ANY,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'MriImage,MriImage,missing'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseArray+2B2CANY+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>An object of the appropriate type.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseArray+2B2CANY+2B2CANY-method_+3A_i">i</code>, <code id="+2B5B+2B2CSparseArray+2B2CANY+2B2CANY-method_+3A_j">j</code>, <code id="+2B5B+2B2CSparseArray+2B2CANY+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>Indexing objects.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseArray+2B2CANY+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>Scalar value: should unitary dimensions be dropped?</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseArray+2B2CANY+2B2CANY-method_+3A_value">value</code></td>
<td>
<p>New value(s) for replacement forms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, array or <code><a href="#topic+SparseArray">SparseArray</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>

<hr>
<h2 id='allEqual'>Test whether all elements of a vector are equal</h2><span id='topic+allEqual'></span>

<h3>Description</h3>

<p>This function tests whether all elements of the specified vector are equal
to each other, i.e., whether the vector contains only a single unique value.
For lists, equality is determined using <code><a href="#topic+equivalent">equivalent</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allEqual(x, ignoreMissing = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allEqual_+3A_x">x</code></td>
<td>
<p>A vector of any mode, including a list.</p>
</td></tr>
<tr><td><code id="allEqual_+3A_ignoremissing">ignoreMissing</code></td>
<td>
<p>If <code>TRUE</code>, missing elements will be ignored.
Otherwise the presence of missing values will result in a return value of
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="allEqual_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>all.equal</code>, via
<code><a href="#topic+equivalent">equivalent</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all elements test equivalent; <code>FALSE</code>
otherwise.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+equivalent">equivalent</a></code> for elementwise equivalence of two
vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
allEqual(c(1,1,1))  # TRUE
allEqual(c(1,1,NA))  # FALSE
allEqual(c(1,1,NA), ignoreMissing=TRUE)  # TRUE

</code></pre>

<hr>
<h2 id='asMriImage'>Creating MriImage objects from data</h2><span id='topic+asMriImage'></span><span id='topic+extractMriImage'></span><span id='topic+trimMriImage'></span><span id='topic+reorderMriImage'></span>

<h3>Description</h3>

<p>Functions for creating MriImage objects from data, including other images.
All of these functions use data from arrays or <code>MriImage</code> objects to
create a new <code>MriImage</code> object. <code>asMriImage</code> is the basic fucntion
for creating an object from its constituents: an array of voxel values and
some metadata (and/or a template image).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asMriImage(data, templateImage = nilObject(), imageDims = NA,
  voxelDims = NA, voxelDimUnits = NA, origin = NA, tags = NA,
  reordered = NA)

extractMriImage(image, dim, loc)

trimMriImage(image, clearance = 4, indices = NULL)

reorderMriImage(image)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asMriImage_+3A_data">data</code></td>
<td>
<p>An array of pixel/voxel data.</p>
</td></tr>
<tr><td><code id="asMriImage_+3A_templateimage">templateImage</code></td>
<td>
<p>An optional <code>MriImage</code> object, to be used as a
metadata template.</p>
</td></tr>
<tr><td><code id="asMriImage_+3A_imagedims">imageDims</code>, <code id="asMriImage_+3A_voxeldims">voxelDims</code>, <code id="asMriImage_+3A_voxeldimunits">voxelDimUnits</code>, <code id="asMriImage_+3A_origin">origin</code>, <code id="asMriImage_+3A_tags">tags</code>, <code id="asMriImage_+3A_reordered">reordered</code></td>
<td>
<p>Metadata for
the new image object. These values override any from the metadata object
or data array. See <code><a href="#topic+MriImage-class">MriImage</a></code> class documentation for
details.</p>
</td></tr>
<tr><td><code id="asMriImage_+3A_image">image</code></td>
<td>
<p>An <code>MriImage</code> object.</p>
</td></tr>
<tr><td><code id="asMriImage_+3A_dim">dim</code>, <code id="asMriImage_+3A_loc">loc</code></td>
<td>
<p>The dimension and location along that dimension for which
data should be extracted.</p>
</td></tr>
<tr><td><code id="asMriImage_+3A_clearance">clearance</code></td>
<td>
<p>The number of voxels' clearance left around a trimmed
image.</p>
</td></tr>
<tr><td><code id="asMriImage_+3A_indices">indices</code></td>
<td>
<p>A list of indices to keep along each dimension. Determined
from the specified <code>clearance</code> if <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>extractMriImage</code> reduces the dimensionality of the source image by
one, by extracting a single &ldquo;slice&rdquo; of data along one dimension.
<code>trimMriImage</code> trims empty space from the edges of an image, reducing
the dimensions of the image and thus avoiding the storage of lots of zeroes.
<code>reorderMriImage</code> reorders the image data (and corresponding metadata)
to the LAS convention, an operation which is usually performed when an
image is read from file.
</p>


<h3>Value</h3>

<p>An <code>MriImage</code> object.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MriImage-class">MriImage</a></code>
</p>

<hr>
<h2 id='augmentedInfoPanel'>A simple interactive viewer for MriImage objects</h2><span id='topic+augmentedInfoPanel'></span><span id='topic+polarPlotPanel'></span><span id='topic+viewImages'></span>

<h3>Description</h3>

<p>The <code>viewImages</code> function provides a simple interactive viewer for
<code>MriImage</code> objects. 3D and 4D images may be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augmentedInfoPanel(indexNames = NULL)

polarPlotPanel(directions, bValues = NULL)

viewImages(images, colourScales = NULL, point = NULL, interactive = TRUE,
  crosshairs = TRUE, orientationLabels = TRUE,
  infoPanel = RNifti::defaultInfoPanel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augmentedInfoPanel_+3A_indexnames">indexNames</code></td>
<td>
<p>A list whose elements are either <code>NULL</code> or a named
character vector giving the names associated with each index in the image.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_directions">directions</code></td>
<td>
<p>A matrix of 3D acquisition direction vectors, one per row.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_bvalues">bValues</code></td>
<td>
<p>A vector of b-values, if the image is diffusion-weighted.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_images">images</code></td>
<td>
<p>An <code>MriImage</code> object, or list of <code>MriImage</code> objects.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_colourscales">colourScales</code></td>
<td>
<p>A list of colour scales to use for each image, which
will be recycled to the length of <code>images</code>. See
<code><a href="#topic+getColourScale">getColourScale</a></code> for details. The default is to use greyscale.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_point">point</code></td>
<td>
<p>A length-3 integer vector giving the initial location of the
crosshairs, in voxels.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_interactive">interactive</code></td>
<td>
<p>A single logical value. If <code>TRUE</code>, the plot is
interactive.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_crosshairs">crosshairs</code></td>
<td>
<p>A single logical value. If <code>TRUE</code>, the crosshairs are
displayed.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_orientationlabels">orientationLabels</code></td>
<td>
<p>A single logical value. If <code>TRUE</code>, orientation
labels are displayed.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_infopanel">infoPanel</code></td>
<td>
<p>A function with at least three arguments, which must plot
something to fill the bottom-right panel of the viewer after each change
of crosshair location. The three mandatory arguments correspond to the
current location in the image, the image values at that location, and the
names of each image. The <code>defaultInfoPanel</code> and
<code>timeSeriesPanel</code> functions from package <code>RNifti</code> are valid
examples.</p>
</td></tr>
<tr><td><code id="augmentedInfoPanel_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>infoPanel</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions are called for their side effects.
</p>


<h3>Note</h3>

<p>The <code>defaultInfoPanel</code> and <code>timeSeriesPanel</code> functions are
not intended to be called directly. They are simple examples of valid
values for the <code>infoPanel</code> argument to <code>viewImages</code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getColourScale">getColourScale</a></code>
</p>

<hr>
<h2 id='createNeighbourhoodInfo'>Image neighbourhoods</h2><span id='topic+createNeighbourhoodInfo'></span><span id='topic+neighbourhoodInfo'></span>

<h3>Description</h3>

<p>This function calculates information about a cuboidal region of an image,
with a centre and a fixed voxel width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNeighbourhoodInfo(width, dim = 3, centre = rep(0, dim))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNeighbourhoodInfo_+3A_width">width</code></td>
<td>
<p>An integer voxel width. Must be odd.</p>
</td></tr>
<tr><td><code id="createNeighbourhoodInfo_+3A_dim">dim</code></td>
<td>
<p>An integer giving the dimensionality of the neighbourhood.
Currently must be 3.</p>
</td></tr>
<tr><td><code id="createNeighbourhoodInfo_+3A_centre">centre</code></td>
<td>
<p>A numeric vector giving the centre voxel of the neighbourhood.
Must have exactly <code>dim</code> elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>createNeighbourhoodInfo</code> returns a list with class
<code>"neighbourhoodInfo"</code> and elements
</p>

<dl>
<dt>width</dt><dd><p>Copied from the <code>width</code> argument.</p>
</dd>
<dt>dim</dt><dd><p>Copied from the <code>dim</code> argument.</p>
</dd>
<dt>centre</dt><dd><p>Copied from the <code>centre</code> argument.</p>
</dd>
<dt>vectors</dt><dd><p><code>dim</code> x <code>width^dim</code> matrix whose columns give
the locations of each point in the neighbourhood.</p>
</dd>
<dt>innerProducts</dt><dd><p>A square, symmetric matrix of inner products
between every location in the neighbourhood and every other.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>

<hr>
<h2 id='createSliceGraphic'>Visualise MriImage objects</h2><span id='topic+createSliceGraphic'></span><span id='topic+visualisation'></span><span id='topic+createProjectionGraphic'></span><span id='topic+createContactSheetGraphic'></span>

<h3>Description</h3>

<p>Visualise <code>MriImage</code> objects noninteractively using an R graphics
device. See <code><a href="#topic+viewImages">viewImages</a></code> for an interactive alternative. These
functions create 2D visualisations of 3D images by slicing or maximum
intensity projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSliceGraphic(image, x = NA, y = NA, z = NA,
  device = c("internal", "png"), colourScale = 1, add = FALSE,
  file = NULL, zoomFactor = 1, windowLimits = NULL)

createProjectionGraphic(image, axis, device = c("internal", "png"),
  colourScale = 1, add = FALSE, file = NULL, zoomFactor = 1,
  windowLimits = NULL)

createContactSheetGraphic(image, axis, device = c("internal", "png"),
  colourScale = 1, add = FALSE, file = NULL, zoomFactor = 1,
  windowLimits = NULL, clearance = NULL, nColumns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSliceGraphic_+3A_image">image</code></td>
<td>
<p>An <code><a href="#topic+MriImage">MriImage</a></code> object.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_x">x</code>, <code id="createSliceGraphic_+3A_y">y</code>, <code id="createSliceGraphic_+3A_z">z</code></td>
<td>
<p>Integer vectors, each of length 1. Exactly one of these must be
specified to indicate the plane of interest.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_device">device</code></td>
<td>
<p>Either <code>"internal"</code> for display on the default graphics
device, or <code>"png"</code> for creating PNG format image file(s).
Abbreviations are fine.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_colourscale">colourScale</code></td>
<td>
<p>A colour scale definition, of the sort generated by
<code><a href="#topic+getColourScale">getColourScale</a></code>.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_add">add</code></td>
<td>
<p>Overlay the graphic on a previous one. Used only when
<code>device</code> is <code>"internal"</code>.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_file">file</code></td>
<td>
<p>A file name, to be used when <code>device</code> is <code>"png"</code>.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_zoomfactor">zoomFactor</code></td>
<td>
<p>Factor by which to enlarge the image. Applies only when
<code>device</code> is <code>"png"</code>.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_windowlimits">windowLimits</code></td>
<td>
<p>Numeric vector of length 2 giving the limits of the
colour scale, or <code>NULL</code> for limits matching the range of the image
data. Passed as the <code>zlim</code> argument to <code><a href="Matrix.html#topic+image">image</a></code>.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_axis">axis</code></td>
<td>
<p>A vector of axes along which slice/projection images should
be created. 1 is left-right, 2 is anterior-posterior, 3 is
superior-inferior.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_clearance">clearance</code></td>
<td>
<p>Number of voxels' clearance to leave around each slice
image in the contact sheet. Passed to <code><a href="#topic+trimMriImage">trimMriImage</a></code>.</p>
</td></tr>
<tr><td><code id="createSliceGraphic_+3A_ncolumns">nColumns</code></td>
<td>
<p>Number of slices per row in the contact sheet grid. If
<code>NULL</code>, the function will aim for a square grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions are called for their side effects.
</p>


<h3>Note</h3>

<p>When the <code>device</code> option is set to <code>"png"</code>, the <code>"png"</code>
and <code>"mmand"</code> packages are required by these functions.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+viewImages">viewImages</a></code> for an interactive alternative, and
<code><a href="#topic+getColourScale">getColourScale</a></code> for details of how colour scales are specified.
Also <code><a href="Matrix.html#topic+image">image</a></code>, which is used as the underlying plot function.
</p>

<hr>
<h2 id='deduplicate'>Concatenate and deduplicate vectors</h2><span id='topic+deduplicate'></span>

<h3>Description</h3>

<p>This function returns its arguments, after concatenating them using <code>c</code>
and then removing elements with duplicate names. The first element with each
name will remain, possibly with subsequent elements' content appended to it.
Unnamed elements are retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deduplicate(..., merge = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deduplicate_+3A_...">...</code></td>
<td>
<p>One or more vectors of any mode, usually named.</p>
</td></tr>
<tr><td><code id="deduplicate_+3A_merge">merge</code></td>
<td>
<p>If <code>FALSE</code>, the default, duplicate elements will simply
be discarded. If <code>TRUE</code>, additional elements with the same name will
be appended to the retained one. This does not apply to unnamed elements.
If this kind of deduplication actually happens, the return value will be a
list, regardless of the source type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The concatenated and deduplicated vector.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>

<hr>
<h2 id='DicomMetadata-class'>The DicomMetadata class</h2><span id='topic+DicomMetadata-class'></span><span id='topic+DicomMetadata'></span>

<h3>Description</h3>

<p>This class represents DICOM metadata, which typically contains detailed
information about the scan parameters and subject.
</p>


<h3>Fields</h3>


<dl>
<dt><code>source</code></dt><dd><p>String naming the source file</p>
</dd>
<dt><code>tags</code></dt><dd><p>Data frame of tag information</p>
</dd>
<dt><code>tagOffset</code></dt><dd><p>Starting offset for tags in the file</p>
</dd>
<dt><code>dataOffset</code></dt><dd><p>Starting offset for pixel data in the file</p>
</dd>
<dt><code>dataLength</code></dt><dd><p>Pixel data length</p>
</dd>
<dt><code>explicitTypes</code></dt><dd><p>Logical value indicating whether explicit types are
used in the file</p>
</dd>
<dt><code>endian</code></dt><dd><p>String naming the endianness of the file</p>
</dd>
<dt><code>asciiFields</code></dt><dd><p>Character vector containing the contents of the ASCII
header, if requested and present in the file.</p>
</dd>
<dt><code>transferSyntax</code></dt><dd><p>Transfer syntax string, if specified in the file;
otherwise the empty string.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>getAsciiFields(regex = NULL)</code></dt><dd><p>Retrieve the value of one or more fields in the ASCII header. Returns NA if no fields match</p>
</dd>
<dt><code>getTagValue(group, element)</code></dt><dd><p>Retrieve the value of a given tag, using an appropriate R type. Returns NA if the tag is missing</p>
</dd>
</dl>

<hr>
<h2 id='embrace'>Combine similar strings into one</h2><span id='topic+embrace'></span>

<h3>Description</h3>

<p>Merge a vector of strings with a common prefix and/or suffix into one string
with the unique parts in braces, comma-separated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embrace(strings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embrace_+3A_strings">strings</code></td>
<td>
<p>A vector, which will be coerced to mode <code>character</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single merged string, with the common prefix and suffix as
attributes.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>embrace(c("image.hdr", "image.img"))

</code></pre>

<hr>
<h2 id='emptyMatrix'>The empty matrix</h2><span id='topic+emptyMatrix'></span><span id='topic+is.emptyMatrix'></span>

<h3>Description</h3>

<p>The empty matrix is a standard matrix of dimensions 0 x 0. It is intended to
be used as a placeholder where a matrix is required but no information is
stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emptyMatrix()

is.emptyMatrix(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emptyMatrix_+3A_object">object</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>emptyMatrix</code> returns the empty matrix, equivalent to
<code>matrix(NA,0,0)</code>. <code>is.emptyMatrix</code> returns <code>TRUE</code> if its
argument is identical to the empty matrix.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>

<hr>
<h2 id='equivalent'>Test two numeric vectors for equivalence</h2><span id='topic+equivalent'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code>isTRUE(all.equal(x,y,...{}))</code>, but
with the additional capability of doing sign-insensitive comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalent(x, y, signMatters = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalent_+3A_x">x</code></td>
<td>
<p>The first numeric vector.</p>
</td></tr>
<tr><td><code id="equivalent_+3A_y">y</code></td>
<td>
<p>The second numeric vector.</p>
</td></tr>
<tr><td><code id="equivalent_+3A_signmatters">signMatters</code></td>
<td>
<p>Logical value: if FALSE then equivalence in absolute
value is sufficient.</p>
</td></tr>
<tr><td><code id="equivalent_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="Matrix.html#topic+all.equal">all.equal</a></code>, notably
<code>tolerance</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all elements of <code>x</code> match all elements of
<code>y</code> to within tolerance, ignoring signs if required. <code>FALSE</code>
otherwise.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+all.equal">all.equal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
equivalent(c(-1,1), c(1,1))  # FALSE
equivalent(c(-1,1), c(1,1), signMatters=FALSE)  # TRUE
equivalent(1:2, 2:3, tolerance=2)  # TRUE

</code></pre>

<hr>
<h2 id='fx'>Shorthand anonymous functions</h2><span id='topic+fx'></span><span id='topic+fxy'></span><span id='topic+fxyz'></span><span id='topic+fi'></span>

<h3>Description</h3>

<p>These functions provide a shorthand route to simple anonymous functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fx(expr)

fxy(expr)

fxyz(expr)

fi(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fx_+3A_expr">expr</code></td>
<td>
<p>A (single or compound) expression forming the body of the
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function constructed.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>

<hr>
<h2 id='getColourScale'>Obtaining colour scales</h2><span id='topic+getColourScale'></span>

<h3>Description</h3>

<p>The <code>getColourScale</code> function can be used to obtain a standard or
customised colour scale for use in the package's image visualisation
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColourScale(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColourScale_+3A_n">n</code></td>
<td>
<p>A number, colour name or list (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colour scales can be specified in any of three ways. Firstly, by a single
number, representing a predefined colour scale. Currently valid values are 1
(greyscale, black background), 2 (red to yellow heat scale, red background),
3 (blue to red rainbow scale, blue background), 4 (blue to white to red
diverging scale, white background), 5 (white to red, white background), 6
(white to blue, white background), 7 (yellow to orange to red) and 8 (purple
to green to yellow, perceptually uniform). Secondly, a single colour name
can be given (see <code><a href="grDevices.html#topic+colours">colours</a></code>); in this case the background will
be black. This is useful for binary images. Thirdly, and most flexibly, a
list with two named elements can be given: <code>colours</code>, a vector of
colours representing the colour scale, perhaps created using using the
<code>shades</code> package; and <code>background</code>, a single colour representing
the background.
</p>


<h3>Value</h3>

<p>A list with elements
</p>

<dl>
<dt>colours</dt><dd><p>A character-mode vector representing the colours in the
scale, usually of length 100. This can be passed as a colour scale to
R's plotting functions.</p>
</dd>
<dt>background</dt><dd><p>A single character string representing the background
colour.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+colours">colours</a></code>, <code><a href="grDevices.html#topic+rgb">rgb</a></code>, <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code>,
and the <code>shades</code> package for colour manipulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getColourScale(1)

</code></pre>

<hr>
<h2 id='identifyImageFileNames'>Working with MRI images stored in various formats</h2><span id='topic+identifyImageFileNames'></span><span id='topic+imageFileExists'></span><span id='topic+removeImageFiles'></span><span id='topic+symlinkImageFiles'></span><span id='topic+copyImageFiles'></span><span id='topic+readImageFile'></span><span id='topic+writeImageFile'></span>

<h3>Description</h3>

<p>Functions for reading, writing, locating, copying and removing MRI images
stored in NIfTI, Analyze, MGH and MRtrix formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifyImageFileNames(fileName, fileType = NULL, errorIfMissing = TRUE,
  auxiliaries = c("dirs", "lut", "tags"), ...)

imageFileExists(fileName, fileType = NULL)

removeImageFiles(fileName, ...)

symlinkImageFiles(from, to, overwrite = FALSE, relative = TRUE, ...)

copyImageFiles(from, to, overwrite = FALSE, deleteOriginals = FALSE, ...)

readImageFile(fileName, fileType = NULL, metadataOnly = FALSE,
  volumes = NULL, sparse = FALSE, mask = NULL, reorder = TRUE, ...)

writeImageFile(image, fileName = NULL, fileType = NA, overwrite = TRUE,
  datatype = "fit", writeTags = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifyImageFileNames_+3A_filename">fileName</code>, <code id="identifyImageFileNames_+3A_from">from</code>, <code id="identifyImageFileNames_+3A_to">to</code></td>
<td>
<p>File names, with or without appropriate extension.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_filetype">fileType</code></td>
<td>
<p>A character vector of length one, giving the file type
required or expected. If this option is missing, the file type used for
writing images will be taken from the <code>tractorFileType</code> option. See
Details.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_errorifmissing">errorIfMissing</code></td>
<td>
<p>Logical value: raise an error if no suitable files
were found?</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_auxiliaries">auxiliaries</code></td>
<td>
<p>A character vector of auxiliary file suffixes to search
for.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_...">...</code></td>
<td>
<p>For <code>identifyImageFileNames</code>, additional arguments to
<code><a href="#topic+resolvePath">resolvePath</a></code>. Elsewhere, additional arguments to
<code>identifyImageFileNames</code>.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical value: overwrite an existing image file? For
<code>writeImageFile</code>, an error will be raised if there is an existing
file and this is set to FALSE.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_relative">relative</code></td>
<td>
<p>Logical value: if <code>TRUE</code>, the path stored in the
symlink will be relative (e.g. <code>"../some_dir/some_image.nii"</code>) rather
than absolute (e.g. <code>"/path/to/some_dir/some_image.nii"</code>).</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_deleteoriginals">deleteOriginals</code></td>
<td>
<p>Logical value: if <code>TRUE</code>, <code>copyImageFiles</code>
performs a move rather than a copy.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_metadataonly">metadataOnly</code></td>
<td>
<p>Logical value: if <code>TRUE</code>, only metadata are read
into the object.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_volumes">volumes</code></td>
<td>
<p>An optional integer vector specifying a subset of volumes to
read (generally to save memory). If given, only the requested volumes in
the 4D file will be read.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_sparse">sparse</code></td>
<td>
<p>Logical value: should the image data be stored in a
<code><a href="#topic+SparseArray-class">SparseArray</a></code> object?</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_mask">mask</code></td>
<td>
<p>An optional <code><a href="#topic+MriImage-class">MriImage</a></code> object representing a
mask, outside of which the image to be read should be considered to be
zero. This can be used to save memory when only a small part of a large
image is of interest. Ignored if <code>sparse</code> is not <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_reorder">reorder</code></td>
<td>
<p>Logical value: should the image data be reordered to LAS?
This is recommended in most circumstances.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_image">image</code></td>
<td>
<p>An <code><a href="#topic+MriImage-class">MriImage</a></code> object.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_datatype">datatype</code></td>
<td>
<p>A datatype string, such as <code>"uint8"</code> or <code>"float"</code>,
specifying the pixel datatype to use when storing the data. If specified,
this must be a type supported by the requested (or default) file format.
The default, <code>"fit"</code>, results in a datatype being chosen that is wide
enough to fit the range of the data elements. An error will arise if
there's no such type.</p>
</td></tr>
<tr><td><code id="identifyImageFileNames_+3A_writetags">writeTags</code></td>
<td>
<p>Logical value: should tags be written in YAML format to an
auxiliary file?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NIfTI and Analyze are related formats for storing magnetic resonance images.
NIfTI is a more recent extension of Analyze, and contains more specific
information about, for example, the orientation of the image. Its use is
therefore recommended where possible. MGH format is used by the popular
image processing package FreeSurfer, and MRtrix format by the software of
the same name. These formats use a number of different file extensions, but
the details are abstracted away from the user by these functions.
</p>
<p>TractoR does not allow for files with the same basic name using multiple
Analyze/NIfTI/MGH/MRtrix formats in a single directory (e.g.
<code>"foo.nii"</code> AND <code>"foo.img"</code>), and these functions will produce an
error if multiple compatible files exist.
</p>
<p>Suitable values for <code>fileType</code> (and the <code>tractorFileType</code> option,
which is used as a default for writing) are <code>"NIFTI"</code>,
<code>"NIFTI_PAIR"</code> (the two-file NIfTI format), <code>"MGH"</code>, and
corresponding gzipped versions of these with <code>"_GZ"</code> appended. File
types <code>"ANALYZE"</code> and <code>"MRTRIX"</code>, and <code>"_GZ"</code> variants, are
additionally available for reading only. <code>"NIFTI_GZ"</code> is the default
value for the <code>tractorFileType</code> option, but that can be changed using a
call to <code><a href="base.html#topic+options">options</a></code>, or by setting the <code>TRACTOR_FILETYPE</code>
environment variable before loading the <code>tractor.base</code> package.
</p>
<p>Since multiple files may be involved, copying, moving or symlinking images
is not trivial. <code>copyImageFiles</code> and <code>symlinkImageFiles</code> are
wrappers around the standard functions <code><a href="base.html#topic+file.copy">file.copy</a></code> and
<code><a href="base.html#topic+file.symlink">file.symlink</a></code> which handle this complexity.
</p>


<h3>Value</h3>

<p><code>readImageFile</code> returns an <code><a href="#topic+MriImage-class">MriImage</a></code>
object. <code>imageFileExists</code> returns <code>TRUE</code> if an existing file
with the specified name exists (all file extensions are checked), and
<code>FALSE</code> otherwise. <code>removeImageFiles</code> returns the result of
<code><a href="base.html#topic+unlink">unlink</a></code> applied to all relevant files. <code>writeImageFile</code>
and <code>identifyImageFileNames</code> return a list with the following elements,
describing the identified or written files:
</p>

<dl>
<dt>fileStem</dt><dd><p>The file name without extension.</p>
</dd>
<dt>headerFile</dt><dd><p>The full header file name.</p>
</dd>
<dt>imageFile</dt><dd><p>The full image file name.</p>
</dd>
<dt>format</dt><dd><p>The format of the files (<code>"Nifti"</code>, <code>"Analyze"</code>
or <code>"Mgh"</code>). Not returned by <code>writeImageFile</code>.</p>
</dd>
</dl>

<p><code>copyImageFiles</code> and <code>symlinkImageFiles</code> are called for their
side effects.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p>The NIfTI-1 standard (<a href="http://nifti.nimh.nih.gov/nifti-1">http://nifti.nimh.nih.gov/nifti-1</a>) and
<code><a href="#topic+MriImage-class">MriImage</a></code>.
</p>

<hr>
<h2 id='implode'>Create a character string by concatenating the elements of a vector</h2><span id='topic+implode'></span>

<h3>Description</h3>

<p>Create a character string by concatenating the elements of a vector, using a
separator and optional final separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>implode(strings, sep = "", finalSep = NULL, ranges = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="implode_+3A_strings">strings</code></td>
<td>
<p>A vector, which will be coerced to mode <code>character</code>.</p>
</td></tr>
<tr><td><code id="implode_+3A_sep">sep</code></td>
<td>
<p>A unit length character vector giving the separator to insert
between elements.</p>
</td></tr>
<tr><td><code id="implode_+3A_finalsep">finalSep</code></td>
<td>
<p>An optional unit length character vector giving the
separator to insert between the final two elements.</p>
</td></tr>
<tr><td><code id="implode_+3A_ranges">ranges</code></td>
<td>
<p>Logical value. If <code>TRUE</code> and <code>strings</code> can be
interpreted as integers, collapse runs of consecutive numbers into range
notation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length one.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste">paste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>implode(1:3, ", ")  # "1, 2, 3"
implode(1:3, ", ", " and ")  # "1, 2 and 3"
implode(1:2, ", ", " and ")  # "1 and 2"
implode(1:3, ", ", ranges=TRUE)  # "1-3"

</code></pre>

<hr>
<h2 id='indexList'>Extract one or more elements from a list</h2><span id='topic+indexList'></span>

<h3>Description</h3>

<p>Given a list-like first argument, this function extracts one or more of its
elements. Numeric and character indexing are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexList(list, index = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexList_+3A_list">list</code></td>
<td>
<p>A list-like object, with a <code>[[</code> indexing method.</p>
</td></tr>
<tr><td><code id="indexList_+3A_index">index</code></td>
<td>
<p>A vector of integers or strings, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>index</code> is <code>NULL</code>, the whole list is returned.
Otherwise, if <code>index</code> has length one, the corresponding element is
extracted and returned. Otherwise a list containing the requested subset
is returned.
</p>


<h3>Note</h3>

<p>This function is not type-safe, in the sense that its return type
depends on its arguments. It should therefore be used with care.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>

<hr>
<h2 id='infix'>Resolve a variable to a default when NULL</h2><span id='topic+infix'></span><span id='topic++25+7C+7C+25'></span>

<h3>Description</h3>

<p>This is a very simple infix function for the common TractoR idiom whereby
<code>NULL</code> is used as a default argument value, but later needs to be
resolved to a meaningful value if not overridden in the call. It returns its
first argument unless it is <code>NULL</code>, in which case it falls back on the
second argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X %||% Y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infix_+3A_x">X</code>, <code id="infix_+3A_y">Y</code></td>
<td>
<p>R objects, possibly <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>X</code>, if it is not <code>NULL</code>; otherwise <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+where">where</a></code>, which resolves a value if an expression is
<code>TRUE</code>. Several calls to that function can be conveniently chained
together with this one.
</p>

<hr>
<h2 id='isDeserialisable'>Reference object serialisation and deserialisation</h2><span id='topic+isDeserialisable'></span><span id='topic+serialisation'></span><span id='topic+serialiseReferenceObject'></span><span id='topic+deserialiseReferenceObject'></span><span id='topic+registerDeserialiser'></span>

<h3>Description</h3>

<p>Rather than using R's <code><a href="base.html#topic+save">save</a></code> and <code><a href="base.html#topic+load">load</a></code> functions
directly for reference objects, TractoR uses the
<code><a href="#topic+SerialisableObject-class">SerialisableObject</a></code> class and these functions to save
and load objects. The main difference is that this approach stores only the
data in the object, and not the functions which operate on them. This helps
backward compatibility when new member functions are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isDeserialisable(object, expectedClass = NULL)

serialiseReferenceObject(object, file = NULL)

deserialiseReferenceObject(file = NULL, object = NULL, raw = FALSE)

registerDeserialiser(className, deserialiser)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isDeserialisable_+3A_object">object</code></td>
<td>
<p>For <code>serialiseReferenceObject</code>, a list or object
inheriting from <code><a href="#topic+SerialisableObject-class">SerialisableObject</a></code>. For other
functions, an object in (raw) serialised form. See Details.</p>
</td></tr>
<tr><td><code id="isDeserialisable_+3A_expectedclass">expectedClass</code></td>
<td>
<p>A class name which the object is expected to inherit.
Any class is acceptable if this parameter is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="isDeserialisable_+3A_file">file</code></td>
<td>
<p>A file name to deserialise from.</p>
</td></tr>
<tr><td><code id="isDeserialisable_+3A_raw">raw</code></td>
<td>
<p>If <code>TRUE</code>, the raw serialised object is returned; otherwise
the object is converted back to its original class.</p>
</td></tr>
<tr><td><code id="isDeserialisable_+3A_classname">className</code></td>
<td>
<p>A string naming a class to be handled by the specified
deserialiser.</p>
</td></tr>
<tr><td><code id="isDeserialisable_+3A_deserialiser">deserialiser</code></td>
<td>
<p>A function taking as its argument a list of serialised
fields, and returning a suitable deserialised object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>serialiseReferenceObject</code> function, or the <code>serialise</code> member
function of the <code><a href="#topic+SerialisableObject">SerialisableObject</a></code> class can be used to create
and/or <code><a href="base.html#topic+save">save</a></code> a version of an object which contains a
hierarchical representation of the data embedded in it. These serialised
objects are standard R lists, with an <code>"originalClass"</code> attribute
describing the class of the original object. The
<code>deserialiseReferenceObject</code> function can be used to deserialise them.
Custom deserialisers can be specified using <code>registerDeserialiser</code>,
typically for legacy classes.
</p>
<p>Note that this should generally NOT be used as the primary mechanism for
saving and loading <code><a href="#topic+MriImage">MriImage</a></code> objects. Saving to standard
NIfTI/Analyze format is usually preferable, and can be done using
<code><a href="#topic+writeImageFile">writeImageFile</a></code>.
</p>


<h3>Value</h3>

<p><code>isDeserialisable</code> returns <code>TRUE</code> if the <code>object</code> is
deserialisable and inherits from the specified class.
<code>deserialiseReferenceObject</code> returns a raw or reconstituted object
after deserialisation.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SerialisableObject-class">SerialisableObject</a></code>, <code><a href="base.html#topic+save">save</a></code>,
<code><a href="base.html#topic+load">load</a></code>, <code><a href="#topic+writeImageFile">writeImageFile</a></code>.
</p>

<hr>
<h2 id='locateExecutable'>Find or run an external executable file</h2><span id='topic+locateExecutable'></span><span id='topic+execute'></span>

<h3>Description</h3>

<p>The <code>execute</code> function is a wrapper around the <code><a href="base.html#topic+system2">system2</a></code>
function in base, which additionally echoes the command being run (including
the full path to the executable) if the reportr output level is
<code>Debug</code>. <code>locateExecutable</code> simply returns the path to an
executable file on the system <code>PATH</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locateExecutable(fileName, errorIfMissing = TRUE)

execute(executable, params = NULL, errorOnFail = TRUE, silent = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locateExecutable_+3A_executable">executable</code>, <code id="locateExecutable_+3A_filename">fileName</code></td>
<td>
<p>Name of the executable to run.</p>
</td></tr>
<tr><td><code id="locateExecutable_+3A_params">params</code></td>
<td>
<p>A character vector giving the parameters to pass to the
executable, if any. Elements will be separated by a space.</p>
</td></tr>
<tr><td><code id="locateExecutable_+3A_erroronfail">errorOnFail</code>, <code id="locateExecutable_+3A_errorifmissing">errorIfMissing</code></td>
<td>
<p>Logical value: should an error be produced
if the executable can't be found?</p>
</td></tr>
<tr><td><code id="locateExecutable_+3A_silent">silent</code></td>
<td>
<p>Logical value: should the executable be run without any
output?</p>
</td></tr>
<tr><td><code id="locateExecutable_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="base.html#topic+system">system</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>execute</code>, the return value of the underlying call to
<code><a href="base.html#topic+system2">system2</a></code>. For <code>locateExecutable</code>, the location of the
requested executable, or <code>NULL</code> if it could not be found.
</p>


<h3>Note</h3>

<p>These functions are designed for Unix systems and may not work on
Windows.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+system2">system2</a></code>
</p>

<hr>
<h2 id='mergeMriImages'>Merging MriImage objects</h2><span id='topic+mergeMriImages'></span>

<h3>Description</h3>

<p>This function concatenates the data from a series of <code>MriImage</code>
objects, and then attempts to work out the final dimensions of the merged
image and returns it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeMriImages(..., bindDim = NULL, padTags = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeMriImages_+3A_...">...</code></td>
<td>
<p><code>MriImage</code> objects. They do not need to have the same
dimensionality.</p>
</td></tr>
<tr><td><code id="mergeMriImages_+3A_binddim">bindDim</code></td>
<td>
<p>An integer specifying the dimension along which to bind the
data, or <code>NULL</code> (the default). The latter case resolves to one number
higher than the last dimension common to all images.</p>
</td></tr>
<tr><td><code id="mergeMriImages_+3A_padtags">padTags</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, <code>NA</code>s will be used to pad
tags which appear to be partially missing in the merged dataset. If
<code>FALSE</code>, incomplete tags will be dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A merged image.
</p>


<h3>Note</h3>

<p>Tags are retained as-is if they are identical in each image. Otherwise
they are concatenated if their lengths match the number of blocks in each
image, or concatenated with NAs for missing values if <code>padTags</code> is
<code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MriImage-class">MriImage</a></code>
</p>

<hr>
<h2 id='MriImage-class'>The MriImage class</h2><span id='topic+MriImage-class'></span><span id='topic+MriImage'></span>

<h3>Description</h3>

<p>This class represents an MRI image. An object of this class is made up of
some voxel data, stored as a sparse or dense numeric array, and some
metadata, such as the file it was read from, the voxel dimensions, and so
on. The group generic functions <code><a href="methods.html#topic+Math">Math</a></code>, <code><a href="methods.html#topic+Ops">Ops</a></code> and
<code><a href="methods.html#topic+Summary">Summary</a></code> are defined for this class, as are methods for
coercing to and from a standard <code><a href="base.html#topic+array">array</a></code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>imageDims</code></dt><dd><p>Integer vector of dimensions</p>
</dd>
<dt><code>voxelDims</code></dt><dd><p>Numeric vector of pixel/voxel spacings</p>
</dd>
<dt><code>voxelDimUnits</code></dt><dd><p>Character vector of spatial and/or temporal spacing
units. Millimetres and seconds (i.e., c(&quot;mm&quot;,&quot;s&quot;)) are typical</p>
</dd>
<dt><code>source</code></dt><dd><p>String naming the file(s) that the image was read from. This
is reset to the empty string if the image is modified</p>
</dd>
<dt><code>origin</code></dt><dd><p>Numeric vector giving the spatial coordinate origin</p>
</dd>
<dt><code>xform</code></dt><dd><p>Numeric matrix giving the NIfTI-style xform matrix associated
with the image, which indicates its orientation</p>
</dd>
<dt><code>reordered</code></dt><dd><p>Logical value indicating whether the image has been
reordered. See <code><a href="#topic+reorderMriImage">reorderMriImage</a></code></p>
</dd>
<dt><code>tags</code></dt><dd><p>Named list of arbitrary DICOM-style tags</p>
</dd>
<dt><code>data</code></dt><dd><p>Sparse or dense array of data, or <code>NULL</code></p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>apply(...)</code></dt><dd><p>Apply a function to the margins of the image</p>
</dd>
<dt><code>binarise()</code></dt><dd><p>Binarise the image by setting nonzero values to one</p>
</dd>
<dt><code>fill(value)</code></dt><dd><p>Fill the image with a particular value</p>
</dd>
<dt><code>find(fun = NULL, ..., array = TRUE)</code></dt><dd><p>Find voxels whose values are not zero, or satisfy a function</p>
</dd>
<dt><code>getDataAtPoint(...)</code></dt><dd><p>Obtain the value of the image at a particular point</p>
</dd>
<dt><code>getMetadata()</code></dt><dd><p>Obtain a version of the image with any data removed</p>
</dd>
<dt><code>getNonzeroIndices(array = TRUE, positiveOnly = FALSE)</code></dt><dd><p>Find voxels whose values are not zero</p>
</dd>
<dt><code>getSlice(dim, loc)</code></dt><dd><p>Extract data from a slice of the image along one dimension</p>
</dd>
<dt><code>getSparseness()</code></dt><dd><p>Obtain the proportion of zeroes in the image</p>
</dd>
<dt><code>getTags(keys = NULL)</code></dt><dd><p>Retrieve some or all of the tags stored with the image</p>
</dd>
<dt><code>getXform(implicit = TRUE)</code></dt><dd><p>Retrieve the stored or implicit xform matrix</p>
</dd>
<dt><code>map(fun, ..., sparse = NULL)</code></dt><dd><p>Replace the current data with the result of a function</p>
</dd>
<dt><code>mask(maskImage)</code></dt><dd><p>Mask the image, setting zero voxels in the mask to zero</p>
</dd>
<dt><code>setData(newData)</code></dt><dd><p>Replace the data in the image</p>
</dd>
<dt><code>setOrigin(newOrigin)</code></dt><dd><p>Update the origin of the image</p>
</dd>
<dt><code>setSource(newSource)</code></dt><dd><p>Update the source of the image</p>
</dd>
<dt><code>setTags(..., merge = FALSE)</code></dt><dd><p>Add, replace or merge metadata tags</p>
</dd>
<dt><code>setXform(newXform)</code></dt><dd><p>Update the xform matrix associated with the image</p>
</dd>
<dt><code>summarise()</code></dt><dd><p>Summarise key aspects of the object</p>
</dd>
<dt><code>threshold(level, defaultValue = 0)</code></dt><dd><p>Threshold the image by setting values below the threshold level to zero</p>
</dd>
</dl>

<hr>
<h2 id='newSparseArrayWithData'>Create a SparseArray object</h2><span id='topic+newSparseArrayWithData'></span>

<h3>Description</h3>

<p>This function creates a <code><a href="#topic+SparseArray-class">SparseArray</a></code> object from its
constituent parts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newSparseArrayWithData(data, coordinates, dims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newSparseArrayWithData_+3A_data">data</code></td>
<td>
<p>A vector of (nonzero) array elements.</p>
</td></tr>
<tr><td><code id="newSparseArrayWithData_+3A_coordinates">coordinates</code></td>
<td>
<p>A matrix with as many rows as <code>data</code> has elements,
containing the coordinates of each nonzero element in the array.</p>
</td></tr>
<tr><td><code id="newSparseArrayWithData_+3A_dims">dims</code></td>
<td>
<p>The dimensions of the array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+SparseArray-class">SparseArray</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>

<hr>
<h2 id='nilObject'>The nil object</h2><span id='topic+nilObject'></span><span id='topic+is.nilObject'></span>

<h3>Description</h3>

<p>The nil object is an empty object of class <code><a href="#topic+SerialisableObject">SerialisableObject</a></code>.
It can be used as a placeholder where such an object of this class, or one
of its subclasses, is required. It serialises to the empty list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nilObject()

is.nilObject(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nilObject_+3A_object">object</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nilObject</code> returns the nil object. <code>is.nilObject</code> returns
<code>TRUE</code> if its argument is identical to the nil object, or if it is
equivalent in the sense of serialising to an identical result.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SerialisableObject">SerialisableObject</a></code>
</p>

<hr>
<h2 id='pluralise'>Number agreement with a vector</h2><span id='topic+pluralise'></span>

<h3>Description</h3>

<p>This function chooses the singular or plural form of a word based on the
length of an associated vector, or an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pluralise(singular, x = NULL, n = NULL, plural = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pluralise_+3A_singular">singular</code></td>
<td>
<p>The singular form of the word.</p>
</td></tr>
<tr><td><code id="pluralise_+3A_x">x</code></td>
<td>
<p>A vector of any mode, whose length is used to choose the correct
word form, unless <code>n</code> is specified.</p>
</td></tr>
<tr><td><code id="pluralise_+3A_n">n</code></td>
<td>
<p>An integer which is used to choose the correct word form (singular
if n = 1, plural otherwise). Take priority over <code>x</code> if not
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pluralise_+3A_plural">plural</code></td>
<td>
<p>The plural form of the word. If <code>NULL</code>, an 's' is simply
appended to the singular form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>singular</code> or <code>plural</code>, as appropriate.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>

<hr>
<h2 id='printLabelledValues'>Pretty print labelled information</h2><span id='topic+printLabelledValues'></span>

<h3>Description</h3>

<p>This is a simple function to print a series of labels and associated data
values, or key-value pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printLabelledValues(labels, values, outputLevel = OL$Info,
  leftJustify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printLabelledValues_+3A_labels">labels</code></td>
<td>
<p>A character vector of labels.</p>
</td></tr>
<tr><td><code id="printLabelledValues_+3A_values">values</code></td>
<td>
<p>A character vector of values. Must have the same length as
<code>labels</code>.</p>
</td></tr>
<tr><td><code id="printLabelledValues_+3A_outputlevel">outputLevel</code></td>
<td>
<p>The output level to print the output to. See
<code>setOutputLevel</code>, in the reportr package.</p>
</td></tr>
<tr><td><code id="printLabelledValues_+3A_leftjustify">leftJustify</code></td>
<td>
<p>Logical value: if <code>TRUE</code> the labels will be left
justified; otherwise they will be right justified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="reportr.html#topic+setOutputLevel">setOutputLevel</a></code> for the reportr output level system.
</p>

<hr>
<h2 id='promote'>Promote a vector to a single-column or single-row matrix</h2><span id='topic+promote'></span>

<h3>Description</h3>

<p>The <code>promote</code> function promotes a vector argument to a single-column or
single-row matrix. Matrix arguments are returned unmodified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>promote(x, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="promote_+3A_x">x</code></td>
<td>
<p>A vector or matrix.</p>
</td></tr>
<tr><td><code id="promote_+3A_byrow">byrow</code></td>
<td>
<p>Logical value: if <code>TRUE</code>, a vector will be promoted to a
single-row matrix; otherwise a single-column matrix will result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix version of the <code>x</code> argument.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+matrix">matrix</a></code>
</p>

<hr>
<h2 id='readDicomDirectory'>Read a directory of DICOM files</h2><span id='topic+readDicomDirectory'></span>

<h3>Description</h3>

<p>This function scans a directory for files in DICOM format, and converts them
to a single Analyze/NIfTI-format image of the appropriate dimensionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDicomDirectory(dicomDir, method = c("internal", "divest"),
  readDiffusionParams = FALSE, untileMosaics = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDicomDirectory_+3A_dicomdir">dicomDir</code></td>
<td>
<p>Character vector of length one giving the name of a
directory containing DICOM files.</p>
</td></tr>
<tr><td><code id="readDicomDirectory_+3A_method">method</code></td>
<td>
<p>Character string specifying whether to use the internal DICOM
reading code or use the <code>divest</code> package.</p>
</td></tr>
<tr><td><code id="readDicomDirectory_+3A_readdiffusionparams">readDiffusionParams</code></td>
<td>
<p>Logical value. Should diffusion MRI parameters
(b-values and gradient directions) be retrieved from the files if
possible?</p>
</td></tr>
<tr><td><code id="readDicomDirectory_+3A_untilemosaics">untileMosaics</code></td>
<td>
<p>Logical value. Should Siemens mosaic images be
converted into 3D volumes? This may occasionally be performed in error,
which can be prevented by setting this value to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="readDicomDirectory_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>readDicom</code>, if the <code>divest</code>
method is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing elements
</p>

<dl>
<dt>image</dt><dd><p>An <code><a href="#topic+MriImage-class">MriImage</a></code> object.</p>
</dd>
<dt>bValues</dt><dd><p>Diffusion b-values, if requested. Will be <code>NA</code> if
the information could not be found in files.</p>
</dd>
<dt>bVectors</dt><dd><p>Diffusion gradient vectors, if requested. Will be
<code>NA</code> if the information could not be found in the files.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DicomMetadata-class">DicomMetadata</a></code>, <code><a href="#topic+MriImage-class">MriImage</a></code>,
<code><a href="#topic+sortDicomDirectories">sortDicomDirectories</a></code>.
</p>

<hr>
<h2 id='readDicomFile'>Read a DICOM file into a DicomMetadata object</h2><span id='topic+readDicomFile'></span>

<h3>Description</h3>

<p>This function reads a DICOM file into a <code><a href="#topic+DicomMetadata">DicomMetadata</a></code> object.
Only DICOM files from magnetic resonance scanners are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDicomFile(fileName, checkFormat = TRUE, stopTag = NULL,
  ignoreTransferSyntax = FALSE, ascii = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDicomFile_+3A_filename">fileName</code></td>
<td>
<p>The name of a DICOM file.</p>
</td></tr>
<tr><td><code id="readDicomFile_+3A_checkformat">checkFormat</code></td>
<td>
<p>If <code>TRUE</code>, the function will check for the magic
string <code>"DICM"</code> at byte offset 128. This string should be present,
but in reality not all files contain it.</p>
</td></tr>
<tr><td><code id="readDicomFile_+3A_stoptag">stopTag</code></td>
<td>
<p>An integer vector giving the group and element numbers (in
that order) of a DICOM tag, or <code>NULL</code>. If not <code>NULL</code>, the
function will stop parsing the DICOM file if the specified tag is
encountered. This can be used to speed up the process if a specific tag is
required.</p>
</td></tr>
<tr><td><code id="readDicomFile_+3A_ignoretransfersyntax">ignoreTransferSyntax</code></td>
<td>
<p>If <code>TRUE</code>, any transfer syntax stored in
the file will be ignored, and the code will try to deduce the transfer
syntax using heuristics. This may occasionally be necessary for awkward
DICOM files, but is not generally recommended.</p>
</td></tr>
<tr><td><code id="readDicomFile_+3A_ascii">ascii</code></td>
<td>
<p>If <code>TRUE</code>, the function will attempt to read an embedded
Siemens ASCII header, if one exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>readDicomFile</code> returns a <code><a href="#topic+DicomMetadata-class">DicomMetadata</a></code>
object, or <code>NULL</code> on failure.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p>The DICOM standard, found online at
<a href="https://www.dicomstandard.org/">https://www.dicomstandard.org/</a>. (Warning: may produce headaches!)
Also <code><a href="#topic+readDicomDirectory">readDicomDirectory</a></code> for information on how to create
<code><a href="#topic+MriImage-class">MriImage</a></code> objects from DICOM files.
</p>

<hr>
<h2 id='resolvePath'>Functions for file name and path manipulation</h2><span id='topic+resolvePath'></span><span id='topic+paths'></span><span id='topic+relativePath'></span><span id='topic+matchPaths'></span><span id='topic+registerPathHandler'></span><span id='topic+expandFileName'></span><span id='topic+ensureFileSuffix'></span>

<h3>Description</h3>

<p>Functions for expanding file paths, finding relative paths and ensuring that
a file name has the required suffix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolvePath(path, ...)

relativePath(path, referencePath)

matchPaths(path, referencePath)

registerPathHandler(regex, handler)

expandFileName(fileName, base = getwd())

ensureFileSuffix(fileName, suffix, strip = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolvePath_+3A_path">path</code>, <code id="resolvePath_+3A_referencepath">referencePath</code></td>
<td>
<p>Character vectors whose elements represent file
paths (which may or may not currently exist).</p>
</td></tr>
<tr><td><code id="resolvePath_+3A_...">...</code></td>
<td>
<p>Additional arguments to custom path handlers.</p>
</td></tr>
<tr><td><code id="resolvePath_+3A_regex">regex</code></td>
<td>
<p>A Ruby-style regular expression.</p>
</td></tr>
<tr><td><code id="resolvePath_+3A_handler">handler</code></td>
<td>
<p>A function taking and returning a string.</p>
</td></tr>
<tr><td><code id="resolvePath_+3A_filename">fileName</code></td>
<td>
<p>A character vector of file names.</p>
</td></tr>
<tr><td><code id="resolvePath_+3A_base">base</code></td>
<td>
<p>If <code>fileName</code> is a relative path, this option gives the
base directory which the path is relative to. If <code>fileName</code> is an
absolute path, this argument is ignored.</p>
</td></tr>
<tr><td><code id="resolvePath_+3A_suffix">suffix</code></td>
<td>
<p>A character vector of file suffixes, which will be recycled if
shorter than <code>fileName</code>.</p>
</td></tr>
<tr><td><code id="resolvePath_+3A_strip">strip</code></td>
<td>
<p>A character vector of suffixes to remove before appending
<code>suffix</code>. The intended suffix does not need to be given here, as the
function will not append it if the specified file name already has the
correct suffix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>resolvePath</code> function passes its arguments elementwise through any
matching path handler, and returns the resolved paths. Nonmatching elements
are returned as-is. <code>registerPathHandler</code> registers a new path handler
for special syntaxes, and is for advanced use only. <code>relativePath</code>
returns the specified <code>path</code>, expressed relative to
<code>referencePath</code>. <code>matchPaths</code> resolves a vector of paths against a
vector of reference paths. <code>expandFileName</code> returns the full path to
the specified file name, collapsing <code>".."</code> elements if appropriate.
<code>ensureFileSuffix</code> returns the specified file names with the requested
suffixes appended (if they are not already).
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+normalizePath">normalizePath</a></code> does most of the work for
<code>expandFileName</code>.
</p>

<hr>
<h2 id='resolveVector'>Miscellaneous vector functions</h2><span id='topic+resolveVector'></span><span id='topic+vectorLength'></span><span id='topic+vectorCrossProduct'></span><span id='topic+angleBetweenVectors'></span>

<h3>Description</h3>

<p>These functions provide the (Euclidean) length of a vector, the vector cross
product or angle between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolveVector(len, ...)

vectorLength(vector)

vectorCrossProduct(a, b)

angleBetweenVectors(v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolveVector_+3A_len">len</code></td>
<td>
<p>The expected length of the vector.</p>
</td></tr>
<tr><td><code id="resolveVector_+3A_...">...</code></td>
<td>
<p>Elements of the vector, to be concatenated together.</p>
</td></tr>
<tr><td><code id="resolveVector_+3A_vector">vector</code>, <code id="resolveVector_+3A_v1">v1</code>, <code id="resolveVector_+3A_v2">v2</code></td>
<td>
<p>Numeric vectors of any length.</p>
</td></tr>
<tr><td><code id="resolveVector_+3A_a">a</code>, <code id="resolveVector_+3A_b">b</code></td>
<td>
<p>Numeric 3-vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>vectorLength</code>, the Euclidean norm or length of the
specified vector, given by <code>sqrt(sum(vector^2))</code>. For
<code>vectorCrossProduct</code>, the vector cross product of the two specified
vectors; and for <code>angleBetweenVectors</code>, the angle (in radians)
between the two specified vectors. The <code>resolveVector</code> function
concatenates the values given in <code>...{}</code>, and if the result is a
vector of length <code>len</code> then it is returned. If not, <code>NULL</code> is
returned.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+crossprod">crossprod</a></code> for the matrix cross product.
</p>

<hr>
<h2 id='SerialisableObject-class'>The SerialisableObject class</h2><span id='topic+SerialisableObject-class'></span><span id='topic+SerialisableObject'></span>

<h3>Description</h3>

<p>This reference class extends <code><a href="#topic+TractorObject-class">TractorObject</a></code> by adding a
function for simple serialisation of the data fields of an object, either to
a list or a file. This is intended to be used for classes whose state can
meaningfully be restored from a list of standard R objects (not including
transient C/C++ pointers, for example). A serialised object may be
deserialised using the <code><a href="#topic+deserialiseReferenceObject">deserialiseReferenceObject</a></code> function.
</p>


<h3>Methods</h3>


<dl>
<dt><code>serialise(file = NULL)</code></dt><dd><p>Serialise the object to a list or file</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="base.html#topic+save">save</a></code>
</p>

<hr>
<h2 id='sortDicomDirectories'>Sort a directory of DICOM files into series</h2><span id='topic+sortDicomDirectories'></span>

<h3>Description</h3>

<p>This function sorts a directory containing DICOM files into subdirectories
by series UID (DICOM tag 0x0020,0x000e), subject name (0x0010,0x0010) and/or
scan date (0x0008,0x0020). Each unique identifier, together with its
description for series, will be used as the name for a new subdirectory, and
all relevant files will be copied into that subdirectory. Duplicate file
names are disambiguated if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortDicomDirectories(directories, method = c("internal", "divest"),
  deleteOriginals = FALSE, sortOn = "series", seriesId = c("UID",
  "number", "time"), nested = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortDicomDirectories_+3A_directories">directories</code></td>
<td>
<p>A character vector giving the directories to search for
DICOM files. Subdirectories will also be searched.</p>
</td></tr>
<tr><td><code id="sortDicomDirectories_+3A_method">method</code></td>
<td>
<p>Character string specifying whether to use the internal DICOM
reading code or use the <code>divest</code> package.</p>
</td></tr>
<tr><td><code id="sortDicomDirectories_+3A_deleteoriginals">deleteOriginals</code></td>
<td>
<p>A single logical value. If <code>TRUE</code>, then the
source files will be deleted after being copied to their new locations,
making the operation a move rather than a copy. Nothing will be deleted if
the copy fails.</p>
</td></tr>
<tr><td><code id="sortDicomDirectories_+3A_sorton">sortOn</code></td>
<td>
<p>The string <code>"series"</code>, <code>"subject"</code> or <code>"date"</code>,
or any combination in the order desired. This will be the basis of the
sort, which will be nested if more than one type is specified.</p>
</td></tr>
<tr><td><code id="sortDicomDirectories_+3A_seriesid">seriesId</code></td>
<td>
<p>A string describing the kind of series identifier to use for
sorting by series: <code>"UID"</code> (DICOM tag 0x0020,0x000e; the default),
<code>"number"</code> (0x0020,0x0011) or <code>"time"</code> (0x0008,0x0031).</p>
</td></tr>
<tr><td><code id="sortDicomDirectories_+3A_nested">nested</code></td>
<td>
<p>Logical value. If <code>TRUE</code> and <code>directories</code> is of
length 1, subdirectories will be created within the specified original
directory. Otherwise they will be created in the working directory.</p>
</td></tr>
<tr><td><code id="sortDicomDirectories_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="#topic+readDicomFile">readDicomFile</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readDicomDirectory">readDicomDirectory</a></code> for reading DICOM files into an
<code>MriImage</code> object.
</p>

<hr>
<h2 id='SparseArray-class'>The SparseArray class</h2><span id='topic+SparseArray-class'></span><span id='topic+SparseArray'></span>

<h3>Description</h3>

<p>This class represents an array with any number of dimensions, in which a
significant proportion of entries are zero. The coordinates of nonzero
entries are stored along with their values, with all remaining entries
assumed to be zero. Methods are provided to index into the array in the
standard way, using matrix or vector indices; and for coercing between
<code>SparseArray</code> objects and standard (dense) arrays.
</p>


<h3>Fields</h3>


<dl>
<dt><code>data</code></dt><dd><p>Vector of nonzero data values</p>
</dd>
<dt><code>coords</code></dt><dd><p>Integer matrix of nonzero <code>data</code> locations, one per row</p>
</dd>
<dt><code>dims</code></dt><dd><p>Integer vector of dimensions</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>aperm(perm)</code></dt><dd><p>Permute the dimensions of the array</p>
</dd>
<dt><code>apply(margin, fun, ...)</code></dt><dd><p>Apply a function to margins of the array</p>
</dd>
<dt><code>flip(dimsToFlip)</code></dt><dd><p>Flip the array along one or more directions</p>
</dd>
<dt><code>setCoordinatesAndData(newCoords, newData)</code></dt><dd><p>Update the nonzero locations and data values in the array</p>
</dd>
<dt><code>setDimensions(newDims)</code></dt><dd><p>Change the dimensions of the image</p>
</dd>
<dt><code>summarise()</code></dt><dd><p>Summarise key aspects of the object</p>
</dd>
</dl>

<hr>
<h2 id='threadSafeTempFile'>Obtain thread-safe temporary file names</h2><span id='topic+threadSafeTempFile'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code><a href="base.html#topic+tempfile">tempfile</a></code>, which creates
temporary file names whose path contains the process ID of the calling
process. This avoids clashes between threads created by functions such as
<code>mclapply</code> (in the &ldquo;parallel&rdquo; package), which can easily occur with
the standard <code><a href="base.html#topic+tempfile">tempfile</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threadSafeTempFile(pattern = "file")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threadSafeTempFile_+3A_pattern">pattern</code></td>
<td>
<p>Character vector giving the initial part of each file name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of temporary file names. No files are actually
created.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tempfile">tempfile</a></code>
</p>

<hr>
<h2 id='TractorObject-class'>The TractorObject class</h2><span id='topic+TractorObject-class'></span><span id='topic+TractorObject'></span>

<h3>Description</h3>

<p>This reference class extends the standard <code><a href="methods.html#topic+envRefClass-class">envRefClass</a></code>
class, adding methods for finding all of the field or methods available for
an object. There is also a method for summarising key elements of the object
as a named character vector, which can be suitable overridden by inheriting
classes. The <code>show</code> method prints this summary as a labelled list.
</p>


<h3>Methods</h3>


<dl>
<dt><code>fields()</code></dt><dd><p>Retrieve a list of all field names</p>
</dd>
<dt><code>methods()</code></dt><dd><p>Retrieve a list of all method names</p>
</dd>
<dt><code>summarise()</code></dt><dd><p>Summarise key aspects of the object</p>
</dd>
</dl>

<hr>
<h2 id='where'>Compact conditional values</h2><span id='topic+where'></span>

<h3>Description</h3>

<p>This simple function checks whether its first argument is a logical value
that evaluates to <code>TRUE</code>. If so, it returns its second argument. If
not, it returns its third argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(condition, value, fallback = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where_+3A_condition">condition</code></td>
<td>
<p>An expression that resolves to a single logical value.</p>
</td></tr>
<tr><td><code id="where_+3A_value">value</code>, <code id="where_+3A_fallback">fallback</code></td>
<td>
<p>Any expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from the standard <code><a href="base.html#topic+ifelse">ifelse</a></code> function in
that it does not act elementwise, and that the third argument is optional,
defaulting to <code>NULL</code>.
</p>


<h3>Value</h3>

<p><code>value</code>, if <code>condition</code> evaluates to <code>TRUE</code>;
otherwise <code>fallback</code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden
</p>


<h3>References</h3>

<p>Please cite the following reference when using TractoR in your
work:
</p>
<p>J.D. Clayden, S. Muñoz Maniega, A.J. Storkey, M.D. King, M.E. Bastin &amp; C.A.
Clark (2011). TractoR: Magnetic resonance imaging and tractography with R.
Journal of Statistical Software 44(8):1-18. <a href="https://doi.org/10.18637/jss.v044.i08">doi:10.18637/jss.v044.i08</a>.
</p>


<h3>See Also</h3>

<p>ifelse
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
