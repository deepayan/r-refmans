<!DOCTYPE html><html><head><title>Help for package paletteknife</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {paletteknife}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoaxis'><p>Auto Axis Tool</p></a></li>
<li><a href='#autocol'><p>Map Colours From Value</p></a></li>
<li><a href='#autolegend'><p>Add Auto-Generated Legend</p></a></li>
<li><a href='#autopal'><p>Auto-Palette</p></a></li>
<li><a href='#autozoom'><p>Auto Zoom to Create a Dynamic Plot</p></a></li>
<li><a href='#palette.display'><p>Built-in Paletteknife Palettes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create Colour Scales and Legend from Continuous or Categorical
Vectors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Streamlines the steps for adding colour scales and associated legends 
         when working with base R graphics, especially for interactive use. Popular
         palettes are included and pretty legends produced when mapping a large 
         variety of vector classes to a colour scale. An additional helper for 
         adding axes and grid lines complements the base::plot() work flow.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/johnxhobbs/paletteknife">https://github.com/johnxhobbs/paletteknife</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/johnxhobbs/paletteknife/issues">https://github.com/johnxhobbs/paletteknife/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>graphics, grDevices</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-20 16:04:28 UTC; john</td>
</tr>
<tr>
<td>Author:</td>
<td>John Hobbs [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Hobbs &lt;johnxhobbs@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-20 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoaxis'>Auto Axis Tool</h2><span id='topic+autoaxis'></span>

<h3>Description</h3>

<p>Overlay base plot with a new axis and optional gridlines. The axis spacing can
be manually specified or automatically generated, including for date and time
axis. A default grid is drawn if called with just the <code>side</code> specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoaxis(
  side,
  major = NA,
  major_grid = FALSE,
  minor = NA,
  minor_grid = FALSE,
  format = "auto",
  spacing = TRUE,
  tck = -0.03,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoaxis_+3A_side">side</code></td>
<td>
<p>Side to add axis, 1 = bottom, 2 = left, 3 = top, 4 = right. If
only this argument is given, a default dense grid is drawn. If
this argument is given as a character, a date-time grid will be
attempted, for example <code>side='1'</code></p>
</td></tr>
<tr><td><code id="autoaxis_+3A_major">major</code></td>
<td>
<p>Spacing of major axis ticks and labels (or approx. number of
intervals if <code>spacing = FALSE</code>). If the axis is date or time,
use a interval specified in <code>?seq.POSIXt</code>, such as 'sec' or
'week', or character value for spacing such as <code style="white-space: pre;">&#8288;='20'&#8288;</code></p>
</td></tr>
<tr><td><code id="autoaxis_+3A_major_grid">major_grid</code></td>
<td>
<p>Add grid lines corresponding to major axis ticks, <code>TRUE</code>
to get default translucent black, otherwise colour (name or hex)</p>
</td></tr>
<tr><td><code id="autoaxis_+3A_minor">minor</code></td>
<td>
<p>Spacing (or number) of minor ticks (note, no label for minor).
If given as a character string, it will pass to <code>seq.POSIXt</code></p>
</td></tr>
<tr><td><code id="autoaxis_+3A_minor_grid">minor_grid</code></td>
<td>
<p>Add gridlines for minor ticks, <code>TRUE</code> uses transparent
black, otherwise colour string</p>
</td></tr>
<tr><td><code id="autoaxis_+3A_format">format</code></td>
<td>
<p>Date or time format for major axis for example <code>'%Y %b'</code>. If left
as the default <code>'auto'</code> an appropriate choice between seconds
and years will be used. Note, <code>major</code> or <code>side</code> must be given as a
character string to trigger datetime labels.</p>
</td></tr>
<tr><td><code id="autoaxis_+3A_spacing">spacing</code></td>
<td>
<p>Should <code>major</code> and <code>minor</code> be interpreted as tick spacing
(default) or approximate number of ticks</p>
</td></tr>
<tr><td><code id="autoaxis_+3A_tck">tck</code></td>
<td>
<p>Size of axis tick: minor axis will always take half this value</p>
</td></tr>
<tr><td><code id="autoaxis_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>axis()</code>, for example <code>las=2</code>
for perpendicular labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Major and minor tick marks can be specified in a number of ways:
</p>

<ul>
<li><p> As a character string if the axis is datetime, such as 'year' or 'hour'
which are passed as <code>by</code> to <code>seq()</code>. These can be prefixed with an integer multiplier,
for example '6 hour' or '10 year', as per <code>seq.POSIXt</code>
</p>
</li>
<li><p> As a tick interval using the default <code>spacing = TRUE</code>
</p>
</li>
<li><p> As an approximate number of tick marks to include, using <code>pretty()</code> to find
the best interval, using <code>spacing = FALSE</code>. Use a character number if this
is a Date or Time axis, such as <code>major = '100'</code> and <code>spacing</code> will be set
FALSE automatically.
</p>
</li></ul>

<p>Major adds labels and ticks, minor is just half-sized ticks marks. Both
tick sizes can be changed (or direction changed) using <code>tck</code>.
</p>
<p>Three different datetime axis are possible: year, day-offset, seconds-offset. Use
<code>format</code> to specify how the label should appear, such as '%b %Y' (see <code>?strptime</code>)
</p>

<ul>
<li><p> Year should be treated as a conventional numeric axis, use <code>major=1/12</code> not <code>major='month'</code>
</p>
</li>
<li><p> day-offset is an axis of <code>class(x)=='Date'</code> and is identified if the axis range exists
within +/-9e4, meaning within dates 1723 - 2216, and minimum interval is 'day'
</p>
</li>
<li><p> second-offset is an axis of <code>class(x)=='POSIXct'</code> and is identified by a range outside
of +/-9e4. This will give very strange results if your entire POSIXct axis is within
24 hours of 1970-01-01
</p>
</li></ul>

<p>A grid can be added at the same time by setting <code>major_grid</code> or <code>minor_grid</code> to <code>TRUE</code>
or a colour string. If <code>TRUE</code>, a transparent black is used by default.
</p>
<p>Any other options can be passed through to <code>axis()</code> directly (see <code>?axis</code>), most
notably <code>las = 2</code> to rotate the labels, and <code>cex.axis</code> for label size.
</p>
<p>The function will exit with a warning if more than 1000 ticks or gridlines were
generated, as this is most likely a mistake with autogenerated date / time intervals
and can lead to very slow behaviour.
</p>
<p>This does NOT work well for <code>barplot()</code> categorical axis, for this continue to use
the basic <code>axis()</code> function with custom labels, see examples.
</p>


<h3>Value</h3>

<p>No return value (<code>NULL</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(sunspots) # This time series is actually given in decimal years
  autoaxis(side=3, major=50, major_grid='coral', minor=10, minor_grid=TRUE, spacing=TRUE)
  autoaxis(side=4, major=11, minor=25, spacing=FALSE, las=2, cex.axis=0.5, tck=0.02)

plot(seq(as.POSIXct('2020-01-01'),as.POSIXct('2020-01-03'),length.out=1e3),
    rnorm(1e3), xlab='POSIXct', xaxt='n')
  autoaxis(side=1, major='day', minor='3 hour', format='%x')
  # Shortcut method to make a default dense grid
  autoaxis(side='3')
  autoaxis(side=2)
  # You can always request a datetime axis (side='4' not 4L) but it will be nonsense
  autoaxis(side='4', col='red')

plot(seq(as.Date('2013-02-01'),as.Date('2020-01-03'),length.out=1e3),
    rnorm(1e3), xlab='Date', xaxt='n')
  autoaxis(side=1, major='10', minor='50', format='%Y')
  autoaxis(side=3, minor='3 month', minor_grid=TRUE)

# Guessing is ambiguous with small values, depends on smallest interval
plot(1:500,runif(500), type='l', xaxt='n', xlab='Time or Date?', main=
  'For small values (&lt;1e5), use interval to guess format\n')
autoaxis(1, major='min', minor='10 sec', format='%M:%S')
autoaxis(3, major='quarter', minor='month', format='%b %Y')

# For barplot() use base functions - remember to set width=1, space=0
# otherwise bars will not be plotted on integer x-coordinates
barplot(mtcars$mpg, width=1, space=0, ylab='mpg')
  # Adjust the x-axis down by 0.5 so that the tick is in centre of each bar
  axis(side=1, at=-0.5+1:length(mtcars$mpg), labels=rownames(mtcars), las=2 )
  # Often prettier, label each bar inside the bar itself using text()
  text(x=-1+1:length(mtcars$mpg), y=1, pos=4,
    labels=rownames(mtcars), srt=90, cex=0.7)
  # autoaxis can still be used for adjusting the numeric scale
  autoaxis(side=2, major=5, major_grid=TRUE, minor=1, minor_grid=TRUE)

</code></pre>

<hr>
<h2 id='autocol'>Map Colours From Value</h2><span id='topic+autocol'></span><span id='topic+palette.misc'></span><span id='topic+palette.viridis'></span><span id='topic+palette.colorbrewer'></span>

<h3>Description</h3>

<p>Create a vector of colours and associated legend for easier base plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocol(
  x,
  set = "",
  alpha = NA,
  limits = NA,
  na_colour = NA,
  bias = 1,
  legend_len = 6
)

palette.misc

palette.viridis

palette.colorbrewer
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocol_+3A_x">x</code></td>
<td>
<p>Vector to be mapped to colours</p>
</td></tr>
<tr><td><code id="autocol_+3A_set">set</code></td>
<td>
<p>Colour set to use &ndash; see Details for full list. A default <code>sasha</code> or <code>viridis</code> is chosen if empty.</p>
</td></tr>
<tr><td><code id="autocol_+3A_alpha">alpha</code></td>
<td>
<p>Transparency as a single value or as another vector (recycled to fill).
If it is a vector, all values are scaled from 0:max(alpha) meaning transparent:opaque.
Single values must be in range 0-1. If <code>NA</code> no alpha channel is added.</p>
</td></tr>
<tr><td><code id="autocol_+3A_limits">limits</code></td>
<td>
<p>Colour scale limits as absolute range <code>c(0,10)</code> or <code>NA</code> = full range</p>
</td></tr>
<tr><td><code id="autocol_+3A_na_colour">na_colour</code></td>
<td>
<p>Colour to represent NA-values, default <code>NA</code> returns a colour of <code>NA</code> (thus not plotted)</p>
</td></tr>
<tr><td><code id="autocol_+3A_bias">bias</code></td>
<td>
<p>Skew to apply to colour-ramp (&gt;1 increases resolution at low end, &lt;1 at the high end)</p>
</td></tr>
<tr><td><code id="autocol_+3A_legend_len">legend_len</code></td>
<td>
<p>Continuous legend target size</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>
<p>An object of class <code>list</code> of length 8.
</p>
<p>An object of class <code>list</code> of length 35.
</p>


<h3>Details</h3>

<p>Helper function for using colours in R's default <code>plot()</code> and <code>legend()</code>. Colours
from built-in palettes are automatically scaled to return a vector of colours
and create <code>options('autolegend')</code> which contains the correct legend mapping for
<code>autolegend()</code>.
</p>
<p>A discrete palette is used for factor and character inputs whilst a
continuous palette is used for integer and numeric.
</p>
<p>Colour sets built-in so far are held in lists starting <code>pals.</code> and can be
visualized most easily with <code>pals_display()</code>. The <code>set</code> argument can be
any of the colour set names listed here (such as 'magma'), or from <code>palette.pals()</code>,
or finally as a custom-defined vector, such as <code>set = rainbow(5)</code>.
</p>
<p>The current lists of palettes included with paletteknife all being with <code>pal.</code>
</p>

<ul>
<li> <p><strong><code>pals.viridis</code></strong>
</p>
<p>All of the continuous palette forked from the <code>viridisLite</code> package maintained by Simon Garnier.
</p>

<ul>
<li><p> Contains: <code>cividis</code> <code>inferno</code> <code>magma</code> <code>mako</code> <code>plasma</code> <code>rocket</code> <code>turbo</code> <code>viridis</code>
</p>
</li></ul>

</li>
<li> <p><strong><code>pals.rcolorbrewer</code></strong>
</p>
<p>All of the palettes included in RColorBrewer
</p>

<ul>
<li><p> Categorical:
<code>Accent</code> <code>Set1</code> <code>Set2</code> <code>Set3</code> <code>Paired</code> <code>Pastel1</code> <code>Pastel2</code> <code>Dark2</code>
</p>
</li>
<li><p> Continuous:
<code>Greys</code> <code>Blues</code> <code>BuGn</code> <code>BuPu</code> <code>Greens</code> <code>GnBu</code> <code>PuBu</code> <code>Purples</code> <code>PuBuGn</code>
<code>YlGnBu</code> <code>YlGn</code>
<code>YlOrBr</code> <code>YlOrRd</code> <code>Oranges</code> <code>OrRd</code> <code>Reds</code> <code>RdPu</code> <code>PuRd</code>
</p>
</li>
<li><p> Divergent:
<code>Spectral</code> <code>RdYlBu</code> <code>RdYlGn</code>
<code>BrBG</code> <code>RdBu</code> <code>RdGy</code> <code>PiYG</code> <code>PRGn</code> <code>PuOr</code>
</p>
</li></ul>

</li>
<li> <p><strong><code>pals.misc</code></strong>
</p>

<ul>
<li><p> Sasha Trubetskoy  (2017): <em>List of 20 Simple, Distinct Colors</em>: <code>sasha</code>
</p>
</li></ul>

</li></ul>

<p>Custom limits can be specified using <code>c(0,10)</code>. This is useful if multiple
plots using the same range are required for cross-comparison. Default
behaviour (<code>limits = NA</code>) sets the range to exactly fit.
</p>
<p>The skew of the colourscale can be adjusted with <code>bias</code>, for example if <code>x</code>
has an exponential distribution, a bias value &gt; 1 will bring out contrast at
the low end.
</p>


<h3>Value</h3>

<p>A character vector of colours of equal length to input <code>x</code>, sampled from the chosen <code>set</code>.
This allows it to be used for plotting directly. Information for a legend (containing every
level for categorical data, or approximately length <code>legend_len</code> for continuous) is stored in
<code>options('autolegend')</code> and not returned explicitly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(iris$Sepal.Length, iris$Petal.Length, cex=3, pch=16,
    col=autocol(iris$Petal.Width, set='PuBuGn', alpha=0.8, legend_len=12) )
  autolegend('topleft', title='Petal.Width', ncol=3)
  # Also try simplest "autolegend()" for click-to-draw

# Try scales which include NA in both colour and alpha channel
with(airquality, plot(Temp, col=autocol(x=Solar.R, set='YlOrRd', alpha=Ozone,
    na_colour='cyan'), pch=16, cex=sqrt(Wind) ))
  # Note inset=1 draws on opposite side ie above not below plot area
  autolegend('bottom', inset=1, bty='n', horiz=TRUE)


# Here we want a summary plot ordered by level, so need to create a colour vector to match
# 'Alphabet' is a built-in colour set, see "palette.pals()"
mixedbag = as.factor(sample(letters,1000,replace=TRUE))
  plot(x=mixedbag, y=rnorm(1000), col=autocol(levels(mixedbag), set='Alphabet'))
  autolegend('bottom', ncol=9, cex=0.7)

# Maintain the order of strings
barplot(1:8, col=autocol(LETTERS[8:1]))
  autolegend('topleft')

# Any unusual formats are coerced to numeric and the legend converted back
mydates = as.Date('2000-01-01')+0:100
  plot(mydates, pch=16, col=autocol(mydates, set=rainbow(10), bias=2) )
  autolegend(x=0, y=mydates[100], title='My Dates')

# Timeseries objects plot as a line, but can overlay with points()
plot(airmiles)
  points(airmiles, pch=15, col=autocol(airmiles, set='Reds'))

# Use the limits to clip or augment the colour-scale
layout(matrix(1:2))
  plot(runif(10), col=autocol(1:10, limits=c(0,20)), pch=16,
    main='Data split over two plots with same scale')
  plot(runif(10), col=autocol(c(100,20:12), limits=c(0,20)), pch=16)
  text(1, 0.5, pos=4, xpd=NA,
'This point has a
value of 100 but
clipped to max
colour == 20')
  autolegend('bottom', inset=1, horiz=TRUE) # Draws above!
  layout(1)

</code></pre>

<hr>
<h2 id='autolegend'>Add Auto-Generated Legend</h2><span id='topic+autolegend'></span>

<h3>Description</h3>

<p>Add a legend for the last <code>autocol()</code> set generated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autolegend(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autolegend_+3A_...">...</code></td>
<td>
<p>Arguments passed directly to <code>legend</code> &ndash; legend text and colours are taken
automatically from <code>options('autolegend')</code>. See examples for useful
parameters, including <code>pch</code> and <code>pt.cex</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no location (such as 'top', 'above', or an x,y coordinate) is given, then it
calls the <code>locator()</code> crosshairs so the position of the legend can be picked
interactively. All arguments are passed to <code>legend()</code>, see <code>?legend</code> for a full
list.
</p>
<p>Positions 'above' and 'below' are allowed which shorthand for inset and
horizontal (see example).
</p>
<p>Legend labels and fill are generated by either <code>autopal()</code> or <code>autocol()</code> and
stored in the global <code>options('autolegend')</code> where they can be manipulated
if needs be.
</p>
<p>See more examples in ?autocol for a <code>plot()</code> and <code>autolegend()</code> work flow.
</p>


<h3>Value</h3>

<p>No return value (<code>NULL</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simplest version: click-to-draw with locator()
plot(1:10, pch=16, col=autocol(1:10, 'Blues', legend_len=5))
# autolegend() # Try me! And click on plot to add legend

# Other neat versions -- note ?legend
autolegend('above', title='Above plot')
# Exactly equivalent to...
autolegend('bottom', inset=1, horiz=TRUE, bty='n')
autolegend(x=6, y=4, ncol=2, title='Draw at (6,4)')
autolegend('topleft', title='"topleft"', ncol=2, bty='n')

# Use pch (and optionally pt.cex) in legend -- these get recycled
autolegend('bottom', horiz=TRUE, pch=16, pt.cex=3, title='pch=16, pt.cex=3')
autolegend('right', pch=1:10, pt.cex=2, title='pch=1:10')

# Manipulate the legend text, for example with format(), this is a bit long-winded!
heatmap(as.matrix(eurodist), col=autopal('turbo', limits=range(eurodist)) )
current_legend = options('autolegend')[[1]]
options(autolegend = list(format(current_legend[[1]], big.mark=','), current_legend[[2]]))
autolegend('bottom', inset=1, horiz=TRUE, title='Misleading miles between cities')

# No helper exists yet for creating size or shape legends -- follow this idea...
with(airquality, plot(Temp, pch=16, cex=Solar.R/100, col=autocol(Ozone, set='Reds')))
cex_legend = pretty(airquality$Solar.R)
legend('bottom', pt.cex=cex_legend/100, legend=cex_legend, pch=1,
  horiz=TRUE, title='Solar.R', bty='n' )
autolegend('above', title='Ozone')

</code></pre>

<hr>
<h2 id='autopal'>Auto-Palette</h2><span id='topic+autopal'></span>

<h3>Description</h3>

<p>Return a palette vector from one of the built-in sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autopal(set = "", n = 30, limits = NA, bias = 1, legend_len = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autopal_+3A_set">set</code></td>
<td>
<p>Colour set to use &ndash; see ?autocol for full list. A default <code>sasha</code> or <code>viridis</code> is chosen if empty.</p>
</td></tr>
<tr><td><code id="autopal_+3A_n">n</code></td>
<td>
<p>Length of colour vector to return, must be at least 2</p>
</td></tr>
<tr><td><code id="autopal_+3A_limits">limits</code></td>
<td>
<p>Colour scale limits to pass to legend eg <code>c(0,10)</code> &ndash; if left as <code>NA</code> no autolegend will be generated</p>
</td></tr>
<tr><td><code id="autopal_+3A_bias">bias</code></td>
<td>
<p>Skew to apply to colour-ramp (&gt;1 increases resolution at low end, &lt;1 at the high end)</p>
</td></tr>
<tr><td><code id="autopal_+3A_legend_len">legend_len</code></td>
<td>
<p>Continuous legend target size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be used where a palette is provided rather than a mapped colour
vector, for example <code>image()</code>. The limits must be specified for <code>autolegend()</code>
information to be updated.
Custom colour limits can be set using <code>breaks</code> or <code>levels</code> (see examples) if
the same colour range is needed across several plots.
</p>
<p>See ?autocol for list of all available colour sets.
</p>


<h3>Value</h3>

<p>A character vector of colours of length <code>n</code> giving a continuous colour palette sampled from <code>set</code>.
If <code>limits</code> are specified, information for a colour legend is produced of approximate length
<code>legend_len</code>. This is stored in <code>options('autolegend')</code> and not returned explicitly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image(volcano, col=autopal('RdYlGn', n=100, limits=c(50,200), bias=1.5),
    breaks=seq(50,200,length.out=101) )
  autolegend('bottom', inset=1, ncol=5)

# Or using the slightly smarter filled.contour
filled.contour(volcano, col=autopal('RdYlGn', n=20, limits=c(100,150)),
  levels=seq(50,200,length.out=21) )

</code></pre>

<hr>
<h2 id='autozoom'>Auto Zoom to Create a Dynamic Plot</h2><span id='topic+autozoom'></span>

<h3>Description</h3>

<p>Replaces <code>plot()</code> with an interactive loop which allows user to click twice
on the plot window to redraw with new limits. Press ESCAPE to finish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autozoom(x, ..., after = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autozoom_+3A_x">x</code></td>
<td>
<p>Passed directly to <code>plot()</code></p>
</td></tr>
<tr><td><code id="autozoom_+3A_...">...</code></td>
<td>
<p>Passed directly to <code>plot()</code></p>
</td></tr>
<tr><td><code id="autozoom_+3A_after">after</code></td>
<td>
<p>An expression to be executed after each plot is drawn</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Click twice to set the new plot extents. If both clicks are on one of the axis
(outside of the plot area) then only this axis is zoomed. Click twice on the
same spot to reset the zoom to the entire plot.
</p>
<p>Extras such as axes or legends are added using the <code>after</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
autozoom(airmiles)

autozoom(faithful, cex=runif(272), after={autoaxis(3); autoaxis(4)})

autozoom(faithful, col=autocol(runif(272)), pch=16,
  after=autolegend('above') )

## End(Not run)

</code></pre>

<hr>
<h2 id='palette.display'>Built-in Paletteknife Palettes</h2><span id='topic+palette.display'></span>

<h3>Description</h3>

<p>Plot a list of palettes for comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette.display(palette = palette.colorbrewer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palette.display_+3A_palette">palette</code></td>
<td>
<p>Character vector of palette names or a named list of colour vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value (<code>NULL</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>palette.display(c(palette.misc,palette.colorbrewer,palette.viridis))

palette.display(c(list(rainbow=rainbow(10), default=palette()),
               palette.misc, palette.colorbrewer[c('Paired','Set1','Set2')] ))

palette.display(list(rainbow=rainbow(45)[30:1], turbo=palette.viridis$turbo ))

# Call by vector of names - here it gets 'Paired' from palette.colorbrewer
palette.display(palette.pals() )

# Bit of fun ordering a list of palettes (MUST be same palette size)
mat_cols = do.call(rbind, lapply(palette.colorbrewer[9:26],
                          function(hex) as.vector(rgb2hsv(col2rgb(hex)))))
palette.display(palette.colorbrewer[9:26][hclust(dist(mat_cols))$order])

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
