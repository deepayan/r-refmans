<!DOCTYPE html><html lang="en"><head><title>Help for package longitudinal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {longitudinal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#longitudinal-package'><p>The longitudinal package</p></a></li>
<li><a href='#dyn.cor'><p>Dynamical Correlation and Covariance</p></a></li>
<li><a href='#dyn.scale'><p>Dynamical Scale, Moments, and Weights</p></a></li>
<li><a href='#longitudinal'><p>Data Structure for Longitudinal Data</p></a></li>
<li><a href='#longitudinal-internal'><p>Internal longitudinal Functions</p></a></li>
<li><a href='#longitudinal.util'><p>Utility Functions for the &quot;Longitudinal&quot; Data Structure</p></a></li>
<li><a href='#tcell'><p>Microarray Time Series Data for T-Cell Activation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.1.13</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Multiple Time Course Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Rainer Opgen-Rhein and Korbinian Strimmer.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Korbinian Strimmer &lt;strimmerlab@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), corpcor (&ge; 1.6.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains general data structures and
  functions for longitudinal data with multiple variables, 
  repeated measurements, and irregularly spaced time points.
  Also implements a shrinkage estimator of dynamical correlation
  and dynamical covariance.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://strimmerlab.github.io/software/longitudinal/">https://strimmerlab.github.io/software/longitudinal/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-13 19:51:22 UTC; strimmer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-13 20:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='longitudinal-package'>The longitudinal package</h2><span id='topic+longitudinal-package'></span>

<h3>Description</h3>

<p>This package contains general data structures and
functions for longitudinal data with multiple variables, 
repeated measurements, and irregularly spaced time points.
It also implements a shrinkage estimator of dynamical correlation
and dynamical covariance.
</p>


<h3>Author(s)</h3>

<p>Rainer Opgen-Rhein and Korbinian Strimmer (<a href="https://strimmerlab.github.io/">https://strimmerlab.github.io/</a>)</p>


<h3>References</h3>

<p>See website: <a href="https://strimmerlab.github.io/software/longitudinal/">https://strimmerlab.github.io/software/longitudinal/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+longitudinal">longitudinal</a>, <a href="#topic+dyn.cor">dyn.cor</a>.</code>
</p>

<hr>
<h2 id='dyn.cor'>Dynamical Correlation and Covariance</h2><span id='topic+dyn.cor'></span><span id='topic+dyn.pcor'></span><span id='topic+dyn.invcor'></span><span id='topic+dyn.cov'></span><span id='topic+dyn.pvar'></span><span id='topic+dyn.var'></span><span id='topic+dyn.invcov'></span>

<h3>Description</h3>

<p>The functions estimate dynamical correlation and covariance, and
related quantities.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyn.cor(x, lambda, verbose=TRUE)
dyn.var(x, lambda.var, verbose=TRUE)
dyn.cov(x, lambda, lambda.var, verbose=TRUE)
dyn.invcor(x, lambda, verbose=TRUE)
dyn.invcov(x, lambda, lambda.var, verbose=TRUE)
dyn.pvar(x, lambda, lambda.var, verbose=TRUE)
dyn.pcor(x, lambda, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dyn.cor_+3A_x">x</code></td>
<td>
<p>a data matrix</p>
</td></tr>
<tr><td><code id="dyn.cor_+3A_lambda">lambda</code></td>
<td>
<p>the correlation shrinkage intensity (range 0-1). If <code>lambda</code> is not specified 
(the default) it is estimated using an analytic formula from Sch\&quot;afer 
and Strimmer (2005) and Opgen-Rhein and Strimmer (2006a,b).
For <code>lambda=0</code> the empirical correlations are recovered.
See also <code><a href="corpcor.html#topic+cor.shrink">cor.shrink</a></code>.</p>
</td></tr>
<tr><td><code id="dyn.cor_+3A_lambda.var">lambda.var</code></td>
<td>
<p>the variance shrinkage intensity (range 0-1). If <code>lambda.var</code> is not specified 
(the default) it is estimated using an analytic formula from Sch\&quot;afer 
and Strimmer (2005) and Opgen-Rhein and Strimmer (2006a,b).
For <code>lambda.var=0</code> the empirical variances are recovered.
See also <code><a href="corpcor.html#topic+var.shrink">var.shrink</a></code>.</p>
</td></tr>  
<tr><td><code id="dyn.cor_+3A_verbose">verbose</code></td>
<td>
<p>report progress while computing (default: TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dynamical correlation and related quantities implemented here
follow the definition of Opgen-Rhein and Strimmer (2006a,b).
This approach is derived from a FDA perspective. Essentially, it takes account 
of the distances between the various time points by assigning weights to samples.
If these weights are all equal the usual iid estimators are obtained.
</p>
<p>For details about the analytic shrinkage procedure consult 
Opgen-Rhein and Strimmer (2006b) and  Sch\&quot;afer and Strimmer (2005)
as well as the help page of <code><a href="corpcor.html#topic+cov.shrink">cov.shrink</a></code>.
</p>


<h3>Value</h3>

<p><code>dyn.cor</code> returns the dynamical correlation matrix.
<code>dyn.var</code> returns the vector of dynamical variances.
<code>dyn.cov</code> returns the dynamical covariance matrix. 
</p>
<p><code>dyn.invcor</code> returns the inverse dynamical correlation matrix.
<code>dyn.invcov</code> returns the inverse dynamical covariance matrix. 
</p>
<p><code>dyn.pvar</code> returns the vector of partial dynamical variances.
<code>dyn.pcor</code> returns the partial dynamical correlation matrix.  
</p>


<h3>Author(s)</h3>

<p>Rainer Opgen-Rhein and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Opgen-Rhein, R., and K. Strimmer. 2006a. Inferring gene dependency networks from 
genomic longitudinal data: a functional data approach.
REVSTAT <b>4</b>:53-65.
</p>
<p>Opgen-Rhein, R., and K. Strimmer. 2006b. Using regularized dynamic correlation 
to infer gene dependency networks from time-series microarray data. 
The 4th International Workshop on Computational Systems Biology,
WCSB 2006 (June 12-13, 2006, Tampere, Finland). 
</p>
<p>Schaefer, J., and Strimmer, K. (2005).  A shrinkage approach to large-scale
covariance estimation and implications for functional genomics. 
Statist. Appl. Genet. Mol. Biol. <b>4</b>:32.
&lt;DOI:10.2202/1544-6115.1175&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dyn.weights">dyn.weights</a></code>, <code><a href="corpcor.html#topic+cov.shrink">cov.shrink</a></code>, <code><a href="corpcor.html#topic+pcor.shrink">pcor.shrink</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load "longitudinal" library
library("longitudinal")

# load tcell data
data(tcell)
get.time.repeats(tcell.34)


# dynamical partial correlation 
# (this takes into account of the unequal spacings between time points) 
dynpc &lt;- dyn.pcor(tcell.34, lambda=0)

# static partial correlation
statpc &lt;- pcor.shrink(tcell.34, lambda=0)

# this is NOT the same
sum((dynpc - statpc)^2)

</code></pre>

<hr>
<h2 id='dyn.scale'>Dynamical Scale, Moments, and Weights</h2><span id='topic+dyn.scale'></span><span id='topic+dyn.moments'></span><span id='topic+dyn.weights'></span><span id='topic+time2weights'></span>

<h3>Description</h3>

<p><code>time2weights</code> computes weights corresponding to time points
</p>
<p><code>dyn.weights</code> computes these weights for a given <code><a href="#topic+longitudinal">longitudinal</a></code> matrix.
</p>
<p><code>dyn.moments</code> computes means and variances for the variables in
a <code><a href="#topic+longitudinal">longitudinal</a></code> object.
</p>
<p><code>dyn.scale</code> centers and standardizes a <code><a href="#topic+longitudinal">longitudinal</a></code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  time2weights(t)
  dyn.weights(x)
  dyn.moments(x)
  dyn.scale(x, center=TRUE, scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dyn.scale_+3A_t">t</code></td>
<td>
<p>a vector with time points</p>
</td></tr>
<tr><td><code id="dyn.scale_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+longitudinal">longitudinal</a></code> object, or a matrix</p>
</td></tr>
<tr><td><code id="dyn.scale_+3A_center">center</code></td>
<td>
<p>logical value</p>
</td></tr>
<tr><td><code id="dyn.scale_+3A_scale">scale</code></td>
<td>
<p>logical value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dynamical weights are computed assuming a linear spline - see Opgen-Rhein
and Strimmer (2006a,b).  The dynamical mean and variance etc. are then simply 
weighted versions of the usual empirical estimators.
</p>


<h3>Value</h3>

<p>A vector with weights (<code>time2weights</code> and <code>dyn.weights</code>), 
a list containing the column means and variances (<code>dyn.moments</code>), 
or a rescaled longitudinal matrix (<code>dyn.scale</code>).
</p>


<h3>Author(s)</h3>

<p>Rainer Opgen-Rhein and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Opgen-Rhein, R., and K. Strimmer. 2006a. Inferring gene dependency networks from 
genomic longitudinal data: a functional data approach.
REVSTAT <b>4</b>:53-65.  
</p>
<p>Opgen-Rhein, R., and K. Strimmer. 2006b. Using regularized dynamic correlation 
to infer gene dependency networks from time-series microarray data. 
The 4th International Workshop on Computational Systems Biology,
WCSB 2006 (June 12-13, 2006, Tampere, Finland). 
</p>


<h3>See Also</h3>

<p><code><a href="corpcor.html#topic+wt.scale">wt.scale</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load "longitudinal" library
library("longitudinal")

# weights of for the data points in tcell data
data(tcell)
dyn.weights(tcell.34)

# dynamical moments
dyn.moments(tcell.34)

</code></pre>

<hr>
<h2 id='longitudinal'>Data Structure for Longitudinal Data</h2><span id='topic+longitudinal'></span><span id='topic+as.longitudinal'></span><span id='topic+is.longitudinal'></span><span id='topic+summary.longitudinal'></span><span id='topic+print.longitudinal'></span><span id='topic+plot.longitudinal'></span>

<h3>Description</h3>

<p>The data type <code>longitudinal</code> stores multiple time series data.  It allows repeated
measurements, irregular sampling, and unequal temporal spacing of the time points. 
</p>
<p><code>as.longitudinal</code> converts a matrix into a <code>longitudinal</code> object.  The columns of the
input matrix are considered as individual variables (time series).  The rows contain the
measurements in temporal order (for instance, rows 1-10 could contain 10 repeated measurements taken at
time point 1, rows 11-20 further 10 measurements taken at time point 2, and so on).
The dates for the time points can be specified with the argument <code>times</code> and need not
be equally spaced.  With the argument <code>repeats</code> it is possible to specify the number
of measurements per time point (this may be different from time point to time point).  In the resulting
<code>longitudinal</code> matrix object the row names will indicate both the time points and the 
repetition number (e.g., &quot;10-1&quot;, &quot;10-2&quot;, &quot;10-3&quot;, ...,  &quot;20-1&quot;, &quot;20-2&quot;, &quot;20-3&quot;, etc.).
</p>
<p><code>is.longitudinal</code> checks whether a matrix has the <code>longitudinal</code> attributes.
</p>
<p>The functions <code>summary</code>, <code>print</code>, <code>plot</code> are the standard generic functions
adapted to <code>longitudinal</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.longitudinal(x, repeats=1, time)
is.longitudinal(x)
## S3 method for class 'longitudinal'
summary(object, ...)
## S3 method for class 'longitudinal'
print(x, ...)
## S3 method for class 'longitudinal'
plot(x, series=1, type=c("median", "mean"), autolayout=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="longitudinal_+3A_x">x</code>, <code id="longitudinal_+3A_object">object</code></td>
<td>
<p>Time series data, contained in a <code>longitudinal</code> object
or in matrix form (<code>as.longitudinal</code>).</p>
</td></tr> 
<tr><td><code id="longitudinal_+3A_repeats">repeats</code></td>
<td>
<p>Integer, or a vector of integers, that specifies the number
of available measurements per time point.  If only one number is given
then it is assumed the time series is regularly sampled. If instead a vector
is specified, then each time point may have a different number of samples.</p>
</td></tr>  
<tr><td><code id="longitudinal_+3A_time">time</code></td>
<td>
<p>A vector with the dates for the time points. If not specified,
equally spaced time points  1, 2, 3, ... are assumed. </p>
</td></tr>	   
<tr><td><code id="longitudinal_+3A_series">series</code></td>
<td>
<p>Number, or a vector of numbers, that indicates which time series
(=variables and columns of x) are plotted.</p>
</td></tr>
<tr><td><code id="longitudinal_+3A_type">type</code></td>
<td>
<p>Determines whether the plotted line corresponds to the mean or median value
of the samples per time point (default: &quot;median&quot;).</p>
</td></tr>
<tr><td><code id="longitudinal_+3A_autolayout">autolayout</code></td>
<td>
<p>determine the number of
columns and rows in the plot automatically in the display of multiple time series  (default: TRUE). </p>
</td></tr>	         	   
<tr><td><code id="longitudinal_+3A_...">...</code></td>
<td>
<p>Additional optional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.longitudinal</code> returns a <code>longitudinal</code> object.
</p>
<p><code>is.longitudinal</code> returns TRUE or false.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+longitudinal.util">longitudinal.util</a></code>, <code><a href="#topic+tcell">tcell</a></code>, <code><a href="stats.html#topic+ts">ts</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load "longitudinal" library
library("longitudinal")

# load data set
data(tcell)
is.longitudinal(tcell.34)
attributes(tcell.34)
tcell.34[,1:3]

# how many samples and how many genes?
dim(tcell.34)
summary(tcell.34)

# plot first nine time series
plot(tcell.34, 1:9)

#####

# an artificial example with repeated measurements, irregular sampling, and unequal spacing 
m &lt;- matrix(rnorm(200), 50, 4)
z &lt;- as.longitudinal(m, repeats=c(10,5,5,10,20), time=c(2,8,9,15,16))
plot(z, 1:4)
</code></pre>

<hr>
<h2 id='longitudinal-internal'>Internal longitudinal Functions</h2><span id='topic+get.time.idx'></span>

<h3>Description</h3>

<p>Internal longitudinal functions.
</p>


<h3>Note</h3>

<p>These are not to be called by the user (or in some cases are just
waiting for proper documentation to be written).
</p>

<hr>
<h2 id='longitudinal.util'>Utility Functions for the &quot;Longitudinal&quot; Data Structure</h2><span id='topic+longitudinal.util'></span><span id='topic+get.time.repeats'></span><span id='topic+is.equally.spaced'></span><span id='topic+is.regularly.sampled'></span><span id='topic+has.repeated.measurements'></span><span id='topic+combine.longitudinal'></span><span id='topic+condense.longitudinal'></span>

<h3>Description</h3>

<p>The above functions are all utility functions for  <code><a href="#topic+longitudinal">longitudinal</a></code> objects.
</p>
<p><code>get.time.repeats</code> returns the measurement design, i.e. the time points
and the number of repeats per time point. 
</p>
<p><code>is.equally.spaced</code> checks whether the distances between subsequent time points
are all equal.   
</p>
<p><code>is.regularly.sampled</code> checks whether the number of measurements are identical
across time points.   
</p>
<p><code>has.repeated.measurements</code> checks whether any time point as been measured more
than once.
</p>
<p><code>combine.longitudinal</code> combines the measurements of two <code>longitudinal</code> objects. 
These objects must have the same (number of) variables. 
</p>
<p><code>condense.longitudinal</code> condenses the multiple measurements per time point using
an arbitrary function (e.g., mean, median, var).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.time.repeats(x)
is.equally.spaced(x)
is.regularly.sampled(x)
has.repeated.measurements(x)
combine.longitudinal(x1, x2)
condense.longitudinal(x, s, func=median)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="longitudinal.util_+3A_x">x</code>, <code id="longitudinal.util_+3A_x1">x1</code>, <code id="longitudinal.util_+3A_x2">x2</code></td>
<td>
<p><code><a href="#topic+longitudinal">longitudinal</a></code> time series objects</p>
</td></tr>
<tr><td><code id="longitudinal.util_+3A_s">s</code></td>
<td>
<p>An integer, or a vector of integers, that designate the set of
time series (variables) to condense.</p>
</td></tr>
<tr><td><code id="longitudinal.util_+3A_func">func</code></td>
<td>
<p>Univariate function used to summarize the multiple measurements
per time point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get.time.repeats</code> returns a list containing two vectors (<code>time</code> and <code>repeats</code>).
</p>
<p><code>is.equally.spaced</code>, <code>is.regularly.sampled</code>, and <code>has.repeated.measurements</code>
return either TRUE or FALSE.
</p>
<p><code>combine.longitudinal</code> returns a <code><a href="#topic+longitudinal">longitudinal</a></code> object.
</p>
<p><code>condense.longitudinal</code> returns a matrix.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+longitudinal">longitudinal</a></code>, <code><a href="#topic+tcell">tcell</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load "longitudinal" library
library("longitudinal")


# load tcell data set
data(tcell)
dim(tcell.34)
is.longitudinal(tcell.34)
summary(tcell.34)

# information
get.time.repeats(tcell.34)
is.equally.spaced(tcell.34)
is.regularly.sampled(tcell.34)
has.repeated.measurements(tcell.34)

# compute the mean value at each time point for the first two gene
condense.longitudinal(tcell.34, 1:2, mean)


# combine two time series
m1 &lt;- matrix(rnorm(100), 50, 2)
m2 &lt;- matrix(rnorm(100), 50, 2)
z1 &lt;- as.longitudinal(m1, repeats=c(10,5,5,10,20), time=c(2,8,9,15,16))
z2 &lt;- as.longitudinal(m2, repeats=c(10,5,5,10,20), time=c(1,8,9,15,20))

z3 &lt;- combine.longitudinal(z1,z2)
summary(z3)
get.time.repeats(z3)  # compare with z1 and z2
</code></pre>

<hr>
<h2 id='tcell'>Microarray Time Series Data for T-Cell Activation </h2><span id='topic+tcell'></span><span id='topic+tcell.10'></span><span id='topic+tcell.34'></span><span id='topic+tcell.gene.description'></span>

<h3>Description</h3>

<p>The data result from two experiments investigating
the expression response of human T cells to PMA and ionomicin treatment.
</p>
<p>The first data set (<code>tcell.34</code>) contains the temporal expression levels of 58 genes
for 10 unequally spaced time points.  At each time point there are 34 
separate measurements. The second data set (<code>tcell.10</code>) stems from
a related experiment considering 
the same genes and identical time points, and contains 
10 further measurements per time point. See Rangel et al. (2004) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tcell)
</code></pre>


<h3>Format</h3>

<p><code>tcell.10</code> and <code>tcell.34</code> are <code><a href="#topic+longitudinal">longitudinal</a></code> objects,
i.e. matrices with 58 colums each and a number of extra attributes
(see <code><a href="#topic+longitudinal">longitudinal</a></code> and <code><a href="#topic+longitudinal.util">longitudinal.util</a></code>).
</p>
<p>The vector <code>tcell.gene.descriptions</code> contains the 
description of the functions of the 58 investigated genes.
</p>


<h3>Source</h3>

<p>This data is described in Rangel et al. (2004).
</p>


<h3>References</h3>

<p>Rangel, C., Angus, J., Ghahramani, Z., Lioumi, M., Sotheran, E., Gaiba, A.,
Wild, D. L., and Falciani, F.
(2004) Modeling T-cell activation using gene expression profiling and
state-space models. <em>Bioinformatics</em>, <b>20</b>, 1361&ndash;1372.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load "longitudinal" library
library("longitudinal")

# load data sets
data(tcell)

# data set with 10 repeats 
dim(tcell.10)
summary(tcell.10)
is.longitudinal(tcell.10)
is.regularly.sampled(tcell.10)
is.equally.spaced(tcell.10)
get.time.repeats(tcell.10)

# data set with 34 repeats 
dim(tcell.34)
summary(tcell.34)
is.longitudinal(tcell.34)
is.regularly.sampled(tcell.34)
is.equally.spaced(tcell.34)
get.time.repeats(tcell.34)

# descriptions of the first nine genes
tcell.gene.description[1:9]

# plot the first nine time series
plot(tcell.10, 1:9)
plot(tcell.34, 1:9)

# Rangel et al. use the combined data set
tcell.44 &lt;- combine.longitudinal(tcell.34, tcell.10)
plot(tcell.44, 1:9)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
