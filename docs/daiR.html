<!DOCTYPE html><html><head><title>Help for package daiR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {daiR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onAttach'><p>Run when daiR is attached</p></a></li>
<li><a href='#build_block_df'><p>Build block dataframe</p></a></li>
<li><a href='#build_token_df'><p>Build token dataframe</p></a></li>
<li><a href='#create_processor'><p>Create processor</p></a></li>
<li><a href='#dai_async'><p>OCR documents asynchronously</p></a></li>
<li><a href='#dai_auth'><p>Check authentication</p></a></li>
<li><a href='#dai_notify'><p>Notify on job completion</p></a></li>
<li><a href='#dai_status'><p>Check job status</p></a></li>
<li><a href='#dai_sync'><p>OCR document synchronously</p></a></li>
<li><a href='#dai_token'><p>Produce access token</p></a></li>
<li><a href='#dai_user'><p>Get user information</p></a></li>
<li><a href='#defunct'><p>Defunct functions</p></a></li>
<li><a href='#delete_processor'><p>Delete processor</p></a></li>
<li><a href='#deprecated'><p>Deprecated functions</p></a></li>
<li><a href='#disable_processor'><p>Disable processor</p></a></li>
<li><a href='#draw_blocks'><p>Draw block bounding boxes</p></a></li>
<li><a href='#draw_entities'><p>Draw entity bounding boxes</p></a></li>
<li><a href='#draw_lines'><p>Draw line bounding boxes</p></a></li>
<li><a href='#draw_paragraphs'><p>Draw paragraph bounding boxes</p></a></li>
<li><a href='#draw_tokens'><p>Draw token bounding boxes</p></a></li>
<li><a href='#enable_processor'><p>Enable processor</p></a></li>
<li><a href='#from_labelme'><p>Extract block coordinates from labelme files</p></a></li>
<li><a href='#get_entities'><p>Get entities</p></a></li>
<li><a href='#get_processor_info'><p>Get information about processor</p></a></li>
<li><a href='#get_processor_versions'><p>List available versions of processor</p></a></li>
<li><a href='#get_processors'><p>List created processors</p></a></li>
<li><a href='#get_project_id'><p>Get project id</p></a></li>
<li><a href='#get_tables'><p>Get tables</p></a></li>
<li><a href='#get_text'><p>Get text</p></a></li>
<li><a href='#image_to_pdf'><p>Convert images to PDF</p></a></li>
<li><a href='#img_to_binbase'><p>Image to base64 tiff</p></a></li>
<li><a href='#is_colour'><p>Check that a string is a valid colour representation</p></a></li>
<li><a href='#is_json'><p>Check that a file is JSON</p></a></li>
<li><a href='#is_pdf'><p>Check that a file is PDF</p></a></li>
<li><a href='#list_processor_types'><p>List available processor types</p></a></li>
<li><a href='#make_hocr'><p>Make hOCR file</p></a></li>
<li><a href='#merge_shards'><p>Merge shards</p></a></li>
<li><a href='#pdf_to_binbase'><p>PDF to base64 tiff</p></a></li>
<li><a href='#reassign_tokens'><p>Assign tokens to new blocks</p></a></li>
<li><a href='#reassign_tokens2'><p>Assign tokens to a single new block</p></a></li>
<li><a href='#redraw_blocks'><p>Inspect revised block bounding boxes</p></a></li>
<li><a href='#split_block'><p>Split a block bounding box</p></a></li>
<li><a href='#tables_from_dai_file'><p>Get tables from output file</p></a></li>
<li><a href='#tables_from_dai_response'><p>Get tables from response object</p></a></li>
<li><a href='#text_from_dai_file'><p>Get text from output file</p></a></li>
<li><a href='#text_from_dai_response'><p>Get text from HTTP response object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interface with Google Cloud Document AI API</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>R interface for the Google Cloud Services 'Document AI API'
    <a href="https://cloud.google.com/document-ai/">https://cloud.google.com/document-ai/</a> with additional tools for
    output file parsing and text reconstruction. 'Document AI' is a
    powerful server-based OCR service that extracts text and tables from
    images and PDF files with high accuracy. 'daiR' gives R users
    programmatic access to this service and additional tools to handle
    and visualize the output. See the package website <a href="https://dair.info/">https://dair.info/</a>
    for more information and examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Hegghammer/daiR">https://github.com/Hegghammer/daiR</a>, <a href="https://dair.info">https://dair.info</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Hegghammer/daiR/issues">https://github.com/Hegghammer/daiR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>base64enc, beepr, cli, data.table, fs, gargle, glue,
googleCloudStorageR, graphics, grDevices, httr, jsonlite,
lifecycle, magick, pdftools, purrr, readtext, stats, stringr,
utils, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ngram, rmarkdown, testthat (&ge; 3.1.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 01:08:35 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Hegghammer <a href="https://orcid.org/0000-0001-6253-1518"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Hegghammer &lt;hegghammer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 04:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onAttach'>Run when daiR is attached</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>Run when daiR is attached
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>name of library</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>name of package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for side effects
</p>

<hr>
<h2 id='build_block_df'>Build block dataframe</h2><span id='topic+build_block_df'></span>

<h3>Description</h3>

<p>Creates a dataframe with the block bounding boxes
identified by Document AI (DAI) in an asynchronous request.
Rows are blocks, in the order DAI proposes to read them. Columns
are location variables such as page coordinates and page numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_block_df(object, type = "sync")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_block_df_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="build_block_df_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot; depending on
the function used to process the original document.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dataframe variables are: page number, block number,
confidence score, left boundary, right boundary, top boundary,
and bottom boundary.
</p>


<h3>Value</h3>

<p>a block data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
resp &lt;- dai_sync("file.pdf")
block_df &lt;- build_block_df(resp)

block_df &lt;- build_block_df("pdf_output.json", type = "async")

## End(Not run)
</code></pre>

<hr>
<h2 id='build_token_df'>Build token dataframe</h2><span id='topic+build_token_df'></span>

<h3>Description</h3>

<p>Builds a token dataframe from the text OCRed by
Document AI (DAI) in an asynchronous request. Rows are tokens, in the
order DAI proposes to read them. Columns are location variables
such as page coordinates and block bounding box numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_token_df(object, type = "sync")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_token_df_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="build_token_df_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot; depending on
the function used to process the original document.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The location variables are: token, start index, end index,
confidence, left boundary, right boundary, top boundary, bottom boundary,
page number, and block number. Start and end indices refer to
character position in the string containing the full text.
</p>


<h3>Value</h3>

<p>a token data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
resp &lt;- dai_sync("file.pdf")
token_df &lt;- build_token_df(resp)

token_df &lt;- build_token_df("pdf_output.json", type = "async")

## End(Not run)
</code></pre>

<hr>
<h2 id='create_processor'>Create processor</h2><span id='topic+create_processor'></span>

<h3>Description</h3>

<p>Create processor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_processor(
  name,
  type = "OCR_PROCESSOR",
  proj_id = get_project_id(),
  loc = "eu",
  token = dai_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_processor_+3A_name">name</code></td>
<td>
<p>a string; the proposed display name of the processor.</p>
</td></tr>
<tr><td><code id="create_processor_+3A_type">type</code></td>
<td>
<p>a string; one of &quot;OCR_PROCESSOR&quot;,
&quot;FORM_PARSER_PROCESSOR&quot;, &quot;INVOICE_PROCESSOR&quot;, or
&quot;US_DRIVER_LICENSE_PROCESSOR&quot;.</p>
</td></tr>
<tr><td><code id="create_processor_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id.</p>
</td></tr>
<tr><td><code id="create_processor_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;.</p>
</td></tr>
<tr><td><code id="create_processor_+3A_token">token</code></td>
<td>
<p>an authentication token generated by <code>dai_auth()</code> or
another auth function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a Document AI processor and returns the id of the
newly created processor. Note that the proposed processor name may
already be taken; if so, try again with another name. Consider
storing the processor id in an environment variable named
DAI_PROCESSOR_ID. For more information about processors, see the
Google Document AI documentation at
<a href="https://cloud.google.com/document-ai/docs/">https://cloud.google.com/document-ai/docs/</a>.
</p>


<h3>Value</h3>

<p>a processor id if successful, otherwise NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proc_id &lt;- create_processor("my-processor-123")

## End(Not run)
</code></pre>

<hr>
<h2 id='dai_async'>OCR documents asynchronously</h2><span id='topic+dai_async'></span>

<h3>Description</h3>

<p>Sends files from a Google Cloud Services (GCS) Storage
bucket to the GCS Document AI v1 API for asynchronous (offline) processing.
The output is delivered to the same bucket as JSON files containing
the OCRed text and additional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dai_async(
  files,
  dest_folder = NULL,
  bucket = Sys.getenv("GCS_DEFAULT_BUCKET"),
  proj_id = get_project_id(),
  proc_id = Sys.getenv("DAI_PROCESSOR_ID"),
  proc_v = NA,
  skip_rev = "true",
  loc = "eu",
  token = dai_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dai_async_+3A_files">files</code></td>
<td>
<p>a vector or list of pdf filepaths in a GCS Storage bucket
Filepaths must include all parent bucket folder(s) except the bucket name</p>
</td></tr>
<tr><td><code id="dai_async_+3A_dest_folder">dest_folder</code></td>
<td>
<p>the name of the GCS Storage bucket subfolder where
you want the json output</p>
</td></tr>
<tr><td><code id="dai_async_+3A_bucket">bucket</code></td>
<td>
<p>the name of the GCS Storage bucket where the files
to be processed are located</p>
</td></tr>
<tr><td><code id="dai_async_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id</p>
</td></tr>
<tr><td><code id="dai_async_+3A_proc_id">proc_id</code></td>
<td>
<p>a Document AI processor id</p>
</td></tr>
<tr><td><code id="dai_async_+3A_proc_v">proc_v</code></td>
<td>
<p>one of 1) a processor version name, 2) &quot;stable&quot; for the
latest processor from the stable channel, or 3) &quot;rc&quot; for the latest
processor from the release candidate channel.</p>
</td></tr>
<tr><td><code id="dai_async_+3A_skip_rev">skip_rev</code></td>
<td>
<p>whether to skip human review; &quot;true&quot; or &quot;false&quot;</p>
</td></tr>
<tr><td><code id="dai_async_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;</p>
</td></tr>
<tr><td><code id="dai_async_+3A_token">token</code></td>
<td>
<p>an access token generated by <code>dai_auth()</code> or another
auth function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires a GCS access token and some configuration of the
.Renviron file; see package vignettes for details. Currently, a
<code>dai_async()</code> call can contain a maximum of 50 files (but a
multi-page pdf counts as one file). You can not have more than
5 batch requests and 10,000 pages undergoing processing at any one time.
Maximum pdf document length is 2,000 pages. With long pdf documents,
Document AI divides the JSON output into separate files ('shards') of
20 pages each. If you want longer shards, use <code>dai_tab_async()</code>,
which accesses another API endpoint that allows for shards of up to
100 pages.
</p>


<h3>Value</h3>

<p>A list of HTTP responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# with daiR configured on your system, several parameters are automatically provided,
# and you can pass simple calls, such as:
dai_async("my_document.pdf")

# NB: Include all parent bucket folders (but not the bucket name) in the filepath:
dai_async("for_processing/pdfs/my_document.pdf")

# Bulk process by passing a vector of filepaths in the files argument:
dai_async(my_files)

# Specify a bucket subfolder for the json output:
dai_async(my_files, dest_folder = "processed")

## End(Not run)
</code></pre>

<hr>
<h2 id='dai_auth'>Check authentication</h2><span id='topic+dai_auth'></span>

<h3>Description</h3>

<p>Checks whether the user can obtain an access token for
Google Cloud Services (GCS) using a service account key stored on file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dai_auth(
  path = Sys.getenv("GCS_AUTH_FILE"),
  scopes = "https://www.googleapis.com/auth/cloud-platform"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dai_auth_+3A_path">path</code></td>
<td>
<p>path to a JSON file with a service account key</p>
</td></tr>
<tr><td><code id="dai_auth_+3A_scopes">scopes</code></td>
<td>
<p>GCS auth scopes for the token</p>
</td></tr>
</table>


<h3>Details</h3>

<p>daiR takes a very parsimonious approach to authentication,
with the native auth functions only supporting service account files.
Those who prefer other authentication methods can pass those directly
to the <code>token</code> parameter in the various functions that call the
Document AI API.
</p>


<h3>Value</h3>

<p>no return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dai_auth()

## End(Not run)
</code></pre>

<hr>
<h2 id='dai_notify'>Notify on job completion</h2><span id='topic+dai_notify'></span>

<h3>Description</h3>

<p>Queries to the Google Cloud Services (GCS) Document AI API
about the status of a previously submitted asynchronous job
and emits a sound notification when the job is complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dai_notify(response, loc = "eu", token = dai_token(), sound = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dai_notify_+3A_response">response</code></td>
<td>
<p>a HTTP response object generated by
<code>dai_async()</code></p>
</td></tr>
<tr><td><code id="dai_notify_+3A_loc">loc</code></td>
<td>
<p>A two-letter region code; &quot;eu&quot; or &quot;us&quot;</p>
</td></tr>
<tr><td><code id="dai_notify_+3A_token">token</code></td>
<td>
<p>An authentication token generated by <code>dai_auth()</code> or
another auth function</p>
</td></tr>
<tr><td><code id="dai_notify_+3A_sound">sound</code></td>
<td>
<p>A number from 1 to 10 for the Beepr sound selection
(https://www.r-project.org/nosvn/pandoc/beepr.html).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
response &lt;- dai_async(myfiles)
dai_notify(response)

## End(Not run)
</code></pre>

<hr>
<h2 id='dai_status'>Check job status</h2><span id='topic+dai_status'></span>

<h3>Description</h3>

<p>Queries the Google Cloud Services (GCS)
Document AI API about the status of a previously submitted
asynchronous job.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dai_status(response, loc = "eu", token = dai_token(), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dai_status_+3A_response">response</code></td>
<td>
<p>A HTTP response object generated by
<code>dai_async()</code></p>
</td></tr>
<tr><td><code id="dai_status_+3A_loc">loc</code></td>
<td>
<p>A two-letter region code; &quot;eu&quot; or &quot;us&quot;</p>
</td></tr>
<tr><td><code id="dai_status_+3A_token">token</code></td>
<td>
<p>An authentication token generated by
<code>dai_auth()</code> or another auth function</p>
</td></tr>
<tr><td><code id="dai_status_+3A_verbose">verbose</code></td>
<td>
<p>boolean; Whether to output the full response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If verbose was set to <code>TRUE</code>, a HTTP response object.
If verbose was set to <code>FALSE</code>, a string summarizing the status.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Short status message:
response &lt;- dai_async(myfiles)
dai_status(response)

# Full status details:
response &lt;- dai_async(myfiles)
status &lt;- dai_status(response, verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dai_sync'>OCR document synchronously</h2><span id='topic+dai_sync'></span>

<h3>Description</h3>

<p>Sends a single document to the Google Cloud Services (GCS)
Document AI v1 API for synchronous (immediate) processing. Returns a
HTTP response object containing the OCRed text and additional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dai_sync(
  file,
  proj_id = get_project_id(),
  proc_id = Sys.getenv("DAI_PROCESSOR_ID"),
  proc_v = NA,
  skip_rev = "true",
  loc = "eu",
  token = dai_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dai_sync_+3A_file">file</code></td>
<td>
<p>path to a single-page pdf or image file</p>
</td></tr>
<tr><td><code id="dai_sync_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id.</p>
</td></tr>
<tr><td><code id="dai_sync_+3A_proc_id">proc_id</code></td>
<td>
<p>a Document AI processor id.</p>
</td></tr>
<tr><td><code id="dai_sync_+3A_proc_v">proc_v</code></td>
<td>
<p>one of 1) a processor version name, 2) &quot;stable&quot; for the
latest processor from the stable channel, or 3) &quot;rc&quot; for the latest
processor from the release candidate channel.</p>
</td></tr>
<tr><td><code id="dai_sync_+3A_skip_rev">skip_rev</code></td>
<td>
<p>whether to skip human review; &quot;true&quot; or &quot;false&quot;.</p>
</td></tr>
<tr><td><code id="dai_sync_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;.</p>
</td></tr>
<tr><td><code id="dai_sync_+3A_token">token</code></td>
<td>
<p>an authentication token generated by <code>dai_auth()</code> or
another auth function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires a GCS access token and some configuration of the
.Renviron file; see package vignettes for details.Input files can be in
either .pdf, .bmp, .gif, .jpeg, .jpg, .png, or .tiff format. PDF files
can be up to five pages long. Extract the text from the response object with
<code>text_from_dai_response()</code>. Inspect the entire response object with
<code>httr::content()</code>.
</p>


<h3>Value</h3>

<p>a HTTP response object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
response &lt;- dai_sync("doc_page.pdf")

response &lt;- dai_sync("doc_page.pdf",
                     proc_v = "pretrained-ocr-v1.1-2022-09-12")


## End(Not run)
</code></pre>

<hr>
<h2 id='dai_token'>Produce access token</h2><span id='topic+dai_token'></span>

<h3>Description</h3>

<p>Produces an access token for Google Cloud Services (GCS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dai_token(
  path = Sys.getenv("GCS_AUTH_FILE"),
  scopes = "https://www.googleapis.com/auth/cloud-platform"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dai_token_+3A_path">path</code></td>
<td>
<p>path to a JSON file with a service account key</p>
</td></tr>
<tr><td><code id="dai_token_+3A_scopes">scopes</code></td>
<td>
<p>GCS auth scopes for the token</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a GCS access token object (if credentials are valid) or a message (if not).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
token &lt;- dai_token()

## End(Not run)
</code></pre>

<hr>
<h2 id='dai_user'>Get user information</h2><span id='topic+dai_user'></span>

<h3>Description</h3>

<p>Fetches the Google Cloud Services (GCS) user information
associated with a service account key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dai_user()
</code></pre>


<h3>Value</h3>

<p>a list of user information elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dai_user()

## End(Not run)
</code></pre>

<hr>
<h2 id='defunct'>Defunct functions</h2><span id='topic+defunct'></span><span id='topic+dai_sync_tab'></span><span id='topic+dai_async_tab'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#defunct"><img src="../help/figures/lifecycle-defunct.svg" alt='[Defunct]' /></a>
</p>
<p>If there's a known replacement, calling the function
will tell you about it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Deprecated in 1.0.0 -------------------------------------

dai_sync_tab(...)

dai_async_tab(...)
</code></pre>

<hr>
<h2 id='delete_processor'>Delete processor</h2><span id='topic+delete_processor'></span>

<h3>Description</h3>

<p>Delete processor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_processor(
  proc_id,
  proj_id = get_project_id(),
  loc = "eu",
  token = dai_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_processor_+3A_proc_id">proc_id</code></td>
<td>
<p>a Document AI processor id.</p>
</td></tr>
<tr><td><code id="delete_processor_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id.</p>
</td></tr>
<tr><td><code id="delete_processor_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;.</p>
</td></tr>
<tr><td><code id="delete_processor_+3A_token">token</code></td>
<td>
<p>an authentication token generated by
<code>dai_auth()</code> or another auth function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
delete_processor(proc_id = get_processors()$id[1])

## End(Not run)
</code></pre>

<hr>
<h2 id='deprecated'>Deprecated functions</h2><span id='topic+deprecated'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>If there's a known replacement, calling the function
will tell you about it.
</p>

<hr>
<h2 id='disable_processor'>Disable processor</h2><span id='topic+disable_processor'></span>

<h3>Description</h3>

<p>Disable processor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disable_processor(
  proc_id,
  proj_id = get_project_id(),
  loc = "eu",
  token = dai_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disable_processor_+3A_proc_id">proc_id</code></td>
<td>
<p>a Document AI processor id.</p>
</td></tr>
<tr><td><code id="disable_processor_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id.</p>
</td></tr>
<tr><td><code id="disable_processor_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;.</p>
</td></tr>
<tr><td><code id="disable_processor_+3A_token">token</code></td>
<td>
<p>an authentication token generated by
<code>dai_auth()</code> or another auth function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
disable_processor(proc_id = get_processors()$id[1])

## End(Not run)
</code></pre>

<hr>
<h2 id='draw_blocks'>Draw block bounding boxes</h2><span id='topic+draw_blocks'></span>

<h3>Description</h3>

<p>Plots the block bounding boxes identified by
Document AI (DAI) onto images of the submitted document.
Generates an annotated .png file for each page in the original
document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_blocks(
  object,
  type = "sync",
  prefix = NULL,
  dir = getwd(),
  linecol = "red",
  linewd = 3,
  fontcol = "blue",
  fontsize = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_blocks_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="draw_blocks_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot;, depending on
the function used to process the original document.</p>
</td></tr>
<tr><td><code id="draw_blocks_+3A_prefix">prefix</code></td>
<td>
<p>string to be prepended to the output png filename.</p>
</td></tr>
<tr><td><code id="draw_blocks_+3A_dir">dir</code></td>
<td>
<p>path to the desired output directory.</p>
</td></tr>
<tr><td><code id="draw_blocks_+3A_linecol">linecol</code></td>
<td>
<p>color of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_blocks_+3A_linewd">linewd</code></td>
<td>
<p>width of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_blocks_+3A_fontcol">fontcol</code></td>
<td>
<p>color of the box numbers.</p>
</td></tr>
<tr><td><code id="draw_blocks_+3A_fontsize">fontsize</code></td>
<td>
<p>size of the box numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not vectorized, but documents can be multi-page.
</p>


<h3>Value</h3>

<p>no return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
resp &lt;- dai_sync("page.pdf")
draw_blocks(resp)

draw_blocks("page.json", type = "async")

## End(Not run)
</code></pre>

<hr>
<h2 id='draw_entities'>Draw entity bounding boxes</h2><span id='topic+draw_entities'></span>

<h3>Description</h3>

<p>Plots the entity bounding boxes identified
by a Document AI form parser processor onto images of the
submitted document. Generates an annotated .png file for
each page in the original document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_entities(
  object,
  type = "sync",
  prefix = NULL,
  dir = getwd(),
  linecol = "red",
  linewd = 3,
  fontcol = "blue",
  fontsize = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_entities_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="draw_entities_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot;, depending on
the function used to process the original document.</p>
</td></tr>
<tr><td><code id="draw_entities_+3A_prefix">prefix</code></td>
<td>
<p>string to be prepended to the output png filename.</p>
</td></tr>
<tr><td><code id="draw_entities_+3A_dir">dir</code></td>
<td>
<p>path to the desired output directory.</p>
</td></tr>
<tr><td><code id="draw_entities_+3A_linecol">linecol</code></td>
<td>
<p>color of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_entities_+3A_linewd">linewd</code></td>
<td>
<p>width of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_entities_+3A_fontcol">fontcol</code></td>
<td>
<p>color of the box numbers.</p>
</td></tr>
<tr><td><code id="draw_entities_+3A_fontsize">fontsize</code></td>
<td>
<p>size of the box numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not vectorized, but documents can be multi-page.
</p>


<h3>Value</h3>

<p>no return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
resp &lt;- dai_sync("page.pdf")
draw_entities(resp)

draw_tokens("page.json", type = "async")


## End(Not run)
</code></pre>

<hr>
<h2 id='draw_lines'>Draw line bounding boxes</h2><span id='topic+draw_lines'></span>

<h3>Description</h3>

<p>Plots the line bounding boxes identified by
Document AI (DAI) onto images of the submitted document.
Generates an annotated .png file for each page in the original
document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_lines(
  object,
  type = "sync",
  prefix = NULL,
  dir = getwd(),
  linecol = "red",
  linewd = 3,
  fontcol = "blue",
  fontsize = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_lines_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="draw_lines_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot;, depending on
the function used to process the original document.</p>
</td></tr>
<tr><td><code id="draw_lines_+3A_prefix">prefix</code></td>
<td>
<p>string to be prepended to the output png filename.</p>
</td></tr>
<tr><td><code id="draw_lines_+3A_dir">dir</code></td>
<td>
<p>path to the desired output directory.</p>
</td></tr>
<tr><td><code id="draw_lines_+3A_linecol">linecol</code></td>
<td>
<p>color of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_lines_+3A_linewd">linewd</code></td>
<td>
<p>width of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_lines_+3A_fontcol">fontcol</code></td>
<td>
<p>color of the box numbers.</p>
</td></tr>
<tr><td><code id="draw_lines_+3A_fontsize">fontsize</code></td>
<td>
<p>size of the box numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not vectorized, but documents can be multi-page.
</p>


<h3>Value</h3>

<p>no return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
resp &lt;- dai_sync("page.pdf")
draw_lines(resp)

draw_lines("page.json", type = "async")

## End(Not run)
</code></pre>

<hr>
<h2 id='draw_paragraphs'>Draw paragraph bounding boxes</h2><span id='topic+draw_paragraphs'></span>

<h3>Description</h3>

<p>Plots the paragraph bounding boxes identified by
Document AI (DAI) onto images of the submitted document.
Generates an annotated .png file for each page in the original
document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_paragraphs(
  object,
  type = "sync",
  prefix = NULL,
  dir = getwd(),
  linecol = "red",
  linewd = 3,
  fontcol = "blue",
  fontsize = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_paragraphs_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="draw_paragraphs_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot;, depending on
the function used to process the original document.</p>
</td></tr>
<tr><td><code id="draw_paragraphs_+3A_prefix">prefix</code></td>
<td>
<p>string to be prepended to the output png filename.</p>
</td></tr>
<tr><td><code id="draw_paragraphs_+3A_dir">dir</code></td>
<td>
<p>path to the desired output directory.</p>
</td></tr>
<tr><td><code id="draw_paragraphs_+3A_linecol">linecol</code></td>
<td>
<p>color of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_paragraphs_+3A_linewd">linewd</code></td>
<td>
<p>width of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_paragraphs_+3A_fontcol">fontcol</code></td>
<td>
<p>color of the box numbers.</p>
</td></tr>
<tr><td><code id="draw_paragraphs_+3A_fontsize">fontsize</code></td>
<td>
<p>size of the box numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not vectorized, but documents can be multi-page.
</p>


<h3>Value</h3>

<p>no return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
resp &lt;- dai_sync("page.pdf")
draw_paragraphs(resp)

draw_paragraphs("page.json", type = "async")

## End(Not run)
</code></pre>

<hr>
<h2 id='draw_tokens'>Draw token bounding boxes</h2><span id='topic+draw_tokens'></span>

<h3>Description</h3>

<p>Plots the token (i.e., word) bounding boxes identified
by Document AI (DAI) onto images of the submitted document.
Generates an annotated .png file for each page in the original
document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_tokens(
  object,
  type = "sync",
  prefix = NULL,
  dir = getwd(),
  linecol = "red",
  linewd = 3,
  fontcol = "blue",
  fontsize = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_tokens_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="draw_tokens_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot;, depending on
the function used to process the original document.</p>
</td></tr>
<tr><td><code id="draw_tokens_+3A_prefix">prefix</code></td>
<td>
<p>string to be prepended to the output png filename.</p>
</td></tr>
<tr><td><code id="draw_tokens_+3A_dir">dir</code></td>
<td>
<p>path to the desired output directory.</p>
</td></tr>
<tr><td><code id="draw_tokens_+3A_linecol">linecol</code></td>
<td>
<p>color of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_tokens_+3A_linewd">linewd</code></td>
<td>
<p>width of the bounding box line.</p>
</td></tr>
<tr><td><code id="draw_tokens_+3A_fontcol">fontcol</code></td>
<td>
<p>color of the box numbers.</p>
</td></tr>
<tr><td><code id="draw_tokens_+3A_fontsize">fontsize</code></td>
<td>
<p>size of the box numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not vectorized, but documents can be multi-page.
</p>


<h3>Value</h3>

<p>no return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
resp &lt;- dai_sync("page.pdf")
draw_tokens(resp)

draw_tokens("page.json", type = "async")

## End(Not run)
</code></pre>

<hr>
<h2 id='enable_processor'>Enable processor</h2><span id='topic+enable_processor'></span>

<h3>Description</h3>

<p>Enable processor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enable_processor(
  proc_id,
  proj_id = get_project_id(),
  loc = "eu",
  token = dai_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enable_processor_+3A_proc_id">proc_id</code></td>
<td>
<p>a Document AI processor id.</p>
</td></tr>
<tr><td><code id="enable_processor_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id.</p>
</td></tr>
<tr><td><code id="enable_processor_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;.</p>
</td></tr>
<tr><td><code id="enable_processor_+3A_token">token</code></td>
<td>
<p>an authentication token generated by
<code>dai_auth()</code> or another auth function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
enable_processor(proc_id = get_processors()$id[1])

## End(Not run)
</code></pre>

<hr>
<h2 id='from_labelme'>Extract block coordinates from labelme files</h2><span id='topic+from_labelme'></span>

<h3>Description</h3>

<p>This is a specialized function for use in connection
with text reordering. It takes the output from the image
annotation tool 'Labelme' <a href="https://github.com/labelmeai/labelme">https://github.com/labelmeai/labelme</a>
and turns it into a one-row data frame compatible with other
'daiR' functions for text reordering such as
<code>reassign_tokens2()</code>. See package vignette on text reconstruction
for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_labelme(json, page = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_labelme_+3A_json">json</code></td>
<td>
<p>a json file generated by 'Labelme'</p>
</td></tr>
<tr><td><code id="from_labelme_+3A_page">page</code></td>
<td>
<p>the number of the annotated page</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with location coordinates for the rectangle
marked in 'Labelme'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new_block &lt;- from_labelme("document1_blocks.json")
new_block &lt;- from_labelme("document5_blocks.json", 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_entities'>Get entities</h2><span id='topic+get_entities'></span>

<h3>Description</h3>

<p>Extracts entities Document AI (DAI) identified by a Document AI
form parser processor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_entities(object, type = "sync")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_entities_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="get_entities_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot;, depending on
the function used to process the original document.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of dataframes, one per page
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
entities &lt;- get_entities(dai_sync("file.pdf"))

entities &lt;- get_entities("file.json", type = "async")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_processor_info'>Get information about processor</h2><span id='topic+get_processor_info'></span>

<h3>Description</h3>

<p>Get information about processor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_processor_info(
  proc_id,
  proj_id = get_project_id(),
  loc = "eu",
  token = dai_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_processor_info_+3A_proc_id">proc_id</code></td>
<td>
<p>a Document AI processor id.</p>
</td></tr>
<tr><td><code id="get_processor_info_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id.</p>
</td></tr>
<tr><td><code id="get_processor_info_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;.</p>
</td></tr>
<tr><td><code id="get_processor_info_+3A_token">token</code></td>
<td>
<p>an authentication token generated by
<code>dai_auth()</code> or another auth function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Retrieves information about a processor. For more
information about processors, see the Google Document AI
documentation at
<a href="https://cloud.google.com/document-ai/docs/">https://cloud.google.com/document-ai/docs/</a>.
</p>


<h3>Value</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
info &lt;- get_processor_info()

info &lt;- get_processor_info(proc_id = get_processors()$id[1])

## End(Not run)
</code></pre>

<hr>
<h2 id='get_processor_versions'>List available versions of processor</h2><span id='topic+get_processor_versions'></span>

<h3>Description</h3>

<p>List available versions of processor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_processor_versions(
  proc_id,
  proj_id = get_project_id(),
  loc = "eu",
  token = dai_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_processor_versions_+3A_proc_id">proc_id</code></td>
<td>
<p>a Document AI processor id.</p>
</td></tr>
<tr><td><code id="get_processor_versions_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id.</p>
</td></tr>
<tr><td><code id="get_processor_versions_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;.</p>
</td></tr>
<tr><td><code id="get_processor_versions_+3A_token">token</code></td>
<td>
<p>an authentication token generated by
<code>dai_auth()</code> or another auth function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
df &lt;- get_processor_versions()

df &lt;- get_processor_versions(proc_id = get_processors()$id[1])

## End(Not run)
</code></pre>

<hr>
<h2 id='get_processors'>List created processors</h2><span id='topic+get_processors'></span>

<h3>Description</h3>

<p>List created processors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_processors(proj_id = get_project_id(), loc = "eu", token = dai_token())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_processors_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id.</p>
</td></tr>
<tr><td><code id="get_processors_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;.</p>
</td></tr>
<tr><td><code id="get_processors_+3A_token">token</code></td>
<td>
<p>an authentication token generated by <code>dai_auth()</code> or
another auth function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Retrieves information about the processors that
have been created in the current project and are ready for use.
For more information about processors, see the Google Document
AI documentation at
<a href="https://cloud.google.com/document-ai/docs/">https://cloud.google.com/document-ai/docs/</a>.
</p>


<h3>Value</h3>

<p>a dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
df &lt;- get_processors()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_project_id'>Get project id</h2><span id='topic+get_project_id'></span>

<h3>Description</h3>

<p>Fetches the Google Cloud Services (GCS) project id
associated with a service account key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_project_id(path = Sys.getenv("GCS_AUTH_FILE"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_project_id_+3A_path">path</code></td>
<td>
<p>path to the JSON file with your service account key</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string with a GCS project id
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
project_id &lt;- get_project_id()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_tables'>Get tables</h2><span id='topic+get_tables'></span>

<h3>Description</h3>

<p>Extracts tables identified by a Document AI
form parser processor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tables(object, type = "sync")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tables_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="get_tables_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot;, depending on
the function used to process the original document.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

tables &lt;- get_tables(dai_sync("file.pdf"))

tables &lt;- get_tables("file.json", type = "async")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_text'>Get text</h2><span id='topic+get_text'></span>

<h3>Description</h3>

<p>Extracts the text OCRed by Document AI (DAI)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_text(
  object,
  type = "sync",
  save_to_file = FALSE,
  dest_dir = getwd(),
  outfile_stem = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_text_+3A_object">object</code></td>
<td>
<p>either a HTTP response object from
<code>dai_sync()</code> or the path to a JSON file from
<code>dai_async()</code>.</p>
</td></tr>
<tr><td><code id="get_text_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot;, depending on
the function used to process the original document.</p>
</td></tr>
<tr><td><code id="get_text_+3A_save_to_file">save_to_file</code></td>
<td>
<p>boolean; whether to save the text as a .txt file</p>
</td></tr>
<tr><td><code id="get_text_+3A_dest_dir">dest_dir</code></td>
<td>
<p>folder path for the .txt output file if <code>save_to_file = TRUE</code></p>
</td></tr>
<tr><td><code id="get_text_+3A_outfile_stem">outfile_stem</code></td>
<td>
<p>string to form the stem of the
.txt output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string (if <code>save_to_file = FALSE</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
text &lt;- get_text(dai_sync("file.pdf"))

text &lt;- get_text("file.json", type = "async", save_to_file = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='image_to_pdf'>Convert images to PDF</h2><span id='topic+image_to_pdf'></span>

<h3>Description</h3>

<p>This helper function converts a vector of images to a
single PDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_to_pdf(files, pdf_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_to_pdf_+3A_files">files</code></td>
<td>
<p>a vector of image files</p>
</td></tr>
<tr><td><code id="image_to_pdf_+3A_pdf_name">pdf_name</code></td>
<td>
<p>a string with the name of the new PDF</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combines any number of image files of almost any type
to a single PDF. The vector can consist of different image file types.
See the 'Magick' package documentation <a href="https://cran.r-project.org/package=magick">https://cran.r-project.org/package=magick</a>
for details on supported file types. Note that on Linux, ImageMagick may
not allow conversion to pdf for security reasons.
</p>


<h3>Value</h3>

<p>no return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Single file
new_pdf &lt;- file.path(tempdir(), "document.pdf")
image_to_pdf("document.jpg", new_pdf)

# A vector of image files:
image_to_pdf(images)

## End(Not run)
</code></pre>

<hr>
<h2 id='img_to_binbase'>Image to base64 tiff</h2><span id='topic+img_to_binbase'></span>

<h3>Description</h3>

<p>Converts an image file to a base64-encoded binary .tiff file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>img_to_binbase(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="img_to_binbase_+3A_file">file</code></td>
<td>
<p>path to an image file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a base64-encoded string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
img_encoded &lt;- img_to_binbase("image.png")

## End(Not run)
</code></pre>

<hr>
<h2 id='is_colour'>Check that a string is a valid colour representation</h2><span id='topic+is_colour'></span>

<h3>Description</h3>

<p>Checks whether a string is a valid colour representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_colour(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_colour_+3A_x">x</code></td>
<td>
<p>a string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
is_colour("red")
is_colour("#12345")

## End(Not run)
</code></pre>

<hr>
<h2 id='is_json'>Check that a file is JSON</h2><span id='topic+is_json'></span>

<h3>Description</h3>

<p>Checks whether a file is a JSON file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_json(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_json_+3A_file">file</code></td>
<td>
<p>a filepath</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
is_json("file.json")

## End(Not run)
</code></pre>

<hr>
<h2 id='is_pdf'>Check that a file is PDF</h2><span id='topic+is_pdf'></span>

<h3>Description</h3>

<p>Checks whether a file is a PDF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_pdf(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_pdf_+3A_file">file</code></td>
<td>
<p>a filepath</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
is_pdf("document.pdf")

## End(Not run)
</code></pre>

<hr>
<h2 id='list_processor_types'>List available processor types</h2><span id='topic+list_processor_types'></span>

<h3>Description</h3>

<p>List available processor types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_processor_types(
  full_list = FALSE,
  proj_id = get_project_id(),
  loc = "eu",
  token = dai_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_processor_types_+3A_full_list">full_list</code></td>
<td>
<p>boolean.</p>
</td></tr>
<tr><td><code id="list_processor_types_+3A_proj_id">proj_id</code></td>
<td>
<p>a GCS project id.</p>
</td></tr>
<tr><td><code id="list_processor_types_+3A_loc">loc</code></td>
<td>
<p>a two-letter region code; &quot;eu&quot; or &quot;us&quot;.</p>
</td></tr>
<tr><td><code id="list_processor_types_+3A_token">token</code></td>
<td>
<p>an authentication token generated by
<code>dai_auth()</code> or another auth function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Retrieves information about the processors that
can be created in the current project. With
<code>full_list = TRUE</code> it returns a list with detailed
information about each processor. With <code>full_list = FALSE</code>
it returns a character vector with just the processor names.
For more information about processors, see the
Google Document AI documentation at
<a href="https://cloud.google.com/document-ai/docs/">https://cloud.google.com/document-ai/docs/</a>.
</p>


<h3>Value</h3>

<p>list or character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
avail_short &lt;- list_processor_types()
avail_long &lt;- list_processor_types(full_list = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='make_hocr'>Make hOCR file</h2><span id='topic+make_hocr'></span>

<h3>Description</h3>

<p>Creates a hOCR file from Document AI output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_hocr(type, output, outfile_name = "out.hocr", dir = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_hocr_+3A_type">type</code></td>
<td>
<p>one of &quot;sync&quot; or &quot;async&quot; depending on
the function used to process the original document.</p>
</td></tr>
<tr><td><code id="make_hocr_+3A_output">output</code></td>
<td>
<p>either a HTTP response object (from <code>dai_sync()</code>) or
the path to a JSON file (from <code>dai_async</code>).</p>
</td></tr>
<tr><td><code id="make_hocr_+3A_outfile_name">outfile_name</code></td>
<td>
<p>a string with the desired filename. Must end with
either <code>.hocr</code>, <code>.html</code>, or <code>.xml</code>.</p>
</td></tr>
<tr><td><code id="make_hocr_+3A_dir">dir</code></td>
<td>
<p>a string with the path to the desired output directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>hOCR is an open standard of data representation for formatted
text obtained from optical character recognition. It can be used to
generate searchable PDFs and many other things. This function generates
a file compliant with the official hOCR specification
(https://github.com/kba/hocr-spec) complete with token-level confidence
scores. It also works with non-latin scripts and right-to-left languages.
</p>


<h3>Value</h3>

<p>no return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
make_hocr(type = "async", output = "output.json")
resp &lt;- dai_sync("file.pdf")
make_hocr(type = "sync", output = resp)
make_hocr(type = "sync", output = resp, outfile_name = "myfile.xml")

## End(Not run)
</code></pre>

<hr>
<h2 id='merge_shards'>Merge shards</h2><span id='topic+merge_shards'></span>

<h3>Description</h3>

<p>Merges text files from Document AI output shards into a
single text file corresponding to the parent document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_shards(source_dir = getwd(), dest_dir = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_shards_+3A_source_dir">source_dir</code></td>
<td>
<p>folder path for input files</p>
</td></tr>
<tr><td><code id="merge_shards_+3A_dest_dir">dest_dir</code></td>
<td>
<p>folder path for output files</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works on .txt files generated from .json output files,
not on .json files directly. It also presupposes that the .txt filenames
have the same name stems as the .json files from which they were extracted.
For the v1 API, this means files ending with &quot;-0.txt&quot;, &quot;-1.txt&quot;, &quot;-2.txt&quot;,
and so forth. The safest approach is to generate .txt files using
<code>get_text()</code> with the <code>save_to_file</code> parameter set to TRUE.
</p>


<h3>Value</h3>

<p>no return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
merge_shards()

merge_shards(tempdir(), getwd())

## End(Not run)
</code></pre>

<hr>
<h2 id='pdf_to_binbase'>PDF to base64 tiff</h2><span id='topic+pdf_to_binbase'></span>

<h3>Description</h3>

<p>Converts a PDF file to a base64-encoded binary .tiff file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdf_to_binbase(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf_to_binbase_+3A_file">file</code></td>
<td>
<p>path to a single-page pdf file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a base64-encoded string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
doc_encoded &lt;- pdf_to_binbase("document.pdf")

## End(Not run)
</code></pre>

<hr>
<h2 id='reassign_tokens'>Assign tokens to new blocks</h2><span id='topic+reassign_tokens'></span>

<h3>Description</h3>

<p>This is a specialized function for use in connection
with text reordering. It modifies a token dataframe by assigning
new block bounding box values to a subset of tokens based on
prior modifications made to a block dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reassign_tokens(token_df, block_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reassign_tokens_+3A_token_df">token_df</code></td>
<td>
<p>a dataframe generated by <code>build_token_df()</code></p>
</td></tr>
<tr><td><code id="reassign_tokens_+3A_block_df">block_df</code></td>
<td>
<p>a dataframe generated by <code>dair::split_block()</code>
or <code>dair::build_block_df()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The token and block data frames provided as input must be
from the same JSON output file.
</p>


<h3>Value</h3>

<p>a token data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new_token_df &lt;- reassign_tokens(token_df, new_block_df)

## End(Not run)
</code></pre>

<hr>
<h2 id='reassign_tokens2'>Assign tokens to a single new block</h2><span id='topic+reassign_tokens2'></span>

<h3>Description</h3>

<p>This is a specialized function for use in connection
with text reordering. It is designed to facilitate manual splitting
of block boundary boxes and typically takes a one-row block dataframe
generated by <code>from_labelme()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reassign_tokens2(token_df, block, page = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reassign_tokens2_+3A_token_df">token_df</code></td>
<td>
<p>a data frame generated by <code>dair::build_token_df</code></p>
</td></tr>
<tr><td><code id="reassign_tokens2_+3A_block">block</code></td>
<td>
<p>a one-row data frame of the same format as <code>token_df</code></p>
</td></tr>
<tr><td><code id="reassign_tokens2_+3A_page">page</code></td>
<td>
<p>the number of the page on which the block belongs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a token data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new_token_df &lt;- reassign_tokens2(token_df, new_block_df)
new_token_df &lt;- reassign_tokens2(token_df, new_block_df, 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='redraw_blocks'>Inspect revised block bounding boxes</h2><span id='topic+redraw_blocks'></span>

<h3>Description</h3>

<p>Tool to visually check the order of block bounding boxes after
manual processing (e.g. block reordering or splitting). Takes as its main
input a token dataframe generated with <code>build_token_df()</code>,
<code>reassign_tokens()</code>, or <code>reassign_tokens2()</code>.
The function plots the block bounding boxes onto images of the submitted
document. Generates an annotated .png file for each page in the
original document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redraw_blocks(json, token_df, dir = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redraw_blocks_+3A_json">json</code></td>
<td>
<p>filepath of a JSON file obtained using <code>dai_async()</code></p>
</td></tr>
<tr><td><code id="redraw_blocks_+3A_token_df">token_df</code></td>
<td>
<p>a token data frame generated with <code>build_token_df()</code>,
<code>reassign_tokens()</code>, or <code>reassign_tokens2()</code>.</p>
</td></tr>
<tr><td><code id="redraw_blocks_+3A_dir">dir</code></td>
<td>
<p>path to the desired output directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not vectorized, but documents can be multi-page.
</p>


<h3>Value</h3>

<p>no return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
redraw_blocks("pdf_output.json", revised_token_df, dir = tempdir())

## End(Not run)
</code></pre>

<hr>
<h2 id='split_block'>Split a block bounding box</h2><span id='topic+split_block'></span>

<h3>Description</h3>

<p>This function 'splits' (in the sense of changing the
coordinates) of an existing block bounding box vertically or
horizontally at a specified point. It takes a block data frame as
input and modifies it. The splitting produces a new block, which
is added to the data frame while the old block's coordinates are
updated. The function returns a revised block data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_block(block_df, page = 1, block, cut_point, direction = "v")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_block_+3A_block_df">block_df</code></td>
<td>
<p>A dataframe generated by <code>build_block_df()</code>.</p>
</td></tr>
<tr><td><code id="split_block_+3A_page">page</code></td>
<td>
<p>The number of the page where the split will be made.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="split_block_+3A_block">block</code></td>
<td>
<p>The number of the block to be split.</p>
</td></tr>
<tr><td><code id="split_block_+3A_cut_point">cut_point</code></td>
<td>
<p>A number between 0 and 100, where 0 is the
existing left/top limit and 100 is the existing right/bottom limit.</p>
</td></tr>
<tr><td><code id="split_block_+3A_direction">direction</code></td>
<td>
<p>&quot;V&quot; for vertical split or &quot;H&quot; for horizontal split.
Defaults to &quot;V&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a block data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new_block_df &lt;- split_block(df = old_block_df, block = 7, cut_point = 33)

## End(Not run)
</code></pre>

<hr>
<h2 id='tables_from_dai_file'>Get tables from output file</h2><span id='topic+tables_from_dai_file'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
<code>tables_from_dai_file()</code> is deprecated; please use <code>get_text()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tables_from_dai_file(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tables_from_dai_file_+3A_file">file</code></td>
<td>
<p>filepath of a JSON file obtained using <code>dai_async_tab()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tables &lt;- tables_from_dai_file("document.json")

## End(Not run)
</code></pre>

<hr>
<h2 id='tables_from_dai_response'>Get tables from response object</h2><span id='topic+tables_from_dai_response'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
<code>tables_from_dai_response()</code> is deprecated; please use <code>get_tables()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tables_from_dai_response(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tables_from_dai_response_+3A_object">object</code></td>
<td>
<p>an HTTP response object returned by <code>dai_sync_tab()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tables &lt;- tables_from_dai_response(response)

## End(Not run)
</code></pre>

<hr>
<h2 id='text_from_dai_file'>Get text from output file</h2><span id='topic+text_from_dai_file'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
<code>text_from_dai_file()</code> is deprecated; please use <code>get_text()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_from_dai_file(file, save_to_file = FALSE, dest_dir = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_from_dai_file_+3A_file">file</code></td>
<td>
<p>filepath of a JSON file obtained using <code>dai_async()</code></p>
</td></tr>
<tr><td><code id="text_from_dai_file_+3A_save_to_file">save_to_file</code></td>
<td>
<p>boolean; whether to save the text as a .txt file</p>
</td></tr>
<tr><td><code id="text_from_dai_file_+3A_dest_dir">dest_dir</code></td>
<td>
<p>folder path for the .txt output file if save_to_file=TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string (if <code>save_to_file = FALSE</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
text &lt;- text_from_dai_file("mydoc-0.json")
text_from_dai_file("mydoc-0.json", save_to_file = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='text_from_dai_response'>Get text from HTTP response object</h2><span id='topic+text_from_dai_response'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
<code>text_from_dai_response()</code> is deprecated; please use <code>get_text()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_from_dai_response(
  response,
  save_to_file = FALSE,
  dest_dir = getwd(),
  filename = "output"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_from_dai_response_+3A_response">response</code></td>
<td>
<p>an HTTP response object returned by <code>dai_sync()</code></p>
</td></tr>
<tr><td><code id="text_from_dai_response_+3A_save_to_file">save_to_file</code></td>
<td>
<p>boolean; whether to save the text as a .txt file</p>
</td></tr>
<tr><td><code id="text_from_dai_response_+3A_dest_dir">dest_dir</code></td>
<td>
<p>folder path for the .txt output file if <code>save_to_file = TRUE</code></p>
</td></tr>
<tr><td><code id="text_from_dai_response_+3A_filename">filename</code></td>
<td>
<p>string to form the stem of the .txt output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string (if <code>save_to_file = FALSE</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
text &lt;- text_from_dai_response(response)

text_from_dai_response(response, save_to_file = TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
