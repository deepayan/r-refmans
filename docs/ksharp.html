<!DOCTYPE html><html lang="en"><head><title>Help for package ksharp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ksharp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kdata.1'><p>Toy dataset with two convex groups with partial overlap</p></a></li>
<li><a href='#kdata.2'><p>Toy dataset with two non-overalpping and non-spherical groups</p></a></li>
<li><a href='#kdata.3'><p>Toy dataset with three groups</p></a></li>
<li><a href='#kdata.4'><p>Toy dataset with four groups atop a wide area of noise points</p></a></li>
<li><a href='#ksharp'><p>sharpen a clustering</p></a></li>
<li><a href='#medinfo'><p>compute info on distances to medoids/centroids</p></a></li>
<li><a href='#neiinfo'><p>Compute info on 'neighbor widths'</p></a></li>
<li><a href='#silinfo'><p>Compute info on silhouette widths</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Cluster Sharpening</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Tomasz Konopka [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tomasz Konopka &lt;tokonopka@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Clustering typically assigns data points into discrete groups, but the clusters can sometimes be indistinct. Cluster sharpening adjusts an existing clustering to create contrast between groups. This package provides a general interface for cluster sharpening along with several implementations based on different excision criteria.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tkonopka/ksharp">https://github.com/tkonopka/ksharp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tkonopka/ksharp/issues">https://github.com/tkonopka/ksharp/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cluster, dbscan, knitr, Rcssplot (&ge; 1.0.0), rmarkdown,
testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-18 15:56:31 UTC; tkonopka</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-26 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='kdata.1'>Toy dataset with two convex groups with partial overlap</h2><span id='topic+kdata.1'></span>

<h3>Description</h3>

<p>Toy dataset with two convex groups with partial overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kdata.1)
</code></pre>


<h3>Format</h3>

<p>matrix with two columns: <code>D1</code>, <code>D2</code></p>

<hr>
<h2 id='kdata.2'>Toy dataset with two non-overalpping and non-spherical groups</h2><span id='topic+kdata.2'></span>

<h3>Description</h3>

<p>Toy dataset with two non-overalpping and non-spherical groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kdata.2)
</code></pre>


<h3>Format</h3>

<p>matrix with two columns: <code>D1</code>, <code>D2</code></p>

<hr>
<h2 id='kdata.3'>Toy dataset with three groups</h2><span id='topic+kdata.3'></span>

<h3>Description</h3>

<p>Toy dataset with three groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kdata.3)
</code></pre>


<h3>Format</h3>

<p>matrix with two columns: <code>D1</code>, <code>D2</code></p>

<hr>
<h2 id='kdata.4'>Toy dataset with four groups atop a wide area of noise points</h2><span id='topic+kdata.4'></span>

<h3>Description</h3>

<p>Toy dataset with four groups atop a wide area of noise points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kdata.4)
</code></pre>


<h3>Format</h3>

<p>matrix with two columns: <code>D1</code>, <code>D2</code></p>

<hr>
<h2 id='ksharp'>sharpen a clustering</h2><span id='topic+ksharp'></span>

<h3>Description</h3>

<p>Each data point in a clustering is assigned to a cluster, but some data
points may lie in ambiguous zones between two or more clusters, or far
from other points. Cluster sharpening assigns these border points into
a separate noise group, thereby creating more stark distinctions between
groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksharp(
  x,
  threshold = 0.1,
  data = NULL,
  method = c("silhouette", "neighbor", "medoid"),
  threshold.abs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ksharp_+3A_x">x</code></td>
<td>
<p>clustering object; several types of inputs are acceptable,
including objects of class kmeans, pam, and self-made lists with a
component &quot;cluster&quot;.</p>
</td></tr>
<tr><td><code id="ksharp_+3A_threshold">threshold</code></td>
<td>
<p>numeric; the fraction of points to place in noise group</p>
</td></tr>
<tr><td><code id="ksharp_+3A_data">data</code></td>
<td>
<p>matrix, raw data corresponding to clustering x; must be present
when sharpening for the first time or if data is not present within x.</p>
</td></tr>
<tr><td><code id="ksharp_+3A_method">method</code></td>
<td>
<p>character, determines method used for sharpening</p>
</td></tr>
<tr><td><code id="ksharp_+3A_threshold.abs">threshold.abs</code></td>
<td>
<p>numeric; absolute-value of threshold for sharpening.
When non-NULL, this value overrides value in argument 'threshold'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Noise points are assigned to a group with cluster index 0. This is
analogous behavior to output produced by dbscan.
</p>


<h3>Value</h3>

<p>clustering object based on input x, with adjusted cluster
assignments and additional list components with sharpness measures.
Cluster assignments are placed in $cluster and excised data points
are given a cluster index of 0. Original cluster assignments are
saved in $cluster.original. Sharpness measures are stored in
components $silinfo, $medinfo, and $neiinfo, although these details
may change in future versions of the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare iris dataset for analysis
iris.data = iris[, 1:4]
rownames(iris.data) = paste0("iris_", seq_len(nrow(iris.data)))

# cluster the dataset into three groups
iris.clustered = kmeans(iris.data, centers=3)
table(iris.clustered$cluster)

# sharpen the clustering by excluding 10% of the data points
iris.sharp = ksharp(iris.clustered, threshold=0.1, data=iris.data)
table(iris.sharp$cluster)

# visualize cluster assignments
iris.pca = prcomp(iris.data)$x[,1:2]
plot(iris.pca, col=iris$Species, pch=ifelse(iris.sharp$cluster==0, 1, 19))

</code></pre>

<hr>
<h2 id='medinfo'>compute info on distances to medoids/centroids</h2><span id='topic+medinfo'></span>

<h3>Description</h3>

<p>Analogous in structure to silinfo and neiinfo, it computes
a &quot;widths&quot; matrix assessing how well each data point belongs
to its cluster. Here, this measure is the ratio of two distances:
in the numerator, the distance from the point to the nearest cluster center,
and in the denominator, from the point to its own cluster center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medinfo(cluster, data, silwidths)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medinfo_+3A_cluster">cluster</code></td>
<td>
<p>named vector</p>
</td></tr>
<tr><td><code id="medinfo_+3A_data">data</code></td>
<td>
<p>matrix with raw data</p>
</td></tr>
<tr><td><code id="medinfo_+3A_silwidths">silwidths</code></td>
<td>
<p>matrix with silhouette widths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with component widths. The widths object is a matrix
with one row per data item, with column med_ratio holding
the sharpness measure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a manual clustering of the iris dataset
iris.data = iris[, 1:4]
rownames(iris.data) = paste0("iris_", seq_len(nrow(iris.data)))
iris.dist = dist(iris.data)
iris.clusters = setNames(as.integer(iris$Species), rownames(iris.data))

# compute sharpnessvalues based on medoids
iris.silinfo = silinfo(iris.clusters, iris.dist)
medinfo(iris.clusters, iris.data, iris.silinfo$widths)

</code></pre>

<hr>
<h2 id='neiinfo'>Compute info on 'neighbor widths'</h2><span id='topic+neiinfo'></span>

<h3>Description</h3>

<p>This function provides information on how well each data point
belongs to its cluster. For each query point, the function considers
n of its nearest neighbors. The neighbor widths are defined as the
fraction of those neighbors that belong to the same cluster as the
query point. These values are termed 'widths' in analogy to
silhouette widths, another measure of cluster membership.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neiinfo(cluster, dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neiinfo_+3A_cluster">cluster</code></td>
<td>
<p>vector with assignments of data elements to clusters</p>
</td></tr>
<tr><td><code id="neiinfo_+3A_dist">dist</code></td>
<td>
<p>distance object or matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function follows a similar signature as silinfo from this package.
</p>


<h3>Value</h3>

<p>list with component widths. The wdiths object is a matrix
with one row per data item, wth column neighborhood holding the
sharpness value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a manual clustering of the iris dataset
iris.data = iris[, 1:4]
rownames(iris.data) = paste0("iris_", seq_len(nrow(iris)))
iris.dist = dist(iris.data)
iris.clusters = setNames(as.integer(iris$Species), rownames(iris.data))

# compute neighbor-based sharpness widths
neiinfo(iris.clusters, iris.dist)

</code></pre>

<hr>
<h2 id='silinfo'>Compute info on silhouette widths</h2><span id='topic+silinfo'></span>

<h3>Description</h3>

<p>This function provides information on how well each data point
belongs to its cluster. For each query point, the function considers
the average distance to other members of the same cluster and the
average distance to members of another, nearest, cluster. The widths
are defined as the
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silinfo(cluster, dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="silinfo_+3A_cluster">cluster</code></td>
<td>
<p>vector with assignments of data elements to clusters</p>
</td></tr>
<tr><td><code id="silinfo_+3A_dist">dist</code></td>
<td>
<p>distance object or matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function signature is very similar to cluster::silhouette but
the implementation has important differences. This implementation
requires both the dist object and and cluster vector must have names.
This prevents accidental assignment of silhouette widths to the wrong
elements.
</p>


<h3>Value</h3>

<p>list, analogous to object within output from cluster::pam.
In particular, the list has a component widths. The widths object is
matrix with one row per data item, with column sil_width holding the
silhouette width.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a manual clustering of the iris dataset
iris.data = iris[, 1:4]
rownames(iris.data) = paste0("iris_", seq_len(nrow(iris.data)))
iris.dist = dist(iris.data)
iris.clusters = setNames(as.integer(iris$Species), rownames(iris.data))

# compute sharpness values based on silhouette widths
silinfo(iris.clusters, iris.dist)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
