<!DOCTYPE html><html><head><title>Help for package intamap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {intamap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesCopula'><p>Performs spatial interpolation using copulas</p></a></li>
<li><a href='#blockPredict'><p> Spatial block prediction</p></a></li>
<li><a href='#checkSetup'><p> check setup</p></a></li>
<li><a href='#coarsenGrid'><p> Coarsening of a spatial grid</p></a></li>
<li><a href='#conformProjections'><p> Getting conformed projections</p></a></li>
<li><a href='#copulaEstimation'><p>ML-estimation of the spatial copula model parameters</p></a></li>
<li><a href='#createIntamapObject'><p>Create an object for interpolation within the intamap package</p></a></li>
<li><a href='#estimateAnisotropy'><p>estimateAnisotropy</p></a></li>
<li><a href='#estimateParameters'><p> Automatic estimation of correlation structure parameters</p></a></li>
<li><a href='#estimateTimeModel'><p>estimateTimeModel</p></a></li>
<li><a href='#generateTimeModels'><p>Generate time models</p></a></li>
<li><a href='#getIntamapParams'><p> Setting parameters for the intamap package</p></a></li>
<li><a href='#getInterpolationMethodNames'><p> get interpolation method names</p></a></li>
<li><a href='#intamap'><p>Example data for the intamap package</p></a></li>
<li><a href='#intamap-package'><p>A package providing methods for automatic interpolation:</p>
pre-processing, parameter estimation, spatial prediction and post processing</a></li>
<li><a href='#intamapExampleObject'><p>Simulated Intamap Object</p></a></li>
<li><a href='#interpolate'><p> spatial interpolation</p></a></li>
<li><a href='#methodParameters'><p> generate string for generation of method parameters</p></a></li>
<li><a href='#plotIntamap'><p> plot intamap objects</p></a></li>
<li><a href='#postProcess'><p> pre-process data</p></a></li>
<li><a href='#predictTime'><p>Time prediction for intamap package methods</p></a></li>
<li><a href='#preProcess'><p> pre-processing of data</p></a></li>
<li><a href='#rotateAnisotropicData'><p>rotateAnisotropicData</p></a></li>
<li><a href='#spatialPredict'><p> Spatial prediction</p></a></li>
<li><a href='#summaryIntamap'><p> summary intamap objects</p></a></li>
<li><a href='#timeModels'><p>models for estimating prediction time in intamap package</p></a></li>
<li><a href='#unbiasedKrige'><p> Unbiased kriging</p></a></li>
<li><a href='#yamamotoKrige'><p>kriging and simulation with alternative kriging variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Procedures for Automated Interpolation</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jon Olav Skoien &lt;jon.skoien@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), sp (&ge; 0.9-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gstat (&ge; 0.9-36), sf, automap, MBA, mvtnorm, MASS, evd,
doParallel, foreach, parallel, stats, methods, grDevices,
utils, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>psgp</td>
</tr>
<tr>
<td>Description:</td>
<td>Geostatistical interpolation has traditionally been done by manually fitting a variogram and then interpolating. Here, we introduce classes and methods that can do this interpolation automatically. Pebesma et al (2010) gives an overview of the methods behind and possible usage &lt;<a href="https://doi.org/10.1016%2Fj.cageo.2010.03.019">doi:10.1016/j.cageo.2010.03.019</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-30 10:34:22 UTC; skoiejo</td>
</tr>
<tr>
<td>Author:</td>
<td>Edzer Pebesma [aut],
  Jon Olav Skoien [aut, cre],
  Olivier Baume [ctb],
  A Chorti [ctb],
  Dionisis Hristopulos [ctb],
  Hannes Kazianka [ctb],
  Stepahnie Melles [ctb],
  Giannis Spiliopoulos [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-30 11:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesCopula'>Performs spatial interpolation using copulas</h2><span id='topic+bayesCopula'></span>

<h3>Description</h3>

<p>Calculates predictive mean, predictive variance, predictive quantiles and exceedance probabilities for certain thresholds in the spatial copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesCopula(obj,estimates,search=10,calc=list(mean=TRUE,variance=TRUE),testMean=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesCopula_+3A_obj">obj</code></td>
<td>
<p>Intamap object including observations and predictionLocations, see 
<code><a href="#topic+intamap-package">intamap-package</a></code></p>
</td></tr>
<tr><td><code id="bayesCopula_+3A_estimates">estimates</code></td>
<td>
<p>List of estimated parameters (typically obtained by calling <code><a href="#topic+copulaEstimation">copulaEstimation</a></code>)</p>
</td></tr>
<tr><td><code id="bayesCopula_+3A_search">search</code></td>
<td>
<p>local prediction: number of observed locations considered for prediction at each unknown point</p>
</td></tr>
<tr><td><code id="bayesCopula_+3A_calc">calc</code></td>
<td>
<p>list of what prediction type is required:
</p>
 
<dl>
<dt><code>mean = TRUE</code></dt><dd><p><code>TRUE</code> if the predictive mean should be calculated, <code>FALSE</code> otherwise</p>
</dd>
<dt><code>variance = TRUE</code></dt><dd><p><code>TRUE</code> if the predictive variance should be calculated, <code>FALSE</code> otherwise</p>
</dd>
<dt><code>quantiles = NULL</code></dt><dd><p>Vector of desired predictive quantiles, e.g. 0.95 or 0.05</p>
</dd>
<dt><code>excprob = NULL</code></dt><dd><p>Vector of thresholds, where the probability of exceeding this threshold is desired</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bayesCopula_+3A_testmean">testMean</code></td>
<td>
<p>Whether or not the predictive means (if calculated) should be tested for being reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bayesCopula</code> is used for plug-in prediction at unobserved spatial locations. The name of the function is somewhat 
misleading since  no Bayesian approach is implemented so far. It is possible to calculate numerically the predictive mean
and variance for both the Gaussian and the chi-square spatial copula model. Exceedance probabilities and predictive 
quantiles are only supported for the Gaussian copula model. Note that it may occur that the predictive distribution has 
no finite moments. In this case, a possible predictor is the median of the predictive distribution. If <code>testMean=TRUE</code> and
the predictive means have no reasonable values, the median is automatically calculated and a warning is produced.
</p>
<p>The copula prediction method is computationally demanding.
There is a possibility of running it as a parallel process by setting the parameter
<code>nclus &gt; 1</code> for the interpolation process. This requires a previous installation
of the package <code>doParallel</code>.
</p>


<h3>Value</h3>

<p>List with the following elements:
</p>

<dl>
<dt>mean</dt><dd><p>Mean of the predictive distribution. NULL if not calculated.</p>
</dd>
<dt>variance</dt><dd><p>Variance of the predtictive distribution. NULL if not calculated.</p>
</dd>
<dt>quantiles</dt><dd><p>Quantiles of the predictive distribution NULL if not calculated.</p>
</dd>
<dt>excprob</dt><dd><p>Probabilities for the predictive distribution to exceed predefined thresholds. NULL if not calculated.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Hannes Kazianka</p>


<h3>References</h3>

<p>[1] Kazianka, H. and Pilz, J. (2009), Spatial Interpolation Using Copula-Based Geostatistical Models. GeoENV2008 - Geostatistics for Environmental Application (P. Atkinson, C. Lloyd, eds.), Springer, New York 
</p>
<p>[2] Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+copulaEstimation">copulaEstimation</a></code>, <code><a href="#topic+spatialPredict">spatialPredict</a></code>, <code><a href="#topic+estimateParameters">estimateParameters</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(intamapExampleObject)
## estimate parameters for the copula model
copula &lt;- list(method="norm")
anisotropy &lt;- list(lower = c(0,1), upper = c(pi, Inf), params = c(pi/3, 2))
correlation &lt;- list(model = "Ste", lower=c(0.01, 0.01, 0.01), upper = c(0.99, Inf, 20),
                    params = c(0.05, 4, 3))
margin &lt;- list(name = "gev", lower = c(0.01, -Inf), upper = c(Inf, Inf), params = c(30, 0.5))
trend &lt;- list(F = as.matrix(rep(1, 196)), lower = -Inf, upper = Inf, params = 40)
estimates &lt;- copulaEstimation(intamapExampleObject, margin, trend, correlation, anisotropy, copula)
## make predictions at unobserved locations
predictions&lt;-bayesCopula(intamapExampleObject, estimates, search = 25,
    calc = list(mean = TRUE, variance = TRUE, excprob = 40, quantile = 0.95))

## End(Not run)
</code></pre>

<hr>
<h2 id='blockPredict'> Spatial block prediction</h2><span id='topic+blockPredict'></span><span id='topic+spatialPredict.block'></span>

<h3>Description</h3>

<p><code>blockPredict</code> is a generic method for prediction of 
spatially aggregated variables within the <code><a href="#topic+intamap-package">intamap-package</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> blockPredict(object, ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockPredict_+3A_object">object</code></td>
<td>
<p> a list object of the type described in <code><a href="#topic+intamap-package">intamap-package</a></code></p>
</td></tr>
<tr><td><code id="blockPredict_+3A_...">...</code></td>
<td>
<p> other arguments that will be passed to the requested interpolation method. 
See the individual interpolation methods for more information. The following arguments 
from <code>object</code> can be overrun through <code>...</code>:
</p>

<dl>
<dt><code>block</code></dt><dd><p>Block size; a vector with 1, 2 or 3 values containing the size
of a rectangular in x-, y- and z-dimension respectively
(0 if not set), or a data frame with 1, 2 or 3 columns,
containing the points that discretize the block in the
x-, y- and z-dimension to define irregular blocks relative to
(0,0) or (0,0,0) - see also the details section of <code><a href="gstat.html#topic+predict.gstat">predict.gstat</a></code>.
By default, predictions or simulations refer to the support of the data values. </p>
</dd>
<dt><code>cellsize</code></dt><dd><p>size of cells for discretization of blocks for numerical simulation</p>
</dd>
</dl>

</td></tr> 
</table>


<h3>Details</h3>

<p>The function <code>blockPredict</code> is a wrapper around the <code>spatialPredict.block</code> function 
within the <code><a href="#topic+intamap-package">intamap-package</a></code> package, to simplify the calls for block predictions. 
</p>
<p>Block predictions are spatial predictions assumed to be valid for a certain area. 
The blocks can either be given by passing <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> as the 
predicitonLocations or by passing the block-argument through the parameters of the 
object or through the <code>...</code>-argument.
</p>
<p>There are esentially two ways to solve the problems of block predictions.
</p>

<dl>
<dt>analytical</dt><dd><p>block predictions can be found directly by block kriging</p>
</dd>
<dt>numerical</dt><dd><p>block predictions can be found through numerical simulations
over a set of points within the block, the requested output is found by 
averaging over these simulations </p>
</dd>
</dl>

<p>The analytical solutions are used when applicable. This is typically for 
ordinary kriging based methods and prediction types that can be
found by linear aggregation (e.g. block mean). 
</p>
<p>If the prediction type necessitates simulations, this is done by subsampling
the blocks. This can either be done block-wise, with a certain number of points
within each block, with a certain cellsize, or with a certain number of points
</p>
<p><code>automap</code> Uses function <code><a href="automap.html#topic+autoKrige">autoKrige</a></code> in the 
<code>automap</code> package.
If <code>object</code> already includes a variogram model, 
<code><a href="gstat.html#topic+krige">krige</a></code> in the <code>gstat</code>-package will be called directly.
</p>


<h3>Value</h3>

 
<p>a list object similar to <code>object</code>, but extended with predictions at
a the set of locations defined <code>object</code>.
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>See Also</h3>

<p><code><a href="gstat.html#topic+gstat">gstat</a></code>,<code><a href="automap.html#topic+autoKrige">autoKrige</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example skips some steps that might be necessary for more complicated
# tasks, such as estimateParameters and pre- and postProcessing of the data
data(meuse)
coordinates(meuse) = ~x+y
meuse$value = log(meuse$zinc)
data(meuse.grid)
gridded(meuse.grid) = ~x+y
proj4string(meuse) = CRS("+init=epsg:28992")
proj4string(meuse.grid) = CRS("+init=epsg:28992")

# set up intamap object:
obj = createIntamapObject(
	observations = meuse,
	predictionLocations = meuse.grid[sample(1:length(meuse.grid),10),],
	targetCRS = "+init=epsg:3035",
	class = "automap"
)

# do interpolation step:
obj = conformProjections(obj)
obj = estimateParameters(obj) 
obj = blockPredict(obj,block=c(100,100))  # blockPredict


# intamap object for which simulation is needed:
meuse$value = meuse$zinc
obj = createIntamapObject(
	observations = meuse,
	predictionLocations = meuse.grid[sample(1:length(meuse.grid),5),],
	params = list(ngrid = 16),
  class = "transGaussian"  # trans-Gaussian kriging method
)
obj = estimateParameters(obj, lambda = 0)  # lambda is optional, lambda = 0 gives lognormal kriging
obj = blockPredict(obj,block=c(100,100))  # blockPredict
</code></pre>

<hr>
<h2 id='checkSetup'> check setup </h2><span id='topic+checkSetup'></span>

<h3>Description</h3>

<p>checkSetup will do some sanity checks on input data provided through object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSetup(object, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSetup_+3A_object">object</code></td>
<td>
<p> object, to be passed to <code><a href="#topic+preProcess">preProcess</a></code>, see <code><a href="#topic+intamap-package">intamap-package</a></code></p>
</td></tr>
<tr><td><code id="checkSetup_+3A_quiet">quiet</code></td>
<td>
<p> logical; TRUE to suppress OK statement </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>checkSetup</code> is a function that makes certain tests on the intamap object to 
make sure that it is suited for interpolation. Particularly, it will issue a warning
or an error if one of the following conditions are met:
</p>

<ul>
<li> <p><code>observations</code> is not an element of <code>object</code>
</p>
</li>
<li> <p><code>observations</code> contain less than 20 observations
</p>
</li>
<li><p> Some of the observation locations are duplicated
</p>
</li>
<li> <p><code>formulaString</code> is not an element of <code>object</code>
</p>
</li>
<li><p> None of the columns of <code>observations</code> has a name that corresponds to the independent variable of <code>formulaString</code> 
</p>
</li>
<li> <p><code>predictionLocations</code> is not an element of <code>object</code>
</p>
</li>
<li> <p><code>predictionLocations</code> is not a <code><a href="sp.html#topic+Spatial-class">Spatial</a></code> object
</p>
</li>
<li> <p><code>targetCRS</code> is given, but <code>observations</code> and <code>predictionLocations</code> do not have CRS set
</p>
</li>
<li> <p><code>addBias</code> includes biases that are not part of <code>removeBias</code>
</p>
</li></ul>

<p>The function will issue a warning if it appears that <code>predictionLocations</code> 
and <code>observations</code> share a small region. This warning is given as it is 
a likely cause of errors, although it can also happen if <code>predictionLocations</code>
are limited to one small cluster.
</p>


<h3>Value</h3>

 
<p>returns TRUE if check passes, will halt with error when some some error condition is met.
</p>


<h3>Author(s)</h3>

<p> Edzer J. Pebesma </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>

<hr>
<h2 id='coarsenGrid'> Coarsening of a spatial grid</h2><span id='topic+coarsenGrid'></span>

<h3>Description</h3>

<p><code>coarsenGrid</code> is a function that resamples a SpatialGridDataFrame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coarsenGrid(object,coarse=2,offset = sample(c(0:(coarse-1)),2,replace=TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coarsenGrid_+3A_object">object</code></td>
<td>
<p>a <code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialGridDataFrame</a></code> or gridded
<code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPixelsDataFrame</a></code></p>
</td></tr>
<tr><td><code id="coarsenGrid_+3A_coarse">coarse</code></td>
<td>
<p>an integer telling how much the grid should be coarsened</p>
</td></tr>
<tr><td><code id="coarsenGrid_+3A_offset">offset</code></td>
<td>
<p>integer giving the relative offset of the first point, see details 
below for a closer description</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function <code>coarsenGrid</code> is a function that samples from a 
<code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialGridDataFrame</a></code>.
The argument <code>coarse</code> indicates that every <code>coarse</code> row and column will
be sampled, starting with the row and column represented in <code>offset</code>. offset = c(0,0) 
implies that the smallest x- and y-coordinates will be a part of the resampled
data set, offset = c(1,1) implies that sampling will start on the second row and column.
</p>


<h3>Value</h3>

 
<p>a <code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialGridDataFrame</a></code>.
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation of an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.grid)
gridded(meuse.grid) = ~x+y
newMeuseGrid = coarsenGrid(meuse.grid,coarse=2,offset=c(1,1))
</code></pre>

<hr>
<h2 id='conformProjections'> Getting conformed projections
</h2><span id='topic+conformProjections'></span>

<h3>Description</h3>

<p> Getting a conformed projection for a set of <code><a href="sp.html#topic+Spatial-class">Spatial</a></code>* elements
necessary for interpolation in the <code><a href="#topic+intamap-package">intamap-package</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
conformProjections(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conformProjections_+3A_object">object</code></td>
<td>
<p> an object of the type described in <code><a href="#topic+intamap-package">intamap-package</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conformProjections</code> is a function that attempts to reproject all projected 
elements in <code>object</code> to one common projection. 
The function is usually called with an intamap object as argument 
from <code><a href="#topic+createIntamapObject">createIntamapObject</a></code> if the parameter <code>confProj = TRUE</code>. 
Thus it is a function that is usually not necessary to call separately.
</p>
<p>The need for this function is because 
several of the functions in a typical spatial interpolation work flow inside the 
<code><a href="#topic+intamap-package">intamap-package</a></code> require that the elements have a common projection. In 
addition, there are some functions which are not able to deal with 
unprojected spatial objects, i.e. objects with coordinates given in lattitude and
longitude. <code>conformProjections</code> will hence also attempt to reproject all 
elements that 
have coordinates in lattitude and longitude, even in the cases where they 
all have the same projections.
</p>
<p>If only one of observations or predictionLocations has a projection (or is longlat), 
the other one is assumed to be equal. A warning is issued in this case.
</p>
<p>The common projection depends on the object that is passed to conformProjections.
First of all, if <code>intCRS</code> (see below) is present as an element of the object, all elements
will be reprojected to this projection. If not, <code>intCRS</code> will be set equal to 
the first projection possible in the list below.
</p>

<dl>
<dt>intCRS</dt><dd><p>Can be given as a component in <code>object</code> - and is the 
user-defined common projection used for interpolation</p>
</dd>
<dt>targetCRS</dt><dd><p>Can be given as a component in <code>object</code> - and is 
the user-defined target projections</p>
</dd>
<dt>predCRS</dt><dd><p>The projection of the predictionLocations in <code>object</code></p>
</dd>
<dt>obsCRS</dt><dd><p>The projection of the observations</p>
</dd> 






</dl>



<h3>Value</h3>

 
<p>A list of the parameters to be included in the <code>object</code> described in <code><a href="#topic+intamap-package">intamap-package</a></code></p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
coordinates(meuse) = ~x+y
proj4string(meuse) &lt;- CRS("+proj=stere +lat_0=52.15616055555555 
    +lon_0=5.38763888888889 +k=0.999908 +x_0=155000 +y_0=463000 +ellps=bessel +units=m")

predictionLocations = spsample(meuse, 50, "regular")

krigingObject = createIntamapObject(
	observations = meuse,
	predictionLocations = predictionLocations,
  formulaString = as.formula("log(zinc)~1"),
  intCRS = "+init=epsg:3035"
	)

krigingObject = conformProjections(krigingObject)
proj4string(meuse)
proj4string(krigingObject$observations)
</code></pre>

<hr>
<h2 id='copulaEstimation'>ML-estimation of the spatial copula model parameters</h2><span id='topic+copulaEstimation'></span>

<h3>Description</h3>

<p>Estimates parameters of the spatial copula model using maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copulaEstimation(obj,margin,trend,correlation,anisotropy,copula,tol=0.001,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copulaEstimation_+3A_obj">obj</code></td>
<td>
<p>Intamap object, see description in <code><a href="#topic+intamap-package">intamap-package</a></code></p>
</td></tr>
<tr><td><code id="copulaEstimation_+3A_margin">margin</code></td>
<td>
<p>list with the following elements:
</p>

<dl>
<dt><code>params</code></dt><dd><p>Starting values for the parameters of the marginal distribution (excluding trend parameters)</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bounds for the values of the parameters of the marginal distribution (excluding trend parameters)</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bounds for the values of the parameters of the marginal distribution (excluding trend parameters)</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of the family of marginal distributions. Possible names are: &quot;norm&quot;,&quot;lnorm&quot;,&quot;gev&quot;,&quot;t&quot; and &quot;logis&quot;</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="copulaEstimation_+3A_trend">trend</code></td>
<td>
<p>list with the following elements:
</p>

<dl>
<dt><code>params</code></dt><dd><p>Starting values for the parameters of the trend model (location parameter of the marginal distribution)</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bounds for the values of the parameters of the trend model</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bounds for the values of the parameters of the trend model</p>
</dd>
<dt><code>F</code></dt><dd><p>Design matrix.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="copulaEstimation_+3A_correlation">correlation</code></td>
<td>
<p>list with the following elements:
</p>

<dl>
<dt><code>model</code></dt><dd><p>Correlation function model. Possible models are: &quot;Ste&quot;, &quot;Sph&quot;, &quot;Gau&quot; and &quot;Exp&quot;</p>
</dd>
<dt><code>params</code></dt><dd><p>Starting values for the parameters of the correlation function model</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bounds for the values of the parameters of the correlation function model</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bounds for the values of the parameters of the correlation function model</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="copulaEstimation_+3A_anisotropy">anisotropy</code></td>
<td>
<p>list with the following elements:
</p>

<dl>
<dt><code>params</code></dt><dd><p>Starting values for the parameters of geometric anisotropy. If <code>NULL</code>, then no anisotropy is considered.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bounds for the values of the parameters of geometric anisotropy. Usually <code>c(0,1)</code></p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bounds for the values of the parameters of geometric anisotropy. Usually <code>c(pi,Inf)</code></p>
</dd>
</dl>

</td></tr>
<tr><td><code id="copulaEstimation_+3A_copula">copula</code></td>
<td>
<p>list with the following elements:
</p>

<dl>
<dt><code>method</code></dt><dd><p>Either &quot;norm&quot; or &quot;chisq&quot;, depending on which spatial copula model is used, the Gaussian or the chi-squared copula.</p>
</dd>
<dt><code>params</code></dt><dd><p>Only used in case of the chi-squared copula: the squared non-centrality parameter of the non-central chi-squared distribution. Controls how far the chi-squared copula is from the Gaussian copula.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Only used in case of the chi-squared copula: the lower bound for the copula parameter. Usually set to <code>0</code></p>
</dd>
<dt><code>upper</code></dt><dd><p>Only used in case of the chi-squared copula: the upper bound for the copula parameter. Usually set to <code>Inf</code></p>
</dd>
</dl>

</td></tr>
<tr><td><code id="copulaEstimation_+3A_tol">tol</code></td>
<td>
<p>Tolerance level for the optimization process.</p>
</td></tr>
<tr><td><code id="copulaEstimation_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>copulaEstimation</code> performs maximum likelihood estimation of all possible parameters included in the Gaussian and
chi-squared spatial copula model: parameters of the predefined family of marginal distributions (including spatial trend 
or external drift), correlation function parameters, parameters for geometric anisotropy and parameters for the copula 
(only used for the chi-squared copula model). Due to the large number of variables that need to be optimized, a 
profile-likelihood approach is used. Although convergence to a global optimum is not assured, the profile-likelihood method
makes it less likely that the optimization routine, <code><a href="stats.html#topic+optim">optim</a></code>, gets stuck in a local optimum. The result of 
<code>copulaEstimation</code> is a list containing all parameter point estimates that are needed for plug-in spatial 
prediction. It is advisable to check the output of the algorithm by trying different starting values for the optimization. 
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>margin</code></td>
<td>
<p>Same as the input except that the list element &quot;params&quot; now consists of the optimized parameters of the marginal distribution function.</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>Same as the input except that the list element &quot;params&quot; now consists of the optimized parameters of the trend model.</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>Same as the input except that the list element &quot;params&quot; now consists of the optimized parameters of the correlation function model.</p>
</td></tr>
<tr><td><code>anisotropy</code></td>
<td>
<p>Same as the input except that the list element &quot;params&quot; now consists of the optimized parameters of geometric anisotropy.</p>
</td></tr>
<tr><td><code>copula</code></td>
<td>
<p>Same as the input except that the list element &quot;params&quot; now consists of the optimized copula parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hannes Kazianka</p>


<h3>References</h3>

<p>[1] Kazianka, H. and Pilz, J. (2009), Spatial Interpolation Using Copula-Based Geostatistical Models. GeoENV2008 - Geostatistics for Environmental Application (P. Atkinson, C. Lloyd, eds.), Springer, New York 
</p>
<p>[2] Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesCopula">bayesCopula</a></code>, <code><a href="#topic+spatialPredict">spatialPredict</a></code>, <code><a href="#topic+estimateParameters">estimateParameters</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(intamapExampleObject)
## estimate parameters for the copula model

## Not run: copula&lt;-list(method="norm")
anisotropy &lt;- list(lower = c(0, 1), upper = c(pi, Inf), params = c(pi/3, 2))
correlation &lt;- list(model = "Ste", lower = c(0.01, 0.01, 0.01), upper = c(0.99, Inf, 20), 
                    params = c(0.05, 4, 3))
margin &lt;- list(name = "gev", lower = c(0.01, -Inf), upper = c(Inf, Inf), params = c(30, 0.5))
trend &lt;- list(F = as.matrix(rep(1, 196)), lower = -Inf, upper = Inf, params = 40)
estimates &lt;- copulaEstimation(intamapExampleObject, margin, trend, correlation, anisotropy, copula)
## make predictions at unobserved locations
predictions &lt;- bayescopula(intamapExampleObject, estimates, search = 25,
               calc = list(mean = TRUE, variance = TRUE, excprob = 40, quantile = 0.95))
## End(Not run)
</code></pre>

<hr>
<h2 id='createIntamapObject'>Create an object for interpolation within the intamap package</h2><span id='topic+createIntamapObject'></span>

<h3>Description</h3>

<p>This is a help function for creating an object (see <code><a href="#topic+intamap-package">intamap-package</a></code>
to be used for interpolation within the <code><a href="#topic+intamap-package">intamap-package</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createIntamapObject(observations, obsChar, formulaString,
            predictionLocations=100, targetCRS, boundaries, boundaryLines,
            intCRS, params=list(), boundFile, lineFile, class="idw",
            outputWhat, blockWhat = "none",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createIntamapObject_+3A_observations">observations</code></td>
<td>
<p>a 
<code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code>, 
<code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPixelsDataFrame</a></code>, 
<code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialGridDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialLines">SpatialLinesDataFrame</a></code> or
<code><a href="sp.html#topic+SpatialPolygons">SpatialPolygonsDataFrame</a></code> with observations. Note that there
are only few methods that can actually handle interpolation of
observations with a support</p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_obschar">obsChar</code></td>
<td>
<p>list with observation characteristics, used by some interpolation methods</p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_formulastring">formulaString</code></td>
<td>
<p>formula that defines the dependent variable as a linear model 
of independent variables; suppose the dependent variable has name <code>z</code>, 
for ordinary and simple kriging use the formula <code>z~1</code>; 
for universal kriging, suppose <code>z</code> is linearly dependent on 
<code>x</code> and <code>y</code>, use the formula <code>z~x+y</code>. The formulaString defaults
to <code>"value~1"</code> if <code>value</code> is a part of the data set. 
If not, the first column of the data set is used.</p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_predictionlocations">predictionLocations</code></td>
<td>
<p>either a <code><a href="sp.html#topic+Spatial-class">Spatial</a></code>* object with 
prediction locations or an integer with the requested number
of prediction locations. If <code>boundaries</code> are supported, 
the sampled prediction locations will be sampled within the 
<code>boundaries</code> </p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_targetcrs">targetCRS</code></td>
<td>
<p>the wanted projection for the interpolated map</p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_boundaries">boundaries</code></td>
<td>
<p><code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPolygonsDataFrame</a></code> with the boundaries
of regions in the prediction region</p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_boundarylines">boundaryLines</code></td>
<td>
<p><code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPointsDataFrame</a></code> with the boundaries between
pairs of regions discretized as points. 
Will be read from file if <code>lineFile</code> is 
given or will be created from <code>boundaries</code> if not.</p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_intcrs">intCRS</code></td>
<td>
<p>a particular projection requested for the interpolation</p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_params">params</code></td>
<td>
<p>parameters for the interpolation, given as exceptions to the 
default parameters set in the function <code><a href="#topic+getIntamapParams">getIntamapParams</a></code>. It is also possible to pass
a <code>methodParameters</code> from an earlier call, as defined from the function
<code><a href="#topic+methodParameters">methodParameters</a></code>. </p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_boundfile">boundFile</code></td>
<td>
<p>Filename where boundaries can be found, e.g. a shapefile </p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_linefile">lineFile</code></td>
<td>
<p>Filename where paired points on boundaries can be found</p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_class">class</code></td>
<td>
<p>setting the class(es) of the object, see <code><a href="#topic+intamap-package">intamap-package</a></code></p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_outputwhat">outputWhat</code></td>
<td>
<p>List defining the requested type of output. Parameters:
</p>

<dl>
<dt><code>mean = TRUE</code></dt><dd><p>Usual kriging prediction </p>
</dd>
<dt><code>variance = TRUE</code></dt><dd><p>Usual kriging error </p>
</dd>
<dt><code>quantile</code></dt><dd><p>The estimated quantile for a certain threshold</p>
</dd>
<dt><code>excprob</code></dt><dd><p>Exceedance probability for a certain threshold</p>
</dd>
<dt><code>cumdistr</code></dt><dd><p>The cumulative distribution for a certain value</p>
</dd>
<dt><code>MOK</code></dt><dd><p>Assumed unbiased prediction using the MOK method for the threshold given.
See <code><a href="#topic+unbiasedKrige">unbiasedKrige</a></code></p>
</dd>
<dt><code>IWQSEL</code></dt><dd><p>Assumed unbiased prediction using the IWQSEL method for the threshold given.
See <code><a href="#topic+unbiasedKrige">unbiasedKrige</a></code></p>
</dd>
<dt><code>...</code></dt><dd><p>Additional prediction types that do not exist in the default parameter set,
particularly parameters necessary for new methods within the 
<code><a href="#topic+intamap-package">intamap-package</a></code>.</p>
</dd>
</dl>

<p>The list defaults to list (mean = TRUE) for objects of class IDW and 
list(mean=TRUE, variance = TRUE) for all other objects.
</p>
</td></tr>
<tr><td><code id="createIntamapObject_+3A_blockwhat">blockWhat</code></td>
<td>
<p>List defining particular output for block predictions. These include:
</p>

<dl>
<dt><code>blockMax</code></dt><dd><p>logical; whether to predict maximum within block, if block predictions</p>
</dd>
<dt><code>blockMin</code></dt><dd><p>logical; whether to predict mimimum within block, if block predictions</p>
</dd>
<dt><code>fat</code></dt><dd><p>Prediction of area within block above a <code>threshold</code> (<code>fat = threshold</code></p>
</dd>
<dt><code>blockMaxVar</code></dt><dd><p>logical; whether to predict the variance of the prediction of max within the block, 
similarly it is possible to set
<code>blockMinVar = TRUE</code> and <code>fatVar = threshold</code></p>
</dd>
</dl>

</td></tr>
<tr><td><code id="createIntamapObject_+3A_...">...</code></td>
<td>
 

<ul>
<li><p> Either: other elements that can be used by particular interpolation methods. 
These are added to the object as named elements.
</p>
</li>
<li><p> Or: elements that have been created 
in earlier calls to one of the functions in the <code><a href="#topic+intamap-package">intamap-package</a></code>, 
and that are
not supposed to change in the second call. By adding these
elements to the object in <code>createIntamapObject</code>, they can be reused 
without having to re-estimate them. Typical examples are the elements created 
from a call to <code><a href="#topic+preProcess">preProcess</a></code>
</p>
</li></ul>
 
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a help function for creating an object (see
<code><a href="#topic+intamap-package">intamap-package</a></code>) for interpolation within the 
<code><a href="#topic+intamap-package">intamap-package</a></code>.
The function uses some default values if certain elements are not included.
</p>
<p>If <code>createIntamapObject</code> is called without predictionLocations, or if a number
is given, the function will sample a set of predictionLocations. These will
be sampled from a regular grid.
</p>
<p>targetCRS and intCRS are not mandatory variables, but are recommended if the 
user wants predictions of a certain projection. intCRS is not necessary if
the targetCRS is given and has a projection (is not lat-long). It is recommended
to include the argument intCRS if all projected elements are lat-long, as many of 
the interpolation methods do not work optimal with lat-long data. 
</p>
<p>The ...-argument can be used for arguments necessary for new methods not being 
a part of the <code><a href="#topic+intamap-package">intamap-package</a></code>.  It is also a method for reusing previously calculated
elements that can be assumed to be unchanged for the second interpolation.  


</p>


<h3>Value</h3>

 
<p>An object with observations, prediction locations, parameters and possible
additional elements for automatic interpolation. The object will have class
equal to the value of argument <code>class</code>, and methods in the 
<code><a href="#topic+intamap-package">intamap-package</a></code> will dispatch on the
object according to this class.
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intamap-package">intamap-package</a></code> and <code><a href="#topic+getIntamapParams">getIntamapParams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up data:
data(meuse)
coordinates(meuse) = ~x+y
meuse$value = log(meuse$zinc)
data(meuse.grid)
gridded(meuse.grid) = ~x+y
proj4string(meuse) = CRS("+init=epsg:28992")
proj4string(meuse.grid) = CRS("+init=epsg:28992")

# set up intamap object:
idwObject = createIntamapObject(
	observations = meuse,
	predictionLocations = meuse.grid,
	targetCRS = "+init=epsg:3035",
	class = "idw"
)
</code></pre>

<hr>
<h2 id='estimateAnisotropy'>estimateAnisotropy</h2><span id='topic+estimateAnisotropy'></span>

<h3>Description</h3>

<p> This function estimates geometric anisotropy parameters for 2-D scattered data using the 
CTI method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateAnisotropy(object,depVar, formulaString)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateAnisotropy_+3A_object">object</code></td>
<td>
<p> (i) An Intamap type  object (see <code><a href="#topic+intamap-package">intamap-package</a></code>) containing one 
<code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code> data frame named 
<code>observations</code> which includes the observed values (ii) or a 
<code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPointsDataFrame</a></code> which includes both coordinates and observations.</p>
</td></tr>
<tr><td><code id="estimateAnisotropy_+3A_depvar">depVar</code></td>
<td>
<p>name of the dependent variable; this is  used only in case (ii).</p>
</td></tr>
<tr><td><code id="estimateAnisotropy_+3A_formulastring">formulaString</code></td>
<td>
<p>formula that defines the dependent variable as a linear model 
of independent variables, only used for case (ii); suppose the dependent variable has name <code>z</code>, 
for ordinary and simple kriging use the formula <code>z~1</code>; 
for universal kriging, suppose <code>z</code> is linearly dependent on 
<code>x</code> and <code>y</code>, use the formula <code>z~x+y</code>. The formulaString defaults
to <code>"value~1"</code> if <code>value</code> is a part of the data set. 
If not, the first column of the data set is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the input object that defines  N  coordinate pairs (x,y) and observed values (z), 
this method estimates of the geometric anisotropy parameters.  
Geometric anisotropy is a statistical property, which implies that the 
iso-level contours of the covariance function are elliptical. In this case the anisotropy is determined from 
the anisotropic ratio (R) and the orientation angle (<code class="reqn">\theta</code>) of the ellipse. 
</p>
<p>Assuming a Cartesian coordinate system of axes x and y, <code class="reqn">\theta</code> represents the angle 
between the horizontal axis and PA1, where PA1 is one of the principal axes  of the ellipse, 
arbitrarily selected (PA2 will denote the other axis). R represents the ratio of the correlation along PA1 divided by
the correlation length PA2. Note that the returned value of R is always greater than one (see <code>value</code> below.)
</p>
<p>The estimation is based on the Covariance Tensor Identity (CTI) method. In CTI, the 
Hessian matrix of the covariance function is estimated from sample derivatives. The 
anisotropy parameters are estimated by explicit solutions of nonlinear equations that link
(R,<code class="reqn">\theta</code>) with ratios of the covariance Hessian matrix elements. 
</p>
<p>To estimate the sample derivatives from scattered data, a background square lattice is used.
The lattice extends in the horizontal direction from x.min to x.max where x.min (x.max) is equal 
to the minimum (maximum) x-coordinate of the data, and similarly in the vertical direction.
The cell step in each direction is equal to the length of the lattice to the respective direction 
divided by the square root of N.
</p>
<p>BiLinear interpolation, as implemented in <code>akima</code> package, is used to interpolate the 
field's z  values at the nodes of the lattice.
</p>
<p>The CTI method is described in detail in (Chorti and Hristopulos, 2008). 
</p>
<p>Note that to be compatible with <code>gstat</code> the returned estimate of the anisotropy ratio is always
greater than 1. 
</p>
<p>For observations assumed to have a trend, the trend is first subtracted from the data using
universal kriging. This is an approximation, as the trend subtraction does not 
take anisotropy into account.
</p>


<h3>Value</h3>

<p>(i) If the input is an Intamap object, the value is a modification of the input object, 
containing a list element <code>anisPar</code> with  the estimated anisotropy parameters.
(ii)if the input is a <code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPointsDataFrame</a></code>, then only the list <code>anisPar</code> is returned.
The list <code>anisPar</code> contains the following elements:
</p>
<table>
<tr><td><code>ratio</code></td>
<td>
<p>The estimate of the anisotropy ratio parameter. Using the degeneracy of the anisotropy under simultaneous
ratio inversion and axis rotation transformations, the returned value of the ratio is always greater than 1.</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>The estimate of the anisotropy orientation angle. It returns the angle between the major 
anisotropy axis and the horizontal axis, and its value is in the interval (-90,90) degrees.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>A 3x1 array containing the sample estimates of the diagonal and off-diagonal elements (Q11,Q22,Q12) of the  
covariance Hessian matrix evaluated at zero lag.</p>
</td></tr>
<tr><td><code>doRotation</code></td>
<td>
<p>Boolean value indicating if the estimated anisotropy is statistically significant. This value is based on
a statistical test of the isotropic (R= 1) hypothesis using a non-parametric approximation for the 95 percent confidence 
interval for R. This approximation leads to conservative (wider than the true) estimates of the confidence interval. 
If doRotation==TRUE then an isotropy restoring transformation (rotation and rescaling) is performed on the coordinates. 
If doRotation==FALSE no action is taken. 
</p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function uses <code>akima</code> package to perform  &quot;bilinear&quot; interpolation. The source code also allows 
other interpolation methods, but this option is not available when the function is called from within INTAMAP.
</p>
<p>In the <code>gstat</code> package, the anisotropy ratio is defined in the interval (0,1) and the orientation 
angle is the angle between the 
vertical axis and the major anisotropy axis, measured in the clockwise direction. 
If one wants to use ordinary kriging inside INTAMAP 
the necessary transformations are performed in the function <code>estimateParameters.automap</code>. 
If one wants to use ordinary kriging 
in the <code>gstat</code> package (but outside INTAMAP) the required transformations can be found in the 
source code of the <code>estimateParameters.automap</code>
function.
</p>


<h3>Author(s)</h3>

<p> A.Chorti, D.T.Hristopulos,G. Spiliopoulos</p>


<h3>References</h3>

<p>[1] Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>
<p>[2] A. Chorti and D. T. Hristopulos (2008). Non-parametric Identification of 
Anisotropic (Elliptic) Correlations in Spatially Distributed Data Sets, 
IEEE Transactions on Signal Processing, 56(10), 4738-4751 (2008).
</p>
<p>[3] Em.Petrakis and D. T. Hristopulos (2009). A non-parametric test of statistical isotropy for Differentiable 
Spatial Random Fields in Two Dimensions.
Work in progress. email: dionisi@mred.tuc.gr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    library(gstat)
    data(sic2004)
    coordinates(sic.val)=~x+y
    sic.val$value=sic.val$dayx

    params=NULL
    
    estimateAnisotropy(sic.val,depVar = "joker")

</code></pre>

<hr>
<h2 id='estimateParameters'> Automatic estimation of correlation structure parameters</h2><span id='topic+estimateParameters'></span><span id='topic+estimateParameters.automap'></span><span id='topic+estimateParameters.copula'></span><span id='topic+estimateParameters.default'></span><span id='topic+estimateParameters.idw'></span><span id='topic+estimateParameters.linearVariogram'></span><span id='topic+estimateParameters.transGaussian'></span><span id='topic+estimateParameters.yamamoto'></span>

<h3>Description</h3>

<p>Function to estimate correlation structure parameters. The actual parameters
depend on the method used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'automap'
estimateParameters(object, ... )
## S3 method for class 'copula'
estimateParameters(object, ... )
## Default S3 method:
estimateParameters(object, ...)
## S3 method for class 'idw'
estimateParameters(object, ... )
## S3 method for class 'linearVariogram'
estimateParameters(object, ...)

## S3 method for class 'transGaussian'
estimateParameters(object, ... )
## S3 method for class 'yamamoto'
estimateParameters(object, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateParameters_+3A_object">object</code></td>
<td>
<p> an intamap object of the type described in <code><a href="#topic+intamap-package">intamap-package</a></code></p>
</td></tr>
<tr><td><code id="estimateParameters_+3A_...">...</code></td>
<td>
<p> other arguments that will be passed to the requested interpolation method. 
See the individual methods for more information. Some parameters that are particular for some methods:
</p>

<dl>
<dt><code>idpRange</code></dt><dd><p> range of idp (inverse distance weighting power) values 
over which to optimize mse (idw-method) </p>
</dd>
<dt><code>nfolds</code></dt><dd><p> number of folds in n-fold cross validation (idw-method)</p>
</dd>
<dt><code>lambda</code></dt><dd><p>lambda parameter for <code><a href="MASS.html#topic+boxcox">boxcox</a></code>-transformation
(transGaussian method)</p>
</dd>
<dt><code>significant</code></dt><dd><p>logical; if TRUE only transform if any of the four tests 
described under <code><a href="#topic+interpolate">interpolate</a></code> are TRUE (transGaussian method)</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>estimateParameters</code> is a wrapper around different
methods for estimating correlation parameters to be used for the spatial 
prediction method <code><a href="#topic+spatialPredict">spatialPredict</a></code>. 
Below are some details about and/or links to the different methods currently implemented
in the <code><a href="#topic+intamap-package">intamap-package</a></code>.
</p>

<dl>
<dt><code>automap</code></dt><dd><p>It is possible but not necessary to estimate variogram parameters for 
this method. If <code>estimateParameters</code> is called with an object of class <em>automap</em>,
<code><a href="automap.html#topic+autofitVariogram">autofitVariogram</a></code> will be called. 
If <code>object</code> already includes a variogram model when 
<code><a href="#topic+spatialPredict">spatialPredict</a></code> is called, 
<code><a href="gstat.html#topic+krige">krige</a></code> in the <code>gstat</code>-package will be called directly.
The user can submit an argument <code>model</code> with the model(s) to be fitted.  </p>
</dd>
<dt><code>copula</code></dt><dd><p>finding the best copula parameters using <code><a href="#topic+copulaEstimation">copulaEstimation</a></code></p>
</dd>
<dt><code>default</code></dt><dd><p>a default method is not really implemented, this function is only 
created to give a sensible error message if the function is called
with an object for which no method exist</p>
</dd>
<dt><code>idw</code></dt><dd><p>fits the best possible idw-power to the data set by brute force searching within
the <code>idpRange</code></p>
</dd>
<dt><code>linearVariogram</code></dt><dd><p>this function just returns the original data, no parameter 
fitting is necessary for linear variogram kriging</p>
</dd>

<dt><code>transGaussian</code></dt><dd><p>Finding the best model parameters for transGaussian kriging 
(<code><a href="gstat.html#topic+krigeTg">krigeTg</a></code>). This means finding the best <code>lambda</code> for 
the <code><a href="MASS.html#topic+boxcox">boxcox</a></code>-transformation and the fitted variogram
parameters for the transformed variable. If <code>significant = TRUE</code>
will <code>lambda</code> only be estimated
if the data show some deviation from normality, i.e., that at least one
of the tests described under <code><a href="#topic+interpolate">interpolate</a></code> is TRUE. Note that
transGaussian kriging is only possible for data with strictly positive values.
</p>
</dd>
<dt><code>yamamoto</code></dt><dd><p>a wrapper around <code>estimateParameters.automap</code>, only to assure that there is a method
also for this class, difference to <code>automap</code> is more important in <code><a href="#topic+spatialPredict">spatialPredict</a></code></p>
</dd>
</dl>

<p>It is also possible to add to the above methods with functionality from
other packages, if wanted.
You can also check which methods are available from other packages by calling 
</p>
<pre>
&gt;methods(estimateParameters)
</pre>


<h3>Value</h3>

 
<p>a list object similar to <code>object</code>, but extended with correlation parameters.
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createIntamapObject">createIntamapObject</a></code>, <code><a href="#topic+spatialPredict">spatialPredict</a></code>, <code><a href="#topic+intamap-package">intamap-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13131)

# set up data:
data(meuse)
coordinates(meuse) = ~x+y
meuse$value = log(meuse$zinc)
data(meuse.grid)
gridded(meuse.grid) = ~x+y
proj4string(meuse) = CRS("+init=epsg:28992")
proj4string(meuse.grid) = CRS("+init=epsg:28992")

# set up intamap object:
idwObject = createIntamapObject(
	observations = meuse,
	formulaString=as.formula(zinc~1),
  predictionLocations = meuse.grid,
	class = "idw"
)

# run test:
checkSetup(idwObject)

# do interpolation steps:
idwObject = estimateParameters(idwObject, idpRange = seq(0.25,2.75,.25),
                               nfold=3) # faster
idwObject$inverseDistancePower
</code></pre>

<hr>
<h2 id='estimateTimeModel'>estimateTimeModel</h2><span id='topic+estimateTimeModel'></span>

<h3>Description</h3>

<p>Function that takes time samples function that can read intamap objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateTimeModel(FUN, class, formulaString, debug.level, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateTimeModel_+3A_fun">FUN</code></td>
<td>
<p>A string with function's name</p>
</td></tr>
<tr><td><code id="estimateTimeModel_+3A_class">class</code></td>
<td>
<p>class of intamapObject, which interpolation method to be used.</p>
</td></tr>
<tr><td><code id="estimateTimeModel_+3A_formulastring">formulaString</code></td>
<td>
<p>the formula of the request, mainly to see if the request has independent variables.</p>
</td></tr>
<tr><td><code id="estimateTimeModel_+3A_debug.level">debug.level</code></td>
<td>
<p>if <code>debug.level &gt;= 1</code>, the function will store 
tables with the prediction times for each model in the workspace.</p>
</td></tr>
<tr><td><code id="estimateTimeModel_+3A_...">...</code></td>
<td>
<p>other arguments as defined in the <a href="#topic+createIntamapObject">createIntamapObject</a> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses createIntamapObject function to create synthetic data, in order to 
take time samples for the function with string name &quot;FUN&quot;. The calculated model is stored, 
as an element of a list, in a local file (workspace for now) and it's used in order to give quick time estimates.
</p>


<h3>Value</h3>

<p>The function does not return a variable but stores the result in an element list with the same name.</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>

<hr>
<h2 id='generateTimeModels'>Generate time models</h2><span id='topic+generateTimeModels'></span>

<h3>Description</h3>

<p>function that generates time models and saves them in workspace.</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateTimeModels(genClasses = NULL, noGenClasses = NULL, nSam = 1, test = FALSE,
             debug.level = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateTimeModels_+3A_genclasses">genClasses</code></td>
<td>
<p>list of particular classes for which time models should be generated</p>
</td></tr>
<tr><td><code id="generateTimeModels_+3A_nogenclasses">noGenClasses</code></td>
<td>
<p>list of particular classes for which time models should not be generated</p>
</td></tr>
<tr><td><code id="generateTimeModels_+3A_nsam">nSam</code></td>
<td>
<p>number of attempts to be tried for each combination of predictions and observations,
defaults to 1, higher number should be used for better accuracy. nSam/2 is used for
copulas, to reduce computation time.</p>
</td></tr>
<tr><td><code id="generateTimeModels_+3A_test">test</code></td>
<td>
<p>logical; if true, the time models are generated based on fewer iterations, for speed </p>
</td></tr>
<tr><td><code id="generateTimeModels_+3A_debug.level">debug.level</code></td>
<td>
<p>if <code>debug.level &gt;= 1</code>, the function will store 
tables with the prediction times for each model in the workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates a time model for different interpolation types
in the <code><a href="#topic+intamap-package">intamap-package</a></code> and returns a list object
with the estimated models. It's users responsibility to store the model in the 
workspace. The normal procedure would be to run the function without arguments. However,
it is both possible to define a list for which classes the user want to 
generate models, or a list of classes that are not of interest.
</p>
<p>The time model is based on creation of a set of synthetical data sets
of different size, both regarding number of observations and prediction locations.
The function will estimate parameters and make predictions with the different combinations,
and for each method, fit a local polynomial regression model (<code><a href="stats.html#topic+loess">loess</a></code>) 
</p>
<p>This model can then be used by <code><a href="#topic+predictTime">predictTime</a></code> to estimate the 
prediction time for an interpolation request with a certain number 
of observations and prediction locations. </p>


<h3>Value</h3>

<p>The function generates a <code>timeModels</code> object, which can be used to estimate
prediction times for different requests to the <code><a href="#topic+interpolate">interpolate</a></code> function
in the <code><a href="#topic+intamap-package">intamap-package</a></code>, via <code><a href="#topic+predictTime">predictTime</a></code>.
</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
timeModels=generateTimeModels()
q("yes")
## restart R in the same directory

## End(Not run)
</code></pre>

<hr>
<h2 id='getIntamapParams'> Setting parameters for the intamap package</h2><span id='topic+getIntamapParams'></span>

<h3>Description</h3>

<p> This function sets a range of the parameters for the <code><a href="#topic+intamap-package">intamap-package</a></code>, 
to be included in the object described in <code><a href="#topic+intamap-package">intamap-package</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>getIntamapParams(oldPar,newPar,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIntamapParams_+3A_oldpar">oldPar</code></td>
<td>
<p>An existing set of parameters for the interpolation process, 
of class <code>IntamapParams</code> or a list of parameters for modification
of the default parameters</p>
</td></tr>
<tr><td><code id="getIntamapParams_+3A_newpar">newPar</code></td>
<td>
<p>A <code>list</code> of parameters for updating <code>oldPar</code> or for
modification of the default parameters. 
Possible parameters with their defaults are given below</p>
</td></tr>
<tr><td><code id="getIntamapParams_+3A_...">...</code></td>
<td>
<p>Individual parameters for updating <code>oldPar</code> or for
modification of the default parameters.
Possible parameters with their defaults are given below 
</p>

<dl>
<dt><code>doAnisotropy = FALSE</code></dt><dd><p>Defining whether anisotropy should be calculated</p>
</dd>
<dt><code>removeBias = NA</code></dt><dd><p>Defining whether biases should be removed, and in case yes, which ones
(<code>localBias</code> and <code>regionalBias</code> implemented</p>
</dd>
<dt><code>addBias = NA</code></dt><dd><p>Defining which biases to be added in the <code><a href="#topic+postProcess">postProcess</a></code> function.
This has not yet been implemented.</p>
</dd>
<dt><code>biasRemovalMethod = "LM"</code></dt><dd><p>character; specifies which methods to use to remove bias. See below.</p>
</dd>
<dt><code>doSegmentation = FALSE</code></dt><dd><p>Defining if the predictions should be subject to segmentation.
Segmentation has been implemented, but not the use of it.</p>
</dd>
<dt><code>testMean</code></dt><dd><p>logical; for copula method only; whether or not the predictive means 
(if calculated) should be tested for being reasonable</p>
</dd>
<dt><code>nmax = 50</code></dt><dd><p>for local kriging: the number of nearest observations that
should be used for a kriging prediction or simulation, where
nearest is defined in terms of the space of the spatial locations.
By default, 50 observations are used. </p>
</dd>
<dt><code>maxdist = Inf</code></dt><dd><p>for local kriging: Maximum distance to neighbouring locations to be used in kriging
or simulations</p>
</dd>
<dt><code>ngrid = 100</code></dt><dd><p>The number of grid points to be used if an Averaged Cumulative
Distribution Function (ACDF) needs to be computed for unbiased kriging</p>
</dd>
<dt><code>nsim=100</code></dt><dd><p>Number of simulations when needed</p>
</dd>
<dt><code>block = numeric(0)</code></dt><dd><p>Block size; a vector with 1, 2 or 3 values containing the size
of a rectangular in x-, y- and z-dimension respectively
(0 if not set), or a data frame with 1, 2 or 3 columns,
containing the points that discretize the block in the
x-, y- and z-dimension to define irregular blocks relative to
(0,0) or (0,0,0) - see also the details section of <code><a href="gstat.html#topic+predict.gstat">predict.gstat</a></code>.
By default, predictions or simulations refer to the support of the data values. </p>
</dd>
<dt><code>processType = "gaussian"</code> </dt><dd><p>If known - the distribution of the data. Defaults to gaussian,
analytical solutions also exists in some cases for logNormal.
This setting only affects a limited number of methods, e.g. the
block prediciton</p>
</dd>
<dt><code>confProj = FALSE</code></dt><dd><p>If set, the program will attempt conform projections in <code><a href="#topic+preProcess">preProcess</a></code>,
calling the function <code><a href="#topic+conformProjections">conformProjections</a></code>.</p>
</dd>
<dt><code>debug.level = 0</code></dt><dd><p>Used in some functions for giving additional output. See 
individual functions for more information. </p>
</dd>
<dt><code>nclus = 1</code></dt><dd><p>it is possible to use parallel processing for some interpolation methods
(currently only the copula method), nclus defines the number of processes to 
spawn. This requires previous installation of the <code>doParallel</code> package</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters that do not exist in the default parameter set,
this could be parameters necessary for new methods within or outside the 
<code><a href="#topic+intamap-package">intamap-package</a></code>
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

 
<p>A list of the parameters with class <code>intamapParams</code> to be included in the 
<code>object</code> described in <code><a href="#topic+intamap-package">intamap-package</a></code></p>


<h3>Note</h3>

<p>This function will mainly be called by <code><a href="#topic+createIntamapObject">createIntamapObject</a></code>, but 
can also be called by the user to create a parameter set or update an 
existing parameter set. If none of the arguments is a list of class
<code>IntamapParams</code>), the function will assume that the argument(s) are
modifications to the default set of parameters.
</p>
<p>If the function is called with two lists of parameters (but the first one is
not of class <code>IntamapParams</code>) they are both seen as modifications to the 
default parameter set. If they share some parameters, the parameter values from
the second list will be applied.
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createIntamapObject">createIntamapObject</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new set of intamapParameters, with default parameters:
params = getIntamapParams()
# Make modifications to the default list of parameters
params = getIntamapParams(newPar=list(removeBias = "local",
              secondParameter = "second"))
# Make modifications to an existing list of parameters
params = getIntamapParams(oldPar = params,newPar = list(predictType = list(exc=TRUE)))

</code></pre>

<hr>
<h2 id='getInterpolationMethodNames'> get interpolation method names </h2><span id='topic+getInterpolationMethodNames'></span>

<h3>Description</h3>

<p> get interpolation method names </p>


<h3>Usage</h3>

<pre><code class='language-R'> getInterpolationMethodNames() </code></pre>


<h3>Details</h3>

<p> none </p>


<h3>Value</h3>

 
<p>character array with names for available interpolation methods
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getInterpolationMethodNames()
</code></pre>

<hr>
<h2 id='intamap'>Example data for the intamap package</h2><span id='topic+observations'></span>

<h3>Description</h3>

<p>Salted (slightly modified) observations from the European gamma radiation network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(intamap)</code></pre>


<h3>Details</h3>

<p>The data set is a salted data set from the European gamma radiation network 
<a href="https://remap.jrc.ec.europa.eu/GammaDoseRates.aspx">https://remap.jrc.ec.europa.eu/GammaDoseRates.aspx</a>. 
Salted does in this context mean that all locations and observation values
have been randomized through addition of a random value.
</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>

<hr>
<h2 id='intamap-package'>A package providing methods for automatic interpolation:
pre-processing, parameter estimation, spatial prediction and post processing </h2><span id='topic+intamap-package'></span>

<h3>Description</h3>

<p>This package provides functionality for automatic interpolation of spatial data. 
The package was originally developed as the computational back-end of the intamap web service, but 
is now a stand-alone package as maintenance of the web service has ended. 
</p>


<h3> General setup </h3>

<p>The normal work flow for working with the <code>intamap</code> package can best be illustrated
with the following R-script. The procedure starts with reading data and meta data,
then setting up an object which is used in the following functions: preprocess data,
estimate parameters, compute spatial predictions, and post process them
(i.e., write them out):
</p>
<pre>
library(intamap)
library(sf)
# set up intamap object, either manually:
data(meuse)
coordinates(meuse) = ~x + y
data(meuse.grid)
gridded(meuse.grid) = ~x + y
obj = list(
        observations = meuse,
        predictionLocations = meuse.grid,
        targetCRS = "+init=epsg:3035",
        params = getIntamapParams()
)
class(obj) = c("idw")

# or using createIntamapObject
obj = createIntamapObject(
        observations = meuse,
        predictionLocations = meuse.grid,
        targetCRS = "+init=epsg:3035",class = c("idw")
)




# run test:
checkSetup(obj)

# do interpolation steps:
obj = preProcess(obj)
obj = estimateParameters(obj) # faster
obj = spatialPredict(obj)
obj = postProcess(obj)
</pre>
<p>Our idea is that a script following this setup will allow the full
statistical analysis required for the R back-end to the automatic
interpolation service, and provides the means to extend the current
(over-simplistic) code with the full-grown statistical analysis routines
developed by INTAMAP partners. Running the package independently under
R gives the user more flexibility in the utilization than what is possible 
through the web-interface.
</p>
<p>Let us look into detail what the code parts do:
</p>
<pre>
library(intamap)
</pre>
<p>The command <code>library(intamap)</code> loads the R code of the <code>intamap</code>
package to the current R session, along with the packages required for
this (sp, gstat, akima, automap, mvtnorm, evd, MASS). After the retirement
of rgdal, it is recommended to use sf-objects from the sf package.
All packages need to be available to the
R session, which is possible after downloading them from 
the Comprehensive R Network Archives (CRAN) (<a href="https://cran.r-project.org">https://cran.r-project.org</a>)
</p>
<pre>
# set up intamap object:
obj = createIntamapObject(
        observations = meuse,
        predictionLocations = meuse.grid,
        targetCRS = "+init=epsg:3051", 
        class = "idw"
)
</pre>
<p>This code sets up a list object called <code>obj</code>, and assigns a class
(or a group of classes) to it. This list should hold anything we need in the next steps, and the
bare minimum seems to be measured point data (which will be extended to 
polygon data) and prediction locations,
and a suggestion what to do with it. Here, the data are read from a
PostGIS data base running on localhost; data base connections over a
network are equally simple to set up. From the data base <code>postgis</code>
the tables <code>eurdep.data</code> and <code>inspire1km.grid</code> are read; it
is assumed that these have their SRID (spatial reference identifier) set.
</p>
<p>The suggestion what to do with these data is put in the classes,
<code>idw</code>. This will determine which <em>versions</em> of <code>preProcess</code>,
<code>parameterEstimate</code> etc will be used: <code>intamap</code> provides <em>methods</em>
for each of the <em>generic</em> functions 
<code>preProcess</code>, 
<code>estimateParameters</code>,
<code>spatialPredict</code>, 
<code>postProcess</code>.
Although it would be possible to apply two classes in this case (<code>dataType</code> in addition to <code>idw</code>), 
as the choice of pre- and post-processing steps 
tend to be data-dependent, we have tried to limit the number of classes to one for most applications.
</p>
<p>The S3 method mechanism (used here) hence requires these versions to
be called <code>preProcess.idw</code>, <code>estimateParameters.idw</code>,
<code>spatialPredict.idw</code>, and <code>postProcess.idw</code> (and eventually 
also <code>preProcess.eurdep</code> and <code>preProcess.eurdep</code>).
</p>
<p>To see that, we get in an interactive session:
</p>
<pre>
&gt; library(intamap)
Loading required package: sp
Loading required package: gstat
Geospatial Data Abstraction Library extensions to R successfully loaded
&gt; methods(estimateParameters)
[1] estimateParameters.automap*         estimateParameters.copula*         
[3] estimateParameters.default*         estimateParameters.idw*            
[5] estimateParameters.linearVariogram* estimateParameters.transGaussian*  
[7] estimateParameters.yamamoto*           
</pre>
<p>Now if a partner provides additional methods for BayesianKriging, one could integrate them by
</p>
<pre>
class(obj) = "BayesianKriging"
</pre>
<p>and provide some or all of the functions
<code>preProcess.BayesianKriging</code>,
<code>estimateParameters.BayesianKriging</code>,
<code>spatialPredict.BayesianKriging</code>, and
<code>postProcess.BayesianKriging</code>, which would be called automatically
when using their generic form (<code>preProcess</code> etc).  
</p>
<p>It is also possible to provide a method that calls another
method. Further, for each generic there is a default method. For
<code>estimateParameter</code> and <code>spatialPredict</code> these print an
error message and stop, for the pre- and postprocessing the default
methods may be the only thing needed for the full procedure; if no
<code>preProcess.BayesianKriging</code> is found, <code>preProcess.default</code>
will be used when the generic (<code>preProcess</code>) is called.
</p>
<p>If a method does something, then it adds its result to the object it
received, and returns this object. If it doesn't do anything, then it
just passes (returns) the object it received.
</p>
<p>To make these different methods exchangable, it is needed that they can
all make the same assumptions about the contents of the object that they
receive when called, and that what they return complies with what the
consequent procedures expect. The details about that are given in the
descriptions of the respective methods, below.
</p>
<p>Because a specific interpolation method implemented may have its peculiar
characteristics, it may have to extend these prescriptions by passing
more information than described below, for example information about
priors from <code>estimateParameters</code> to <code>spatialPredict</code>.
</p>
<p>The choice between methods is usually done based on the type of problem
(extreme values present, computation time available etc.). The possibility
for parallel processing of the prediction step is enabled for some of the main methods.
To be able to take advantage of multiple CPUs on a computer, the package
<code>doParallel</code> must be installed, additionally the parameter nclus must be set to
a value larger than 1.
</p>


<h3>Input object components</h3>


<dl>
<dt><code>observations</code></dt><dd><p> object of class 
<code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code>, containing
a field <code>value</code> that is the target variable.</p>
</dd>
<dt><code>predictionLocations</code></dt><dd><p> object extending class <code><a href="sp.html#topic+Spatial-class">Spatial</a></code>, containing
prediction locations.</p>
</dd>
<dt><code>targetCRS</code></dt><dd><p> character; target CRS or missing</p>
</dd>
<dt><code>formulaString</code></dt><dd><p>formula string for parameter estimation and prediction functions</p>
</dd>  
<dt><code>params</code></dt><dd><p><code>list</code> of parameters, to be set in <code><a href="#topic+getIntamapParams">getIntamapParams</a></code>. These parameters include: </p>
</dd>
</dl>

<dl>
<dt>doAnisotropy = FALSE</dt><dd><p>Defining whether anisotropy should be calculated</p>
</dd>
<dt>removeBias = NA</dt><dd><p>Defining whether biases should be removed, and in case yes, which ones
(<code>localBias</code> and <code>regionalBias</code> implemented</p>
</dd>
<dt>addBias = NA</dt><dd><p>Defining which biases to be added in the <code><a href="#topic+postProcess">postProcess</a></code> function.
This has not yet been implemented.</p>
</dd>
<dt>biasRemovalMethod = <code>"LM"</code></dt><dd><p>character; specifies which methods to use to remove bias. See below.</p>
</dd>
<dt>doSegmentation = FALSE</dt><dd><p>Defining if the predictions should be subject to segmentation.
Segmentation has been implemented, but not the use of it.</p>
</dd>
<dt>nmax = 50</dt><dd><p>for local kriging: the number of nearest observations that
should be used for a kriging prediction or simulation, where
nearest is defined in terms of the space of the spatial locations.
By default, 50 observations are used. </p>
</dd>
<dt>ngrid = 100</dt><dd><p>The number of grid points to be used if an Averaged Cumulative
Distribution Function (ACDF) needs to be computed for unbiased kriging</p>
</dd>
<dt>nsim=100</dt><dd><p>Number of simulations when needed</p>
</dd>
<dt>block = numeric(0)</dt><dd><p>Block size; a vector with 1, 2 or 3 values containing the size
of a rectangular in x-, y- and z-dimension respectively
(0 if not set), or a data frame with 1, 2 or 3 columns,
containing the points that discretize the block in the
x-, y- and z-dimension to define irregular blocks relative to
(0,0) or (0,0,0) - see also the details section of <code><a href="gstat.html#topic+predict.gstat">predict.gstat</a></code>.
By default, predictions or simulations refer to the support of the data values. </p>
</dd>
<dt>processType = <code>"gaussian"</code> </dt><dd><p>If known - the distribution of the data. Defaults to gaussian,
analytical solutions also exists in some cases for logNormal.
This setting only affects a limited number of methods, e.g. the
block prediciton</p>
</dd>
<dt>confProj = FALSE</dt><dd><p>If set, the program will attempt conform projections in <code><a href="#topic+preProcess">preProcess</a></code>,
calling the function <code><a href="#topic+conformProjections">conformProjections</a></code>.</p>
</dd>
<dt>nclus = 1</dt><dd><p>The number of clusters to use, if applying to a method which can 
run processes in parallel. Currently implemented for methods <code>automap</code>,
<code>copula</code> and <code>psgp</code>.</p>
</dd>
<dt>debug.level = 0</dt><dd><p>Used in some functions for giving additional output. See 
individual functions for more information. </p>
</dd>
<dt>...</dt><dd><p>Additional parameters that do not exist in the default parameter set,
particularly parameters necessary for new methods within the <code>intamap</code>
package</p>
</dd>
</dl>




<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>

<hr>
<h2 id='intamapExampleObject'>Simulated Intamap Object</h2><span id='topic+intamapExampleObject'></span>

<h3>Description</h3>

<p>Intamap object of class &quot;copula&quot; containing a simulated data set with 196 spatial locations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(intamapExampleObject)</code></pre>


<h3>Details</h3>

<p>The data set is 
a realization of a random field generated using a Gaussian copula and generalized extreme value distributed margins (location=40,shape=0.5, scale=30). The correlation function is Matern (Stein's representation) with range=4, kappa=3 and nugget=0.05.
Furthermore, there is geometric anisotropy with direction=pi/3 and ratio=2. 
</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spatialPredict.copula">spatialPredict.copula</a></code>, <code><a href="#topic+estimateParameters.copula">estimateParameters.copula</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(intamapExampleObject)
## estimate parameters for the copula model
intamapExampleObject&lt;-estimateParameters(intamapExampleObject)
## make predictions at unobserved locations
intamapExampleObject&lt;-spatialCopula(intamapExampleObject)

## End(Not run)
</code></pre>

<hr>
<h2 id='interpolate'> spatial interpolation </h2><span id='topic+interpolate'></span><span id='topic+interpolateBlock'></span>

<h3>Description</h3>

<p><code>interpolate</code> is a function that interpolates spatial data </p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate(observations, predictionLocations, 
            outputWhat = list(mean = TRUE, variance = TRUE), 
            obsChar = NA, methodName = "automatic", maximumTime = 30, 
            optList = list(), cv = FALSE, ...)
interpolateBlock(observations, predictionLocations, outputWhat, 
            blockWhat = "none", obsChar = NA, methodName = "automatic", 
            maximumTime = 30, 
            optList = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_+3A_observations">observations</code></td>
<td>
<p>observation data, object of class <code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code>. 
The observation to be interpolated has to be identified through the 
column name <code>value</code></p>
</td></tr>
<tr><td><code id="interpolate_+3A_predictionlocations">predictionLocations</code></td>
<td>
<p> prediction locations, object of class <code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code>*, <code><a href="sp.html#topic+SpatialPixels">SpatialPixels</a></code>* or <code><a href="sp.html#topic+SpatialGrid">SpatialGrid</a></code>*, or the number of predictionLocations to be sampled from the boundaries of the observations</p>
</td></tr>
<tr><td><code id="interpolate_+3A_outputwhat">outputWhat</code></td>
<td>
<p> list with names what kind of output is expected, e.g.
<code>outputWhat = list(mean=TRUE,variance=TRUE, nsim = 5)</code></p>
</td></tr>
<tr><td><code id="interpolate_+3A_blockwhat">blockWhat</code></td>
<td>
<p>List defining particular output for block predictions. See <code><a href="#topic+createIntamapObject">createIntamapObject</a></code></p>
</td></tr>
<tr><td><code id="interpolate_+3A_obschar">obsChar</code></td>
<td>
<p>list with observation characteristics, used by some interpolation methods</p>
</td></tr>
<tr><td><code id="interpolate_+3A_methodname">methodName</code></td>
<td>
<p>name of interpolation method to be used, see <a href="#topic+spatialPredict">spatialPredict</a> for more details, or <code>automatic</code>, to let
the method be decided by the program, based on maximumTime and type of variables input</p>
</td></tr>
<tr><td><code id="interpolate_+3A_maximumtime">maximumTime</code></td>
<td>
<p>the maximum time available for interpolation, will be compared to the result of <code><a href="#topic+predictTime">predictTime</a></code> 
for the requested method, or for finding the best interpolation method
able to finish within this time</p>
</td></tr>
<tr><td><code id="interpolate_+3A_optlist">optList</code></td>
<td>
<p>list; further options, mainly passed to <code><a href="#topic+createIntamapObject">createIntamapObject</a></code>
as the argument <code>params</code>, directly as arguments, but some are used
locally in <code>interpolate</code> and <code>interpolateBlock</code>:
</p>

<dl>
<dt>formulaString</dt><dd><p>passed as argument to <code><a href="#topic+createIntamapObject">createIntamapObject</a></code>,
if no formulaString is given, it will default to
<code>value~1</code> if <code>observations</code> has a column named
<code>value</code> or to <code>col1 ~ 1</code> where <code>col1</code>
is the first column of the observations </p>
</dd>
<dt>set.seed</dt><dd><p>the possibility to pass a seed value to 
<code>interpolate</code>, to assure reproducible results also
for methods relying on random numbers</p>
</dd>
<dt>methodParameters</dt><dd><p>methodParameters from an earlier run, see also <code><a href="#topic+methodParameters">methodParameters</a></code></p>
</dd>
<dt>model</dt><dd><p>defining which variogram model(s) to fit when <code>methodName = "automap"</code></p>
</dd>
</dl>
                  
</td></tr>
<tr><td><code id="interpolate_+3A_cv">cv</code></td>
<td>
<p>If cross-validation should be done</p>
</td></tr>
<tr><td><code id="interpolate_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>interpolate</code> and <code>interpolateBlock</code>  are particularly implemented for being called by 
a Web Processing Server (WPS), but they can also be used interactively. The only necessary 
arguments are <code>observations</code> and <code>predictionLocations</code>. It is also recommended
to set <code>outputWhat</code>, and <code>blockWhat</code> if necessary. If <code>outputWhat</code>
contains <code>nsim</code>, the return table will also contain a number of realisations,
for methods able to return simulations. 

</p>
<p><code>interpolate</code> can use different interpolation methods for the result. The function
will internally call the following functions which can be method specific.
</p>

<ul>
<li> <p><code><a href="#topic+preProcess">preProcess</a></code>
</p>
</li>
<li> <p><code><a href="#topic+estimateParameters">estimateParameters</a></code>
</p>
</li>
<li> <p><code><a href="#topic+spatialPredict">spatialPredict</a></code>
</p>
</li>
<li> <p><code><a href="#topic+postProcess">postProcess</a></code>
</p>
</li></ul>

<p>An indication of available methods can be given by <code>methods(estimateParameters)</code>
or <code>methods(spatialPredict)</code>.
The method can be set through the argument <code>methodName</code>, or through the 
built-in automatic selection method. There are different criteria that helps 
in selecting the right method for a particular data set. There are four 
methods that are available for the automatic choice:
<code>automap</code>, <code>psgp</code> (from the separate package <code>psgp</code>) 
<code>copula</code> and <code>transgaussian</code> are the possibilities. 
First of all, if observation errors are present, the <code>psgp</code> method is preferred. 
If not, it is checked whether the data appear to deviate significantly from normality. 
This is assumed to be the case if any of the tests below are TRUE:
</p>
<pre>
      test[1] = length(boxplot.stats(dataObs)$out)/length(dataObs) &gt; 0.1
      test[2] = fivenum(dataObs)[3] - fivenum(dataObs)[2] &lt; IQR(dataObs)/3
      test[3] = fivenum(dataObs)[4] - fivenum(dataObs)[3] &lt; IQR(dataObs)/3
      g = boxcox(dataObs ~ 1,lambda=seq(-2.5,2.5,len=101),plotit=FALSE)$y
      test[4] = g[71] &lt; sort(g)[91]
</pre>
<p>where <code><a href="stats.html#topic+fivenum">fivenum</a></code> defines the Tukey five number statistic and 
<code><a href="stats.html#topic+IQR">IQR</a></code> finds the interquartile range of the data. If the minimum of 
dataObs is &lt;= 0, min(dataObs) + sdev(dataObs) is added to all values.
At last, the function calls <code><a href="#topic+predictTime">predictTime</a></code> for an estimate of the 
prediction time. If any of the tests above were true and the estimated prediction time
for <code>copula</code> prediction is below <code>maximumTime</code>, the <code>copula</code>
method is chosen. If any of the
tests were TRUE and the estimated prediction time is too long, <code>transGaussian</code> 
kriging is chosen, as long as all values are above zero. If any of 
the tests are true for a set of observations with negative or zero-values, 
<code>automap</code> is chosen, but a warning is issued.
</p>
<p>The element <code>methodParameters</code> in the object being returned is a string that makes it possible
to regenerate the variogram model or the copula parameters in <code><a href="#topic+createIntamapObject">createIntamapObject</a></code>.
This is particularly useful when the function is called through a WPS, when
the element with the estimated parameters cannot be preserved in a state 
that makes it possible to use them for a later call to <code>interpolate</code>.
</p>
<p>The possibility
for doing parallel processing is enabled for some of the main methods.
To be able to take advantage of multiple CPUs on a computer, the package
<code>doParallel</code> must be downloaded, additionally the parameter nclus must be set to
a value larger than 1. Parallel computation is not taken into account when 
estimating the prediction times.
</p>


<h3>Value</h3>

 
<p>An intamap object, which is a list with elements, see <code><a href="#topic+intamap-package">intamap-package</a></code>. 
The exact number and names of these elements might vary due to different methods applied,
but the list below shows the most typical:
</p>
<table>
<tr><td><code>observations</code></td>
<td>
<p>the observations, as a <code>Spatial*DataFrame</code></p>
</td></tr>
<tr><td><code>predictionLocations</code></td>
<td>
<p>the prediction locations, as a <code><a href="sp.html#topic+Spatial-class">Spatial</a></code>-object</p>
</td></tr>
<tr><td><code>formulaString</code></td>
<td>
<p>the relationship between independent and dependent variables, 
<code>value</code> or <code>obs</code> used if not given</p>
</td></tr>
<tr><td><code>outputWhat</code></td>
<td>
<p>a list of the prediction types to return</p>
</td></tr>
<tr><td><code>anisPar</code></td>
<td>
<p>the estimated anisotropy parameters</p>
</td></tr>
<tr><td><code>variogramModel</code></td>
<td>
<p>the estimated parameter for the method, can also be e.g. <code>copulaParams</code>
for the copula method or <code>inverseDistancePower</code> for inverse distance power method.</p>
</td></tr>
<tr><td><code>methodParameters</code></td>
<td>
<p>a string, that when parsed, can be used to regenerate
the variogram model or copula parameters. Useful for repeated calls to interpolate
when it is not necessary to reestimate the parameters.</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>a <code>Spatial*DataFrame</code> with predictions, for most 
methods with a format equal to the output from <code><a href="gstat.html#topic+krige">krige</a></code> with 
predicted mean and variance as <code>var1.pred</code> and <code>var1.var</code></p>
</td></tr>
<tr><td><code>outputTable</code></td>
<td>
<p>a matrix, organized in a convenient way for the calling WPS;
first row: x-coordinates,  second row: y-coordinates; further rows: 
output elements as specified by <code>outputWhat</code></p>
</td></tr>
<tr><td><code>processDescription</code></td>
<td>
<p>some textual descriptions of the interpolation
process, including warnings</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createIntamapObject">createIntamapObject</a></code>, <code><a href="#topic+estimateParameters">estimateParameters</a></code>, 
<code><a href="#topic+spatialPredict">spatialPredict</a></code>, <code><a href="#topic+intamap-package">intamap-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(meuse)
coordinates(meuse) = ~x+y
meuse$value = meuse$zinc
data(meuse.grid)
gridded(meuse.grid) = ~x+y
x = interpolate(meuse, meuse.grid, list(mean=TRUE, variance=TRUE))
summary(t(x$outputTable))
</code></pre>

<hr>
<h2 id='methodParameters'> generate string for generation of method parameters </h2><span id='topic+methodParameters'></span><span id='topic+methodParameters.default'></span><span id='topic+methodParameters.copula'></span><span id='topic+methodParameters.idw'></span>

<h3>Description</h3>

<p>function that generates a parsable string of identified method parameters 
for an intamap interpolation object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
methodParameters(object)
## S3 method for class 'copula'
methodParameters(object)
## S3 method for class 'idw'
methodParameters(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methodParameters_+3A_object">object</code></td>
<td>
<p>  a list object. Most arguments necessary for interpolation
are passed through this object. See <code><a href="#topic+intamap-package">intamap-package</a></code> for further 
description of the necessary content of this variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a text-string that makes it possible to add the 
the method parameters (anisotropy and idw-parameter, variogram model or 
copula parameters) to the <code>object</code> in a later call to 
<code><a href="#topic+createIntamapObject">createIntamapObject</a></code> or <code><a href="#topic+interpolate">interpolate</a></code> 
without having to re-estimate the parameters.
This function is particularly useful when <code><a href="#topic+interpolate">interpolate</a></code> is
called from a Web Processing Service, and the user wants to reuse the 
method parameters. The function is mainly assumed to be called from 
within <code><a href="#topic+interpolate">interpolate</a></code>.
</p>
<p>The default method assumes a variogram model of <em>gstat</em> type, e.g. a variogram
similar to what can be created with a call to <code><a href="gstat.html#topic+vgm">vgm</a></code>.
Also <em>psgp</em> uses this variogram model.
</p>


<h3>Value</h3>

<p>A string that, when parsed, will recreate the methodParameters
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sessionInfo()
data(meuse)
coordinates(meuse) = ~x+y
meuse$value = log(meuse$zinc)
# set up intamap object:
krigingObject = createIntamapObject(
		observations = meuse,
		formulaString = as.formula('value~1'),class = "automap")
# do estimation steps:
krigingObject = estimateParameters(krigingObject)
krigingObject = methodParameters(krigingObject)

# Create a new object
krigingObject2 = createIntamapObject(observations = meuse,
		formulaString = as.formula('value~1'),
    params = list(methodParameters = krigingObject$methodParameters))

krigingObject$variogramModel
krigingObject2$variogramModel

</code></pre>

<hr>
<h2 id='plotIntamap'> plot intamap objects</h2><span id='topic+plotIntamap'></span><span id='topic+plot.default'></span><span id='topic+plot.copula'></span><span id='topic+plot.idw'></span><span id='topic+plot.automap'></span><span id='topic+plot.linearVariogram'></span><span id='topic+plot.transGaussian'></span><span id='topic+plot.yamamoto'></span>

<h3>Description</h3>

<p>Plotting function for <code>intamap</code>-objects of the type described in 
<code><a href="#topic+intamap-package">intamap-package</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotIntamap(object, zcol = "all", sp.layout = NULL, plotMat = c(2,2), ...)
## S3 method for class 'copula'
plot(x,  ...)
## S3 method for class 'idw'
plot(x, ...)
## S3 method for class 'automap'
plot(x, ...)

## S3 method for class 'linearVariogram'
plot(x, ...)
## S3 method for class 'transGaussian'
plot(x, ...)
## S3 method for class 'yamamoto'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotIntamap_+3A_object">object</code></td>
<td>
<p>  a list object. Most arguments necessary for interpolation
are passed through this object. See <code><a href="#topic+intamap-package">intamap-package</a></code> for further 
description of the necessary content of this variable</p>
</td></tr>
<tr><td><code id="plotIntamap_+3A_x">x</code></td>
<td>
<p>intamap object, when plot is called directly</p>
</td></tr>
<tr><td><code id="plotIntamap_+3A_zcol">zcol</code></td>
<td>
<p>a list of column names to be plotted; if equal to all, the column names
will correspond to all possible column names from <code>outputWhat</code>
(see <code><a href="#topic+createIntamapObject">createIntamapObject</a></code>) </p>
</td></tr>
<tr><td><code id="plotIntamap_+3A_sp.layout">sp.layout</code></td>
<td>
<p>an object that can contain lines, points and polygons that function as extra layout;
see <code><a href="sp.html#topic+spplot">spplot</a></code> for more information</p>
</td></tr>
<tr><td><code id="plotIntamap_+3A_plotmat">plotMat</code></td>
<td>
<p>an array of lengt two with the number of rows and columns of plots per page</p>
</td></tr>
<tr><td><code id="plotIntamap_+3A_...">...</code></td>
<td>
<p> other parameters that can be passed to other plot functions (e.g. 
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="sp.html#topic+spplot">spplot</a></code>, <code><a href="automap.html#topic+automapPlot">automapPlot</a></code>
and <code><a href="lattice.html#topic+xyplot">xyplot</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the plot methods above are simple wrapper functions around the plotIntamap function.
</p>


<h3>Value</h3>

 
<p>A plot of some of the elements of <code>object</code>. This will typically be the 
sample variogram and the fitted variogram model (if a method based on variograms 
has been used) and all the predictions. 
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
meuse$value = log(meuse$zinc)
data(meuse.grid)
coordinates(meuse) = ~x+y
coordinates(meuse.grid) = ~x+y
object = interpolate(meuse, meuse.grid, 
                     outputWhat = list(mean = TRUE, variance = TRUE, 
                     excprob = 7, excprob = 8, quantile = 0.9, quantile = 0.95),
                     methodName = "automap")
plot(object)
</code></pre>

<hr>
<h2 id='postProcess'> pre-process data</h2><span id='topic+postProcess'></span><span id='topic+postProcess.default'></span><span id='topic+postProcess.idw'></span>

<h3>Description</h3>

<p>post-processing of data for the <code><a href="#topic+intamap-package">intamap-package</a></code>. The function will typically call
other functions for adding back biases, aggregation etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
postProcess(object, ...)
## S3 method for class 'idw'
postProcess(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postProcess_+3A_object">object</code></td>
<td>
<p>  a list object. Most arguments necessary for interpolation
are passed through this object. See <code><a href="#topic+intamap-package">intamap-package</a></code> for further 
description of the necessary content of this variable</p>
</td></tr>
<tr><td><code id="postProcess_+3A_...">...</code></td>
<td>
<p> other parameters that can be passed to functions called from <code>preProcess</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>postProcess</code> includes code for postprocessing an object after interpolation. 
The function can easily be replaced by more specific methods relevant for a 
certain data set, doing more data specific things in addition to what is done in the default method.
</p>


<h3>Value</h3>

 
<p>An object of same type as above, but with new elements. Most important from the default
method is the <code>outputTable</code>, a matrix, organized in a convenient way for the calling WPS;
first row: x-coordinates,  second row: y-coordinates; further rows: 
output elements as specified by <code>outputWhat</code> (see <code><a href="#topic+createIntamapObject">createIntamapObject</a></code>
</p>


<h3>Author(s)</h3>

<p> Edzer J. Pebesma </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>

<hr>
<h2 id='predictTime'>Time prediction for intamap package methods</h2><span id='topic+predictTime'></span>

<h3>Description</h3>

<p>Functions that gives a time estimate for an intamap function given the 
number of observations and predictionLocations</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictTime(nObs, nPred, class, formulaString, calibration=FALSE, 
                   outputWhat, FUN = "spatialPredict",...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictTime_+3A_nobs">nObs</code></td>
<td>
<p>An integer or an array of integers containing the number of observations.</p>
</td></tr>
<tr><td><code id="predictTime_+3A_npred">nPred</code></td>
<td>
<p>An integer or an array of integers containing the number of predictions.</p>
</td></tr>
<tr><td><code id="predictTime_+3A_class">class</code></td>
<td>
<p>class of intamapObject, which interpolation method to be used</p>
</td></tr>
<tr><td><code id="predictTime_+3A_formulastring">formulaString</code></td>
<td>
<p>the formula of the request, mainly to see if the request has independent variables</p>
</td></tr>
<tr><td><code id="predictTime_+3A_calibration">calibration</code></td>
<td>
<p>enables or disables time calibration - not properly implemented yet</p>
</td></tr>
<tr><td><code id="predictTime_+3A_outputwhat">outputWhat</code></td>
<td>
<p>List defining the requested type of output, see 
<code><a href="#topic+createIntamapObject">createIntamapObject</a></code> </p>
</td></tr>
<tr><td><code id="predictTime_+3A_fun">FUN</code></td>
<td>
<p>A string with the intamap functions name, now obsolete</p>
</td></tr>
<tr><td><code id="predictTime_+3A_...">...</code></td>
<td>
<p>other arguments needed to define the intamap object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on <code>timeModels</code> being available in the workspace. 
This is a <code><a href="stats.html#topic+loess">loess</a></code>-model that has been fitted to different calls to a range of 
interpolation requests with synthetically generated data in
<code><a href="#topic+generateTimeModels">generateTimeModels</a></code>. </p>


<h3>Value</h3>

<p>An integer or an array of integers with the predicted times.</p>


<h3>Note</h3>

<p>RUN FIRST generateTimeModels() or estimateTimeModel() in order to save time Models to workspace. It might take some time!</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>

<hr>
<h2 id='preProcess'> pre-processing of data</h2><span id='topic+preProcess'></span><span id='topic+preProcess.default'></span><span id='topic+preProcess.idw'></span>

<h3>Description</h3>

<p> pre-processing of the data for the <code><a href="#topic+intamap-package">intamap-package</a></code> package. 
</p>





<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
preProcess(object, ...)
## S3 method for class 'idw'
preProcess(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcess_+3A_object">object</code></td>
<td>
<p> see <code><a href="#topic+intamap-package">intamap-package</a></code>; list that should at
least contain (i) an element called <code>observations</code> of class
<code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code>. The measured values should be named
<code>value</code>, and (ii) an element <code>params</code> of class <code>list</code>, by calling the
function <code><a href="#topic+getIntamapParams">getIntamapParams</a></code>. (iii) Usually, the object will also
contain an element called <code>predictionLocations</code>,
of a class extending <code><a href="sp.html#topic+Spatial-class">Spatial</a></code>. 
</p>
</td></tr>
<tr><td><code id="preProcess_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>





</table>


<h3>Details</h3>

<p>The function <code>preProcess</code> includes code for preprocessing an object before interpolation. 
The function can easily be replaced by more specific methods relevant for a 
certain data set. Functions can be called from <code>preProcess</code> according to the settings in parameters
in the <code>object</code>, set by the function <code><a href="#topic+getIntamapParams">getIntamapParams</a></code>. 



</p>


<h3>Value</h3>

 
<p>The input object is returned, after its components have been pre-processed.
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>

<hr>
<h2 id='rotateAnisotropicData'>rotateAnisotropicData</h2><span id='topic+rotateAnisotropicData'></span>

<h3>Description</h3>

<p>This function applies an isotropic transformation of
the coordinates specified in <code>object</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotateAnisotropicData(object,anisPar)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotateAnisotropicData_+3A_object">object</code></td>
<td>
<p>   (i) An Intamap type  object (see <code><a href="#topic+intamap-package">intamap-package</a></code>) 
containing one <code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code>
data frame named  <code>observations</code> which includes the observed values (ii) or a 
<code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code>
which includes both coordinates and observations or (iii) <code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code> which includes only
coordinates to be rotated.</p>
</td></tr>
<tr><td><code id="rotateAnisotropicData_+3A_anispar">anisPar</code></td>
<td>
<p>An array containing the anisotropy parameters (anisotropy ratio and axes orientation)
(see <code><a href="#topic+estimateAnisotropy">estimateAnisotropy</a></code>) for the rotation.
If <code>object</code> is the output of <code><a href="#topic+estimateAnisotropy">estimateAnisotropy</a></code> function, these parameters are part of <code>object</code>.
In cases (ii) and (iii) <code>anisPar</code> defines the two anisotropy
parameters. For the definition of the anisotropy parameters see <code><a href="#topic+estimateAnisotropy">estimateAnisotropy</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a rotation and rescaling of the
coordinate axes in order to obtain a new coordinate system, in which
the observations become statistically isotropic. This assumes that
the estimates of the anisotropy ratio and the orientation angle
provided in <code>anisPar</code> are accurate.
</p>


<h3>Value</h3>

<p>(i) A modified object with transformed coordinates if 
rotateAnisotropicData is called with an Intamap object as input (see
<code><a href="#topic+intamap-package">intamap-package</a></code>) or (ii) the transformed coordinates if a
<code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code> is used as input or (iii)
the transformed coordinates if a <code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code>
object is the input. </p>


<h3>Author(s)</h3>

<p> Hristopulos Dionisis, Spiliopoulos Giannis
</p>


<h3>References</h3>

<p>[1] Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>
<p>[2] A. Chorti and D. T. Hristopulos (2008). Non-parametric Identification of Anisotropic (Elliptic) 
Correlations in Spatially Distributed Data Sets, IEEE Transactions on Signal Processing, 56(10), 4738-4751 (2008).</p>


<h3>See Also</h3>

<p><code>estimateAnisotropy</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
    library(gstat)
    data(sic2004)
    coordinates(sic.val)=~x+y
    sic.val$value=sic.val$dayx

    anisPar &lt;- estimateAnisotropy(sic.val)
    print(anisPar)  

    rotatedObs &lt;- rotateAnisotropicData(sic.val,anisPar)

    newAnisPar &lt;- estimateAnisotropy(rotatedObs)
    print(newAnisPar)  


</code></pre>

<hr>
<h2 id='spatialPredict'> Spatial prediction</h2><span id='topic+spatialPredict'></span><span id='topic+spatialPredict.automap'></span><span id='topic+spatialPredict.copula'></span><span id='topic+spatialPredict.default'></span><span id='topic+spatialPredict.idw'></span><span id='topic+spatialPredict.linearVariogram'></span><span id='topic+spatialPredict.transGaussian'></span><span id='topic+spatialPredict.yamamoto'></span>

<h3>Description</h3>

<p><code>spatialPredict</code> is a generic method for spatial predictions 
within the <code><a href="#topic+intamap-package">intamap-package</a></code>.
A series of methods have been implemented, 
partly based on other R-packages (as <code><a href="gstat.html#topic+krige">krige</a></code>),
other methods have been developed particularly for the INTAMAP project. The object 
has to include a range of variables, further described in 
<code><a href="#topic+intamap-package">intamap-package</a></code>. The prediction method is 
chosen based on the class of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'automap'
spatialPredict(object, nsim = 0, ...)
## S3 method for class 'copula'
spatialPredict(object, ...)
## Default S3 method:
spatialPredict(object, ...)
## S3 method for class 'idw'
spatialPredict(object, ...)
## S3 method for class 'linearVariogram'
spatialPredict(object, nsim = 0, ...)

## S3 method for class 'transGaussian'
spatialPredict(object, nsim = 0, ...)
## S3 method for class 'yamamoto'
spatialPredict(object, nsim = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialPredict_+3A_object">object</code></td>
<td>
<p> a list object. Most arguments necessary for interpolation
are passed through this object. See <code><a href="#topic+intamap-package">intamap-package</a></code> for further 
description of the necessary content of this variable</p>
</td></tr>
<tr><td><code id="spatialPredict_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to return, for methods able to return simulations</p>
</td></tr>
<tr><td><code id="spatialPredict_+3A_...">...</code></td>
<td>
<p> other arguments that will be passed to the requested interpolation method. 
See the individual interpolation methods for more information. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>spatialPredict</code> is a wrapper around different
spatial interpolation methods found within the <code><a href="#topic+intamap-package">intamap-package</a></code> or within other packages
in <code>R</code>. It is for most of the
methods necessary to have parameters of the correlation structure
included in <code>object</code> to be able to carry out the spatial prediction.
Below are some details 
about particular interpolation methods
</p>

<dl>
<dt><code>default</code></dt><dd><p>a default method is not really implemented, this function is only 
created to give a sensible error message if the function is called
with an object for which no method exist</p>
</dd>
<dt><code>automap</code></dt><dd><p>If the object already has an element <code>variogramModel</code> with
variogram parameters,
<code><a href="gstat.html#topic+krige">krige</a></code> is called. If the this is not a part of the object,
<code><a href="#topic+estimateParameters">estimateParameters</a></code> is called to create this element.</p>
</dd>
<dt><code>copula</code></dt><dd><p>spatial prediction using <code><a href="#topic+bayesCopula">bayesCopula</a></code></p>
</dd>
<dt><code>idw</code></dt><dd><p>applies inverse distance modelling with the idp-power found by <code>estimateParameters.idw</code></p>
</dd>
<dt><code>linearVariogram</code></dt><dd><p>this function estimates the process using an unfitted linear variogram; although variance is returned it can not be relied upon</p>
</dd>

<dt><code>transGaussian</code></dt><dd><p>spatial prediction using <code><a href="gstat.html#topic+krigeTg">krigeTg</a></code></p>
</dd>
<dt><code>yamamoto</code></dt><dd><p>spatial prediction using <code><a href="#topic+yamamotoKrige">yamamotoKrige</a></code></p>
</dd>
</dl>
<p>It is also possible to add to the above methods with functionality from
other packages, if wanted. 
You can also check which methods are available from other packages by calling 
</p>
<pre>
&gt;methods(spatialPredict)
</pre>



<h3>Value</h3>

 
<p>a list object similar to <code>object</code>, but extended with predictions at
a the set of locations defined <code>object</code>.
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>See Also</h3>

<p><code><a href="gstat.html#topic+gstat">gstat</a></code>,<code><a href="automap.html#topic+autoKrige">autoKrige</a></code>, 
<code><a href="#topic+createIntamapObject">createIntamapObject</a></code>, <code><a href="#topic+estimateParameters">estimateParameters</a></code>, 
<code><a href="#topic+intamap-package">intamap-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example skips some steps that might be necessary for more complicated
# tasks, such as estimateParameters and pre- and postProcessing of the data
data(meuse)
coordinates(meuse) = ~x+y
meuse$value = log(meuse$zinc)
data(meuse.grid)
gridded(meuse.grid) = ~x+y
proj4string(meuse) = CRS("+init=epsg:28992")
proj4string(meuse.grid) = CRS("+init=epsg:28992")

# set up intamap object:
obj = createIntamapObject(
	observations = meuse,
	predictionLocations = meuse.grid,
	targetCRS = "+init=epsg:3035",
	params = getIntamapParams(),
	class = "linearVariogram"
)

# do interpolation step:
obj = spatialPredict(obj)  # spatialPredict.linearVariogram
</code></pre>

<hr>
<h2 id='summaryIntamap'> summary intamap objects</h2><span id='topic+summaryIntamap'></span><span id='topic+summary.copula'></span><span id='topic+summary.idw'></span><span id='topic+summary.automap'></span><span id='topic+summary.transGaussian'></span><span id='topic+summary.linearVariogram'></span><span id='topic+summary.yamamoto'></span>

<h3>Description</h3>

<p>summary function for <code>intamap</code>-objects of the type described in 
<code><a href="#topic+intamap-package">intamap-package</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryIntamap(object, ...)
## S3 method for class 'copula'
summary(object, ...)
## S3 method for class 'idw'
summary(object, ...)
## S3 method for class 'automap'
summary(object, ...)

## S3 method for class 'linearVariogram'
summary(object, ...)
## S3 method for class 'transGaussian'
summary(object, ...)
## S3 method for class 'yamamoto'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryIntamap_+3A_object">object</code></td>
<td>
<p>  a list object. Most arguments necessary for interpolation
are passed through this object. See <code><a href="#topic+intamap-package">intamap-package</a></code> for further 
description of the necessary content of this variable</p>
</td></tr>
<tr><td><code id="summaryIntamap_+3A_...">...</code></td>
<td>
<p>parameters to be passed to the default summary function for each element</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>A summary of some of the elements of <code>object</code>. 
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien </p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>

<hr>
<h2 id='timeModels'>models for estimating prediction time in intamap package</h2><span id='topic+timeModels'></span>

<h3>Description</h3>

<p>This is a standard model for estimating the prediction time within the 
<code><a href="#topic+intamap-package">intamap-package</a></code>. It was created by the function
<code><a href="#topic+generateTimeModels">generateTimeModels</a></code>, on a 64 bits Linux server running 
<code>R</code> version 2.9.0 and <code><a href="#topic+intamap-package">intamap-package</a></code> version 1.1.15. 
</p>
<p>The prediction time will depend on the speed of the local machine, on the version
of <code>R</code> and <code><a href="#topic+intamap-package">intamap-package</a></code>, and on the installed libraries. 
It is therefore strongly recommended to run <code><a href="#topic+generateTimeModels">generateTimeModels</a></code> on the local
machine and store the result in the workspace if the predicted interpolation 
time is of real interest. <code>timeModels</code> in the workspace will be chosen if available.
</p>
<p>It is not necessary to load the data set, this happens automatically in predictTime
if <code>timeModels</code> if the object is not already existing in the workspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(timeModels)
</code></pre>


<h3>Author(s)</h3>

<p>Jon Olav Skoien</p>


<h3>References</h3>

 
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>

<hr>
<h2 id='unbiasedKrige'> Unbiased kriging</h2><span id='topic+unbiasedKrige'></span>

<h3>Description</h3>

<p><code>unbiasedKrige</code> is a function for modifying a kriging prediction
to a prediction that can be assumed to be unbiased for a certain threshold.</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbiasedKrige(object, formulaString, observations, predictionLocations,
              model, outputWhat, yamamoto, iwqmaxit = 500,
              iwqCpAddLim = 0.0001, debug.level, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbiasedKrige_+3A_object">object</code></td>
<td>
<p>either an object of the intamap type (see <code><a href="#topic+intamap-package">intamap-package</a></code> 
for further 
description of the necessary content of this variable) or the output from the function
<code><a href="gstat.html#topic+krige">krige</a></code> in <code><a href="gstat.html#topic+gstat">gstat</a></code>. If the object is a result
from the intamap procedure spatialPredict, the remaining arguments are not necessary.</p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_formulastring">formulaString</code></td>
<td>
<p>formula that defines the dependent variable as a linear model of independent variables; 
suppose the dependent variable has name z, for ordinary and simple kriging use the formula z~1; 
for universal kriging, suppose z is linearly dependent on x and y, use the formula z~x+y</p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_observations">observations</code></td>
<td>
<p>a <code><a href="sp.html#topic+Spatial-class">Spatial</a></code>*DataFrame with observations; 
should contain the dependent variable, independent variables, and coordinates</p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_predictionlocations">predictionLocations</code></td>
<td>
<p>the predictionLocations, only necessary if the 
method is &quot;IWQSEL&quot; and formulaString contains independent variables.
Should preferentally be a grid if the method is &quot;IWQSEL&quot;</p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_model">model</code></td>
<td>
<p>variogram model of dependent variable (or its residuals), defined 
by a call to <code><a href="gstat.html#topic+vgm">vgm</a></code> or <code><a href="automap.html#topic+autofitVariogram">autofitVariogram</a></code> </p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_outputwhat">outputWhat</code></td>
<td>
<p>Argument with type of unbiasedness method (&quot;MOK&quot; or &quot;IWQSEL&quot;) and the thresholds.</p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_yamamoto">yamamoto</code></td>
<td>
<p>logical describing if the yamamoto approach )is to be used in simulations.
Defaults to yamamoto = FALSE when object is a <code><a href="sp.html#topic+Spatial-class">Spatial</a></code>*DataFrame.</p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_iwqmaxit">iwqmaxit</code></td>
<td>
<p>maximum number of iterations in iwqsel</p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_iwqcpaddlim">iwqCpAddLim</code></td>
<td>
<p>convergence criteria in iwqsel</p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_debug.level">debug.level</code></td>
<td>
<p>debug level, passed to subfunctions</p>
</td></tr>
<tr><td><code id="unbiasedKrige_+3A_...">...</code></td>
<td>
<p> other arguments that will be passed to subfunctions. These include 
</p>

<dl>
<dt><code>nsim</code></dt><dd><p>number of simulations necessary if the method is &quot;IWQSEL&quot;.
Defaults to nsim = 100 when object is a <code><a href="sp.html#topic+Spatial-class">Spatial</a></code>*DataFrame.</p>
</dd>
<dt><code>maxdist</code></dt><dd><p>maximum number of neighbours to use in local kriging, defaults to Inf</p>
</dd>
<dt><code>nmax</code></dt><dd><p>for local kriging: the number of nearest observations that 
should be used in simulations for the &quot;IWQSEL&quot; method in terms of the space of the spatial locations. 
Defaults to nmax = 10 when object is a Spatial*DataFrame.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>It is a fact that predictions from kriging tend to be biased towards the mean of
the process. The function <code>unbiasedKrige</code> is a function that adds one or more predictions
to the original output, which are assumed to be unbiased relative to a certain 
threshold. The two methods supported are the IWQSEL-method (Craigmile, 2006) and
MOK (Skoien et al, 2008). 
</p>


<h3>Value</h3>

 
<p>an object of type intamap, as described in <code><a href="#topic+intamap-package">intamap-package</a></code>, or a 
<code><a href="sp.html#topic+Spatial-class">Spatial</a></code>*DataFrame with one or more new prediction columns, representing different
methods and thresholds.
</p>


<h3>Author(s)</h3>

<p> Jon Olav Skoien</p>


<h3>References</h3>

 
<p>Craigmile, P. F., N. Cressie, T. J. Santner, and Y. Rao. 2006. 
A loss function approach to identifying environmental exceedances. Extremes, 8, 143-159.
</p>
<p>Skoien, J. O., G. B. M. Heuvelink, and E. J. Pebesma. 2008. 
Unbiased block predictions and exceedance probabilities for environmental thresholds. 
In: J. Ortiz C. and X. Emery (eds). Proceedings of the eight international geostatistics congress. 
Gecamin, Santiago, Chile,  pp. 831-840.
</p>
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(automap)
library(gstat)
data(meuse)
data(meuse.grid)
coordinates(meuse) = ~x+y
gridded(meuse.grid) = ~x+y

predictionLocations = meuse.grid[sample(1:length(meuse.grid),50),]
vmod = autofitVariogram(log(zinc)~1,meuse)$var_model
prediction = krige(log(zinc)~1,meuse,predictionLocations,vmod)
summary(prediction)

prediction &lt;- unbiasedKrige(prediction,log(zinc)~1,
  meuse,  model = vmod, outputWhat = list(MOK = 6.0, MOK = 7.0, IWQSEL=7.0), 
  iwqmaxit = 100, iwqCpAddLim = 0.01)
summary(prediction)
</code></pre>

<hr>
<h2 id='yamamotoKrige'>kriging and simulation with alternative kriging variance</h2><span id='topic+yamamotoKrige'></span>

<h3>Description</h3>

<p>ordinary kriging and simulation with an alternative kriging variance</p>


<h3>Usage</h3>

<pre><code class='language-R'>yamamotoKrige(formula, Obs, newPoints, model, nsim = 0, nmax = 20, maxdist = Inf)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yamamotoKrige_+3A_formula">formula</code></td>
<td>
<p>formula that defines the dependent variable as a linear model of 
independent variables; suppose the dependent variable has name 
<code>z</code>, for ordinary and simple kriging use the formula <code>z~1</code>; 
only ordinary kriging is currently implemented, <code>formula</code> is
hence mainly used to identify the dependent variable </p>
</td></tr>
<tr><td><code id="yamamotoKrige_+3A_obs">Obs</code></td>
<td>
<p><code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code> with observations</p>
</td></tr>
<tr><td><code id="yamamotoKrige_+3A_newpoints">newPoints</code></td>
<td>
<p><code><a href="sp.html#topic+Spatial-class">Spatial</a></code> object with prediction locations, either points or grid</p>
</td></tr>
<tr><td><code id="yamamotoKrige_+3A_model">model</code></td>
<td>
<p>variogram model - of the type that can be found by a call to 
<code><a href="gstat.html#topic+vgm">vgm</a></code> </p>
</td></tr>
<tr><td><code id="yamamotoKrige_+3A_nsim">nsim</code></td>
<td>
<p>integer; if set to a non-zero value, conditional simulation is used 
instead of kriging interpolation. For this, sequential Gaussian simulation 
is used, following a single random path through the data. </p>
</td></tr>
<tr><td><code id="yamamotoKrige_+3A_nmax">nmax</code></td>
<td>
<p>for local kriging: the number of nearest observations that should 
be used for a kriging prediction or simulation, where nearest is 
defined in terms of the space of the spatial locations. 
By default, all observations are used. </p>
</td></tr>
<tr><td><code id="yamamotoKrige_+3A_maxdist">maxdist</code></td>
<td>
<p>maximum number of neighbours to use in local kriging, defaults to Inf</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The term <code>yamamotoKrige</code> comes from the paper of Yamamoto (2000) where
he suggests using local variance around the kriging estimate (weighted with
the kriging weights) as an alternative kriging variance. This as a 
solution to more reliable estimates of the kriging variance also when the 
stationarity assumption has been violated. The method was applied by 
Skoien et al. (2008), who showed that it can have advantages for cases where the 
stationarity assumption behind kriging is violated.
</p>
<p>If the number of observations is high, it is recommended have <code>nmax</code> lower.
This is partly because the method relies on positive kriging weights. The method
to do this adds the norm of the largest negative weight to all weights, and rescales.
This tends to smooth the weights, giving a prediction closer to the average if a 
too large number of observation locations is used.
</p>


<h3>Value</h3>

<p>Either a <code><a href="sp.html#topic+Spatial-class">Spatial</a></code>*DataFrame with predictions and prediction variance, 
in the columns <code>var1.pred</code> and <code>var1.var</code>, together with the
classical ordinary kriging variance in <code>var1.ok</code>, or simulations with 
column names <code>simx</code> where x is the number of the simulation.
</p>


<h3>Author(s)</h3>

<p>Jon Olav Skoien</p>


<h3>References</h3>

<p>Skoien, J. O., G. B. M. Heuvelink, and E. J. Pebesma. 2008. 
Unbiased block predictions and exceedance probabilities for environmental thresholds. 
In: J. Ortiz C. and X. Emery (eds). Proceedings of the eight international 
geostatistics congress. Santiago, Chile: Gecamin, pp. 831-840.
</p>
<p>Yamamoto, J. K. 2000. An alternative measure of the reliability of ordinary 
kriging estimates. Mathematical Geology, 32 (4), 489-509.
</p>
<p>Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gstat)
library(automap)
data(sic2004)
coordinates(sic.val) = ~x+y
coordinates(sic.test) = ~x+y
variogramModel = autofitVariogram(joker~1,sic.val)$var_model
newData = yamamotoKrige(joker~1,sic.val,sic.test,variogramModel,nmax = 20)
summary(newData)
plot(sqrt(var1.ok)~var1.pred,newData) 
# Kriging variance the same in regions with extreme values
plot(sqrt(var1.var)~var1.pred,newData) 
# Kriging standard deviation higher for high predictions (close to extreme values)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
