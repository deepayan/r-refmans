<!DOCTYPE html><html><head><title>Help for package CICI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CICI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CICI-package'>
<p>Causal Inference with Continuous (Multiple Time Point) Interventions</p></a></li>
<li><a href='#custom.measure'><p>Custom estimands after applying <code>gformula</code></p></a></li>
<li><a href='#EFV'>
<p>Pharmacoepidemiological HIV treatment data</p></a></li>
<li><a href='#EFVfull'>
<p>Pharmacoepidemiological HIV treatment data</p></a></li>
<li><a href='#fit.updated.formulas'><p>Fit models after screening</p></a></li>
<li><a href='#gformula'>
<p>Parametric g-formula for continuous multiple time point interventions</p></a></li>
<li><a href='#make.model.formulas'>
<p>Compose appropriate model formulas</p></a></li>
<li><a href='#mi.boot'><p>Obtaining estimates from multiply imputed data</p></a></li>
<li><a href='#model.formulas.update'><p>Update model formulas based on variable screening</p></a></li>
<li><a href='#model.update'><p>Update GAM models</p></a></li>
<li><a href='#plot.gformula'>
<p>Plot dose-response curves</p></a></li>
<li><a href='#print.gformula'>
<p>Printing the results of a <code>gformula</code> object</p></a></li>
<li><a href='#prop'><p>Helper function to calculate proportions of categorical variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Causal Inference with Continuous (Multiple Time Point)
Interventions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Schomaker &lt;michael.schomaker@stat.uni-muenchen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of counterfactual outcomes for multiple values of continuous interventions at different time points, and plotting of causal dose-response curves. Details are given in Schomaker, McIlleron, Denti, Diaz (2023) &lt;<a href="https://arxiv.org/abs/2305.06645">arXiv:2305.06645</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, glmnet, ggplot2, parallel, doParallel, foreach, doRNG,
rngtools</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-16 09:53:06 UTC; 01465840</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Schomaker [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-18 13:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='CICI-package'>
Causal Inference with Continuous (Multiple Time Point) Interventions
</h2><span id='topic+CICI'></span>

<h3>Description</h3>

<p>This package facilitates the estimation of counterfactual outcomes for multiple values of continuous interventions at different time points, and allows plotting of causal dose-response curves. 
</p>
<p>It implements the standard g-methods approach using the (semi-)parametric <em>g</em>-formula, as described in the Schomaker et al. (2023) reference listed below. Weighted dose-response curves that address positivity violations, and are fitted via sequential <em>g</em>-computation, are currently only available on GitHub and are not (yet) integrated in this package. 
</p>
<p>The main function of the package is currently <code><a href="#topic+gformula">gformula</a></code>.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CICI</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.9.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-07-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 4.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> mgcv, glmnet, ggplot2, parallel, doParallel, foreach, doRNG, rngtools</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Michael Schomaker
</p>
<p>Maintainer: Michael Schomaker &lt;michael.schomaker@stat.uni-muenchen.de&gt;
</p>


<h3>References</h3>

<p>Schomaker M, McIlleron H, Denti P, Diaz I. (2023) <em>Causal Inference for Continuous Multiple Time Point Interventions</em>, ArXiv e-prints: <em>https://arxiv.org/abs/2305.06645</em>.
</p>

<hr>
<h2 id='custom.measure'>Custom estimands after applying <code><a href="#topic+gformula">gformula</a></code></h2><span id='topic+custom.measure'></span>

<h3>Description</h3>

<p>The default estimate returned by <code><a href="#topic+gformula">gformula</a></code> is the <strong>expected</strong> outcome under the respective intervention strategies <code>abar</code>.
<code>custom.measure</code> takes an object of class <code>gformula</code> and enables estimation of other estimands based on the 
counterfactual datasets produced by <code><a href="#topic+gformula">gformula</a></code> (if the option <code>ret=TRUE</code> had been chosen), for example estimands conditional on baseline variables, quantiles instead of expectations, and others.</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom.measure(X, fun = NULL, cond = NULL, verbose = TRUE, with.se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom.measure_+3A_x">X</code></td>
<td>

<p>An object of class <code>gformula</code> produced by  <code><a href="#topic+gformula">gformula</a></code> with option <code>ret=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="custom.measure_+3A_fun">fun</code></td>
<td>

<p>A function to be applied to the outcome(s) of the counterfactual data set.
</p>
</td></tr>
<tr><td><code id="custom.measure_+3A_cond">cond</code></td>
<td>

<p>A string containing a condition to be applied to the counterfactual datasets.
</p>
</td></tr>
<tr><td><code id="custom.measure_+3A_verbose">verbose</code></td>
<td>

<p>Logical. TRUE if notes should be printed.
</p>
</td></tr>
<tr><td><code id="custom.measure_+3A_with.se">with.se</code></td>
<td>
<p>Logical. TRUE if standard deviation should be calculated and returned.</p>
</td></tr>
<tr><td><code id="custom.measure_+3A_...">...</code></td>
<td>

<p>other parameters to be passed to <code>fun</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In settings with censoring, it will often be needed to pass on the option <code>na.rm=T</code>, e.g. for the mean, median, quantilesn, and others. 
</p>
<p>Calculation of the bootstrap standard error (i.e., <code>with.se</code>=T) is typically not needed; but, for example, necessary for the calculations after multiple imputation and hence used by <code><a href="#topic+mi.boot">mi.boot</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>gformula</code>. See <code><a href="#topic+gformula">gformula</a></code> for details.
</p>


<h3>See Also</h3>

<p>see also <code><a href="#topic+gformula">gformula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(EFV)

est &lt;- gformula(X=EFV,
                Lnodes  = c("adherence.1","weight.1",
                            "adherence.2","weight.2",
                            "adherence.3","weight.3",
                            "adherence.4","weight.4"
                ),
                Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
                Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
                abar=seq(0,2,1), ret=TRUE
)

est
custom.measure(est, fun=prop,categ=1) # identical
custom.measure(est, fun=prop,categ=0)
custom.measure(est, fun=prop, categ=0, cond="sex==1")
# note: metabolic has been recoded internally (see output above)
custom.measure(est, fun=prop, categ=0, cond="metabolic==0") 
# does not make sense here, just for illustration (useful for metric outcomes)
custom.measure(est, fun=quantile, probs=0.1) 

</code></pre>

<hr>
<h2 id='EFV'>
Pharmacoepidemiological HIV treatment data
</h2><span id='topic+EFV'></span>

<h3>Description</h3>

<p>A hypothetical, simulated dataset which is line with the data-generating process of Schomaker et al. (2023) and inspired by the data of Bienczak et al. (2017); see references below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EFV)</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 observations on the following variables:
</p>

<dl>
<dt><code>sex</code></dt><dd><p>The patient's sex</p>
</dd>
<dt><code>metabolic</code></dt><dd><p>Metabolism status (slow, intermediate, extensive) related to the single nucleotide polymorphisms in the CYP2B6 gene, which is relevant
for metabolizing evafirenz and directly affects its concentration in the body.</p>
</dd>
<dt><code>log_age</code></dt><dd><p>log(age) at baseline</p>
</dd>
<dt><code>NRTI</code></dt><dd><p>Nucleoside reverse transcriptase inhibitor (NRTI) component of HIV treatment, i.e.
abacavir, stavudine or zidovudine.</p>
</dd>
<dt><code>weight.0</code></dt><dd><p>log(weight) at time 0 (baseline)</p>
</dd>
<dt><code>efv.0</code></dt><dd><p>Efavirenz concentration at time 0 (baseline)</p>
</dd>
<dt><code>VL.0</code></dt><dd><p>Elevated viral load (viral failure) at time 0 (baseline)</p>
</dd>
<dt><code>adherence.1</code></dt><dd><p>Adherence at time 1 (if 0, then signs of non-adherence)</p>
</dd>
<dt><code>weight.1</code></dt><dd><p>log(weight) at time 1</p>
</dd>
<dt><code>efv.1</code></dt><dd><p>Efavirenz concentration at time 1</p>
</dd>
<dt><code>VL.1</code></dt><dd><p>Elevated viral load (viral failure) at time 1</p>
</dd>
<dt><code>adherence.2</code></dt><dd><p>Adherence at time 2 (if 0, then signs of non-adherence)</p>
</dd>
<dt><code>weight.2</code></dt><dd><p>log(weight) at time 2</p>
</dd>
<dt><code>efv.2</code></dt><dd><p>Efavirenz concentration at time 2</p>
</dd>
<dt><code>VL.2</code></dt><dd><p>Elevated viral load (viral failure) at time 2</p>
</dd>
<dt><code>adherence.3</code></dt><dd><p>Adherence at time 3 (if 0, then signs of non-adherence)</p>
</dd>
<dt><code>weight.3</code></dt><dd><p>log(weight) at time 3</p>
</dd>
<dt><code>efv.3</code></dt><dd><p>Efavirenz concentration at time 3</p>
</dd>
<dt><code>VL.3</code></dt><dd><p>Elevated viral load (viral failure) at time 3</p>
</dd>
<dt><code>adherence.4</code></dt><dd><p>Adherence at time 4 (if 0, then signs of non-adherence)</p>
</dd>
<dt><code>weight.4</code></dt><dd><p>log(weight) at time 4</p>
</dd>
<dt><code>efv.4</code></dt><dd><p>Efavirenz concentration at time 4</p>
</dd>
<dt><code>VL.4</code></dt><dd><p>Elevated viral load (viral failure) at time 4</p>
</dd>
</dl>



<h3>References</h3>

<p>Schomaker M, McIlleron H, Denti P, Diaz I. (2023) <em>Causal Inference for Continuous Multiple Time Point Interventions</em>, ArXiv e-prints: <em>https://arxiv.org/abs/2305.06645</em>.
</p>
<p>Bienczak et al. (2017) <em>Determinants of virological outcome and adverse events in African children treated with paediatric nevirapine fixed-dose-combination tablets</em>, AIDS, <em>31:905-915</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EFV)
str(EFV)
</code></pre>

<hr>
<h2 id='EFVfull'>
Pharmacoepidemiological HIV treatment data
</h2><span id='topic+EFVfull'></span>

<h3>Description</h3>

<p>A hypothetical, simulated dataset which is line with the data-generating process of Schomaker et al. (2023) and inspired by the data of Bienczak et al. (2017); see references below. Compared to the dataset <code>EFV</code>, it contains all variables of the DAG in Figure 3 of Schomaker et al. (2023), also those which are not needed for identification of the counterfactual quantity of interest; that is, the expected viral suppression (<code>VL</code>) under a specific intervention on efavirenz concentrations (<code>efv.0, efv.1, ...</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EFVfull)</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 observations on the following variables:
</p>

<dl>
<dt><code>sex</code></dt><dd><p>The patient's sex</p>
</dd>
<dt><code>metabolic</code></dt><dd><p>Metabolism status (slow, intermediate, extensive) related to the single nucleotide polymorphisms in the CYP2B6 gene, which is relevant
for metabolizing evafirenz and directly affects its concentration in the body.</p>
</dd>
<dt><code>log_age</code></dt><dd><p>log(age) at baseline</p>
</dd>
<dt><code>NRTI</code></dt><dd><p>Nucleoside reverse transcriptase inhibitor (NRTI) component of HIV treatment, i.e.
abacavir, stavudine or zidovudine.</p>
</dd>
<dt><code>weight.0</code></dt><dd><p>log(weight) at time 0 (baseline)</p>
</dd>
<dt><code>comorbidity.0</code></dt><dd><p>Presence of co-morbidities at time 0 (baseline)</p>
</dd>
<dt><code>dose.0</code></dt><dd><p>Dose of efavirenz administered at time 0 (basline)</p>
</dd>
<dt><code>efv.0</code></dt><dd><p>Efavirenz concentration at time 0 (baseline)</p>
</dd>
<dt><code>VL.0</code></dt><dd><p>Elevated viral load (viral failure) at time 0 (baseline)</p>
</dd>
<dt><code>adherence.1</code></dt><dd><p>Adherence at time 1 (if 0, then signs of non-adherence)</p>
</dd>
<dt><code>weight.1</code></dt><dd><p>log(weight) at time 1</p>
</dd>
<dt><code>comorbidity.1</code></dt><dd><p>Presence of co-morbidities at time 1</p>
</dd>
<dt><code>dose.1</code></dt><dd><p>Dose of efavirenz administered at time 1</p>
</dd>
<dt><code>efv.1</code></dt><dd><p>Efavirenz concentration at time 1</p>
</dd>
<dt><code>VL.1</code></dt><dd><p>Elevated viral load (viral failure) at time 1</p>
</dd>
<dt><code>adherence.2</code></dt><dd><p>Adherence at time 2 (if 0, then signs of non-adherence)</p>
</dd>
<dt><code>weight.2</code></dt><dd><p>log(weight) at time 2</p>
</dd>
<dt><code>comorbidity.2</code></dt><dd><p>Presence of co-morbidities at time 2</p>
</dd>
<dt><code>dose.2</code></dt><dd><p>Dose of efavirenz administered at time 2</p>
</dd>
<dt><code>efv.2</code></dt><dd><p>Efavirenz concentration at time 2</p>
</dd>
<dt><code>VL.2</code></dt><dd><p>Elevated viral load (viral failure) at time 2</p>
</dd>
<dt><code>adherence.3</code></dt><dd><p>Adherence at time 3 (if 0, then signs of non-adherence)</p>
</dd>
<dt><code>weight.3</code></dt><dd><p>log(weight) at time 3</p>
</dd>
<dt><code>comorbidity.3</code></dt><dd><p>Presence of co-morbidities at time 3</p>
</dd>
<dt><code>dose.3</code></dt><dd><p>Dose of efavirenz administered at time 3</p>
</dd>
<dt><code>efv.3</code></dt><dd><p>Efavirenz concentration at time 3</p>
</dd>
<dt><code>VL.3</code></dt><dd><p>Elevated viral load (viral failure) at time 3</p>
</dd>
<dt><code>adherence.4</code></dt><dd><p>Adherence at time 4 (if 0, then signs of non-adherence)</p>
</dd>
<dt><code>weight.4</code></dt><dd><p>log(weight) at time 4</p>
</dd>
<dt><code>comorbidity.4</code></dt><dd><p>Presence of co-morbidities at time 4</p>
</dd>
<dt><code>dose.4</code></dt><dd><p>Dose of efavirenz administered at time 4</p>
</dd>
<dt><code>efv.4</code></dt><dd><p>Efavirenz concentration at time 4</p>
</dd>
<dt><code>VL.4</code></dt><dd><p>Elevated viral load (viral failure) at time</p>
</dd>
</dl>



<h3>References</h3>

<p>Schomaker M, McIlleron H, Denti P, Diaz I. (2023) <em>Causal Inference for Continuous Multiple Time Point Interventions</em>, ArXiv e-prints: <em>https://arxiv.org/abs/2305.06645</em>.
</p>
<p>Bienczak et al. (2017) <em>Determinants of virological outcome and adverse events in African children treated with paediatric nevirapine fixed-dose-combination tablets</em>, AIDS, <em>31:905-915</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EFVfull)
str(EFVfull)
</code></pre>

<hr>
<h2 id='fit.updated.formulas'>Fit models after screening</h2><span id='topic+fit.updated.formulas'></span>

<h3>Description</h3>

<p>Fits the models that have been generated with screening using <code><a href="#topic+model.formulas.update">model.formulas.update</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.updated.formulas(formulas, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.updated.formulas_+3A_formulas">formulas</code></td>
<td>
<p>An object returned by <code><a href="#topic+model.formulas.update">model.formulas.update</a></code></p>
</td></tr>
<tr><td><code id="fit.updated.formulas_+3A_x">X</code></td>
<td>
<p>A data frame on which the model formulas should be evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits generalized (additive) linear models based on the screened model formula list generated by <code><a href="#topic+model.formulas.update">model.formulas.update</a></code>.
</p>


<h3>Value</h3>

<p>Returns a list of length 2:
</p>
<table>
<tr><td><code>fitted.models</code></td>
<td>
<p>A list of length 4, containing the fitted Y-/L-/C- and A-models.</p>
</td></tr>
<tr><td><code>all.summaries</code></td>
<td>
<p>A list of length 4, containing the summary of the fitted Y-/L-/C- and A-models.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+model.formulas.update">model.formulas.update</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(EFV)

# first: generate generic model formulas
m &lt;- make.model.formulas(X=EFV,
                         Lnodes  = c("adherence.1","weight.1",
                                     "adherence.2","weight.2",
                                     "adherence.3","weight.3",
                                     "adherence.4","weight.4"
                                    ),
                         Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
                         Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
                         evaluate=FALSE) 
                         
# second: update these model formulas based on variable screening with LASSO
glmnet.formulas &lt;-  model.formulas.update(m$model.names, EFV)
glmnet.formulas 

# then: fit and inspect the updated models
fitted.models &lt;- fit.updated.formulas(glmnet.formulas, EFV)
fitted.models$all.summaries
fitted.models$all.summaries$Ynames[1] # first outcome model

</code></pre>

<hr>
<h2 id='gformula'>
Parametric g-formula for continuous multiple time point interventions
</h2><span id='topic+gformula'></span>

<h3>Description</h3>

<p>Estimation of counterfactual outcomes for multiple values of continuous interventions at different time points using the g-formula. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gformula(X, Anodes, Ynodes, Lnodes = NULL, Cnodes = NULL,
         abar = NULL, cbar = "uncensored",
         survivalY = FALSE, 
         Yform = "GLM", Lform = "GLM", Aform = "GLM", Cform = "GLM",
         calc.support = FALSE, B = 0, ret = FALSE, ncores = 1, 
         verbose = TRUE, seed = NULL, prog = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gformula_+3A_x">X</code></td>
<td>

<p>A data frame, following the time-ordering of the nodes. Categorical variables with k categories should be a factor, with levels 0,...,k-1. Binary variables should be coded 0/1. 
</p>
</td></tr>
<tr><td><code id="gformula_+3A_anodes">Anodes</code></td>
<td>

<p>A character string of column names in <code>X</code> of the intervention variable(s).
</p>
</td></tr>
<tr><td><code id="gformula_+3A_ynodes">Ynodes</code></td>
<td>

<p>A character string of column names in <code>X</code> of  the outcome variable(s).
</p>
</td></tr>
<tr><td><code id="gformula_+3A_lnodes">Lnodes</code></td>
<td>

<p>A character string of column names in <code>X</code> of  the time-dependent (post first treatment) variable(s).
</p>
</td></tr>
<tr><td><code id="gformula_+3A_cnodes">Cnodes</code></td>
<td>

<p>A character string of column names in <code>X</code> of  the censoring variable(s).
</p>
</td></tr>
<tr><td><code id="gformula_+3A_abar">abar</code></td>
<td>

<p>Numeric vector or matrix of intervention values, or the string &quot;natural&quot;. See Details.
</p>
</td></tr>
<tr><td><code id="gformula_+3A_cbar">cbar</code></td>
<td>

<p>Typically either the string &quot;uncensored&quot; or &quot;natural&quot;, but a numeric vector or matrix of censoring values is not forbidden. See Details.
</p>
</td></tr>
<tr><td><code id="gformula_+3A_survivaly">survivalY</code></td>
<td>

<p>Logical. If TRUE, then Y nodes are indicators of an event, and if Y at some time point is 1, then all following should be 1.
</p>
</td></tr>
<tr><td><code id="gformula_+3A_yform">Yform</code></td>
<td>

<p>A string of either &quot;GLM&quot;, &quot;GAM&quot; or of length 'number of Ynodes' with model formulas. See Details. 
</p>
</td></tr>
<tr><td><code id="gformula_+3A_lform">Lform</code></td>
<td>

<p>A string of either &quot;GLM&quot;, &quot;GAM&quot; or of length 'number of Lnodes' with model formulas. See Details. 
</p>
</td></tr>
<tr><td><code id="gformula_+3A_aform">Aform</code></td>
<td>

<p>A string of either &quot;GLM&quot;, &quot;GAM&quot; or of length 'number of Anodes' with model formulas. See Details. 
</p>
</td></tr>
<tr><td><code id="gformula_+3A_cform">Cform</code></td>
<td>

<p>A string of either &quot;GLM&quot;, &quot;GAM&quot; or of length 'number of Cnodes' with model formulas. See Details. 
</p>
</td></tr>
<tr><td><code id="gformula_+3A_calc.support">calc.support</code></td>
<td>

<p>Logical. If <code>TRUE</code>, both crude and conditional support is estimated.
</p>
</td></tr>
<tr><td><code id="gformula_+3A_b">B</code></td>
<td>

<p>An integer specifying the number of bootstrap samples to be used, if any. 
</p>
</td></tr>
<tr><td><code id="gformula_+3A_ret">ret</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the simulated post-intervention data is returned.
</p>
</td></tr>
<tr><td><code id="gformula_+3A_ncores">ncores</code></td>
<td>

<p>An integer for the number of threads/cores to be used. If &gt;1, parallelization will be utilized.
</p>
</td></tr>
<tr><td><code id="gformula_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, notes and warnings are printed.
</p>
</td></tr>
<tr><td><code id="gformula_+3A_seed">seed</code></td>
<td>

<p>An integer specifying the seed to be used to create reproducable results for parallel computing (i.e. when ncores&gt;1).
</p>
</td></tr>
<tr><td><code id="gformula_+3A_prog">prog</code></td>
<td>

<p>A character specifying a path where progress should be saved (typically, when <code>ncores</code>&gt;1)
</p>
</td></tr>
<tr><td><code id="gformula_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed on.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, expected counterfactual outcomes (specified under <code>Ynodes</code>) under the intervention <code>abar</code> are calculated. Other estimands can be specified via <code><a href="#topic+custom.measure">custom.measure</a></code>.
</p>
<p>If <code>abar</code> is a vector, then each vector component is used as the intervention value at each time point; that is, interventions which are constant over time are defined. If <code>abar</code> is a matrix (of size 'number interventions' x 'time points'), then each row of the length of <code>Anodes</code> refers to a particular time-varying intervention strategy. The natural intervention can be picked by setting <code>abar='natural'</code>.
</p>
<p>The fitted outcome and confounder models are based on generalized additive models (GAMs) as implemented in the <code>mgcv</code> package. Model families are picked automatically and reported in the output if <code>verbose=TRUE</code> (see manual for modifications, though they hardly ever make sense). The model formulas are standard GLMs or GAMs (with penalized splines for continuous covariates), conditional on the past, unless specific formulae are given. It is recommended to use customized formulae to reduce the risk of model mis-specification and to ensure that the models make sense (e.g., not too many splines are used when this is computationally not meaningful). This can be best facilitated by using objects generated through <code><a href="#topic+make.model.formulas">make.model.formulas</a></code>, followed by <code><a href="#topic+model.formulas.update">model.formulas.update</a></code> and/or <code><a href="#topic+model.update">model.update</a></code> (see examples for those functions). 
</p>
<p>For survival settings, it is required that i) <code>survivalY=TRUE</code>, ii) the data are in a format where a Ynode stays 1, after it jumps to 1 and ii) after a Cnode/Ynode is 1, every variable thereafter is set to <code>NA</code> (except a Ynode which is already 1). See manual for an example. By default, the package intervenes on Cnodes, i.e. calculates counterfactual outcomes under no censoring. 
</p>
<p>If <code>calc.support=TRUE</code>, conditional and crude support measures (i.e., diagnostics) are calculated as described in Section 3.3.2 of Schomaker et al. (2023). Another useful diagnostic for multiple time points is the natural course scenario, which can be evaluated under <code>abar='natural'</code> and <code>cbar='natural'</code>.
</p>
<p>To parallelize computations automatically, it is sufficient to set <code>ncores&gt;1</code>, as appropriate. No further customization or setup is needed, everything will be done by the package. To make estimates under parallelization reproducible, use the <code>seed</code> argument. To watch the progress of parallelized computations, set a path in the <code>prog</code> argument: then, a text file reports on the progress, which is particularly useful if lengthy bootstrapping computations are required.
</p>


<h3>Value</h3>

<p>Returns an object of of <code>class</code> &lsquo;gformula&rsquo;:
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>matrix of results</p>
</td></tr>
<tr><td><code>diagnostics</code></td>
<td>
<p>list of diagnostics and weights based on the estimated support (if <code>calc.support=TRUE</code>)</p>
</td></tr>
<tr><td><code>simulated.data</code></td>
<td>
<p>list of counterfactual data sets related to the interventions defined through option <code>abar</code> (and <code>cbar</code>). Will be <code>NULL</code> is <code>ret=FALSE</code>.</p>
</td></tr>
<tr><td><code>observed.data</code></td>
<td>
<p>list of observed data (and bootstrapped observed data). Will be <code>NULL</code> is <code>ret=FALSE</code>.</p>
</td></tr>
<tr><td><code>setup</code></td>
<td>
<p>list of chosen setup parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Schomaker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.gformula">plot.gformula</a></code> for plotting results as (causal) dose response curves, <code><a href="#topic+custom.measure">custom.measure</a></code> for evaluating custom estimands and <code><a href="#topic+mi.boot">mi.boot</a></code> for using <code><a href="#topic+gformula">gformula</a></code> on multiply imputed data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(EFV)
est &lt;- gformula(X=EFV,
                      Lnodes  = c("adherence.1","weight.1",
                                  "adherence.2","weight.2",
                                  "adherence.3","weight.3",
                                  "adherence.4","weight.4"
                        ),
                        Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
                        Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
                        abar=seq(0,10,1)
)
est


</code></pre>

<hr>
<h2 id='make.model.formulas'>
Compose appropriate model formulas
</h2><span id='topic+make.model.formulas'></span>

<h3>Description</h3>

<p>Function that generates generic model formulas for Y-/L-/A- and Cnodes, according to time ordering and to be used in <code><a href="#topic+gformula">gformula</a></code> or <code><a href="#topic+model.formulas.update">model.formulas.update</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.model.formulas(X, Ynodes = NULL, Lnodes = NULL, Cnodes = NULL, Anodes = NULL,
                    survival = FALSE, evaluate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.model.formulas_+3A_x">X</code></td>
<td>

<p>A data frame, following the time-ordering of the nodes.  
</p>
</td></tr>
<tr><td><code id="make.model.formulas_+3A_ynodes">Ynodes</code></td>
<td>

<p>A character string of column names in <code>X</code> of  the outcome variable(s).</p>
</td></tr>
<tr><td><code id="make.model.formulas_+3A_lnodes">Lnodes</code></td>
<td>

<p>A character string of column names in <code>X</code> of  time-dependent (post first treatment) variable(s).
</p>
</td></tr>
<tr><td><code id="make.model.formulas_+3A_cnodes">Cnodes</code></td>
<td>

<p>A character string of column names in <code>X</code> of  the censoring variable(s).
</p>
</td></tr>
<tr><td><code id="make.model.formulas_+3A_anodes">Anodes</code></td>
<td>

<p>A character string of column names in <code>X</code> of intervention variable(s).
</p>
</td></tr>
<tr><td><code id="make.model.formulas_+3A_survival">survival</code></td>
<td>

<p>Logical. If TRUE, a survival setting is assumed and taken into account for model specification.
</p>
</td></tr>
<tr><td><code id="make.model.formulas_+3A_evaluate">evaluate</code></td>
<td>

<p>Logical. TRUE if model formulas should model formulas be evaluated on <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function to generate model formulas for Y-/L-/A- and Cnodes, according to the time ordering: i.e. to generate GLM/GAM model formulas for the respective nodes given all <em>past</em> variables. In survival settings, past censoring and outcome nodes are omitted from the formulae. If censoring is present without a survival setting (e.g. Cnodes describe drop-outs and Y is a continuous outcome), then survival should be set as FALSE.
</p>


<h3>Value</h3>

<p>Returns a named list:
</p>
<table>
<tr><td><code>model.names</code></td>
<td>
<p>A list of length 4 containing strings of the actual formulas</p>
</td></tr>
<tr><td><code>fitted.models</code></td>
<td>
<p>A list of the fitted models (if <code>evaluate=TRUE</code>)</p>
</td></tr>
<tr><td><code>fitted.model.summary</code></td>
<td>
<p>A list of the summary of the fitted models (if <code>evaluate=TRUE</code>)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The generated generic model formulas can be updated manually with <code><a href="#topic+model.update">model.update</a></code> or in an automated manner with screening using <code><a href="#topic+model.formulas.update">model.formulas.update</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EFV)

m &lt;- make.model.formulas(X=EFV,
                         Lnodes  = c("adherence.1","weight.1",
                                     "adherence.2","weight.2",
                                     "adherence.3","weight.3",
                                     "adherence.4","weight.4"
                                    ),
                         Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
                         Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
                         evaluate=FALSE) # set TRUE to see fitted models
                         
m$model.names # all models potentially relevant for gformula(), given full past
</code></pre>

<hr>
<h2 id='mi.boot'>Obtaining estimates from multiply imputed data</h2><span id='topic+mi.boot'></span>

<h3>Description</h3>

<p>Combines <code><a href="#topic+gformula">gformula</a></code> estimates obtained from multiple imputed data sets according to the <em>MI Boot</em> and <em>MI Boot pooled</em> methods decribed in Schomaker and Heumann (2018, see reference section below) </p>


<h3>Usage</h3>

<pre><code class='language-R'>mi.boot(x, fun, cond=NULL, pooled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi.boot_+3A_x">x</code></td>
<td>
<p>A list of objects of <code>class</code> &lsquo;gformula&rsquo;</p>
</td></tr>
<tr><td><code id="mi.boot_+3A_fun">fun</code></td>
<td>
<p>A function to be applied to the outcome(s) of the counterfactual data set. For expected outcome, use <code><a href="base.html#topic+mean">mean</a></code> and possibly pass on option <code>na.rm=TRUE</code>.</p>
</td></tr>
<tr><td><code id="mi.boot_+3A_cond">cond</code></td>
<td>
<p>A string containing a condition to be applied to the counterfactual datasets.</p>
</td></tr>
<tr><td><code id="mi.boot_+3A_pooled">pooled</code></td>
<td>
<p>Logical. If TRUE, confidence interval estimation is based on the MI Boot pooled from Schomaker and Heumann (2018), otherwise on MI Boot.</p>
</td></tr>
<tr><td><code id="mi.boot_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gformula</code>. See <code><a href="#topic+gformula">gformula</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Michael Schomaker
</p>


<h3>References</h3>

<p>Schomaker, M., Heumann, C. (2018) <em>Bootstrap inference when using multiple imputation</em>,
Statistics in Medicine, 37:2252-2266
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(EFV)

# suppose the following subsets were actually multiply imputed data (M=2)
EFV_1 &lt;- EFV[1:2500,]
EFV_2 &lt;- EFV[2501:5000,]

# first: conduct analysis on each imputed data set. Set ret=T.
m1 &lt;- gformula(X=EFV_1,
               Lnodes  = c("adherence.1","weight.1",
                           "adherence.2","weight.2",
                           "adherence.3","weight.3",
                           "adherence.4","weight.4"
               ),
               Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
               Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
               abar=seq(0,5,1), verbose=FALSE, ret=TRUE
        )

m2 &lt;- gformula(X=EFV_2,
               Lnodes  = c("adherence.1","weight.1",
                           "adherence.2","weight.2",
                           "adherence.3","weight.3",
                           "adherence.4","weight.4"
               ),
               Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
               Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
               abar=seq(0,5,1), verbose=FALSE, ret=TRUE
)

# second combine results
m_imp &lt;- mi.boot(list(m1,m2), mean) # uses MI rules &amp; returns 'gformula' object
plot(m_imp)

# custom estimand: evaluate probability of suppression (Y=0), among females
m_imp2 &lt;- mi.boot(list(m1,m2), prop, categ=0, cond="sex==1")
plot(m_imp2)

</code></pre>

<hr>
<h2 id='model.formulas.update'>Update model formulas based on variable screening</h2><span id='topic+model.formulas.update'></span>

<h3>Description</h3>

<p>Wrapper function to facilitate variable screening on all models generated through <code><a href="#topic+make.model.formulas">make.model.formulas</a></code> and return updated formulas in the appropriate format for <code><a href="#topic+gformula">gformula</a></code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>model.formulas.update(formulas, X, screening = screen.glmnet.cramer,
                      with.s = FALSE, by= NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.formulas.update_+3A_formulas">formulas</code></td>
<td>

<p>A named list of length 4 containing model formulas for all Y-/L-/A- and Cnodes. These are likely formulas returned from <code><a href="#topic+make.model.formulas">make.model.formulas</a></code>.
</p>
</td></tr>
<tr><td><code id="model.formulas.update_+3A_x">X</code></td>
<td>

<p>A data frame on which the model formulas are to be evaluated.</p>
</td></tr>
<tr><td><code id="model.formulas.update_+3A_screening">screening</code></td>
<td>

<p>A screening function. Default is <code>screen.glmnet.cramer</code>, see Details below.</p>
</td></tr>
<tr><td><code id="model.formulas.update_+3A_with.s">with.s</code></td>
<td>

<p>Logical. If TRUE, a spline, i.e. s(), will be added to <em>all</em> continuous variables.
</p>
</td></tr>
<tr><td><code id="model.formulas.update_+3A_by">by</code></td>
<td>

<p>A character vector specifying the variables with which to multiply the smooth (if <code>with.s=TRUE</code>). 
</p>
</td></tr>
<tr><td><code id="model.formulas.update_+3A_...">...</code></td>
<td>

<p>optional arguments to be passed to the screening algorithm
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default screening algorithm uses LASSO for variable screening (and Cramer's V for the categorized version of all variables if LASSO fails). It is possible to provide user-specific screening algorithms. 
User-specific algorithms should take the data as first argument, <em>one</em> model formula (i.e. one entry of the list in <code>model.formulas</code>) as second argument and return a vector of strings, containing the variable names that remain after screening. Another screening algorithm available in the package is <code>screen.cramersv</code>, which categorizes all variables, calculates their association with the outcome based on Cramer's <em>V</em> and selects the 4 variables with strongest associations (can be changed with option <code>nscreen</code>).
The manual provides more information.
</p>
<p>The fitted models of the updated models can be evaluated with <code><a href="#topic+fit.updated.formulas">fit.updated.formulas</a></code>.
</p>


<h3>Value</h3>

<p>A list of length 4 containing the updated model formulas:
</p>
<table>
<tr><td><code>Lnames</code></td>
<td>
<p>A vector of strings containing updated model formulas for all L nodes.</p>
</td></tr>
<tr><td><code>Ynames</code></td>
<td>
<p>A vector of strings containing updated model formulas for all Y nodes.</p>
</td></tr>
<tr><td><code>Anames</code></td>
<td>
<p>A vector of strings containing updated model formulas for all A nodes.</p>
</td></tr>
<tr><td><code>Cnames</code></td>
<td>
<p>A vector of strings containing updated model formulas for all C nodes.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+make.model.formulas">make.model.formulas</a></code>, <code><a href="#topic+model.update">model.update</a></code>, <code><a href="#topic+fit.updated.formulas">fit.updated.formulas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(EFV)

# first: generate generic model formulas
m &lt;- make.model.formulas(X=EFV,
                         Lnodes  = c("adherence.1","weight.1",
                                     "adherence.2","weight.2",
                                     "adherence.3","weight.3",
                                     "adherence.4","weight.4"
                                    ),
                         Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
                         Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
                         evaluate=FALSE) 
                         
# second: update these model formulas based on variable screening with LASSO
glmnet.formulas &lt;-  model.formulas.update(m$model.names, EFV)
glmnet.formulas 


# third: use these models for estimation
est &lt;- gformula(X=EFV,
                Lnodes  = c("adherence.1","weight.1",
                            "adherence.2","weight.2",
                            "adherence.3","weight.3",
                            "adherence.4","weight.4"
                ),
                Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
                Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
                Yform=glmnet.formulas$Ynames, Lform=glmnet.formulas$Lnames,
                abar=seq(0,2,1)
)
est

</code></pre>

<hr>
<h2 id='model.update'>Update GAM models</h2><span id='topic+model.update'></span>

<h3>Description</h3>

<p>A wrapper to simplify the update of GAM models</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.update(gam.object, form)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.update_+3A_gam.object">gam.object</code></td>
<td>

<p>A <code>gam</code> object produced with package <span class="pkg">mgcv</span>. 
</p>
</td></tr>
<tr><td><code id="model.update_+3A_form">form</code></td>
<td>

<p>A new model formula in the form <code>.~formula</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>gam</code> object needs to be fitted with the option control=list(keepData=T), otherwise the function can not access the data that is needed to update the model fit. Note that both <code><a href="#topic+fit.updated.formulas">fit.updated.formulas</a></code> and <code><a href="#topic+make.model.formulas">make.model.formulas</a></code> with option <code>evaluate=T</code> produce results that are based on this option.</p>


<h3>Value</h3>

<p>An object of <code>class</code> &lsquo;gam&rsquo;, &lsquo;glm&rsquo; and &lsquo;lm&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EFV)

m &lt;- make.model.formulas(X=EFV,
                         Lnodes  = c("adherence.1","weight.1",
                                     "adherence.2","weight.2",
                                     "adherence.3","weight.3",
                                     "adherence.4","weight.4"
                         ),
                         Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
                         Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
                         evaluate=TRUE) # set TRUE for model.update()

# update first confounder model of weight manually
model.update(m$fitted.models$fitted.L$m_weight.1, .~s(weight.0, by=sex))

# manual update of model formula
m$model.names$Lnames[2] &lt;- "weight.1 ~ s(weight.0, by=sex)" 

</code></pre>

<hr>
<h2 id='plot.gformula'>
Plot dose-response curves
</h2><span id='topic+plot.gformula'></span>

<h3>Description</h3>

<p>Function to plot dose-response curves based on results returned from <code><a href="#topic+gformula">gformula</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gformula'
plot(x, msm.method = c("line","loess", "gam", "none"), 
                        CI = FALSE, time.points = NULL, 
                        cols = NULL, weight = NULL,
                        survival = FALSE,variable = "psi", difference = FALSE,
                        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gformula_+3A_x">x</code></td>
<td>

<p>An object of <code>class</code> &lsquo;gformula&rsquo;.
</p>
</td></tr>
<tr><td><code id="plot.gformula_+3A_msm.method">msm.method</code></td>
<td>

<p>A string specifying the method to connect individual estimates into a curve (marginal structural model). One of <code>"line"</code>,<code>"none"</code>,<code>"gam"</code> and <code>"loess"</code>.</p>
</td></tr>
<tr><td><code id="plot.gformula_+3A_ci">CI</code></td>
<td>

<p>Logical. If TRUE, confidence bands are drawn; or confidence intervals for specific points if both <code>msm.method="none"</code> and appropriate.
</p>
</td></tr>
<tr><td><code id="plot.gformula_+3A_time.points">time.points</code></td>
<td>

<p>A vector of time points for which the respective curves should be drawn. Default is all time points.
</p>
</td></tr>
<tr><td><code id="plot.gformula_+3A_cols">cols</code></td>
<td>

<p>A vector of strings specifying custom colours for each drawn curve.
</p>
</td></tr>
<tr><td><code id="plot.gformula_+3A_weight">weight</code></td>
<td>

<p>Weight vector of size &quot;number of interventions times time points&quot;, that is used for the MSM if <code>msm.method="loess"</code> or <code>msm.method="gam"</code>.
</p>
</td></tr>
<tr><td><code id="plot.gformula_+3A_survival">survival</code></td>
<td>

<p>Logical. If TRUE, time refers to the x-axis (under the condition that it is indeed a survival setting).
</p>
</td></tr>
<tr><td><code id="plot.gformula_+3A_variable">variable</code></td>
<td>

<p>A string specifying the variable to be plotted under the natural course scenario (i.e., if <code>abar"natural"</code> and <code>cbar="natural"</code> in the respective <code>gformula</code> object). 
</p>
</td></tr>
<tr><td><code id="plot.gformula_+3A_difference">difference</code></td>
<td>

<p>Logical. If TRUE, differences of observed outcomes and outcomes under the natural intervention will be plotted (if <code>abar"natural"</code> and <code>cbar="natural"</code> in the respective <code>gformula</code> object.).
</p>
</td></tr>
<tr><td><code id="plot.gformula_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time points and variable names should be specified according to the labeling of the results table returned by <code><a href="#topic+gformula">gformula</a></code>.
</p>


<h3>Value</h3>

<p>Draws an object of <code>class</code> &lsquo;ggplot&rsquo;.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(EFV)
est &lt;- gformula(X=EFV,
                Lnodes  = c("adherence.1","weight.1",
                            "adherence.2","weight.2",
                            "adherence.3","weight.3",
                            "adherence.4","weight.4"
                ),
                Ynodes  = c("VL.0","VL.1","VL.2","VL.3","VL.4"),
                Anodes  = c("efv.0","efv.1","efv.2","efv.3","efv.4"),
                abar=seq(0,10,1)
)


plot(est)
plot(est, time.points=c(1,5))

</code></pre>

<hr>
<h2 id='print.gformula'>
Printing the results of a <code>gformula</code> object
</h2><span id='topic+print.gformula'></span>

<h3>Description</h3>

<p>Generic S3 function to print the results of an object created with <code><a href="#topic+gformula">gformula</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gformula'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gformula_+3A_x">x</code></td>
<td>
<p>An object of <code>class</code> &lsquo;gformula&rsquo;.
</p>
</td></tr>
<tr><td><code id="print.gformula_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for printing the results of an object of class <code>class</code> &lsquo;gformula&rsquo;.</p>

<hr>
<h2 id='prop'>Helper function to calculate proportions of categorical variables</h2><span id='topic+prop'></span>

<h3>Description</h3>

<p>To be used as <code>fun</code> argument in <code><a href="#topic+custom.measure">custom.measure</a></code>.</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_+3A_vec">vec</code></td>
<td>
<p>A vector with either numeric, logical or string elements.</p>
</td></tr>
<tr><td><code id="prop_+3A_categ">categ</code></td>
<td>
<p>A  numeric, logical or string vector of length 1, that refers to a particular category of <code>vec</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar numeric value of the proportion of <code>categ</code> values in <code>vec</code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
