<!DOCTYPE html><html><head><title>Help for package ldamatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ldamatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ldamatch-package'><p>ldamatch: Selection of Statistically Similar Research Groups.</p></a></li>
<li><a href='#.ad_crit'><p>Criterion function for ad_halt.</p></a></li>
<li><a href='#.apply_crit'><p>Returns smallest halting_test-threshold ratio, or 0 if less than 1.</p></a></li>
<li><a href='#.apply_crit_to_condition_pairs'><p>Returns smallest value from .apply_crit for all condition pairs.</p></a></li>
<li><a href='#.calc_multipliers'><p>Calculates multipliers used in search_random.</p></a></li>
<li><a href='#.calc_p_thresh_ratio'><p>Calculates p-value-threshold ratio.</p></a></li>
<li><a href='#.calc_subject_balance_divergence'><p>Characterizes closeness of actual group sizes to what is expected.</p></a></li>
<li><a href='#.check_subspaces_for_group_size_setup'><p>Searches over all possible subspaces for specified group size setup.</p></a></li>
<li><a href='#.choose_best_subjects'><p>Chooses best set of subjects in a set.</p></a></li>
<li><a href='#.choose_best_test_statistic'><p>Chooses rows with best test statistic.</p></a></li>
<li><a href='#.choose_most_frequently_chosen_subject_from_subject_tuples'><p>Chooses best one(s) of a set of subjects having the best p-value(s).</p></a></li>
<li><a href='#.choose_subject_with_best_p_value_from_subject_tuples'><p>Chooses best one(s) of a set of subjects having the best p-value(s).</p></a></li>
<li><a href='#.combine_sets'><p>Combines current best and candidate sets, keeping the highest metric value.</p></a></li>
<li><a href='#.create_Cartesian_iterable'><p>Creates Cartesian product of iterators.</p></a></li>
<li><a href='#.decrease_group_sizes'><p>Creates all group sizes by reducing one group in all rows of grpsizes.</p></a></li>
<li><a href='#.f_crit'><p>Criterion function for f_halt.</p></a></li>
<li><a href='#.flip_ind'><p>Flips logical vector at specified indices</p></a></li>
<li><a href='#.foreach'><p>Wrapper to foreach::foreach called from .choose_best_subjects.</p></a></li>
<li><a href='#.get_halting_test'><p>Returns halting tests for names, or checks if pass functions are suitable.</p></a></li>
<li><a href='#.get_human_readable'><p>Returns human readable format for number of seconds.</p></a></li>
<li><a href='#.get_if_args_are_missing'><p>Determines which arguments for a function, which is its caller by default.</p></a></li>
<li><a href='#.internally_compare_ldamatch_outputs'><p>Compares outputs of ldamatch runs using internally normalized parameters.</p></a></li>
<li><a href='#.ks_crit'><p>Criterion function for ks_halt.</p></a></li>
<li><a href='#.l_crit'><p>Criterion function for l_halt.</p></a></li>
<li><a href='#.normalize_max_removed_per_cond'><p>Normalizes max_removed_per_cond parameter for match_groups() and estimate_exhaustive().</p></a></li>
<li><a href='#.normalize_props'><p>Normalizes the props parameter for match_groups().</p></a></li>
<li><a href='#.recycle'><p>Recycles threshold values for halting tests.</p></a></li>
<li><a href='#.search_heuristic_with_lookahead'><p>Finds matching using depth-first search, looking ahead n steps.</p></a></li>
<li><a href='#.sort_group_sizes'><p>Orders rows by similarity to expected group size proportions.</p></a></li>
<li><a href='#.t_crit'><p>Criterion function for t_halt.</p></a></li>
<li><a href='#.tolerance'><p>An infinitesimally small amount, used to check if values are</p>
approximately the same.</a></li>
<li><a href='#.U_crit'><p>Criterion function for U_halt.</p></a></li>
<li><a href='#.unique_list'><p>Uniquifies a list.</p></a></li>
<li><a href='#.vector_list_to_string'><p>Creates string from list of vectors.</p></a></li>
<li><a href='#.warn_about_extra_params'><p>Warns about extra (i.e. unused) parameters.</p></a></li>
<li><a href='#ad_halt'><p>A univariate halting test using the Anderson-Darling test.</p></a></li>
<li><a href='#calc_metrics'><p>Calculates basic metrics about ldamatch search result.</p></a></li>
<li><a href='#calc_p_value'><p>Calculates p-value using specified halting test.</p></a></li>
<li><a href='#compare_ldamatch_outputs'><p>Compares outputs of ldamatch runs.</p></a></li>
<li><a href='#create_halting_test'><p>Creates halting test from multiple tests.</p></a></li>
<li><a href='#estimate_exhaustive'><p>Estimates the maximum number of cases to be checked during exhaustive search.</p></a></li>
<li><a href='#f_halt'><p>A univariate halting test using Fisher's exact test.</p></a></li>
<li><a href='#get_param'><p>Gets value for ldamatch global parameter.</p></a></li>
<li><a href='#ks_halt'><p>A univariate halting test using the Kolmogorov-Smirnov Test, which must be satisfied for all condition pairs.</p></a></li>
<li><a href='#l_halt'><p>A univariate halting test using Levene's test.</p></a></li>
<li><a href='#match_groups'><p>Creates a matched group via backward selection.</p></a></li>
<li><a href='#matching_methods'><p>The available methods for matching.</p></a></li>
<li><a href='#nondeterministic_matching_methods'><p>The available nondeterministic methods for matching.</p></a></li>
<li><a href='#parallelized_matching_methods'><p>The available parallelized methods for matching.</p></a></li>
<li><a href='#search_exhaustive'><p>Searches the space backwards, prefering more subjects and certain group size</p>
proportions.</a></li>
<li><a href='#search_heuristic2'><p>OBSOLETE: Finds matching using depth-first search recursively.</p></a></li>
<li><a href='#search_heuristic3'><p>Finds matching using depth-first search, looking ahead n steps.</p></a></li>
<li><a href='#search_heuristic4'><p>Finds matching using depth-first search, looking ahead n steps.</p></a></li>
<li><a href='#search_random'><p>Searches by randomly selecting subspaces with decreasing expected size.</p></a></li>
<li><a href='#set_param'><p>Sets value for ldamatch global parameter.</p></a></li>
<li><a href='#t_halt'><p>A univariate halting test using the t-test, which must be satisfied for all condition pairs.</p></a></li>
<li><a href='#U_halt'><p>A univariate halting test using the Wilcoxon test, which must be satisfied for all condition pairs.</p></a></li>
<li><a href='#wilks_halt'><p>A multivariate halting test appropriate for more than two condition levels.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Selection of Statistically Similar Research Groups</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Select statistically similar research groups by backward selection using various robust algorithms, including a heuristic based on linear discriminant analysis, multiple heuristics based on the test statistic, and parallelized exhaustive search.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, testthat, roxygen2, doParallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>RUnit, data.table, entropy, foreach, iterators, iterpc,
kSamples, stats, car, gmp, utils, methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-14 17:12:48 UTC; Kiss család</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyle Gorman [aut, cre],
  Géza Kiss [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyle Gorman &lt;kylebgorman@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-14 17:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ldamatch-package'>ldamatch: Selection of Statistically Similar Research Groups.</h2><span id='topic+ldamatch'></span><span id='topic+ldamatch-package'></span>

<h3>Description</h3>

<p>Select statistically similar research groups by backward selection
using various robust algorithms,
including a heuristic based on linear discriminant analysis,
multiple heuristics based on the test statistic,
and parallelized exhaustive search.
See the help for function <code><a href="#topic+match_groups">match_groups</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kyle Gorman <a href="mailto:kylebgorman@gmail.com">kylebgorman@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Géza Kiss <a href="mailto:kiss2017@alumni.ohsu.edu">kiss2017@alumni.ohsu.edu</a>
</p>
</li></ul>


<hr>
<h2 id='.ad_crit'>Criterion function for ad_halt.</h2><span id='topic+.ad_crit'></span>

<h3>Description</h3>

<p>Criterion function for ad_halt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ad_crit(covariate, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ad_crit_+3A_covariate">covariate</code></td>
<td>
<p>A vector containing a covariate to match the conditions on.</p>
</td></tr>
<tr><td><code id=".ad_crit_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value.
</p>

<hr>
<h2 id='.apply_crit'>Returns smallest halting_test-threshold ratio, or 0 if less than 1.</h2><span id='topic+.apply_crit'></span>

<h3>Description</h3>

<p>Returns smallest halting_test-threshold ratio, or 0 if less than 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.apply_crit(covariates, crit, condition, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".apply_crit_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id=".apply_crit_+3A_crit">crit</code></td>
<td>
<p>The criterion function to use, such as <code><a href="#topic+.t_crit">.t_crit</a></code>.</p>
</td></tr>
<tr><td><code id=".apply_crit_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id=".apply_crit_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of the p-value and the threshold, or 0 if the p-value is
less than the threshold.
</p>

<hr>
<h2 id='.apply_crit_to_condition_pairs'>Returns smallest value from .apply_crit for all condition pairs.</h2><span id='topic+.apply_crit_to_condition_pairs'></span>

<h3>Description</h3>

<p>Returns smallest value from .apply_crit for all condition pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.apply_crit_to_condition_pairs(covariates, crit, condition, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".apply_crit_to_condition_pairs_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id=".apply_crit_to_condition_pairs_+3A_crit">crit</code></td>
<td>
<p>The criterion function to use, such as <code><a href="#topic+.t_crit">.t_crit</a></code>.</p>
</td></tr>
<tr><td><code id=".apply_crit_to_condition_pairs_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id=".apply_crit_to_condition_pairs_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of the p-value and the threshold, or 0 if the p-value is
less than the threshold.
</p>

<hr>
<h2 id='.calc_multipliers'>Calculates multipliers used in search_random.</h2><span id='topic+.calc_multipliers'></span>

<h3>Description</h3>

<p>Derives multiplier for rcounts (the number of subjects that can be removed)
such that the proportion of the expected sizes of groups will be props.
The returned multipliers will be in the range of 0 to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.calc_multipliers(counts, rcounts, props)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".calc_multipliers_+3A_counts">counts</code></td>
<td>
<p>The number of subjects for each group.</p>
</td></tr>
<tr><td><code id=".calc_multipliers_+3A_rcounts">rcounts</code></td>
<td>
<p>The number of subjects that can be removed for each group.</p>
</td></tr>
<tr><td><code id=".calc_multipliers_+3A_props">props</code></td>
<td>
<p>The expected proportion of subjects for each group.</p>
</td></tr>
</table>

<hr>
<h2 id='.calc_p_thresh_ratio'>Calculates p-value-threshold ratio.</h2><span id='topic+.calc_p_thresh_ratio'></span>

<h3>Description</h3>

<p>Calculates p-value-threshold ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.calc_p_thresh_ratio(
  condition,
  covariates,
  halting_test,
  thresh,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".calc_p_thresh_ratio_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id=".calc_p_thresh_ratio_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id=".calc_p_thresh_ratio_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id=".calc_p_thresh_ratio_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id=".calc_p_thresh_ratio_+3A_silent">silent</code></td>
<td>
<p>If FALSE, prints warning when the test statistic cannot be
calculated; if TRUE (the default) they are not printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value-threshold ratio, or NA if the p-value could not be
calculated.
</p>
<p>The p-value / thresh ratio.
</p>

<hr>
<h2 id='.calc_subject_balance_divergence'>Characterizes closeness of actual group sizes to what is expected.</h2><span id='topic+.calc_subject_balance_divergence'></span>

<h3>Description</h3>

<p>Characterizes closeness of actual group sizes to what is expected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.calc_subject_balance_divergence(table_condition, props)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".calc_subject_balance_divergence_+3A_table_condition">table_condition</code></td>
<td>
<p>The number of different condition values,
usually created by calling table(condition).</p>
</td></tr>
<tr><td><code id=".calc_subject_balance_divergence_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>KL divergence of the actual group size proportions from the expected ones.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_groups">match_groups</a></code> for meaning of condition parameter.
</p>

<hr>
<h2 id='.check_subspaces_for_group_size_setup'>Searches over all possible subspaces for specified group size setup.</h2><span id='topic+.check_subspaces_for_group_size_setup'></span>

<h3>Description</h3>

<p>Results are optimized for the following, in decreasing order of preference:
number of subjects; proportion of group sizes close to props;
p-value as large as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_subspaces_for_group_size_setup(
  best,
  grpsize_setup,
  sspace,
  condition,
  covariates,
  halting_test,
  thresh,
  print_info
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_subspaces_for_group_size_setup_+3A_best">best</code></td>
<td>
<p>The best matched groups so far together with its
p-value / thresh ratio; a list containing ratio and sets
(a list of subject index vectors).</p>
</td></tr>
<tr><td><code id=".check_subspaces_for_group_size_setup_+3A_grpsize_setup">grpsize_setup</code></td>
<td>
<p>A set of group sizes as a data.table row (also a list).</p>
</td></tr>
<tr><td><code id=".check_subspaces_for_group_size_setup_+3A_sspace">sspace</code></td>
<td>
<p>An ordered subject subspace: a list of vectors,
with one vector per group containing the corresponding subject indices.</p>
</td></tr>
<tr><td><code id=".check_subspaces_for_group_size_setup_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id=".check_subspaces_for_group_size_setup_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id=".check_subspaces_for_group_size_setup_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id=".check_subspaces_for_group_size_setup_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id=".check_subspaces_for_group_size_setup_+3A_print_info">print_info</code></td>
<td>
<p>If TRUE, prints summary information on the input and the
results, as well as progress information for the
exhaustive search and random algorithms. Default: TRUE;
can be changed using
<code><a href="#topic+set_param">set_param</a>("PRINT_INFO", FALSE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of logical vectors for the best matched groups.
</p>

<hr>
<h2 id='.choose_best_subjects'>Chooses best set of subjects in a set.</h2><span id='topic+.choose_best_subjects'></span>

<h3>Description</h3>

<p>Chooses best set of subjects in a set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.choose_best_subjects(
  candidates,
  is.in,
  condition,
  covariates,
  halting_test,
  thresh,
  tiebreaker,
  props,
  prefer_test,
  max_removed_per_cond,
  max_removed_in_next_step,
  ratio_for_slowdown,
  remove_best_only
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".choose_best_subjects_+3A_candidates">candidates</code></td>
<td>
<p>An iterator returning (or a list containing)
indices for the is.in logical vector whose in / out status
is to be changed.</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_is.in">is.in</code></td>
<td>
<p>A logical vector showing which items are preserved
currently; versions resulting by changing indices for
each candidate are then compared.</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_prefer_test">prefer_test</code></td>
<td>
<p>If TRUE, prefers higher test statistic more than
the expected group size proportion; default is TRUE.
Used by all algorithms except exhaustive, which always</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>A named integer vector, containing the maximum number
of subjects that can be removed from each group.
Specify 0 for groups if you want to preserve
all of their subjects. If you do not specify a value
for a group, it defaults to 2 less than the group size.
Values outside the valid range of 0..(N-1)
(where N is the number of subjects in the group)
are corrected without a warning.</p>
</td></tr>
<tr><td><code id=".choose_best_subjects_+3A_ratio_for_slowdown">ratio_for_slowdown</code></td>
<td>
<p>The p-value / threshold ratio at which
it starts removing subjects one by one.
Used when max_removed_per_step &gt; 1,
with a default value of 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(inds): A list containing the best index vectors indicating the
positions to flip in is.in.
</p>

<hr>
<h2 id='.choose_best_test_statistic'>Chooses rows with best test statistic.</h2><span id='topic+.choose_best_test_statistic'></span>

<h3>Description</h3>

<p>Chooses rows with best test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.choose_best_test_statistic(
  dat,
  condition,
  covariates,
  halting_test,
  thresh,
  tiebreaker
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".choose_best_test_statistic_+3A_dat">dat</code></td>
<td>
<p>A data.table with an ind column with indices for items to
consider dropping.</p>
</td></tr>
<tr><td><code id=".choose_best_test_statistic_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id=".choose_best_test_statistic_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id=".choose_best_test_statistic_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id=".choose_best_test_statistic_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id=".choose_best_test_statistic_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing only the rows of dat with for best test
statistic values (decided primarily by halting_test, then by
tiebreaker).
</p>

<hr>
<h2 id='.choose_most_frequently_chosen_subject_from_subject_tuples'>Chooses best one(s) of a set of subjects having the best p-value(s).</h2><span id='topic+.choose_most_frequently_chosen_subject_from_subject_tuples'></span>

<h3>Description</h3>

<p>Used as first parameter of .search_heuristic_with_lookahead.
It chooses subject(s) for removal: the most frequently removed one(s);
among those, it prefers the one with the lowest p-value,
then chooses randomly among the remaining ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.choose_most_frequently_chosen_subject_from_subject_tuples(
  is.in,
  best_sets,
  look,
  condition,
  covariates,
  halting_test,
  thresh,
  tiebreaker,
  props,
  prefer_test,
  max_removed_per_cond,
  max_removed_in_next_step,
  ratio_for_slowdown,
  remove_best_only,
  print_info
)
</code></pre>


<h3>Value</h3>

<p>The table of counts for the chosen indices within is.in.
</p>

<hr>
<h2 id='.choose_subject_with_best_p_value_from_subject_tuples'>Chooses best one(s) of a set of subjects having the best p-value(s).</h2><span id='topic+.choose_subject_with_best_p_value_from_subject_tuples'></span>

<h3>Description</h3>

<p>Used as first parameter of .search_heuristic_with_lookahead.
It traces the best parents for a set of subjects to be removed back to the first level.
Note that the subject indices may not be unique: ones that occur in more configurations may be listed multiple times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.choose_subject_with_best_p_value_from_subject_tuples(
  is.in,
  best_sets,
  look,
  condition,
  covariates,
  halting_test,
  thresh,
  tiebreaker,
  props,
  prefer_test,
  max_removed_per_cond,
  max_removed_in_next_step,
  ratio_for_slowdown,
  remove_best_only,
  print_info
)
</code></pre>


<h3>Value</h3>

<p>The table of counts for the chosen indices within is.in.
</p>

<hr>
<h2 id='.combine_sets'>Combines current best and candidate sets, keeping the highest metric value.</h2><span id='topic+.combine_sets'></span>

<h3>Description</h3>

<p>Combines current best and candidate sets, keeping the highest metric value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.combine_sets(best, candidate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".combine_sets_+3A_best">best</code></td>
<td>
<p>A list(metric, sets); metric is a number, set is a list of
vectors.</p>
</td></tr>
<tr><td><code id=".combine_sets_+3A_candidate">candidate</code></td>
<td>
<p>A list(metric, set); metric is a number, set is a vector.
Candidate is only considered if metric is not zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the highest metric and a list of set values (sets).
</p>

<hr>
<h2 id='.create_Cartesian_iterable'>Creates Cartesian product of iterators.</h2><span id='topic+.create_Cartesian_iterable'></span>

<h3>Description</h3>

<p>Creates Cartesian product of iterators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.create_Cartesian_iterable(initializers, get_next, sspace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".create_Cartesian_iterable_+3A_initializers">initializers</code></td>
<td>
<p>A list of initializer functions (with no arguments)
for iterators.</p>
</td></tr>
<tr><td><code id=".create_Cartesian_iterable_+3A_get_next">get_next</code></td>
<td>
<p>A function for retrieving next item for an iterator
argument; it assumes that the iterator returns NULL
when finished.</p>
</td></tr>
<tr><td><code id=".create_Cartesian_iterable_+3A_sspace">sspace</code></td>
<td>
<p>elements to be used (a list of vectors)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that returns list of values, and stops with
&quot;StopIteration&quot; message when finished, so that it can be used with
the iterators::iter() function to create an iterator that works with
foreach.
</p>

<hr>
<h2 id='.decrease_group_sizes'>Creates all group sizes by reducing one group in all rows of grpsizes.</h2><span id='topic+.decrease_group_sizes'></span>

<h3>Description</h3>

<p>Used for generating all group size combinations for one specific total size
iteratively, starting from grpsizes with one row containing original group
sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.decrease_group_sizes(grpsizes, grpnames, minpergrp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".decrease_group_sizes_+3A_grpsizes">grpsizes</code></td>
<td>
<p>A data.table with the columns containing the group names,
and the rows containing a particular setup of group sizes.
All rows are expected to have the same sum (not checked).</p>
</td></tr>
<tr><td><code id=".decrease_group_sizes_+3A_grpnames">grpnames</code></td>
<td>
<p>The group names (specified because the table can have other
columns as well).</p>
</td></tr>
<tr><td><code id=".decrease_group_sizes_+3A_minpergrp">minpergrp</code></td>
<td>
<p>The minimum number of subjects to be preserved per group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with the same format as grpsizes, containing all
possible group setups totaling to one less than the total in grpsizes.
</p>

<hr>
<h2 id='.f_crit'>Criterion function for f_halt.</h2><span id='topic+.f_crit'></span>

<h3>Description</h3>

<p>Criterion function for f_halt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.f_crit(covariate, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".f_crit_+3A_covariate">covariate</code></td>
<td>
<p>A vector containing a covariate to match the conditions on.</p>
</td></tr>
<tr><td><code id=".f_crit_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value.
</p>

<hr>
<h2 id='.flip_ind'>Flips logical vector at specified indices</h2><span id='topic+.flip_ind'></span>

<h3>Description</h3>

<p>Flips logical vector at specified indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.flip_ind(ind, is.in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".flip_ind_+3A_ind">ind</code></td>
<td>
<p>Integer indices for the is.in logical vector.</p>
</td></tr>
<tr><td><code id=".flip_ind_+3A_is.in">is.in</code></td>
<td>
<p>A logical vector showing which items are preserved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector identical to is.in except for indices in ind where
it is is.in negated.
</p>

<hr>
<h2 id='.foreach'>Wrapper to foreach::foreach called from .choose_best_subjects.</h2><span id='topic+.foreach'></span>

<h3>Description</h3>

<p>Wrapper to foreach::foreach called from .choose_best_subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.foreach(
  input,
  operation,
  preprocess_input,
  .init,
  .combine,
  max_chunk_size = get("PROCESSED_CHUNK_SIZE", .ldamatch_globals),
  print_progress = get("PRINT_PROGRESS", .ldamatch_globals)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".foreach_+3A_input">input</code></td>
<td>
<p>An iterator created using either the iterpc or the iterators
package, or anything else foreach::foreach can interpret (esp. a list).</p>
</td></tr>
<tr><td><code id=".foreach_+3A_operation">operation</code></td>
<td>
<p>The operation to be performed for each item in input
(possibly after preprocessing it; see preprocess_input).</p>
</td></tr>
<tr><td><code id=".foreach_+3A_preprocess_input">preprocess_input</code></td>
<td>
<p>Processes each value retrieved from the input iterator.</p>
</td></tr>
<tr><td><code id=".foreach_+3A_.init">.init</code>, <code id=".foreach_+3A_.combine">.combine</code></td>
<td>
<p>The same as the parameters of foreach::foreach
with identical names.</p>
</td></tr>
<tr><td><code id=".foreach_+3A_max_chunk_size">max_chunk_size</code></td>
<td>
<p>The maximum number of items to be retrieved from input
if it is an iterator.</p>
</td></tr>
<tr><td><code id=".foreach_+3A_print_progress">print_progress</code></td>
<td>
<p>If TRUE, prints messages about the progress.
</p>
<p>Used to use iterpc::iter_wrapper() on iterpc iterators, but realized that
foreach doesn't handle iterators in a nice way (converts it to a list, which
may be huge, instead of gradually retrieving the contensts), so feeding
segments of the iterators to foreach instead.</p>
</td></tr>
</table>

<hr>
<h2 id='.get_halting_test'>Returns halting tests for names, or checks if pass functions are suitable.</h2><span id='topic+.get_halting_test'></span>

<h3>Description</h3>

<p>Returns halting tests for names, or checks if pass functions are suitable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_halting_test(halting_test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_halting_test_+3A_halting_test">halting_test</code></td>
<td>
<p>The name of one halting test, or a halting test function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of halting test functions.
</p>

<hr>
<h2 id='.get_human_readable'>Returns human readable format for number of seconds.</h2><span id='topic+.get_human_readable'></span>

<h3>Description</h3>

<p>Returns human readable format for number of seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_human_readable(seconds, num_decimals = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_human_readable_+3A_seconds">seconds</code></td>
<td>
<p>The number of seconds to convert to human-readable form.</p>
</td></tr>
<tr><td><code id=".get_human_readable_+3A_num_decimals">num_decimals</code></td>
<td>
<p>The number of decimals to print in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing &quot;&lt;number&gt; seconds/minutes/hours/days/years&quot;.
</p>

<hr>
<h2 id='.get_if_args_are_missing'>Determines which arguments for a function, which is its caller by default.</h2><span id='topic+.get_if_args_are_missing'></span>

<h3>Description</h3>

<p>Determines which arguments for a function, which is its caller by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_if_args_are_missing(fun = sys.function(-1), ncall = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_if_args_are_missing_+3A_fun">fun</code></td>
<td>
<p>A function; default: the caller.</p>
</td></tr>
<tr><td><code id=".get_if_args_are_missing_+3A_ncall">ncall</code></td>
<td>
<p>The parent frame index; default: 3 (the great-grandparent).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named boolean vector that contains whether each argument is missing.
</p>

<hr>
<h2 id='.internally_compare_ldamatch_outputs'>Compares outputs of ldamatch runs using internally normalized parameters.</h2><span id='topic+.internally_compare_ldamatch_outputs'></span>

<h3>Description</h3>

<p>Compares outputs of ldamatch runs using internally normalized parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.internally_compare_ldamatch_outputs(
  is.in1,
  is.in2,
  condition,
  covariates,
  halting_test,
  props,
  prefer_test,
  tiebreaker
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".internally_compare_ldamatch_outputs_+3A_is.in1">is.in1</code></td>
<td>
<p>A logical vector for output 1, TRUE iff row is in the match.</p>
</td></tr>
<tr><td><code id=".internally_compare_ldamatch_outputs_+3A_is.in2">is.in2</code></td>
<td>
<p>A logical vector for output 2, TRUE iff row is in the match.</p>
</td></tr>
<tr><td><code id=".internally_compare_ldamatch_outputs_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id=".internally_compare_ldamatch_outputs_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id=".internally_compare_ldamatch_outputs_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id=".internally_compare_ldamatch_outputs_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id=".internally_compare_ldamatch_outputs_+3A_prefer_test">prefer_test</code></td>
<td>
<p>If TRUE, it prioritizes the test statistic more than
the group size proportion.</p>
</td></tr>
<tr><td><code id=".internally_compare_ldamatch_outputs_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number that is &gt; 0 if is.in1 is a better solution than is.in2,
&lt; 0 if is.in1 is a worse solution than is.in2, or
0 if the two solutions are equivalent (not necessarily identical).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare_ldamatch_outputs">compare_ldamatch_outputs</a></code> for operation and meaning of
parameters.
</p>

<hr>
<h2 id='.ks_crit'>Criterion function for ks_halt.</h2><span id='topic+.ks_crit'></span>

<h3>Description</h3>

<p>Warnings such as &quot;cannot compute exact p-value with ties&quot; are suppressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ks_crit(covariate, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ks_crit_+3A_covariate">covariate</code></td>
<td>
<p>A vector containing a covariate to match the conditions on.</p>
</td></tr>
<tr><td><code id=".ks_crit_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value.
</p>

<hr>
<h2 id='.l_crit'>Criterion function for l_halt.</h2><span id='topic+.l_crit'></span>

<h3>Description</h3>

<p>Warnings such as &quot;ANOVA F-tests on an essentially perfect fit are unreliable&quot;
are suppressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.l_crit(covariate, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".l_crit_+3A_covariate">covariate</code></td>
<td>
<p>A vector containing a covariate to match the conditions on.</p>
</td></tr>
<tr><td><code id=".l_crit_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value.
</p>

<hr>
<h2 id='.normalize_max_removed_per_cond'>Normalizes max_removed_per_cond parameter for match_groups() and estimate_exhaustive().</h2><span id='topic+.normalize_max_removed_per_cond'></span>

<h3>Description</h3>

<p>Normalizes max_removed_per_cond parameter for match_groups() and estimate_exhaustive().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.normalize_max_removed_per_cond(max_removed_per_cond, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".normalize_max_removed_per_cond_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>A named integer vector, containing the maximum number
of subjects that can be removed from each group.
Specify 0 for groups if you want to preserve
all of their subjects. If you do not specify a value
for a group, it defaults to 2 less than the group size.
Values outside the valid range of 0..(N-1)
(where N is the number of subjects in the group)
are corrected without a warning.</p>
</td></tr>
<tr><td><code id=".normalize_max_removed_per_cond_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
</table>

<hr>
<h2 id='.normalize_props'>Normalizes the props parameter for match_groups().</h2><span id='topic+.normalize_props'></span>

<h3>Description</h3>

<p>Normalizes the props parameter for match_groups().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.normalize_props(props, condition, keep_last_item = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".normalize_props_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id=".normalize_props_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id=".normalize_props_+3A_keep_last_item">keep_last_item</code></td>
<td>
<p>If TRUE and props is a character vector, last item is not dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector: if props contains proportions, it is the same, but
ordered to follow the levels of condition; if props contains names of
conditions, the total number of subjects for the condition names in props.
</p>

<hr>
<h2 id='.recycle'>Recycles threshold values for halting tests.</h2><span id='topic+.recycle'></span>

<h3>Description</h3>

<p>Recycles threshold values for halting tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.recycle(ts, hs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".recycle_+3A_ts">ts</code></td>
<td>
<p>Threshold value(s).</p>
</td></tr>
<tr><td><code id=".recycle_+3A_hs">hs</code></td>
<td>
<p>Halting tests.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with one threshold value per halting test.
</p>

<hr>
<h2 id='.search_heuristic_with_lookahead'>Finds matching using depth-first search, looking ahead n steps.</h2><span id='topic+.search_heuristic_with_lookahead'></span>

<h3>Description</h3>

<p>In each step, it removes one subject from the set of subjects with the
smallest associated p-value after &quot;lookahead&quot; steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.search_heuristic_with_lookahead(
  choose_from_subject_tuples,
  condition,
  covariates,
  halting_test,
  thresh,
  props,
  max_removed_per_cond,
  tiebreaker = NULL,
  min_preserved = length(levels(condition)),
  lookahead = 2,
  prefer_test = TRUE,
  print_info = TRUE,
  max_removed_per_step = 1,
  max_removed_percent_per_step = 0.5,
  ratio_for_slowdown = 0.5,
  given_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>The maximum number of subjects that can be removed from
each group. It must have a valid number for each group.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_min_preserved">min_preserved</code></td>
<td>
<p>The minimum number of preserved subjects.
It can be used to ensure that the search will not take
forever to run, but instead fail when a solution is not
found when preserving this number of subjects.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_lookahead">lookahead</code></td>
<td>
<p>The lookahead to use: a positive integer.
It is used by the heuristic3 and heuristic4 algorithms,
with a default of 2.
The running time is O(N ^ lookahead), wheren N is the
number of subjects.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_prefer_test">prefer_test</code></td>
<td>
<p>If TRUE, prefers higher test statistic more than
the expected group size proportion; default is TRUE.
Used by all algorithms except exhaustive, which always</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_print_info">print_info</code></td>
<td>
<p>If TRUE, prints summary information on the input and the
results, as well as progress information for the
exhaustive search and random algorithms. Default: TRUE;
can be changed using
<code><a href="#topic+set_param">set_param</a>("PRINT_INFO", FALSE)</code>.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_max_removed_per_step">max_removed_per_step</code></td>
<td>
<p>The number of equivalent subjects
that can be removed in each step. (The actual allowed
number may be less depending on the p-value / theshold ratio.)
This parameters is used by the heuristic3 and heuristic4
algorithms, with a default value of 1.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_max_removed_percent_per_step">max_removed_percent_per_step</code></td>
<td>
<p>The percentage of remaining subjects
that can be removed in each step.
Used when max_removed_per_step &gt; 1,
with a default value of 0.5.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_ratio_for_slowdown">ratio_for_slowdown</code></td>
<td>
<p>The p-value / threshold ratio at which
it starts removing subjects one by one.
Used when max_removed_per_step &gt; 1,
with a default value of 0.5.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_given_args">given_args</code></td>
<td>
<p>The names of arguments given to the search function.</p>
</td></tr>
<tr><td><code id=".search_heuristic_with_lookahead_+3A_...">...</code></td>
<td>
<p>Consumes extra parameters that are not used by the
search algorithm at hand; this function gives a warning
about the ones whose value is not NULL that their value
is not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All results found by search method in a list. It raises a
&quot;Convergence failure&quot; error if it cannot find a matched set.
</p>

<hr>
<h2 id='.sort_group_sizes'>Orders rows by similarity to expected group size proportions.</h2><span id='topic+.sort_group_sizes'></span>

<h3>Description</h3>

<p>Orders rows by similarity to expected group size proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sort_group_sizes(grpsizes, grpnames, props)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sort_group_sizes_+3A_grpsizes">grpsizes</code></td>
<td>
<p>A data.table with the columns containing the group names,
and the rows containing a particular setup of group sizes.
All rows are expected to have the same sum (not checked).</p>
</td></tr>
<tr><td><code id=".sort_group_sizes_+3A_grpnames">grpnames</code></td>
<td>
<p>The group names (specified because the table can have other
columns as well).</p>
</td></tr>
<tr><td><code id=".sort_group_sizes_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
</table>

<hr>
<h2 id='.t_crit'>Criterion function for t_halt.</h2><span id='topic+.t_crit'></span>

<h3>Description</h3>

<p>Criterion function for t_halt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.t_crit(covariate, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".t_crit_+3A_covariate">covariate</code></td>
<td>
<p>A vector containing a covariate to match the conditions on.</p>
</td></tr>
<tr><td><code id=".t_crit_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value.
</p>

<hr>
<h2 id='.tolerance'>An infinitesimally small amount, used to check if values are
approximately the same.</h2><span id='topic+.tolerance'></span>

<h3>Description</h3>

<p>An infinitesimally small amount, used to check if values are
approximately the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.tolerance
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1.
</p>

<hr>
<h2 id='.U_crit'>Criterion function for U_halt.</h2><span id='topic+.U_crit'></span>

<h3>Description</h3>

<p>Criterion function for U_halt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.U_crit(covariate, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".U_crit_+3A_covariate">covariate</code></td>
<td>
<p>A vector containing a covariate to match the conditions on.</p>
</td></tr>
<tr><td><code id=".U_crit_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value.
</p>

<hr>
<h2 id='.unique_list'>Uniquifies a list.</h2><span id='topic+.unique_list'></span>

<h3>Description</h3>

<p>Uniquifies a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.unique_list(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".unique_list_+3A_l">l</code></td>
<td>
<p>A list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unique list items.
</p>

<hr>
<h2 id='.vector_list_to_string'>Creates string from list of vectors.</h2><span id='topic+.vector_list_to_string'></span>

<h3>Description</h3>

<p>Creates string from list of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vector_list_to_string(lv, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".vector_list_to_string_+3A_lv">lv</code></td>
<td>
<p>A list of vectors.</p>
</td></tr>
<tr><td><code id=".vector_list_to_string_+3A_sep">sep</code></td>
<td>
<p>A string to be inserted between the name of a vector item and
its value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>

<hr>
<h2 id='.warn_about_extra_params'>Warns about extra (i.e. unused) parameters.</h2><span id='topic+.warn_about_extra_params'></span>

<h3>Description</h3>

<p>Warns about extra (i.e. unused) parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.warn_about_extra_params(given_args = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".warn_about_extra_params_+3A_given_args">given_args</code></td>
<td>
<p>The names of arguments given to the search function.</p>
</td></tr>
<tr><td><code id=".warn_about_extra_params_+3A_...">...</code></td>
<td>
<p>Consumes extra parameters that are not used by the
search algorithm at hand; this function gives a warning
about the ones whose value is not NULL that their value
is not used.</p>
</td></tr>
</table>

<hr>
<h2 id='ad_halt'>A univariate halting test using the Anderson-Darling test.</h2><span id='topic+ad_halt'></span>

<h3>Description</h3>

<p>A univariate halting test using the Anderson-Darling test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ad_halt(condition, covariates, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ad_halt_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="ad_halt_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="ad_halt_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of the p-value and the threshold, or 0 if the p-value is
less than the threshold.
</p>

<hr>
<h2 id='calc_metrics'>Calculates basic metrics about ldamatch search result.</h2><span id='topic+calc_metrics'></span>

<h3>Description</h3>

<p>Calculates basic metrics about ldamatch search result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_metrics(
  is.in,
  condition,
  covariates,
  halting_test,
  props = prop.table(table(condition)),
  tiebreaker = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_metrics_+3A_is.in">is.in</code></td>
<td>
<p>The output of <code><a href="#topic+match_groups">match_groups</a>()</code>:
either a logical vector, or a list of those.</p>
</td></tr>
<tr><td><code id="calc_metrics_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="calc_metrics_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="calc_metrics_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id="calc_metrics_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id="calc_metrics_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing: </p>

<dl>
<dt>all.is.in</dt><dd><p>all results as a list;</p>
</dd>
<dt>is.in</dt><dd><p>simply the first item in all.is.in or the error contained
in is.in if there was an error running <code><a href="#topic+match_groups">match_groups</a></code>;</p>
</dd>
<dt>num_excluded</dt><dd><p>the number of excluded subjects;</p>
</dd>
<dt>p_matched</dt><dd><p>the test statistic from halting_test for the matched groups;</p>
</dd>
<dt>p_tiebreaker</dt><dd><p>the test statistic from tiebreaker for the matched groups; and</p>
</dd>
<dt>balance_divergence</dt><dd><p>a value characterizing the deviation
from the expected group size proportions specified in props.</p>
</dd>
</dl>

<p>If the value for a field cannot be calculated, it will still be present
with a value of NA.
</p>

<hr>
<h2 id='calc_p_value'>Calculates p-value using specified halting test.</h2><span id='topic+calc_p_value'></span>

<h3>Description</h3>

<p>Calculates p-value using specified halting test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_p_value(condition, covariates, halting_test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_p_value_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="calc_p_value_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="calc_p_value_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value.
</p>

<hr>
<h2 id='compare_ldamatch_outputs'>Compares outputs of ldamatch runs.</h2><span id='topic+compare_ldamatch_outputs'></span>

<h3>Description</h3>

<p>It favors, in decreasing order of priority, fewer excluded subjects,
better balance (i.e. subsamples that diverge less from the expected
proportions, which are by default the proportions of the input groups), and
better (i.e. larger) test statistic for the matched groups.
The preference order for the last two items can be reversed by specifying
prefer_test = TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_ldamatch_outputs(
  is.in1,
  is.in2,
  condition,
  covariates = matrix(),
  halting_test = NA,
  props = prop.table(table(condition)),
  prefer_test = is.null(props),
  tiebreaker = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_ldamatch_outputs_+3A_is.in1">is.in1</code></td>
<td>
<p>A logical vector for output 1, TRUE iff row is in the match.</p>
</td></tr>
<tr><td><code id="compare_ldamatch_outputs_+3A_is.in2">is.in2</code></td>
<td>
<p>A logical vector for output 2, TRUE iff row is in the match.</p>
</td></tr>
<tr><td><code id="compare_ldamatch_outputs_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="compare_ldamatch_outputs_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="compare_ldamatch_outputs_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id="compare_ldamatch_outputs_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id="compare_ldamatch_outputs_+3A_prefer_test">prefer_test</code></td>
<td>
<p>If TRUE, it prioritizes the test statistic more than
the group size proportion.</p>
</td></tr>
<tr><td><code id="compare_ldamatch_outputs_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number that is &gt; 0 if is.in1 is a better solution than is.in2,
&lt; 0 if is.in1 is a worse solution than is.in2, or
0 if the two solutions are equivalent (not necessarily identical).
</p>

<hr>
<h2 id='create_halting_test'>Creates halting test from multiple tests.</h2><span id='topic+create_halting_test'></span>

<h3>Description</h3>

<p>The created halting test function returns the smallest p-value-to-threshold
ratio of the values produced by the supplied tests, or zero if any of the
p-values does not exceed the threshold. The resulting function expects one
threshold per halting test in a vector or it recycles the given value(s) to
get a threshold for each one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_halting_test(halting_tests)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_halting_test_+3A_halting_tests">halting_tests</code></td>
<td>
<p>Either a vector of halting test functions
(or function names) with the signature
halting_test(condition, covariates, thresh)
(for the meaning of the parameters see
<code><a href="#topic+match_groups">match_groups</a></code>); or it may be a list of
list(test = halting_test, cond = subset_of_conditions,
cov = variable_selector, thresh) fields.
All fields can be left out except test, and test need
not be named if it is the first item in the list.
The subset_of_conditions can be names of the
conditions to match (a character vector or a factor).
The variable_selector can be a logical vector with as
many items as there will be columns in covariates
(recommended), or a vector of integer covariate
column indices.
Each halting_test is then only applied to the
specified subset of conditions and variables of the
covariate matrix, with the specified threshold; when
a value is not specified the defaults are used.
Note that ordering the functions does not change the
behavior, but can make the execution of the combined
function faster, as the later ones are often evaluated
only if the criteria for the earlier ones are met.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that returns the minimum of all halting test values;
the threshold value supplied to it is recycled for the individual
functions.
</p>

<hr>
<h2 id='estimate_exhaustive'>Estimates the maximum number of cases to be checked during exhaustive search.</h2><span id='topic+estimate_exhaustive'></span>

<h3>Description</h3>

<p>Estimates the maximum number of cases to be checked during exhaustive search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_exhaustive(
  min_preserved = sum(group_sizes),
  condition,
  cases_per_second = 100,
  print_info = TRUE,
  max_removed_per_cond = NULL,
  group_sizes = NULL,
  props = prop.table(table(condition)),
  max_cases = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_exhaustive_+3A_min_preserved">min_preserved</code></td>
<td>
<p>Assumes that at least a total of this many subjects
will be preserved.</p>
</td></tr>
<tr><td><code id="estimate_exhaustive_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="estimate_exhaustive_+3A_cases_per_second">cases_per_second</code></td>
<td>
<p>Assumes that this number of cases are checked out
per second, for estimating the time it takes to run
the exhaustive search; default: 100.</p>
</td></tr>
<tr><td><code id="estimate_exhaustive_+3A_print_info">print_info</code></td>
<td>
<p>If TRUE, prints partial calculations as well for
the number of cases and estimated time when removing
1, 2, ... subjects.</p>
</td></tr>
<tr><td><code id="estimate_exhaustive_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>A named integer vector, containing the maximum number
of subjects that can be removed from each group.
Specify 0 for groups if you want to preserve
all of their subjects. If you do not specify a value
for a group, it defaults to 2 less than the group size.
Values outside the valid range of 0..(N-1)
(where N is the number of subjects in the group)
are corrected without a warning.</p>
</td></tr>
<tr><td><code id="estimate_exhaustive_+3A_group_sizes">group_sizes</code></td>
<td>
<p>A particular set of group sizes that we know a
matched solution for; min_preserved need not be
specified if this one is.</p>
</td></tr>
<tr><td><code id="estimate_exhaustive_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.</p>
</td></tr>
<tr><td><code id="estimate_exhaustive_+3A_max_cases">max_cases</code></td>
<td>
<p>Once it is certain that the number of cases is
definitely above this number, calculation stops. In this case,
the returned number is guaranteed to be larger than max_cases,
but it is not the exact number of exhaustive cases.
Default is infimum, i.e. the exact number of cases is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The maximum number of cases: an integer if not greater than the
maximum integer size (.Machine$integer.max), otherwise a Big Integer
(see the gmp package).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>estimate_exhaustive(58, as.factor(c(rep("ALN", 25), rep("TD", 44))))
estimate_exhaustive(84, as.factor(c(rep("ASD", 51), rep("TD", 44))))

</code></pre>

<hr>
<h2 id='f_halt'>A univariate halting test using Fisher's exact test.</h2><span id='topic+f_halt'></span>

<h3>Description</h3>

<p>A univariate halting test using Fisher's exact test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_halt(condition, covariates, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_halt_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="f_halt_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="f_halt_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of the p-value and the threshold, or 0 if the p-value is
less than the threshold.
</p>

<hr>
<h2 id='get_param'>Gets value for ldamatch global parameter.</h2><span id='topic+get_param'></span>

<h3>Description</h3>

<p>Gets value for ldamatch global parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_param(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_param_+3A_name">name</code></td>
<td>
<p>The name of the global parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the global parameter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_param">set_param</a></code> for parameter names.
</p>

<hr>
<h2 id='ks_halt'>A univariate halting test using the Kolmogorov-Smirnov Test, which must be satisfied for all condition pairs.</h2><span id='topic+ks_halt'></span>

<h3>Description</h3>

<p>The condition must have two levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks_halt(condition, covariates, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks_halt_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="ks_halt_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="ks_halt_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that unlike many tests, the null hypothesis is that the two samples are
are drawn from the same distribution.
</p>
<p>Warnings such as &quot;cannot compute exact p-value with ties&quot; are suppressed.
</p>


<h3>Value</h3>

<p>The ratio of the p-value and the threshold, or 0 if the p-value is
less than the threshold. If there are more than two conditions,
it returns the smallest value found for any condition pair.
</p>

<hr>
<h2 id='l_halt'>A univariate halting test using Levene's test.</h2><span id='topic+l_halt'></span>

<h3>Description</h3>

<p>Warnings such as &quot;ANOVA F-tests on an essentially perfect fit are unreliable&quot;
are suppressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_halt(condition, covariates, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_halt_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="l_halt_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="l_halt_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of the p-value and the threshold, or 0 if the p-value is
less than the threshold.
</p>

<hr>
<h2 id='match_groups'>Creates a matched group via backward selection.</h2><span id='topic+match_groups'></span>

<h3>Description</h3>

<p>Creates a matched group via backward selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_groups(
  condition,
  covariates,
  halting_test,
  thresh = 0.2,
  method = ldamatch::matching_methods,
  props = prop.table(table(condition)),
  replicates = get("RND_DEFAULT_REPLICATES", .ldamatch_globals),
  min_preserved = length(levels(condition)),
  print_info = get("PRINT_INFO", .ldamatch_globals),
  max_removed_per_cond = NULL,
  tiebreaker = NULL,
  lookahead = 2,
  all_results = FALSE,
  prefer_test = TRUE,
  max_removed_per_step = 1,
  max_removed_percent_per_step = 0.5,
  ratio_for_slowdown = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_groups_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_method">method</code></td>
<td>
<p>The choice of search method, one of &quot;random&quot;,
You can get more information about each method on the
help page for &quot;search_&lt;method_name&gt;&quot;
(e.g. &quot;<code><a href="#topic+search_exhaustive">search_exhaustive</a></code>&quot;).</p>
</td></tr>
<tr><td><code id="match_groups_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_replicates">replicates</code></td>
<td>
<p>The maximum number of random replications to be
performed. This is only used for the &quot;random&quot;
method.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_min_preserved">min_preserved</code></td>
<td>
<p>The minimum number of preserved subjects.
It can be used to ensure that the search will not take
forever to run, but instead fail when a solution is not
found when preserving this number of subjects.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_print_info">print_info</code></td>
<td>
<p>If TRUE, prints summary information on the input and the
results, as well as progress information for the
exhaustive search and random algorithms. Default: TRUE;
can be changed using
<code><a href="#topic+set_param">set_param</a>("PRINT_INFO", FALSE)</code>.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>A named integer vector, containing the maximum number
of subjects that can be removed from each group.
Specify 0 for groups if you want to preserve
all of their subjects. If you do not specify a value
for a group, it defaults to 2 less than the group size.
Values outside the valid range of 0..(N-1)
(where N is the number of subjects in the group)
are corrected without a warning.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_lookahead">lookahead</code></td>
<td>
<p>The lookahead to use: a positive integer.
It is used by the heuristic3 and heuristic4 algorithms,
with a default of 2.
The running time is O(N ^ lookahead), wheren N is the
number of subjects.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_all_results">all_results</code></td>
<td>
<p>If TRUE, returns all results found by method in a list.
(A list is returned even if there is only one result.)
If FALSE (the default), it returns the first result
(a logical vector).</p>
</td></tr>
<tr><td><code id="match_groups_+3A_prefer_test">prefer_test</code></td>
<td>
<p>If TRUE, prefers higher test statistic more than
the expected group size proportion; default is TRUE.
Used by all algorithms except exhaustive, which always</p>
</td></tr>
<tr><td><code id="match_groups_+3A_max_removed_per_step">max_removed_per_step</code></td>
<td>
<p>The number of equivalent subjects
that can be removed in each step. (The actual allowed
number may be less depending on the p-value / theshold ratio.)
This parameters is used by the heuristic3 and heuristic4
algorithms, with a default value of 1.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_max_removed_percent_per_step">max_removed_percent_per_step</code></td>
<td>
<p>The percentage of remaining subjects
that can be removed in each step.
Used when max_removed_per_step &gt; 1,
with a default value of 0.5.</p>
</td></tr>
<tr><td><code id="match_groups_+3A_ratio_for_slowdown">ratio_for_slowdown</code></td>
<td>
<p>The p-value / threshold ratio at which
it starts removing subjects one by one.
Used when max_removed_per_step &gt; 1,
with a default value of 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exhaustive, heuristic3, and heuristic4 search methods use the foreach
package to parallelize computation.
To take advantage of this, you must register a cluster.
For example, to use all but one of the CPU cores, run:
<code>doParallel::registerDoParallel(cores = max(1, parallel::detectCores() - 1))</code>
To use sequential processing without getting a warning, run:
<code>foreach::registerDoSEQ()</code>
</p>


<h3>Value</h3>

<p>A logical vector that contains TRUE for the conditions
that are in the matched groups;
or if all_results = TRUE, a list of such vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_p_value">calc_p_value</a></code> for calculating the test statistic for
a group setup.
</p>
<p><code><a href="#topic+calc_metrics">calc_metrics</a></code> for calculating multiple metrics about
the goodness of the result.
</p>
<p><code><a href="#topic+compare_ldamatch_outputs">compare_ldamatch_outputs</a></code> for comparing multiple
different results from this function.
</p>
<p><code><a href="#topic+search_heuristic2">search_heuristic2</a>, <a href="#topic+search_heuristic3">search_heuristic3</a>, <a href="#topic+search_heuristic4">search_heuristic4</a>, <a href="#topic+search_random">search_random</a>, <a href="#topic+search_exhaustive">search_exhaustive</a></code> for
</p>

<hr>
<h2 id='matching_methods'>The available methods for matching.</h2><span id='topic+matching_methods'></span>

<h3>Description</h3>

<p>The available methods for matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matching_methods
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 5.
</p>

<hr>
<h2 id='nondeterministic_matching_methods'>The available nondeterministic methods for matching.</h2><span id='topic+nondeterministic_matching_methods'></span>

<h3>Description</h3>

<p>The available nondeterministic methods for matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nondeterministic_matching_methods
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 3.
</p>

<hr>
<h2 id='parallelized_matching_methods'>The available parallelized methods for matching.</h2><span id='topic+parallelized_matching_methods'></span>

<h3>Description</h3>

<p>The available parallelized methods for matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallelized_matching_methods
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 3.
</p>

<hr>
<h2 id='search_exhaustive'>Searches the space backwards, prefering more subjects and certain group size
proportions.</h2><span id='topic+search_exhaustive'></span>

<h3>Description</h3>

<p>Searches the space backwards, prefering more subjects and certain group size
proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_exhaustive(
  condition,
  covariates,
  halting_test,
  thresh,
  props,
  max_removed_per_cond,
  tiebreaker = NULL,
  min_preserved = length(levels(condition)),
  print_info = TRUE,
  given_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_exhaustive_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>The maximum number of subjects that can be removed from
each group. It must have a valid number for each group.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_min_preserved">min_preserved</code></td>
<td>
<p>The minimum number of preserved subjects.
It can be used to ensure that the search will not take
forever to run, but instead fail when a solution is not
found when preserving this number of subjects.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_print_info">print_info</code></td>
<td>
<p>If TRUE, prints summary information on the input and the
results, as well as progress information for the
exhaustive search and random algorithms. Default: TRUE;
can be changed using
<code><a href="#topic+set_param">set_param</a>("PRINT_INFO", FALSE)</code>.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_given_args">given_args</code></td>
<td>
<p>The names of arguments given to the search function.</p>
</td></tr>
<tr><td><code id="search_exhaustive_+3A_...">...</code></td>
<td>
<p>Consumes extra parameters that are not used by the
search algorithm at hand; this function gives a warning
about the ones whose value is not NULL that their value
is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the search is done in parallel, the search space is enormous and so
it can be very slow in the worst case. It is perhaps most useful as a tool
to study other matching procedures.
</p>
<p>You can calculate the maximum possible number of cases to evaluate by
calling estimate_exhaustive().
</p>


<h3>Value</h3>

<p>All results found by search method in a list. It raises a
&quot;Convergence failure&quot; error if it cannot find a matched set.
</p>

<hr>
<h2 id='search_heuristic2'>OBSOLETE: Finds matching using depth-first search recursively.</h2><span id='topic+search_heuristic2'></span>

<h3>Description</h3>

<p>Please use the heuristic3 search algorithm with lookahead=1 instead
for nearly equivalent results. Note that heuristic3 is parallelized,
more memory efficient, and chooses subject to remove randomly from among
equivalent choices instead of choosing the first one deterministically.
This function is implemented recursively, so may run out of memory when
applied to many subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_heuristic2(
  condition,
  covariates,
  halting_test,
  thresh,
  props,
  max_removed_per_cond,
  tiebreaker = NULL,
  prefer_test = TRUE,
  print_info = TRUE,
  given_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_heuristic2_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>The maximum number of subjects that can be removed from
each group. It must have a valid number for each group.</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_prefer_test">prefer_test</code></td>
<td>
<p>If TRUE, prefers higher test statistic more than
the expected group size proportion; default is TRUE.
Used by all algorithms except exhaustive, which always</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_print_info">print_info</code></td>
<td>
<p>If TRUE, prints summary information on the input and the
results, as well as progress information for the
exhaustive search and random algorithms. Default: TRUE;
can be changed using
<code><a href="#topic+set_param">set_param</a>("PRINT_INFO", FALSE)</code>.</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_given_args">given_args</code></td>
<td>
<p>The names of arguments given to the search function.</p>
</td></tr>
<tr><td><code id="search_heuristic2_+3A_...">...</code></td>
<td>
<p>Consumes extra parameters that are not used by the
search algorithm at hand; this function gives a warning
about the ones whose value is not NULL that their value
is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In each step, it removes one subject from the set of subjects with
the smallest p-value recursively.
</p>


<h3>Value</h3>

<p>All results found by search method in a list. It raises a
&quot;Convergence failure&quot; error if it cannot find a matched set.
</p>

<hr>
<h2 id='search_heuristic3'>Finds matching using depth-first search, looking ahead n steps.</h2><span id='topic+search_heuristic3'></span>

<h3>Description</h3>

<p>In each step, it removes one subject from the set of subjects with the
smallest associated p-value after &quot;lookahead&quot; steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_heuristic3(
  condition,
  covariates,
  halting_test,
  thresh,
  props,
  max_removed_per_cond,
  tiebreaker = NULL,
  min_preserved = length(levels(condition)),
  lookahead = 2,
  prefer_test = TRUE,
  print_info = TRUE,
  max_removed_per_step = 1,
  max_removed_percent_per_step = 0.5,
  ratio_for_slowdown = 0.5,
  given_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_heuristic3_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>The maximum number of subjects that can be removed from
each group. It must have a valid number for each group.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_min_preserved">min_preserved</code></td>
<td>
<p>The minimum number of preserved subjects.
It can be used to ensure that the search will not take
forever to run, but instead fail when a solution is not
found when preserving this number of subjects.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_lookahead">lookahead</code></td>
<td>
<p>The lookahead to use: a positive integer.
It is used by the heuristic3 and heuristic4 algorithms,
with a default of 2.
The running time is O(N ^ lookahead), wheren N is the
number of subjects.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_prefer_test">prefer_test</code></td>
<td>
<p>If TRUE, prefers higher test statistic more than
the expected group size proportion; default is TRUE.
Used by all algorithms except exhaustive, which always</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_print_info">print_info</code></td>
<td>
<p>If TRUE, prints summary information on the input and the
results, as well as progress information for the
exhaustive search and random algorithms. Default: TRUE;
can be changed using
<code><a href="#topic+set_param">set_param</a>("PRINT_INFO", FALSE)</code>.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_max_removed_per_step">max_removed_per_step</code></td>
<td>
<p>The number of equivalent subjects
that can be removed in each step. (The actual allowed
number may be less depending on the p-value / theshold ratio.)
This parameters is used by the heuristic3 and heuristic4
algorithms, with a default value of 1.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_max_removed_percent_per_step">max_removed_percent_per_step</code></td>
<td>
<p>The percentage of remaining subjects
that can be removed in each step.
Used when max_removed_per_step &gt; 1,
with a default value of 0.5.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_ratio_for_slowdown">ratio_for_slowdown</code></td>
<td>
<p>The p-value / threshold ratio at which
it starts removing subjects one by one.
Used when max_removed_per_step &gt; 1,
with a default value of 0.5.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_given_args">given_args</code></td>
<td>
<p>The names of arguments given to the search function.</p>
</td></tr>
<tr><td><code id="search_heuristic3_+3A_...">...</code></td>
<td>
<p>Consumes extra parameters that are not used by the
search algorithm at hand; this function gives a warning
about the ones whose value is not NULL that their value
is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this algorithm is not deterministic, as it chooses one possible
path randomly when there are multiple apparently equivalent ones. In practice
this means that it may return different results on different runs (including
the case that it fails to converge to a solution in one run, but converges in
another run). If print_info = TRUE (the default), you will see a message
about &quot;Random choices&quot; if the algorithm needed to make random path choices.
</p>


<h3>Value</h3>

<p>All results found by search method in a list. It raises a
&quot;Convergence failure&quot; error if it cannot find a matched set.
</p>

<hr>
<h2 id='search_heuristic4'>Finds matching using depth-first search, looking ahead n steps.</h2><span id='topic+search_heuristic4'></span>

<h3>Description</h3>

<p>In each step, it removes one subject from the set of subjects that were
removed on most paths after &quot;lookahead&quot; steps, preferring one with the
smallest associate p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_heuristic4(
  condition,
  covariates,
  halting_test,
  thresh,
  props,
  max_removed_per_cond,
  tiebreaker = NULL,
  min_preserved = length(levels(condition)),
  lookahead = 2,
  prefer_test = TRUE,
  print_info = TRUE,
  max_removed_per_step = 1,
  max_removed_percent_per_step = 0.5,
  ratio_for_slowdown = 0.5,
  given_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_heuristic4_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>The maximum number of subjects that can be removed from
each group. It must have a valid number for each group.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_min_preserved">min_preserved</code></td>
<td>
<p>The minimum number of preserved subjects.
It can be used to ensure that the search will not take
forever to run, but instead fail when a solution is not
found when preserving this number of subjects.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_lookahead">lookahead</code></td>
<td>
<p>The lookahead to use: a positive integer.
It is used by the heuristic3 and heuristic4 algorithms,
with a default of 2.
The running time is O(N ^ lookahead), wheren N is the
number of subjects.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_prefer_test">prefer_test</code></td>
<td>
<p>If TRUE, prefers higher test statistic more than
the expected group size proportion; default is TRUE.
Used by all algorithms except exhaustive, which always</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_print_info">print_info</code></td>
<td>
<p>If TRUE, prints summary information on the input and the
results, as well as progress information for the
exhaustive search and random algorithms. Default: TRUE;
can be changed using
<code><a href="#topic+set_param">set_param</a>("PRINT_INFO", FALSE)</code>.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_max_removed_per_step">max_removed_per_step</code></td>
<td>
<p>The number of equivalent subjects
that can be removed in each step. (The actual allowed
number may be less depending on the p-value / theshold ratio.)
This parameters is used by the heuristic3 and heuristic4
algorithms, with a default value of 1.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_max_removed_percent_per_step">max_removed_percent_per_step</code></td>
<td>
<p>The percentage of remaining subjects
that can be removed in each step.
Used when max_removed_per_step &gt; 1,
with a default value of 0.5.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_ratio_for_slowdown">ratio_for_slowdown</code></td>
<td>
<p>The p-value / threshold ratio at which
it starts removing subjects one by one.
Used when max_removed_per_step &gt; 1,
with a default value of 0.5.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_given_args">given_args</code></td>
<td>
<p>The names of arguments given to the search function.</p>
</td></tr>
<tr><td><code id="search_heuristic4_+3A_...">...</code></td>
<td>
<p>Consumes extra parameters that are not used by the
search algorithm at hand; this function gives a warning
about the ones whose value is not NULL that their value
is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this algorithm is not deterministic, as it chooses one possible
subject for removal randomly when there are multiple apparently equivalent ones.
In practice it means that it may return different results on different runs
(including the case that it fails to converge to a solution in one run,
but converges in another run). If print_info = TRUE (the default), you will
see a message about &quot;Random choices&quot; if the algorithm needed to make such
random decisions.
</p>


<h3>Value</h3>

<p>All results found by search method in a list. It raises a
&quot;Convergence failure&quot; error if it cannot find a matched set.
</p>

<hr>
<h2 id='search_random'>Searches by randomly selecting subspaces with decreasing expected size.</h2><span id='topic+search_random'></span>

<h3>Description</h3>

<p>Searches by randomly selecting subspaces with decreasing expected size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_random(
  condition,
  covariates,
  halting_test,
  thresh,
  props,
  max_removed_per_cond,
  tiebreaker = NULL,
  replicates,
  prefer_test = TRUE,
  print_info = TRUE,
  given_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_random_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="search_random_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="search_random_+3A_halting_test">halting_test</code></td>
<td>
<p>A function to apply to 'covariates' (in matrix form)
which is TRUE iff the conditions are matched.
Signature: halting_test(condition, covariates, thresh).
The following halting tests are part of this package:
<code><a href="#topic+t_halt">t_halt</a></code>, <code><a href="#topic+U_halt">U_halt</a></code>,
<code><a href="#topic+l_halt">l_halt</a></code>, <code><a href="#topic+ad_halt">ad_halt</a></code>,
<code><a href="#topic+ks_halt">ks_halt</a></code>, <code><a href="#topic+wilks_halt">wilks_halt</a></code>,
<code><a href="#topic+f_halt">f_halt</a></code>.
You can create the intersection of two or more halting
tests using <code><a href="#topic+create_halting_test">create_halting_test</a></code>.</p>
</td></tr>
<tr><td><code id="search_random_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
<tr><td><code id="search_random_+3A_props">props</code></td>
<td>
<p>Either the desired proportions (percentage) of the
sample for each condition as a named vector,
or the names of the conditions
for which we prefer to preserve the subjects,
in decreasing order of preference. If not specified, the
(full) sample proportions are used.
This is preferred among configurations with the same
taken into account by the other methods to some extent.
For example, c(A = 0.4, B = 0.4, C = 0.2) means that
we would like the number of subjects in groups A, B, and
C to be around 40%, 40%, and 20% of the total number of
subjects, respectively. Whereas c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) means
that if possible, we would like to keep all subjects
in group A, and prefer keeping subjects in B, even if
it results in losing more subjects from C.</p>
</td></tr>
<tr><td><code id="search_random_+3A_max_removed_per_cond">max_removed_per_cond</code></td>
<td>
<p>The maximum number of subjects that can be removed from
each group. It must have a valid number for each group.</p>
</td></tr>
<tr><td><code id="search_random_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>NULL, or a function similar to halting_test, used to
decide between cases for which halting_test yields
equal values.</p>
</td></tr>
<tr><td><code id="search_random_+3A_replicates">replicates</code></td>
<td>
<p>The maximum number of random replications to be
performed. This is only used for the &quot;random&quot;
method.</p>
</td></tr>
<tr><td><code id="search_random_+3A_prefer_test">prefer_test</code></td>
<td>
<p>If TRUE, prefers higher test statistic more than
the expected group size proportion; default is TRUE.
Used by all algorithms except exhaustive, which always</p>
</td></tr>
<tr><td><code id="search_random_+3A_print_info">print_info</code></td>
<td>
<p>If TRUE, prints summary information on the input and the
results, as well as progress information for the
exhaustive search and random algorithms. Default: TRUE;
can be changed using
<code><a href="#topic+set_param">set_param</a>("PRINT_INFO", FALSE)</code>.</p>
</td></tr>
<tr><td><code id="search_random_+3A_given_args">given_args</code></td>
<td>
<p>The names of arguments given to the search function.</p>
</td></tr>
<tr><td><code id="search_random_+3A_...">...</code></td>
<td>
<p>Consumes extra parameters that are not used by the
search algorithm at hand; this function gives a warning
about the ones whose value is not NULL that their value
is not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All results found by search method in a list. It raises a
</p>

<hr>
<h2 id='set_param'>Sets value for ldamatch global parameter.</h2><span id='topic+set_param'></span>

<h3>Description</h3>

<p>Sets value for ldamatch global parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_param(name, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_param_+3A_name">name</code></td>
<td>
<p>The name of the global parameter.</p>
</td></tr>
<tr><td><code id="set_param_+3A_value">value</code></td>
<td>
<p>The new value of the global parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the available parameters:
</p>

<dl>
<dt>RND_DEFAULT_REPLICATES</dt><dd><p>random search: default number of replicates</p>
</dd>
<dt>Anderson-Darling test parameters; see kSamples::ad.test for explanation</dt><dd>

<dl>
<dt>AD_METHOD</dt><dd><p>the method parameter for ad.test; default: asymptotic</p>
</dd>
<dt>AD_NSIM</dt><dd><p>the Nsim parameter for ad.test, used when AD_METHOD is 'simulated'; default: 10000</p>
</dd>
<dt>AD_VERSION</dt><dd><p>1 or 2 for the two versions of the test statistic; default: 1</p>
</dd>
</dl>

</dd>
<dt>PRINT_INFO</dt><dd><p>print summary information, and progress information for
the exhaustive search algorithm</p>
</dd>
<dt>PRINT_PROGRESS</dt><dd><p>whether to print progress information about parallel processing of cases</p>
</dd>
<dt>PROCESSED_CHUNK_SIZE</dt><dd><p>the number of cases to be retrieved at a time from iterators for parallel processing</p>
</dd>
</dl>



<h3>Value</h3>

<p>The previous value of the global parameter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_param">get_param</a></code> for retrieving the current value of a
parameter.
</p>

<hr>
<h2 id='t_halt'>A univariate halting test using the t-test, which must be satisfied for all condition pairs.</h2><span id='topic+t_halt'></span>

<h3>Description</h3>

<p>A univariate halting test using the t-test, which must be satisfied for all condition pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_halt(condition, covariates, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_halt_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="t_halt_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="t_halt_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of the p-value and the threshold, or 0 if the p-value is
less than the threshold. If there are more than two conditions,
it returns the smallest value found for any condition pair.
</p>

<hr>
<h2 id='U_halt'>A univariate halting test using the Wilcoxon test, which must be satisfied for all condition pairs.</h2><span id='topic+U_halt'></span>

<h3>Description</h3>

<p>A univariate halting test using the Wilcoxon test, which must be satisfied for all condition pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>U_halt(condition, covariates, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="U_halt_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="U_halt_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="U_halt_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of the p-value and the threshold, or 0 if the p-value is
less than the threshold. If there are more than two conditions,
it returns the smallest value found for any condition pair.
</p>

<hr>
<h2 id='wilks_halt'>A multivariate halting test appropriate for more than two condition levels.</h2><span id='topic+wilks_halt'></span>

<h3>Description</h3>

<p>A multivariate halting test appropriate for more than two condition levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilks_halt(condition, covariates, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilks_halt_+3A_condition">condition</code></td>
<td>
<p>A factor vector containing condition labels.</p>
</td></tr>
<tr><td><code id="wilks_halt_+3A_covariates">covariates</code></td>
<td>
<p>A columnwise matrix containing
covariates to match the conditions on.</p>
</td></tr>
<tr><td><code id="wilks_halt_+3A_thresh">thresh</code></td>
<td>
<p>The return value of halting_test has to be greater than
or equal to thresh for the matched groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of the p-value and the threshold, or 0 if the p-value is
less than the threshold.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
