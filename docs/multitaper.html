<!DOCTYPE html><html lang="en"><head><title>Help for package multitaper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multitaper}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#centre'><p>Centres (converts to zero-mean) the time series.</p></a></li>
<li><a href='#CETdaily'><p>Central England Temperature daily time series</p></a></li>
<li><a href='#CETmonthly'><p>Central England Temperature monthly time series</p></a></li>
<li><a href='#demod.dpss'><p>Computes complex demodulates using multiple taper techniques</p></a></li>
<li><a href='#dpss'><p>Compute Discrete Prolate Spheroidal Sequences</p></a></li>
<li><a href='#dpssToEigenvalues'><p>Compute eigenvalues for the Discrete Prolate Spheroidal Sequences</p>
(dpss)</a></li>
<li><a href='#dropFreqs'><p>Truncate mtm or mtm.coh Objects in Frequency</p></a></li>
<li><a href='#HadCRUTnh'><p>HadCRUT Land Temperature Anomaly (Northern Hemisphere) Series</p></a></li>
<li><a href='#mlco2'><p>Mauna Loa Observatory CO2 Monthly Averages</p></a></li>
<li><a href='#mtm.coh'><p>Compute and plot the multitaper magnitude-squared coherence.</p></a></li>
<li><a href='#multitaperTrend'><p>Estimate Linear Trend using Multitaper Techniques</p></a></li>
<li><a href='#percivalAR4'><p>Auto Regressive Series generated by Don Percival at Applied</p>
Physics Laboratory</a></li>
<li><a href='#plot.mtm'><p>Compute and plot the multitaper spectrum estimate</p></a></li>
<li><a href='#plot.mtm.coh'><p>Compute and plot the multitaper magnitude-squared coherence.</p></a></li>
<li><a href='#sineTaper'><p>Computes sine tapers</p></a></li>
<li><a href='#spec.mtm'><p>Compute and plot multitaper spectrum estimates</p></a></li>
<li><a href='#willamette'><p>Willamette River time series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Spectral Analysis Tools using the Multitaper Method</td>
</tr>
<tr>
<td>Author:</td>
<td>Karim Rahim &lt;karim.rahim@queensu.ca&gt;, Wesley S. Burr &lt;wesleyburr@trentu.ca&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karim Rahim &lt;karim.rahim@queensu.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>psd, fftwtools, slp</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements multitaper spectral analysis using discrete prolate spheroidal sequences (Slepians) and sine tapers. It includes an adaptive weighted multitaper spectral estimate, a coherence estimate, Thomson's Harmonic F-test, and complex demodulation. The Slepians sequences are generated efficiently using a tridiagonal matrix solution, and jackknifed confidence intervals are available for most estimates. This package is an implementation of the method described in D.J. Thomson (1982) "Spectrum estimation and harmonic analysis" &lt;<a href="https://doi.org/10.1109%2FPROC.1982.12433">doi:10.1109/PROC.1982.12433</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/krahim/multitaper/">https://github.com/krahim/multitaper/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-20 11:37:23 UTC; karim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-20 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='centre'>Centres (converts to zero-mean) the time series.</h2><span id='topic+centre'></span>

<h3>Description</h3>

<p>Centres the data using an expansion on the Slepian sequences if the bandwidth
parameter (nw) and number of tapers (k) is specified, otherwise
subtracts the mean or robust trimmed mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centre(x, nw = NULL, k = NULL, deltaT = NULL, trim = 0)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centre_+3A_x">x</code></td>
<td>
<p>The data as a vector or as a time series.</p>
</td></tr>
<tr><td><code id="centre_+3A_nw">nw</code></td>
<td>
<p>The Slepian bandwidth parameter, typically between 2.0 and 6.0.</p>
</td></tr>
<tr><td><code id="centre_+3A_k">k</code></td>
<td>
<p>The number of Slepian tapers used, often 2*nw.</p>
</td></tr>
<tr><td><code id="centre_+3A_deltat">deltaT</code></td>
<td>
<p>Parameter required if the data is a vector and not a time
series, and only for the Slepian case.</p>
</td></tr>
<tr><td><code id="centre_+3A_trim">trim</code></td>
<td>
<p>[only used if nw and k are not specified]
The fraction (0 to 0.5) of observations to be trimmed from
each end of &lsquo;x&rsquo; before the mean is computed.  Values of trim
outside that range are taken as the nearest endpoint.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>
Volume <b>70</b>, number 9, pp. 1055&ndash;1096.
</p>
<p>Slepian, D. (1978)
Prolate spheroidal wave functions, Fourier analysis, and
uncertainty. V&ndash;The discrete case. <em>Bell System Technical Journal</em>
Volume <b>57</b>, pp. 1371&ndash;1430.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(willamette)
cent.Slepian &lt;- centre(willamette, nw=4, k=8, deltaT=1)
cent.Trim &lt;- centre(willamette, trim=0.2)
</code></pre>

<hr>
<h2 id='CETdaily'>Central England Temperature daily time series</h2><span id='topic+CETdaily'></span>

<h3>Description</h3>

<p>Central England Temperature daily time series from the Hadley Centre United Kingdom
Meteorological Office, http://www.metoffice.gov.uk/hadobs/hadcet/.
The data set represents daily CET values recorded to the tenth of a degree Celsius, 
and contains temperatures for the years 1772 through September 30, 2011.
This dataset was retrieved from the Met office at Hadley on Oct 1, 2011.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CETdaily</code></pre>


<h3>Format</h3>

<p> A data frame indicating the year, month, day, and temperature 
observed in Central England. This data-set contains 87566
observations.</p>

<hr>
<h2 id='CETmonthly'>Central England Temperature monthly time series</h2><span id='topic+CETmonthly'></span>

<h3>Description</h3>

<p>Central England Temperature monthly time series from the Hadley Centre United Kingdom
Meteorological Office, http://www.metoffice.gov.uk/hadobs/hadcet/.
The data set represents monthly CET temperature values recorded to the nearest 
tenth of a degree Celsius, and containing records for January 1659 through December 2011.
This dataset was retrieved from the Met office at Hadley on Mar 10, 2012.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CETmonthly</code></pre>


<h3>Format</h3>

<p> A data frame indicating the year, month and temperature 
observed in Central England. This data-set contains 4237
observations.
</p>


<h3>References</h3>

<p>Parker DE, Horton EB (2005). Uncertainties in central England
temperature 1878-2003 and some improvements to the maximum and minimum
series. <em>Int. J. Climatol</em>. 25: 1173&ndash;1188.
</p>

<hr>
<h2 id='demod.dpss'>Computes complex demodulates using multiple taper techniques</h2><span id='topic+demod.dpss'></span>

<h3>Description</h3>

<p>Computes complex demodulate of a given series around a given central
frequency using multiple taper techniques. Returns amplitude, phase,
and complex demodulate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demod.dpss(x,centreFreq,nw,blockLen,stepSize=1,wrapphase=TRUE,...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="demod.dpss_+3A_x">x</code></td>
<td>
<p>Time series, required to be contiguous.</p>
</td></tr>
<tr><td><code id="demod.dpss_+3A_centrefreq">centreFreq</code></td>
<td>
<p>Frequency around which to demodulate.</p>
</td></tr>
<tr><td><code id="demod.dpss_+3A_nw">nw</code></td>
<td>
<p>Parameter controlling time-bandwidth.</p>
</td></tr>
<tr><td><code id="demod.dpss_+3A_blocklen">blockLen</code></td>
<td>
<p>Length of sub-block to use; demodulate is computed on 
each block in turn.</p>
</td></tr>
<tr><td><code id="demod.dpss_+3A_stepsize">stepSize</code></td>
<td>
<p>This is a proposed option that sets the index step
size between blocks. Currently this must be set to 1 and
changes in step size have not been implemented.</p>
</td></tr>
<tr><td><code id="demod.dpss_+3A_wrapphase">wrapphase</code></td>
<td>
<p>If true, routine wraps phases around +/-360 degree 
boundaries.</p>
</td></tr>
<tr><td><code id="demod.dpss_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently only includes depreciated arguments</p>
</td></tr>
</table>


<h3>References</h3>

<p>Thomson, D.J. (1995). The Seasons, Global Temperature, and Precession. 
<em>Science</em>, Volume 268, pp. 59&ndash;68.
</p>
<p>Bloomfield P. (2000). Fourier Analysis of Time Series. 2nd
edition. Wiley New York, pp. 97&ndash;130.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CETmonthly)
nJulOff &lt;- 1175
xd &lt;- ts(CETmonthly[,"temp"],deltat=1/12)
demodYr &lt;- demod.dpss(xd,centreFreq=1,nw=3,blockLen=120,stepSize=1)
phase &lt;- demodYr$phase
offsJul &lt;- 3*360/365 
phaseAdj &lt;- phase
phaseAdj[1:nJulOff] &lt;- phase[1:nJulOff] + offsJul
yr &lt;- (time(xd)+1658)[1:length(phase)]
plot(yr, phaseAdj, type="l", lwd=2,
     ylab="Phase of the Year in Degrees",
     xlab="Gegorian calender date")
lines((1:nJulOff)/12+1659, phase[1:nJulOff], col="red")
fit &lt;- lm( phaseAdj ~ yr)
abline(fit, lty=2, col="blue")
cat(paste("Precession Estimate: ",fit$coef[2]*60*60,digits=6," (arcseconds/yr)\n",sep=""))
</code></pre>

<hr>
<h2 id='dpss'>Compute Discrete Prolate Spheroidal Sequences</h2><span id='topic+dpss'></span>

<h3>Description</h3>

<p>Compute Discrete Prolate Spheroidal (Slepian) Sequences for use as
tapers or other applications. This function uses the tridiagonal method and exploits
symmetry. Note the odd order tapers are normalized so that the slope at the
centre is positive in accordance with Slepian (1978) and Thomson (1982). This
differs from Percival and Walden (1993). This code follows section
(8.3) of Percival and Walden (1993) using LAPACK function calls Anderson (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpss(n,k,nw, returnEigenvalues=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpss_+3A_n">n</code></td>
<td>
<p>A positive integer, typically the non-zero-padded length of the time series.</p>
</td></tr>
<tr><td><code id="dpss_+3A_k">k</code></td>
<td>
<p>A positive integer, the number of tapers, often 2*nw for spectrum estimation purposes.</p>
</td></tr>
<tr><td><code id="dpss_+3A_nw">nw</code></td>
<td>
<p>A positive double-precision number, the time-bandwidth
parameter.</p>
</td></tr>
<tr><td><code id="dpss_+3A_returneigenvalues">returnEigenvalues</code></td>
<td>
<p>If true the appropriate eigenvalues are
calculated and returned using the function dpssToEigenvalues. If
FALSE, the eigenvalues returned are from the LAPACK function DSTEBZ
using the tridiagonal. See section 8.3 of Percival and Walden (1993), or equation (13) in Slepian (1978).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>v</code></td>
<td>
<p>A n by k matrix of Slepian Sequences. Each column represents
the Slepian sequence of order k-1.</p>
</td></tr>
<tr><td><code>eigen</code></td>
<td>
<p>A length k vector of eigenvalues corresponding to
equation (13) in Slepian (1978), or the eigenvalues of the input
tridiagonal matrix returned from the internal call to the LAPACK function DSTEBZ.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Anderson, E. (1999).
<em>LAPACK Users' guide (Vol. 9).</em>
Siam.
</p>
<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications.</em>
Cambridge University Press.
</p>
<p>Slepian, D. (1978)
Prolate spheroidal wave functions, Fourier analysis, and
uncertainty. V&ndash;The discrete case. <em>Bell System Technical Journal</em>
Volume <b>57</b>, pp. 1371&ndash;1430
</p>
<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>
Volume <b>70</b>, number 9, pp. 1055&ndash;1096.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dpss(10,4,4.0)
dpss(100,8,5.0)
</code></pre>

<hr>
<h2 id='dpssToEigenvalues'>Compute eigenvalues for the Discrete Prolate Spheroidal Sequences
(dpss)</h2><span id='topic+dpssToEigenvalues'></span>

<h3>Description</h3>

<p>Compute eigenvalues for the Discrete Prolate Spheroidal Sequences. The
method used here is described in Chapter 8 of Percival and Walden (1993).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpssToEigenvalues(v, nw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpssToEigenvalues_+3A_v">v</code></td>
<td>
<p>A matrix of dpss's, with each column representing a sequence of a
different order, 1 to k.</p>
</td></tr>
<tr><td><code id="dpssToEigenvalues_+3A_nw">nw</code></td>
<td>
<p>A positive double-precision number, the time-bandwidth
parameter.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications.</em>
Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dpss1 &lt;- dpss(10,4,4.0, returnEigenvalues=FALSE)$v
dpssToEigenvalues(dpss1,4.0)
</code></pre>

<hr>
<h2 id='dropFreqs'>Truncate mtm or mtm.coh Objects in Frequency</h2><span id='topic+dropFreqs'></span><span id='topic+dropFreqs.default'></span><span id='topic+dropFreqs.spec'></span><span id='topic+dropFreqs.mtm'></span><span id='topic+dropFreqs.mtm.coh'></span>

<h3>Description</h3>

<p>A utility function to truncate the frequencies in a spectral
estimate. This utility is used before calling plot(), to increase the
visual frequency resolution of a plot by truncating frequencies outside a
particular band of interest. This function is not a filter, but rather
a utility to allow R to 'zoom' a spectrum plot to a certain frequency band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropFreqs(spec, minFreq, maxFreq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropFreqs_+3A_spec">spec</code></td>
<td>
<p>A spectrum object 'obj', of class spec, mtm, or mtm.coh.</p>
</td></tr>
<tr><td><code id="dropFreqs_+3A_minfreq">minFreq</code></td>
<td>
<p>The lower bound for the frequency band to be retained, 
in the same units as the obj$freq array.</p>
</td></tr>
<tr><td><code id="dropFreqs_+3A_maxfreq">maxFreq</code></td>
<td>
<p>The upper bound for the frequency band to be retained,
also in the same units as the obj$freq array.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(willamette)
mtm1 &lt;- spec.mtm(willamette, nw=4.0, k=8, plot=FALSE, deltat=1.0, dtUnits="month")
mtm2 &lt;- dropFreqs(mtm1, 0.1, 0.4)
plot(mtm2)

# another option
plot(dropFreqs(mtm1, 0.1, 0.4))

# using sine tapers
mtm.sine &lt;- spec.mtm(willamette, k=10, plot=FALSE, deltat=1.0, dtUnits="month", 
                     taper="sine", sineAdaptive=FALSE, sineSmoothFact=0.05)
plot(dropFreqs(mtm.sine, 0.1, 0.4))                     
</code></pre>

<hr>
<h2 id='HadCRUTnh'>HadCRUT Land Temperature Anomaly (Northern Hemisphere) Series</h2><span id='topic+HadCRUTnh'></span>

<h3>Description</h3>

<p>Hadley Climate Research Unit Temperature anomaly (Northern Hemisphere) 
time series. Consists of monthly observations, truncated to start at
March 1958 and extend to September 2009, to match mlco2 dataset.
This dataset was retrieved from the Hadley CRU on Oct 1, 2011.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HadCRUTnh</code></pre>


<h3>Format</h3>

<p> A data frame indicating the year, month and temperature anomaly 
for the Northern Hemisphere, between 1958 and 2009.</p>

<hr>
<h2 id='mlco2'>Mauna Loa Observatory CO2 Monthly Averages</h2><span id='topic+mlco2'></span>

<h3>Description</h3>

<p>Observations of monthly CO2 atmospheric concentration averages from the 
Mauna Loa Observatory, Mauna Loa, Hawaii, USA. Obtained from the ESRL
Global Monitoring Division of the National Oceanic and Atmospheric Administration
at http://www.esrl.noaa.gov/gmd/dv/data/index.php?parameter_name=Carbon%2BDioxide. 
Dataset downloaded Oct 1, 2011.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlco2</code></pre>


<h3>Format</h3>

<p> A data frame indicating the year, month and atmospheric concentration 
of CO2 in PPM.</p>

<hr>
<h2 id='mtm.coh'>Compute and plot the multitaper magnitude-squared coherence.</h2><span id='topic+mtm.coh'></span>

<h3>Description</h3>

<p>Computes and plots the adaptive multitaper spectrum estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtm.coh(mtm1, mtm2, fr=NULL, tau=0, phcorr = TRUE, plot=TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mtm.coh_+3A_mtm1">mtm1</code></td>
<td>
<p>An object created with spec.mtm(... ,returnInternals=TRUE).</p>
</td></tr>
<tr><td><code id="mtm.coh_+3A_mtm2">mtm2</code></td>
<td>
<p>An object created with spec.mtm(... ,returnInternals=TRUE). 
Note mtm1 and mtm2 must be created with the same frequency resolution. 
They both must have the same values for nFFT and returnZeroFreq.</p>
</td></tr> 
<tr><td><code id="mtm.coh_+3A_fr">fr</code></td>
<td>
<p>The frequency values for the mtm object. This can be null by
default (which results in computation for the full frequency range) or 
it can be a subset of frequency values.</p>
</td></tr>
<tr><td><code id="mtm.coh_+3A_tau">tau</code></td>
<td>
<p>Phase-correction factor, if known.</p>
</td></tr>
<tr><td><code id="mtm.coh_+3A_phcorr">phcorr</code></td>
<td>
<p>Correct phase (unwrap). By default, set to TRUE; set to FALSE if you would prefer the phase to be untouched. </p>
</td></tr>
<tr><td><code id="mtm.coh_+3A_plot">plot</code></td>
<td>
<p>Boolean value indicating if a plot should be drawn.</p>
</td></tr>
<tr><td><code id="mtm.coh_+3A_...">...</code></td>
<td>
<p>Additional parameters, such as xaxs=&quot;i&quot; which are passed through to
the plotting function.</p>
</td></tr> 
</table>


<h3>References</h3>

<p>Thomson, DJ (1991)
Jackknifed error estimates for spectra, coherences, and transfer
functions, <em>Advances in Spectrum Estimation</em> 58&ndash;113.
</p>
<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>
Volume <b>70</b>, number 9, pp. 1055&ndash;1096.
</p>
<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications</em>
Cambridge University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HadCRUTnh)
data(mlco2)
spec1 &lt;- spec.mtm(HadCRUTnh, nw=5.0, k=8, plot=FALSE,
    returnInternals=TRUE, dtUnits="month", deltat=1.0)
spec2 &lt;- spec.mtm(mlco2, nw=5.0, k=8, plot=FALSE, returnInternals=TRUE,
    dtUnits="month", deltat=1.0)
resCoh &lt;- mtm.coh(spec1, spec2, plot=FALSE)
plot(resCoh)
plot(resCoh, cdfQuantilesTicks=1-10^(-(6:12)))
</code></pre>

<hr>
<h2 id='multitaperTrend'>Estimate Linear Trend using Multitaper Techniques</h2><span id='topic+multitaperTrend'></span>

<h3>Description</h3>

<p>Estimate linear trend using inverse spectrum estimation, with the 
spectrum being computed via multitaper. This technique has improved
spectral properties when compared to the least-squares approach. 
Returned values from this function include the intercept, slope,
and centered time array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multitaperTrend(xd, B, deltat, t.in)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multitaperTrend_+3A_xd">xd</code></td>
<td>
<p>Contiguous time series to be detrended.</p>
</td></tr>
<tr><td><code id="multitaperTrend_+3A_b">B</code></td>
<td>
<p>Bandwidth to use in estimating trend in physical units; corresponds
to NW via equation NW=BT, where N and W are the usual Slepian definitions,
and T is the total time elapsed, i.e. T = N*deltat.</p>
</td></tr>
<tr><td><code id="multitaperTrend_+3A_deltat">deltat</code></td>
<td>
<p>Time step for series xd, also used in computing T.</p>
</td></tr>
<tr><td><code id="multitaperTrend_+3A_t.in">t.in</code></td>
<td>
<p>Time array, used in accurately estimating the slope.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:101
y &lt;- 1.0 + 0.5*(x) + rnorm(n=101,mean=0,sd=2)
vars &lt;- multitaperTrend(xd=y, B=0.05, deltat=1.0, t.in=x)
plot(x,y,type="l")
lines(x,vars[[1]]+vars[[2]]*vars[[3]],type="l",col="red")
</code></pre>

<hr>
<h2 id='percivalAR4'>Auto Regressive Series generated by Don Percival at Applied
Physics Laboratory</h2><span id='topic+percivalAR4'></span>

<h3>Description</h3>

<p>This is a simulated AR(4) time series (page 45 of Percival
and Walden 1993). The source of this series is: Applied Physics
Laboratory (Don Percival). The value for delta T is 1, and the sample
size is 1024. Another realization of this series based on the same
autoregressive coefficients can be generated in R using the code in
the example section of the documentation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percivalAR4</code></pre>


<h3>Format</h3>

<p>A time series object containing 1024 simulated values.</p>


<h3>Source</h3>

<p>Presented on page 45 of Percival, D.B. and Walden, A.T. (1993).
See: <a href="http://faculty.washington.edu/dbp/DATA/ar4.dat">http://faculty.washington.edu/dbp/DATA/ar4.dat</a>
</p>


<h3>References</h3>

<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications.</em>
Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get the Percival realization of the series saved as data.
data(percivalAR4)
## generate another realization of this series using the same AR(4)
## coefficients.
ar4Coef &lt;- c(2.7607, -3.8106, 2.6535, -0.9238)
ar4.ts &lt;- arima.sim(list(order = c(4, 0, 0), ar=ar4Coef), n=1024)
</code></pre>

<hr>
<h2 id='plot.mtm'>Compute and plot the multitaper spectrum estimate</h2><span id='topic+plot.mtm'></span>

<h3>Description</h3>

<p>Plots the multitaper spectral estimate and the multitaper F-test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mtm'
plot(x, jackknife = FALSE, Ftest = FALSE, ftbase = 1.01, siglines = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mtm_+3A_x">x</code></td>
<td>
<p>An object of the class mtm generated by spec.mtm.</p>
</td></tr>
<tr><td><code id="plot.mtm_+3A_jackknife">jackknife</code></td>
<td>
<p>Boolean variable indicating if jackknife
confidence intervals should be plotted, only applies if Ftest=FALSE.</p>
</td></tr>
<tr><td><code id="plot.mtm_+3A_ftest">Ftest</code></td>
<td>
<p>Boolean variable indicating if the multitaper harmonic F-test
should be plotted instead of the spectrum.</p>
</td></tr>
<tr><td><code id="plot.mtm_+3A_ftbase">ftbase</code></td>
<td>
<p>Lowest value to be plotted when the F-test is
plotted. When Ftest = TRUE, max(ftestvalue, ftbase) is plotted.</p>
</td></tr>
<tr><td><code id="plot.mtm_+3A_siglines">siglines</code></td>
<td>
<p>Vector of significance values (as probabilities, 0.0 to 1.0) 
to plot as horizontal significance lines on the F-test plot. </p>
</td></tr>
<tr><td><code id="plot.mtm_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical
parameters (see 'par').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value log can be set to &ldquo;yes&rdquo; (default), &ldquo;no&rdquo;, or &ldquo;dB&rdquo;
as in the function plot.spec.</p>


<h3>References</h3>

<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>
Volume <b>70</b>, number 9, pp. 1055&ndash;1096.
</p>
<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications</em>
Cambridge University Press. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+spec.mtm">spec.mtm</a></code> and <code><a href="stats.html#topic+plot.spec">plot.spec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(willamette)
resSpec &lt;- spec.mtm(willamette, nw=4.0, k=8, Ftest=TRUE, plot=FALSE, deltat=1.0, dtUnits="month")
plot(resSpec)
plot(resSpec, Ftest=TRUE)
plot(resSpec, Ftest=TRUE, siglines=c(0.90, 0.99))

# with jackknife estimate
resSpec2 &lt;- spec.mtm(willamette, nw=4.0, k=8, Ftest=TRUE, jackknife=TRUE, plot=FALSE,
                     deltat=1.0, dtUnits="month")
plot(resSpec2,jackknife=TRUE)

</code></pre>

<hr>
<h2 id='plot.mtm.coh'>Compute and plot the multitaper magnitude-squared coherence.</h2><span id='topic+plot.mtm.coh'></span>

<h3>Description</h3>

<p>Plots the magnitude-squared coherence for a mtm.coh object computed
from two equal-parameter mtm objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mtm.coh'
plot(x,percentGreater=NULL,nehlim=10,nehc=4, cdfQuantilesTicks=NULL,
                       drawPercentLines=TRUE, percentG=c(.1,.2,.5,.8,.9), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mtm.coh_+3A_x">x</code></td>
<td>
<p>An object of the class mtm.coh generated by spec.mtm.coh.</p>
</td></tr>
<tr><td><code id="plot.mtm.coh_+3A_percentgreater">percentGreater</code></td>
<td>
<p>Prints the percent of the coherence function
greater than the given values in the lower left hand corner.
The values are expected in a vector representing the percentages.
For example c(.5, .7) will print the
percent of the msc that is greater than 50% and 70%.</p>
</td></tr>
<tr><td><code id="plot.mtm.coh_+3A_nehlim">nehlim</code></td>
<td>
<p>A smoothing parameter used in smoothing the
variance in the final plot. nehlim is the number of points to smooth by
on each side.</p>
</td></tr>
<tr><td><code id="plot.mtm.coh_+3A_nehc">nehc</code></td>
<td>
<p>A smoothing parameter used in smoothing the MSC in the 
final plot. nehc is the number of points to smooth by on each side.</p>
</td></tr>
<tr><td><code id="plot.mtm.coh_+3A_cdfquantilesticks">cdfQuantilesTicks</code></td>
<td>
<p>Percent lines to place the tick marks on the
right axis (CDF). See the example in mtm.coh for use.</p>
</td></tr>
<tr><td><code id="plot.mtm.coh_+3A_drawpercentlines">drawPercentLines</code></td>
<td>
<p>Boolean variable indicating if significance lines
are to be drawn.</p>
</td></tr>
<tr><td><code id="plot.mtm.coh_+3A_percentg">percentG</code></td>
<td>
<p>A vector of values for which to print dashed lines
indicating the percent greater than a particular value. If
drawpPercentLines is FALSE then this will not be used.</p>
</td></tr>
<tr><td><code id="plot.mtm.coh_+3A_...">...</code></td>
<td>
<p>Parameters passed to plotting function. Currently
only tested with xaxs=&quot;i&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an object containing the user-specified significance levels (<code>percentG</code>), along with
their normal transforms. This allows the user to examine the <code>mtm.coh</code> object and clip the
<code>NTmsc</code> variable to different significances.
</p>


<h3>References</h3>

<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>
Volume <b>70</b>, number 9, pp. 1055&ndash;1096.
</p>
<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications</em>
Cambridge University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples here
</code></pre>

<hr>
<h2 id='sineTaper'>Computes sine tapers</h2><span id='topic+sineTaper'></span>

<h3>Description</h3>

<p>Computes sine tapers for use in transfer function estimation and 
plotting. Not called from within spec.mtm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sineTaper(n, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sineTaper_+3A_n">n</code></td>
<td>
<p>The data as a vector or as a time series.</p>
</td></tr>
<tr><td><code id="sineTaper_+3A_k">k</code></td>
<td>
<p>The Slepian bandwidth parameter, typically between 2.0 and 6.0.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Riedel, K.S. and Sidorenko, A. (1995)
Minimum bias multiple taper spectral estimation. <em>IEEE Transactions
on Signal Processing</em>, Volume <b>43</b>, Number <b>1</b>, pp. 188&ndash;195.
</p>

<hr>
<h2 id='spec.mtm'>Compute and plot multitaper spectrum estimates</h2><span id='topic+spec.mtm'></span>

<h3>Description</h3>

<p>Computes and plots adaptive or nonadaptive multitaper spectrum estimates from
contiguous time series objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec.mtm(timeSeries, nw=4.0, k=7, nFFT="default", taper=c("dpss"),
         centre=c("Slepian"), dpssIN=NULL, returnZeroFreq=TRUE,
         Ftest=FALSE, jackknife=FALSE, jkCIProb=.95, adaptiveWeighting=TRUE,
         maxAdaptiveIterations=100, plot=TRUE, na.action=na.fail,
         returnInternals=FALSE, sineAdaptive=FALSE, sineSmoothFact=0.2,
         dtUnits=c("default"), deltat=NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spec.mtm_+3A_timeseries">timeSeries</code></td>
<td>
<p>A time series of equally spaced data, this can be
created by the ts() function where deltat is specified.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_nw">nw</code></td>
<td>
<p>nw a positive double precision number, the time-bandwidth
parameter.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_k">k</code></td>
<td>
<p>k a positive integer, the number of tapers, often 2*nw.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_nfft">nFFT</code></td>
<td>
<p>This function pads the data before computing the fft. nFFT
indicates the total length of the data after padding.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_taper">taper</code></td>
<td>
<p>Choose between dpss-based multitaper (the default,'dpss') or sine taper
method. In the case of the sine taper, parameter nw is useless, and both Ftest
and jackknife are forced to FALSE. The sine taper also has two specific parameters
below.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_centre">centre</code></td>
<td>
<p>The time series is centred using one of three methods: expansion
onto discrete prolate spheroidal sequences ('Slepian'), arithmetic mean ('arithMean'), 
trimmed mean ('trimMean'), or not at all ('none'). </p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_dpssin">dpssIN</code></td>
<td>
<p>Allows the user to enter a dpss object which has already
been created. This can save computation time when Slepians with
the same bandwidth parameter and same number of tapers are used repeatedly.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_returnzerofreq">returnZeroFreq</code></td>
<td>
<p>Boolean variable indicating if the zeroth
frequency (DC component) should be returned for all applicable arrays.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_ftest">Ftest</code></td>
<td>
<p>Boolean variable indicating if the Ftest result should be
computed and returned.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_jackknife">jackknife</code></td>
<td>
<p>Boolean variable indicating if jackknifed confidence
intervals should be computed and returned.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_jkciprob">jkCIProb</code></td>
<td>
<p>Decimal value indicating the jackknife probability for
calculating jackknife confidence intervals. The default returns a
95% confidence interval.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_adaptiveweighting">adaptiveWeighting</code></td>
<td>
<p>Boolean flag for enabling/disabling adaptively weighted
spectrum estimates. Defaults to <code>TRUE</code>. The <code>FALSE</code> case gives complex
Fourier transforms equivalent to direct estimates with Slepian sequences as tapers.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_maxadaptiveiterations">maxAdaptiveIterations</code></td>
<td>
<p>Maximum number of iterations in the
adaptive multitaper calculation. Generally convergence is quick, and should
require less than 100 iterations.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_plot">plot</code></td>
<td>
<p>Boolean variable indicating if the spectrum should be plotted.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_na.action">na.action</code></td>
<td>
<p>Action to take if NAs exist in the data, the default
is to fail.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_returninternals">returnInternals</code></td>
<td>
<p>Return the weighted eigencoefficients, complex mean values, and so on. These are necessary for extensions to the multitaper, including magnitude-squared coherence (function mtm.coh in this package). Note:
The internal ($mtm) variables eigenCoefs and eigenCoefWt correspond to
the multitaper eigencoefficients. The eigencoefficients correspond to
equation (3.4) and weights, eigenCoefWt, correspond to sqrt(|d_k(f)|^2) from equation (5.4) in Thomson's 1982 paper. This is because the square root values contained in eigenCoefWt are commonly used in additional calculations (example: eigenCoefWt * eigenCoefs). The
values returned in mtm$cmv correspond to the the estimate of the
coefficients hat(mu)(f) in equation (13.5) in Thomson (1982), or to the
estimate of hat(C)_1 at frequency 1 in equation (499) form Percival and Walden (1993)</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_sineadaptive">sineAdaptive</code></td>
<td>
<p>In the case of using the sine taper method, choose between
non-adaptive and adaptive taper choice.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_sinesmoothfact">sineSmoothFact</code></td>
<td>
<p>The sine taper option has an inherent smoothing parameter that
can be set between 0.01 and 0.5. Lower values indicate smaller amounts of smoothing.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_dtunits">dtUnits</code></td>
<td>
<p>Allows indication of the units of delta-t for accurate frequency axis
labels.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_deltat">deltat</code></td>
<td>
<p>Time step for observations. If not in seconds, dtUnits should be set to indicate
the proper units for plot labels.</p>
</td></tr>
<tr><td><code id="spec.mtm_+3A_...">...</code></td>
<td>
<p>Additional parameters, such as xaxs=&quot;i&quot; which are passed to
the plotting function. Not all parameters are supported.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The value log can be set to &ldquo;yes&rdquo; (default), &ldquo;no&rdquo;, or &ldquo;dB&rdquo;
as in the function plot.spec.</p>


<h3>References</h3>

<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>
Volume <b>70</b>, Number 9, pp. 1055&ndash;1096.
</p>
<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications</em>
Cambridge University Press. 
</p>
<p>Riedel, K.S. and Sidorenko, A. (1995)
Minimum bias multiple taper spectral estimation. <em>IEEE Transactions on Signal Processing</em>
Volume <b>43</b>, Number 1, pp. 188&ndash;195.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.mtm">plot.mtm</a></code> and <code><a href="stats.html#topic+plot.spec">plot.spec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## default behaviour, dpss tapers; deltat and dtUnits set to ensure axis accuracy
data(willamette)
spec.mtm(willamette, nw=4.0, k=8, deltat=1/12, dtUnits="year")
spec.mtm(willamette, nw=4.0, k=8, nFFT=2048, deltat=1/12, dtUnits="year")

## if you have a ts object, you can skip the deltat and dtUnits parameters
will.ts &lt;- ts(data=willamette, start=1950.75, freq=12)
spec.mtm(will.ts, nw=4.0, k=8)

## using Sine Tapers
spec.mtm(will.ts, k=10, taper="sine", sineAdaptive=FALSE)
spec.mtm(will.ts, k=10, taper="sine", sineAdaptive=TRUE, 
         maxAdaptiveIterations=100, sineSmoothFact=0.05)
</code></pre>

<hr>
<h2 id='willamette'>Willamette River time series</h2><span id='topic+willamette'></span>

<h3>Description</h3>

<p>Willamette River time series. Each point represents the log of the
average daily flow over a one month period from October, 1950, to
August 1983. The sampling time is 1/12 year and the Nyquist frequency
is 6 cycles per year. The data is from the companion code to &ldquo;Spectral
Analysis for the Physical Applications&rdquo; (1993) and was originally compiled by
the US Geological Survey. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>willamette</code></pre>


<h3>Format</h3>

<p>A vector containing 395 observations</p>


<h3>References</h3>

<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications.</em>
Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(willamette)
# time series object, January = year.0, December = year.917
will.ts &lt;- ts(data=willamette, start=(1950+9/12), freq=12)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
