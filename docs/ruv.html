<!DOCTYPE html><html><head><title>Help for package ruv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ruv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ruv-package'>
<p>Detect and Remove Unwanted Variation using Negative Controls</p></a></li>
<li><a href='#collapse.replicates'>
<p>Collapse Replicates</p></a></li>
<li><a href='#design.matrix'>
<p>Design Matrix</p></a></li>
<li><a href='#get_empirical_variances'>
<p>Get empirical variances</p></a></li>
<li><a href='#getK'>
<p>Get K</p></a></li>
<li><a href='#google_search'>
<p>Google Search URL</p></a></li>
<li><a href='#inputcheck1'>
<p>Input Check One</p></a></li>
<li><a href='#invvar'>
<p>Inverse Method Variances</p></a></li>
<li><a href='#projectionplotvariables'>
<p>Projection Plot Variables</p></a></li>
<li><a href='#randinvvar'>
<p>(Randomization) Inverse Method Variances</p></a></li>
<li><a href='#replicate.matrix'>
<p>Replicate (Mapping) Matrix</p></a></li>
<li><a href='#residop'>
<p>Residual Operator</p></a></li>
<li><a href='#ruv_cancorplot'>
<p>RUV Canonical Correlation Plot</p></a></li>
<li><a href='#ruv_ecdf'>
<p>RUV P-value Empirical CDF Plot</p></a></li>
<li><a href='#ruv_hist'>
<p>RUV P-value Histogram Plot</p></a></li>
<li><a href='#ruv_projectionplot'>
<p>RUV Projection Plot</p></a></li>
<li><a href='#ruv_rankplot'>
<p>RUV Rank Plot</p></a></li>
<li><a href='#ruv_residuals'>
<p>RUV Residuals</p></a></li>
<li><a href='#ruv_rle'>
<p>RUV RLE Plot</p></a></li>
<li><a href='#ruv_scree'>
<p>RUV Scree Plot</p></a></li>
<li><a href='#ruv_shiny'>
<p>RUV Shiny App</p></a></li>
<li><a href='#ruv_summary'>
<p>RUV Summary</p></a></li>
<li><a href='#ruv_svdgridplot'>
<p>RUV SVD Grid Plot</p></a></li>
<li><a href='#ruv_svdplot'>
<p>RUV SVD Plot</p></a></li>
<li><a href='#ruv_varianceplot'>
<p>RUV Variance Plot</p></a></li>
<li><a href='#ruv_volcano'>
<p>RUV Volcano Plot</p></a></li>
<li><a href='#RUV2'>
<p>Remove Unwanted Variation, 2-step</p></a></li>
<li><a href='#RUV4'>
<p>Remove Unwanted Variation, 4-step</p></a></li>
<li><a href='#RUVI'>
<p>RUV-I</p></a></li>
<li><a href='#RUVIII'>
<p>RUV-III</p></a></li>
<li><a href='#RUVinv'>
<p>Remove Unwanted Variation, inverse method</p></a></li>
<li><a href='#RUVrinv'>
<p>Remove Unwanted Variation, ridged inverse method</p></a></li>
<li><a href='#sigmashrink'>
<p>Empirical Bayes shrinkage estimate of sigma^2</p></a></li>
<li><a href='#variance_adjust'>
<p>Adjust Estimated Variances</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Detect and Remove Unwanted Variation using Negative Controls</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the 'RUV' (Remove Unwanted Variation) algorithms.  These algorithms attempt to adjust for systematic errors of unknown origin in high-dimensional data.  The algorithms were originally developed for use with genomic data, especially microarray data, but may be useful with other types of high-dimensional data as well.  These algorithms were proposed in Gagnon-Bartsch and Speed (2012) &lt;<a href="https://doi.org/10.1093%2Fnar%2Fgkz433">doi:10.1093/nar/gkz433</a>&gt;, Gagnon-Bartsch, Jacob and Speed (2013), and Molania, et. al. (2019) &lt;<a href="https://doi.org/10.1093%2Fnar%2Fgkz433">doi:10.1093/nar/gkz433</a>&gt;.  The algorithms require the user to specify a set of negative control variables, as described in the references.  The algorithms included in this package are 'RUV-2', 'RUV-4', 'RUV-inv', 'RUV-rinv', 'RUV-I', and RUV-III', along with various supporting algorithms.  </td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.7.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-08-30</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2, scales, gridExtra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>shiny, colourpicker</td>
</tr>
<tr>
<td>Author:</td>
<td>Johann Gagnon-Bartsch &lt;johanngb@umich.edu&gt; </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Johann Gagnon-Bartsch &lt;johanngb@umich.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www-personal.umich.edu/~johanngb/ruv/">http://www-personal.umich.edu/~johanngb/ruv/</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-08-30 20:08:45 UTC; johanngb</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-08-30 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ruv-package'>
Detect and Remove Unwanted Variation using Negative Controls 
</h2><span id='topic+ruv-package'></span><span id='topic+ruv'></span>

<h3>Description</h3>

<p>Implements the 'RUV' (Remove Unwanted Variation) algorithms.  These algorithms attempt to adjust for systematic errors of unknown origin in high-dimensional data.  The algorithms were originally developed for use with genomic data, especially microarray data, but may be useful with other types of high-dimensional data as well.  These algorithms were proposed in Gagnon-Bartsch and Speed (2012) &lt;doi:10.1093/nar/gkz433&gt;, Gagnon-Bartsch, Jacob and Speed (2013), and Molania, et. al. (2019) &lt;doi:10.1093/nar/gkz433&gt;.  The algorithms require the user to specify a set of negative control variables, as described in the references.  The algorithms included in this package are 'RUV-2', 'RUV-4', 'RUV-inv', 'RUV-rinv', 'RUV-I', and RUV-III', along with various supporting algorithms.  
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ruv</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.9.7.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-08-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> <a href="http://www-personal.umich.edu/~johanngb/ruv/">http://www-personal.umich.edu/~johanngb/ruv/</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

 
<p>Additional resources can be found at <a href="http://www-personal.umich.edu/~johanngb/ruv/">http://www-personal.umich.edu/~johanngb/ruv/</a>.   
</p>


<h3>Author(s)</h3>

 
<p>Johann Gagnon-Bartsch &lt;johanngb@umich.edu&gt; 
</p>


<h3>References</h3>

 
<p>Gagnon-Bartsch, J.A. and T.P. Speed (2012).  Using control genes to correct for unwanted variation in microarray data.  Biostatistics.  &lt;doi:10.1093/biostatistics/kxr034&gt;   
</p>
<p>Gagnon-Bartsch, J.A., L. Jacob, and T.P. Speed (2013).  Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Technical report.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>  
</p>
<p>Molania, R., J. A. Gagnon-Bartsch, A. Dobrovic, and T. P. Speed (2019).  A new normalization for the Nanostring nCounter gene expression assay.  Nucleic Acids Research.  &lt;doi:10.1093/nar/gkz433&gt; 
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+RUV2">RUV2</a></code>, <code><a href="#topic+RUV4">RUV4</a></code>, <code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>, <code><a href="#topic+variance_adjust">variance_adjust</a></code>, 
<code><a href="#topic+RUVI">RUVI</a></code>, <code><a href="#topic+RUVIII">RUVIII</a></code> 
</p>

<hr>
<h2 id='collapse.replicates'>
Collapse Replicates
</h2><span id='topic+collapse.replicates'></span>

<h3>Description</h3>

<p>This function is intended for use in conjunction with <code><a href="#topic+RUVIII">RUVIII</a></code>, specifically when using the <code>average=TRUE</code> option.  When using the <code>average=TRUE</code> option, the adjusted data matrix has only one row for each set of replicates.  In other words, each set of replicate rows in the orginal data matrix is &quot;collapsed&quot; into a single row in the adjusted data matrix.  This function similarly collapses the rows of a dataframe of covariates.  Only covariates that are constant within each set of replicates are retained.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse.replicates(df, M)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse.replicates_+3A_df">df</code></td>
<td>

<p>A dataframe.
</p>
</td></tr>
<tr><td><code id="collapse.replicates_+3A_m">M</code></td>
<td>

<p>The replicate structure.  See <code><a href="#topic+RUVIII">RUVIII</a></code> for details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sub-dataframe of df.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUVIII">RUVIII</a></code>
</p>

<hr>
<h2 id='design.matrix'>
Design Matrix
</h2><span id='topic+design.matrix'></span>

<h3>Description</h3>

<p>Creates a design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design.matrix(a, name = "X", remove.collinear = TRUE, include.intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design.matrix_+3A_a">a</code></td>
<td>

<p>Object from which to create a design matrix.  Can be a vector, matrix, factor, or dataframe.
</p>
</td></tr>
<tr><td><code id="design.matrix_+3A_name">name</code></td>
<td>

<p>Name of the design matrix.  Used to name columns that aren't already named (e.g. X1, X2, etc.)
</p>
</td></tr>
<tr><td><code id="design.matrix_+3A_remove.collinear">remove.collinear</code></td>
<td>

<p>Will remove columns that are collinear, to ensure the design matrix is full rank.
</p>
</td></tr>
<tr><td><code id="design.matrix_+3A_include.intercept">include.intercept</code></td>
<td>

<p>Add an intercept to the matrix if one is not included already.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numerical vectors are not modified.  Factors are converted to dummy variables.  Character vectors are converted to factors, and then to dummy variables.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>

<hr>
<h2 id='get_empirical_variances'>
Get empirical variances
</h2><span id='topic+get_empirical_variances'></span>

<h3>Description</h3>

<p>This method implements the method of empirical variances as described in Gagnon-Bartsch, Jacob, and Speed (2013).  This function is normally called from the function <code><a href="#topic+variance_adjust">variance_adjust</a></code>, and is not normally intended for stand-alone use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_empirical_variances(sigma2, betahat, bin = 10,
                        rescaleconst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_empirical_variances_+3A_sigma2">sigma2</code></td>
<td>

<p>Estimates of sigma^2
</p>
</td></tr>
<tr><td><code id="get_empirical_variances_+3A_betahat">betahat</code></td>
<td>

<p>Estimates of beta
</p>
</td></tr>
<tr><td><code id="get_empirical_variances_+3A_bin">bin</code></td>
<td>

<p>The bin size
</p>
</td></tr>
<tr><td><code id="get_empirical_variances_+3A_rescaleconst">rescaleconst</code></td>
<td>

<p>The expected value of the average of the smallest <code>bin - 1</code> of <code>bin</code> independent chi-square random variables.  This can be specified to save computational time (otherwise, it is calculated by simulation).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the empirical variances.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>


<h3>References</h3>

<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variance_adjust">variance_adjust</a></code>
</p>

<hr>
<h2 id='getK'>
Get K
</h2><span id='topic+getK'></span>

<h3>Description</h3>

<p>Finds an often-suitable value of K for use in RUV-4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getK(Y, X, ctl, Z = 1, eta = NULL, include.intercept = TRUE,
     fullW0 = NULL, cutoff = NULL, method="select", l=1, inputcheck = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getK_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="getK_+3A_x">X</code></td>
<td>

<p>The factor(s) of interest.  A m by p matrix, where m is the number of samples and p is the number of factors of interest.  Note that X should be only a single column, i.e. p = 1; if X has more than one column, only column <code>l</code> will be used (see below).  
</p>
</td></tr>
<tr><td><code id="getK_+3A_ctl">ctl</code></td>
<td>

<p>An index vector to specify the negative controls.  Either a logical vector of length n or a vector of integers.  
</p>
</td></tr>
<tr><td><code id="getK_+3A_z">Z</code></td>
<td>

<p>Any additional covariates to include in the model, typically a m by q matrix.  Factors and dataframes are also permissible, and converted to a matrix by <code><a href="#topic+design.matrix">design.matrix</a></code>.  Alternatively, may simply be 1 (the default) for an intercept term.  May also be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="getK_+3A_eta">eta</code></td>
<td>

<p>Gene-wise (as opposed to sample-wise) covariates.  These covariates are adjusted for by RUV-1 before any further analysis proceeds.  Can be either (1) a matrix with n columns, (2) a matrix with n rows, (3) a dataframe with n rows, (4) a vector or factor of length n, or (5) simply 1, for an intercept term.  
</p>
</td></tr>
<tr><td><code id="getK_+3A_include.intercept">include.intercept</code></td>
<td>

<p>Applies to both <code>Z</code> and <code>eta</code>.  When <code>Z</code> or <code>eta</code> (or both) is specified (not <code>NULL</code>) but does not already include an intercept term, this will automatically include one.  If only one of <code>Z</code> or <code>eta</code> should include an intercept, this variable should be set to <code>FALSE</code>, and the intercept term should be included manually where desired.
</p>
</td></tr>
<tr><td><code id="getK_+3A_fullw0">fullW0</code></td>
<td>

<p>Can be included to speed up execution.  Is returned by previous calls of <code>getK</code>, <code>RUV4</code>, <code>RUVinv</code>, or <code>RUVrinv</code> (see  below).
</p>
</td></tr>
<tr><td><code id="getK_+3A_cutoff">cutoff</code></td>
<td>

<p>Specify an alternative cut-off.  Default is the (approximate) 90th percentile of the distribution of the first singular value of an m by n gaussian matrix.
</p>
</td></tr>
<tr><td><code id="getK_+3A_method">method</code></td>
<td>

<p>Can be set to either <code>leave1out</code>, <code>fast</code>, or <code>select</code>.  <code>leave1out</code> is the preferred method but may be slow, <code>fast</code> is an approximate method that is faster but may provide poor results if n_c is not much larger than m, and <code>select</code> (the default) tries to choose for you.
</p>
</td></tr>
<tr><td><code id="getK_+3A_l">l</code></td>
<td>

<p>Which column of X to use in the getK algorithm. 
</p>
</td></tr>
<tr><td><code id="getK_+3A_inputcheck">inputcheck</code></td>
<td>

<p>Perform a basic sanity check on the inputs, and issue a warning if there is a problem.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>k</code></td>
<td>
<p>the estimated value of k</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>The cutoff value used</p>
</td></tr>
<tr><td><code>sizeratios</code></td>
<td>
<p>A measure of the relative sizes of the rows of alpha.</p>
</td></tr>
<tr><td><code>fullW0</code></td>
<td>
<p>Can be used to speed up future calls of RUV4.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>This value of K will not be the best choice in all cases.  Moreover, it will often be a poor choice of K for use with RUV2.  See Gagnon-Bartsch and Speed (2012) for commentary on estimating k.</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>References</h3>

<p>Using control genes to correct for unwanted variation in microarray data.  Gagnon-Bartsch and Speed, 2012.  Available at: <a href="http://biostatistics.oxfordjournals.org/content/13/3/539.full">http://biostatistics.oxfordjournals.org/content/13/3/539.full</a>. 
</p>
<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV4">RUV4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create some simulated data
m = 50
n = 10000
nc = 1000
p = 1
k = 20
ctl = rep(FALSE, n)
ctl[1:nc] = TRUE
X = matrix(c(rep(0,floor(m/2)), rep(1,ceiling(m/2))), m, p)
beta = matrix(rnorm(p*n), p, n)
beta[,ctl] = 0
W = matrix(rnorm(m*k),m,k)
alpha = matrix(rnorm(k*n),k,n)
epsilon = matrix(rnorm(m*n),m,n)
Y = X%*%beta + W%*%alpha + epsilon

## Run getK
temp = getK(Y, X, ctl)
K = temp$k
</code></pre>

<hr>
<h2 id='google_search'>
Google Search URL
</h2><span id='topic+google_search'></span>

<h3>Description</h3>

<p>Converts a string to URL for a goolge search of that string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>google_search(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="google_search_+3A_a">a</code></td>
<td>

<p>A string.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string that is a URL.
</p>

<hr>
<h2 id='inputcheck1'>
Input Check One
</h2><span id='topic+inputcheck1'></span>

<h3>Description</h3>

<p>Performs a basic sanity check on the arguments passed to RUV-2, RUV-4, RUV-inv, and RUV-rinv.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputcheck1(Y, X, Z, ctl, check.na=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inputcheck1_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="inputcheck1_+3A_x">X</code></td>
<td>

<p>The factor(s) of interest.  A m by p matrix, where m is the number of samples and p is the number of factors of interest.  Very often p = 1.
</p>
</td></tr>
<tr><td><code id="inputcheck1_+3A_z">Z</code></td>
<td>

<p>Any additional covariates to include in the model.  Either a m by q matrix of covariates, or simply 1 (the default) for an intercept term.
</p>
</td></tr>
<tr><td><code id="inputcheck1_+3A_ctl">ctl</code></td>
<td>

<p>The negative controls.  A logical vector of length n.  
</p>
</td></tr>
<tr><td><code id="inputcheck1_+3A_check.na">check.na</code></td>
<td>

<p>Whether to check for missing values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL.  The function is only called to check for problems in the arguments and to issue warnings if any problems are found.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV2">RUV2</a></code>, <code><a href="#topic+RUV4">RUV4</a></code>, <code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>
</p>

<hr>
<h2 id='invvar'>
Inverse Method Variances
</h2><span id='topic+invvar'></span>

<h3>Description</h3>

<p>Estimate the features' variances using the inverse method.  This function is usually called from <code><a href="#topic+RUVinv">RUVinv</a></code> and not normally intended for stand-alone use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invvar(Y, ctl, XZ = NULL, eta = NULL, lambda = NULL,
       invsvd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invvar_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="invvar_+3A_ctl">ctl</code></td>
<td>

<p>The negative controls.  A logical vector of length n.  
</p>
</td></tr>
<tr><td><code id="invvar_+3A_xz">XZ</code></td>
<td>

<p>A m by (p + q) matrix containing both the factor(s) of interest (X) and known covariates (Z).
</p>
</td></tr>
<tr><td><code id="invvar_+3A_eta">eta</code></td>
<td>

<p>Gene-wise (as opposed to sample-wise) covariates.  These covariates are adjusted for by RUV-1 before any further analysis proceeds.  A matrix with n columns.
</p>
</td></tr>
<tr><td><code id="invvar_+3A_lambda">lambda</code></td>
<td>

<p>Ridge parameter.  If specified, the ridged inverse method will be used.
</p>
</td></tr>
<tr><td><code id="invvar_+3A_invsvd">invsvd</code></td>
<td>

<p>Can be included to speed up execution.  Generally used when calling invvar many times with different values of lambda.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimates of the features' variances.  A vector of length n.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The &quot;effective degrees of freedom&quot;</p>
</td></tr>
<tr><td><code>invsvd</code></td>
<td>
<p>Can be used to speed up future calls of invvar.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>References</h3>

<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>
</p>

<hr>
<h2 id='projectionplotvariables'>
Projection Plot Variables
</h2><span id='topic+projectionplotvariables'></span>

<h3>Description</h3>

<p>Calculates the variables necessary to produce a projection plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectionplotvariables(Y, X, W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectionplotvariables_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="projectionplotvariables_+3A_x">X</code></td>
<td>

<p>A m by p matrix containing the factor(s) of interest.
</p>
</td></tr>
<tr><td><code id="projectionplotvariables_+3A_w">W</code></td>
<td>

<p>A m by k matrix containing the estimated unwanted factors.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically intended for internal use, and called after adjustment for known covariates (Z).
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>byx</code></td>
<td>
<p>Regression coefficients from regressing Y on X.</p>
</td></tr>
<tr><td><code>bwx</code></td>
<td>
<p>Regression coefficients from regressing W on X.</p>
</td></tr>
<tr><td><code>projectionplotalpha</code></td>
<td>
<p>A reparameterization of alpha.</p>
</td></tr>
<tr><td><code>projectionplotW</code></td>
<td>
<p>A reparameterization of W.</p>
</td></tr>
</table>

<hr>
<h2 id='randinvvar'>
(Randomization) Inverse Method Variances
</h2><span id='topic+randinvvar'></span>

<h3>Description</h3>

<p>Estimate the features' variances using a stochastic version of the inverse method.  This function is usually called from <code><a href="#topic+RUVinv">RUVinv</a></code> and not normally intended for stand-alone use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randinvvar(Y, ctl, XZ = NULL, eta = NULL, lambda = NULL,
           iterN = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randinvvar_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="randinvvar_+3A_ctl">ctl</code></td>
<td>

<p>The negative controls.  A logical vector of length n.  
</p>
</td></tr>
<tr><td><code id="randinvvar_+3A_xz">XZ</code></td>
<td>

<p>A m by (p + q) matrix containing both the factor(s) of interest (X) and known covariates (Z).
</p>
</td></tr>
<tr><td><code id="randinvvar_+3A_eta">eta</code></td>
<td>

<p>Gene-wise (as opposed to sample-wise) covariates.  These covariates are adjusted for by RUV-1 before any further analysis proceeds.  A matrix with n columns.
</p>
</td></tr>
<tr><td><code id="randinvvar_+3A_lambda">lambda</code></td>
<td>

<p>Ridge parameter.  If specified, the ridged inverse method will be used.
</p>
</td></tr>
<tr><td><code id="randinvvar_+3A_itern">iterN</code></td>
<td>

<p>The number of random &quot;factors of interest&quot; to generate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimates of the features' variances.  A vector of length n.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The &quot;effective degrees of freedom&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>References</h3>

<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>, <code><a href="#topic+invvar">invvar</a></code>
</p>

<hr>
<h2 id='replicate.matrix'>
Replicate (Mapping) Matrix
</h2><span id='topic+replicate.matrix'></span>

<h3>Description</h3>

<p>For use with <code><a href="#topic+RUVIII">RUVIII</a></code>, generates a mapping matrix that describes the replicate structure.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replicate.matrix(a, burst=NULL, return.factor=FALSE, name="M", sep="_", burstsep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replicate.matrix_+3A_a">a</code></td>
<td>

<p>An object that describes the replicate structure.  Can be a vector, matrix, factor, or dataframe.  If a vector, it is converted to a factor.  If a factor, each level of the factor is taken to represent a set of replicates.  If a matrix: First it is determined whether it is already a mapping matrix; if so, the matrix is returned unchanged; if not, the matrix is converted to a dataframe.   If a dataframe: Each column is converted to a factor.  A new factor is then created with levels for every possible combination of factor levels in the dataframe.  For example, if the dataframe contains two factors, patientID and sampleDate, the new factor will have a unique level for each (observed) combination of patientID and sampleDate.  Thus observations will be considered replicates if they have identical values for BOTH patientID and sampleDate.
</p>
</td></tr>
<tr><td><code id="replicate.matrix_+3A_burst">burst</code></td>
<td>

<p>A character vector, containing the names of factor levels to be &quot;burst.&quot;  When a factor level is burst, the corresponding observations are no longer replicates; they become singletons.
</p>
</td></tr>
<tr><td><code id="replicate.matrix_+3A_return.factor">return.factor</code></td>
<td>

<p>Return a factor instead of the mapping matrix.  This may be useful in two situations: (1) When the input is a mapping matrix, and it is desired to convert it back to a factor; (2) When making repeated calls to <code>replicate.matrix</code> in order to define the replicates in several steps.  Example of (2): Suppose there are 4 patients and 3 sample dates.  We wish to designate as replicates observations that have the same patient ID and sample date, but only for the first two sample dates; none of the observations in the third sample date should be considered replicates.  We would first call <code>replicate.matrix</code> using only the sampleDate factor, bursting the third level, and returning another factor.  We would then call <code>replicate.matrix</code> again, this time with a dataframe containing patientID and the bursted sampleDate.  See below for example code.
</p>
</td></tr>
<tr><td><code id="replicate.matrix_+3A_name">name</code></td>
<td>

<p>Name of the mapping matrix.  Used to name columns that aren't already named (e.g. M1, M2, etc.)
</p>
</td></tr>
<tr><td><code id="replicate.matrix_+3A_sep">sep</code></td>
<td>

<p>Text separating the level names of different factors when they are combined.  
</p>
</td></tr>
<tr><td><code id="replicate.matrix_+3A_burstsep">burstsep</code></td>
<td>

<p>Text appended to factor level names when bursting a factor.  This text is then followed by a number.  Example: if the factor level to be burst is &quot;June29&quot;, and burstsep is the default value of &quot;_&quot;, then the new levels will be &quot;June29_1&quot;, &quot;June29_2&quot;, etc.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a factor, depending on the value of <code>return.factor</code>.
</p>


<h3>Warning </h3>

<p>Be sure to change the default values of <code>sep</code> and <code>burstsep</code> if there is any risk of factor level naming conflicts (e.g. if existing factors already have level names like &quot;patient_1&quot;, &quot;patient_2&quot;, etc.</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUVIII">RUVIII</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define patientID and sampleDate
patientID = paste("patient", rep(1:4, each=6), sep="")
#print(patientID)
sampleDate = paste("June", rep(c(12,17,29), 8), sep="")
#print(sampleDate)
# Create a mapping matrix, where every unique 
# patientID / sampleDate combination define a set of replicates
M = replicate.matrix(data.frame(patientID, sampleDate))
#print(M)
# Convert M back to a factor
M = replicate.matrix(M, return.factor=TRUE)
#print(M)
# Create a factor for sampleDate, but burst the third date
temp = replicate.matrix(sampleDate, burst="June29", return.factor=TRUE)
#print(temp)
# Create a mapping matrix as described above in the description of return.factor
M = replicate.matrix(data.frame(temp, patientID))
#print(M)
</code></pre>

<hr>
<h2 id='residop'>
Residual Operator
</h2><span id='topic+residop'></span>

<h3>Description</h3>

<p>Applies the residual operator of a matrix B to a matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residop(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residop_+3A_a">A</code></td>
<td>

<p>A matrix with m rows.
</p>
</td></tr>
<tr><td><code id="residop_+3A_b">B</code></td>
<td>

<p>Another matrix with m rows.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns of B must be linearly independent.
</p>


<h3>Value</h3>

<p>The matrix A after projection into the orthogonal complement of the column space of B.
</p>

<hr>
<h2 id='ruv_cancorplot'>
RUV Canonical Correlation Plot
</h2><span id='topic+ruv_cancorplot'></span>

<h3>Description</h3>

<p>Canonical correlation plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_cancorplot(Y, X, ctl, W1 = NULL, W2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_cancorplot_+3A_y">Y</code></td>
<td>

<p>The data matrix.  Rows are observations and columns are features (e.g. genes).  
</p>
</td></tr>
<tr><td><code id="ruv_cancorplot_+3A_x">X</code></td>
<td>

<p>Factor(s) of interest.  Can be a vector, factor, matrix, or dataframe.  Must have the same length (or number of rows) as the number of row of Y.  
</p>
</td></tr>
<tr><td><code id="ruv_cancorplot_+3A_ctl">ctl</code></td>
<td>

<p>Index of negative controls.
</p>
</td></tr>
<tr><td><code id="ruv_cancorplot_+3A_w1">W1</code></td>
<td>

<p>Optional.  The left singular vectors of <code>Y</code>.  Can be included to speed up execution.
</p>
</td></tr>
<tr><td><code id="ruv_cancorplot_+3A_w2">W2</code></td>
<td>

<p>Optional.  The left singular vectors of <code>Y[,ctl]</code>.  Can be included to speed up execution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots, as a function of k, the square of of the first canonical correlation of <code>X</code> and the first k left singular vectors of <code>Y</code> (and also, similarly, <code>Y[,ctl]</code>).
</p>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_ecdf'>
RUV P-value Empirical CDF Plot
</h2><span id='topic+ruv_ecdf'></span>

<h3>Description</h3>

<p>Plots an ECDF of p-values returned by a call to <code><a href="#topic+ruv_summary">ruv_summary</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_ecdf(fit, X.col = "all", power = 1, uniform.lines = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_ecdf_+3A_fit">fit</code></td>
<td>

<p>The results of a call to <code><a href="#topic+ruv_summary">ruv_summary</a></code>.
</p>
</td></tr>
<tr><td><code id="ruv_ecdf_+3A_x.col">X.col</code></td>
<td>

<p>Which column of the X matrix to make the plot for, i.e. which factor's p-values to plot.  Can be either an integer or a character string.  Or, if &quot;all&quot; (the default), use the F-test p-values.
</p>
</td></tr>
<tr><td><code id="ruv_ecdf_+3A_power">power</code></td>
<td>

<p>A power transformation of the x and y axes.  For example, set to 1/2 for a square-root transformation.  This can help to see the behavior of the ECDF near 0.
</p>
</td></tr>
<tr><td><code id="ruv_ecdf_+3A_uniform.lines">uniform.lines</code></td>
<td>

<p>A vector of values between 0 and 1, or NULL.  If specified, light gray lines will be drawn, showing (locally) uniform distributions. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_hist'>
RUV P-value Histogram Plot
</h2><span id='topic+ruv_hist'></span>

<h3>Description</h3>

<p>Plots a histogram of p-values returned by a call to <code><a href="#topic+ruv_summary">ruv_summary</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_hist(fit, X.col = "all", breaks = c(0, 0.001, 0.01, 0.05, seq(0.1, 1, by = 0.1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_hist_+3A_fit">fit</code></td>
<td>

<p>The results of a call to <code><a href="#topic+ruv_summary">ruv_summary</a></code>.
</p>
</td></tr>
<tr><td><code id="ruv_hist_+3A_x.col">X.col</code></td>
<td>

<p>Which column of the X matrix to make the plot for, i.e. which factor's p-values to plot.  Can be either an integer or a character string.  Or, if &quot;all&quot; (the default), use the F-test p-values.
</p>
</td></tr>
<tr><td><code id="ruv_hist_+3A_breaks">breaks</code></td>
<td>

<p>Breakpoints of the histogram.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_projectionplot'>
RUV Projection Plot
</h2><span id='topic+ruv_projectionplot'></span>

<h3>Description</h3>

<p>Projection plot of an RUV regression fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_projectionplot(fit, X.col = 1, factor = "gradient", adjusted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_projectionplot_+3A_fit">fit</code></td>
<td>

<p>The results of a call to <code><a href="#topic+ruv_summary">ruv_summary</a></code>.
</p>
</td></tr>
<tr><td><code id="ruv_projectionplot_+3A_x.col">X.col</code></td>
<td>

<p>Which column of the X matrix to make the plot for.  Can be either an integer or a character string.
</p>
</td></tr>
<tr><td><code id="ruv_projectionplot_+3A_factor">factor</code></td>
<td>

<p>Which unwanted factor to use (horizontal axis).  Must be either an integer or the character string &quot;gradient&quot;.
</p>
</td></tr>
<tr><td><code id="ruv_projectionplot_+3A_adjusted">adjusted</code></td>
<td>

<p>Whether the plot should be adjusted for unwanted factors other than the one being plotted.  Not relevant when <code>factor = "gradient"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_rankplot'>
RUV Rank Plot
</h2><span id='topic+ruv_rankplot'></span>

<h3>Description</h3>

<p>A plot showing the number of positive controls to be found within the N top-ranked features, as a function of N.  The ranking of the features is by p-value. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_rankplot(fit, pctl, X.col = "all", uniform.lines = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_rankplot_+3A_fit">fit</code></td>
<td>

<p>The results of a call to <code><a href="#topic+ruv_summary">ruv_summary</a></code>.
</p>
</td></tr>
<tr><td><code id="ruv_rankplot_+3A_pctl">pctl</code></td>
<td>

<p>Either an integer or character string specifying which column of <code>fit$C</code> to be used as positive controls.  (Must be a logical vector).  Alternatively, may some other index vector specifying the positive controls; importantly, in this case, the index vector must index the features as they are sorted in <code>fit$C</code>.
</p>
</td></tr>
<tr><td><code id="ruv_rankplot_+3A_x.col">X.col</code></td>
<td>

<p>Which column of the X matrix to make the plot for.  Can be either an integer or a character string.  Or, if &quot;all&quot; (the default), use the F-test p-values.
</p>
</td></tr>
<tr><td><code id="ruv_rankplot_+3A_uniform.lines">uniform.lines</code></td>
<td>

<p>A vector of values between 0 and 1, or NULL.  If specified, light gray lines will be drawn, showing (locally) uniform distributions. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_residuals'>
RUV Residuals
</h2><span id='topic+ruv_residuals'></span>

<h3>Description</h3>

<p>Calculate the residuals or adjusted data matrix of an RUV2 or RUV4 fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_residuals(fit, type=c("residuals", "adjusted.Y"), subset_and_sort=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_residuals_+3A_fit">fit</code></td>
<td>

<p>The results of a call to <code><a href="#topic+ruv_summary">ruv_summary</a></code>.
</p>
</td></tr>
<tr><td><code id="ruv_residuals_+3A_type">type</code></td>
<td>

<p>Whether to compute residuals or an adjusted data matrix.  Caution; see details below.
</p>
</td></tr>
<tr><td><code id="ruv_residuals_+3A_subset_and_sort">subset_and_sort</code></td>
<td>

<p>Whether to subset and sort the features, as in <code><a href="#topic+ruv_summary">ruv_summary</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return either the residuals or an adjusted data matrix.  The residuals are the result of removing all factors (wanted and unwanted), whereas the adjusted data matrix is the result of removing only the unwanted factors.  
</p>
<p>The residuals can be useful for diagnostics, e.g. in producing a residual RLE plot.  The adjusted data matrix may also be useful for diagnostics, but typically should *not* be used for any additional downstream analyses.  The adjusted data matrix can suffer from overfitting, which can be severe, especially when k is large, and this can produce artificially &quot;good&quot; results in downstream analyses.  
</p>
<p>If an adjusted data matrix for use in downstream analyses is desired, see <code><a href="#topic+RUVIII">RUVIII</a></code>.
</p>


<h3>Value</h3>

<p>Either a matrix of residuals, or an adjusted data matrix.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV2">RUV2</a></code>, <code><a href="#topic+RUV4">RUV4</a></code>, <code><a href="#topic+ruv_summary">ruv_summary</a></code>, <code><a href="#topic+RUVIII">RUVIII</a></code>
</p>

<hr>
<h2 id='ruv_rle'>
RUV RLE Plot
</h2><span id='topic+ruv_rle'></span>

<h3>Description</h3>

<p>An RLE (Relative Log Expression) Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_rle(Y, rowinfo = NULL, probs = c(0.05, 0.25, 0.5, 0.75, 0.95), ylim = c(-0.5, 0.5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_rle_+3A_y">Y</code></td>
<td>

<p>The data matrix.  Rows are observations and columns are features (e.g. genes).
</p>
</td></tr>
<tr><td><code id="ruv_rle_+3A_rowinfo">rowinfo</code></td>
<td>

<p>A dataframe of information about the observations.  Should have the same number of rows as Y.  This information will be included in the ggplot, and can be used for setting aesthetics such as color.
</p>
</td></tr>
<tr><td><code id="ruv_rle_+3A_probs">probs</code></td>
<td>

<p>The percentiles used to construct the boxplots.  By default, whiskers are drawn to the 5th and 95th percentiles.  Note that this is non-standard for boxplots.
</p>
</td></tr>
<tr><td><code id="ruv_rle_+3A_ylim">ylim</code></td>
<td>

<p>Limits of the y axis.  Defaults to (-0.5, 0.5) so that the plots are always on the same scale and can be easily compared.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>


<h3>References</h3>

<p>Irizarry, R. A.,  Bolstad, B. M., Collin, F., Cope, L. M., Hobbs, B., and Speed, T. P. (2003).  Summaries of Affymetrix GeneChip probe level data.  Nucleic acids research, 31(4):e15.
</p>

<hr>
<h2 id='ruv_scree'>
RUV Scree Plot
</h2><span id='topic+ruv_scree'></span>

<h3>Description</h3>

<p>A scree plot (on the log scale)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_scree(Y = NULL, Z = 1, Y.svd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_scree_+3A_y">Y</code></td>
<td>

<p>The data matrix.  Rows are observations and columns are features (e.g. genes).  If not specified, Y.svd must be specified instead (which is faster).
</p>
</td></tr>
<tr><td><code id="ruv_scree_+3A_z">Z</code></td>
<td>

<p>Any variables to regress out of Y as a preprocessing step.  May simply be 1 (the default) for an intercept term, i.e. the columns of Y are mean centered.  May also be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="ruv_scree_+3A_y.svd">Y.svd</code></td>
<td>

<p>The SVD of Y, as returned by the svd function.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because 0 cannot be plotted on a log scale, if any singular values are equal to 0, they will be changed to the minimum non-zero singular value and plotted in red.  Exception: singular values that are 0 as a result of regressing out Z are simply not plotted.
</p>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_shiny'>
RUV Shiny App
</h2><span id='topic+ruv_shiny'></span>

<h3>Description</h3>

<p>A Shiny App that allows quick exploration of a dataset using RUV methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_shiny(Y, rowinfo, colinfo, options = list(port = 3840)) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_shiny_+3A_y">Y</code></td>
<td>

<p>The data matrix.  Rows are observations and columns are features (e.g. genes).
</p>
</td></tr>
<tr><td><code id="ruv_shiny_+3A_rowinfo">rowinfo</code></td>
<td>

<p>A dataframe of information about the observations.  Should have the same number of rows as Y.  Should contain at least one column that can be used as either a factor of interest or to define replicates.
</p>
</td></tr>
<tr><td><code id="ruv_shiny_+3A_colinfo">colinfo</code></td>
<td>

<p>A dataframe of information about the observations.  Should have the same number of rows as Y.  Should contain at least one column that is a logical vector that can be used to define negative controls.
</p>
</td></tr>
<tr><td><code id="ruv_shiny_+3A_options">options</code></td>
<td>

<p>A list of options to pass to the shinyApp function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.  Calls shinyApp.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_summary'>
RUV Summary
</h2><span id='topic+ruv_summary'></span>

<h3>Description</h3>

<p>Post-process and summarize the results of call to RUV2, RUV4, RUVinv, or RUVrinv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_summary(Y, fit, rowinfo=NULL, colinfo=NULL, colsubset=NULL, sort.by="F.p", 
            var.type=c("ebayes", "standard", "pooled"),
            p.type=c("standard", "rsvar", "evar"), min.p.cutoff=10e-25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_summary_+3A_y">Y</code></td>
<td>

<p>The original data matrix used in the call to RUV2/4/inv/rinv
</p>
</td></tr>
<tr><td><code id="ruv_summary_+3A_fit">fit</code></td>
<td>

<p>A RUV model fit (a list), as returned by RUV2 / RUV4 / RUVinv / RUVrinv
</p>
</td></tr>
<tr><td><code id="ruv_summary_+3A_rowinfo">rowinfo</code></td>
<td>

<p>A matrix or dataframe containing information about the rows (samples).  This information is included in the summary that is returned.
</p>
</td></tr>
<tr><td><code id="ruv_summary_+3A_colinfo">colinfo</code></td>
<td>

<p>A matrix or dataframe containing information about the columns (features, e.g. genes).  This information is included in the summary that is returned.
</p>
</td></tr>
<tr><td><code id="ruv_summary_+3A_colsubset">colsubset</code></td>
<td>

<p>A vector indexing the features of interest.  Only only data on these features will be returned.
</p>
</td></tr>
<tr><td><code id="ruv_summary_+3A_sort.by">sort.by</code></td>
<td>

<p>An index variable; which column of <code>C</code> (see below) should be used to sort the features.  The default is &quot;F.p&quot;, meaning that features will be sorted by the F-test p-value.  If <code>NULL</code>, features will note be sorted.
</p>
</td></tr>
<tr><td><code id="ruv_summary_+3A_var.type">var.type</code></td>
<td>

<p>Which type of estimate for sigma2 should be used from the call to <a href="#topic+variance_adjust">variance_adjust</a>?  The options are &quot;ebayes&quot;, &quot;standard&quot;, or &quot;pooled.&quot;  See <a href="#topic+variance_adjust">variance_adjust</a> for details.
</p>
</td></tr>
<tr><td><code id="ruv_summary_+3A_p.type">p.type</code></td>
<td>

<p>Which type of p-values should be used from the call to <a href="#topic+variance_adjust">variance_adjust</a>?  The options are &quot;standard&quot;, &quot;rsvar&quot;, or &quot;evar&quot;. 
</p>
</td></tr>
<tr><td><code id="ruv_summary_+3A_min.p.cutoff">min.p.cutoff</code></td>
<td>

<p>p-values below this value will be changed and set equal to this value.  Useful for plotting p-values on a log scale.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function post-processes the results of a call to RUV2/4/inv/rinv and then nicely summarizes the output.  The post-processing step primarily consists of a call to <a href="#topic+variance_adjust">variance_adjust</a>, which computes various adjustments to variances, t-statistics, and and p-values.  See <a href="#topic+variance_adjust">variance_adjust</a> for details.  The <code>var.type</code> and <code>p.type</code> options determine which of these adjustments are used.  An additional post-processing step is that the column means of the <code>Y</code> matrix are computed, both before and after the call to <code>RUV1</code> (if <code>eta</code> was specified).  
</p>
<p>After post-processing, the results are summarized into a list containing 4 objects: 1) the data matrix <code>Y</code>; 2) a dataframe <code>R</code> containing information about the rows (samples); 3) a dataframe <code>C</code> containing information about the columns (features, e.g. genes), and 4) a list <code>misc</code> of other information returned by RUV2/4/inv/rinv. 
</p>
<p>Finally, if <code>colsubset</code> is specified, then <code>C</code> is subset to include only the features of interest (as are the relevant entries of <code>misc</code> that are used to compute projection plots).  If <code>sort.by</code> is specified, the features will also be sorted.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>The original data matrix.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>A dataframe of row-wise information, including <code>X</code>, <code>Z</code>, and any other data passed in with <code>rowinfo</code></p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>A dataframe of column-wise information, including p-values, estimated regression coefficients, estimated variances, column means, an index of the negative controls, and any other data passed in with <code>colinfo</code>.</p>
</td></tr>
<tr><td><code>misc</code></td>
<td>
<p>A list of additional information returned by RUV2/4/inv/rinv</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV2">RUV2</a></code>, <code><a href="#topic+RUV4">RUV4</a></code>, <code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>, <code><a href="#topic+variance_adjust">variance_adjust</a></code>
</p>

<hr>
<h2 id='ruv_svdgridplot'>
RUV SVD Grid Plot
</h2><span id='topic+ruv_svdgridplot'></span>

<h3>Description</h3>

<p>A plot composed of a grid of several subplots created by <code><a href="#topic+ruv_svdplot">ruv_svdplot</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_svdgridplot(Y.data, Y.space = NULL, rowinfo = NULL, colinfo = NULL, k = 1:3, Z = 1,
                left.additions = NULL, right.additions = NULL, 
                factor.labels = paste("S.V.", k))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_svdgridplot_+3A_y.data">Y.data</code></td>
<td>

<p>The data matrix.  Rows are observations and columns are features (e.g. genes).
</p>
</td></tr>
<tr><td><code id="ruv_svdgridplot_+3A_y.space">Y.space</code></td>
<td>

<p>Either a data matrix of the same dimension as <code>Y.data</code>, or the SVD of such a matrix, as returned by the <code>svd</code> function.  The singular vectors of this matrix define the space in which <code>Y.data</code> will be plotted.  If NULL, <code>Y.data</code> itself is used.
</p>
</td></tr>
<tr><td><code id="ruv_svdgridplot_+3A_rowinfo">rowinfo</code></td>
<td>

<p>A dataframe of information about the observations.  Should have the same number of rows as Y.  This information will be included in the ggplots, and can be used for setting aesthetics such as color.
</p>
</td></tr>
<tr><td><code id="ruv_svdgridplot_+3A_colinfo">colinfo</code></td>
<td>

<p>A dataframe of information about the observations.  Should have a number of rows equal to the number of columns of Y.  This information will be included in the ggplots, and can be used for setting aesthetics such as color.
</p>
</td></tr>
<tr><td><code id="ruv_svdgridplot_+3A_k">k</code></td>
<td>

<p>A numeric vector of the singular vectors to be plotted.  Typically integers, but fractional values can also be specified.  For example, a value of 2.5 corresponds to the linear combination (singular vector 2) + (singular vector 3), rescaled to have unit length.  Similarly, a value of 2.2 corresponds to the (rescaled) linear combination 8*(singular vector 2) + 2*(singular vector 3), and -2.2 corresponds to the (rescaled) linear combination 8*(singular vector 2) - 2*(singular vector 3).  Note that the vectors defined by 2.2 and -2.8 are orthogonal to each other, as are those defined by 2.3 and -2.7, etc.
</p>
</td></tr>
<tr><td><code id="ruv_svdgridplot_+3A_z">Z</code></td>
<td>

<p>Any variables to regress out of <code>Y.data</code> as a preprocessing step.  May simply be 1 (the default) for an intercept term, i.e. the columns of Y are mean centered.  May also be <code>NULL</code>.  Similarly for <code>Y.space</code>, unless <code>Y.space</code> is already an SVD.
</p>
</td></tr>
<tr><td><code id="ruv_svdgridplot_+3A_left.additions">left.additions</code></td>
<td>

<p>A list of additions to the ggplots of the left singular vectors.  Can be used to set aesthetics such as color, etc.
</p>
</td></tr>
<tr><td><code id="ruv_svdgridplot_+3A_right.additions">right.additions</code></td>
<td>

<p>A list of additions to the ggplots of the right singular vectors.  Can be used to set aesthetics such as color, etc.
</p>
</td></tr>
<tr><td><code id="ruv_svdgridplot_+3A_factor.labels">factor.labels</code></td>
<td>

<p>The factor labels.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots of the left singular vectors are shown on the left, and plots of the right singular vectors are shown on the right.  The diagonal shows squares with side lengths proportional to the singular values.  
</p>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_svdplot'>
RUV SVD Plot
</h2><span id='topic+ruv_svdplot'></span>

<h3>Description</h3>

<p>A generalization of a PC (principal component) plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_svdplot(Y.data, Y.space = NULL, info = NULL, k = c(1, 2), Z = 1, left = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_svdplot_+3A_y.data">Y.data</code></td>
<td>

<p>The data matrix.  Rows are observations and columns are features (e.g. genes).
</p>
</td></tr>
<tr><td><code id="ruv_svdplot_+3A_y.space">Y.space</code></td>
<td>

<p>Either a data matrix of the same dimension as <code>Y.data</code>, or the SVD of such a matrix, as returned by the <code>svd</code> function.  The singular vectors of this matrix define the space in which <code>Y.data</code> will be plotted.  If NULL, <code>Y.data</code> itself is used.
</p>
</td></tr>
<tr><td><code id="ruv_svdplot_+3A_info">info</code></td>
<td>

<p>Additional data to be included in the ggplot, which can be used for setting aesthetics such as color.  Converted to a dataframe, which should have a number of rows equal to the number of rows of <code>Y.data</code> (if <code>left=TRUE</code>) or the number of columns of <code>Y.data</code> (if <code>left=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="ruv_svdplot_+3A_k">k</code></td>
<td>

<p>A numeric vector of length 2.  The singular vectors to be plotted.  Typically integers, but fractional values can also be specified.  For example, a value of 2.5 corresponds to the linear combination (singular vector 2) + (singular vector 3), rescaled to have unit length.  Similarly, a value of 2.2 corresponds to the (rescaled) linear combination 8*(singular vector 2) + 2*(singular vector 3), and -2.2 corresponds to the (rescaled) linear combination 8*(singular vector 2) - 2*(singular vector 3).  Note that the vectors defined by 2.2 and -2.8 are orthogonal to each other, as are those defined by 2.3 and -2.7, etc.
</p>
</td></tr>
<tr><td><code id="ruv_svdplot_+3A_z">Z</code></td>
<td>

<p>Any variables to regress out of <code>Y.data</code> as a preprocessing step.  May simply be 1 (the default) for an intercept term, i.e. the columns of Y are mean centered.  May also be <code>NULL</code>.  Similarly for <code>Y.space</code>, unless <code>Y.space</code> is already an SVD.
</p>
</td></tr>
<tr><td><code id="ruv_svdplot_+3A_left">left</code></td>
<td>

<p>Plot the left singular vectors (if TRUE) or the right singular vectors (if FALSE).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>Y.space = NULL</code> and <code>Z = 1</code> and the values of <code>k</code> are integers, this is a standard PC plot.
</p>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_varianceplot'>
RUV Variance Plot
</h2><span id='topic+ruv_varianceplot'></span>

<h3>Description</h3>

<p>A scatter plot of (squared) coefficient estimates against variance estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_varianceplot(fit, X.col = 1, power = 1/4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_varianceplot_+3A_fit">fit</code></td>
<td>

<p>The results of a call to <code><a href="#topic+ruv_summary">ruv_summary</a></code>.
</p>
</td></tr>
<tr><td><code id="ruv_varianceplot_+3A_x.col">X.col</code></td>
<td>

<p>Which column of the X matrix to make the plot for.  Can be either an integer or a character string.
</p>
</td></tr>
<tr><td><code id="ruv_varianceplot_+3A_power">power</code></td>
<td>

<p>Power transformation of the x and y axes.  Default is fourth root.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A black curve is also plotted, showing the estimated variances of the coefficient estimates.
</p>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='ruv_volcano'>
RUV Volcano Plot
</h2><span id='topic+ruv_volcano'></span>

<h3>Description</h3>

<p>A scatter plot of negative log p-values against coefficient estimates, commonly known as a volcano plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruv_volcano(fit, X.col = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruv_volcano_+3A_fit">fit</code></td>
<td>

<p>The results of a call to <code><a href="#topic+ruv_summary">ruv_summary</a></code>.
</p>
</td></tr>
<tr><td><code id="ruv_volcano_+3A_x.col">X.col</code></td>
<td>

<p>Which column of the X matrix to make the plot for.  Can be either an integer or a character string.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>

<hr>
<h2 id='RUV2'>
Remove Unwanted Variation, 2-step
</h2><span id='topic+RUV2'></span>

<h3>Description</h3>

<p>The RUV-2 algorithm.  Estimates and adjusts for unwanted variation using negative controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RUV2(Y, X, ctl, k, Z=1, eta=NULL, include.intercept=TRUE,
fullW=NULL, svdyc=NULL, do_projectionplot=TRUE, inputcheck=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RUV2_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_x">X</code></td>
<td>

<p>The factor(s) of interest.  A m by p matrix, where m is the number of samples and p is the number of factors of interest.  Very often p = 1.  Factors and dataframes are also permissible, and converted to a matrix by <code><a href="#topic+design.matrix">design.matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_ctl">ctl</code></td>
<td>

<p>An index vector to specify the negative controls.  Either a logical vector of length n or a vector of integers.  
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_k">k</code></td>
<td>

<p>The number of unwanted factors to use.  Can be 0.
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_z">Z</code></td>
<td>

<p>Any additional covariates to include in the model, typically a m by q matrix.  Factors and dataframes are also permissible, and converted to a matrix by <code><a href="#topic+design.matrix">design.matrix</a></code>.  Alternatively, may simply be 1 (the default) for an intercept term.  May also be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_eta">eta</code></td>
<td>

<p>Gene-wise (as opposed to sample-wise) covariates.  These covariates are adjusted for by RUV-1 before any further analysis proceeds.  Can be either (1) a matrix with n columns, (2) a matrix with n rows, (3) a dataframe with n rows, (4) a vector or factor of length n, or (5) simply 1, for an intercept term.  
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_include.intercept">include.intercept</code></td>
<td>

<p>Applies to both <code>Z</code> and <code>eta</code>.  When <code>Z</code> or <code>eta</code> (or both) is specified (not <code>NULL</code>) but does not already include an intercept term, this will automatically include one.  If only one of <code>Z</code> or <code>eta</code> should include an intercept, this variable should be set to <code>FALSE</code>, and the intercept term should be included manually where desired.
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_fullw">fullW</code></td>
<td>

<p>Can be included to speed up execution.  Is returned by previous calls of <code>RUV2</code> (see  below).
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_svdyc">svdyc</code></td>
<td>

<p>Can be included to speed up execution.  For internal use; please use <code>fullW</code> instead.
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_do_projectionplot">do_projectionplot</code></td>
<td>

<p>Calculate the quantities necessary to generate a projection plot.
</p>
</td></tr>
<tr><td><code id="RUV2_+3A_inputcheck">inputcheck</code></td>
<td>

<p>Perform a basic sanity check on the inputs, and issue a warning if there is a problem.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the RUV-2 algorithm as described in Gagnon-Bartsch and Speed (2012), using the SVD as the factor analysis routine.  Unwanted factors W are estimated using control genes.  Y is then regressed on the variables X, Z, and W.   
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>betahat</code></td>
<td>
<p>The estimated coefficients of the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimates of the features' variances.  A vector of length n.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>t statistics for the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>P-values for the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>Fstats</code></td>
<td>
<p>F statistics for testing all of the factors in <code>X</code> simultaneously.</p>
</td></tr>
<tr><td><code>Fpvals</code></td>
<td>
<p>P-values for testing all of the factors in <code>X</code> simultaneously.</p>
</td></tr>
<tr><td><code>multiplier</code></td>
<td>
<p>The constant by which <code>sigma2</code> must be multiplied in order get an estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of residual degrees of freedom.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>The estimated unwanted factors.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The estimated coefficients of W.</p>
</td></tr>
<tr><td><code>byx</code></td>
<td>
<p>The coefficients in a regression of Y on X (after both Y and X have been &quot;adjusted&quot; for Z).  Useful for projection plots.</p>
</td></tr>
<tr><td><code>bwx</code></td>
<td>
<p>The coefficients in a regression of W on X (after X has been &quot;adjusted&quot; for Z).  Useful for projection plots.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p><code>X</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p><code>k</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>ctl</code></td>
<td>
<p><code>ctl</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p><code>Z</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p><code>eta</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>fullW</code></td>
<td>
<p>Can be used to speed up future calls of RUV2.</p>
</td></tr>
<tr><td><code>projectionplotW</code></td>
<td>
<p>A reparameterization of W useful for projection plots.</p>
</td></tr>
<tr><td><code>projectionplotalpha</code></td>
<td>
<p>A reparameterization of alpha useful for projection plots.</p>
</td></tr>
<tr><td><code>include.intercept</code></td>
<td>
<p><code>include.intercept</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Character variable with value &quot;RUV2&quot;.  Included for reference.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Additional resources can be found at <a href="http://www-personal.umich.edu/~johanngb/ruv/">http://www-personal.umich.edu/~johanngb/ruv/</a>. 
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>References</h3>

<p>Using control genes to correct for unwanted variation in microarray data.  Gagnon-Bartsch and Speed, 2012.  Available at: <a href="http://biostatistics.oxfordjournals.org/content/13/3/539.full">http://biostatistics.oxfordjournals.org/content/13/3/539.full</a>. 
</p>
<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV4">RUV4</a></code>, <code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>, <code><a href="#topic+variance_adjust">variance_adjust</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create some simulated data
m = 50
n = 10000
nc = 1000
p = 1
k = 20
ctl = rep(FALSE, n)
ctl[1:nc] = TRUE
X = matrix(c(rep(0,floor(m/2)), rep(1,ceiling(m/2))), m, p)
beta = matrix(rnorm(p*n), p, n)
beta[,ctl] = 0
W = matrix(rnorm(m*k),m,k)
alpha = matrix(rnorm(k*n),k,n)
epsilon = matrix(rnorm(m*n),m,n)
Y = X%*%beta + W%*%alpha + epsilon

## Run RUV-2
fit = RUV2(Y, X, ctl, k)

## Get adjusted variances and p-values
fit = variance_adjust(fit)
</code></pre>

<hr>
<h2 id='RUV4'>
Remove Unwanted Variation, 4-step
</h2><span id='topic+RUV4'></span>

<h3>Description</h3>

<p>The RUV-4 algorithm.  Estimates and adjusts for unwanted variation using negative controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RUV4(Y, X, ctl, k, Z = 1, eta = NULL, include.intercept=TRUE,
fullW0=NULL, inputcheck=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RUV4_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="RUV4_+3A_x">X</code></td>
<td>

<p>The factor(s) of interest.  A m by p matrix, where m is the number of samples and p is the number of factors of interest.  Very often p = 1.  Factors and dataframes are also permissible, and converted to a matrix by <code><a href="#topic+design.matrix">design.matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="RUV4_+3A_ctl">ctl</code></td>
<td>

<p>An index vector to specify the negative controls.  Either a logical vector of length n or a vector of integers.  
</p>
</td></tr>
<tr><td><code id="RUV4_+3A_k">k</code></td>
<td>

<p>The number of unwanted factors to use.  Can be 0.
</p>
</td></tr>
<tr><td><code id="RUV4_+3A_z">Z</code></td>
<td>

<p>Any additional covariates to include in the model, typically a m by q matrix.  Factors and dataframes are also permissible, and converted to a matrix by <code><a href="#topic+design.matrix">design.matrix</a></code>.  Alternatively, may simply be 1 (the default) for an intercept term.  May also be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="RUV4_+3A_eta">eta</code></td>
<td>

<p>Gene-wise (as opposed to sample-wise) covariates.  These covariates are adjusted for by RUV-1 before any further analysis proceeds.  Can be either (1) a matrix with n columns, (2) a matrix with n rows, (3) a dataframe with n rows, (4) a vector or factor of length n, or (5) simply 1, for an intercept term.  
</p>
</td></tr>
<tr><td><code id="RUV4_+3A_include.intercept">include.intercept</code></td>
<td>

<p>Applies to both <code>Z</code> and <code>eta</code>.  When <code>Z</code> or <code>eta</code> (or both) is specified (not <code>NULL</code>) but does not already include an intercept term, this will automatically include one.  If only one of <code>Z</code> or <code>eta</code> should include an intercept, this variable should be set to <code>FALSE</code>, and the intercept term should be included manually where desired.
</p>
</td></tr>
<tr><td><code id="RUV4_+3A_fullw0">fullW0</code></td>
<td>

<p>Can be included to speed up execution.  Is returned by previous calls of <code>RUV4</code>, <code>RUVinv</code>, or <code>RUVrinv</code> (see  below).
</p>
</td></tr>
<tr><td><code id="RUV4_+3A_inputcheck">inputcheck</code></td>
<td>

<p>Perform a basic sanity check on the inputs, and issue a warning if there is a problem.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the RUV-4 algorithm as described in Gagnon-Bartsch, Jacob, and Speed (2013), using the SVD as the factor analysis routine.  Unwanted factors W are estimated using control genes.  Y is then regressed on the variables X, Z, and W.   
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>betahat</code></td>
<td>
<p>The estimated coefficients of the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimates of the features' variances.  A vector of length n.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>t statistics for the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>P-values for the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>Fstats</code></td>
<td>
<p>F statistics for testing all of the factors in <code>X</code> simultaneously.</p>
</td></tr>
<tr><td><code>Fpvals</code></td>
<td>
<p>P-values for testing all of the factors in <code>X</code> simultaneously.</p>
</td></tr>
<tr><td><code>multiplier</code></td>
<td>
<p>The constant by which <code>sigma2</code> must be multiplied in order get an estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of residual degrees of freedom.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>The estimated unwanted factors.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The estimated coefficients of W.</p>
</td></tr>
<tr><td><code>byx</code></td>
<td>
<p>The coefficients in a regression of Y on X (after both Y and X have been &quot;adjusted&quot; for Z).  Useful for projection plots.</p>
</td></tr>
<tr><td><code>bwx</code></td>
<td>
<p>The coefficients in a regression of W on X (after X has been &quot;adjusted&quot; for Z).  Useful for projection plots.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p><code>X</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p><code>k</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>ctl</code></td>
<td>
<p><code>ctl</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p><code>Z</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p><code>eta</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>fullW0</code></td>
<td>
<p>Can be used to speed up future calls of RUV4.</p>
</td></tr>
<tr><td><code>include.intercept</code></td>
<td>
<p><code>include.intercept</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Character variable with value &quot;RUV4&quot;.  Included for reference.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Additional resources can be found at <a href="http://www-personal.umich.edu/~johanngb/ruv/">http://www-personal.umich.edu/~johanngb/ruv/</a>. 
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>References</h3>

<p>Using control genes to correct for unwanted variation in microarray data.  Gagnon-Bartsch and Speed, 2012.  Available at: <a href="http://biostatistics.oxfordjournals.org/content/13/3/539.full">http://biostatistics.oxfordjournals.org/content/13/3/539.full</a>. 
</p>
<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV2">RUV2</a></code>, <code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>, <code><a href="#topic+variance_adjust">variance_adjust</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create some simulated data
m = 50
n = 10000
nc = 1000
p = 1
k = 20
ctl = rep(FALSE, n)
ctl[1:nc] = TRUE
X = matrix(c(rep(0,floor(m/2)), rep(1,ceiling(m/2))), m, p)
beta = matrix(rnorm(p*n), p, n)
beta[,ctl] = 0
W = matrix(rnorm(m*k),m,k)
alpha = matrix(rnorm(k*n),k,n)
epsilon = matrix(rnorm(m*n),m,n)
Y = X%*%beta + W%*%alpha + epsilon

## Run RUV-4
fit = RUV4(Y, X, ctl, k)

## Get adjusted variances and p-values
fit = variance_adjust(fit)
</code></pre>

<hr>
<h2 id='RUVI'>
RUV-I
</h2><span id='topic+RUVI'></span><span id='topic+RUV1'></span>

<h3>Description</h3>

<p>The RUV-I algorithm.  Generally used as a preprocessing step to RUV-2, RUV-4, RUV-inv, RUV-rinv, or RUVIII.  RUV1 is an alias of (identical to) RUVI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RUVI(Y, eta, ctl, include.intercept = TRUE)

RUV1(Y, eta, ctl, include.intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RUVI_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="RUVI_+3A_eta">eta</code></td>
<td>

<p>Gene-wise (as opposed to sample-wise) covariates.  A matrix with n columns.
</p>
</td></tr>
<tr><td><code id="RUVI_+3A_ctl">ctl</code></td>
<td>

<p>The negative controls.  A logical vector of length n.  
</p>
</td></tr>
<tr><td><code id="RUVI_+3A_include.intercept">include.intercept</code></td>
<td>

<p>Add an intercept term to eta if it does not include one already.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the RUV-I algorithm as described in Gagnon-Bartsch, Jacob, and Speed (2013).  Most often this algorithm is not used directly, but rather is called from RUV-2, RUV-4, RUV-inv, or RUV-rinv.  Note that RUV1 and RUVI are two different names for the same (identical) function.
</p>


<h3>Value</h3>

<p>An adjusted data matrix (i.e., an adjusted Y)
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>References</h3>

<p>Using control genes to correct for unwanted variation in microarray data.  Gagnon-Bartsch and Speed, 2012.  Available at: <a href="http://biostatistics.oxfordjournals.org/content/13/3/539.full">http://biostatistics.oxfordjournals.org/content/13/3/539.full</a>. 
</p>
<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV2">RUV2</a></code>, <code><a href="#topic+RUV4">RUV4</a></code>, <code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>, <code><a href="#topic+RUVIII">RUVIII</a></code>
</p>

<hr>
<h2 id='RUVIII'>
RUV-III
</h2><span id='topic+RUVIII'></span>

<h3>Description</h3>

<p>Globally adjust data matrix using both negative controls and replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RUVIII(Y, M, ctl, k = NULL, eta = NULL, include.intercept = TRUE,
       average = FALSE, fullalpha = NULL, return.info = FALSE, inputcheck = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RUVIII_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of observations and n is the number of features.
</p>
</td></tr>
<tr><td><code id="RUVIII_+3A_m">M</code></td>
<td>

<p>The replicate structure.  Represented internally as a mapping matrix.  The mapping matrix has m rows (one for each observation), and each column represents a set of replicates.  The (i, j)-th entry of the mapping matrix is 1 if the i-th observation is in replicate set j, and 0 otherwise.  Each observation must be in exactly one set of replicates (some replicate sets may contain only one observation), and thus each row of M must sum to 1.  <code>M</code> may be the mapping matrix itself.  Alternatively, <code>M</code> may be a vector, factor, or dataframe, in which case it is converted to the mapping matrix by the <code><a href="#topic+replicate.matrix">replicate.matrix</a></code> function.
</p>
</td></tr>
<tr><td><code id="RUVIII_+3A_ctl">ctl</code></td>
<td>

<p>An index vector to specify the negative controls.  Either a logical vector of length n or a vector of integers.
</p>
</td></tr>
<tr><td><code id="RUVIII_+3A_k">k</code></td>
<td>

<p>The number of unwanted factors to use.  Can be 0, in which case no adjustment is made.  Can also be NULL (the default value), in which case the maximum possible value of k is used; note that in this case no singular value decomposition is necessary and execution is faster.
</p>
</td></tr>
<tr><td><code id="RUVIII_+3A_eta">eta</code></td>
<td>

<p>Gene-wise (as opposed to sample-wise) covariates.  These covariates are adjusted for by RUV-1 before any further analysis proceeds.  Can be either (1) a matrix with n columns, (2) a matrix with n rows, (3) a dataframe with n rows, (4) a vector or factor of length n, or (5) simply 1, for an intercept term.  
</p>
</td></tr>
<tr><td><code id="RUVIII_+3A_include.intercept">include.intercept</code></td>
<td>

<p>When <code>eta</code> is specified (not <code>NULL</code>) but does not already include an intercept term, this will automatically include one.  
</p>
</td></tr>
<tr><td><code id="RUVIII_+3A_average">average</code></td>
<td>

<p>Average replicates after adjustment. 
</p>
</td></tr>
<tr><td><code id="RUVIII_+3A_fullalpha">fullalpha</code></td>
<td>

<p>Can be included to speed up execution.  Is returned by previous calls of <code>RUVIII</code> (see  below).
</p>
</td></tr>
<tr><td><code id="RUVIII_+3A_return.info">return.info</code></td>
<td>

<p>If <code>FALSE</code>, only the adjusted data matrix is returned.  If <code>TRUE</code>, additional information is returned (see below).
</p>
</td></tr>
<tr><td><code id="RUVIII_+3A_inputcheck">inputcheck</code></td>
<td>

<p>Perform a basic sanity check on the inputs, and issue a warning if there is a problem.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If codereturn.info is <code>TRUE</code>, a list is returned that contains:
</p>
<table>
<tr><td><code>newY</code></td>
<td>
<p>The adjusted data matrix.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>The replicate mapping matrix.  Included for reference.</p>
</td></tr>
<tr><td><code>fullalpha</code></td>
<td>
<p>Can be used to speed up future calls to <code>RUVIII</code></p>
</td></tr>
</table>
<p>Otherwise, if <code>return.info</code> is <code>FALSE</code>, only the adjusted data matrix is returned.
</p>


<h3>Note</h3>

<p>Additional resources can be found at <a href="http://www-personal.umich.edu/~johanngb/ruv/">http://www-personal.umich.edu/~johanngb/ruv/</a>. 
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>

<hr>
<h2 id='RUVinv'>
Remove Unwanted Variation, inverse method
</h2><span id='topic+RUVinv'></span>

<h3>Description</h3>

<p>The RUV-inv algorithm.  Estimates and adjusts for unwanted variation using negative controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RUVinv(Y, X, ctl, Z=1, eta=NULL, include.intercept=TRUE,
       fullW0=NULL, invsvd=NULL, lambda=NULL,
       randomization=FALSE, iterN=100000, inputcheck=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RUVinv_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_x">X</code></td>
<td>

<p>The factor(s) of interest.  A m by p matrix, where m is the number of samples and p is the number of factors of interest.  Very often p = 1.  Factors and dataframes are also permissible, and converted to a matrix by <code><a href="#topic+design.matrix">design.matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_ctl">ctl</code></td>
<td>

<p>An index vector to specify the negative controls.  Either a logical vector of length n or a vector of integers.  
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_z">Z</code></td>
<td>

<p>Any additional covariates to include in the model, typically a m by q matrix.  Factors and dataframes are also permissible, and converted to a matrix by <code><a href="#topic+design.matrix">design.matrix</a></code>.  Alternatively, may simply be 1 (the default) for an intercept term.  May also be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_eta">eta</code></td>
<td>

<p>Gene-wise (as opposed to sample-wise) covariates.  These covariates are adjusted for by RUV-1 before any further analysis proceeds.  Can be either (1) a matrix with n columns, (2) a matrix with n rows, (3) a dataframe with n rows, (4) a vector or factor of length n, or (5) simply 1, for an intercept term.  
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_include.intercept">include.intercept</code></td>
<td>

<p>Applies to both <code>Z</code> and <code>eta</code>.  When <code>Z</code> or <code>eta</code> (or both) is specified (not <code>NULL</code>) but does not already include an intercept term, this will automatically include one.  If only one of <code>Z</code> or <code>eta</code> should include an intercept, this variable should be set to <code>FALSE</code>, and the intercept term should be included manually where desired.
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_fullw0">fullW0</code></td>
<td>

<p>Can be included to speed up execution.  Is returned by previous calls of <code>RUV4</code>, <code>RUVinv</code>, or <code>RUVrinv</code> (see  below).
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_invsvd">invsvd</code></td>
<td>

<p>Can be included to speed up execution.  Generally used when calling RUV(r)inv many times with different values of lambda.  Is returned by previous calls of RUV(r)inv (see  below).
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_lambda">lambda</code></td>
<td>

<p>Ridge parameter.  If specified, the ridged inverse method will be used.
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_randomization">randomization</code></td>
<td>

<p>Whether the inverse-method variances should be computed using randomly generated factors of interest (as opposed to a numerical integral).
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_itern">iterN</code></td>
<td>

<p>The number of random &quot;factors of interest&quot; to generate (used only when randomization=TRUE).
</p>
</td></tr>
<tr><td><code id="RUVinv_+3A_inputcheck">inputcheck</code></td>
<td>

<p>Perform a basic sanity check on the inputs, and issue a warning if there is a problem.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the RUV-inv algorithm as described in Gagnon-Bartsch, Jacob, and Speed (2013).  
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>betahat</code></td>
<td>
<p>The estimated coefficients of the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimates of the features' variances.  A vector of length n.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>t statistics for the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>P-values for the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>Fstats</code></td>
<td>
<p>F statistics for testing all of the factors in <code>X</code> simultaneously.</p>
</td></tr>
<tr><td><code>Fpvals</code></td>
<td>
<p>P-values for testing all of the factors in <code>X</code> simultaneously.</p>
</td></tr>
<tr><td><code>multiplier</code></td>
<td>
<p>The constant by which <code>sigma2</code> must be multiplied in order get an estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of residual degrees of freedom.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>The estimated unwanted factors.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The estimated coefficients of W.</p>
</td></tr>
<tr><td><code>byx</code></td>
<td>
<p>The coefficients in a regression of Y on X (after both Y and X have been &quot;adjusted&quot; for Z).  Useful for projection plots.</p>
</td></tr>
<tr><td><code>bwx</code></td>
<td>
<p>The coefficients in a regression of W on X (after X has been &quot;adjusted&quot; for Z).  Useful for projection plots.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p><code>X</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p><code>k</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>ctl</code></td>
<td>
<p><code>ctl</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p><code>Z</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p><code>eta</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>fullW0</code></td>
<td>
<p>Can be used to speed up future calls of RUV4.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p><code>lambda</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>invsvd</code></td>
<td>
<p>Can be used to speed up future calls of RUV(r)inv.</p>
</td></tr>
<tr><td><code>include.intercept</code></td>
<td>
<p><code>include.intercept</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Character variable with value &quot;RUVinv&quot;.  Included for reference.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Additional resources can be found at <a href="http://www-personal.umich.edu/~johanngb/ruv/">http://www-personal.umich.edu/~johanngb/ruv/</a>. 
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>References</h3>

<p>Using control genes to correct for unwanted variation in microarray data.  Gagnon-Bartsch and Speed, 2012.  Available at: <a href="http://biostatistics.oxfordjournals.org/content/13/3/539.full">http://biostatistics.oxfordjournals.org/content/13/3/539.full</a>. 
</p>
<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV2">RUV2</a></code>, <code><a href="#topic+RUV4">RUV4</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>, <code><a href="#topic+variance_adjust">variance_adjust</a></code>, <code><a href="#topic+invvar">invvar</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create some simulated data
m = 50
n = 10000
nc = 1000
p = 1
k = 20
ctl = rep(FALSE, n)
ctl[1:nc] = TRUE
X = matrix(c(rep(0,floor(m/2)), rep(1,ceiling(m/2))), m, p)
beta = matrix(rnorm(p*n), p, n)
beta[,ctl] = 0
W = matrix(rnorm(m*k),m,k)
alpha = matrix(rnorm(k*n),k,n)
epsilon = matrix(rnorm(m*n),m,n)
Y = X%*%beta + W%*%alpha + epsilon

## Run RUV-inv
fit = RUVinv(Y, X, ctl)

## Get adjusted variances and p-values
fit = variance_adjust(fit)
</code></pre>

<hr>
<h2 id='RUVrinv'>
Remove Unwanted Variation, ridged inverse method
</h2><span id='topic+RUVrinv'></span>

<h3>Description</h3>

<p>The RUV-rinv algorithm.  Estimates and adjusts for unwanted variation using negative controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RUVrinv(Y, X, ctl, Z=1, eta=NULL, include.intercept=TRUE,
        fullW0=NULL, invsvd=NULL, lambda=NULL, k=NULL, l=NULL,
        randomization=FALSE, iterN=100000, inputcheck=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RUVrinv_+3A_y">Y</code></td>
<td>

<p>The data.  A m by n matrix, where m is the number of samples and n is the number of features.
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_x">X</code></td>
<td>

<p>The factor(s) of interest.  A m by p matrix, where m is the number of samples and p is the number of factors of interest.  Very often p = 1.  Factors and dataframes are also permissible, and converted to a matrix by <code><a href="#topic+design.matrix">design.matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_ctl">ctl</code></td>
<td>

<p>An index vector to specify the negative controls.  Either a logical vector of length n or a vector of integers.  
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_z">Z</code></td>
<td>

<p>Any additional covariates to include in the model, typically a m by q matrix.  Factors and dataframes are also permissible, and converted to a matrix by <code><a href="#topic+design.matrix">design.matrix</a></code>.  Alternatively, may simply be 1 (the default) for an intercept term.  May also be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_eta">eta</code></td>
<td>

<p>Gene-wise (as opposed to sample-wise) covariates.  These covariates are adjusted for by RUV-1 before any further analysis proceeds.  Can be either (1) a matrix with n columns, (2) a matrix with n rows, (3) a dataframe with n rows, (4) a vector or factor of length n, or (5) simply 1, for an intercept term.  
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_include.intercept">include.intercept</code></td>
<td>

<p>Applies to both <code>Z</code> and <code>eta</code>.  When <code>Z</code> or <code>eta</code> (or both) is specified (not <code>NULL</code>) but does not already include an intercept term, this will automatically include one.  If only one of <code>Z</code> or <code>eta</code> should include an intercept, this variable should be set to <code>FALSE</code>, and the intercept term should be included manually where desired.
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_fullw0">fullW0</code></td>
<td>

<p>Can be included to speed up execution.  Is returned by previous calls of <code>RUV4</code>, <code>RUVinv</code>, or <code>RUVrinv</code> (see  below).
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_invsvd">invsvd</code></td>
<td>

<p>Can be included to speed up execution.  Generally used when calling RUV(r)inv many times with different values of lambda.  Is returned by previous calls of RUV(r)inv (see  below).
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_lambda">lambda</code></td>
<td>

<p>Ridge parameter.  If unspecified, an appropriate default will be used.
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_k">k</code></td>
<td>

<p>When calculating the default value of lambda, a call to RUV4 is made.  This parameter specifies the value of k to use.  Otherwise, an appropriate default k will be used.
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_l">l</code></td>
<td>

<p>If lambda and k are both NULL, then k must be estimated using the getK routine.  The getK routine only accepts a single-column X.  If p &gt; 1, l specifies which column of X should be used in the getK routine. 
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_randomization">randomization</code></td>
<td>

<p>Whether the inverse-method variances should be computed using randomly generated factors of interest (as opposed to a numerical integral).
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_itern">iterN</code></td>
<td>

<p>The number of random &quot;factors of interest&quot; to generate (used only when randomization=TRUE).
</p>
</td></tr>
<tr><td><code id="RUVrinv_+3A_inputcheck">inputcheck</code></td>
<td>

<p>Perform a basic sanity check on the inputs, and issue a warning if there is a problem.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the RUV-rinv algorithm as described in Gagnon-Bartsch, Jacob, and Speed (2013).  This function is essentially just a wrapper to RUVinv, but with a little extra code to calculate the default value of <code>lambda</code>.  
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>betahat</code></td>
<td>
<p>The estimated coefficients of the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimates of the features' variances.  A vector of length n.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>t statistics for the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>P-values for the factor(s) of interest.  A p by n matrix.</p>
</td></tr>
<tr><td><code>Fstats</code></td>
<td>
<p>F statistics for testing all of the factors in <code>X</code> simultaneously.</p>
</td></tr>
<tr><td><code>Fpvals</code></td>
<td>
<p>P-values for testing all of the factors in <code>X</code> simultaneously.</p>
</td></tr>
<tr><td><code>multiplier</code></td>
<td>
<p>The constant by which <code>sigma2</code> must be multiplied in order get an estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of residual degrees of freedom.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>The estimated unwanted factors.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The estimated coefficients of W.</p>
</td></tr>
<tr><td><code>byx</code></td>
<td>
<p>The coefficients in a regression of Y on X (after both Y and X have been &quot;adjusted&quot; for Z).  Useful for projection plots.</p>
</td></tr>
<tr><td><code>bwx</code></td>
<td>
<p>The coefficients in a regression of W on X (after X has been &quot;adjusted&quot; for Z).  Useful for projection plots.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p><code>X</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p><code>k</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>ctl</code></td>
<td>
<p><code>ctl</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p><code>Z</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p><code>eta</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>fullW0</code></td>
<td>
<p>Can be used to speed up future calls of RUV4.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p><code>lambda</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>invsvd</code></td>
<td>
<p>Can be used to speed up future calls of RUV(r)inv.</p>
</td></tr>
<tr><td><code>include.intercept</code></td>
<td>
<p><code>include.intercept</code>.  Included for reference.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Character variable with value &quot;RUVinv&quot;.  Included for reference.  (Note that RUVrinv is simply a wrapper to RUVinv, hence both return &quot;RUVinv&quot; as the method.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Additional resources can be found at <a href="http://www-personal.umich.edu/~johanngb/ruv/">http://www-personal.umich.edu/~johanngb/ruv/</a>. 
</p>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>References</h3>

<p>Using control genes to correct for unwanted variation in microarray data.  Gagnon-Bartsch and Speed, 2012.  Available at: <a href="http://biostatistics.oxfordjournals.org/content/13/3/539.full">http://biostatistics.oxfordjournals.org/content/13/3/539.full</a>. 
</p>
<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV2">RUV2</a></code>, <code><a href="#topic+RUV4">RUV4</a></code>, <code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+variance_adjust">variance_adjust</a></code>, <code><a href="#topic+invvar">invvar</a></code>, <code><a href="#topic+getK">getK</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create some simulated data
m = 50
n = 10000
nc = 1000
p = 1
k = 20
ctl = rep(FALSE, n)
ctl[1:nc] = TRUE
X = matrix(c(rep(0,floor(m/2)), rep(1,ceiling(m/2))), m, p)
beta = matrix(rnorm(p*n), p, n)
beta[,ctl] = 0
W = matrix(rnorm(m*k),m,k)
alpha = matrix(rnorm(k*n),k,n)
epsilon = matrix(rnorm(m*n),m,n)
Y = X%*%beta + W%*%alpha + epsilon

## Run RUV-rinv
fit = RUVrinv(Y, X, ctl)

## Get adjusted variances and p-values
fit = variance_adjust(fit)
</code></pre>

<hr>
<h2 id='sigmashrink'>
Empirical Bayes shrinkage estimate of sigma^2
</h2><span id='topic+sigmashrink'></span>

<h3>Description</h3>

<p>This function (re)implements the empirical bayes shrinkage estimate of Smyth (2004), which is also implemented in the Limma package.  This function is normally called from the function <code><a href="#topic+variance_adjust">variance_adjust</a></code>, and is not normally intended for stand-alone use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmashrink(s2, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmashrink_+3A_s2">s2</code></td>
<td>

<p>&quot;Standard&quot; estimates of sigma^2
</p>
</td></tr>
<tr><td><code id="sigmashrink_+3A_d">d</code></td>
<td>

<p>&quot;Standard&quot; degrees of freedom of the residuals
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimates of sigma^2 using the empirical bayes shrinkage method of Smyth (2004)</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Estimate of degrees of freedom using the empirical bayes shrinkage method of Smyth (2004)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch <a href="mailto:johanngb@umich.edu">johanngb@umich.edu</a>
</p>


<h3>References</h3>

<p>Linear models and empirical bayes methods for assessing differential expression in microarray experiments.  Smyth, 2004.
</p>
<p>Using control genes to correct for unwanted variation in microarray data.  Gagnon-Bartsch and Speed, 2012.  Available at: <a href="http://biostatistics.oxfordjournals.org/content/13/3/539.full">http://biostatistics.oxfordjournals.org/content/13/3/539.full</a>. 
</p>
<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variance_adjust">variance_adjust</a></code>
</p>

<hr>
<h2 id='variance_adjust'>
Adjust Estimated Variances
</h2><span id='topic+variance_adjust'></span>

<h3>Description</h3>

<p>Calculate rescaled variances, empirical variances, etc.  For use with RUV model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance_adjust(fit, ctl.idx = NULL, ebayes = TRUE, pooled=TRUE, evar = TRUE,
                rsvar = TRUE, bin = 10, rescaleconst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variance_adjust_+3A_fit">fit</code></td>
<td>

<p>A RUV model fit (a list), as returned by RUV2 / RUV4 / RUVinv / RUVrinv
</p>
</td></tr>
<tr><td><code id="variance_adjust_+3A_ctl.idx">ctl.idx</code></td>
<td>

<p>An index vector to specify the negative controls for use with the rescaled variances method.  If unspecified, by default <code>fit$ctl</code> is used.
</p>
</td></tr>
<tr><td><code id="variance_adjust_+3A_ebayes">ebayes</code></td>
<td>

<p>A logical variable.  Should empirical bayes variance estimates be calculated?
</p>
</td></tr>
<tr><td><code id="variance_adjust_+3A_pooled">pooled</code></td>
<td>

<p>A logical variable.  Should pooled variance estimates be calculated?
</p>
</td></tr>
<tr><td><code id="variance_adjust_+3A_evar">evar</code></td>
<td>

<p>A logical variable.  Should empirical variance estimates be calculated?
</p>
</td></tr>
<tr><td><code id="variance_adjust_+3A_rsvar">rsvar</code></td>
<td>

<p>A logical variable.  Should rescaled variance estimates be calculated?
</p>
</td></tr>
<tr><td><code id="variance_adjust_+3A_bin">bin</code></td>
<td>

<p>The bin size to use when calculating empirical variances.
</p>
</td></tr>
<tr><td><code id="variance_adjust_+3A_rescaleconst">rescaleconst</code></td>
<td>

<p>Can be used to speed up execution.  See <code><a href="#topic+get_empirical_variances">get_empirical_variances</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An RUV model fit (a list).  In addition to the elements of the list returned by RUV2 / RUV4 / RUVinv / RUVrinv, the list will now contain:
</p>
<table>
<tr><td><code>sigma2.ebayes</code></td>
<td>
<p>Estimates of sigma^2 using the empirical bayes shrinkage method of Smyth (2004)</p>
</td></tr>
<tr><td><code>df.ebayes</code></td>
<td>
<p>Estimate of degrees of freedom using the empirical bayes shrinkage method of Smyth (2004)</p>
</td></tr>
<tr><td><code>sigma2.pooled</code></td>
<td>
<p>Estimate of sigma^2 pooled (averaged) over all genes</p>
</td></tr>
<tr><td><code>df.pooled</code></td>
<td>
<p>Degrees of freedom for pooled estimate</p>
</td></tr>
<tr><td><code>varbetahat</code></td>
<td>
<p>&quot;Standard&quot; estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>varbetahat.rsvar</code></td>
<td>
<p>&quot;Rescaled Variances&quot; estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>varbetahat.evar</code></td>
<td>
<p>&quot;Empirical Variances&quot; estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>varbetahat.ebayes</code></td>
<td>
<p>&quot;Empirical Bayes&quot; estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>varbetahat.rsvar.ebayes</code></td>
<td>
<p>&quot;Rescaled Empirical Bayes&quot; estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>varbetahat.pooled</code></td>
<td>
<p>&quot;Pooled&quot; estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>varbetahat.rsvar.pooled</code></td>
<td>
<p>&quot;Rescaled pooled&quot; estimate of the variance of <code>betahat</code></p>
</td></tr>
<tr><td><code>varbetahat.evar.pooled</code></td>
<td>
<p>Similar to the above, but all genes used to determine the rescaling, not just control genes</p>
</td></tr>
<tr><td><code>p.rsvar</code></td>
<td>
<p>P-values, after applying the method of rescaled variances</p>
</td></tr>
<tr><td><code>p.evar</code></td>
<td>
<p>P-values, after applying the method of empirical variances</p>
</td></tr>
<tr><td><code>p.ebayes</code></td>
<td>
<p>P-values, after applying the empirical bayes method of Smyth (2004)</p>
</td></tr>
<tr><td><code>p.pooled</code></td>
<td>
<p>P-values, after pooling variances</p>
</td></tr>
<tr><td><code>p.rsvar.ebayes</code></td>
<td>
<p>P-values, after applying the empirical bayes method of Smyth (2004) and the method of rescaled variances</p>
</td></tr>
<tr><td><code>p.rsvar.pooled</code></td>
<td>
<p>P-values, after pooling variances and the method of rescaled variances</p>
</td></tr>
<tr><td><code>p.evar.pooled</code></td>
<td>
<p>Similar to the above, but all genes used to determine the rescaling, not just control genes</p>
</td></tr>
<tr><td><code>Fpvals.ebayes</code></td>
<td>
<p>F test p-values, after applying the empirical bayes method of Smyth (2004)</p>
</td></tr>
<tr><td><code>Fpvals.pooled</code></td>
<td>
<p>F test p-values, after pooling variances</p>
</td></tr>
<tr><td><code>p.BH</code></td>
<td>
<p>FDR-adjusted p-values</p>
</td></tr>
<tr><td><code>Fpvals.BH</code></td>
<td>
<p>FDR-adjusted p-values (from F test)</p>
</td></tr>
<tr><td><code>p.rsvar.BH</code></td>
<td>
<p>FDR-adjusted p-values (from p.rsvar)</p>
</td></tr>
<tr><td><code>p.evar.BH</code></td>
<td>
<p>FDR-adjusted p-values (from p.evar)</p>
</td></tr>
<tr><td><code>p.ebayes.BH</code></td>
<td>
<p>FDR-adjusted p-values (from p.ebayes)</p>
</td></tr>
<tr><td><code>p.rsvar.ebayes.BH</code></td>
<td>
<p>FDR-adjusted p-values (from p.rsvar.ebayes)</p>
</td></tr>
<tr><td><code>Fpvals.ebayes.BH</code></td>
<td>
<p>FDR-adjusted F test p-values (from Fpvals.ebayes)</p>
</td></tr>
<tr><td><code>p.pooled.BH</code></td>
<td>
<p>FDR-adjusted p-values (from p.pooled)</p>
</td></tr>
<tr><td><code>p.rsvar.pooled.BH</code></td>
<td>
<p>FDR-adjusted p-values (from p.rsvar.pooled)</p>
</td></tr>
<tr><td><code>p.evar.pooled.BH</code></td>
<td>
<p>FDR-adjusted p-values (from p.evar.pooled)</p>
</td></tr>
<tr><td><code>Fpvals.pooled.BH</code></td>
<td>
<p>FDR-adjusted F test p-values (from Fpvals.pooled)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Johann Gagnon-Bartsch
</p>


<h3>References</h3>

<p>Using control genes to correct for unwanted variation in microarray data.  Gagnon-Bartsch and Speed, 2012.  Available at: <a href="http://biostatistics.oxfordjournals.org/content/13/3/539.full">http://biostatistics.oxfordjournals.org/content/13/3/539.full</a>. 
</p>
<p>Removing Unwanted Variation from High Dimensional Data with Negative Controls.  Gagnon-Bartsch, Jacob, and Speed, 2013.  Available at: <a href="http://statistics.berkeley.edu/tech-reports/820">http://statistics.berkeley.edu/tech-reports/820</a>.
</p>
<p>Linear models and empirical bayes methods for assessing differential expression in microarray experiments.  Smyth, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RUV2">RUV2</a></code>, <code><a href="#topic+RUV4">RUV4</a></code>, <code><a href="#topic+RUVinv">RUVinv</a></code>, <code><a href="#topic+RUVrinv">RUVrinv</a></code>, <code><a href="#topic+get_empirical_variances">get_empirical_variances</a></code>, <code><a href="#topic+sigmashrink">sigmashrink</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create some simulated data
m = 50
n = 10000
nc = 1000
p = 1
k = 20
ctl = rep(FALSE, n)
ctl[1:nc] = TRUE
X = matrix(c(rep(0,floor(m/2)), rep(1,ceiling(m/2))), m, p)
beta = matrix(rnorm(p*n), p, n)
beta[,ctl] = 0
W = matrix(rnorm(m*k),m,k)
alpha = matrix(rnorm(k*n),k,n)
epsilon = matrix(rnorm(m*n),m,n)
Y = X%*%beta + W%*%alpha + epsilon

## Run RUV-inv
fit = RUVinv(Y, X, ctl)

## Get adjusted variances and p-values
fit = variance_adjust(fit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
