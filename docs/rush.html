<!DOCTYPE html><html lang="en"><head><title>Help for package rush</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rush}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rush-package'><p>rush: Rapid Parallel and Distributed Computing</p></a></li>
<li><a href='#AppenderRedis'><p>Log to Redis Database</p></a></li>
<li><a href='#get_hostname'><p>Get the computer name of the current host</p></a></li>
<li><a href='#heartbeat'><p>Heartbeat Loop</p></a></li>
<li><a href='#remove_rush_plan'><p>Remove Rush Plan</p></a></li>
<li><a href='#rsh'><p>Synctatic Sugar for Rush Controller Construction</p></a></li>
<li><a href='#Rush'><p>Rush Controller</p></a></li>
<li><a href='#rush_assertions'><p>Assertion for Rush Objects</p></a></li>
<li><a href='#rush_available'><p>Rush Available</p></a></li>
<li><a href='#rush_config'><p>Get Rush Config</p></a></li>
<li><a href='#rush_plan'><p>Create Rush Plan</p></a></li>
<li><a href='#RushWorker'><p>Rush Worker</p></a></li>
<li><a href='#start_worker'><p>Start a worker</p></a></li>
<li><a href='#store_large_object'><p>Store Large Objects</p></a></li>
<li><a href='#with_rng_state'><p>Set RNG Sate before Running a Function</p></a></li>
<li><a href='#worker_loop_callr'><p>Single Task Worker Loop with callr Encapsulation</p></a></li>
<li><a href='#worker_loop_default'><p>Single Task Worker Loop</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Rapid Parallel and Distributed Computing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Parallel computing with a network of local and remote
    workers. Fast exchange of results between the workers through a
    'Redis' database. Key features include task queues, local caching, and
    sophisticated error handling.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlr-org/rush">https://github.com/mlr-org/rush</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/rush/issues">https://github.com/mlr-org/rush/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, data.table, jsonlite, lgr, mlr3misc, parallel,
processx, redux, R6, uuid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>callr, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-06 16:16:51 UTC; marc</td>
</tr>
<tr>
<td>Author:</td>
<td>Marc Becker <a href="https://orcid.org/0000-0002-8115-0400"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc Becker &lt;marcbecker@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-06 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rush-package'>rush: Rapid Parallel and Distributed Computing</h2><span id='topic+rush'></span><span id='topic+rush-package'></span>

<h3>Description</h3>

<p>Parallel computing with a network of local and remote workers. Fast exchange of results between the workers through a 'Redis' database. Key features include task queues, local caching, and sophisticated error handling.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marc Becker <a href="mailto:marcbecker@posteo.de">marcbecker@posteo.de</a> (<a href="https://orcid.org/0000-0002-8115-0400">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mlr-org/rush">https://github.com/mlr-org/rush</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/rush/issues">https://github.com/mlr-org/rush/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AppenderRedis'>Log to Redis Database</h2><span id='topic+AppenderRedis'></span>

<h3>Description</h3>

<p><a href="#topic+AppenderRedis">AppenderRedis</a> writes log messages to a Redis data base.
This <a href="lgr.html#topic+Appender">lgr::Appender</a> is created internally by <a href="#topic+RushWorker">RushWorker</a> when logger thresholds are passed via <code><a href="#topic+rush_plan">rush_plan()</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <a href="R6.html#topic+R6Class">R6::R6Class</a> and <code>AppenderRedis</code> with methods for writing log events to Redis data bases.
</p>


<h3>Super classes</h3>

<p><code><a href="lgr.html#topic+Filterable">lgr::Filterable</a></code> -&gt; <code><a href="lgr.html#topic+Appender">lgr::Appender</a></code> -&gt; <code><a href="lgr.html#topic+AppenderMemory">lgr::AppenderMemory</a></code> -&gt; <code>AppenderRedis</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AppenderRedis-new"><code>AppenderRedis$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AppenderRedis-flush"><code>AppenderRedis$flush()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="lgr" data-topic="Filterable" data-id="add_filter"><a href='../../lgr/html/Filterable.html#method-Filterable-add_filter'><code>lgr::Filterable$add_filter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="Filterable" data-id="filter"><a href='../../lgr/html/Filterable.html#method-Filterable-filter'><code>lgr::Filterable$filter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="Filterable" data-id="remove_filter"><a href='../../lgr/html/Filterable.html#method-Filterable-remove_filter'><code>lgr::Filterable$remove_filter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="Filterable" data-id="set_filters"><a href='../../lgr/html/Filterable.html#method-Filterable-set_filters'><code>lgr::Filterable$set_filters()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="Appender" data-id="set_layout"><a href='../../lgr/html/Appender.html#method-Appender-set_layout'><code>lgr::Appender$set_layout()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="Appender" data-id="set_threshold"><a href='../../lgr/html/Appender.html#method-Appender-set_threshold'><code>lgr::Appender$set_threshold()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="AppenderMemory" data-id="append"><a href='../../lgr/html/AppenderMemory.html#method-AppenderMemory-append'><code>lgr::AppenderMemory$append()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="AppenderMemory" data-id="clear"><a href='../../lgr/html/AppenderMemory.html#method-AppenderMemory-clear'><code>lgr::AppenderMemory$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="AppenderMemory" data-id="format"><a href='../../lgr/html/AppenderMemory.html#method-AppenderMemory-format'><code>lgr::AppenderMemory$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="AppenderMemory" data-id="set_buffer_size"><a href='../../lgr/html/AppenderMemory.html#method-AppenderMemory-set_buffer_size'><code>lgr::AppenderMemory$set_buffer_size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="AppenderMemory" data-id="set_flush_on_exit"><a href='../../lgr/html/AppenderMemory.html#method-AppenderMemory-set_flush_on_exit'><code>lgr::AppenderMemory$set_flush_on_exit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="AppenderMemory" data-id="set_flush_on_rotate"><a href='../../lgr/html/AppenderMemory.html#method-AppenderMemory-set_flush_on_rotate'><code>lgr::AppenderMemory$set_flush_on_rotate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="AppenderMemory" data-id="set_flush_threshold"><a href='../../lgr/html/AppenderMemory.html#method-AppenderMemory-set_flush_threshold'><code>lgr::AppenderMemory$set_flush_threshold()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="AppenderMemory" data-id="set_should_flush"><a href='../../lgr/html/AppenderMemory.html#method-AppenderMemory-set_should_flush'><code>lgr::AppenderMemory$set_should_flush()</code></a></span></li>
<li><span class="pkg-link" data-pkg="lgr" data-topic="AppenderMemory" data-id="show"><a href='../../lgr/html/AppenderMemory.html#method-AppenderMemory-show'><code>lgr::AppenderMemory$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AppenderRedis-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppenderRedis$new(
  config,
  key,
  threshold = NA_integer_,
  layout = lgr::LayoutJson$new(),
  buffer_size = 0,
  flush_threshold = "error",
  flush_on_exit = TRUE,
  flush_on_rotate = TRUE,
  should_flush = NULL,
  filters = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config</code></dt><dd><p>(<a href="redux.html#topic+redis_config">redux::redis_config</a>)<br />
Redis configuration options.</p>
</dd>
<dt><code>key</code></dt><dd><p>(<code>character(1)</code>)<br />
Key of the list holding the log messages in the Redis data store.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>(<code>integer(1)</code> | <code>character(1)</code>)<br />
Threshold for the log messages.</p>
</dd>
<dt><code>layout</code></dt><dd><p>(<a href="lgr.html#topic+Layout">lgr::Layout</a>)<br />
Layout for the log messages.</p>
</dd>
<dt><code>buffer_size</code></dt><dd><p>(<code>integer(1)</code>)<br />
Size of the buffer.</p>
</dd>
<dt><code>flush_threshold</code></dt><dd><p>(<code>character(1)</code>)<br />
Threshold for flushing the buffer.</p>
</dd>
<dt><code>flush_on_exit</code></dt><dd><p>(<code>logical(1)</code>)<br />
Flush the buffer on exit.</p>
</dd>
<dt><code>flush_on_rotate</code></dt><dd><p>(<code>logical(1)</code>)<br />
Flush the buffer on rotate.</p>
</dd>
<dt><code>should_flush</code></dt><dd><p>(<code>function</code>)<br />
Function that determines if the buffer should be flushed.</p>
</dd>
<dt><code>filters</code></dt><dd><p>(<code>list</code>)<br />
List of filters.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AppenderRedis-flush"></a>



<h4>Method <code>flush()</code></h4>

<p>Sends the buffer's contents to the Redis data store, and then clears the buffer.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppenderRedis$flush()</pre></div>




<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

   config_local = redux::redis_config()

   rush_plan(
     config = config_local,
     n_workers = 2,
     lgr_thresholds = c(rush = "info"))

   rush = rsh(network_id = "test_network")
   rush

</code></pre>

<hr>
<h2 id='get_hostname'>Get the computer name of the current host</h2><span id='topic+get_hostname'></span>

<h3>Description</h3>

<p>Returns the computer name of the current host.
First it tries to get the computer name from the environment variables <code>HOST</code>, <code>HOSTNAME</code> or <code>COMPUTERNAME</code>.
If this fails it tries to get the computer name from the function <code>Sys.info()</code>.
Finally, if this fails it queries the computer name from the command <code>uname -n</code>.
Copied from the <code>R.utils</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hostname()
</code></pre>


<h3>Value</h3>

<p><code>character(1)</code> of hostname.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_hostname()
</code></pre>

<hr>
<h2 id='heartbeat'>Heartbeat Loop</h2><span id='topic+heartbeat'></span>

<h3>Description</h3>

<p>The heartbeat loop updates the heartbeat key if the worker is still alive.
If the kill key is set, the worker is killed.
This function is called in a callr session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heartbeat(
  network_id,
  config,
  worker_id,
  heartbeat_period,
  heartbeat_expire,
  pid
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heartbeat_+3A_network_id">network_id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Identifier of the rush network.
Controller and workers must have the same instance id.
Keys in Redis are prefixed with the instance id.</p>
</td></tr>
<tr><td><code id="heartbeat_+3A_config">config</code></td>
<td>
<p>(<a href="redux.html#topic+redis_config">redux::redis_config</a>)<br />
Redis configuration options.</p>
</td></tr>
<tr><td><code id="heartbeat_+3A_worker_id">worker_id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Identifier of the worker.
Keys in redis specific to the worker are prefixed with the worker id.</p>
</td></tr>
<tr><td><code id="heartbeat_+3A_heartbeat_period">heartbeat_period</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Period of the heartbeat in seconds.</p>
</td></tr>
<tr><td><code id="heartbeat_+3A_heartbeat_expire">heartbeat_expire</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Time to live of the heartbeat in seconds.</p>
</td></tr>
<tr><td><code id="heartbeat_+3A_pid">pid</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Process ID of the worker.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

   config_local = redux::redis_config()

   rush_plan(
     config = config_local,
     n_workers = 2,
     lgr_thresholds = c(rush = "info"))

   rush = rsh(network_id = "test_network")

   fun = function(x1, x2, ...) list(y = x1 + x2)
   rush$start_local_workers(
     fun = fun,
     heartbeat_period = 3,
     heartbeat_expire = 9)

   rush$stop_workers()

</code></pre>

<hr>
<h2 id='remove_rush_plan'>Remove Rush Plan</h2><span id='topic+remove_rush_plan'></span>

<h3>Description</h3>

<p>Removes the rush plan that was set by <code><a href="#topic+rush_plan">rush_plan()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_rush_plan()
</code></pre>


<h3>Value</h3>

<p>Invisible <code>TRUE</code>. Function called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

  config_local = redux::redis_config()
  rush_plan(config = config_local, n_workers = 2)
  remove_rush_plan()

</code></pre>

<hr>
<h2 id='rsh'>Synctatic Sugar for Rush Controller Construction</h2><span id='topic+rsh'></span>

<h3>Description</h3>

<p>Function to construct a <a href="#topic+Rush">Rush</a> controller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsh(network_id = NULL, config = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsh_+3A_network_id">network_id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Identifier of the rush network.
Controller and workers must have the same instance id.
Keys in Redis are prefixed with the instance id.</p>
</td></tr>
<tr><td><code id="rsh_+3A_config">config</code></td>
<td>
<p>(<a href="redux.html#topic+redis_config">redux::redis_config</a>)<br />
Redis configuration options.
If <code>NULL</code>, configuration set by <code><a href="#topic+rush_plan">rush_plan()</a></code> is used.
If <code>rush_plan()</code> has not been called, the <code>REDIS_URL</code> environment variable is parsed.
If <code>REDIS_URL</code> is not set, a default configuration is used.
See <a href="redux.html#topic+redis_config">redux::redis_config</a> for details.</p>
</td></tr>
<tr><td><code id="rsh_+3A_...">...</code></td>
<td>
<p>(ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+Rush">Rush</a> controller.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

   config_local = redux::redis_config()
   rush = rsh(network_id = "test_network", config = config_local)
   rush

</code></pre>

<hr>
<h2 id='Rush'>Rush Controller</h2><span id='topic+Rush'></span>

<h3>Description</h3>

<p><a href="#topic+Rush">Rush</a> is the controller in a centralized rush network.
The controller starts and stops the workers, pushes tasks to the workers and fetches results.
</p>


<h3>Value</h3>

<p>Object of class <a href="R6.html#topic+R6Class">R6::R6Class</a> and <code>Rush</code> with controller methods.
</p>


<h3>Local Workers</h3>

<p>A local worker runs on the same machine as the controller.
Local workers are spawned with the <code style="white-space: pre;">&#8288;$start_local_workers() method via the &#8288;</code>processx' package.
</p>


<h3>Remote Workers</h3>

<p>A remote worker runs on a different machine than the controller.
Remote workers are started manually with the <code style="white-space: pre;">&#8288;$create_worker_script()&#8288;</code> and <code style="white-space: pre;">&#8288;$start_remote_workers()&#8288;</code> methods.
Remote workers can be started on any system as long as the system has access to Redis and all required packages are installed.
Only a heartbeat process can kill remote workers.
The heartbeat process also monitors the remote workers for crashes.
</p>


<h3>Stopping Workers</h3>

<p>Local and remote workers can be terminated with the <code style="white-space: pre;">&#8288;$stop_workers(type = "terminate")&#8288;</code> method.
The workers evaluate the currently running task and then terminate.
The option <code>type = "kill"</code> stops the workers immediately.
Killing a local worker is done with the <code>processx</code> package.
Remote workers are killed by pushing a kill signal to the heartbeat process.
Without a heartbeat process a remote worker cannot be killed (see section heartbeat).
</p>


<h3>Heartbeat</h3>

<p>The heartbeat process periodically signals that a worker is still alive.
This is implemented by setting a <a href="https://redis.io/docs/latest/commands/expire/">timeout</a> on the heartbeat key.
Furthermore, the heartbeat process can kill the worker.
</p>


<h3>Data Structure</h3>

<p>Tasks are stored in Redis <a href="https://redis.io/docs/latest/develop/data-types/hashes/">hashes</a>.
Hashes are collections of field-value pairs.
The key of the hash identifies the task in Redis and <code>rush</code>.
</p>
<div class="sourceCode"><pre>key : xs | ys | xs_extra
</pre></div>
<p>The field-value pairs are written by different methods, e.g. <code style="white-space: pre;">&#8288;$push_tasks()&#8288;</code> writes <code>xs</code> and <code style="white-space: pre;">&#8288;$push_results()&#8288;</code> writes <code>ys</code>.
The values of the fields are serialized lists or atomic values e.g. unserializing <code>xs</code> gives <code>list(x1 = 1, x2 = 2)</code>
This data structure allows quick converting of a hash into a row and joining multiple hashes into a table.
</p>
<div class="sourceCode"><pre>| key | x1 | x2 | y | timestamp |
| 1.. |  3 |  4 | 7 |  12:04:11 |
| 2.. |  1 |  4 | 5 |  12:04:12 |
| 3.. |  1 |  1 | 2 |  12:04:13 |
</pre></div>
<p>When the value of a field is a named list, the field can store the cells of multiple columns of the table.
When the value of a field is an atomic value, the field stores a single cell of a column named after the field.
The methods <code style="white-space: pre;">&#8288;$push_tasks()&#8288;</code> and <code style="white-space: pre;">&#8288;$push_results()&#8288;</code> write into multiple hashes.
For example, <code style="white-space: pre;">&#8288;$push_tasks(xss = list(list(x1 = 1, x2 = 2), list(x1 = 2, x2 = 2))&#8288;</code> writes <code>xs</code> in two hashes.
</p>


<h3>Task States</h3>

<p>A task can go through four states <code>"queued"</code>, <code>"running"</code>, <code>"finished"</code> or <code>"failed"</code>.
Internally, the keys of the tasks are pushed through Redis <a href="https://redis.io/docs/latest/develop/data-types/lists/">lists</a> and <a href="https://redis.io/docs/latest/develop/data-types/sets/">sets</a> to keep track of their state.
Queued tasks are waiting to be evaluated.
A worker pops a task from the queue and changes the state to <code>"running"</code> while evaluating the task.
When the task is finished, the state is changed to <code style="white-space: pre;">&#8288;"finished" and the result is written to the data base. If the task fails, the state is changed to &#8288;</code>&quot;failed&quot;<code style="white-space: pre;">&#8288;instead of&#8288;</code>&quot;finished&quot;'.
</p>


<h3>Queues</h3>

<p>Rush uses a shared queue and a queue for each worker.
The shared queue is used to push tasks to the workers.
The first worker that pops a task from the shared queue evaluates the task.
The worker queues are used to push tasks to specific workers.
</p>


<h3>Fetch Tasks and Results</h3>

<p>The <code style="white-space: pre;">&#8288;$fetch_*()&#8288;</code> methods retrieve data from the Redis database.
A matching method is defined for each task state e.g. <code style="white-space: pre;">&#8288;$fetch_running_tasks()&#8288;</code> and <code style="white-space: pre;">&#8288;$fetch_finished_tasks()&#8288;</code>.
The methods <code style="white-space: pre;">&#8288;$fetch_new_tasks()&#8288;</code> and <code style="white-space: pre;">&#8288;$fetch_finished_tasks()&#8288;</code> cache the already queried data.
The <code style="white-space: pre;">&#8288;$wait_for_finished_tasks()&#8288;</code> variant wait until a new result is available.
</p>


<h3>Error Handling</h3>

<p>When evaluating tasks in a distributed system, many things can go wrong.
Simple R errors in the worker loop are caught and written to the archive.
The task is marked as <code>"failed"</code>.
If the connection to a worker is lost, it looks like a task is <code>"running"</code> forever.
The method <code style="white-space: pre;">&#8288;$detect_lost_workers()&#8288;</code> identifies lost workers.
Running this method periodically adds a small overhead.
</p>


<h3>Logging</h3>

<p>The worker logs all messages written with the <code>lgr</code> package to the data base.
The <code>lgr_thresholds</code> argument defines the logging level for each logger e.g. <code>c(rush = "debug")</code>.
Saving log messages adds a small overhead but is useful for debugging.
By default, no log messages are stored.
</p>


<h3>Seed</h3>

<p>Setting a seed is important for reproducibility.
The tasks can be evaluated with a specific L'Ecuyer-CMRG seed.
If an initial seed is passed, the seed is used to generate L'Ecuyer-CMRG seeds for each task.
Each task is then evaluated with a separate RNG stream.
See <a href="parallel.html#topic+RngStream">parallel::nextRNGStream</a> for more details.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>network_id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier of the rush network.</p>
</dd>
<dt><code>config</code></dt><dd><p>(<a href="redux.html#topic+redis_config">redux::redis_config</a>)<br />
Redis configuration options.</p>
</dd>
<dt><code>connector</code></dt><dd><p>(<a href="redux.html#topic+redis_api">redux::redis_api</a>)<br />
Returns a connection to Redis.</p>
</dd>
<dt><code>processes</code></dt><dd><p>(<a href="processx.html#topic+process">processx::process</a>)<br />
List of processes started with <code style="white-space: pre;">&#8288;$start_local_workers()&#8288;</code>.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>n_workers</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of workers.</p>
</dd>
<dt><code>n_running_workers</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of running workers.</p>
</dd>
<dt><code>n_terminated_workers</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of terminated workers.</p>
</dd>
<dt><code>n_killed_workers</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of killed workers.</p>
</dd>
<dt><code>n_lost_workers</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of lost workers.
Run <code style="white-space: pre;">&#8288;$detect_lost_workers()&#8288;</code> to update the number of lost workers.</p>
</dd>
<dt><code>n_pre_workers</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of workers that are not yet completely started.</p>
</dd>
<dt><code>worker_ids</code></dt><dd><p>(<code>character()</code>)<br />
Ids of workers.</p>
</dd>
<dt><code>running_worker_ids</code></dt><dd><p>(<code>character()</code>)<br />
Ids of running workers.</p>
</dd>
<dt><code>terminated_worker_ids</code></dt><dd><p>(<code>character()</code>)<br />
Ids of terminated workers.</p>
</dd>
<dt><code>killed_worker_ids</code></dt><dd><p>(<code>character()</code>)<br />
Ids of killed workers.</p>
</dd>
<dt><code>lost_worker_ids</code></dt><dd><p>(<code>character()</code>)<br />
Ids of lost workers.</p>
</dd>
<dt><code>pre_worker_ids</code></dt><dd><p>(<code>character()</code>)<br />
Ids of workers that are not yet completely started.</p>
</dd>
<dt><code>tasks</code></dt><dd><p>(<code>character()</code>)<br />
Keys of all tasks.</p>
</dd>
<dt><code>queued_tasks</code></dt><dd><p>(<code>character()</code>)<br />
Keys of queued tasks.</p>
</dd>
<dt><code>running_tasks</code></dt><dd><p>(<code>character()</code>)<br />
Keys of running tasks.</p>
</dd>
<dt><code>finished_tasks</code></dt><dd><p>(<code>character()</code>)<br />
Keys of finished tasks.</p>
</dd>
<dt><code>failed_tasks</code></dt><dd><p>(<code>character()</code>)<br />
Keys of failed tasks.</p>
</dd>
<dt><code>n_queued_tasks</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of queued tasks.</p>
</dd>
<dt><code>n_queued_priority_tasks</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of queued priority tasks.</p>
</dd>
<dt><code>n_running_tasks</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of running tasks.</p>
</dd>
<dt><code>n_finished_tasks</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of finished tasks.</p>
</dd>
<dt><code>n_failed_tasks</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of failed tasks.</p>
</dd>
<dt><code>n_tasks</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of all tasks.</p>
</dd>
<dt><code>worker_info</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Contains information about the workers.</p>
</dd>
<dt><code>worker_states</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Contains the states of the workers.</p>
</dd>
<dt><code>all_workers_terminated</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether all workers are terminated.</p>
</dd>
<dt><code>all_workers_lost</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether all workers are lost.
Runs <code style="white-space: pre;">&#8288;$detect_lost_workers()&#8288;</code> to detect lost workers.</p>
</dd>
<dt><code>priority_info</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
Contains the number of tasks in the priority queues.</p>
</dd>
<dt><code>snapshot_schedule</code></dt><dd><p>(<code>character()</code>)<br />
Set a snapshot schedule to periodically save the data base on disk.
For example, <code>c(60, 1000)</code> saves the data base every 60 seconds if there are at least 1000 changes.
Overwrites the redis configuration file.
Set to <code>NULL</code> to disable snapshots.
For more details see <a href="https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/">redis.io</a>.</p>
</dd>
<dt><code>redis_info</code></dt><dd><p>(<code>list()</code>)<br />
Information about the Redis server.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Rush-new"><code>Rush$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-format"><code>Rush$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-print"><code>Rush$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-reconnect"><code>Rush$reconnect()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-start_local_workers"><code>Rush$start_local_workers()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-restart_local_workers"><code>Rush$restart_local_workers()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-create_worker_script"><code>Rush$create_worker_script()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-start_remote_workers"><code>Rush$start_remote_workers()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-wait_for_workers"><code>Rush$wait_for_workers()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-stop_workers"><code>Rush$stop_workers()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-detect_lost_workers"><code>Rush$detect_lost_workers()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-reset"><code>Rush$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-read_log"><code>Rush$read_log()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-print_log"><code>Rush$print_log()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-push_tasks"><code>Rush$push_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-push_priority_tasks"><code>Rush$push_priority_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-push_failed"><code>Rush$push_failed()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-retry_tasks"><code>Rush$retry_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-fetch_queued_tasks"><code>Rush$fetch_queued_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-fetch_priority_tasks"><code>Rush$fetch_priority_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-fetch_running_tasks"><code>Rush$fetch_running_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-fetch_finished_tasks"><code>Rush$fetch_finished_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-wait_for_finished_tasks"><code>Rush$wait_for_finished_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-fetch_new_tasks"><code>Rush$fetch_new_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-wait_for_new_tasks"><code>Rush$wait_for_new_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-fetch_failed_tasks"><code>Rush$fetch_failed_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-fetch_tasks"><code>Rush$fetch_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-fetch_tasks_with_state"><code>Rush$fetch_tasks_with_state()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-wait_for_tasks"><code>Rush$wait_for_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-write_hashes"><code>Rush$write_hashes()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-read_hashes"><code>Rush$read_hashes()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-read_hash"><code>Rush$read_hash()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-is_running_task"><code>Rush$is_running_task()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-is_failed_task"><code>Rush$is_failed_task()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-tasks_with_state"><code>Rush$tasks_with_state()</code></a>
</p>
</li>
<li> <p><a href="#method-Rush-clone"><code>Rush$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Rush-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$new(network_id = NULL, config = NULL, seed = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>network_id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier of the rush network.
Controller and workers must have the same instance id.
Keys in Redis are prefixed with the instance id.</p>
</dd>
<dt><code>config</code></dt><dd><p>(<a href="redux.html#topic+redis_config">redux::redis_config</a>)<br />
Redis configuration options.
If <code>NULL</code>, configuration set by <code><a href="#topic+rush_plan">rush_plan()</a></code> is used.
If <code>rush_plan()</code> has not been called, the <code>REDIS_URL</code> environment variable is parsed.
If <code>REDIS_URL</code> is not set, a default configuration is used.
See <a href="redux.html#topic+redis_config">redux::redis_config</a> for details.</p>
</dd>
<dt><code>seed</code></dt><dd><p>(<code>integer()</code>)<br />
Initial seed for the random number generator.
Either a L'Ecuyer-CMRG seed (<code>integer(7)</code>) or a regular RNG seed (<code>integer(1)</code>).
The later is converted to a L'Ecuyer-CMRG seed.
If <code>NULL</code>, no seed is used for the random number generator.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-Rush-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-Rush-reconnect"></a>



<h4>Method <code>reconnect()</code></h4>

<p>Reconnect to Redis.
The connection breaks when the Rush object is saved to disk.
Call this method to reconnect after loading the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$reconnect()</pre></div>


<hr>
<a id="method-Rush-start_local_workers"></a>



<h4>Method <code>start_local_workers()</code></h4>

<p>Start workers locally with <code>processx</code>.
The <a href="processx.html#topic+process">processx::process</a> are stored in <code style="white-space: pre;">&#8288;$processes&#8288;</code>.
Alternatively, use <code style="white-space: pre;">&#8288;$create_worker_script()&#8288;</code> to create a script for starting workers on remote machines.
By default, <code><a href="#topic+worker_loop_default">worker_loop_default()</a></code> is used as worker loop.
This function takes the arguments <code>fun</code> and optionally <code>constants</code> which are passed in <code>...</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$start_local_workers(
  n_workers = NULL,
  wait_for_workers = TRUE,
  timeout = Inf,
  globals = NULL,
  packages = NULL,
  heartbeat_period = NULL,
  heartbeat_expire = NULL,
  lgr_thresholds = NULL,
  lgr_buffer_size = 0,
  supervise = TRUE,
  worker_loop = worker_loop_default,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_workers</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of workers to be started.</p>
</dd>
<dt><code>wait_for_workers</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to wait until all workers are available.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Timeout to wait for workers in seconds.</p>
</dd>
<dt><code>globals</code></dt><dd><p>(<code>character()</code>)<br />
Global variables to be loaded to the workers global environment.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Packages to be loaded by the workers.</p>
</dd>
<dt><code>heartbeat_period</code></dt><dd><p>(<code>integer(1)</code>)<br />
Period of the heartbeat in seconds.</p>
</dd>
<dt><code>heartbeat_expire</code></dt><dd><p>(<code>integer(1)</code>)<br />
Time to live of the heartbeat in seconds.</p>
</dd>
<dt><code>lgr_thresholds</code></dt><dd><p>(named <code>character()</code> | named <code>numeric()</code>)<br />
Logger threshold on the workers e.g. <code>c(rush = "debug")</code>.</p>
</dd>
<dt><code>lgr_buffer_size</code></dt><dd><p>(<code>integer(1)</code>)<br />
By default (<code>lgr_buffer_size = 0</code>), the log messages are directly saved in the Redis data store.
If <code>lgr_buffer_size &gt; 0</code>, the log messages are buffered and saved in the Redis data store when the buffer is full.
This improves the performance of the logging.</p>
</dd>
<dt><code>supervise</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to kill the workers when the main R process is shut down.</p>
</dd>
<dt><code>worker_loop</code></dt><dd><p>(<code>function</code>)<br />
Loop run on the workers.
Defaults to <a href="#topic+worker_loop_default">worker_loop_default</a> which is called with <code>fun</code>.
Pass <code>fun</code> in <code>...</code>.
Use <a href="#topic+worker_loop_callr">worker_loop_callr</a> to run <code>fun</code> in an external callr session.</p>
</dd>
<dt><code>...</code></dt><dd><p>(<code>any</code>)<br />
Arguments passed to <code>worker_loop</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-restart_local_workers"></a>



<h4>Method <code>restart_local_workers()</code></h4>

<p>Restart local workers.
If the worker is is still running, it is killed and restarted.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$restart_local_workers(worker_ids, supervise = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>worker_ids</code></dt><dd><p>(<code>character()</code>)<br />
Worker ids to be restarted.</p>
</dd>
<dt><code>supervise</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to kill the workers when the main R process is shut down.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-create_worker_script"></a>



<h4>Method <code>create_worker_script()</code></h4>

<p>Create script to remote start workers.
Run these command to pre-start a worker.
The worker will wait until the start arguments are pushed with <code style="white-space: pre;">&#8288;$start_remote_workers()&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$create_worker_script()</pre></div>


<hr>
<a id="method-Rush-start_remote_workers"></a>



<h4>Method <code>start_remote_workers()</code></h4>

<p>Push start arguments to remote workers.
Remote workers must be pre-started with <code style="white-space: pre;">&#8288;$create_worker_script()&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$start_remote_workers(
  globals = NULL,
  packages = NULL,
  heartbeat_period = NULL,
  heartbeat_expire = NULL,
  lgr_thresholds = NULL,
  lgr_buffer_size = 0,
  worker_loop = worker_loop_default,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>globals</code></dt><dd><p>(<code>character()</code>)<br />
Global variables to be loaded to the workers global environment.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Packages to be loaded by the workers.</p>
</dd>
<dt><code>heartbeat_period</code></dt><dd><p>(<code>integer(1)</code>)<br />
Period of the heartbeat in seconds.</p>
</dd>
<dt><code>heartbeat_expire</code></dt><dd><p>(<code>integer(1)</code>)<br />
Time to live of the heartbeat in seconds.</p>
</dd>
<dt><code>lgr_thresholds</code></dt><dd><p>(named <code>character()</code> | named <code>numeric()</code>)<br />
Logger threshold on the workers e.g. <code>c(rush = "debug")</code>.</p>
</dd>
<dt><code>lgr_buffer_size</code></dt><dd><p>(<code>integer(1)</code>)<br />
By default (<code>lgr_buffer_size = 0</code>), the log messages are directly saved in the Redis data store.
If <code>lgr_buffer_size &gt; 0</code>, the log messages are buffered and saved in the Redis data store when the buffer is full.
This improves the performance of the logging.</p>
</dd>
<dt><code>worker_loop</code></dt><dd><p>(<code>function</code>)<br />
Loop run on the workers.
Defaults to <a href="#topic+worker_loop_default">worker_loop_default</a> which is called with <code>fun</code>.
Pass <code>fun</code> in <code>...</code>.
Use <a href="#topic+worker_loop_callr">worker_loop_callr</a> to run <code>fun</code> in an external callr session.</p>
</dd>
<dt><code>...</code></dt><dd><p>(<code>any</code>)<br />
Arguments passed to <code>worker_loop</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-wait_for_workers"></a>



<h4>Method <code>wait_for_workers()</code></h4>

<p>Wait until <code>n</code> workers are available.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$wait_for_workers(n, timeout = Inf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of workers to wait for.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Timeout in seconds.
Default is <code>Inf</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-stop_workers"></a>



<h4>Method <code>stop_workers()</code></h4>

<p>Stop workers.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$stop_workers(type = "terminate", worker_ids = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>(<code>character(1)</code>)<br />
Type of stopping.
Either <code>"terminate"</code> or <code>"kill"</code>.
If <code>"terminate"</code> the workers evaluate the currently running task and then terminate.
If <code>"kill"</code> the workers are stopped immediately.</p>
</dd>
<dt><code>worker_ids</code></dt><dd><p>(<code>character()</code>)<br />
Worker ids to be stopped.
If <code>NULL</code> all workers are stopped.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-detect_lost_workers"></a>



<h4>Method <code>detect_lost_workers()</code></h4>

<p>Detect lost workers.
The state of the worker is changed to <code>"lost"</code>.
Local workers without a heartbeat are checked by their process id.
Checking local workers on unix systems only takes a few microseconds per worker.
But checking local workers on windows might be very slow.
Workers with a heartbeat process are checked with the heartbeat.
Lost tasks are marked as <code>"lost"</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$detect_lost_workers(restart_local_workers = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>restart_local_workers</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to restart lost workers.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Stop workers and delete data stored in redis.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$reset(type = "kill")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>(<code>character(1)</code>)<br />
Type of stopping.
Either <code>"terminate"</code> or <code>"kill"</code>.
If <code>"terminate"</code> the workers evaluate the currently running task and then terminate.
If <code>"kill"</code> the workers are stopped immediately.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-read_log"></a>



<h4>Method <code>read_log()</code></h4>

<p>Read log messages written with the <code>lgr</code> package from a worker.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$read_log(worker_ids = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>worker_ids</code></dt><dd><p>(<code>character(1)</code>)<br />
Worker ids.
If <code>NULL</code> all worker ids are used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-print_log"></a>



<h4>Method <code>print_log()</code></h4>

<p>Print log messages written with the <code>lgr</code> package from a worker.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$print_log()</pre></div>


<hr>
<a id="method-Rush-push_tasks"></a>



<h4>Method <code>push_tasks()</code></h4>

<p>Pushes a task to the queue.
Task is added to queued tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$push_tasks(
  xss,
  extra = NULL,
  seeds = NULL,
  timeouts = NULL,
  max_retries = NULL,
  terminate_workers = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xss</code></dt><dd><p>(list of named <code>list()</code>)<br />
Lists of arguments for the function e.g. <code style="white-space: pre;">&#8288;list(list(x1, x2), list(x1, x2)))&#8288;</code>.</p>
</dd>
<dt><code>extra</code></dt><dd><p>(<code>list()</code>)<br />
List of additional information stored along with the task e.g. <code style="white-space: pre;">&#8288;list(list(timestamp), list(timestamp)))&#8288;</code>.</p>
</dd>
<dt><code>seeds</code></dt><dd><p>(<code>list()</code>)<br />
List of L'Ecuyer-CMRG seeds for each task e.g <code>list(list(c(104071, 490840688, 1690070564, -495119766, 503491950, 1801530932, -1629447803)))</code>.
If <code>NULL</code> but an initial seed is set, L'Ecuyer-CMRG seeds are generated from the initial seed.
If <code>NULL</code> and no initial seed is set, no seeds are used for the random number generator.</p>
</dd>
<dt><code>timeouts</code></dt><dd><p>(<code>integer()</code>)<br />
Timeouts for each task in seconds e.g. <code>c(10, 15)</code>.
A single number is used as the timeout for all tasks.
If <code>NULL</code> no timeout is set.</p>
</dd>
<dt><code>max_retries</code></dt><dd><p>(<code>integer()</code>)<br />
Number of retries for each task.
A single number is used as the number of retries for all tasks.
If <code>NULL</code> tasks are not retried.</p>
</dd>
<dt><code>terminate_workers</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to stop the workers after evaluating the tasks.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(<code>character()</code>)<br />
Keys of the tasks.
</p>


<hr>
<a id="method-Rush-push_priority_tasks"></a>



<h4>Method <code>push_priority_tasks()</code></h4>

<p>Pushes a task to the queue of a specific worker.
Task is added to queued priority tasks.
A worker evaluates the tasks in the priority queue before the shared queue.
If <code>priority</code> is <code>NA</code> the task is added to the shared queue.
If the worker is lost or worker id is not known, the task is added to the shared queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$push_priority_tasks(xss, extra = NULL, priority = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xss</code></dt><dd><p>(list of named <code>list()</code>)<br />
Lists of arguments for the function e.g. <code style="white-space: pre;">&#8288;list(list(x1, x2), list(x1, x2)))&#8288;</code>.</p>
</dd>
<dt><code>extra</code></dt><dd><p>(<code>list</code>)<br />
List of additional information stored along with the task e.g. <code style="white-space: pre;">&#8288;list(list(timestamp), list(timestamp)))&#8288;</code>.</p>
</dd>
<dt><code>priority</code></dt><dd><p>(<code>character()</code>)<br />
Worker ids to which the tasks should be pushed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(<code>character()</code>)<br />
Keys of the tasks.
</p>


<hr>
<a id="method-Rush-push_failed"></a>



<h4>Method <code>push_failed()</code></h4>

<p>Pushes failed tasks to the data base.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$push_failed(keys, conditions)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keys</code></dt><dd><p>(<code>character(1)</code>)<br />
Keys of the associated tasks.</p>
</dd>
<dt><code>conditions</code></dt><dd><p>(named <code>list()</code>)<br />
List of lists of conditions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-retry_tasks"></a>



<h4>Method <code>retry_tasks()</code></h4>

<p>Retry failed tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$retry_tasks(keys, ignore_max_retries = FALSE, next_seed = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keys</code></dt><dd><p>(<code>character()</code>)<br />
Keys of the tasks to be retried.</p>
</dd>
<dt><code>ignore_max_retries</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to ignore the maximum number of retries.</p>
</dd>
<dt><code>next_seed</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to change the seed of the task.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-fetch_queued_tasks"></a>



<h4>Method <code>fetch_queued_tasks()</code></h4>

<p>Fetch queued tasks from the data base.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$fetch_queued_tasks(
  fields = c("xs", "xs_extra"),
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.
Defaults to <code>c("xs", "xs_extra")</code>.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table()</code><br />
Table of queued tasks.
</p>


<hr>
<a id="method-Rush-fetch_priority_tasks"></a>



<h4>Method <code>fetch_priority_tasks()</code></h4>

<p>Fetch queued priority tasks from the data base.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$fetch_priority_tasks(
  fields = c("xs", "xs_extra"),
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.
Defaults to <code>c("xs", "xs_extra")</code>.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table()</code><br />
Table of queued priority tasks.
</p>


<hr>
<a id="method-Rush-fetch_running_tasks"></a>



<h4>Method <code>fetch_running_tasks()</code></h4>

<p>Fetch running tasks from the data base.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$fetch_running_tasks(
  fields = c("xs", "xs_extra", "worker_extra"),
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.
Defaults to <code>c("xs", "xs_extra", "worker_extra")</code>.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table()</code><br />
Table of running tasks.
</p>


<hr>
<a id="method-Rush-fetch_finished_tasks"></a>



<h4>Method <code>fetch_finished_tasks()</code></h4>

<p>Fetch finished tasks from the data base.
Finished tasks are cached.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$fetch_finished_tasks(
  fields = c("xs", "ys", "xs_extra", "worker_extra", "ys_extra", "condition"),
  reset_cache = FALSE,
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.
Defaults to <code>c("xs", "xs_extra", "worker_extra", "ys", "ys_extra")</code>.</p>
</dd>
<dt><code>reset_cache</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to reset the cache.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table()</code><br />
Table of finished tasks.
</p>


<hr>
<a id="method-Rush-wait_for_finished_tasks"></a>



<h4>Method <code>wait_for_finished_tasks()</code></h4>

<p>Block process until a new finished task is available.
Returns all finished tasks or <code>NULL</code> if no new task is available after <code>timeout</code> seconds.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$wait_for_finished_tasks(
  fields = c("xs", "ys", "xs_extra", "worker_extra", "ys_extra"),
  timeout = Inf,
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.
Defaults to <code>c("xs", "xs_extra", "worker_extra", "ys", "ys_extra")</code>.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Time to wait for a result in seconds.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table()</code><br />
Table of finished tasks.
</p>


<hr>
<a id="method-Rush-fetch_new_tasks"></a>



<h4>Method <code>fetch_new_tasks()</code></h4>

<p>Fetch finished tasks from the data base that finished after the last fetch.
Updates the cache of the finished tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$fetch_new_tasks(
  fields = c("xs", "ys", "xs_extra", "worker_extra", "ys_extra", "condition"),
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table()</code><br />
Latest results.
</p>


<hr>
<a id="method-Rush-wait_for_new_tasks"></a>



<h4>Method <code>wait_for_new_tasks()</code></h4>

<p>Block process until a new finished task is available.
Returns new tasks or <code>NULL</code> if no new task is available after <code>timeout</code> seconds.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$wait_for_new_tasks(
  fields = c("xs", "ys", "xs_extra", "worker_extra", "ys_extra", "condition"),
  timeout = Inf,
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.
Defaults to <code>c("xs", "xs_extra", "worker_extra", "ys", "ys_extra")</code>.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Time to wait for new result in seconds.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table() | list()</code>.
</p>


<hr>
<a id="method-Rush-fetch_failed_tasks"></a>



<h4>Method <code>fetch_failed_tasks()</code></h4>

<p>Fetch failed tasks from the data base.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$fetch_failed_tasks(
  fields = c("xs", "worker_extra", "condition"),
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.
Defaults to <code style="white-space: pre;">&#8288;c("xs", "xs_extra", "worker_extra", "condition"&#8288;</code>.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table()</code><br />
Table of failed tasks.
</p>


<hr>
<a id="method-Rush-fetch_tasks"></a>



<h4>Method <code>fetch_tasks()</code></h4>

<p>Fetch all tasks from the data base.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$fetch_tasks(
  fields = c("xs", "ys", "xs_extra", "worker_extra", "ys_extra", "condition"),
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.
Defaults to <code>c("xs", "xs_extra", "worker_extra", "ys", "ys_extra", "condition", "state")</code>.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table()</code><br />
Table of all tasks.
</p>


<hr>
<a id="method-Rush-fetch_tasks_with_state"></a>



<h4>Method <code>fetch_tasks_with_state()</code></h4>

<p>Fetch tasks with different states from the data base.
If tasks with different states are to be queried at the same time, this function prevents tasks from appearing twice.
This could be the case if a worker changes the state of a task while the tasks are being fetched.
Finished tasks are cached.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$fetch_tasks_with_state(
  fields = c("xs", "ys", "xs_extra", "worker_extra", "ys_extra", "condition"),
  states = c("queued", "running", "finished", "failed"),
  reset_cache = FALSE,
  data_format = "data.table"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.
Defaults to <code>c("xs", "ys", "xs_extra", "worker_extra", "ys_extra")</code>.</p>
</dd>
<dt><code>states</code></dt><dd><p>(<code>character()</code>)<br />
States of the tasks to be fetched.
Defaults to <code>c("queued", "running", "finished", "failed")</code>.</p>
</dd>
<dt><code>reset_cache</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to reset the cache of the finished tasks.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character()</code>)<br />
Returned data format.
Choose <code>"data.table"</code> or &quot;list&quot;.
The default is <code>"data.table"</code> but <code>"list"</code> is easier when list columns are present.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-wait_for_tasks"></a>



<h4>Method <code>wait_for_tasks()</code></h4>

<p>Wait until tasks are finished.
The function also unblocks when no worker is running or all tasks failed.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$wait_for_tasks(keys, detect_lost_workers = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keys</code></dt><dd><p>(<code>character()</code>)<br />
Keys of the tasks to wait for.</p>
</dd>
<dt><code>detect_lost_workers</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to detect failed tasks.
Comes with an overhead.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-write_hashes"></a>



<h4>Method <code>write_hashes()</code></h4>

<p>Writes R objects to Redis hashes.
The function takes the vectors in <code>...</code> as input and writes each element as a field-value pair to a new hash.
The name of the argument defines the field into which the serialized element is written.
For example, <code>xs = list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4))</code> writes <code>serialize(list(x1 = 1, x2 = 2))</code> at field <code>xs</code> into a hash and <code>serialize(list(x1 = 3, x2 = 4))</code> at field <code>xs</code> into another hash.
The function can iterate over multiple vectors simultaneously.
For example, <code style="white-space: pre;">&#8288;xs = list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4)), ys = list(list(y = 3), list(y = 7))&#8288;</code> creates two hashes with the fields <code>xs</code> and <code>ys</code>.
The vectors are recycled to the length of the longest vector.
Both lists and atomic vectors are supported.
Arguments that are <code>NULL</code> are ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$write_hashes(..., .values = list(), keys = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(named <code>list()</code>)<br />
Lists to be written to the hashes.
The names of the arguments are used as fields.</p>
</dd>
<dt><code>.values</code></dt><dd><p>(named <code>list()</code>)<br />
Lists to be written to the hashes.
The names of the list are used as fields.</p>
</dd>
<dt><code>keys</code></dt><dd><p>(character())<br />
Keys of the hashes.
If <code>NULL</code> new keys are generated.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(<code>character()</code>)<br />
Keys of the hashes.
</p>


<hr>
<a id="method-Rush-read_hashes"></a>



<h4>Method <code>read_hashes()</code></h4>

<p>Reads R Objects from Redis hashes.
The function reads the field-value pairs of the hashes stored at <code>keys</code>.
The values of a hash are deserialized and combined to a list.
If <code>flatten</code> is <code>TRUE</code>, the values are flattened to a single list e.g. list(xs = list(x1 = 1, x2 = 2), ys = list(y = 3)) becomes list(x1 = 1, x2 = 2, y = 3).
The reading functions combine the hashes to a table where the names of the inner lists are the column names.
For example, <code style="white-space: pre;">&#8288;xs = list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4)), ys = list(list(y = 3), list(y = 7))&#8288;</code> becomes <code>data.table(x1 = c(1, 3), x2 = c(2, 4), y = c(3, 7))</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$read_hashes(keys, fields, flatten = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keys</code></dt><dd><p>(<code>character()</code>)<br />
Keys of the hashes.</p>
</dd>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hashes.</p>
</dd>
<dt><code>flatten</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to flatten the list.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(list of <code>list()</code>)<br />
The outer list contains one element for each key.
The inner list is the combination of the lists stored at the different fields.
</p>


<hr>
<a id="method-Rush-read_hash"></a>



<h4>Method <code>read_hash()</code></h4>

<p>Reads a single Redis hash and returns the values as a list named by the fields.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$read_hash(key, fields)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>(<code>character(1)</code>)<br />
Key of the hash.</p>
</dd>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be read from the hash.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(list of <code>list()</code>)<br />
The outer list contains one element for each key.
The inner list is the combination of the lists stored at the different fields.
</p>


<hr>
<a id="method-Rush-is_running_task"></a>



<h4>Method <code>is_running_task()</code></h4>

<p>Checks whether tasks have the status <code>"running"</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$is_running_task(keys)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keys</code></dt><dd><p>(<code>character()</code>)<br />
Keys of the tasks.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-is_failed_task"></a>



<h4>Method <code>is_failed_task()</code></h4>

<p>Checks whether tasks have the status <code>"failed"</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$is_failed_task(keys)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keys</code></dt><dd><p>(<code>character()</code>)<br />
Keys of the tasks.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rush-tasks_with_state"></a>



<h4>Method <code>tasks_with_state()</code></h4>

<p>Returns keys of requested states.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$tasks_with_state(states)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>states</code></dt><dd><p>(<code>character()</code>)<br />
States of the tasks.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(Named list of <code>character()</code>).
</p>


<hr>
<a id="method-Rush-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rush$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

   config_local = redux::redis_config()
   rush = rsh(network_id = "test_network", config = config_local)
   rush

</code></pre>

<hr>
<h2 id='rush_assertions'>Assertion for Rush Objects</h2><span id='topic+rush_assertions'></span><span id='topic+assert_rush'></span><span id='topic+assert_rushs'></span><span id='topic+assert_rush_worker'></span><span id='topic+assert_rush_workers'></span>

<h3>Description</h3>

<p>Most assertion functions ensure the right class attribute, and optionally additional properties.
If an assertion fails, an exception is raised.
Otherwise, the input object is returned invisibly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_rush(rush, null_ok = FALSE)

assert_rushs(rushs, null_ok = FALSE)

assert_rush_worker(worker, null_ok = FALSE)

assert_rush_workers(workers, null_ok = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rush_assertions_+3A_rush">rush</code></td>
<td>
<p>(<a href="#topic+Rush">Rush</a>).</p>
</td></tr>
<tr><td><code id="rush_assertions_+3A_null_ok">null_ok</code></td>
<td>
<p>(<code>logical(1)</code>).
If <code>TRUE</code>, <code>NULL</code> is allowed.</p>
</td></tr>
<tr><td><code id="rush_assertions_+3A_rushs">rushs</code></td>
<td>
<p>(list of <a href="#topic+Rush">Rush</a>).</p>
</td></tr>
<tr><td><code id="rush_assertions_+3A_worker">worker</code></td>
<td>
<p>(<a href="#topic+RushWorker">RushWorker</a>).</p>
</td></tr>
<tr><td><code id="rush_assertions_+3A_workers">workers</code></td>
<td>
<p>(list of <a href="#topic+RushWorker">RushWorker</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Exception if the assertion fails, otherwise the input object invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

   config_local = redux::redis_config()
   rush = rsh(network_id = "test_network", config = config_local)

   assert_rush(rush)

</code></pre>

<hr>
<h2 id='rush_available'>Rush Available</h2><span id='topic+rush_available'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if a redis config file (<a href="redux.html#topic+redis_config">redux::redis_config</a>) has been set by <code><a href="#topic+rush_plan">rush_plan()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rush_available()
</code></pre>


<h3>Value</h3>

<p><code>logical(1)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

  config_local = redux::redis_config()
  rush_plan(config = config_local, n_workers = 2)
  rush_available()

</code></pre>

<hr>
<h2 id='rush_config'>Get Rush Config</h2><span id='topic+rush_config'></span>

<h3>Description</h3>

<p>Returns the rush config that was set by <code><a href="#topic+rush_plan">rush_plan()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rush_config()
</code></pre>


<h3>Value</h3>

<p><code>list()</code> with the stored configuration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

  config_local = redux::redis_config()
  rush_plan(config = config_local, n_workers = 2)
  rush_config()

</code></pre>

<hr>
<h2 id='rush_plan'>Create Rush Plan</h2><span id='topic+rush_plan'></span>

<h3>Description</h3>

<p>Stores the number of workers and Redis configuration options (<a href="redux.html#topic+redis_config">redux::redis_config</a>) for <a href="#topic+Rush">Rush</a>.
The function tests the connection to Redis and throws an error if the connection fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rush_plan(
  n_workers = NULL,
  config = NULL,
  lgr_thresholds = NULL,
  large_objects_path = NULL,
  start_worker_timeout = Inf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rush_plan_+3A_n_workers">n_workers</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of workers to be started.</p>
</td></tr>
<tr><td><code id="rush_plan_+3A_config">config</code></td>
<td>
<p>(<a href="redux.html#topic+redis_config">redux::redis_config</a>)<br />
Configuration options used to connect to Redis.
If <code>NULL</code>, the <code>REDIS_URL</code> environment variable is parsed.
If <code>REDIS_URL</code> is not set, a default configuration is used.
See <a href="redux.html#topic+redis_config">redux::redis_config</a> for details.</p>
</td></tr>
<tr><td><code id="rush_plan_+3A_lgr_thresholds">lgr_thresholds</code></td>
<td>
<p>(named <code>character()</code> | named <code>numeric()</code>)<br />
Logger threshold on the workers e.g. <code>c(rush = "debug")</code>.</p>
</td></tr>
<tr><td><code id="rush_plan_+3A_large_objects_path">large_objects_path</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The path to the directory where large objects are stored.</p>
</td></tr>
<tr><td><code id="rush_plan_+3A_start_worker_timeout">start_worker_timeout</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
The time in seconds to wait for a worker to start.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list()</code> with the stored configuration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

   config_local = redux::redis_config()
   rush_plan(config = config_local, n_workers = 2)

   rush = rsh(network_id = "test_network")
   rush

</code></pre>

<hr>
<h2 id='RushWorker'>Rush Worker</h2><span id='topic+RushWorker'></span>

<h3>Description</h3>

<p><a href="#topic+RushWorker">RushWorker</a> evaluates tasks and writes results to the data base.
The worker inherits from <a href="#topic+Rush">Rush</a>.
</p>


<h3>Value</h3>

<p>Object of class <a href="R6.html#topic+R6Class">R6::R6Class</a> and <code>RushWorker</code> with worker methods.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Rush">rush::Rush</a></code> -&gt; <code>RushWorker</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>worker_id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier of the worker.</p>
</dd>
<dt><code>remote</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the worker is on a remote machine.</p>
</dd>
<dt><code>heartbeat</code></dt><dd><p>('r_process&ldquo;)<br />
Background process for the heartbeat.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>terminated</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to shutdown the worker.
Used in the worker loop to determine whether to continue.</p>
</dd>
<dt><code>terminated_on_idle</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to shutdown the worker if no tasks are queued.
Used in the worker loop to determine whether to continue.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RushWorker-new"><code>RushWorker$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RushWorker-push_running_tasks"><code>RushWorker$push_running_tasks()</code></a>
</p>
</li>
<li> <p><a href="#method-RushWorker-pop_task"><code>RushWorker$pop_task()</code></a>
</p>
</li>
<li> <p><a href="#method-RushWorker-push_results"><code>RushWorker$push_results()</code></a>
</p>
</li>
<li> <p><a href="#method-RushWorker-set_terminated"><code>RushWorker$set_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-RushWorker-clone"><code>RushWorker$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="create_worker_script"><a href='../../rush/html/Rush.html#method-Rush-create_worker_script'><code>rush::Rush$create_worker_script()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="detect_lost_workers"><a href='../../rush/html/Rush.html#method-Rush-detect_lost_workers'><code>rush::Rush$detect_lost_workers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="fetch_failed_tasks"><a href='../../rush/html/Rush.html#method-Rush-fetch_failed_tasks'><code>rush::Rush$fetch_failed_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="fetch_finished_tasks"><a href='../../rush/html/Rush.html#method-Rush-fetch_finished_tasks'><code>rush::Rush$fetch_finished_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="fetch_new_tasks"><a href='../../rush/html/Rush.html#method-Rush-fetch_new_tasks'><code>rush::Rush$fetch_new_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="fetch_priority_tasks"><a href='../../rush/html/Rush.html#method-Rush-fetch_priority_tasks'><code>rush::Rush$fetch_priority_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="fetch_queued_tasks"><a href='../../rush/html/Rush.html#method-Rush-fetch_queued_tasks'><code>rush::Rush$fetch_queued_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="fetch_running_tasks"><a href='../../rush/html/Rush.html#method-Rush-fetch_running_tasks'><code>rush::Rush$fetch_running_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="fetch_tasks"><a href='../../rush/html/Rush.html#method-Rush-fetch_tasks'><code>rush::Rush$fetch_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="fetch_tasks_with_state"><a href='../../rush/html/Rush.html#method-Rush-fetch_tasks_with_state'><code>rush::Rush$fetch_tasks_with_state()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="format"><a href='../../rush/html/Rush.html#method-Rush-format'><code>rush::Rush$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="is_failed_task"><a href='../../rush/html/Rush.html#method-Rush-is_failed_task'><code>rush::Rush$is_failed_task()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="is_running_task"><a href='../../rush/html/Rush.html#method-Rush-is_running_task'><code>rush::Rush$is_running_task()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="print"><a href='../../rush/html/Rush.html#method-Rush-print'><code>rush::Rush$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="print_log"><a href='../../rush/html/Rush.html#method-Rush-print_log'><code>rush::Rush$print_log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="push_failed"><a href='../../rush/html/Rush.html#method-Rush-push_failed'><code>rush::Rush$push_failed()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="push_priority_tasks"><a href='../../rush/html/Rush.html#method-Rush-push_priority_tasks'><code>rush::Rush$push_priority_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="push_tasks"><a href='../../rush/html/Rush.html#method-Rush-push_tasks'><code>rush::Rush$push_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="read_hash"><a href='../../rush/html/Rush.html#method-Rush-read_hash'><code>rush::Rush$read_hash()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="read_hashes"><a href='../../rush/html/Rush.html#method-Rush-read_hashes'><code>rush::Rush$read_hashes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="read_log"><a href='../../rush/html/Rush.html#method-Rush-read_log'><code>rush::Rush$read_log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="reconnect"><a href='../../rush/html/Rush.html#method-Rush-reconnect'><code>rush::Rush$reconnect()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="reset"><a href='../../rush/html/Rush.html#method-Rush-reset'><code>rush::Rush$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="restart_local_workers"><a href='../../rush/html/Rush.html#method-Rush-restart_local_workers'><code>rush::Rush$restart_local_workers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="retry_tasks"><a href='../../rush/html/Rush.html#method-Rush-retry_tasks'><code>rush::Rush$retry_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="start_local_workers"><a href='../../rush/html/Rush.html#method-Rush-start_local_workers'><code>rush::Rush$start_local_workers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="start_remote_workers"><a href='../../rush/html/Rush.html#method-Rush-start_remote_workers'><code>rush::Rush$start_remote_workers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="stop_workers"><a href='../../rush/html/Rush.html#method-Rush-stop_workers'><code>rush::Rush$stop_workers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="tasks_with_state"><a href='../../rush/html/Rush.html#method-Rush-tasks_with_state'><code>rush::Rush$tasks_with_state()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="wait_for_finished_tasks"><a href='../../rush/html/Rush.html#method-Rush-wait_for_finished_tasks'><code>rush::Rush$wait_for_finished_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="wait_for_new_tasks"><a href='../../rush/html/Rush.html#method-Rush-wait_for_new_tasks'><code>rush::Rush$wait_for_new_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="wait_for_tasks"><a href='../../rush/html/Rush.html#method-Rush-wait_for_tasks'><code>rush::Rush$wait_for_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="wait_for_workers"><a href='../../rush/html/Rush.html#method-Rush-wait_for_workers'><code>rush::Rush$wait_for_workers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rush" data-topic="Rush" data-id="write_hashes"><a href='../../rush/html/Rush.html#method-Rush-write_hashes'><code>rush::Rush$write_hashes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RushWorker-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>RushWorker$new(
  network_id,
  config = NULL,
  remote,
  worker_id = NULL,
  heartbeat_period = NULL,
  heartbeat_expire = NULL,
  lgr_thresholds = NULL,
  lgr_buffer_size = 0,
  seed = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>network_id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier of the rush network.
Controller and workers must have the same instance id.
Keys in Redis are prefixed with the instance id.</p>
</dd>
<dt><code>config</code></dt><dd><p>(<a href="redux.html#topic+redis_config">redux::redis_config</a>)<br />
Redis configuration options.
If <code>NULL</code>, configuration set by <code><a href="#topic+rush_plan">rush_plan()</a></code> is used.
If <code>rush_plan()</code> has not been called, the <code>REDIS_URL</code> environment variable is parsed.
If <code>REDIS_URL</code> is not set, a default configuration is used.
See <a href="redux.html#topic+redis_config">redux::redis_config</a> for details.</p>
</dd>
<dt><code>remote</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the worker is started on a remote machine.
See <a href="#topic+Rush">Rush</a> for details.</p>
</dd>
<dt><code>worker_id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier of the worker.
Keys in redis specific to the worker are prefixed with the worker id.</p>
</dd>
<dt><code>heartbeat_period</code></dt><dd><p>(<code>integer(1)</code>)<br />
Period of the heartbeat in seconds.</p>
</dd>
<dt><code>heartbeat_expire</code></dt><dd><p>(<code>integer(1)</code>)<br />
Time to live of the heartbeat in seconds.</p>
</dd>
<dt><code>lgr_thresholds</code></dt><dd><p>(named <code>character()</code> | named <code>numeric()</code>)<br />
Logger threshold on the workers e.g. <code>c(rush = "debug")</code>.</p>
</dd>
<dt><code>lgr_buffer_size</code></dt><dd><p>(<code>integer(1)</code>)<br />
By default (<code>lgr_buffer_size = 0</code>), the log messages are directly saved in the Redis data store.
If <code>lgr_buffer_size &gt; 0</code>, the log messages are buffered and saved in the Redis data store when the buffer is full.
This improves the performance of the logging.</p>
</dd>
<dt><code>seed</code></dt><dd><p>(<code>integer()</code>)<br />
Initial seed for the random number generator.
Either a L'Ecuyer-CMRG seed (<code>integer(7)</code>) or a regular RNG seed (<code>integer(1)</code>).
The later is converted to a L'Ecuyer-CMRG seed.
If <code>NULL</code>, no seed is used for the random number generator.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RushWorker-push_running_tasks"></a>



<h4>Method <code>push_running_tasks()</code></h4>

<p>Push a task to running tasks without queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>RushWorker$push_running_tasks(xss, extra = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xss</code></dt><dd><p>(list of named <code>list()</code>)<br />
Lists of arguments for the function e.g. <code style="white-space: pre;">&#8288;list(list(x1, x2), list(x1, x2)))&#8288;</code>.</p>
</dd>
<dt><code>extra</code></dt><dd><p>(<code>list</code>)<br />
List of additional information stored along with the task e.g. <code style="white-space: pre;">&#8288;list(list(timestamp), list(timestamp)))&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(<code>character()</code>)<br />
Keys of the tasks.
</p>


<hr>
<a id="method-RushWorker-pop_task"></a>



<h4>Method <code>pop_task()</code></h4>

<p>Pop a task from the queue.
Task is moved to the running tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>RushWorker$pop_task(timeout = 1, fields = "xs")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>timeout</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Time to wait for task in seconds.</p>
</dd>
<dt><code>fields</code></dt><dd><p>(<code>character()</code>)<br />
Fields to be returned.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RushWorker-push_results"></a>



<h4>Method <code>push_results()</code></h4>

<p>Pushes results to the data base.
</p>


<h5>Usage</h5>

<div class="r"><pre>RushWorker$push_results(keys, yss, extra = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keys</code></dt><dd><p>(<code>character(1)</code>)<br />
Keys of the associated tasks.</p>
</dd>
<dt><code>yss</code></dt><dd><p>(named <code>list()</code>)<br />
List of lists of named results.</p>
</dd>
<dt><code>extra</code></dt><dd><p>(named <code>list()</code>)<br />
List of lists of additional information stored along with the results.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RushWorker-set_terminated"></a>



<h4>Method <code>set_terminated()</code></h4>

<p>Mark the worker as terminated.
Last step in the worker loop before the worker terminates.
</p>


<h5>Usage</h5>

<div class="r"><pre>RushWorker$set_terminated()</pre></div>


<hr>
<a id="method-RushWorker-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RushWorker$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>The worker registers itself in the data base of the rush network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

   config_local = redux::redis_config()
   rush = rsh(network_id = "test_network", config = config_local)

   fun = function(x1, x2, ...) list(y = x1 + x2)
   rush$start_local_workers(fun = fun)

   rush$stop_workers()

</code></pre>

<hr>
<h2 id='start_worker'>Start a worker</h2><span id='topic+start_worker'></span>

<h3>Description</h3>

<p>Starts a worker.
The function loads the globals and packages, initializes the <a href="#topic+RushWorker">RushWorker</a> instance and invokes the worker loop.
This function is called by <code style="white-space: pre;">&#8288;$start_local_workers()&#8288;</code> or by the user after creating the worker script with <code style="white-space: pre;">&#8288;$create_worker_script()&#8288;</code>.
Use with caution.
The global environment is changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_worker(network_id, worker_id = NULL, remote = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="start_worker_+3A_network_id">network_id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Identifier of the rush network.
Controller and workers must have the same instance id.
Keys in Redis are prefixed with the instance id.</p>
</td></tr>
<tr><td><code id="start_worker_+3A_worker_id">worker_id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Identifier of the worker.
Keys in redis specific to the worker are prefixed with the worker id.</p>
</td></tr>
<tr><td><code id="start_worker_+3A_remote">remote</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether the worker is on a remote machine.</p>
</td></tr>
<tr><td><code id="start_worker_+3A_...">...</code></td>
<td>
<p>(<code>any</code>)<br />
Arguments passed to <a href="redux.html#topic+redis_config">redux::redis_config</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Note</h3>

<p>The function initializes the connection to the Redis data base.
It loads the packages and copies the globals to the global environment of the worker.
The function initialize the <a href="#topic+RushWorker">RushWorker</a> instance and starts the worker loop.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed
## Not run: 
  rush::start_worker(
   network_id = 'test-rush',
   remote = TRUE,
   url = 'redis://127.0.0.1:6379',
   scheme = 'redis',
   host = '127.0.0.1',
   port = '6379')

## End(Not run)
</code></pre>

<hr>
<h2 id='store_large_object'>Store Large Objects</h2><span id='topic+store_large_object'></span>

<h3>Description</h3>

<p>Store large objects to disk and return a reference to the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_large_object(obj, path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_large_object_+3A_obj">obj</code></td>
<td>
<p>(<code>any</code>)<br />
Object to store.</p>
</td></tr>
<tr><td><code id="store_large_object_+3A_path">path</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Path to store the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list()</code> of class <code>"rush_large_object"</code> with the name and path of the stored object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj = list(a = 1, b = 2)
rush_large_object = store_large_object(obj, tempdir())
</code></pre>

<hr>
<h2 id='with_rng_state'>Set RNG Sate before Running a Function</h2><span id='topic+with_rng_state'></span>

<h3>Description</h3>

<p>This function sets the rng state before running a function.
Use with caution.
The global environment is changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_rng_state(fun, args, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_rng_state_+3A_fun">fun</code></td>
<td>
<p>(<code>function</code>)<br />
Function to run.</p>
</td></tr>
<tr><td><code id="with_rng_state_+3A_args">args</code></td>
<td>
<p>(<code>list</code>)<br />
Arguments to pass to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="with_rng_state_+3A_seed">seed</code></td>
<td>
<p>(<code>integer</code>)<br />
RNG state to set before running <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>any</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with_rng_state(runif, list(n = 1), .Random.seed)
</code></pre>

<hr>
<h2 id='worker_loop_callr'>Single Task Worker Loop with callr Encapsulation</h2><span id='topic+worker_loop_callr'></span>

<h3>Description</h3>

<p>Worker loop that pops a single task from the queue, executes the function in an external callr session and pushes the results.
Supports timeouts on the tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worker_loop_callr(fun, constants = NULL, rush)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="worker_loop_callr_+3A_fun">fun</code></td>
<td>
<p>(<code>function</code>)<br />
Function to be executed.</p>
</td></tr>
<tr><td><code id="worker_loop_callr_+3A_constants">constants</code></td>
<td>
<p>(<code>list</code>)<br />
List of constants passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="worker_loop_callr_+3A_rush">rush</code></td>
<td>
<p>(<a href="#topic+RushWorker">RushWorker</a>)<br />
Rush worker instance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

   config_local = redux::redis_config()
   rush = rsh(network_id = "test_network", config = config_local)

   fun = function(x1, x2, ...) list(y = x1 + x2)
   rush$start_local_workers(
     fun = fun,
     worker_loop = worker_loop_callr)

   rush$stop_workers()

</code></pre>

<hr>
<h2 id='worker_loop_default'>Single Task Worker Loop</h2><span id='topic+worker_loop_default'></span>

<h3>Description</h3>

<p>Worker loop that pops a single task from the queue, executes the function and pushes the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worker_loop_default(fun, constants = NULL, rush)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="worker_loop_default_+3A_fun">fun</code></td>
<td>
<p>(<code>function</code>)<br />
Function to be executed.</p>
</td></tr>
<tr><td><code id="worker_loop_default_+3A_constants">constants</code></td>
<td>
<p>(<code>list</code>)<br />
List of constants passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="worker_loop_default_+3A_rush">rush</code></td>
<td>
<p>(<a href="#topic+RushWorker">RushWorker</a>)<br />
Rush worker instance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not executed since Redis must be installed

   config_local = redux::redis_config()
   rush = rsh(network_id = "test_network", config = config_local)

   fun = function(x1, x2, ...) list(y = x1 + x2)
   rush$start_local_workers(
     fun = fun,
     worker_loop = worker_loop_default)

   rush$stop_workers()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
