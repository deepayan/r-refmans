<!DOCTYPE html><html><head><title>Help for package inflection</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inflection}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#inflection-package'>
<p>Finds the Inflection Point of a Curve</p></a></li>
<li><a href='#bede'>
<p>Bisection Extremum Distance Estimator Method</p></a></li>
<li><a href='#bese'>
<p>Bisection Extremum Surface Estimator Method</p></a></li>
<li><a href='#check_curve'>
<p>Checks a curve and decides for its convexity type</p></a></li>
<li><a href='#d2uik'>
<p>Implementation of UIK method to the approximation for second order derivative of data points</p></a></li>
<li><a href='#ede'>
<p>The Extremum Distance Estimator (EDE) for finding the inflection point of a convex/concave curve</p></a></li>
<li><a href='#edeci'>
<p>An improved version of EDE that provides us with a Chebyshev confidence interval for inflection point</p></a></li>
<li><a href='#ese'>
<p>The Extremum Surface Estimator (ESE) for finding the inflection point of a convex/concave curve</p></a></li>
<li><a href='#findipiterplot'>
<p>A function to show implementation of BESE and BEDE methods by plotting their iterative convergence</p></a></li>
<li><a href='#findipl'>
<p>Finds the s-left and s-right for a given internal point x[j]</p></a></li>
<li><a href='#findiplist'>
<p>The Extremum Surface Estimator (ESE) and Extremum Distance Estimator (EDE) methods for finding the inflection point of a convex/concave curve.</p></a></li>
<li><a href='#lin2'><p>Linear function defined from two planar points (x1,y1) and (x2,y2)</p></a></li>
<li><a href='#table_01'>
<p>Fisher-Pry sigmoid with total symmetry and no error</p></a></li>
<li><a href='#table_02'>
<p>Fisher-Pry sigmoid with total symmetry and error ~ U(-0.5,0.05)</p></a></li>
<li><a href='#table_03_04'>
<p>Fisher-Pry sigmoid with data left asymmetry and no error</p></a></li>
<li><a href='#table_05_06'>
<p>Fisher-Pry sigmoid with data left asymmetry and no error ~ U(-0.05,0.05)</p></a></li>
<li><a href='#table_08_09'>
<p>Gompertz non-symmetric sigmoid with no error</p></a></li>
<li><a href='#table_10_11'>
<p>Gompertz non-symmetric sigmoid with error ~ U(-0.05,0.05)</p></a></li>
<li><a href='#table_13'>
<p>A 3rd order polynomial with total symmetry and no error</p></a></li>
<li><a href='#table_14_15'>
<p>A 3rd order polynomial with total symmetry and error ~ U(-2,2)</p></a></li>
<li><a href='#table_17_18'>
<p>A 3rd order polynomial with data right symmetry and no error</p></a></li>
<li><a href='#table_19_20'>
<p>A 3rd order polynomial with data right symmetry and error ~ U(-2,2)</p></a></li>
<li><a href='#uik'>
<p>Implementation of Unit Invariant Knee (UIK) method for finding the knee point of a curve</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Finds the Inflection Point of a Curve</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Demetris T. Christopoulos</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Demetris T. Christopoulos &lt;dchristop@econ.uoa.gr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of methods Extremum Surface Estimator (ESE) and 
   Extremum Distance Estimator (EDE) to identify the inflection point of a curve .
   Christopoulos, DT (2014) &lt;<a href="https://doi.org/10.48550%2FarXiv.1206.5478">doi:10.48550/arXiv.1206.5478</a>&gt; .
   Christopoulos, DT (2016) <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> .
   Christopoulos, DT (2016) &lt;<a href="https://doi.org/10.2139%2Fssrn.3043076">doi:10.2139/ssrn.3043076</a>&gt; .</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=inflection">https://CRAN.R-project.org/package=inflection</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, stats, graphics, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-15 12:15:59 UTC; demetris_ws</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-15 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='inflection-package'>
Finds the Inflection Point of a Curve
</h2><span id='topic+inflection-package'></span><span id='topic+inflection'></span>

<h3>Description</h3>

<p>Implementation of methods Extremum Surface Estimator (ESE), Extremum Distance Estimator
(EDE) and their iterative versions BESE and BEDE in order to identify the inflection point of a curve.
</p>


<h3>Details</h3>

<p>The x,y data should be numeric vectors of length at least 4 without missing values. <br /> 
Main functions for a convex/concave curve are: <br />
ese(x,y,0) for ESE method, see <code><a href="#topic+ese">ese</a></code> &amp; iterative version <code><a href="#topic+bese">bese</a></code> for BESE  <br />
ede(x,y,0) for EDE method, see <code><a href="#topic+ede">ede</a></code> &amp; iterative version <code><a href="#topic+bede">bede</a></code> for BEDE   <br />
findiplist(x,y,0) for both ESE and EDE methods, see <code><a href="#topic+findiplist">findiplist</a></code> <br />
</p>
<p>From version 1.3.5 it is also available the implementation of Unit Invariant Knee (UIK) method for the determination 
of elbow or knee point of a curve. That is extremely useful in a wide range of analyses every time we want to find the optimal number of 'components' from a scree plot (PCA: components, Archetypal Analysis: archetypes, Factor A.: factors,  Cluster A..: clusters and so on). In most of the cases uasage is uik(x,y), with x the vector of components, archetypes, clusters, factors or whatever and y the relevant vector Sum of Squared Errors (SSE), see <code><a href="#topic+uik">uik</a></code> and <code><a href="#topic+d2uik">d2uik</a></code>.
</p>
<p>The methods are defined at [1] &amp; [2] while a detailed reproduction of all Tables for [1] exist in a vignette. All relevant Tables exist as data, for example 
to load Table 1 of [1] we just use data(&quot;table_01&quot;). 
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1]Demetris T. Christopoulos (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]. <a href="https://arxiv.org/pdf/1206.5478v2.pdf">https://arxiv.org/pdf/1206.5478v2.pdf</a> <br />
</p>
<p>[2]Demetris T. Christopoulos (2016). On the efficient identification of an inflection point.International Journal of Mathematics and Scientific Computing, (ISSN: 2231-5330), vol. 6(1). <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> <br />
</p>
<p>[3]Demetris T. Christopoulos (2016). Introducing Unit Invariant Knee (UIK) As an Objective Choice for Elbow Point in Multivariate Data Analysis Techniques (March 1, 2016). <a href="https://www.ssrn.com/abstract=3043076">https://www.ssrn.com/abstract=3043076</a>  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ese">ese</a></code>, <code><a href="#topic+bese">bese</a></code>, <code><a href="#topic+ede">ede</a></code>, <code><a href="#topic+bede">bede</a></code>, <code><a href="#topic+findiplist">findiplist</a></code>, <code><a href="#topic+findipiterplot">findipiterplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
## Lets create some convex/concave data based on the Fisher-Pry model
##by using 1001 not equal spaced abscissas with data right asymmetry
N=20001;
## Case I: not noisy data
#
set.seed(20190628);
x=sort(runif(N,0,15));y=5+5*tanh(x-5);
#
# t1=Sys.time();
# tese=ese(x,y,0,doparallel = TRUE);#...simple run of ESE
# t2=Sys.time();print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
## Time difference of 6.023056 secs
# tese;
##       j1   j2      chi
## ESE 4573 8272 4.834904
tede=ede(x,y,0);tede;#...simple run of EDE
##       j1   j2      chi
## EDE 4418 8867 5.000198
edeci(x,y,0);#...Run EDE and compute 95% Chebyshev c.i.
##       j1   j2      chi k  chi-5*s chi+5*s
## EDE 4418 8867 5.000198 5 4.994605 5.00579
#
# t1=Sys.time();
# eseit=bese(x,y,0,doparallel = TRUE);#...Bisection ESE (BESE)
# t2=Sys.time();
# print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
## Time difference of 6.262982 secs
#eseit$iplast #...last estimation for inflection point
## [1] 5.000773
#eseit$iters #...all iterations done...
#        n            a         b      ESE
# 1  20001 0.0001931784 14.999900 4.835303
# 2   3668 4.4606627093  5.647031 5.053847
# 3   1567 4.6878642635  5.262619 4.975242
# 4    737 4.8696049280  5.154673 5.012139
# 5    376 4.9229470803  5.064312 4.993629
# 6    181 4.9684872106  5.038649 5.003568
# 7     82 4.9806225684  5.015416 4.998019
# 8     35 4.9924177257  5.009629 5.001023
# 9     20 4.9960624950  5.002740 4.999401
# 10    11 4.9980399851  5.001968 5.000004
#
t1=Sys.time();
edeit=bede(x,y,0);#...Bisection EDE (BEDE)
t2=Sys.time();
print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
# Time difference of 0.073102 secs
edeit$iplast #...last estimation for inflection point
## [1]  4.999941
edeit$iters #...all iterations done
##        n            a         b      EDE
## 1  20001 0.0004635123 14.999801 5.000198
## 2   4450 4.1996716394  5.799961 4.999816
## 3   2129 4.5614927786  5.438346 4.999920
## 4   1182 4.7512642248  5.249931 5.000597
## 5    656 4.8580908542  5.143351 5.000721
## 6    365 4.9175169028  5.082218 4.999868
## 7    229 4.9524894403  5.047898 5.000194
## 8    135 4.9723928177  5.027658 5.000025
## 9     77 4.9835896748  5.016056 4.999823
## 10    46 4.9904827878  5.009340 4.999912
## 11    28 4.9945713510  5.005444 5.000008
## 12    15 4.9968973151  5.003045 4.999971
## 13    11 4.9978968780  5.001986 4.999941
# t1=Sys.time();
# A=findiplist(x,y,0,doparallel=TRUE);#...Run both ESE &amp; EDE at once...
# t2=Sys.time();print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
## Time difference of 5.143354 secs
#A
##       j1   j2      chi
## ESE 4573 8272 4.834904
## EDE 4418 8867 5.000198
## Let's plot some interesting approximately results.
# plot(x,y,type="l",xaxt="n",lwd=2);axis(1,at=seq(0,x[N]));
# lines(c(x[1],x[A[1,2]]),c(y[1],y[A[1,2]]),col="green",lty=2);
# lines(c(x[N],x[A[1,1]]),c(y[N],y[A[1,1]]),col="blue",lty=2);
# lines(c(x[1],x[N]),c(y[1],y[N]),col="black",lty=2);
# abline(v=A[,3],col=c('blue','red'),lty=2);
# points(x[A[1,1:2]],y[A[1,1:2]], type = "p",pch = 19,col="blue",font=2);
# points(x[A[2,1:2]],y[A[2,1:2]], type = "p",pch = 19,col="red",font=2);
# text(A[1,3]-0.5,0,expression(chi[S]),font=2,col='blue');
# text(A[2,3]+0.5,0,expression(chi[D]),font=2,col='red');
# grid();
#
### Case II: noisy data
#
set.seed(20190628);
x=sort(runif(N,0,15));
r=0.1;y=5+5*tanh(x-5)+rnorm(N,0,0.05);
#
# t1=Sys.time();
# tese=ese(x,y,0,doparallel = TRUE);#...simple run of ESE
# t2=Sys.time();
# print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
## Time difference of 4.878437 secs
#tese
##       j1   j2      chi
## ESE 4684 8412 4.936269
tede=ede(x,y,0);tede;#...simple run of EDE
#       j1   j2      chi
# EDE 4190 8856 4.909071
edeci(x,y,0);#...Run EDE and compute 95% Chebyshev c.i.
##       j1   j2      chi k  chi-5*s  chi+5*s
## EDE 4190 8856 4.909071 5 4.659396 5.158746
# t1=Sys.time();
# eseit=bese(x,y,0,doparallel = TRUE);#...Bisection ESE (BESE)
# t2=Sys.time();print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
## Time difference of 6.288019 secs
#eseit$iplast#...last estimation for inflection point
## [1] 4.94072
#eseit$iters#...all iterations done...
##       n            a         b      ESE
## 1 20001 0.0004635123 14.999801 4.936269
## 2  3729 4.4285049755  5.538487 4.983496
## 3  1475 4.7297708667  5.413794 5.071782
## 4   932 4.7838335764  5.097607 4.940720
#
t1=Sys.time();
edeit=bede(x,y,0);#...Bisection EDE (BEDE)
t2=Sys.time();
print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
## Time difference of 0.01700807 secs
edeit$iplast#...last estimation for inflection point
## [1] 5.071782
edeit$iters#...all iterations done
##       n            a         b      EDE
## 1 20001 0.0004635123 14.999801 4.909071
## 2  4667 4.2343777127  5.704010 4.969194
## 3  1938 4.7297708667  5.413794 5.071782
#
# t1=Sys.time();
# A=findiplist(x,y,0,doparallel=TRUE);#...Run both ESE &amp; EDE at once...
# t2=Sys.time();
# print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
## Time difference of 5.037386 secs
#A
##       j1   j2      chi
## ESE 4684 8412 4.936269
## EDE 4190 8856 4.909071
#
## Let's plot some interesting approximately results.
# plot(x,y,type="l",xaxt="n",lwd=2);axis(1,at=seq(0,x[N]));
# lines(c(x[1],x[A[1,2]]),c(y[1],y[A[1,2]]),col="green",lty=2);
# lines(c(x[N],x[A[1,1]]),c(y[N],y[A[1,1]]),col="blue",lty=2);
# lines(c(x[1],x[N]),c(y[1],y[N]),col="black",lty=2);
# abline(v=A[,3],col=c('blue','red'),lty=2);
# points(x[A[1,1:2]],y[A[1,1:2]], type = "p",pch = 19,col="blue",font=2);
# points(x[A[2,1:2]],y[A[2,1:2]], type = "p",pch = 19,col="red",font=2);
# text(A[1,3]-0.5,0,expression(chi[S]),font=2,col='blue');
# text(A[2,3]+0.5,0,expression(chi[D]),font=2,col='red');
# grid();
## Close device
#dev.off()
##
## Load data used for Tables of [1]
data("table_01")
dh=table_01
plot(dh,pch=19,cex=0.1)
A=findiplist(dh$x,dh$y,0) 
A
abline(v=A[1,3],col='blue')
abline(v=A[2,3],col='red')
##
</code></pre>

<hr>
<h2 id='bede'>
Bisection Extremum Distance Estimator Method 
</h2><span id='topic+bede'></span>

<h3>Description</h3>

<p>It iterates in a way similar to the well known bisection method in root finding, with the only exception that 
our <code class="reqn">[a_{n},b_{n}]</code> intervals contain the inflection point now and the rule for choosing them follows definitions
and Lemmas of [1], [2].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bede(x, y, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bede_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="bede_+3A_y">y</code></td>
<td>

<p>The numeric vector of the noisy or not y-ordinates, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="bede_+3A_index">index</code></td>
<td>

<p>If data is convex/concave then index=0 <br />
If data is concave/convex then index=1
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is the fastest solution for very large data sets, over one million rows.
</p>


<h3>Value</h3>

<p>It returns a list of two elements: <br />
</p>
<table>
<tr><td><code>iplast</code></td>
<td>
<p>the last EDE estimation that was found</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>a matrix with 4 columns (&quot;n&quot;, &quot;a&quot;, &quot;b&quot;, &quot;EDE&quot;) that give the number of x-y pairs 
used at each iteration, the [a,b] range where we searched and the EDE estimated inflection point.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1]Demetris T. Christopoulos (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]. <a href="https://arxiv.org/pdf/1206.5478v2.pdf">https://arxiv.org/pdf/1206.5478v2.pdf</a> <br />
</p>
<p>[2]Demetris T. Christopoulos (2016). On the efficient identification of an inflection point.International Journal of Mathematics and Scientific Computing, (ISSN: 2231-5330), vol. 6(1). <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> 
</p>


<h3>See Also</h3>

<p>See also the simple version <code><a href="#topic+ede">ede</a></code>, <code><a href="#topic+edeci">edeci</a></code> and iterations plot using <code><a href="#topic+findipiterplot">findipiterplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#Fisher-pry model with heavy noise, unequal spaces
#and 1 million cases:
N=10^6+1;
set.seed(2017-05-11);x=sort(runif(N,0,10));y=5+5*tanh(x-5)+runif(N,-1,1);
#
ptm &lt;- proc.time()
tede=ede(x,y,0);tede;proc.time() - ptm
#         j1     j2      chi
# EDE 351061 648080 4.997139
# user  system elapsed 
# 0.02    0.02    0.05 
#
</code></pre>

<hr>
<h2 id='bese'>
Bisection Extremum Surface Estimator Method
</h2><span id='topic+bese'></span>

<h3>Description</h3>

<p>It iterates in a way similar to the well known bisection method in root finding, with the only exception that 
our <code class="reqn">[a_{n},b_{n}]</code> intervals contain the inflection point now and the rule for choosing them follows definitions
and Lemmas of [1], [2]. It uses parallel computing under user request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bese(x, y, index, doparallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bese_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="bese_+3A_y">y</code></td>
<td>

<p>The numeric vector of the noisy or not y-ordinates, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="bese_+3A_index">index</code></td>
<td>

<p>If data is convex/concave then index=0 <br />
If data is concave/convex then index=1
</p>
</td></tr>
<tr><td><code id="bese_+3A_doparallel">doparallel</code></td>
<td>

<p>If doparallel=TRUE then parallel computing is applied, based on the available workers of current machine (default value = FALSE)    
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is suitable for making a &lsquo;fine tuning&rsquo; while searching for inflection point.
For very large data sets it is better using first EDE method, see <code><a href="#topic+ede">ede</a></code>.
Then we apply BESE at a smaller range.
</p>


<h3>Value</h3>

<p>It returns a list of two elements: <br />
</p>
<table>
<tr><td><code>iplast</code></td>
<td>
<p>the last estimation found</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>a matrix with 4 columns (&quot;n&quot;, &quot;a&quot;, &quot;b&quot;, &quot;ESE&quot;) that give the number of x-y pairs 
used at each iteration, the [a,b] range where we searched and the ESE estimated inflection point.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Parallel computing was added in version 1.3
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1]Demetris T. Christopoulos, Developing methods for identifying the inflection point of a convex/ concave curve. arXiv:1206.5478v2 [math.NA], <a href="https://arxiv.org/pdf/1206.5478v2.pdf">https://arxiv.org/pdf/1206.5478v2.pdf</a>, 2014 <br />
</p>
<p>[2]Demetris T. Christopoulos, On the efficient identification of an inflection point,International Journal of Mathematics and Scientific Computing,(ISSN: 2231-5330), vol. 6(1), <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a>, 2016
</p>


<h3>See Also</h3>

<p>See also the simple version <code><a href="#topic+ese">ese</a></code> and iterations plot using <code><a href="#topic+findipiterplot">findipiterplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fisher-pry model with noise and 50k cases:
N=5*10^4+1;
set.seed(2017-05-11);x=seq(0,15,length.out = N);y=5+5*tanh(x-5)+runif(N,-0.25,0.25);
#We first run BEDE to find a smaller neighborhood for inflection point
iters=bede(x,y,0)$iters;
iters;
#Now we find last interval
ab=apply(iters[dim(iters)[1],c('a','b')],2,function(xx,x){which(x==xx)},x);ab;
#Apply BESE to that
eseit=bese(x[ab[1]:ab[2]],y[ab[1]:ab[2]],0)
eseit$iplast
eseit$iters
#Or apply directly to data with doparallel=TRUE
#
#t1=Sys.time();
#eseit=bese(x,y,0,doparallel = TRUE);#...Bisection ESE (BESE)
#t2=Sys.time();print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
# Time difference of 56.14608 secs
#eseit$iplast#...last estimation for inflection point
# [1] 5.0241
#eseit$iters#...all iterations done...
#       n      a       b     ESE
# 1 50001 0.0000 15.0000 4.81740
# 2  9375 4.4721  5.6505 5.06130
# 3  3929 4.7007  5.2758 4.98825
# 4  1918 4.8654  5.1828 5.02410
#Better accuracy, slightly more time, provided that there exist multi cores.
#plot(eseit$iters$ESE,type='b');abline(h=5,col='blue',lwd=3)
#
</code></pre>

<hr>
<h2 id='check_curve'>
Checks a curve and decides for its convexity type
</h2><span id='topic+check_curve'></span>

<h3>Description</h3>

<p>Given a planar curve with discrete (xi,yi) points this function can find if it is convex, concave or
for the sigmoid case if it is convex/concave or concave/convex. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_curve(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_curve_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas
</p>
</td></tr>
<tr><td><code id="check_curve_+3A_y">y</code></td>
<td>

<p>The numeric vector of y-abscissas
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses the function <code><a href="#topic+findipl">findipl</a></code> which provides us with a consistent estimator for the 
surfaces left and right that are used here, see [1],[2] for more details.
</p>


<h3>Value</h3>

<p>A list with members:
</p>

<ol>
<li><p> ctype, the convexity type of the curve
</p>
</li>
<li><p> index, the index that can be used from other functions to identify the inflection point
</p>
</li></ol>



<h3>Note</h3>

<p>If we do not have a visual inspection of our data, then this function is useful because it can automate the usage of all other functions that compute the inflection point.
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1]Demetris T. Christopoulos (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]. <a href="https://arxiv.org/pdf/1206.5478v2.pdf">https://arxiv.org/pdf/1206.5478v2.pdf</a> <br />
</p>
<p>[2]Demetris T. Christopoulos (2016). On the efficient identification of an inflection point.International Journal of Mathematics and Scientific Computing, (ISSN: 2231-5330), vol. 6(1). <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> <br />
</p>
<p>[3]Bardsley, W. G. &amp; Childs, R. E. Sigmoid curves, non-linear double-reciprocal plots and allosterism Biochemical Journal, Portland Press Limited, 1975, 149, 313-328
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findipl">findipl</a></code>, <code><a href="#topic+ese">ese</a></code>, <code><a href="#topic+ede">ede</a></code>, <code><a href="#topic+bese">bese</a></code>, <code><a href="#topic+bede">bede</a></code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Lets create a really hard data set, an exxample of a "2:2 function" taken from [3]
## This function for x&gt;0 has an inflectrion point at 
## x = -1/8+(1/24)*sqrt(381) = 0.6883008876 ~0.69
## We want to see ,if function 'check_curve()' will proper classify it,
## given that we used [0.2,4] as definition range.
f=function(x){(1/8*x+1/2*x^2)/(1+1/8*x+1/2*x^2)}
x=seq(0.2,4,0.05)
y=f(x)
plot(x,y,pch=19,cex=0.5)
cc=check_curve(x,y)
cc
## $ctype
## [1] "convex_concave"
## 
## $index
## [1] 0
##
## Yes it found it.
</code></pre>

<hr>
<h2 id='d2uik'>
Implementation of UIK method to the approximation for second order derivative of data points
</h2><span id='topic+d2uik'></span>

<h3>Description</h3>

<p>It finds the UIK estimation for elbow or knee point of a curve, see [1] for details,
but now it applies the method to the properly prepared approximation of second derivative  
for data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2uik(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d2uik_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 6.
</p>
</td></tr>
<tr><td><code id="d2uik_+3A_y">y</code></td>
<td>

<p>The numeric vector of y-abscissas, must be of length at least 6.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A preprocessing step is initially done in order to ensure that data points have unique x-abscissas:
</p>

<ul>
<li><p> if no multiple entries exist for the same xi's, then we proceed with initial data frame
</p>
</li>
<li><p> if multiple entries exist for the same xi's, then we average entries and proceed with the new aggregated data frame
</p>
</li></ul>

<p>After we take the approximation of second derivative for the discrete data points as given from the second order forward divided differences 
estimation. Finally we apply UIK method on the absolute values of the estimated second derivatives.
</p>


<h3>Value</h3>

<p>It returns the x-abscissa which is the estimation for the knee point.
</p>


<h3>Warning </h3>

<p>Please use this function as a supplementary to <code><a href="#topic+uik">uik</a></code>.
</p>


<h3>Note</h3>

<p>This function has been created for robustnes reasons:
</p>

<ul>
<li><p> many times the knee point is dependent on the number N of used data points
</p>
</li>
<li><p> in those cases by applying UIK method on second derivatives we obtain a result that does not depend on N
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1] Christopoulos, Demetris T., Introducing Unit Invariant Knee (UIK) As an Objective Choice 
for Elbow Point in Multivariate Data Analysis Techniques (March 1, 2016).
Available at SSRN: https://ssrn.com/abstract=3043076 or http://dx.doi.org/10.2139/ssrn.3043076
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uik">uik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Lets create a convex data set with x from 1 to 10
x=seq(1,10,1)
y=1/x
plot(x,y)
uik1=uik(x,y)
uik1
## [1] 3 
uik2=d2uik(x,y)
uik2
## [1] 3
## Lets extend it from 1 to 15
x=seq(1,15,1)
y=1/x
plot(x,y)
uik1=uik(x,y)
uik1
## [1] 4 
uik2=d2uik(x,y)
uik2
## [1] 3
## We observe the d2uik remains 3
## Lets do the same job with noisy data sets:
set.seed(20190625)
x=seq(1,10,1)
y=1/x+runif(length(x),-0.02,0.02)
plot(x,y)
uik1=uik(x,y)
uik1
## [1] 3
uik2=d2uik(x,y)
uik2
## [1] 3
## Extension to 1:15
x=seq(1,15,1)
y=1/x+runif(length(x),-0.02,0.02)
plot(x,y)
uik1=uik(x,y)
uik1
## [1] 5
uik2=d2uik(x,y)
uik2
## [1] 3
## Again d2uik is stable
</code></pre>

<hr>
<h2 id='ede'>
The Extremum Distance Estimator (EDE) for finding the inflection point of a convex/concave curve
</h2><span id='topic+ede'></span>

<h3>Description</h3>

<p>Implementation of EDE method as defined in [1] and [2] by giving a simple output of the method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ede(x, y, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ede_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="ede_+3A_y">y</code></td>
<td>

<p>The numeric vector of the noisy or not y-ordinates, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="ede_+3A_index">index</code></td>
<td>

<p>If data is convex/concave then index=0 <br />
If data is concave/convex then index=1
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We also obtain the <code class="reqn">x_{F_{1}},x_{F_{2}}</code> points, see [1], [2].
</p>


<h3>Value</h3>

<p>A matrix of size 1 x 3 is returned with elements:
</p>
<table>
<tr><td><code>A(1</code>, <code>1)</code></td>
<td>
<p>The index <code class="reqn">j_{F_{1}}</code> for EDE method</p>
</td></tr>
<tr><td><code>A(1</code>, <code>2)</code></td>
<td>
<p>The index <code class="reqn">j_{F_{2}}</code> for EDE method</p>
</td></tr>
<tr><td><code>A(1</code>, <code>3)</code></td>
<td>
<p>The Extremum Distance Estimator (EDE) for inflection point</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is for real big data sets, more than one million rows. It is the fastest available method, see [2] for comparison to other methods.
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1]Demetris T. Christopoulos (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]. <a href="https://arxiv.org/pdf/1206.5478v2.pdf">https://arxiv.org/pdf/1206.5478v2.pdf</a> <br />
</p>
<p>[2]Demetris T. Christopoulos (2016). On the efficient identification of an inflection point.International Journal of Mathematics and Scientific Computing, (ISSN: 2231-5330), vol. 6(1). <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> 
</p>


<h3>See Also</h3>

<p>See also the iterative version <code><a href="#topic+bede">bede</a></code> and iterations plot using <code><a href="#topic+findipiterplot">findipiterplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#Fisher-pry model with heavy noise, unequal spaces
#and 1 million cases:
N=10^6+1;
set.seed(2017-05-11);x=sort(runif(N,0,10));y=5+5*tanh(x-5)+runif(N,-1,1);
#
ptm &lt;- proc.time()
tede=ede(x,y,0);tede;proc.time() - ptm
#         j1     j2      chi
# EDE 351061 648080 4.997139
# user  system elapsed 
# 0.01    0.00    0.01 
#
</code></pre>

<hr>
<h2 id='edeci'>
An improved version of EDE that provides us with a Chebyshev confidence interval for inflection point
</h2><span id='topic+edeci'></span>

<h3>Description</h3>

<p>It computes except from the common EDE output the Chebyshev confidence interval based on Chebyshev inequality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edeci(x, y, index, k = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edeci_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="edeci_+3A_y">y</code></td>
<td>

<p>The numeric vector of the noisy or not y-ordinates, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="edeci_+3A_index">index</code></td>
<td>

<p>If data is convex/concave then index=0 <br />
If data is concave/convex then index=1
</p>
</td></tr>
<tr><td><code id="edeci_+3A_k">k</code></td>
<td>

<p>According to Chebyshev's inequality we find a relevant Chebyshev confidence interval of 
the form <code class="reqn">[\mu-k\,\sigma,\mu+k\,\sigma]</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We define as Chebyshev confidence interval the
</p>
<p style="text-align: center;"><code class="reqn">[\mu-k\,\sigma,\mu+k\,\sigma]</code>
</p>

<p>where usually k=5 because it corresponds to 96%, while an estimator of <code class="reqn">\sigma</code> is given by <code class="reqn">s_{D}</code>, see Eq. (29) of [2]:<br />
</p>
<p style="text-align: center;"><code class="reqn">s_{D}^2=\frac{1}{2}\,s^2=\frac{1}{2}\,\sum\limits_{i=1}^{n}{(\frac{y_{i}-y_{i-1}}{2})^2}</code>
</p>



<h3>Value</h3>

<p>A one row matrix with elements the output of EDE, the given k and the Chebyshev c.i.
</p>


<h3>Note</h3>

<p>This function works better if the noise is of a &quot;zig-zag&quot;&quot; pattern, see [1].
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>Demetris T. Christopoulos (2016). On the efficient identification of an inflection point.International Journal of Mathematics and Scientific Computing, (ISSN: 2231-5330), vol. 6(1). <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> 
</p>


<h3>See Also</h3>

<p>See also the simple <code><a href="#topic+ede">ede</a></code> and iterative version <code><a href="#topic+bede">bede</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#Gompertz model with noise, unequal spaces
#and 1 million cases:
N=10^6+1;
set.seed(2017-05-11);x=sort(runif(N,0,10));y=10*exp(-exp(5)*exp(-x))+runif(N,-0.05,0.05);
#EDE one time only
ede(x,y,0)
#         j1     j2      chi
# EDE 372064 720616 5.465584
#Not so close to the exact point
#Let's reduce the size using BEDE
iters=bede(x,y,0)$iters;iters;
#         n            a        b      EDE
# 1 1000001 2.273591e-05 9.999994 5.465584
# 2  348553 4.237734e+00 6.017385 5.127559
# 3  177899 4.573986e+00 5.499655 5.036821
#Now we choose last interval, in order for EDE to be applicable on next run
ab=apply(iters[dim(iters)[1]-1,c('a','b')],2,function(xx,x){which(x==xx)},x);ab;
#      a      b 
# 423480 601378
#Apply edeci...
edeci(x[ab[1]:ab[2]],y[ab[1]:ab[2]],0)
#        j1     j2      chi k  chi-5*s  chi+5*s
# EDE 33355 126329 5.036821 5 4.892156 5.181485
#Very close to the true inflection point.
#
</code></pre>

<hr>
<h2 id='ese'>
The Extremum Surface Estimator (ESE) for finding the inflection point of a convex/concave curve
</h2><span id='topic+ese'></span>

<h3>Description</h3>

<p>Implementation of ESE method as defined in [1] and [2] by giving a simple output of the method. Use of parallel computing under user request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ese(x, y, index, doparallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ese_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="ese_+3A_y">y</code></td>
<td>

<p>The numeric vector of the noisy or not y-ordinates, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="ese_+3A_index">index</code></td>
<td>

<p>If data is convex/concave then index=0 <br />
If data is concave/convex then index=1
</p>
</td></tr>
<tr><td><code id="ese_+3A_doparallel">doparallel</code></td>
<td>

<p>If doparallel=TRUE then parallel computing is applied, based on the available workers of current machine (default value = FALSE)    
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is from an unknown function and without noise then we can find the inflection point by a way similar to bisection method way for root finding.
If data is noisy, then we have two consistent estimators of the trapezoidal estimated inflection point, i.e. we consistently estimate what we could find by computing the relevant areas with elementary trapezoids.
This method is not so fast as <code><a href="#topic+ede">ede</a></code> but it can be used for a fine-tuning of the result returned be EDE.
</p>


<h3>Value</h3>

<p>A matrix of size 1 x 3 is returned with elements:
</p>
<table>
<tr><td><code>A(1</code>, <code>1)</code></td>
<td>
<p>The index j-right for ESE method</p>
</td></tr>
<tr><td><code>A(1</code>, <code>2)</code></td>
<td>
<p>The index j-left for ESE method</p>
</td></tr>
<tr><td><code>A(1</code>, <code>3)</code></td>
<td>
<p>The Extremum Surface Estimator (ESE) for inflection point</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use doparallel=TRUE option when you have relative large data sets (N&gt;20000). <br />
For large data sets (one million rows) it is better to use first <code><a href="#topic+ede">ede</a></code> or <code><a href="#topic+bede">bede</a></code>
in order to locate a smaller neighbourhood of the inflection point. Then ese gives a better estimation, since it uses 
surfaces and not distances from total chord.
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1]Demetris T. Christopoulos (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]. <a href="https://arxiv.org/pdf/1206.5478v2.pdf">https://arxiv.org/pdf/1206.5478v2.pdf</a> <br />
</p>
<p>[2]Demetris T. Christopoulos (2016). On the efficient identification of an inflection point.International Journal of Mathematics and Scientific Computing, (ISSN: 2231-5330), vol. 6(1). <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> 
</p>


<h3>See Also</h3>

<p>See also the iterative version <code><a href="#topic+bese">bese</a></code> and iterations plot using <code><a href="#topic+findipiterplot">findipiterplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#
#Fisher-pry model with heavy noise and unequal spaces, relative large data set:
#N=20001;
#set.seed(2017-05-11);x=sort(runif(N,0,10));y=5+5*tanh(x-5)+runif(N,-1,1);
#plot(x,y,type='l',ylab=expression(5+5*tanh(x-5)+epsilon[i]))
#
#t1=Sys.time();
#tese=ese(x,y,0,doparallel = TRUE);
#t2=Sys.time();print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
#Time difference of 7.641404 secs
#tese;abline(v=tese[3],col='blue')
#       j1    j2      chi
# ESE 7559 12790 5.078434
#Compare with serial version (don't run):
#
# t1=Sys.time();
# tese=ese(x,y,0,doparallel = FALSE);
# t2=Sys.time();print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
# #Time difference of 24.24364 secs
# tese;
#      j1    j2      chi
# ESE 7559 12790 5.078434
#
</code></pre>

<hr>
<h2 id='findipiterplot'>
A function to show implementation of BESE and BEDE methods by plotting their iterative convergence
</h2><span id='topic+findipiterplot'></span>

<h3>Description</h3>

<p>We apply the BESE and BEDE methods, we plot results showing the bisection like convergence to the true inflection point. 
One plot is created for BESE and another one for BEDE. If it is possible, then we compute 95% confidence intervals
for the results. Parallel computing also available under user request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findipiterplot(x, y, index, plots = TRUE, ci = FALSE, doparallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findipiterplot_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="findipiterplot_+3A_y">y</code></td>
<td>

<p>The numeric vector of the noisy or not y-ordinates
</p>
</td></tr>
<tr><td><code id="findipiterplot_+3A_index">index</code></td>
<td>

<p>If data is convex/concave then index=0 <br />
If data is concave/convex then index=1
</p>
</td></tr>
<tr><td><code id="findipiterplot_+3A_plots">plots</code></td>
<td>

<p>When plots=TRUE the plot commands are executed (default value = TRUE) 
</p>
</td></tr>
<tr><td><code id="findipiterplot_+3A_ci">ci</code></td>
<td>

<p>When ci=TRUE the 95% confidence intervals are computed, if sufficient results are available (default value = FALSE) 
</p>
</td></tr>
<tr><td><code id="findipiterplot_+3A_doparallel">doparallel</code></td>
<td>

<p>If doparallel=TRUE then parallel computing is applied, based on the available workers of current machine (default value = FALSE)    
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It applies iteratively when that is theoretically allowable the methods ESE, EDE, stores all useful results and according to 
the input computes 95% confidence intervals and plots the two sequences (BESE, BEDE).
Useful for a graphical investigation of the inflection point.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ans$first</code></td>
<td>
<p>The output of first run for ESE and EDE methods</p>
</td></tr>
<tr><td><code>ans$BESE</code></td>
<td>
<p>The vector of BESE iterations</p>
</td></tr>
<tr><td><code>ans$BEDE</code></td>
<td>
<p>The vector of BEDE iterations</p>
</td></tr>
<tr><td><code>ans$aesmout</code></td>
<td>
<p>Mean, Std Deviation and 95 % confidence interval for all BESE iterations, if possible</p>
</td></tr>
<tr><td><code>ans$aedmout</code></td>
<td>
<p>Mean, Std Deviation and 95 % confidence interval for all BEDE iterations, if possible</p>
</td></tr>
<tr><td><code>ans$xysl</code></td>
<td>
<p>A list of xy data frames containing the data used for every ESE iteration</p>
</td></tr>
<tr><td><code>ans$xydl</code></td>
<td>
<p>A list of xy data frames containing the data used for every EDE iteration</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>Non direct methods have been removed in version 1.3 due to their limited functionality.
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1]Demetris T. Christopoulos (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]. <a href="https://arxiv.org/pdf/1206.5478v2.pdf">https://arxiv.org/pdf/1206.5478v2.pdf</a> <br />
</p>
<p>[2]Demetris T. Christopoulos (2016). On the efficient identification of an inflection point.International Journal of Mathematics and Scientific Computing, (ISSN: 2231-5330), vol. 6(1). <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bese">bese</a></code> and <code><a href="#topic+bede">bede</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#Lets create some convex/concave data based on the Fisher-Pry model, without noise
f=function(x){5+5*tanh(x-5)};xa=0;xb=15;
set.seed(12345);x=sort(runif(5001,xa,xb));y=f(x);
#
t1=Sys.time();
a&lt;-findipiterplot(x,y,0,TRUE,TRUE,FALSE);
t2=Sys.time();print(as.POSIXlt(t2, "GMT")-as.POSIXlt(t1, "GMT"),quote=F);
#Time difference of 2.692897 secs
#Lets see available results
ls(a)
# [1] "aedmout" "aesmout" "BEDE"    "BESE"    "first"   "xydl"    "xysl"  
a$first;#Show first solution
#       i1   i2  chi_S,D
# ESE 1128 2072 4.835633
# EDE 1091 2221 4.999979
a$BESE;#Show ESE iterations
#                       1        2        3        4        5        6        7        8
# ESE iterations 4.835633 5.054775 4.978086 5.011331 4.993876 5.003637 4.998145 4.999782
a$BEDE;#Show EDE iterations
#                       1        2        3        4        5        6        7        8        
# EDE iterations 4.999979 4.996327 4.997657 5.001511 4.996464 5.000629 4.999149 4.999885 
#        9       10
# 5.000082 4.999782
a$aesmout;#Statistics and 95%c c.i. for ESE
#                mean      sdev   95%(l)   95%(r)
# ESE method 4.984408 0.0640699 4.930844 5.037972
a$aedmout;#Statistics and 95%c c.i. for EDE
#                mean        sdev   95%(l) 95%(r)
# EDE method 4.999146 0.001753223 4.997892 5.0004
#
#Look how bisection based method (BESE) converges in 8 steps...
#
lapply(a$xysl,summary);
# [[1]]
# x                   y           
# Min.   : 0.006405   Min.   : 0.00046  
# 1st Qu.: 3.802278   1st Qu.: 0.83521  
# Median : 7.583006   Median : 9.94325  
# Mean   : 7.504537   Mean   : 6.68942  
# 3rd Qu.:11.240944   3rd Qu.: 9.99996  
# Max.   :14.994895   Max.   :10.00000  
# 
#...
#
# 
# [[8]]
# x               y        
# Min.   :4.978   Min.   :4.891  
# 1st Qu.:4.988   1st Qu.:4.938  
# Median :5.004   Median :5.018  
# Mean   :4.999   Mean   :4.997  
# 3rd Qu.:5.009   3rd Qu.:5.043  
# Max.   :5.018   Max.   :5.090  
# 
# and BEDE in 10 steps:
#
lapply(a$xydl,summary)
# [[1]]
# x                   y           
# Min.   : 0.006405   Min.   : 0.00046  
# 1st Qu.: 3.802278   1st Qu.: 0.83521  
# Median : 7.583006   Median : 9.94325  
# Mean   : 7.504537   Mean   : 6.68942  
# 3rd Qu.:11.240944   3rd Qu.: 9.99996  
# Max.   :14.994895   Max.   :10.00000  
# 
# ...
# 
# [[10]]
# x               y        
# Min.   :4.982   Min.   :4.911  
# 1st Qu.:4.993   1st Qu.:4.965  
# Median :5.004   Median :5.019  
# Mean   :5.001   Mean   :5.007  
# 3rd Qu.:5.009   3rd Qu.:5.045  
# Max.   :5.018   Max.   :5.090  
#
# See also the pdf plots 'ese_iterations.pdf' and 'ede_iterations.pdf'
</code></pre>

<hr>
<h2 id='findipl'>
Finds the s-left and s-right for a given internal point x[j]
</h2><span id='topic+findipl'></span>

<h3>Description</h3>

<p>From the definitions (1.3), (2.2) of references [1], [2] it is necessary to find <code class="reqn">s_l</code> and <code class="reqn">s_r</code> in order to estimate the Extremum Surface Estimator (ESE)
of the inflection point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findipl(x, y, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findipl_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="findipl_+3A_y">y</code></td>
<td>

<p>The numeric vector of the noisy or not y-ordinates, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="findipl_+3A_j">j</code></td>
<td>

<p>The data index j such that x=<code class="reqn">x_j</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned that contains
</p>
<table>
<tr><td><code>j</code></td>
<td>
<p>The data index j such that x=<code class="reqn">x_j</code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The corresponding x-abscissa</p>
</td></tr>
<tr><td><code>sl</code></td>
<td>
<p>The value of s-left</p>
</td></tr>
<tr><td><code>sr</code></td>
<td>
<p>The value of s-right</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This small function is used when we are scanning for the position of inflection point in ESE method.
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1]Demetris T. Christopoulos (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]. <a href="https://arxiv.org/pdf/1206.5478v2.pdf">https://arxiv.org/pdf/1206.5478v2.pdf</a> <br />
</p>
<p>[2]Demetris T. Christopoulos (2016). On the efficient identification of an inflection point.International Journal of Mathematics and Scientific Computing, (ISSN: 2231-5330), vol. 6(1). <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+ese">ese</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#Lets create some data based on the Fisher-Pry model, without noise:
x&lt;-seq(0,10,by=0.1);y&lt;-5*(1+tanh(x-5));
tese=ese(x,y,0);tese;
#     j1 j2 chi
# ESE 39 63   5
N&lt;-length(x);N
# [1] 101
#We know that total symmetry exists, so for the middle point it is better to compute |sl|=|sr|
j=(N-1)/2+1;j
# [1] 51
#Define the left and right chord:
fl&lt;-function(t){y[1] + (y[j] - y[1]) * (t - x[1]) / (x[j] - x[1])}
fr&lt;-function(t){y[j] + (y[N] - y[j]) * (t - x[j]) / (x[N] - x[j])}
#Find the s-left and s-right:
LR&lt;-findipl(x,y,j);LR;
# [1] 51.000000  5.000000 -9.031459  9.031459
#Show all results in a plot:
plot(x,y,type="l",col="red")
lines(c(x[1],x[j]),c(y[1],y[j]),type="l",col="green")
lines(c(x[N],x[j]),c(y[N],y[j]),type="l",col="blue")
points(x[j],y[j], type = "p",pch = 19,col="black")
text(2.5,1,round(LR[3],digits=2))
text(6.5,7.5,round(LR[4],digits=2))
#The two surfaces are indeed absolutely equal |sl|=|sr|
#
</code></pre>

<hr>
<h2 id='findiplist'>
The Extremum Surface Estimator (ESE) and Extremum Distance Estimator (EDE) methods for finding the inflection point of a convex/concave curve.
</h2><span id='topic+findiplist'></span>

<h3>Description</h3>

<p>Given the <code class="reqn">(x_{i},y_{i}),i=1,...,N</code> noisy or not data we want to estimate the inflection point of the corresponding curve.
The curve can be convex before the inflection point and then concave or vice versa.
The ESE and EDE methods are applied and the results are returned as a matrix.
Parallel computing is applied under request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findiplist(x, y, index, doparallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findiplist_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="findiplist_+3A_y">y</code></td>
<td>

<p>The numeric vector of the noisy or not y-ordinates, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="findiplist_+3A_index">index</code></td>
<td>

<p>If data is convex/concave then index=0 <br />
If data is concave/convex then index=1
</p>
</td></tr>
<tr><td><code id="findiplist_+3A_doparallel">doparallel</code></td>
<td>

<p>If doparallel=TRUE then parallel computing is applied, based on the available workers of current machine (default value = FALSE)    
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is from an unknown function and without error then we can find the inflection point in a way similar to that of bisection method' s way for a root.
If data is noisy, then we have two consistent estimators of the inflection point.
</p>


<h3>Value</h3>

<p>A matrix of size 2 x 3 is returned with elements:
</p>
<table>
<tr><td><code>A(1</code>, <code>1)</code></td>
<td>
<p>The index j-right for ESE method</p>
</td></tr>
<tr><td><code>A(1</code>, <code>2)</code></td>
<td>
<p>The index j-left for ESE method</p>
</td></tr>
<tr><td><code>A(1</code>, <code>3)</code></td>
<td>
<p>The Extremum Surface Estimator (ESE) for inflection point</p>
</td></tr>
<tr><td><code>A(2</code>, <code>1)</code></td>
<td>
<p>The index j1 for EDE method</p>
</td></tr>
<tr><td><code>A(2</code>, <code>2)</code></td>
<td>
<p>The index j2 for EDE method</p>
</td></tr>
<tr><td><code>A(2</code>, <code>3)</code></td>
<td>
<p>The Extremum Distance Estimator (EDE) for inflection point, if this method is applicable</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is a simple implementation of both ESE and EDE methods to a data set of at least 4 xy-pairs.
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1]Demetris T. Christopoulos (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]. <a href="https://arxiv.org/pdf/1206.5478v2.pdf">https://arxiv.org/pdf/1206.5478v2.pdf</a> <br />
</p>
<p>[2]Demetris T. Christopoulos (2016). On the efficient identification of an inflection point.International Journal of Mathematics and Scientific Computing, (ISSN: 2231-5330), vol. 6(1). <a href="https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf">https://veltech.edu.in/wp-content/uploads/2016/04/Paper-04-2016.pdf</a> 
</p>


<h3>See Also</h3>

<p>See also the simple versions <code><a href="#topic+ese">ese</a></code> and <code><a href="#topic+ede">ede</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Lets create some convex/concave data based on the Fisher-Pry model
#by using 1001 not equal spaced abscissas with data right asymmetry
N=1001;
#Case I: data without noise
set.seed(2017-05-11);x=sort(runif(N,0,15));y=5+5*tanh(x-5);
A=findiplist(x,y,0);A;
#      j1  j2      chi
# ESE 242 438 4.848448
# EDE 228 478 5.000907
plot(x,y,type="l",xaxt="n",lwd=2);axis(1,at=seq(0,15));
abline(v=A[,3],col=c("blue","red"))
text(A[1,3]-0.5,0,expression(chi[S]),font=2);
text(A[2,3]+0.5,0,expression(chi[D]),font=2);
grid();
#
###Case II: noisy data
set.seed(2017-05-11);x=sort(runif(N,0,15));y=5+5*tanh(x-5)+rnorm(N,0,0.05);
A=findiplist(x,y,0);A;
#      j1  j2      chi
# ESE 245 437 4.853798
# EDE 245 469 5.030581
plot(x,y,type="l",xaxt="n",lwd=2);axis(1,at=seq(0,15));
abline(v=A[,3],col=c("blue","red"))
text(A[1,3]-0.5,0,expression(chi[S]),font=2);
text(A[2,3]+0.5,0,expression(chi[D]),font=2);
grid();
#
</code></pre>

<hr>
<h2 id='lin2'>Linear function defined from two planar points (x1,y1) and (x2,y2)
</h2><span id='topic+lin2'></span>

<h3>Description</h3>

<p>It gives the value of the linear function defined from two points (x1,y1) and (x2,y2) at any x 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin2(x1, y1, x2, y2, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin2_+3A_x1">x1</code></td>
<td>
<p>the x - abscissa of the first point
</p>
</td></tr>
<tr><td><code id="lin2_+3A_y1">y1</code></td>
<td>
<p>the y - ordinate of the first point
</p>
</td></tr>
<tr><td><code id="lin2_+3A_x2">x2</code></td>
<td>
<p>the x - abscissa of the second point
</p>
</td></tr>
<tr><td><code id="lin2_+3A_y2">y2</code></td>
<td>
<p>the y - ordinate of the second point
</p>
</td></tr>
<tr><td><code id="lin2_+3A_x">x</code></td>
<td>
<p>the x - point where we compute the value of the linear function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the value of the linear function from (x1,y1) to (x2,y2) at an arbitrary x. 
</p>


<h3>Note</h3>

<p>The value of a linear function is built by this way for R to be faster than a two-vectors call.
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;-1
y1&lt;-3
x2&lt;-5
y2&lt;-7
x&lt;-10
ylin&lt;-lin2(x1,y1,x2,y2,x)
print(ylin)
</code></pre>

<hr>
<h2 id='table_01'>
Fisher-Pry sigmoid with total symmetry and no error
</h2><span id='topic+table_01'></span>

<h3>Description</h3>

<p>Data used for creating Table 1 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_01")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Table 1: Fisher-Pry sigmoid, p=5, total symmetry, n=500, no-error
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_01")
dh=table_01
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0) 
</code></pre>

<hr>
<h2 id='table_02'>
Fisher-Pry sigmoid with total symmetry and error ~ U(-0.5,0.05)
</h2><span id='topic+table_02'></span>

<h3>Description</h3>

<p>Data used for creating Table 2 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_02")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Fisher-Pry sigmoid, p=5, data symmetry, [a, b] = [2, 8], n=500, error r=0.05
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_02")
dh=table_02
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0) 
</code></pre>

<hr>
<h2 id='table_03_04'>
Fisher-Pry sigmoid with data left asymmetry and no error
</h2><span id='topic+table_03_04'></span>

<h3>Description</h3>

<p>Data used for creating Table 3 and 4 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_03_04")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Table 3: Fisher-Pry sigmoid, p=5, data left symmetry, [a, b] = [4.2, 8], n=500, no error
</p>
<p>Table 4: ESE &amp; EDE iterations for Fisher-Pry sigmoid, p=5, data left asymmetry, [a, b] = [4.2, 8], n=500, no-error
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_03_04")
dh=table_03_04
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0)
bese(dh$x,dh$y,0)
bede(dh$x,dh$y,0)
</code></pre>

<hr>
<h2 id='table_05_06'>
Fisher-Pry sigmoid with data left asymmetry and no error ~ U(-0.05,0.05)
</h2><span id='topic+table_05_06'></span>

<h3>Description</h3>

<p>Data used for creating Table 5 and 6 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_05_06")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Table 5: Fisher-Pry sigmoid, p=5, data left symmetry, [a, b] = [4.2, 8], n=500, error r=0.05
</p>
<p>Table 6: ESE &amp; EDE iterations for Fisher-Pry sigmoid, p=5, data left asymmetry, [a, b] = [4.2, 8], n=500, error r=0.05
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_05_06")
dh=table_05_06
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0)
bese(dh$x,dh$y,0)
bede(dh$x,dh$y,0)
</code></pre>

<hr>
<h2 id='table_08_09'>
Gompertz non-symmetric sigmoid with no error
</h2><span id='topic+table_08_09'></span>

<h3>Description</h3>

<p>Data used for creating Table 8 and 9 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_08_09")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Table 8: Gompertz sigmoid, p=5, asymmetry, n=500, no-error
</p>
<p>Table 9: ESE &amp; EDE iterations for Gompertz sigmoid, p=5, asymmetry, [a, b] = [3.5, 8], n=500, no error
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_08_09")
dh=table_08_09
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0)
bese(dh$x,dh$y,0)
bede(dh$x,dh$y,0)
</code></pre>

<hr>
<h2 id='table_10_11'>
Gompertz non-symmetric sigmoid with error ~ U(-0.05,0.05)
</h2><span id='topic+table_10_11'></span>

<h3>Description</h3>

<p>Data used for creating Table 10 and 11 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_10_11")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Table 10: Gompertz sigmoid, p=5, asymmetry, [a, b] = [3.5, 8], n=500, error r=0.05
</p>
<p>Table 11: ESE &amp; EDE iterations for Gompertz sigmoid, p=5, asymmetry, [a, b] = [3.5, 8], n=500, error r=0.05
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_10_11")
dh=table_10_11
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0)
bese(dh$x,dh$y,0)
bede(dh$x,dh$y,0)
</code></pre>

<hr>
<h2 id='table_13'>
A 3rd order polynomial with total symmetry and no error
</h2><span id='topic+table_13'></span>

<h3>Description</h3>

<p>Data used for creating Table 13 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_13")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Table 13: 3rd order polynomial, total symmetry, p=2.5, n=500, no-error
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_13")
dh=table_13
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0)
bese(dh$x,dh$y,0)
bede(dh$x,dh$y,0)
</code></pre>

<hr>
<h2 id='table_14_15'>
A 3rd order polynomial with total symmetry and error ~ U(-2,2)
</h2><span id='topic+table_14_15'></span>

<h3>Description</h3>

<p>Data used for creating Table 14 and 15 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_14_15")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Table 14: Symmetric 3rd order polynomial, total symmetry, p=2.5, n=500, error r=2.0
</p>
<p>Table 15: ESE iterations for 3rd order polynomial, p=2.5, total symmetry, n=500, error r=2.0
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_14_15")
dh=table_14_15
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0)
bese(dh$x,dh$y,0)
</code></pre>

<hr>
<h2 id='table_17_18'>
A 3rd order polynomial with data right symmetry and no error
</h2><span id='topic+table_17_18'></span>

<h3>Description</h3>

<p>Data used for creating Table 17 and 18 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_17_18")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Table 17: Symmetric 3rd order polynomial, data right asymmetry, p=2.5, n=500, [-2, 8], no-error
</p>
<p>Table 18: ESE &amp; EDE iterations for 3rd order polynomial, p=5, p=2.5, n=500, [-2, 8], no-error
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_17_18")
dh=table_17_18
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0)
bese(dh$x,dh$y,0)
bede(dh$x,dh$y,0)
</code></pre>

<hr>
<h2 id='table_19_20'>
A 3rd order polynomial with data right symmetry and error ~ U(-2,2)
</h2><span id='topic+table_19_20'></span>

<h3>Description</h3>

<p>Data used for creating Table 19 and 20 of arXiv:1206.5478v2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("table_19_20")</code></pre>


<h3>Format</h3>

<p>A data frame with 501 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Table 19: Symmetric 3rd order polynomial, data right asymmetry, p=2.5, n=500, [-2, 8], error r=2.0
</p>
<p>Table 20: ESE &amp; EDE iterations for 3rd order polynomial, p=2.5, n=500, [-2, 8], error r=2.0
</p>


<h3>References</h3>

<p>Christopoulos, DT (2014). Developing methods for identifying the inflection point of a convex/concave curve. arXiv:1206.5478v2 [math.NA]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("table_19_20")
dh=table_19_20
plot(dh,pch=19,cex=0.1)
findiplist(dh$x,dh$y,0)
bese(dh$x,dh$y,0)
bede(dh$x,dh$y,0)
</code></pre>

<hr>
<h2 id='uik'>
Implementation of Unit Invariant Knee (UIK) method for finding the knee point of a curve
</h2><span id='topic+uik'></span>

<h3>Description</h3>

<p>It finds the UIK estimation for elbow or knee point of a curve, see [1] for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uik(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uik_+3A_x">x</code></td>
<td>

<p>The numeric vector of x-abscissas, must be of length at least 4.
</p>
</td></tr>
<tr><td><code id="uik_+3A_y">y</code></td>
<td>

<p>The numeric vector of y-abscissas, must be of length at least 4.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the x, y numeric vectors it first checks the curve by using <code><a href="#topic+check_curve">check_curve</a></code>
and classifies it as convex, concave or convex/concave, concave/convex.
</p>


<h3>Value</h3>

<p>It returns the x-abscissa which is the UIK estimation for the knee point.
</p>


<h3>Author(s)</h3>

<p>Demetris T. Christopoulos
</p>


<h3>References</h3>

<p>[1] Christopoulos, Demetris T., Introducing Unit Invariant Knee (UIK) As an Objective Choice 
for Elbow Point in Multivariate Data Analysis Techniques (March 1, 2016).
Available at SSRN: https://ssrn.com/abstract=3043076 or http://dx.doi.org/10.2139/ssrn.3043076
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_curve">check_curve</a></code> and <code><a href="#topic+d2uik">d2uik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Lets create a convex data set
x=seq(1,10,0.05)
y=1/x
plot(x,y)
knee=uik(x,y)
knee
## [1] 3.15
abline(v=knee)
## Lets add noise to them now
set.seed(20190625)
x=seq(1,10,0.05)
y=1/x+runif(length(x),-0.02,0.02)
plot(x,y)
knee=uik(x,y)
knee
## [1] 3.3
abline(v=knee)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
