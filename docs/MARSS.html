<!DOCTYPE html><html><head><title>Help for package MARSS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MARSS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MARSS-package'>
<p>Multivariate Autoregressive State-Space Model Estimation</p></a></li>
<li><a href='#accuracy'><p>Return accuracy metrics</p></a></li>
<li><a href='#allowed'><p> MARSS Function Defaults and Allowed Methods</p></a></li>
<li><a href='#checkMARSSInputs'><p> Check inputs to MARSS call</p></a></li>
<li><a href='#checkModelList'><p> Check model List Passed into MARSS Call</p></a></li>
<li><a href='#coef.marssMLE'><p> Coefficient function for MARSS MLE objects</p></a></li>
<li><a href='#CSEGriskfigure'><p> Plot Extinction Risk Metrics</p></a></li>
<li><a href='#CSEGtmufigure'><p> Plot Forecast Uncertainty</p></a></li>
<li><a href='#datasets'><p> Example Data Sets</p></a></li>
<li><a href='#describe.marssMODEL'><p> Describe a marssMODEL Objects</p></a></li>
<li><a href='#fitted.marssMLE'><p>Return fitted values for X(t) and Y(t) in a MARSS model</p></a></li>
<li><a href='#forecast.marssMLE'><p> forecast function for marssMLE objects</p></a></li>
<li><a href='#glance'><p>Return brief summary information on a MARSS fit</p></a></li>
<li><a href='#harborSeal'><p> Harbor Seal Population Count Data (Log counts)</p></a></li>
<li><a href='#is.marssMLE'><p> Tests marssMLE object for completeness</p></a></li>
<li><a href='#is.marssMODEL'><p> Test Model Objects</p></a></li>
<li><a href='#isleRoyal'><p> Isle Royale Wolf and Moose Data</p></a></li>
<li><a href='#ldiag'><p> Return a diagonal list matrix</p></a></li>
<li><a href='#loggerhead'><p> Loggerhead Turtle Tracking Data</p></a></li>
<li><a href='#logLik.marssMLE'><p> logLik method for MARSS MLE objects</p></a></li>
<li><a href='#MARSS'><p> Fit a MARSS Model via Maximum-Likelihood Estimation</p></a></li>
<li><a href='#marss.conversion'><p> Convert Model Objects between Forms</p></a></li>
<li><a href='#MARSS.dfa'><p> Multivariate Dynamic Factor Analysis</p></a></li>
<li><a href='#MARSS.marss'><p> Multivariate AR-1 State-space Model</p></a></li>
<li><a href='#MARSS.marxss'><p> Multivariate AR-1 State-space Model with Inputs</p></a></li>
<li><a href='#MARSS.vectorized'><p> Vectorized Multivariate AR-1 State-space Model</p></a></li>
<li><a href='#MARSSaic'><p> AIC for MARSS Models</p></a></li>
<li><a href='#MARSSapplynames'><p> Names for marssMLE Object Components</p></a></li>
<li><a href='#MARSSboot'><p> Bootstrap MARSS Parameter Estimates</p></a></li>
<li><a href='#MARSScv'><p>MARSScv is a wrapper for MARSS that re-fits the model with cross validated data.</p></a></li>
<li><a href='#MARSSFisherI'><p> Observed Fisher Information Matrix at the MLE</p></a></li>
<li><a href='#MARSSfit'><p>Generic for fitting MARSS models</p></a></li>
<li><a href='#MARSSharveyobsFI'><p> Hessian Matrix via the Harvey (1989) Recursion</p></a></li>
<li><a href='#MARSShatyt'><p> Compute Expected Value of Y, YY, and YX</p></a></li>
<li><a href='#MARSShessian'><p> Parameter Variance-Covariance Matrix from the Hessian Matrix</p></a></li>
<li><a href='#MARSShessian.numerical'><p> Hessian Matrix via Numerical Approximation</p></a></li>
<li><a href='#MARSSinfo'><p> MARSS Error Messages and Warnings</p></a></li>
<li><a href='#MARSSinits'><p> Initial Values for MLE</p></a></li>
<li><a href='#MARSSinnovationsboot'><p> Bootstrapped Data using Stoffer and Wall's Algorithm</p></a></li>
<li><a href='#MARSSkem'><p> EM Algorithm function for MARSS models</p></a></li>
<li><a href='#MARSSkemcheck'><p> Model Checking for MLE objects Passed to MARSSkem</p></a></li>
<li><a href='#MARSSkf'><p> Kalman Filtering and Smoothing</p></a></li>
<li><a href='#marssMLE-class'><p>Class &quot;marssMLE&quot;</p></a></li>
<li><a href='#marssMODEL-class'><p>Class &quot;marssMODEL&quot;</p></a></li>
<li><a href='#MARSSoptim'><p>Parameter estimation for MARSS models using optim</p></a></li>
<li><a href='#MARSSparamCIs'><p> Standard Errors, Confidence Intervals and Bias for MARSS Parameters</p></a></li>
<li><a href='#marssPredict-class'><p>Class &quot;marssPredict&quot;</p></a></li>
<li><a href='#MARSSresiduals'><p> MARSS Residuals</p></a></li>
<li><a href='#marssResiduals-class'><p>Class &quot;marssResiduals&quot;</p></a></li>
<li><a href='#MARSSresiduals.tt'><p> MARSS Contemporaneous Residuals</p></a></li>
<li><a href='#MARSSresiduals.tT'><p> MARSS Smoothed Residuals</p></a></li>
<li><a href='#MARSSresiduals.tt1'><p> MARSS One-Step-Ahead Residuals</p></a></li>
<li><a href='#MARSSsimulate'><p> Simulate Data from a MARSS Model</p></a></li>
<li><a href='#MARSSvectorizeparam'><p> Vectorize or Replace the par List</p></a></li>
<li><a href='#match.arg.exact'><p> match.arg with exact matching</p></a></li>
<li><a href='#model.frame.marssMODEL'><p> model.frame method for marssMLE and marssMODEL objects</p></a></li>
<li><a href='#plankton'><p> Plankton Data Sets</p></a></li>
<li><a href='#plot.marssMLE'><p> Plot MARSS MLE objects</p></a></li>
<li><a href='#plot.marssPredict'><p> Plot MARSS Forecast and Predict objects</p></a></li>
<li><a href='#plot.marssResiduals'><p> Plot MARSS marssResiduals objects</p></a></li>
<li><a href='#population-count-data'><p> Population Data Sets</p></a></li>
<li><a href='#predict'><p> predict and forecast MARSS MLE objects</p></a></li>
<li><a href='#predict.marssMLE'><p> predict and forecast MARSS MLE objects</p></a></li>
<li><a href='#print.marssMLE'><p> Printing functions for MARSS MLE objects</p></a></li>
<li><a href='#print.marssMODEL'><p> Printing marssMODEL Objects</p></a></li>
<li><a href='#print.marssPredict'><p> Printing function for MARSS Predict objects</p></a></li>
<li><a href='#residuals.marssMLE'><p>Model and state fitted values, residuals, and residual sigma</p></a></li>
<li><a href='#SalmonSurvCUI'><p> Salmon Survival Indices</p></a></li>
<li><a href='#stdInnov'><p> Standardized Innovations</p></a></li>
<li><a href='#summary.marssMLE'><p> Summary methods for marssMLE objects</p></a></li>
<li><a href='#sysdata'><p> Palettes</p></a></li>
<li><a href='#tidy.marssMLE'><p>Return estimated parameters with summary information</p></a></li>
<li><a href='#toLatex.marssMODEL'><p> Create a LaTeX Version of the Model</p></a></li>
<li><a href='#tsSmooth.marssMLE'><p> Smoothed and filtered x and y time series</p></a></li>
<li><a href='#utility.functions'><p> Utility Functions</p></a></li>
<li><a href='#zscore'><p> z-score a vector or matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Autoregressive State-Space Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>3.11.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-19</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>generics (&ge; 0.1.2), graphics, grDevices, KFAS (&ge; 1.0.1),
mvtnorm, nlme, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>forecast, ggplot2, Hmisc, knitr, marssTMB</td>
</tr>
<tr>
<td>Description:</td>
<td>The MARSS package provides maximum-likelihood parameter
    estimation for constrained and unconstrained linear multivariate autoregressive
    state-space (MARSS) models, including partially deterministic models. MARSS models are a class 
    of dynamic linear model (DLM) and vector autoregressive model (VAR)
    model. Fitting available via Expectation-Maximization (EM), BFGS (using optim), and 'TMB'
    (using the 'marssTMB' companion package). Functions are provided for parametric and 
    innovations bootstrapping, Kalman filtering and smoothing, model selection criteria including
    bootstrap AICb, confidences intervals via the Hessian approximation or bootstrapping, and all
    conditional residual types. See the user guide for examples of dynamic factor analysis, 
    dynamic linear models, outlier and shock detection, and multivariate AR-p models.  
    Online workshops (lectures, eBook, and computer labs) 
    at <a href="https://atsa-es.github.io/">https://atsa-es.github.io/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://atsa-es.github.io/MARSS/">https://atsa-es.github.io/MARSS/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/atsa-es/MARSS/issues">https://github.com/atsa-es/MARSS/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, utils</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://atsa-es.r-universe.dev">https://atsa-es.r-universe.dev</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-19 06:49:03 UTC; eli.holmes</td>
</tr>
<tr>
<td>Author:</td>
<td>Elizabeth Eli Holmes
    <a href="https://orcid.org/0000-0001-9128-8393"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Eric J. Ward <a href="https://orcid.org/0000-0002-4359-0296"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Mark D. Scheuerell
    <a href="https://orcid.org/0000-0002-8284-1254"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Kellie Wills [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elizabeth Eli Holmes &lt;eli.holmes@noaa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-19 08:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='MARSS-package'>
Multivariate Autoregressive State-Space Model Estimation
</h2><span id='topic+MARSS-package'></span>

<h3>Description</h3>

<p>The MARSS package fits time-varying constrained and unconstrained multivariate autoregressive time-series models to multivariate time series data.  To get started quickly, go to the <a href="https://cran.r-project.org/package=MARSS/vignettes/Quick_Start.html">Quick Start Guide</a> (or at the command line, you can type <code>RShowDoc("Quick_Start", package="MARSS")</code>). To open the MARSS User Guide with many vignettes and examples, go to <a href="https://cran.r-project.org/package=MARSS/vignettes/UserGuide.pdf">User Guide</a> (or type <code>RShowDoc("UserGuide",package="MARSS")</code>).  
</p>
<p>The default MARSS model form is a MARXSS model: Multivariate Auto-Regressive(1) eXogenous inputs State-Space model. This model has the following form:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x}_{t} = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{C} \mathbf{c}_{t} + \mathbf{G} \mathbf{w}_t, \textrm{ where } \mathbf{W}_t \sim \textrm{MVN}(0,\mathbf{Q})</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}(t) + \mathbf{a} + \mathbf{D} \mathbf{d}_t + \mathbf{H} \mathbf{v}_t, \textrm{ where } \mathbf{V}_t \sim \textrm{MVN}(0,\mathbf{R})</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{X}_1 \sim \textrm{MVN}(\mathbf{x0}, \mathbf{V0}) \textrm{ or } \mathbf{X}_0 \sim \textrm{MVN}(\mathbf{x0}, \mathbf{V0}) </code>
</p>

<p>All parameters can be time-varying; the <code class="reqn">t</code> subscript is left off the parameters to remove clutter. Note, by default <code class="reqn">\mathbf{V0}</code> is a matrix of all zeros and thus <code class="reqn">\mathbf{x}_1</code> or <code class="reqn">\mathbf{x}_0</code> is treated as an estimated parameter not a diffuse prior.
</p>
<p>The parameter matrices can have fixed values and linear constraints. This is an example of a 3x3 matrix with fixed values and linear constraints. In this example all the matrix elements can be written as a linear function of <code class="reqn">a</code>, <code class="reqn">b</code>, and <code class="reqn">c</code>:
</p>
<p style="text-align: center;"><code class="reqn">\left[\begin{array}{c c c} a+2b &amp; 1 &amp; a\\ 1+3a+b &amp; 0 &amp; b \\ 0 &amp; -2 &amp; c\end{array}\right]</code>
</p>

<p>Values such as <code class="reqn">a b</code> or <code class="reqn">a^2</code> or <code class="reqn">ln(a)</code> are not allowed as those would not be linear.
</p>
<p>The MARSS model parameters, hidden state processes (<code class="reqn">\mathbf{x}</code>), and observations (<code class="reqn">\mathbf{y}</code>) are matrices:
</p>

<ul>
<li> <p><code class="reqn">\mathbf{x}_t</code>, <code class="reqn">\mathbf{x0}</code>, and <code class="reqn">\mathbf{u}</code> are m x 1 
</p>
</li>
<li> <p><code class="reqn">\mathbf{y}_t</code> and <code class="reqn">\mathbf{a}</code> are n x 1 (m&lt;=n)
</p>
</li>
<li> <p><code class="reqn">\mathbf{B}</code> and <code class="reqn">\mathbf{V0}</code> are m x m 
</p>
</li>
<li> <p><code class="reqn">\mathbf{Z}</code> is n x m 
</p>
</li>
<li> <p><code class="reqn">\mathbf{Q}</code> is g x g (default m x m) 
</p>
</li>
<li> <p><code class="reqn">\mathbf{G}</code> is m x g (default m x m identity matrix)
</p>
</li>
<li> <p><code class="reqn">\mathbf{R}</code> is h x h (default n x n)
</p>
</li>
<li> <p><code class="reqn">\mathbf{H}</code> is n x h (default n x n identity matrix)
</p>
</li>
<li> <p><code class="reqn">\mathbf{C}</code> is m x q
</p>
</li>
<li> <p><code class="reqn">\mathbf{D}</code> is n x p
</p>
</li>
<li> <p><code class="reqn">\mathbf{c}_t</code> is q x 1
</p>
</li>
<li> <p><code class="reqn">\mathbf{d}_t</code> is p x 1
</p>
</li></ul>

<p>If a parameter is time-varying then the time dimension is the 3rd dimension. Thus a time-varying <code class="reqn">\mathbf{Z}</code> would be n x m x T where T is the length of the data time series.
</p>
<p>The main fitting function is <code><a href="#topic+MARSS">MARSS</a>()</code> which is used to fit a specified model to data and estimate the model parameters.  <code><a href="#topic+MARSS">MARSS</a>()</code> estimates the model parameters using an EM algorithm (primarily but see <code><a href="#topic+MARSSoptim">MARSSoptim</a>()</code>).  Functions are provided for parameter confidence intervals and the observed Fisher Information matrix, smoothed state estimates with confidence intervals, all the Kalman filter and smoother outputs, residuals and residual diagnostics, printing and plotting, and summaries.
</p>


<h3>Details</h3>

<p><strong>Main MARSS functions</strong>:
</p>

<dl>
<dt><code><a href="#topic+MARSS">MARSS</a>()</code></dt><dd><p> Top-level function for specifying and fitting MARSS models. </p>
</dd> 
<dt><code><a href="#topic+coef.marssMLE">coef</a>()</code></dt><dd><p> Returns the estimated parameters in a variety of formats. </p>
</dd>    
<dt><code><a href="#topic+tidy.marssMLE">tidy</a>()</code></dt><dd><p> Parameter estimates with confidence intervals </p>
</dd> 
<dt><code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code></dt><dd> <p><code class="reqn">\mathbf{x}</code> and <code class="reqn">\mathbf{y}</code> estimates output as a data frame. Output can be conditioned on all the data (<code class="reqn">T</code>), data up to <code class="reqn">t-1</code>, or data up to <code class="reqn">t</code>. From the Kalman filter and smoother output. </p>
</dd> 
<dt><code><a href="#topic+fitted.marssMLE">fitted</a>()</code></dt><dd><p> Model x<code class="reqn">\mathbf{x}</code> and <code class="reqn">\mathbf{y}</code> predictions as a data frame or matrices. Another user interface for model predictions is <code>predict.marssMLE</code>. </p>
</dd> 
<dt><code><a href="#topic+residuals.marssMLE">residuals</a>()</code></dt><dd><p> Model residuals as a data frame. </p>
</dd> 
<dt><code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code></dt><dd><p> Model residuals as a data frame or matrices. Normal user interface to residuals is <code>residuals.marssMLE</code>.</p>
</dd> 
<dt><code><a href="#topic+predict.marssMLE">predict</a>()</code></dt><dd><p> Predictions and forecasts from a <code><a href="#topic+marssMLE">marssMLE</a></code> object. </p>
</dd> 
<dt><code><a href="#topic+plot.marssMLE">plot for marssMLE</a></code> </dt><dd><p> A series of plots of fits and residuals diagnostics. </p>
</dd> 
<dt><code><a href="#topic+autoplot.marssMLE">autoplot</a>()</code> </dt><dd><p> A series of plots using ggplot2 of fits and residuals diagnostics. </p>
</dd> 
<dt><code><a href="#topic+glance.marssMLE">glance</a>()</code></dt><dd><p> Brief summary of fit. </p>
</dd> 
<dt><code><a href="#topic+logLik.marssMLE">logLik</a>()</code></dt><dd><p> Log-likelihood. </p>
</dd>
<dt><code><a href="#topic+print.marssMLE">print</a>()</code></dt><dd><p> Prints a wide variety of output from a <code><a href="#topic+marssMLE">marssMLE</a></code> object. </p>
</dd>
<dt><code><a href="#topic+print.marssMODEL">print.marssMODEL</a>()</code></dt><dd><p> Prints description of the MARSS model (<code><a href="#topic+marssMODEL">marssMODEL</a></code> object). </p>
</dd>
<dt><code><a href="#topic+plot.marssPredict">plot.marssPredict</a>()</code></dt><dd><p> Plot a prediction or forecast. </p>
</dd> 
<dt><code><a href="#topic+toLatex.marssMODEL">toLatex.marssMODEL</a>()</code></dt><dd><p> Outputs a LaTeX version of the model. </p>
</dd>
</dl>

<p><strong>Other outputs for a fitted model</strong>:
</p>

<dl>
<dt><code><a href="#topic+MARSSsimulate">MARSSsimulate</a>()</code></dt><dd><p> Produces simulated data from a MARSS model. </p>
</dd> 
<dt><code><a href="#topic+MARSSkf">MARSSkf</a>()</code>, <code><a href="#topic+MARSSkfas">MARSSkfas</a>()</code>, <code><a href="#topic+MARSSkfss">MARSSkfss</a>()</code> </dt><dd><p> Kalman filters and smoothers with extensive output of all the intermediate filter and smoother variances and expectations. </p>
</dd> 
<dt><code><a href="#topic+MARSSaic">MARSSaic</a>()</code></dt><dd><p> Calculates AICc, AICc, and various bootstrap AICs. </p>
</dd> 
<dt><code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code></dt><dd><p> Adds confidence intervals to a <code><a href="#topic+marssMLE">marssMLE</a></code> object. </p>
</dd>
<dt><code><a href="#topic+MARSShessian">MARSShessian</a>()</code></dt><dd><p> Computes an estimate of the variance-covariance matrix for the MLE parameters. </p>
</dd>    
<dt><code><a href="#topic+MARSSFisherI">MARSSFisherI</a>()</code></dt><dd><p> Returns the observed Fisher Information matrix. </p>
</dd>    
</dl>

<p><strong>Important internal MARSS functions (called by the above functions)</strong>:
</p>

<dl>
<dt><code><a href="#topic+MARSSkem">MARSSkem</a>()</code></dt><dd><p> Estimates MARSS parameters using an EM algorithm. </p>
</dd> 
<dt><code><a href="#topic+MARSSoptim">MARSSoptim</a>()</code></dt><dd><p> Estimates MARSS parameters using a quasi-Newton algorithm via <code><a href="stats.html#topic+optim">optim</a></code>. </p>
</dd> 
<dt><code><a href="#topic+MARSShatyt">MARSShatyt</a>()</code></dt><dd><p> Calculates the expectations involving Y. </p>
</dd> 
<dt><code><a href="#topic+MARSSinnovationsboot">MARSSinnovationsboot</a>()</code></dt><dd><p> Creates innovations bootstrapped data. </p>
</dd>
<dt><code><a href="#topic+MARSS.marss">MARSS.marss</a>()</code></dt><dd><p> Discusses the form in which MARSS models are stored internally. </p>
</dd>
</dl>

<p>Use <code>help.search("internal", package="MARSS")</code> to see the documentation of all the internal functions in the MARSS R package.
</p>


<h3>Author(s)</h3>

<p>Eli Holmes, Eric Ward and Kellie Wills, NOAA, Seattle, USA.
</p>


<h3>References</h3>

<p>The MARSS User Guide:  Holmes, E. E., E. J. Ward, and M. D. Scheuerell (2012) Analysis of multivariate time-series using the MARSS package. NOAA Fisheries, Northwest Fisheries Science
Center, 2725 Montlake Blvd E., Seattle, WA 98112   <a href="https://cran.r-project.org/package=MARSS/vignettes/UserGuide.pdf">User Guide</a> or type <code>RShowDoc("UserGuide",package="MARSS")</code> to open a copy.
</p>
<p>The MARSS Quick Start Guide:  <a href="https://cran.r-project.org/package=MARSS/vignettes/Quick_Start.html">Quick Start Guide</a> or type <code>RShowDoc("Quick_Start",package="MARSS")</code> to open a copy.
</p>

<hr>
<h2 id='accuracy'>Return accuracy metrics</h2><span id='topic+accuracy'></span><span id='topic+accuracy.marssPredict'></span><span id='topic+accuracy.marssMLE'></span>

<h3>Description</h3>

<p>This is a method for the generic <code>accuracy</code> function in the generics package. It is written to mimic the output from the accuracy function in the forecast package. See that package for details.
</p>
<p>The measures calculated are:
</p>

<ul>
<li><p> ME: Mean Error
</p>
</li>
<li><p> RMSE: Root Mean Squared Error
</p>
</li>
<li><p> MAE: Mean Absolute Error
</p>
</li>
<li><p> MPE: Mean Percentage Error
</p>
</li>
<li><p> MAPE: Mean Absolute Percentage Error
</p>
</li>
<li><p> MASE: Mean Absolute Scaled Error
</p>
</li>
<li><p> ACF1: Autocorrelation of errors at lag 1.
</p>
</li></ul>

<p>The MASE calculation is scaled using MAE of the training set naive
forecasts which are simply <code class="reqn">\mathbf{y}_{t-1}</code>.
</p>
<p>For the training data, the metrics are shown for the one-step-ahead predictions by default (<code>type="ytt1"</code>). This is the prediction of <code class="reqn">\mathbf{y}_t</code> conditioned on the data up to <code class="reqn">t-1</code> (and the model estimated from all the data). With <code>type="ytT"</code>, you can compute the metrics for the fitted <code>ytT</code>, which is the expected value of new data at <code class="reqn">t</code> conditioned on all the data. <code>type</code> does not affect test data (forecasts are past the end of the training data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssPredict'
accuracy(object, x, test = NULL, type = "ytt1", verbose = FALSE, ...)
## S3 method for class 'marssMLE'
accuracy(object, x, test = NULL, type = "ytt1", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+marssMLE">marssMLE</a></code> or <code><a href="#topic+marssPredict">marssPredict</a></code> object</p>
</td></tr>
<tr><td><code id="accuracy_+3A_x">x</code></td>
<td>
<p>A matrix or data frame with data to test against the h steps of a forecast.</p>
</td></tr>
<tr><td><code id="accuracy_+3A_test">test</code></td>
<td>
<p>Which time steps in training data (data model fit to) to compute accuracy for.</p>
</td></tr>
<tr><td><code id="accuracy_+3A_type">type</code></td>
<td>
<p>type=&quot;ytt1&quot; is the one-step-ahead predictions. type=&quot;ytT&quot; is the fitted ytT predictions. The former are standardly used for training data prediction metrics.</p>
</td></tr>  
<tr><td><code id="accuracy_+3A_verbose">verbose</code></td>
<td>
<p>Show metrics for each time series of data.</p>
</td></tr>
<tr><td><code id="accuracy_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hyndman, R.J. and Koehler, A.B. (2006) &quot;Another look at measures of forecast accuracy&quot;. International Journal of Forecasting, 22(4), 679-688. 
</p>
<p>Hyndman, R.J. and Athanasopoulos, G. (2018) &quot;Forecasting: principles and practice&quot;, 2nd ed., OTexts, Melbourne, Australia. Section 3.4 &quot;Evaluating forecast accuracy&quot;. <a href="https://otexts.com/fpp2/accuracy.html">https://otexts.com/fpp2/accuracy.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11, 12),]
train.dat &lt;- dat[,1:12]
fit &lt;- MARSS(train.dat, model = list(Z = factor(c("WA", "OR", "OR"))))

accuracy(fit)

# Compare to test data set
fr &lt;- predict(fit, n.ahead=10)
test.dat &lt;- dat[,13:22]
accuracy(fr, x=test.dat)
</code></pre>

<hr>
<h2 id='allowed'> MARSS Function Defaults and Allowed Methods </h2><span id='topic+allowed.methods'></span><span id='topic+kem.methods'></span><span id='topic+optim.methods'></span><span id='topic+alldefaults'></span>

<h3>Description</h3>

<p>Defaults and allowed fitting methods for the <code><a href="#topic+MARSS">MARSS</a>()</code> function are specified in the file <code>onLoad.R</code>. These are hidden package globals that are assigned to the package environment when the library is loaded either via <code>library(MARSS)</code>, <code>require(MARSS)</code> or a call to a MARSS function using <code>MARSS::</code>. 
</p>


<h3>Details</h3>

<p><code>allowed.methods</code> is a vector with the allowed <code>method</code> arguments for the <code><a href="#topic+MARSS">MARSS</a>()</code> function.  <code>kem.methods</code> and <code>optim.methods</code> are vectors of <code>method</code> arguments that fall in each of these two categories; used by <code><a href="#topic+MARSS">MARSS</a>()</code>.  <code>alldefaults</code> is a list that specifies the defaults for <code><a href="#topic+MARSS">MARSS</a>()</code> arguments if they are not passed in.
</p>

<hr>
<h2 id='checkMARSSInputs'> Check inputs to MARSS call </h2><span id='topic+checkMARSSInputs'></span>

<h3>Description</h3>

<p>This is a helper function to check the inputs to a <code><a href="#topic+MARSS">MARSS</a>()</code> call for any errors. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkMARSSInputs( MARSS.inputs, silent = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkMARSSInputs_+3A_marss.inputs">MARSS.inputs</code></td>
<td>
<p> A list comprised of the needed inputs to a MARSS call: 
data, 
inits, 
model,
control,
method,
form) </p>
</td></tr>
<tr><td><code id="checkMARSSInputs_+3A_silent">silent</code></td>
<td>
<p> Suppresses printing of progress bars, error messages, warnings and convergence information. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function to check that all the inputs to a <code><a href="#topic+MARSS">MARSS</a>()</code> function call are properly specified.  
</p>
<p>If arguments <code>inits</code> or <code>control</code> are not provided by the user, they will be set by the <code>alldefaults[[method]]</code> object specified in <code>MARSSsettings</code>.  Argument <code>model</code> specifies the model structure using a list of matrices; see <code><a href="#topic+MARSS">MARSS</a></code> or the <a href="https://cran.r-project.org/package=MARSS/vignettes/UserGuide.pdf">User Guide</a> for instructions on how to specify model structure. If <code>model</code> is left off, then the function <code>MARSS.form()</code> is used to determine the default model structure.
</p>


<h3>Value</h3>

<p>If the function does not stop due to errors, it returns an updated list with elements
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p> Data supplied by user. </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> Not changed.  Will be updated by the <code>MARSS.form</code> function (e.g. <code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code>). </p>
</td></tr>
<tr><td><code>inits</code></td>
<td>
<p> A list specifying initial values for parameters to be used at iteration 1 in iterative maximum-likelihood algorithms. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> The method used for estimation. </p>
</td></tr>
<tr><td><code>form</code></td>
<td>
<p> The equation form used to convert wrapper object to a <code><a href="#topic+marssMODEL">marssMODEL</a></code> object. </p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p> See Arguments. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Kellie Wills, NOAA, Seattle, USA.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+MARSS">MARSS</a>()</code>, <code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+checkModelList">checkModelList</a>()</code> 
</p>

<hr>
<h2 id='checkModelList'> Check model List Passed into MARSS Call </h2><span id='topic+checkModelList'></span>

<h3>Description</h3>

<p>This is a helper function to check the model list passed in to a <code><a href="#topic+MARSS">MARSS</a>()</code> call for any errors. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkModelList( model, defaults, this.form.allows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkModelList_+3A_model">model</code></td>
<td>
<p> A list from which a marssMODEL model will be constructed. </p>
</td></tr>
<tr><td><code id="checkModelList_+3A_defaults">defaults</code></td>
<td>
<p> A list with the defaults for the elements in the model list in case the user leaves out any. </p>
</td></tr>
<tr><td><code id="checkModelList_+3A_this.form.allows">this.form.allows</code></td>
<td>
<p> A list of what inputs are allowed for each element in the model list. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function to check that all the model list that will be passed to a <code>MARSS.form</code> function to make the <code><a href="#topic+marssMODEL">marssMODEL</a></code> object.  If elements in the list are left off, they will be filled in by defaults.
</p>


<h3>Value</h3>

<p>If the function does not stop due to errors, it returns an updated model list with missing elements filled in by the defaults.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+MARSS">MARSS</a>()</code>, <code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+checkModelList">checkModelList</a></code> 
</p>

<hr>
<h2 id='coef.marssMLE'> Coefficient function for MARSS MLE objects </h2><span id='topic+coef.marssMLE'></span>

<h3>Description</h3>

<p><code><a href="#topic+MARSS">MARSS</a>()</code> outputs <code><a href="#topic+marssMLE">marssMLE</a></code> objects.  <code>coef(object)</code>, where <code>object</code> is the output from a <code><a href="#topic+MARSS">MARSS</a>()</code> call, will print out the estimated parameters.  The default output is a list with values for each parameter, however the output can be altered using the <code>type</code> argument to output a vector of all the estimated values (<code>type="vector"</code>) or a list with the full parameter matrix with the estimated and fixed elements (<code>type="matrix"</code>). For a summary of the parameter estimates with CIs from the estimated Hessian, use try <code>tidy(object)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
coef(object, ..., type = "list", form = NULL, what = "par")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.marssMLE_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object.  </p>
</td></tr>
<tr><td><code id="coef.marssMLE_+3A_...">...</code></td>
<td>
<p> Other arguments. Not used. </p>
</td></tr>
<tr><td><code id="coef.marssMLE_+3A_type">type</code></td>
<td>
<p> What to output.  Default is &quot;list&quot;. Options are
</p>

<dl>
<dt> &quot;list&quot; </dt><dd><p> A list of only the estimated values in each matrix. Each model matrix has it's own list element.</p>
</dd>
<dt> &quot;vector&quot; </dt><dd><p> A vector of all the estimated values in each matrix. </p>
</dd>
<dt> &quot;matrix&quot; </dt><dd><p> A list of the parameter matrices each parameter with fixed values at their fixed values and the estimated values at their estimated values. Time-varying parameters, including d and c in a marxss form model, are returned as an array with time in the 3rd dimension. </p>
</dd>
<dt> parameter name </dt><dd><p> Returns the parameter matrix for that parameter with fixed values at their fixed values and the estimated values at their estimated values. Note, time-varying parameters, including d and c in a marxss form model, are returned as an array with time in the 3rd dimension.</p>
</dd>
</dl>
 </td></tr>
<tr><td><code id="coef.marssMLE_+3A_form">form</code></td>
<td>
<p> This argument can be ignored. By default, the model form specified in the call to <code><a href="#topic+MARSS">MARSS</a>()</code> is used to determine how to display the coefficients.  This information is in <code> attr(object$model,"form") </code>.  The default form is <code>"marxss"</code>; see <code><a href="#topic+MARSS.marxss">MARSS.marxss</a>()</code>.  However, the internal functions convert this to form <code>"marss"</code>; see <code><a href="#topic+MARSS.marss">MARSS.marss</a>()</code>. The marss form of the model is stored (in <code>object$marss</code>). You can look at the coefficients in marss form by passing in <code>form="marss"</code>.  </p>
</td></tr>
<tr><td><code id="coef.marssMLE_+3A_what">what</code></td>
<td>
<p> By default, <code>coef()</code> shows the parameter estimates.  Other options are &quot;par.se&quot;, &quot;par.lowCI&quot;, &quot;par.upCI&quot;, &quot;par.bias&quot;, and &quot;start&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the estimated parameters for each model matrix.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy.marssMLE">tidy</a>()</code>, <code><a href="#topic+print.marssMLE">print</a>()</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11), ]
fit &lt;- MARSS(dat)

coef(fit)
coef(fit, type = "vector")
coef(fit, type = "matrix")
# to retrieve just the Q matrix
coef(fit, type = "matrix")$Q
</code></pre>

<hr>
<h2 id='CSEGriskfigure'> Plot Extinction Risk Metrics </h2><span id='topic+CSEGriskfigure'></span>

<h3>Description</h3>

<p>Generates a six-panel plot of extinction risk metrics used in Population Viability Analysis (PVA). This is a function used by one of the vignettes in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSEGriskfigure(data, te = 100, absolutethresh = FALSE, threshold = 0.1, 
  datalogged = FALSE, silent = FALSE, return.model = FALSE, 
  CI.method = "hessian", CI.sim = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSEGriskfigure_+3A_data">data</code></td>
<td>
<p> A data matrix with 2 columns; time in first column and counts in second column. Note time is down rows, which is different than the base <code><a href="#topic+MARSS-package">MARSS-package</a></code> functions.</p>
</td></tr>
<tr><td><code id="CSEGriskfigure_+3A_te">te</code></td>
<td>
<p> Length of forecast period (positive integer) </p>
</td></tr>
<tr><td><code id="CSEGriskfigure_+3A_absolutethresh">absolutethresh</code></td>
<td>
<p> Is extinction threshold an absolute number? (T/F)</p>
</td></tr>
<tr><td><code id="CSEGriskfigure_+3A_threshold">threshold</code></td>
<td>
<p> Extinction threshold either as an absolute number, if <code>absolutethresh=TRUE</code>, or as a fraction of current population count, if <code>absolutethresh=FALSE</code>. </p>
</td></tr>
<tr><td><code id="CSEGriskfigure_+3A_datalogged">datalogged</code></td>
<td>
<p> Are the data already logged? (T/F)</p>
</td></tr>
<tr><td><code id="CSEGriskfigure_+3A_silent">silent</code></td>
<td>
<p> Suppress printed output? (T/F) </p>
</td></tr>
<tr><td><code id="CSEGriskfigure_+3A_return.model">return.model</code></td>
<td>
<p> Return state-space model as <code><a href="#topic+marssMLE">marssMLE</a></code> object? (T/F)</p>
</td></tr>
<tr><td><code id="CSEGriskfigure_+3A_ci.method">CI.method</code></td>
<td>
<p> Confidence interval method: &quot;hessian&quot;, &quot;parametrc&quot;, &quot;innovations&quot;, or &quot;none&quot;. See <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a></code>. </p>
</td></tr>
<tr><td><code id="CSEGriskfigure_+3A_ci.sim">CI.sim</code></td>
<td>
<p> Number of simulations for bootstrap confidence intervals (positive integer). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Panel 1: Time-series plot of the data.
Panel 2: CDF of extinction risk.
Panel 3: PDF of time to reach threshold.
Panel 4: Probability of reaching different thresholds during forecast period.
Panel 5: Sample projections.
Panel 6: TMU plot (uncertainty as a function of the forecast).
</p>


<h3>Value</h3>

<p>If <code>return.model=TRUE</code>, an object of class <code><a href="#topic+marssMLE">marssMLE</a></code>.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA, and Steve Ellner, Cornell Univ. 
</p>


<h3>References</h3>

 
<p>Holmes, E. E., E. J. Ward, and M. D. Scheuerell (2012) Analysis of multivariate time-series using the MARSS package. NOAA Fisheries, Northwest Fisheries Science
Center, 2725 Montlake Blvd E., Seattle, WA 98112   Type <code>RShowDoc("UserGuide",package="MARSS")</code> to open a copy.
</p>
<p>(theory behind the figure) Holmes, E. E., J. L. Sabo, S. V. Viscido, and W. F. Fagan. (2007) A statistical approach to quasi-extinction forecasting. Ecology Letters 10:1182-1198.
</p>
<p>(CDF and PDF calculations) Dennis, B., P. L. Munholland, and J. M. Scott. (1991) Estimation of growth and extinction parameters for endangered species. Ecological Monographs 61:115-143.
</p>
<p>(TMU figure) Ellner, S. P. and E. E. Holmes. (2008) Resolving the debate on when extinction risk is predictable. Ecology Letters 11:E1-E5.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSboot">MARSSboot</a></code>, <code><a href="#topic+marssMLE">marssMLE</a></code>, <code><a href="#topic+CSEGtmufigure">CSEGtmufigure</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- harborSeal[, 1:2]
kem &lt;- CSEGriskfigure(d, datalogged = TRUE)
</code></pre>

<hr>
<h2 id='CSEGtmufigure'> Plot Forecast Uncertainty </h2><span id='topic+CSEGtmufigure'></span>

<h3>Description</h3>

<p>Plot the uncertainty in the probability of hitting a percent threshold (quasi-extinction) for a single random walk trajectory.  This is the quasi-extinction probability used in Population Viability Analysis.  The uncertainty is shown as a function of the forecast, where the forecast is defined in terms of the forecast length (number of time steps) and forecasted decline (percentage).  This is a function used by one of the vignettes in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSEGtmufigure(N = 20, u = -0.1, s2p = 0.01, make.legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSEGtmufigure_+3A_n">N</code></td>
<td>
<p> Time steps between the first and last population data point (positive integer) </p>
</td></tr>
<tr><td><code id="CSEGtmufigure_+3A_u">u</code></td>
<td>
<p> Per time-step decline (-0.1 means a 10% decline per time step; 1 means a doubling per time step.) </p>
</td></tr>
<tr><td><code id="CSEGtmufigure_+3A_s2p">s2p</code></td>
<td>
<p> Process variance (Q). (a positive number)</p>
</td></tr>
<tr><td><code id="CSEGtmufigure_+3A_make.legend">make.legend</code></td>
<td>
<p> Add a legend to the plot? (T/F) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This figure shows the region of high uncertainty in dark grey. In this region, the minimum 95 percent confidence intervals on the probability of quasi-extinction span 80 percent of the 0 to 1 probability. Green hashing indicates where the 95 percent upper bound does not exceed 5% probability of quasi-extinction.  The red hashing indicates, where the 95 percent lower bound is above 95% probability of quasi-extinction. The light grey lies between these two certain/uncertain extremes.   The extinction calculation is based on Dennis et al. (1991). The minimum theoretical confidence interval is based on Fieberg and Ellner (2000).  This figure was developed in Ellner and Holmes (2008).
</p>
<p>Examples using this figure are shown in the <a href="https://cran.r-project.org/package=MARSS/vignettes/UserGuide.pdf">User Guide</a> in the PVA chapter.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA, and Steve Ellner, Cornell Univ.  
</p>


<h3>References</h3>

 
<p>Dennis, B., P. L. Munholland, and J. M. Scott. (1991) Estimation of growth and extinction parameters for endangered species. Ecological Monographs 61:115-143.
</p>
<p>Fieberg, J. and Ellner, S.P. (2000) When is it meaningful to estimate an extinction probability? Ecology, 81, 2040-2047.
</p>
<p>Ellner, S. P. and E. E. Holmes. (2008) Resolving the debate on when extinction risk is predictable. Ecology Letters 11:E1-E5.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CSEGriskfigure">CSEGriskfigure</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>CSEGtmufigure(N = 20, u = -0.1, s2p = 0.01)
</code></pre>

<hr>
<h2 id='datasets'> Example Data Sets </h2><span id='topic+datasets'></span>

<h3>Description</h3>

<p>Example data sets for use in MARSS vignettes for the <code><a href="#topic+MARSS-package">MARSS-package</a></code>. 
</p>

<ul>
<li><p><a href="#topic+plankton">plankton</a> Plankton data sets: Lake WA plankton 32-year time series and Ives et al data from West Long Lake. 
</p>
</li>
<li><p><a href="#topic+SalmonSurvCUI">SalmonSurvCUI</a> Snake River spring/summer chinook survival indices. 
</p>
</li>
<li><p><a href="#topic+isleRoyal">isleRoyal</a> Isle Royale wolf and moose data with temperature and precipitation covariates. 
</p>
</li>
<li><p><a href="#topic+population-count-data">population-count-data</a> A variety of fish, mammal and bird population count data sets. 
</p>
</li>
<li><p><a href="#topic+loggerhead">loggerhead</a> Loggerhead turtle tracking (location) data from ARGOS tags. 
</p>
</li>
<li><p><a href="#topic+harborSeal">harborSeal</a> Harbor seal survey data (haul out counts) from Oregon, Washington and California, USA. 
</p>
</li></ul>


<hr>
<h2 id='describe.marssMODEL'> Describe a marssMODEL Objects </h2><span id='topic+describe.marssMODEL'></span>

<h3>Description</h3>

<p><code>describe.marssMODEL</code> will print out information on the model in short form (e.g. 'diagonal and equal'). It is used by <code><a href="#topic+print.marssMLE">print</a>()</code>. It calls form specific functions: <code>describe_dfa</code>, <code>describe_marss</code>, and <code>describe_marxss</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe.marssMODEL(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe.marssMODEL_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+marssMODEL">marssMODEL</a></code> object.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>describe.marssMODEL(marssMODEL)</code> returns a list with the structure of each parameter matrix in 'English' (e.g. 'diagonal and unequal'). 
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11), ]
MLEobj &lt;- MARSS(dat)

MARSS:::describe.marssMODEL(MLEobj$model)
</code></pre>

<hr>
<h2 id='fitted.marssMLE'>Return fitted values for X(t) and Y(t) in a MARSS model</h2><span id='topic+fitted.marssMLE'></span>

<h3>Description</h3>

<p><code>fitted()</code> returns the different types of fitted values for <code class="reqn">\mathbf{x}_t</code> and <code class="reqn">\mathbf{y}_t</code> in a MARSS model. The fitted values are the expected value of the right side of the MARSS equations without the error terms, thus are the model predictions of <code class="reqn">\mathbf{y}_t</code> or <code class="reqn">\mathbf{x}_t</code>. <code>fitted.marssMLE</code> is a companion function to <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code> which returns the expected value of the right side of the MARSS equations with the error terms (the Kalman filter and smoother output).
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x}_{t} = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{C} \mathbf{c}_t + \mathbf{G} \mathbf{w}_t, \textrm{ where } \mathbf{W}_t \sim \textrm{MVN}(0,\mathbf{Q})</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{D} \mathbf{d}_t + \mathbf{H} \mathbf{v}_t, \textrm{ where } \mathbf{V}_t \sim \textrm{MVN}(0,\mathbf{R})</code>
</p>

<p>The data go from <code class="reqn">t=1</code> to <code class="reqn">t=T</code>. For brevity, the parameter matrices are shown without a time subscript, however all parameters can be time-varying.
</p>
<p>Note that the prediction of <code class="reqn">\mathbf{x}_t</code> conditioned on the data up to time <code class="reqn">t</code> is not provided since that would require the expected value of <code class="reqn">\mathbf{X}_{t}</code> conditioned on data from <code class="reqn">t = 1</code> to <code class="reqn">t+1</code>, which is not output from the Kalman filter or smoother.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
fitted(object, ..., 
    type = c("ytt1", "ytT", "xtT", "ytt", "xtt1"),   
    interval = c("none", "confidence", "prediction"), 
    level = 0.95, 
    output = c("data.frame", "matrix"), 
    fun.kf = c("MARSSkfas", "MARSSkfss"))
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.marssMLE_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object.  </p>
</td></tr>
<tr><td><code id="fitted.marssMLE_+3A_type">type</code></td>
<td>
<p> If <code>type="tT"</code>, then the predictions are conditioned on all the data. If  <code>type="tt"</code>, then the predictions are conditioned on data up to time <code class="reqn">t</code>. If  <code>type="tt1"</code>, the predictions are conditioned on data up to time <code class="reqn">t-1</code>. The latter are also known as one-step-ahead estimates. For <code class="reqn">\mathbf{y}</code>, these are also known as the innovations.</p>
</td></tr>
<tr><td><code id="fitted.marssMLE_+3A_interval">interval</code></td>
<td>
<p> If <code>interval="confidence"</code>, then the standard error and confidence interval of the predicted value is returned. If <code>interval="prediction"</code>, then the standard deviation and prediction interval of new data or states are returned. </p>
</td></tr>
<tr><td><code id="fitted.marssMLE_+3A_level">level</code></td>
<td>
<p> Level for the intervals if <code>interval</code> is not equal to <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="fitted.marssMLE_+3A_output">output</code></td>
<td>
<p> data frame or list of matrices</p>
</td></tr>
<tr><td><code id="fitted.marssMLE_+3A_fun.kf">fun.kf</code></td>
<td>
<p> By default, <code>tsSmooth()</code> will use the Kalman filter/smoother function in <code>object$fun.kf</code> (either <code><a href="#topic+MARSSkfas">MARSSkfas</a>()</code> or <code><a href="#topic+MARSSkfss">MARSSkfss</a>()</code>). You can pass in <code>fun.kf</code> to force a particular Kalman filter/smoother function to be used. </p>
</td></tr>
<tr><td><code id="fitted.marssMLE_+3A_...">...</code></td>
<td>
<p> Not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the state-space literature, the two most commonly used fitted values are <code>"ytt1"</code> and 
<code>"ytT"</code>. The former is the expected value of <code class="reqn">\mathbf{Y}_t</code> conditioned on the data 1 to time <code class="reqn">t-1</code>. These are known as the innovations and they, plus their variance, are used in the calculation of the likelihood of a MARSS model via the innovations form of the likelihood. The latter, <code>"ytT"</code> are the model estimates of the <code class="reqn">\mathbf{y}</code> values using all the data; this is the expected value of <code class="reqn">\mathbf{Z}\mathbf{X}_t+\mathbf{a}+\mathbf{D}\mathbf{d}_t</code> conditioned on the data 1 to <code class="reqn">T</code>. The <code>"xtT"</code> along with <code>"ytT"</code> are used for computing smoothation residuals used in outlier and shock detection. See <code><a href="#topic+MARSSresiduals">MARSSresiduals</a></code>. For completeness, <code>fitted.marssMLE</code> will also return the other possible model predictions with different conditioning on the data (1 to <code class="reqn">t-1</code>, <code class="reqn">t</code>, and <code class="reqn">T</code>), however only <code>type="ytt1"</code> (innovations) and <code>"ytT"</code> and <code>"xtT"</code> (smoothations) are regularly used. Keep in mind that the fitted <code>"xtT"</code> is not the smoothed estimate of <code class="reqn">\mathbf{x}</code> (unlike <code>"ytT"</code>). If you want the smoothed estimate of <code class="reqn">\mathbf{x}</code> (i.e. the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on all the data), you want the Kalman smoother. See <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a></code>.
</p>
<p>Fitted versus estimated values: The fitted states at time <code class="reqn">t</code> are predictions from the estimated state at time <code class="reqn">t-1</code> conditioned on the data: expected value of <code class="reqn">\mathbf{B}\mathbf{X}_{t-1}+\mathbf{u}+\mathbf{C}\mathbf{c}_t</code> conditioned on the data. They are distinguished from the estimated states at time <code class="reqn">t</code> which would includes the conditional expected values of the error terms: <code class="reqn">\textrm{E}[\mathbf{X}_{t}] = \mathbf{B}\mathbf{X}_{t-1}+\mathbf{u}+\mathbf{C}\mathbf{c}_t + \mathbf{w}_t</code>. The latter are returned by the Kalman filter and smoother. Analogously, the fitted observations at time <code class="reqn">t</code> are model predictions from the estimated state at time <code class="reqn">t</code> conditioned on the data: the expected value of the right side of the <code class="reqn">\mathbf{y}</code> equation without the error term. Like with the states, one can also compute the expected value of the observations at time <code class="reqn">t</code> conditioned on the data: the expected value of the right side of the <code class="reqn">\mathbf{y}</code> equation with the error term.  The latter would just be equal to the data if there are no missing data, but when there are missing data, this is what is used to estimate their values. The expected value of states and observations are provided via <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a></code>.
</p>
<p><strong>observation fitted values</strong>
</p>
<p>The model predicted <code class="reqn">\hat{\mathbf{y}}_t</code> is <code class="reqn">\mathbf{Z}\mathbf{x}_t^\tau+\mathbf{a} + \mathbf{D}\mathbf{d}_t</code>, where <code class="reqn">\mathbf{x}_t^\tau</code> is the expected value of the state at time <code class="reqn">t</code> conditioned on the data from 1 to <code class="reqn">\tau</code> (<code class="reqn">\tau</code> will be <code class="reqn">t-1</code>, <code class="reqn">t</code> or <code class="reqn">T</code>). Note, if you are using MARSS for estimating the values for missing data, then you want to use <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code> with <code>type="ytT"</code> not <code>fitted(..., type="ytT")</code>.
</p>
<p><code class="reqn">\mathbf{x}_t^\tau</code> is the expected value of the states at time <code class="reqn">t</code> conditioned on the data from time 1 to <code class="reqn">\tau</code>. If <code>type="ytT"</code>, the expected value is conditioned on all the data, i.e. <code>xtT</code> returned by <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>.  If <code>type="ytt1"</code>, then the expected value uses only the data up to time <code class="reqn">t-1</code>, i.e. <code>xtt1</code> returned by <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>.  These are commonly known as the one step ahead predictions for a state-space model. If <code>type="ytt"</code>, then the expected value uses the data up to time <code class="reqn">t</code>, i.e. <code>xtt</code> returned by <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>. 
</p>
<p>If <code>interval="confidence"</code>, the standard error and interval is for the predicted <code class="reqn">\mathbf{y}</code>. The standard error is <code class="reqn">\mathbf{Z} \mathbf{V}_t^\tau \mathbf{Z}^\top</code>.  If <code>interval="prediction"</code>, the standard deviation of new iid <code class="reqn">\mathbf{y}</code> data sets is returned. The standard deviation of new <code class="reqn">\mathbf{y}</code> is <code class="reqn">\mathbf{Z} \mathbf{V}_t^\tau \mathbf{Z}^\top + \mathbf{R}_t</code>.  <code class="reqn">\mathbf{V}_t^\tau</code> is conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">n</code>. <code class="reqn">\tau</code> will be either <code class="reqn">t</code>, <code class="reqn">t-1</code> or <code class="reqn">T</code> depending on the value of <code>type</code>. 
</p>
<p>Intervals returned by <code><a href="#topic+predict.marssMLE">predict</a>()</code> are not for the data used in the model but rather new data sets. To evaluate the data used to fit the model for residuals analysis or analysis or model inadequacy, you want the model residuals (and residual se's). Use <code><a href="#topic+residuals.marssMLE">residuals</a></code> for model residuals and their intervals. The intervals for model residuals are narrower because the predictions for <code class="reqn">\mathbf{y}</code> were estimated from the model data (so is closer to the data used to estimate the predictions than new independent data will be).
</p>
<p><strong>state fitted values</strong>
</p>
<p>The model predicted <code class="reqn">\mathbf{x}_t</code> given <code class="reqn">\mathbf{x}_{t-1}</code> is <code class="reqn">\mathbf{B}\mathbf{x}_{t-1}^\tau+\mathbf{u}+\mathbf{C}\mathbf{c}_t</code>. If you want estimates of the states, rather than the model predictions based on <code class="reqn">\mathbf{x}_{t-1}</code>, go to <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code>. Which function you want depends on your objective and application. 
</p>
<p><code class="reqn">\mathbf{x}_{t-1}^\tau</code> used in the prediction is the expected value of the states at time <code class="reqn">t-1</code> conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t=\tau</code>. If <code>type="xtT"</code>, this is the expected value at time <code class="reqn">t-1</code> conditioned on all the data, i.e. <code>xtT[,t-1]</code> returned by <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>.  If <code>type="xtt1"</code>, it is the expected value conditioned on the data up to time <code class="reqn">t-1</code>, i.e. <code>xtt[,t-1]</code> returned by <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>. The predicted state values conditioned on data up to <code class="reqn">t</code> are not provided. This would require the expected value of states at time <code class="reqn">t</code> conditioned on data up to time <code class="reqn">t+1</code>, and this is not output by the Kalman filter. Only conditioning on data up to <code class="reqn">t-1</code> and <code class="reqn">T</code> are output.
</p>
<p>If <code>interval="confidence"</code>, the standard error of the predicted values (meaning the standard error of the expected value of <code class="reqn">\mathbf{X}_t</code> given <code class="reqn">\mathbf{X}_{t-1}</code>) is returned.  The standard error of the predicted value is <code class="reqn">\mathbf{B} \mathbf{V}_{t-1}^\tau\mathbf{B}^\top</code>. If <code>interval="prediction"</code>, the standard deviation of <code class="reqn">\mathbf{X}_t</code> given <code class="reqn">\mathbf{X}_{t-1}</code> is output. The latter is <code class="reqn">\mathbf{B} \mathbf{V}_{t-1}^\tau \mathbf{B}^\top + \mathbf{Q}</code> . <code class="reqn">\mathbf{V}_{t-1}^\tau</code> is either conditioned on data 1 to <code class="reqn">\tau=T</code> or <code class="reqn">\tau=t-1</code> depending on <code>type</code>. 
</p>
<p>The intervals returned by <code>fitted.marssMLE()</code> are for the state predictions based on the state estimate at <code class="reqn">t-1</code>. These are not typically what one uses or needs&ndash;however might be useful for simulation work. If you want confidence intervals for the state estimates, those are provided in <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a></code>. If you want to do residuals analysis (for outliers or model inadequacy), you want the residuals intervals provided in <code><a href="#topic+residuals.marssMLE">residuals</a>()</code>.
</p>


<h3>Value</h3>

<p>If <code>output="data.frame"</code> (the default), a data frame with the following columns is returned. If <code>output="matrix"</code>, the columns are returned as matrices in a list. Information computed from the model has a leading &quot;.&quot; in the column name.
</p>
<p>If <code>interval="none"</code>, the following are returned (colnames with <code>.</code> in front are computed values):
</p>
<table>
<tr><td><code>.rownames</code></td>
<td>
<p> Names of the data or states. </p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p> Time step. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> The data if <code>type</code> is <code>"ytT"</code>, <code>"ytt"</code> or <code>"ytt1"</code>. </p>
</td></tr>
<tr><td><code>.x</code></td>
<td>
<p> The expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on all the data if <code>type="xtT"</code> or data up to time <code class="reqn">t</code> if <code>type="xtt1"</code>. From <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code>. This is the expected value of the right-side of the <code class="reqn">\mathbf{x}_t</code> equation with the errors terms while <code>.fitted</code> is the expected value of the right side without the error term <code class="reqn">\mathbf{w}_t</code>.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Predicted values of observations (<code class="reqn">\mathbf{y}</code>) or the states (<code class="reqn">\mathbf{x}</code>). See details.</p>
</td></tr>
</table>
<p>If <code>interval = "confidence"</code>, the following are also returned:
</p>
<table>
<tr><td><code>.se</code></td>
<td>
<p> Standard errors of the predictions. </p>
</td></tr>
<tr><td><code>.conf.low</code></td>
<td>
<p> Lower confidence level at <code>alpha = 1-level</code>. The interval is approximated using qnorm(alpha/2)*.se + .fitted </p>
</td></tr>
<tr><td><code>.conf.up</code></td>
<td>
<p> Upper confidence level. The interval is approximated using qnorm(1-alpha/2)*.se + .fitted </p>
</td></tr>
</table>
<p>The confidence interval is for the predicted value, i.e. <code class="reqn">\mathbf{Z}\mathbf{x}_t^\tau+\mathbf{a}</code> for <code class="reqn">\mathbf{y}</code> or <code class="reqn">\mathbf{B}\mathbf{x}_{t-1}^\tau+\mathbf{u}</code> for <code class="reqn">\mathbf{x}</code> where <code class="reqn">\mathbf{x}_t^\tau</code> is the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on the data from 1 to <code class="reqn">\tau</code>. (<code class="reqn">\tau</code> will be <code class="reqn">t-1</code>, <code class="reqn">t</code> or <code class="reqn">T</code>).
</p>
<p>If <code>interval = "prediction"</code>, the following are also returned:
</p>
<table>
<tr><td><code>.sd</code></td>
<td>
<p> Standard deviation of new <code class="reqn">\mathbf{x}_t</code> or <code class="reqn">\mathbf{y}_t</code> iid values. </p>
</td></tr>
<tr><td><code>.lwr</code></td>
<td>
<p> Lower range at <code>alpha = 1-level</code>. The interval is approximated using qnorm(alpha/2)*.sd + .fitted </p>
</td></tr>
<tr><td><code>.upr</code></td>
<td>
<p> Upper range at <code>level</code>. The interval is approximated using qnorm(1-alpha/2)*.sd + .fitted </p>
</td></tr>
</table>
<p>The prediction interval is for new <code class="reqn">\mathbf{x}_t</code> or <code class="reqn">\mathbf{y}_t</code>. If you want to evaluate the observed data or the states estimates for outliers then these are not the intervals that you want. For that you need the residuals intervals provided by <code><a href="#topic+residuals.marssMLE">residuals</a>()</code>.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MARSSkf">MARSSkf</a>()</code>, <code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code>, <code><a href="#topic+residuals.marssMLE">residuals</a>()</code>, <code><a href="#topic+predict.marssMLE">predict</a>()</code>, <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11, 12), ]
fit &lt;- MARSS(dat, model = list(Z = factor(c("WA", "OR", "OR"))))
fitted(fit)

# Example of fitting a stochastic level model to the Nile River flow data
# red line is smooothed level estimate
# grey line is one-step-ahead prediction using xtt1
nile &lt;- as.vector(datasets::Nile)
mod.list &lt;- list(
  Z = matrix(1), A = matrix(0), R = matrix("r"),
  B = matrix(1), U = matrix(0), Q = matrix("q"),
  x0 = matrix("pi")
)
fit &lt;- MARSS(nile, model = mod.list, silent = TRUE)

# Plotting
# There are plot methods for marssMLE objects
library(ggplot2)
autoplot(fit)

# Below shows how to make plots manually but all of these can be made
# with autoplot(fit) or plot(fit)
plot(nile, type = "p", pch = 16, col = "blue")
lines(fitted(fit, type="ytT")$.fitted, col = "red", lwd = 2)
lines(fitted(fit, type="ytt1")$.fitted, col = "grey", lwd = 2)

# Make a plot of the model estimate of y(t), i.e., put a line through the points
# Intervals are for new data not the blue dots 
# (which were used to fit the model so are not new)
library(ggplot2)
d &lt;- fitted(fit, type = "ytT", interval="confidence", level=0.95)
d2 &lt;- fitted(fit, type = "ytT", interval="prediction", level=0.95)
d$.lwr &lt;- d2$.lwr
d$.upr &lt;- d2$.upr
ggplot(data = d) +
  geom_line(aes(t, .fitted), linewidth=1) +
  geom_point(aes(t, y), color = "blue", na.rm=TRUE) +
  geom_ribbon(aes(x = t, ymin = .conf.low, ymax = .conf.up), alpha = 0.3) +
  geom_line(aes(t, .lwr), linetype = 2) +
  geom_line(aes(t, .upr), linetype = 2) +
  facet_grid(~.rownames) +
  xlab("Time Step") + ylab("Count") +
  ggtitle("Blue=data, Black=estimate, grey=CI, dash=prediction interval") +
  geom_text(x=15, y=7, label="The intervals are for \n new data not the blue dots")

</code></pre>

<hr>
<h2 id='forecast.marssMLE'> forecast function for marssMLE objects </h2><span id='topic+forecast.marssMLE'></span>

<h3>Description</h3>

<p><code><a href="#topic+MARSS">MARSS</a>()</code> outputs <code><a href="#topic+marssMLE">marssMLE</a></code> objects.  <code>forecast(object)</code>, where object is <code><a href="#topic+marssMLE">marssMLE</a></code> object, will return the forecasts of <code class="reqn">\mathbf{y}_t</code> or <code class="reqn">\mathbf{x}_t</code> for <code>h</code> steps past the end of the model data. <code>forecast(object)</code> returns a <code><a href="#topic+marssPredict">marssPredict</a></code> object which can be passed to <code><a href="#topic+plot.marssPredict">plot.marssPredict</a></code> for automatic plotting of the forecast. <code>forecast.marssMLE()</code> is used by <code><a href="#topic+predict.marssMLE">predict.marssMLE</a>()</code> to generate forecasts.
</p>
<p>This is a method for the generic <code>forecast</code> function in the generics package. It is written to mimic the behavior and look of the forecast package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
forecast(object, h = 10, level = c(0.8, 0.95), 
     type = c("ytT","xtT", "ytt", "ytt1", "xtt", "xtt1"), 
     newdata = list(y = NULL, c = NULL, d = NULL), 
     interval = c("prediction", "confidence", "none"), 
     fun.kf = c("MARSSkfas", "MARSSkfss"), ...)
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.marssMLE_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object.  </p>
</td></tr>
<tr><td><code id="forecast.marssMLE_+3A_h">h</code></td>
<td>
<p> Number of steps ahead to forecast. <code>newdata</code> is for the forecast, i.e. for the <code class="reqn">h</code> time steps after the end of the model data. If there are covariates in the model, <code class="reqn">\mathbf{c}_t</code> or <code class="reqn">\mathbf{d}_t</code>, then <code>newdata</code> is required. See details. </p>
</td></tr>
<tr><td><code id="forecast.marssMLE_+3A_level">level</code></td>
<td>
<p> Level for the intervals if <code>interval != "none"</code>.</p>
</td></tr>
<tr><td><code id="forecast.marssMLE_+3A_type">type</code></td>
<td>
<p> The default for observations would be <code>type="ytT"</code> and for the states would be <code>type="xtT"</code>, i.e. using all the data. Other possible forecasts are provided for completeness but would in most cases be identical (see details). </p>
</td></tr>
<tr><td><code id="forecast.marssMLE_+3A_newdata">newdata</code></td>
<td>
<p> An optional list with matrices for new covariates <code class="reqn">\mathbf{c}_t</code> or <code class="reqn">\mathbf{d}_t</code> to use for the forecasts. <code class="reqn">\mathbf{c}_t</code> or <code class="reqn">\mathbf{d}_t</code> must be in the original model and have the same matrix rows and columns as used in the <code><a href="#topic+MARSS">MARSS</a>()</code> call but the number of time steps can be different (and should be equal to <code>h</code>). </p>
</td></tr>
<tr><td><code id="forecast.marssMLE_+3A_interval">interval</code></td>
<td>
<p> If <code>interval="confidence"</code>, then the standard error and confidence interval of the expected value of <code class="reqn">\mathbf{y}_t</code> (<code>type="ytT"</code>) or <code class="reqn">\mathbf{x}_t</code> (<code>type="xtT"</code>) is returned. <code>interval="prediction"</code> (default) returns prediction intervals which include the uncertainty in the expected value and due to observation error (the <code class="reqn">\mathbf{R}</code> in the <code class="reqn">\mathbf{y}</code> equation). Note, in the context of a MARSS model, only confidence intervals are available for the states (the <code class="reqn">\mathbf{x}</code>). </p>
</td></tr>
<tr><td><code id="forecast.marssMLE_+3A_fun.kf">fun.kf</code></td>
<td>
<p> Only if you want to change the default Kalman filter. Can be ignored. </p>
</td></tr>
<tr><td><code id="forecast.marssMLE_+3A_...">...</code></td>
<td>
<p> Other arguments. Not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>type="ytT"</code> forecast for <code class="reqn">T+i</code>  is 
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{Z}\mathbf{x}_{T+i}^T + \mathbf{a} + \mathbf{D}\mathbf{d}_{T+i}</code>
</p>

<p>where <code class="reqn">\mathbf{Z}</code>, <code class="reqn">\mathbf{a}</code> and <code class="reqn">\mathbf{D}</code> are estimated from the data from <code class="reqn">t=1</code> to <code class="reqn">T</code>. If the model includes <code class="reqn">\mathbf{d}_t</code> then <code>newdata</code> with <code>d</code> must be passed in. Either confidence or prediction intervals can be shown. Prediction intervals would be the norm for forecasts and show the intervals for new data which based on the conditional variance of <code class="reqn">\mathbf{Z}\mathbf{X}_{T+i} + \mathbf{V}_{T+i}</code>. Confidence intervals would show the variance of the mean of the new data (such as if you ran a simulation multiple times and recorded only the mean observation time series). It is based on the conditional variance of <code class="reqn">\mathbf{Z}\mathbf{X}_{T+i}</code>. The intervals shown are computed with <code><a href="#topic+fitted.marssMLE">fitted</a>()</code>.
</p>
<p>The <code>type="xtT"</code> forecast for <code class="reqn">T+i</code>  is 
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{B}\mathbf{x}_{T+i-1}^T + \mathbf{u} + \mathbf{C}\mathbf{c}_{T+i}</code>
</p>

<p>where <code class="reqn">\mathbf{B}</code> and <code class="reqn">\mathbf{u}</code> and <code class="reqn">\mathbf{C}</code> are estimated from the data from <code class="reqn">t=1</code> to <code class="reqn">T</code> (i.e. the estimates in the marssMLE object). If the model includes <code class="reqn">\mathbf{c}_t</code> then <code>newdata</code> with <code>c</code> must be passed in. The only intervals are confidence intervals which based on the conditional variance of <code class="reqn">\mathbf{B}\mathbf{X}_{T+i-1} + \mathbf{W}_{T+i}</code>. If you pass in data for your forecast time steps, then the forecast will be computed conditioned on the original data plus the data in the forecast period. The intervals shown are computed with the Kalman smoother (or filter if <code>type="xtt"</code> or <code>type="xtt1"</code> specified) via <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code>.
</p>
<p>If the model has time-varying parameters, the parameter estimates at time <code class="reqn">T</code> will be used for the whole forecast. If new data <code>c</code> or <code>d</code> are passed in, it must have <code>h</code> time steps. 
</p>
<p>Note: <code>y</code> in <code>newdata</code>. Data along with covariates can be passed into <code>newdata</code>. In this case, the data in <code>newdata</code> (<code class="reqn">T+1</code> to <code class="reqn">T+h</code>) are conditioned on for the expected value of <code class="reqn">\mathbf{X}_t</code>
but parameters used are only estimated using the data in the marssMLE object (<code class="reqn">t=1</code> to <code class="reqn">T</code>). If you include data in <code>newdata</code>, you need to decide how to condition on that
new data for the forecast. <code>type="ytT"</code> would mean that the <code class="reqn">t=T+i</code> forecast is conditioned on all the data, <code class="reqn">t=1</code> to <code class="reqn">T+h</code>, <code>type="ytt"</code> would mean that the
<code class="reqn">t=T+i</code> forecast is conditioned on the data, <code class="reqn">t=1</code> to <code class="reqn">T+i</code>, and <code>type="ytt1"</code> would mean that the <code class="reqn">t=T+i</code> forecast is conditioned on the data, <code class="reqn">t=1</code> to <code class="reqn">T+i-1</code>. Because MARSS models can be used in all sorts of systems, the <code class="reqn">\mathbf{y}</code> part of the MARSS model might not be &quot;data&quot; in the traditional sense. In some cases, one of the <code class="reqn">\mathbf{y}</code> (in a multivariate model) might be a known deterministic process or it might be a simulated future <code class="reqn">\mathbf{y}</code> that you want to include. In this case the
<code class="reqn">\mathbf{y}</code> rows that are being forecasted are NAs and the <code class="reqn">\mathbf{y}</code> rows that are known are passed in with <code>newdata</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>The method used for fitting, e.g. &quot;kem&quot;. </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The <code><a href="#topic+marssMLE">marssMLE</a></code> object passed into <code>forecast.marssMLE()</code>. </p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>The <code>newdata</code> list if passed into <code>forecast.marssMLE()</code>.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The confidence <code>level</code> passed into <code>forecast.marssMLE()</code>.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>A data frame the forecasts along with the intervals. </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The <code>type</code> (&quot;ytT&quot; or &quot;xtT&quot;) passed into <code>forecast.marssMLE()</code>.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The time steps used to fit the model (used for plotting).</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>The number of forecast time steps (used for plotting).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.marssPredict">plot.marssPredict</a>()</code>, <code><a href="#topic+predict.marssMLE">predict.marssMLE</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># More examples are in ?predict.marssMLE

dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4,] #remove the year row
fit &lt;- MARSS(dat, model=list(R="diagonal and equal"))

# 2 steps ahead forecast
fr &lt;- forecast(fit, type="ytT", h=2)
plot(fr)

# forecast and only show last 10 steps of original data
fr &lt;- forecast(fit, h=10)
plot(fr, include=10)

</code></pre>

<hr>
<h2 id='glance'>Return brief summary information on a MARSS fit</h2><span id='topic+glance'></span><span id='topic+glance.marssMLE'></span>

<h3>Description</h3>

<p>This returns a data frame with brief summary information.
</p>

<dl>
<dt>coef.det</dt><dd><p> The coefficient of determination. This is the squared correlation between the fitted values and the original data points. This is simply a metric for the difference between the data points and the fitted values and should not be used for formal model comparison.  </p>
</dd>
<dt>sigma</dt><dd><p> The sample variance (unbiased) of the data residuals (fitted minus data). This is another simple metric of the difference between the data and fitted values.  This is different than the sigma returned by an <code><a href="stats.html#topic+arima">arima</a>()</code> call for example.  That sigma would be akin to <code>sqrt(Q)</code> in the MARSS parameters; 'akin' because MARSS models are multivariate and the sigma returned by <code>arima()</code> is for a univariate model. </p>
</dd>
<dt>df</dt><dd><p> The number of estimated parameters.  Denoted <code>num.params</code> in a <code><a href="#topic+marssMLE">marssMLE</a></code> object.</p>
</dd>
<dt>logLik</dt><dd><p> The log-likelihood.</p>
</dd>
<dt>AIC</dt><dd><p> Akaike information criterion.</p>
</dd>
<dt>AICc</dt><dd><p> Akaike information criterion corrected for small sample size.</p>
</dd>
<dt>AICbb</dt><dd><p> Non-parametric bootstrap Akaike information criterion if in the <code><a href="#topic+marssMLE">marssMLE</a></code> object.</p>
</dd>
<dt>AICbp</dt><dd><p> Parametric bootstrap Akaike information criterion if in the <code><a href="#topic+marssMLE">marssMLE</a></code> object.</p>
</dd>
<dt>convergence</dt><dd><p> 0 if converged according to the convergence criteria set.  Note the default convergence criteria are high in order to speed up fitting. A number other than 0 means the model did not meet the convergence criteria.</p>
</dd>
<dt>errors</dt><dd><p> 0 if no errors. 1 if some type of error or warning returned.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+marssMLE">marssMLE</a></code> object</p>
</td></tr>
<tr><td><code id="glance_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11, 12), ]
fit &lt;- MARSS(dat, model = list(Z = factor(c("WA", "OR", "OR"))))

glance(fit)
</code></pre>

<hr>
<h2 id='harborSeal'> Harbor Seal Population Count Data (Log counts) </h2><span id='topic+harborSeal'></span><span id='topic+harborSealWA'></span>

<h3>Description</h3>

<p>Data sets used in MARSS vignettes in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>.  These are data sets based on logged count data from Oregon, Washington and California sites where harbor seals were censused while hauled out on land. &quot;harborSealnomiss&quot; is an extrapolated data set where missing values in the original data set have been extrapolated so that the data set can be used to demonstrate fitting population models with different underlying structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(harborSeal)
data(harborSealWA)
</code></pre>


<h3>Format</h3>

<p>Matrix &quot;harborSeal&quot; contains columns &quot;Years&quot;, &quot;StraitJuanDeFuca&quot;, &quot;SanJuanIslands&quot;, &quot;EasternBays&quot;, &quot;PugetSound&quot;, &quot;HoodCanal&quot;, &quot;CoastalEstuaries&quot;, &quot;OlympicPeninsula&quot;, &quot;CA.Mainland&quot;,  &quot;OR.NorthCoast&quot;, &quot;CA.ChannelIslands&quot;, and &quot;OR.SouthCoast&quot;.
</p>
<p>Matrix &quot;harborSealnomiss&quot; contains columns &quot;Years&quot;, &quot;StraitJuanDeFuca&quot;, &quot;SanJuanIslands&quot;, &quot;EasternBays&quot;, &quot;PugetSound&quot;, &quot;HoodCanal&quot;, &quot;CoastalEstuaries&quot;, &quot;OlympicPeninsula&quot;, &quot;OR.NorthCoast&quot;, and &quot;OR.SouthCoast&quot;.
Matrix &quot;harborSealWA&quot; contains columns &quot;Years&quot;, &quot;SJF&quot;, &quot;SJI&quot;, &quot;EBays&quot;, &quot;PSnd&quot;, and &quot;HC&quot;, representing the same five sites as the first five columns of &quot;harborSeal&quot;.
</p>


<h3>Details</h3>

<p>Matrix &quot;harborSealWA&quot; contains the original 1978-1999 logged count data for five inland WA sites. Matrix &quot;harborSealnomiss&quot; contains 1975-2003 data for the same sites as well as four coastal sites, where missing values have been replaced with extrapolated values.  Matrix &quot;harborSeal&quot; contains the original 1975-2003 LOGGED data (with missing values) for the WA and OR sites as well as a CA Mainland and CA ChannelIslands time series.
</p>


<h3>Source</h3>

<p>Jeffries et al. 2003.  Trends and status of harbor seals in Washington State: 1978-1999. Journal of Wildlife Management 67(1):208-219.
</p>
<p>Brown, R. F., Wright, B. E., Riemer, S. D. and Laake, J. 2005. Trends in abundance and current status of harbor seals in Oregon: 1977-2003. Marine Mammal Science, 21: 657-670.
</p>
<p>Lowry, M. S., Carretta, J. V., and Forney, K. A. 2008.  Pacific harbor seal census in California during May-July 2002 and 2004. California Fish and Game 94:180-193.
</p>
<p>Hanan, D. A. 1996. Dynamics of Abundance and Distribution for Pacific Harbor Seal, Phoca vitulina richardsi, on the Coast of California. Ph.D. Dissertation, University of California, Los Angeles. 158pp. DFO. 2010. Population Assessment Pacific Harbour Seal (Phoca vitulina richardsi). DFO Can. Sci. Advis. Sec. Sci. Advis. Rep. 2009/011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(harborSealWA)
str(harborSeal)
</code></pre>

<hr>
<h2 id='is.marssMLE'> Tests marssMLE object for completeness </h2><span id='topic+is.marssMLE'></span>

<h3>Description</h3>

<p>Tests a <code><a href="#topic+marssMLE">marssMLE</a></code> object for completeness to determine if it has all the pieces and attributes necessary to be passed to MARSS functions for fitting, filtering, smoothing, or displaying. Internal function, use <code>MARSS:::</code> to access. This is a very slow function which should not be called repeatedly in a <code>for</code> loop for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.marssMLE(MLEobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.marssMLE_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>is.marssMLE()</code> function checks components <code>marss</code>, <code>start</code> and <code>control</code>, which must be present for estimation by functions e.g. <code><a href="#topic+MARSSkem">MARSSkem</a>()</code>. Components returned from estimation must include at least <code>method</code>, <code>par</code>, <code>kf</code>, <code>numIter</code>, <code>convergence</code> and <code>logLik</code>. Additional components (e.g. AIC) may be returned, as described in function help files.
</p>

<dl>
<dt><code>model</code></dt><dd><p> An object of class <code><a href="#topic+marssMODEL">marssMODEL</a></code> in whatever form the user specified in the call to <code><a href="#topic+MARSS">MARSS</a>()</code>.  Default is form &quot;marxss&quot;. </p>
</dd>
<dt><code>marss</code></dt><dd><p> An object of class <code><a href="#topic+marssMODEL">marssMODEL</a></code> in &quot;marss&quot; forms, needed for all the base MARSS functions. </p>
</dd>
<dt><code>start</code></dt><dd><p> List with matrices specifying initial values for parameters to be used (if needed) by the maximization algorithm. 
</p>

<dl>
<dt><code>B</code></dt><dd><p> Initial value(s) for <code class="reqn">\mathbf{B}</code> matrix (m x m). </p>
</dd>
<dt><code>U</code></dt><dd><p> Initial value(s) for <code class="reqn">\mathbf{u}</code> matrix (m x 1). </p>
</dd>
<dt><code>Q</code></dt><dd><p> Initial value(s) for <code class="reqn">\mathbf{Q}</code> variance-covariance matrix (m x m). </p>
</dd>
<dt><code>Z</code></dt><dd><p> Initial value(s) for <code class="reqn">\mathbf{Z}</code> matrix (n x m). </p>
</dd>
<dt><code>A</code></dt><dd><p> Initial value(s) for <code class="reqn">\mathbf{a}</code> matrix (n x 1). </p>
</dd>
<dt><code>R</code></dt><dd><p> Initial value(s) for <code class="reqn">\mathbf{R}</code> variance-covariance matrix (n x n). </p>
</dd>
<dt><code>x0</code></dt><dd><p> Initial value(s) for initial state vector (m x 1). </p>
</dd>
<dt><code>V0</code></dt><dd><p> Initial variance(s) for initial state variance (m x m). </p>
</dd>
</dl>

</dd>
<dt><code>control</code></dt><dd><p> A list specifying estimation options.  The following options are needed by <code><a href="#topic+MARSSkem">MARSSkem</a>()</code>.  Other control options
can be set if needed for other estimation methods, e.g. the control options listed for <code><a href="stats.html#topic+optim">optim</a></code> for use with <code><a href="#topic+MARSSoptim">MARSSoptim</a>()</code>.  The default values for control options are set in <code>alldefaults[[method]]</code> which is specified in <code>MARSSsettings.R</code>.
</p>

<dl>
<dt><code>minit</code></dt><dd><p> The minimum number of iterations to do in the maximization routine (if needed by method). </p>
</dd> 
<dt><code>maxit</code></dt><dd><p> Maximum number of iterations to be used in the maximization routine (if needed by method). </p>
</dd>
<dt><code>min.iter.conv.test</code></dt><dd><p> Minimum iterations to run before testing convergence via the slope of the log parameter versus log iterations.</p>
</dd> 
<dt><code>conv.test.deltaT=9</code></dt><dd><p> Number of iterations to use for the testing convergence via the slope of the log parameter versus log iterations. </p>
</dd>
<dt><code>conv.test.slope.tol</code></dt><dd><p> The slope of the log parameter versus log iteration to use as the cut-off for convergence.  The default is 0.5 which is a bit high.  For final analyses, this should be set lower. </p>
</dd>
<dt><code>abstol</code></dt><dd><p> The logLik.(iter-1)-logLik.(iter) convergence tolerance for the maximization routine. Both the abstol and the slope of the log of the parameters versus the log iteration tests must be met for convergence.</p>
</dd> 
<dt><code>trace</code></dt><dd><p> A positive integer.  If not 0, a record will be created during maximization iterations (what's recorded depends on method of maximization). -1 turns off most internal error checking.</p>
</dd>
<dt><code>safe</code></dt><dd><p> Logical.  If TRUE, then the Kalman filter is run after each update equation in the EM algorithm.  This slows down the algorithm.  The default is FALSE. </p>
</dd>
<dt><code>allow.degen</code></dt><dd><p> If TRUE, replace <code class="reqn">\mathbf{Q}</code> or <code class="reqn">\mathbf{R}</code> diagonal elements by 0 when they become very small.</p>
</dd> 
<dt><code>min.degen.iter</code></dt><dd><p> Number of iterations before trying to set a diagonal element of <code class="reqn">\mathbf{Q}</code> or <code class="reqn">\mathbf{R}</code> to zero). </p>
</dd> 
<dt><code>degen.lim</code></dt><dd><p> How small the <code class="reqn">\mathbf{Q}</code> or <code class="reqn">\mathbf{R}</code> diagonal element should be before attempting to replace it with zero. </p>
</dd>
<dt><code>silent</code></dt><dd><p> Suppresses printing of progress bar, error messages and convergence information. </p>
</dd> 
</dl>

</dd>
<dt><code>method</code></dt><dd><p> A string specifying the estimation method. MARSS allows &quot;kem&quot; for EM and &quot;BFGS&quot; for quasi-Newton. </p>
</dd>
</dl>
<p>Once the model has been fitted, additional elements are added.
</p>
<dl>
<dt><code>par</code></dt><dd><p> A list with 8 matrices of estimated parameter values Z, A, R, B, U, Q, x0, V0. </p>
</dd>
<dt><code>states</code></dt><dd><p> Expected values of the x (hidden states). </p>
</dd>
<dt><code>states.se</code></dt><dd><p> Standard errors on the estimates states. </p>
</dd>
<dt><code>ytT</code></dt><dd><p> Expected values of the y.  This is just y for non-missing y. </p>
</dd>
<dt><code>ytT.se</code></dt><dd><p> Standard errors on the ytT. This will be 0 for non-missing y. </p>
</dd>
<dt><code>kf</code></dt><dd><p> A list containing Kalman filter/smoother output if <code>control$trace</code> is &gt; 0.</p>
</dd>
<dt><code>Ey</code></dt><dd><p> A list containing expectations involving y. Output if <code>control$trace</code> is &gt; 0.</p>
</dd>
<dt><code>numIter</code></dt><dd><p> Number of iterations which were required for convergence. </p>
</dd>
<dt><code>convergence</code></dt><dd><p> Convergence status and errors. 0 means converged successfully.  Anything else means an error or warning.</p>
</dd>
<dt><code>logLik</code></dt><dd><p> Log-likelihood. </p>
</dd>
<dt><code>AIC</code></dt><dd><p> AIC </p>
</dd>
<dt><code>AICc</code></dt><dd><p> Corrected AIC. </p>
</dd>
<dt><code>call</code></dt><dd><p> A list of all the arguments passed into the MARSS call.  Not required for most functions, but is a record of what was used to call MARSS for checking and can be used to customize the printing of MARSS output. </p>
</dd>
</dl>



<h3>Value</h3>

<p>TRUE if no problems; otherwise a message describing the problems.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes and Kellie Wills, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+MARSSkem">MARSSkem</a>()</code> 
</p>

<hr>
<h2 id='is.marssMODEL'> Test Model Objects </h2><span id='topic+is.marssMODEL'></span><span id='topic+is.marssMODEL_marss'></span><span id='topic+is.marssMODEL_marxss'></span><span id='topic+is.marssMODEL_dfa'></span>

<h3>Description</h3>

<p>These are model objects and utility functions for model objects in the package <code><a href="#topic+MARSS-package">MARSS-package</a></code>.  
<code>is.marssMODEL()</code> ensures model consistency.
<code>MARSS_formname()</code> translates a model list as passed in call to <code><a href="#topic+MARSS">MARSS</a>()</code> into a marssMODEL model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.marssMODEL(MODELobj, method = "kem")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.marssMODEL_+3A_modelobj">MODELobj</code></td>
<td>
<p> An object of class marssMODEL. </p>
</td></tr>
<tr><td><code id="is.marssMODEL_+3A_method">method</code></td>
<td>
<p> Method used for fitting in case there are special constraints for that method. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+marssMODEL">marssMODEL</a></code> object is an R representation of a MARSS model along with the data.  
Data in a <code><a href="#topic+marssMODEL">marssMODEL</a></code> object consists of multivariate time series data in which time is across columns and the n observed time series are in the n different rows.
</p>
<p>The base MARSS model (form=marss) is
</p>

<dl>
<dt>x(t) = B(t) x(t-1) + U(t) + w(t), where w(t) ~ MVN(0,Q(t))</dt><dd></dd>
<dt>y(t) = Z(t) x(t) + A(t) + v(t), where v(t) ~ MVN(0,R(t))</dt><dd></dd>
<dt>x(0) ~ MVN(x0, V0) or x(1) ~ MVN(x0, V0)</dt><dd></dd> 
</dl>

<p>The marssMODEL(form=marss) object describes this MARSS model but written in vec form:
</p>

<dl>
<dt>x(t) = kron(x(t-1),I)(f_b(t)+D_b(t)b) + (f_u(t)+D_u(t)u) + w(t), where w(t) ~ MVN(0,Q)</dt><dd></dd>
<dt>vec(Q) = f_q(t)+D_q(t)q</dt><dd></dd> 
<dt>y(t) = kron(x(t),I)(f_z(t)+D_z(t)z) + (f_a(t)+D_a(t)a) + v(t), where v(t) ~ MVN(0,R)</dt><dd></dd>
<dt>vec(R) = f_r(t)+D_r(t)r</dt><dd></dd> 
<dt>x(0) ~ MVN(f_p+D_p p, V0) or x(1) ~ MVN(f_p+D_p p, V0</dt><dd></dd>
<dt>vec(V0) = f_l+D_l l</dt><dd></dd>  
</dl>

<p>In the marssMODEL(form=marss) object, f(t) + D(t)m, is the vec of a matrix M(t), so f_b(t)+D_b(t)b would be vec(B(t)). The estimated parameters are in the column vectors: b, u, q, z, a, r, p, and l.  Each matrix M(t) is f(t)+D(t)m so is the sum of a fixed part f(t) and the linear combination, D(t), of the free (or estimated) part m.  
</p>
<p>The vec form of the MARSS model is specified by 3D matrices for each f and D for each parameter: B, U, Q, Z, A, R, x0, V0.  The number of columns in the D matrix for a parameter determines the number of estimated values for that parameter.  
The first dimension for f (<code>fixed</code>) and D (<code>free</code>) must be:
</p>

<dl>
<dt>Z</dt><dd><p> n x m </p>
</dd>
<dt>B, Q, and V0</dt><dd><p> m x m </p>
</dd>
<dt>U and x0</dt><dd><p> m x 1 </p>
</dd>
<dt>A</dt><dd><p> n x 1 </p>
</dd>
<dt>R</dt><dd><p> n x n </p>
</dd>
</dl>

<p>The third dimension of f (<code>fixed</code>) and D (<code>free</code>) is either 1 (if not time-varying) or T (if time-varying).   The second dimension of f (<code>fixed</code>) is always 1, while the second dimension of D  (<code>free</code>) depends on how many values are being estimated for a matrix.  It can be 0 (if the matrix is fixed) or up to the size of the matrix (if all elements are being estimated).
</p>


<h3>Value</h3>

<p>A vector of error messages or NULL is no errors.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSS">MARSS</a>()</code>, <code><a href="#topic+MARSS.marxss">MARSS.marxss</a>()</code>, <code><a href="#topic+marssMODEL">marssMODEL</a></code> </p>

<hr>
<h2 id='isleRoyal'> Isle Royale Wolf and Moose Data </h2><span id='topic+isleRoyal'></span>

<h3>Description</h3>

<p>Example data set for estimation of species interaction strengths. These are data on the number of wolves and 
moose on Isle Royal, Michigan.  The data are unlogged.  The covariate data are the average Jan-Feb, average Apr-May and average July-Sept
temperature (Fahrenheit) and precipitation (inches).  Also included are 3-year running means of these covariates.  The choice of 
covariates is based on those presented in the Isle Royale 2012 annual report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(isleRoyal)
</code></pre>


<h3>Format</h3>

<p>The data are supplied as a matrix with years in the first column.
</p>


<h3>Source</h3>

<p>Peterson R. O., Thomas N. J., Thurber J. M., Vucetich J. A. and Waite T. A. (1998) Population limitation and the wolves of Isle Royale. In: Biology and Conservation of Wild Canids (eds. D. Macdonald and C. Sillero-Zubiri). Oxford University Press, Oxford, pp. 281-292.
</p>
<p>Vucetich, J. A. and R. O. Peterson. (2010) Ecological studies of wolves on Isle Royale. Annual Report 2009-10. School of Forest Resources and Environmental Science, Michigan Technological University, Houghton, Michigan USA 49931-1295
</p>
<p>The source for the covariate data is the Western Regional Climate Center (http://www.wrcc.dri.edu) using their data for the NE Minnesota division.  The website used was http://www.wrcc.dri.edu/cgi-bin/divplot1_form.pl?2103 and www.wrcc.dri.edu/spi/divplot1map.html.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(isleRoyal)
</code></pre>

<hr>
<h2 id='ldiag'> Return a diagonal list matrix </h2><span id='topic+ldiag'></span>

<h3>Description</h3>

<p>Creates a list diagonal matrix where the diagonal can be a combination of numbers and characters. Characters are names of parameters to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldiag(x, nrow = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldiag_+3A_x">x</code></td>
<td>
<p> A vector or list of single values </p>
</td></tr>
<tr><td><code id="ldiag_+3A_nrow">nrow</code></td>
<td>
<p> Rows in square matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A diagonal list matrix is returned. The off-diagonals will be 0 and the diagonal will be <code>x
  </code>. <code>x</code> can be a combination of numbers and characters.  If <code>x</code> is numeric, the diagonal will still be list type so that later the diagonal can be replace with characters. See examples. 
</p>


<h3>Value</h3>

<p>a square list matrix
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ldiag(list(0, "b"))
ldiag("a", nrow=3)

# This works
a &lt;- ldiag(1:3)
diag(a) &lt;- "a"
diag(a) &lt;- list("a", 0, 0)

# ldiag() is a convenience function to replace having to 
# write code like this
a &lt;- matrix(list(0), 3, 3)
diag(a) &lt;- list("a", 0, 0)

# diag() alone won't work because it cannot handle mixed number/char lists

# This turns the off-diagonals to character "0" 
a &lt;- diag(1:3)
diag(a) &lt;- "a"

# This would turn our matrix into a list only (not a matrix anymore)
a &lt;- diag(1:3)
diag(a) &lt;- list("a", 0, 0)

# This would return NA on the diagonal
a &lt;- diag("a", 3)

</code></pre>

<hr>
<h2 id='loggerhead'> Loggerhead Turtle Tracking Data </h2><span id='topic+loggerhead'></span><span id='topic+loggerheadNoisy'></span>

<h3>Description</h3>

<p>Data used in MARSS vignettes in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>.  Tracking data from ARGOS tags on eight individual loggerhead turtles, 1997-2006.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(loggerhead)
data(loggerheadNoisy)
</code></pre>


<h3>Format</h3>

<p>Data frames &quot;loggerhead&quot; and &quot;loggerheadNoisy&quot; contain the following columns:
</p>

<dl>
<dt>turtle</dt><dd><p> Turtle name. </p>
</dd>
<dt>day</dt><dd><p> Day of the month (character). </p>
</dd>
<dt>month</dt><dd><p> Month number (character). </p>
</dd>
<dt>year</dt><dd><p> Year (character). </p>
</dd>
<dt>lon</dt><dd><p> Longitude of observation. </p>
</dd>
<dt>lat</dt><dd><p> Latitude of observation. </p>
</dd> 
</dl>



<h3>Details</h3>

<p>Data frame &quot;loggerhead&quot; contains the original latitude and longitude data. Data frame &quot;loggerheadNoisy&quot; has noise added to the lat and lon data to represent data corrupted by errors.
</p>


<h3>Source</h3>

<p>Gray's Reef National Marine Sanctuary (Georgia) and WhaleNet:
http://whale.wheelock.edu/whalenet-stuff/stop_cover_archive.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(loggerhead)
str(loggerheadNoisy)
</code></pre>

<hr>
<h2 id='logLik.marssMLE'> logLik method for MARSS MLE objects </h2><span id='topic+logLik.marssMLE'></span><span id='topic+logLik'></span>

<h3>Description</h3>

<p>Returns a logLik class object with attributes nobs and df.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'marssMLE'
logLik(object, ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.marssMLE_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object.  </p>
</td></tr>
<tr><td><code id="logLik.marssMLE_+3A_...">...</code></td>
<td>
<p> Other arguments. Not used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class logLik.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSkf">MARSSkf</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11, 12), ]
MLEobj &lt;- MARSS(dat, model = list(Z = factor(c("WA", "OR", "OR"))))
logLik(MLEobj)

  </code></pre>

<hr>
<h2 id='MARSS'> Fit a MARSS Model via Maximum-Likelihood Estimation </h2><span id='topic+MARSS'></span>

<h3>Description</h3>

<p>This is the main function for fitting multivariate autoregressive state-space (MARSS) models with linear constraints.  Scroll down to the bottom to see some short examples.  To open a guide to show you how to get started quickly, type <code>RShowDoc("Quick_Start",package="MARSS")</code>.  To open the MARSS User Guide from the command line, type <code>RShowDoc("UserGuide",package="MARSS")</code>. To get an overview of the package and all its main functions and how to get output (parameter estimates, fitted values, residuals, Kalmin filter or smoother output, or plots), go to <code><a href="#topic+MARSS-package">MARSS-package</a></code>. If <code>MARSS()</code> is throwing errors or warnings that you don't understand, try the Troubleshooting section of the user guide or type <code><a href="#topic+MARSSinfo">MARSSinfo</a>()</code> at the command line.
</p>
<p>The default MARSS model form is &quot;marxss&quot;, which is Multivariate Auto-Regressive(1) eXogenous inputs State-Space model:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x}_{t} = \mathbf{B}_t \mathbf{x}_{t-1} + \mathbf{u}_t + \mathbf{C}_t \mathbf{c}_t + \mathbf{G}_t \mathbf{w}_t, \textrm{ where } \mathbf{W}_t \sim \textrm{MVN}(0,\mathbf{Q}_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z}_t \mathbf{x}_t + \mathbf{a}_t + \mathbf{D}_t \mathbf{d}_t + \mathbf{H}_t \mathbf{v}_t, \textrm{ where } \mathbf{V}_t \sim \textrm{MVN}(0,\mathbf{R}_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{X}_1 \sim \textrm{MVN}(\mathbf{x0}, \mathbf{V0}) \textrm{ or } \mathbf{X}_0 \sim \textrm{MVN}(\mathbf{x0}, \mathbf{V0}) </code>
</p>

<p>The parameters are everything except <code class="reqn">\mathbf{x}</code>, <code class="reqn">\mathbf{y}</code>, <code class="reqn">\mathbf{v}</code>, <code class="reqn">\mathbf{w}</code>, <code class="reqn">\mathbf{c}</code> and <code class="reqn">\mathbf{d}</code>. <code class="reqn">\mathbf{y}</code> are data (missing values allowed). <code class="reqn">\mathbf{c}</code> and <code class="reqn">\mathbf{d}</code> are inputs (no missing values allowed). All parameters (except <code class="reqn">\mathbf{x0}</code> and <code class="reqn">\mathbf{V0}</code>) can be time-varying but by default, all are time-constant (and the MARSS equation is generally written without the <code class="reqn">t</code> subscripts on the parameter matrices). All parameters can be zero, including the variance matrices. 
</p>
<p>The parameter matrices can have fixed values and linear constraints. This is an example of a 3x3 matrix with linear constraints. All matrix elements can be written as a linear function of <code class="reqn">a</code>, <code class="reqn">b</code>, and <code class="reqn">c</code>:
</p>
<p style="text-align: center;"><code class="reqn">\left[\begin{array}{c c c} a+2b &amp; 1 &amp; a\\ 1+3a+b &amp; 0 &amp; b \\ 0 &amp; -2 &amp; c\end{array}\right]</code>
</p>

<p>Values such as <code class="reqn">a b</code> or <code class="reqn">a^2</code> or <code class="reqn">log(a)</code> are not linear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSS(y, 
    model = NULL, 
    inits = NULL, 
    miss.value = as.numeric(NA), 
    method = c("kem", "BFGS", "TMB", "BFGS_TMB", "nlminb_TMB"), 
    form = c("marxss", "dfa", "marss"), 
    fit = TRUE, 
    silent = FALSE, 
    control = NULL, 
    fun.kf = c("MARSSkfas", "MARSSkfss"), 
    ...) 
</code></pre>


<h3>Arguments</h3>

<p>The default settings for the optional arguments are set in <code>MARSSsettings.R</code> and are given below in the details section. For form specific defaults see the form help file (e.g. <code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code> or <code><a href="#topic+MARSS.dfa">MARSS.dfa</a></code>).
</p>
<table>
<tr><td><code id="MARSS_+3A_y">y</code></td>
<td>
<p> A n x T matrix of n time series over T time steps. Only y is required for the function. A ts object (univariate or multivariate) can be used and this will be converted to a matrix with time in the columns. </p>
</td></tr>
<tr><td><code id="MARSS_+3A_inits">inits</code></td>
<td>
<p> A list with the same form as the list outputted by <code>coef(fit)</code> that specifies initial values for the parameters.  See also <code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code>. </p>
</td></tr>
<tr><td><code id="MARSS_+3A_model">model</code></td>
<td>
<p> Model specification using a list of parameter matrix text shortcuts or matrices. See Details and <code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code> for the default form. Or better yet open the Quick Start Guide <code>RShowDoc("Quick_Start",package="MARSS")</code>. </p>
</td></tr>
<tr><td><code id="MARSS_+3A_miss.value">miss.value</code></td>
<td>
<p> Deprecated.  Denote missing values by NAs in your data. </p>
</td></tr>
<tr><td><code id="MARSS_+3A_method">method</code></td>
<td>
<p> Estimation method. MARSS provides an EM algorithm (<code>method="kem"</code>) (see <code><a href="#topic+MARSSkem">MARSSkem</a></code>) and the BFGS algorithm (<code>method="BFGS"</code>) (see <code><a href="#topic+MARSSoptim">MARSSoptim</a></code>). </p>
</td></tr>
<tr><td><code id="MARSS_+3A_form">form</code></td>
<td>
<p> The equation form used in the <code>MARSS()</code> call.  The default is &quot;marxss&quot;. See <code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code> or <code><a href="#topic+MARSS.dfa">MARSS.dfa</a></code>. </p>
</td></tr>
<tr><td><code id="MARSS_+3A_fit">fit</code></td>
<td>
<p> TRUE/FALSE Whether to fit the model to the data. If FALSE, a <code><a href="#topic+marssMLE">marssMLE</a></code> object with only the model is returned. </p>
</td></tr>
<tr><td><code id="MARSS_+3A_silent">silent</code></td>
<td>
<p> Setting to TRUE(1) suppresses printing of full error messages, warnings, progress bars and convergence information. Setting to FALSE(0) produces error output. Setting silent=2 will produce more verbose error messages and progress information. </p>
</td></tr>
<tr><td><code id="MARSS_+3A_fun.kf">fun.kf</code></td>
<td>
<p>   What Kalman filter function to use.  MARSS has two: <code><a href="#topic+MARSSkfas">MARSSkfas</a>()</code> which is based on the Kalman filter in the <a href="https://cran.r-project.org/package=KFAS">KFAS</a> package based on Koopman and Durbin and <code><a href="#topic+MARSSkfss">MARSSkfss</a>()</code> which is a native R implementation of the Kalman filter and smoother in Shumway and Stoffer. The KFAS filter is much faster.  <code><a href="#topic+MARSSkfas">MARSSkfas</a>()</code> modifies the input and output in order to output the lag-one covariance smoother needed for the EM algorithm (per page 321 in Shumway and Stoffer (2000).</p>
</td></tr>
<tr><td><code id="MARSS_+3A_control">control</code></td>
<td>
<p> Estimation options for the maximization algorithm. The typically used control options for method=&quot;kem&quot; are below but see  <code><a href="#topic+marssMLE">marssMLE</a></code> for the full list of control options.  Note many of these are not allowed if method=&quot;BFGS&quot;; see  <code><a href="#topic+MARSSoptim">MARSSoptim</a></code> for the allowed control options for this method.
</p>

<dl>
<dt><code>minit</code></dt><dd><p>   The minimum number of iterations to do in the maximization routine (if needed by method). If <code>method="kem"</code>, this is an easy way to up the iterations and see how your estimates are converging. (positive integer)</p>
</dd> 
<dt><code>maxit</code></dt><dd><p>   Maximum number of iterations to be used in the maximization routine (if needed by method) (positive integer). </p>
</dd>
<dt><code>min.iter.conv.test</code></dt><dd><p> Minimum iterations to run before testing convergence via the slope of the log parameter versus log iterations.</p>
</dd> 
<dt><code>conv.test.deltaT=9</code></dt><dd><p> Number of iterations to use for the testing convergence via the slope of the log parameter versus log iterations. </p>
</dd>
<dt><code>conv.test.slope.tol</code></dt><dd><p> The slope of the log parameter versus log iteration to use as the cut-off for convergence.  The default is 0.5 which is a bit high.  For final analyses, this should be set lower.  If you want to only use abstol as your convergence test, then to something very large, for example <code>conv.test.slope.tol=1000</code>.  Type <code>MARSSinfo(11)</code> to see some comments on when you might want to do this.</p>
</dd>
<dt><code>abstol</code></dt><dd><p> The logLik.(iter-1)-logLik.(iter) convergence tolerance for the maximization routine. To meet convergence both the abstol and slope tests must be passed.</p>
</dd> 
<dt><code>allow.degen</code></dt><dd><p> Whether to try setting <code class="reqn">\mathbf{Q}</code> or <code class="reqn">\mathbf{R}</code> elements to zero if they appear to be going to zero. </p>
</dd>
<dt><code>trace</code></dt><dd><p> An integer specifying the level of information recorded and error-checking run during the algorithms.  <code>trace=0</code>, specifies basic error-checking and brief error-messages; <code>trace&gt;0</code> will print full error messages. In addition if trace&gt;0, the Kalman filter output will be added to the outputted <code>marssMLE</code> object.  Additional information recorded depends on the method of maximization. For the EM algorithm, a record of each parameter estimate for each EM iteration will be added.   See <code><a href="stats.html#topic+optim">optim</a></code> for trace output details for the BFGS method.   <code>trace=-1</code> will turn off most internal error-checking and most error messages.  The internal error checks are time expensive so this can speed up model fitting.  This is particularly useful for bootstrapping and simulation studies. It is also useful if you get an error saying that <code>MARSS()</code> stops in <code><a href="#topic+MARSSkfss">MARSSkfss</a>()</code> due to a <code>chol()</code> call. <code>MARSSkfss()</code> uses matrix inversions and for some models these are unstable (high condition value). <code>MARSSkfss()</code> is used for error-checks and does not need to be called normally. </p>
</dd>
<dt><code>safe</code></dt><dd><p>  Setting <code>safe=TRUE</code> runs the Kalman smoother after each parameter update rather than running the smoother only once after updated all parameters.  The latter is faster but is not a strictly correct EM algorithm.  In most cases, <code>safe=FALSE</code> (default) will not change the fits.  If this setting does cause problems, you will know because you will see an error regarding the log-likelihood dropping and it will direct you to set <code>safe=TRUE</code>.    </p>
</dd>
</dl>
 </td></tr>
<tr><td><code id="MARSS_+3A_...">...</code></td>
<td>
<p> Optional arguments passed to function specified by form. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>model</code> argument specifies the structure of your model. There is a one-to-one correspondence between how you would write your model in matrix form on the whiteboard and how you specify the model for <code>MARSS()</code>.  Many different types of multivariate time-series models can be converted to the MARSS form. See the <a href="https://cran.r-project.org/package=MARSS/vignettes/UserGuide.pdf">User Guide</a> and <a href="https://cran.r-project.org/package=MARSS/vignettes/Quick_Start.html">Quick Start Guide</a> for examples. 
</p>
<p>The MARSS package has two forms for standard users: marxss and dfa.
</p>

<dl>
<dt><code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code></dt><dd><p>This is the default form. This is a MARSS model with (optional) inputs <code class="reqn">\mathbf{c}_t</code> or <code class="reqn">\mathbf{d}_t</code>. Most users will want this help page.</p>
</dd>
<dt><code><a href="#topic+MARSS.dfa">MARSS.dfa</a></code></dt><dd><p>This is a model form to allow easier specification of models for Dynamic Factor Analysis. The <code class="reqn">\mathbf{Z}</code> parameters has a specific form and the <code class="reqn">\mathbf{Q}</code> is set at i.i.d (diagonal) with variance of 1.</p>
</dd>
</dl>

<p>Those looking to modify or understand the base code, should look at <code><a href="#topic+MARSS.marss">MARSS.marss</a></code> and 
<code><a href="#topic+MARSS.vectorized">MARSS.vectorized</a></code>. These describe the forms used by the base functions. The EM algorithm uses the MARSS model written in vectorized form. This form is what allows linear constraints. 
</p>
<p>The likelihood surface for MARSS models can be  multimodal or with strong ridges.  It is  recommended that for final analyses the estimates are checked by using a Monte Carlo initial conditions search; see the chapter on initial conditions searches in the User Guide.  This requires more computation time, but reduces the chance of the algorithm terminating at a local maximum and not reaching the true MLEs.  Also it is wise to check the EM results against the BFGS results (if possible) if there are strong ridges in the likelihood.  Such ridges seems to slow down the EM algorithm considerably and can cause the algorithm to report convergence far from the maximum-likelihood values.  EM steps up the likelihood and the convergence test is based on the rate of change of the log-likelihood in each step. Once on a strong ridge, the steps can slow dramatically.  You can force the algorithm to keep working by setting <code>minit</code>.  BFGS seems less hindered by the ridges but can be prodigiously slow for some multivariate problems.  BFGS tends to work better if you give it good initial conditions (see Examples below for how to do this).
</p>
<p>If you are working with models with time-varying parameters, it is important to notice the time-index for the parameters in the process equation (the <code class="reqn">\mathbf{x}</code> equation).  In some formulations (e.g. in <code><a href="KFAS.html#topic+KFAS">KFAS</a></code>), the process equation is <code class="reqn">\mathbf{x}_t=\mathbf{B}_{t-1}\mathbf{x}_{t-1}+\mathbf{w}_{t-1}</code> so <code class="reqn">\mathbf{B}_{t-1}</code> goes with <code class="reqn">\mathbf{x}_t</code> not <code class="reqn">\mathbf{B}_t</code>. Thus one needs to be careful to line up the time indices when passing in time-varying parameters to <code>MARSS()</code>.  See the User Guide for examples.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>.  The structure of this object is discussed below, but if you want to know how to get specific output (like residuals, coefficients, smoothed states, confidence intervals, etc), see <code><a href="#topic+print.marssMLE">print.marssMLE</a>()</code>, <code><a href="#topic+tidy.marssMLE">tidy.marssMLE</a>()</code>, <code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code> and <code><a href="#topic+plot.marssMLE">plot.marssMLE</a>()</code>.  
</p>
<p>The outputted <code><a href="#topic+marssMLE">marssMLE</a></code> object has the following components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p> MARSS model specification. It is a <code><a href="#topic+marssMODEL">marssMODEL</a></code> object in the form specified by the user in the <code>MARSS()</code> call.  This is used by print functions so that the user sees the expected form.</p>
</td></tr>
<tr><td><code>marss</code></td>
<td>
<p> The <code><a href="#topic+marssMODEL">marssMODEL</a></code> object in marss form. This form is needed for all the internal algorithms, thus is a required part of a <code><a href="#topic+marssMLE">marssMLE</a></code> object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> All the information passed in in the <code>MARSS()</code> call. </p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p> List with specifying initial values that were used for each parameter matrix. </p>
</td></tr> 
<tr><td><code>control</code></td>
<td>
<p> A list of estimation options, as specified by arguments <code>control</code>. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> Estimation method. </p>
</td></tr>
</table>
<p>If <code>fit=TRUE</code>, the following are also added to the <code><a href="#topic+marssMLE">marssMLE</a></code> object.
If <code>fit=FALSE</code>, a <code><a href="#topic+marssMLE">marssMLE</a></code> object ready for fitting via the specified <code>method</code> is returned.
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p> A list of estimated parameter values in marss form. Use <code><a href="#topic+print.marssMLE">print</a>()</code>, <code><a href="#topic+tidy.marssMLE">tidy</a>()</code> or <code><a href="#topic+coef.marssMLE">coef</a>()</code> for outputing the model estimates in the <code>MARSS()</code> call (e.g. the default &quot;marxss&quot; form).</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p> The expected value of <code class="reqn">\mathbf{X}</code> conditioned on all the data, i.e. smoothed states. </p>
</td></tr>
<tr><td><code>states.se</code></td>
<td>
<p> The standard errors of the expected value of <code class="reqn">\mathbf{X}</code>. </p>
</td></tr>
<tr><td><code>ytT</code></td>
<td>
<p> The expected value of <code class="reqn">\mathbf{Y}</code> conditioned on all the data.  Note this is just <code class="reqn">y</code> for those <code class="reqn">y</code> that are not missing. </p>
</td></tr>
<tr><td><code>ytT.se</code></td>
<td>
<p> The standard errors of the expected value of <code class="reqn">\mathbf{Y}</code>. Note this is 0 for any non-missing <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code>numIter</code></td>
<td>
<p> Number of iterations required for convergence. </p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p> Convergence status. 0 means converged successfully, 3 means all parameters were fixed (so model did not need to be fit) and -1 means call was made with <code>fit=FALSE</code> and parameters were not fixed (thus no <code>$par</code> element and Kalman filter/smoother cannot be run).  Anything else is a warning or error. 2 means the <code><a href="#topic+marssMLE">marssMLE</a></code> object has an error; the object is returned so you can debug it.  The other numbers are errors during fitting.  The error code depends on the fitting method.  See <code><a href="#topic+MARSSkem">MARSSkem</a></code> and <code><a href="#topic+MARSSoptim">MARSSoptim</a></code>. </p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p> Log-likelihood. </p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p> Akaike's Information Criterion. </p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p> Sample size corrected AIC. </p>
</td></tr>
</table>
<p>If <code>control$trace</code> is set to 1 or greater, the following are also added to the <code><a href="#topic+marssMLE">marssMLE</a></code> object.
</p>
<table>
<tr><td><code>kf</code></td>
<td>
<p> A list containing Kalman filter/smoother output from <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>.  This is not normally added to a <code><a href="#topic+marssMLE">marssMLE</a></code> object since it is verbose, but can be added using <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>.</p>
</td></tr>
<tr><td><code>Ey</code></td>
<td>
<p> A list containing output from <code><a href="#topic+MARSShatyt">MARSShatyt</a></code>. This isn't normally added to a <code><a href="#topic+marssMLE">marssMLE</a></code> object since it is verbose, but can be computed using <code><a href="#topic+MARSShatyt">MARSShatyt</a>()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes, Eric Ward and Kellie Wills, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

 
<p>The MARSS User Guide:  Holmes, E. E., E. J. Ward, and M. D. Scheuerell (2012) Analysis of multivariate time-series using the MARSS package. NOAA Fisheries, Northwest Fisheries Science
Center, 2725 Montlake Blvd E., Seattle, WA 98112   Type <code>RShowDoc("UserGuide",package="MARSS")</code> to open a copy.          
</p>
<p>Holmes, E. E. (2012).  Derivation of the EM algorithm for constrained and unconstrained multivariate autoregressive state-space (MARSS) models.  Technical Report. arXiv:1302.3919 [stat.ME]
</p>
<p>Holmes, E. E., E. J. Ward and K. Wills. (2012) MARSS: Multivariate autoregressive state-space models for analyzing time-series data. R Journal 4: 11-19.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marssMLE">marssMLE</a></code>, <code><a href="#topic+MARSSkem">MARSSkem</a>()</code>, <code><a href="#topic+MARSSoptim">MARSSoptim</a>()</code>, <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>, <code><a href="#topic+MARSS-package">MARSS-package</a></code>, <code><a href="#topic+print.marssMLE">print.marssMLE</a>()</code>, <code><a href="#topic+plot.marssMLE">plot.marssMLE</a>()</code>, <code><a href="#topic+print.marssMODEL">print.marssMODEL</a>()</code>, <code><a href="#topic+MARSS.marxss">MARSS.marxss</a>()</code>, <code><a href="#topic+MARSS.dfa">MARSS.dfa</a>()</code>,  <code><a href="#topic+fitted.marssMLE">fitted</a>()</code>, <code><a href="#topic+residuals.marssMLE">residuals</a>()</code>, <code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code>, <code><a href="#topic+predict.marssMLE">predict</a>()</code>, <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code>,
<code><a href="#topic+tidy.marssMLE">tidy</a>()</code>, <code><a href="#topic+coef.marssMLE">coef</a>()</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4, ] # remove the year row
# fit a model with 1 hidden state and 3 observation time series
kemfit &lt;- MARSS(dat, model = list(
  Z = matrix(1, 3, 1),
  R = "diagonal and equal"
))
kemfit$model # This gives a description of the model
print(kemfit$model) # same as kemfit$model
summary(kemfit$model) # This shows the model structure

# add CIs to a marssMLE object
# default uses an estimated Hessian matrix
kem.with.hess.CIs &lt;- MARSSparamCIs(kemfit)
kem.with.hess.CIs

# fit a model with 3 hidden states (default)
kemfit &lt;- MARSS(dat, silent = TRUE) # suppress printing
kemfit

# Fit the above model with BFGS using a short EM fit as initial conditions
kemfit &lt;- MARSS(dat, control=list(minit=5, maxit=5))
bffit &lt;- MARSS(dat, method="BFGS", inits=kemfit)

# fit a model with 3 correlated hidden states
# with one variance and one  covariance
# maxit set low to speed up example, but more iters are needed for convergence
kemfit &lt;- MARSS(dat, model = list(Q = "equalvarcov"), control = list(maxit = 50))
# use Q="unconstrained" to allow different variances and covariances

# fit a model with 3 independent hidden states
# where each observation time series is independent
# the hidden trajectories 2-3 share their U parameter
kemfit &lt;- MARSS(dat, model = list(U = matrix(c("N", "S", "S"), 3, 1)))

# same model, but with fixed independent observation errors
# and the 3rd x processes are forced to have a U=0
# Notice how a list matrix is used to combine fixed and estimated elements
# all parameters can be specified in this way using list matrices
kemfit &lt;- MARSS(dat, model = list(U = matrix(list("N", "N", 0), 3, 1), R = diag(0.01, 3)))

# fit a model with 2 hidden states (north and south)
# where observation time series 1-2 are north and 3 is south
# Make the hidden state process independent with same process var
# Make the observation errors different but independent
# Make the growth parameters (U) the same
# Create a Z matrix as a design matrix that assigns the "N" state to the first 2 rows of dat
# and the "S" state to the 3rd row of data
Z &lt;- matrix(c(1, 1, 0, 0, 0, 1), 3, 2)
# You can use factor is a shortcut making the above design matrix for Z
# Z &lt;- factor(c("N","N","S"))
# name the state vectors
colnames(Z) &lt;- c("N", "S")
kemfit &lt;- MARSS(dat, model = list(
  Z = Z,
  Q = "diagonal and equal", R = "diagonal and unequal", U = "equal"
))

# print the model followed by the marssMLE object
kemfit$model

## Not run: 
# simulate some new data from our fitted model
sim.data &lt;- MARSSsimulate(kemfit, nsim = 10, tSteps = 10)

# Compute bootstrap AIC for the model; this takes a long, long time
kemfit.with.AICb &lt;- MARSSaic(kemfit, output = "AICbp")
kemfit.with.AICb

## End(Not run)

## Not run: 
# Many more short examples can be found in the
# Quick Examples chapter in the User Guide
RShowDoc("UserGuide", package = "MARSS")

# You can find the R scripts from the chapters by
# going to the index page
RShowDoc("index", package = "MARSS")

## End(Not run)

</code></pre>

<hr>
<h2 id='marss.conversion'> Convert Model Objects between Forms </h2><span id='topic+marxss_to_marss'></span><span id='topic+marss_to_marxss'></span>

<h3>Description</h3>

<p>These are utility functions for model objects in the package <code><a href="#topic+MARSS-package">MARSS-package</a></code>.  
Users would not normally work directly with these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marss_to_marxss(x, C.and.D.are.zero = FALSE)
marxss_to_marss(x, only.par = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marss.conversion_+3A_x">x</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. </p>
</td></tr>
<tr><td><code id="marss.conversion_+3A_c.and.d.are.zero">C.and.D.are.zero</code></td>
<td>
<p> If the C and D matrices are all 0, then a marss model can be converted to marxss without further information besides the marss model. </p>
</td></tr>
<tr><td><code id="marss.conversion_+3A_only.par">only.par</code></td>
<td>
<p> If only.par=TRUE then only the par element is changed and marss is used for the marss object. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the name of the functions imply, these convert <code><a href="#topic+marssMODEL">marssMODEL</a></code> objects of different forms into other forms.  form=marss is the base form needed for the internal algorithms, thus other (more user friendly forms) must have a <code>form_to_marss</code> function to convert to the base form.  The printing functions are customized to show output in the user-friendly form, thus a <code>marss_to_form</code> function is needed for <code>print</code> and <code>coef</code> methods for <code><a href="#topic+marssMLE">marssMLE</a></code> objects.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+marssMODEL">marssMODEL</a></code> object of the appropriate form.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+marssMODEL">marssMODEL</a></code> </p>

<hr>
<h2 id='MARSS.dfa'> Multivariate Dynamic Factor Analysis </h2><span id='topic+MARSS.dfa'></span>

<h3>Description</h3>

<p>The Dynamic Factor Analysis model in MARSS is
The argument <code>form="marxss"</code> in a <code><a href="#topic+MARSS">MARSS</a>()</code> function call specifies a MAR-1 model with eXogenous variables model.  This is a MARSS(1) model of the form:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x}_{t} = \mathbf{x}_{t-1} + \mathbf{w}_t, \textrm{ where } \mathbf{W}_t \sim \textrm{MVN}(0,\mathbf{I})</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z}_t \mathbf{x}_t + \mathbf{D}_t \mathbf{d}_t + \mathbf{v}_t, \textrm{ where } \mathbf{V}_t \sim \textrm{MVN}(0,\mathbf{R}_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{X}_1 \sim \textrm{MVN}(\mathbf{x0}, 5\mathbf{I})</code>
</p>

<p>Note, by default <code class="reqn">\mathbf{x}_1</code> is treated as a diffuse prior.
</p>
<p>Passing in <code>form="dfa"</code> to <code><a href="#topic+MARSS">MARSS</a>()</code> invokes a helper function to create that model and creates the <code class="reqn">\mathbf{Z}</code> matrix for the user.  <code class="reqn">\mathbf{Q}</code> is by definition identity, <code class="reqn">\mathbf{x}_0</code> is zero and <code class="reqn">\mathbf{V_0}</code> is diagonal with large variance (5). <code class="reqn">\mathbf{u}</code> is zero, <code class="reqn">\mathbf{a}</code> is zero, and covariates only enter the <code class="reqn">\mathbf{y}</code> equation.  Because <code class="reqn">\mathbf{u}</code> and <code class="reqn">\mathbf{a}</code> are 0, the data should have mean 0 (demeaned) otherwise one is likely to be creating a structurally inadequate model (i.e. the model implies that the data have mean = 0, yet data do not have mean = 0 ).
</p>


<h3>Arguments</h3>

<p>Some arguments are common to all forms: &quot;y&quot; (data), &quot;inits&quot;, &quot;control&quot;, &quot;method&quot;, &quot;form&quot;, &quot;fit&quot;, &quot;silent&quot;, &quot;fun.kf&quot;. See <code><a href="#topic+MARSS">MARSS</a></code> for information on these arguments.
</p>
<p>In addition to these, form=&quot;dfa&quot; has some special arguments that can be passed in:
</p>

<ul>
<li> <p><code>demean</code>  Logical.  Default is TRUE, which means the data will be demeaned.
</p>
</li>
<li> <p><code>z.score</code>  Logical.  Default is TRUE, which means the data will be z-scored (demeaned and variance standardized to 1).
</p>
</li>
<li> <p><code>covariates</code>  Covariates (<code class="reqn">d</code>) for the <code class="reqn">y</code> equation. No missing values allowed and must be a matrix with the same number of time steps as the data. An unconstrained <code class="reqn">D</code> matrix will estimated.
</p>
</li></ul>

<p>The <code>model</code> argument of the <code><a href="#topic+MARSS">MARSS</a>()</code> call is constrained in terms of what parameters can be changed and how they can be changed.  See details below. An additional element, <code>m</code>, can be passed into the <code>model</code> argument that specifies the number of hidden state variables.  It is not necessarily for the user to specify <code>Z</code> as the helper function will create a <code>Z</code> appropriate for a DFA model.
</p>


<h3>Details</h3>

<p>The <code>model</code> argument is a list. The following details what list elements can be passed in:
</p>

<ul>
<li> <p><code>B</code>  &quot;Identity&quot;. The standard (and default) DFA model has B=&quot;identity&quot;. However it can be &quot;identity&quot;, &quot;diagonal and equal&quot;, &quot;diagonal and unequal&quot;  or a time-varying fixed or estimated diagonal matrix.
</p>
</li>
<li> <p><code>U</code>  &quot;Zero&quot;. Cannot be changed or passed in via model argument.
</p>
</li>
<li> <p><code>Q</code>  &quot;Identity&quot;. The standard (and default) DFA model has Q=&quot;identity&quot;. However, it can be &quot;identity&quot;, &quot;diagonal and equal&quot;, &quot;diagonal and unequal&quot; or a time-varying fixed or estimated diagonal matrix.
</p>
</li>
<li> <p><code>Z</code>  Can be passed in as a (list) matrix if the user does not want a default DFA <code>Z</code> matrix.  There are many equivalent ways to construct a DFA <code>Z</code> matrix.  The default is Zuur et al.'s form (see User Guide).
</p>
</li>
<li> <p><code>A</code>  Default=&quot;zero&quot;. Can be &quot;unequal&quot;, &quot;zero&quot; or a matrix.
</p>
</li>
<li> <p><code>R</code>  Default=&quot;diagonal and equal&quot;. Can be set to &quot;identity&quot;, &quot;zero&quot;, &quot;unconstrained&quot;, &quot;diagonal and unequal&quot;, &quot;diagonal and equal&quot;, &quot;equalvarcov&quot;, or a (list) matrix to specify general forms.
</p>
</li>
<li> <p><code>x0</code> Default=&quot;zero&quot;. Can be &quot;unconstrained&quot;, &quot;unequal&quot;, &quot;zero&quot;, or a (list) matrix.
</p>
</li>
<li> <p><code>V0</code> Default=diagonal matrix with 5 on the diagonal. Can be &quot;identity&quot;, &quot;zero&quot;, or a matrix.
</p>
</li>
<li> <p><code>tinitx</code> Default=0. Can be 0 or 1.  Tells MARSS whether x0 is at t=0 or t=1.
</p>
</li>
<li> <p><code>m</code> Default=1. Can be 1 to n (the number of y time-series). Must be integer.
</p>
</li></ul>

<p>See the <a href="https://cran.r-project.org/package=MARSS/vignettes/UserGuide.pdf">User Guide</a> chapter on Dynamic Factor Analysis for examples of of using <code>form="dfa"</code>.
</p>


<h3>Value</h3>

<p>A object of class <code><a href="#topic+marssMLE">marssMLE</a></code>.  See <code><a href="#topic+print.marssMLE">print</a>()</code> for a discussion of the various output available for <code><a href="#topic+marssMLE">marssMLE</a></code> objects (coefficients, residuals, Kalman filter and smoother output, imputed values for missing data, etc.).  See <code><a href="#topic+MARSSsimulate">MARSSsimulate</a>()</code> for simulating from <code><a href="#topic+marssMLE">marssMLE</a></code> objects. <code><a href="#topic+MARSSboot">MARSSboot</a>()</code> for bootstrapping, <code><a href="#topic+MARSSaic">MARSSaic</a>()</code> for calculation of various AIC related model selection metrics, and <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code> for calculation of confidence intervals and bias. 
</p>


<h3>Usage</h3>

<p><code>MARSS(y, 
    inits = NULL, 
    model = NULL, 
    miss.value = as.numeric(NA), 
    method = "kem", 
    form = "dfa", 
    fit = TRUE, 
    silent = FALSE, 
    control = NULL, 
    fun.kf = "MARSSkfas", 
    demean = TRUE, 
    z.score = TRUE)</code>
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA. 
</p>


<h3>References</h3>

 
<p>The MARSS User Guide:  Holmes, E. E., E. J. Ward, and M. D. Scheuerell (2012) Analysis of multivariate time-series using the MARSS package. NOAA Fisheries, Northwest Fisheries Science
Center, 2725 Montlake Blvd E., Seattle, WA 98112   Type <code>RShowDoc("UserGuide",package="MARSS")</code> to open a copy.          
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSS">MARSS</a>()</code>, <code><a href="#topic+MARSS.marxss">MARSS.marxss</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- t(harborSealWA[,-1])
# DFA with 3 states; used BFGS because it fits much faster for this model
fit &lt;- MARSS(dat, model = list(m=3), form="dfa", method="BFGS")

# See the Dynamic Factor Analysis chapter in the User Guide
RShowDoc("UserGuide", package = "MARSS")

## End(Not run)
</code></pre>

<hr>
<h2 id='MARSS.marss'> Multivariate AR-1 State-space Model  </h2><span id='topic+MARSS.marss'></span>

<h3>Description</h3>

<p>The form of MARSS models for users is &quot;marxss&quot;, the MARSS models with inputs.  See <code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code>.  In the internal algorithms (e.g. <code><a href="#topic+MARSSkem">MARSSkem</a></code>), the &quot;marss&quot; form is used and the <code class="reqn">\mathbf{D}\mathbf{d}_t</code> are incorporated into the <code class="reqn">\mathbf{a}_t</code> matrix and <code class="reqn">\mathbf{C}\mathbf{c}_t</code> are incorporated into the <code class="reqn">\mathbf{u}_t</code>. The <code class="reqn">\mathbf{a}</code> and <code class="reqn">\mathbf{u}</code> matrices then become time-varying if the model includes <code class="reqn">\mathbf{d}_t</code> and <code class="reqn">\mathbf{c}_t</code>.
</p>
<p>This is a MARSS(1) model of the marss form:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x}_{t} = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u}_t + \mathbf{G} \mathbf{w}_t, \textrm{ where } \mathbf{W}_t \sim \textrm{MVN}(0,\mathbf{Q})</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a}_t + \mathbf{H} \mathbf{v}_t, \textrm{ where } \mathbf{V}_t \sim \textrm{MVN}(0,\mathbf{R})</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{X}_1 \sim \textrm{MVN}(\mathbf{x0}, \mathbf{V0}) \textrm{ or } \mathbf{X}_0 \sim \textrm{MVN}(\mathbf{x0}, \mathbf{V0}) </code>
</p>
<p>Note, by default <code class="reqn">\mathbf{V0}</code> is a matrix of all zeros and thus <code class="reqn">\mathbf{x}_1</code> or <code class="reqn">\mathbf{x}_0</code> is treated as an estimated parameter not a diffuse prior. To remove clutter, the rest of the parameters are shown as time-constant (no <code class="reqn">t</code> subscript) but all parameters can be time-varying.
</p>
<p>Note, &quot;marss&quot; is a model form.  A model form is defined by a collection of form functions discussed in <code><a href="#topic+marssMODEL">marssMODEL</a></code>.  These functions are not exported to the user, but are called by <code><a href="#topic+MARSS">MARSS</a>()</code> using the argument <code>form</code>.  These internal functions convert the users model list into the vec form of a MARSS model and do extensive error-checking.
</p>


<h3>Details</h3>

<p>See the help page for the <code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code> form for details. 
</p>


<h3>Value</h3>

<p>A object of class <code><a href="#topic+marssMLE">marssMLE</a></code>.
</p>


<h3>Usage</h3>

<p><code>MARSS(y, 
    inits = NULL, 
    model = NULL, 
    miss.value = as.numeric(NA), 
    method = "kem", 
    form = "marxss", 
    fit = TRUE, 
    silent = FALSE, 
    control = NULL, 
    fun.kf = "MARSSkfas", 
    ...)</code>
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+MARSS.marxss">MARSS.marxss</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See the MARSS man page for examples
?MARSS

# and the Quick Examples chapter in the User Guide
RShowDoc("UserGuide", package = "MARSS")

## End(Not run)
</code></pre>

<hr>
<h2 id='MARSS.marxss'> Multivariate AR-1 State-space Model with Inputs </h2><span id='topic+MARSS.marxss'></span>

<h3>Description</h3>

<p>The argument <code>form="marxss"</code> in a <code><a href="#topic+MARSS">MARSS</a>()</code> function call specifies a MAR-1 model with eXogenous variables model.  This is a MARSS(1) model of the form:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x}_{t} = \mathbf{B}_t \mathbf{x}_{t-1} + \mathbf{u}_t + \mathbf{C}_t \mathbf{c}_t + \mathbf{G}_t \mathbf{w}_t, \textrm{ where } \mathbf{W}_t \sim \textrm{MVN}(0,\mathbf{Q}_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z}_t \mathbf{x}_t + \mathbf{a}_t + \mathbf{D}_t \mathbf{d}_t + \mathbf{H}_t \mathbf{v}_t, \textrm{ where } \mathbf{V}_t \sim \textrm{MVN}(0,\mathbf{R}_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{X}_1 \sim \textrm{MVN}(\mathbf{x0}, \mathbf{V0}) \textrm{ or } \mathbf{X}_0 \sim \textrm{MVN}(\mathbf{x0}, \mathbf{V0}) </code>
</p>

<p>Note, by default <code class="reqn">\mathbf{V0}</code> is a matrix of all zeros and thus <code class="reqn">\mathbf{x}_1</code> or <code class="reqn">\mathbf{x}_0</code> is treated as an estimated parameter not a diffuse prior.
</p>
<p>Note, &quot;marxss&quot; is a model form.  A model form is defined by a collection of form functions discussed in <code><a href="#topic+marssMODEL">marssMODEL</a></code>.  These functions are not exported to the user, but are called by <code><a href="#topic+MARSS">MARSS</a>()</code> using the argument <code>form</code>.  
</p>


<h3>Details</h3>

<p>The allowed arguments when <code>form="marxss"</code> are 1) the arguments common to all forms: &quot;y&quot; (data), &quot;inits&quot;, &quot;control&quot;, &quot;method&quot;, &quot;form&quot;, &quot;fit&quot;, &quot;silent&quot;, &quot;fun.kf&quot; (see <code><a href="#topic+MARSS">MARSS</a></code> for information on these arguments) and 2) the argument &quot;model&quot; which is a list describing the MARXSS model (the model list is described below).
See the <a href="https://cran.r-project.org/package=MARSS/vignettes/Quick_Start.html">Quick Start Guide</a> guide or the <a href="https://cran.r-project.org/package=MARSS/vignettes/UserGuide.pdf">User Guide</a> for examples.
</p>
<p>The argument <code>model</code> must be a list.  The elements in the list specify the structure for the <code class="reqn">\mathbf{B}</code>, <code class="reqn">\mathbf{u}</code>, <code class="reqn">\mathbf{C}</code>, <code class="reqn">\mathbf{c}</code>, <code class="reqn">\mathbf{Q}</code>, <code class="reqn">\mathbf{Z}</code>, <code class="reqn">\mathbf{a}</code>, <code class="reqn">\mathbf{D}</code>, <code class="reqn">\mathbf{d}</code>, <code class="reqn">\mathbf{R}</code>, <code class="reqn">\mathbf{x}_0</code>, and <code class="reqn">\mathbf{V}_0</code> in the MARXSS model (above).  The list elements can have the following values:
</p>

<dl>
<dt><code>Z</code></dt><dd><p>Default=&quot;identity&quot;.  A text string, &quot;identity&quot;,&quot;unconstrained&quot;, &quot;diagonal and unequal&quot;, &quot;diagonal and equal&quot;, &quot;equalvarcov&quot;, or &quot;onestate&quot;, or a length n vector of factors specifying which of the m hidden state time series correspond to which of the n observation time series.   May be specified as a n x m list matrix for general specification of both fixed and shared elements within the matrix.  May also be specified as a numeric n x m matrix to use a custom fixed <code class="reqn">\mathbf{Z}</code>. &quot;onestate&quot; gives a n x 1 matrix of 1s. &quot;identity&quot;,&quot;unconstrained&quot;, &quot;diagonal and unequal&quot;, &quot;diagonal and equal&quot;, and &quot;equalvarcov&quot; all specify n x n matrices.</p>
</dd>
<dt><code>B</code></dt><dd><p>Default=&quot;identity&quot;.  A text string, &quot;identity&quot;, &quot;unconstrained&quot;, &quot;diagonal and unequal&quot;, &quot;diagonal and equal&quot;, &quot;equalvarcov&quot;, &quot;zero&quot;. Can also be specified as a list matrix for general specification of both fixed and shared elements within the matrix.  May also be specified as a numeric m x m matrix to use custom fixed <code class="reqn">\mathbf{B}</code>, but in this case all the eigenvalues of <code class="reqn">\mathbf{B}</code> must fall in the unit circle.</p>
</dd>
<dt><code>U</code>, <code>x0</code></dt><dd><p>Default=&quot;unconstrained&quot;. A text string, &quot;unconstrained&quot;, &quot;equal&quot;, &quot;unequal&quot; or &quot;zero&quot;. May be specified as a m x 1 list matrix for general specification of both fixed and shared elements within the matrix. May also be specified as a numeric m x 1 matrix to use a custom fixed <code class="reqn">\mathbf{u}</code> or <code class="reqn">\mathbf{x}_0</code>. Notice that <code>U</code> is capitalized in the <code>model</code> argument and output lists.</p>
</dd>
<dt><code>A</code></dt><dd><p>Default=&quot;scaling&quot;.  A text string, &quot;scaling&quot;,&quot;unconstrained&quot;, &quot;equal&quot;, &quot;unequal&quot; or &quot;zero&quot;. May be specified as a  n x 1 list matrix for general specification of both fixed and shared elements within the matrix. May also be specified as a numeric n x 1 matrix to use a custom fixed <code class="reqn">\mathbf{a}</code>. Care must be taken when specifying <code>A</code> so that the model is not under-constrained and unsolvable model.  The default, &quot;scaling&quot;, only applies to <code class="reqn">\mathbf{Z}</code> matrices that are design matrices (only 1s and 0s and all rows sum to 1). When a column in <code class="reqn">\mathbf{Z}</code> has multiple 1s, the first row in the <code class="reqn">\mathbf{a}</code> matrix associated with those <code class="reqn">\mathbf{Z}</code> rows is 0 and the other associated <code class="reqn">\mathbf{a}</code> rows have an estimated value. This is used to treat <code class="reqn">\mathbf{a}</code> as an intercept where one intercept for each <code class="reqn">\mathbf{x}</code> (hidden state) is fixed at 0 and any other intercepts associated with that <code class="reqn">\mathbf{x}</code> have an estimated intercept.  This ensures a solvable model when <code class="reqn">\mathbf{Z}</code> is a design matrix. Note in the model argument and output, <code>A</code> is capitalized.</p>
</dd>
<dt><code>Q</code></dt><dd><p>Default=&quot;diagonal and unequal&quot;.  A text string, &quot;identity&quot;, &quot;unconstrained&quot;, &quot;diagonal and unequal&quot;, &quot;diagonal and equal&quot;, &quot;equalvarcov&quot;, &quot;zero&quot;. May be specified as a list matrix for general specification of both fixed and shared elements within the matrix.  May also be specified as a numeric g x g matrix to use a custom fixed matrix. Default value of g is m, so <code class="reqn">\mathbf{Q}</code> is a m x m matrix.  g is the number of columns in <code class="reqn">\mathbf{G}</code> (below).</p>
</dd>
<dt><code>R</code></dt><dd><p>Default=&quot;diagonal and equal&quot;.  A text string, &quot;identity&quot;, &quot;unconstrained&quot;, &quot;diagonal and unequal&quot;, &quot;diagonal and equal&quot;, &quot;equalvarcov&quot;, &quot;zero&quot;. May be specified as a list matrix for general specification of both fixed and shared elements within the matrix.  May also be specified as a numeric h x h matrix to use a custom fixed matrix. Default value of h is n, so <code class="reqn">\mathbf{R}</code> is a n x n matrix.  h is the num of columns in <code class="reqn">\mathbf{H}</code> (below).</p>
</dd>
<dt><code>V0</code></dt><dd><p>Default=&quot;zero&quot;.  A text string, &quot;identity&quot;, &quot;unconstrained&quot;, &quot;diagonal and unequal&quot;, &quot;diagonal and equal&quot;, &quot;equalvarcov&quot;, &quot;zero&quot;. May be specified as a list matrix for general specification of both fixed and shared elements within the matrix.  May also be specified as a numeric m x m matrix to use a custom fixed matrix.</p>
</dd>
<dt><code>D</code> and <code>C</code></dt><dd><p>Default=&quot;zero&quot;.  A text string, &quot;identity&quot;, &quot;unconstrained&quot;, &quot;diagonal and unequal&quot;, &quot;diagonal and equal&quot;, &quot;equalvarcov&quot;, &quot;zero&quot;. Can be specified as a list matrix for general specification of both fixed and shared elements within the matrix.  May also be specified as a numeric matrix to use custom fixed values. Must have n rows (<code class="reqn">\mathbf{D}</code>) or m rows (<code class="reqn">\mathbf{C}</code>).</p>
</dd>
<dt><code>d</code> and <code>c</code></dt><dd><p>Default=&quot;zero&quot;.  Numeric matrix.  No missing values allowed.  Must have 1 column or the same number of columns as the data, <code class="reqn">\mathbf{y}</code>.  The numbers of rows in <code class="reqn">\mathbf{d}</code> must be the same as number of columns in <code class="reqn">\mathbf{D}</code>; similarly for <code class="reqn">\mathbf{c}</code> and <code class="reqn">\mathbf{C}</code>.</p>
</dd>
<dt><code>G</code> and <code>H</code></dt><dd><p>Default=&quot;identity&quot;.  A text string, &quot;identity&quot;. Can be specified as a numeric matrix or array for time-varying cases. Must have m rows and g columns (<code class="reqn">\mathbf{G}</code>) or n rows and h columns (<code class="reqn">\mathbf{H}</code>). g is the dim of <code class="reqn">\mathbf{Q}</code> and h is the dim of <code class="reqn">\mathbf{R}</code>.</p>
</dd>
<dt><code>tinitx</code></dt><dd><p>Default=0.  Whether the initial state is specified at t=0 (default) or t=1.</p>
</dd>
</dl>
       
<p>All parameters except <code class="reqn">\mathbf{x}_0</code> and <code class="reqn">\mathbf{V}_0</code> may be time-varying.  If time-varying, then text shortcuts cannot be used.  Enter as an array with the 3rd dimension being time.   Time dimension must be 1 or equal to the number of time-steps in the data.    See Quick Start guide (<code>RShowDoc("Quick_Start",package="MARSS")</code>) or the User Guide (<code>RShowDoc("UserGuide",package="MARSS")</code>) for  examples.Valid model structures for <code>method="BFGS"</code> are the same as for <code>method="kem"</code>.  See  <code><a href="#topic+MARSSoptim">MARSSoptim</a>()</code> for the allowed options for this method.
</p>
<p>The default estimation method, <code>method="kem"</code>, is the EM algorithm described in the MARSS User Guide.  The default settings for the control and inits arguments are set via <code>MARSS:::alldefaults$kem</code> in <code>MARSSsettings.R</code>.  The defaults for the model argument are set in <code>MARSS_marxss.R</code> For this method, they are:
</p>

<ul>
<li><p>inits = list(B=1, U=0, Q=0.05, Z=1, A=0, R=0.05, x0=-99, V0=0.05, G=0, H=0, L=0, C=0, D=0, c=0, d=0)
</p>
</li>
<li><p>model = list(Z=&quot;identity&quot;, A=&quot;scaling&quot;, R=&quot;diagonal and equal&quot;, B=&quot;identity&quot;, U=&quot;unconstrained&quot;, Q=&quot;diagonal and unequal&quot;, x0=&quot;unconstrained&quot;, V0=&quot;zero&quot;, C=&quot;zero&quot;,D=&quot;zero&quot;,c=matrix(0,0,1), d=matrix(0,0,1), tinitx=0, diffuse=FALSE)
</p>
</li>
<li><p>control=list(minit=15, maxit=500, abstol=0.001, trace=0, sparse=FALSE,
safe=FALSE, allow.degen=TRUE, min.degen.iter=50, degen.lim=1.0e-04, 
min.iter.conv.test=15, conv.test.deltaT=9, conv.test.slope.tol= 0.5,  demean.states=FALSE) You can read about these in <code><a href="#topic+MARSS">MARSS</a>()</code>.  If you want to speed up your fits, you can turn off most of the model checking using <code>trace=-1</code>. 
</p>
</li>
<li><p>fun.kf = &quot;MARSSkfas&quot;; This sets the Kalman filter function to use.  <code>MARSSkfas()</code> is generally more stable as it uses Durban &amp; Koopman's algorithm.  But it may dramatically slow down when the data set is large (more than 10 rows of data).  Try the classic Kalman filter algorithm to see if it runs faster by setting <code>fun.kf="MARSSkfss"</code>. You can read about the two algorithms in <code><a href="#topic+MARSSkf">MARSSkf</a></code>.
</p>
</li></ul>

<p>For <code>method="BFGS"</code>, type  <code>MARSS:::alldefaults$BFGS</code> to see the defaults.
</p>


<h3>Value</h3>

<p>A object of class <code><a href="#topic+marssMLE">marssMLE</a></code>.  See <code><a href="#topic+print.marssMLE">print.marssMLE</a></code> for a discussion of the various output available for <code><a href="#topic+marssMLE">marssMLE</a></code> objects (coefficients, residuals, Kalman filter and smoother output, imputed values for missing data, etc.).  See <code><a href="#topic+MARSSsimulate">MARSSsimulate</a></code> for simulating from <code><a href="#topic+marssMLE">marssMLE</a></code> objects. <code><a href="#topic+MARSSboot">MARSSboot</a></code> for bootstrapping, <code><a href="#topic+MARSSaic">MARSSaic</a></code> for calculation of various AIC related model selection metrics, and <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a></code> for calculation of confidence intervals and bias. See <code><a href="#topic+plot.marssMLE">plot.marssMLE</a></code> for some default plots of a model fit.
</p>


<h3>Usage</h3>

<p><code>MARSS(y, 
    inits = NULL, 
    model = NULL, 
    miss.value = as.numeric(NA), 
    method = "kem", 
    form = "marxss", 
    fit = TRUE, 
    silent = FALSE, 
    control = NULL, 
    fun.kf = "MARSSkfas", 
    ...)</code>
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+MARSS.dfa">MARSS.dfa</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#See the MARSS man page for examples
?MARSS

#and the Quick Examples chapter in the User Guide
RShowDoc("UserGuide",package="MARSS")

## End(Not run)
</code></pre>

<hr>
<h2 id='MARSS.vectorized'> Vectorized Multivariate AR-1 State-space Model  </h2><span id='topic+MARSS.vectorized'></span>

<h3>Description</h3>

<p>The EM algorithm (<code><a href="#topic+MARSSkem">MARSSkem</a></code>) in the MARSS package works by converting the more familiar MARSS model in matrix form into the vectorized form which allows general linear constraints (Holmes 2012).  
The vectorized form is:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x}(t) = (\mathbf{x}(t-1)^\top \otimes \mathbf{I}_m)(\mathbf{f}_b(t)+\mathbf{D}_b(t)\beta) + (\mathbf{f}_u(t)+\mathbf{D}_u(t)\upsilon) + \mathbf{w}(t), \textrm{ where } \mathbf{W}(t) \sim \textrm{MVN}(0,\textbf{Q}(t))</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{y}(t) = (\mathbf{x}(t)^\top \otimes \mathbf{I}_n)(\mathbf{f}_z(t)+\mathbf{D}_z(t)\zeta) + (\mathbf{f}_a(t)+\mathbf{D}_a(t)\alpha) + \mathbf{v}(t), \textrm{ where } \mathbf{V}(t) \sim \textrm{MVN}(0,\textbf{R}(t))</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}(1) \sim \textrm{MVN}(x0, V0) \textrm{ or } \mathbf{x}(0) \sim \textrm{MVN}(x0, V0)</code>
</p>

<p>where <code class="reqn">\beta</code>, <code class="reqn">\upsilon</code>, <code class="reqn">\zeta</code>, and <code class="reqn">\alpha</code> are column vectors of estimated values, the <code class="reqn">\mathbf{f}</code> are column vectors of inputs (fixed values), and the <code class="reqn">\mathbf{D}</code> are perturbation matrices that align the estimated values into the right rows.  The <code class="reqn">\mathbf{f}</code> and <code class="reqn">\mathbf{D}</code> are potentially time-varying. <code class="reqn">\otimes</code> means kronecker product and <code class="reqn">\mathbf{I}_p</code> is a p x p identity matrix.  
</p>
<p>Normally the user will specify their model in &quot;marxss&quot; form, perhaps with text short-cuts. The &quot;marxss&quot; form is then converted to &quot;marss&quot; form using the conversion function <code>marxss_to_marss()</code>. In &quot;marss&quot; form, the D, d, C, and c information is put in A and U respectively. If there are inputs (d and c), then this will make A and U time-varying. This is unfortunate, because this slows down the EM algorithm considerably due to the unfortunate decision (early on) to store time-varying parameters as 3-dimensional. The functions for the &quot;marss&quot; form (in the file <code>MARSS_marss.R</code>) convert the &quot;marss&quot; form model into vectorized form and prepares the f (fixed) and D (free) matrices that are at the heart of the model specification.  
</p>
<p>Note, &quot;marss&quot; is a model form.  A model form is defined by a collection of form functions discussed in <code><a href="#topic+marssMODEL">marssMODEL</a></code>.  These functions are not exported to the user, but are called by <code><a href="#topic+MARSS">MARSS</a>()</code> using the argument <code>form</code>.  These internal functions convert the users model list into the vectorized form of a MARSS model and do extensive error-checking.   &quot;marxss&quot; is also a model form and these models are also stored in vectorized form (See examples below).
</p>


<h3>Details</h3>

<p>See Holmes (2012) for a discussion of MARSS models in vectorized form. 
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.
</p>


<h3>References</h3>

 
<p>Holmes, E. E. (2012).  Derivation of the EM algorithm for constrained and unconstrained multivariate autoregressive state-space (MARSS) models.  Technical Report. arXiv:1302.3919 [stat.ME]
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+MARSS.marss">MARSS.marss</a>()</code>, <code><a href="#topic+MARSS.marxss">MARSS.marxss</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4, ] 
MLEobj &lt;- MARSS(dat)

# free (D) and fixed (f) matrices
names(MLEobj$model$free)
names(MLEobj$model$fixed)
# In marss form, the D, C, d, and c matrices are found in A and U
# If there are inputs, this makes U time-varying
names(MLEobj$marss$free)
names(MLEobj$marss$fixed)

# par is in marss form so does not have values for D, C, d, or c
names(MLEobj$par)
# if you need the par in marxss form, you can use print
tmp &lt;- print(MLEobj, what="par", form="marxss", silent=TRUE)
names(tmp)

</code></pre>

<hr>
<h2 id='MARSSaic'> AIC for MARSS Models </h2><span id='topic+MARSSaic'></span>

<h3>Description</h3>

<p>Calculates AIC, AICc, a parametric bootstrap AIC (AICbp) and a non-parametric bootstrap AIC (AICbb). If you simply want the AIC value for a <code><a href="#topic+marssMLE">marssMLE</a></code> object, you can use <code>AIC(fit)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSaic(MLEobj, output = c("AIC", "AICc"), 
    Options = list(nboot = 1000, return.logL.star = FALSE, 
    silent = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSaic_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. This object must have a <code>$par</code> element containing MLE parameter estimates from e.g. <code>MARSSkem()</code>. </p>
</td></tr>
<tr><td><code id="MARSSaic_+3A_output">output</code></td>
<td>
<p> A vector containing one or more of the following: &quot;AIC&quot;, &quot;AICc&quot;, &quot;AICbp&quot;, &quot;AICbb&quot;, &quot;AICi&quot;, &quot;boot.params&quot;. See Details.</p>
</td></tr>
<tr><td><code id="MARSSaic_+3A_options">Options</code></td>
<td>
<p> A list containing:
</p>

<ul>
<li> <p><code>nboot</code>  Number of bootstraps (positive integer) 
</p>
</li>
<li> <p><code>return.logL.star</code>  Return the log-likelihoods for each bootstrap? (T/F)
</p>
</li>
<li> <p><code>silent</code>  Suppress printing of the progress bar during AIC bootstraps? (T/F)  
</p>
</li></ul>
 
</td></tr>
</table>


<h3>Details</h3>

<p>When sample size is small, Akaike's Information Criterion (AIC) under-penalizes more complex models. The most commonly used small sample size corrector is AICc, which uses a penalty term of <code class="reqn">K n/(n-K-1)</code>, where <code class="reqn">K</code> is the number of estimated parameters. However, for time series models, AICc still under-penalizes complex models; this is especially true for MARSS models.
</p>
<p>Two small-sample estimators specific for MARSS models have been developed. Cavanaugh and Shumway (1997) developed a variant of bootstrapped AIC using Stoffer and Wall's (1991) bootstrap algorithm (&quot;AICbb&quot;). Holmes and Ward (2010) developed a variant on AICb (&quot;AICbp&quot;) using a parametric bootstrap. The parametric bootstrap permits AICb calculation when there are missing values in the data, which Cavanaugh and Shumway's algorithm does not allow. More recently, Bengtsson and Cavanaugh (2006) developed another small-sample AIC estimator, AICi, based on fitting candidate models to multivariate white noise.
</p>
<p>When the <code>output</code> argument passed in includes both <code>"AICbp"</code> and <code>"boot.params"</code>, the bootstrapped parameters from <code>"AICbp"</code> will be added to <code>MLEobj</code>.  
</p>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+marssMLE">marssMLE</a></code> object that was passed in with additional AIC components added on top as specified in the 'output' argument.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.
</p>


<h3>References</h3>

<p>Holmes, E. E., E. J. Ward, and M. D. Scheuerell (2012) Analysis of multivariate time-series using the MARSS package. NOAA Fisheries, Northwest Fisheries Science
Center, 2725 Montlake Blvd E., Seattle, WA 98112   Type <code>RShowDoc("UserGuide",package="MARSS")</code> to open a copy.
</p>
<p>Bengtsson, T., and J. E. Cavanaugh. 2006. An improved Akaike information criterion for state-space model selection. Computational Statistics &amp; Data Analysis 50:2635-2654.
</p>
<p>Cavanaugh, J. E., and R. H. Shumway. 1997. A bootstrap variant of AIC for state-space model selection. Statistica Sinica 7:473-496.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSboot">MARSSboot</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSealWA)
dat &lt;- dat[2:3, ]
kem &lt;- MARSS(dat, model = list(
  Z = matrix(1, 2, 1),
  R = "diagonal and equal"
))
kemAIC &lt;- MARSSaic(kem, output = c("AIC", "AICc"))
</code></pre>

<hr>
<h2 id='MARSSapplynames'> Names for marssMLE Object Components </h2><span id='topic+MARSSapplynames'></span>

<h3>Description</h3>

<p>Puts names on the par, start, par.se, init components of <code><a href="#topic+marssMLE">marssMLE</a></code> objects.  This is a utility function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code> and is not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSapplynames(MLEobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSapplynames_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The X.names and Y.names are attributes of <code><a href="#topic+marssMODEL">marssMODEL</a></code> objects (which would be in <code>$marss</code> and <code>$model</code> in the <code><a href="#topic+marssMLE">marssMLE</a></code> object).  These names are applied to the par elements in the <code><a href="#topic+marssMLE">marssMLE</a></code> object.
</p>


<h3>Value</h3>

<p>The object passed in, with row and column names on matrices as specified.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+marssMLE">marssMLE</a></code>, <code><a href="#topic+marssMODEL">marssMODEL</a></code> </p>

<hr>
<h2 id='MARSSboot'> Bootstrap MARSS Parameter Estimates </h2><span id='topic+MARSSboot'></span>

<h3>Description</h3>

<p>Creates bootstrap parameter estimates and simulated (or bootstrapped) data (if appropriate).  This is a base function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSboot(MLEobj, nboot = 1000, 
    output = "parameters", sim = "parametric", 
    param.gen = "MLE", control = NULL, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSboot_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. Must have a <code>$par</code> element containing MLE parameter estimates. </p>
</td></tr>
<tr><td><code id="MARSSboot_+3A_nboot">nboot</code></td>
<td>
<p> Number of bootstraps to perform. </p>
</td></tr>
<tr><td><code id="MARSSboot_+3A_output">output</code></td>
<td>
<p> Output to be returned: &quot;data&quot;, &quot;parameters&quot; or &quot;all&quot;.</p>
</td></tr> 
<tr><td><code id="MARSSboot_+3A_sim">sim</code></td>
<td>
<p> Type of bootstrap: &quot;parametric&quot; or &quot;innovations&quot;. See Details. </p>
</td></tr>
<tr><td><code id="MARSSboot_+3A_param.gen">param.gen</code></td>
<td>
<p> Parameter generation method: &quot;hessian&quot; or &quot;MLE&quot;. </p>
</td></tr> 
<tr><td><code id="MARSSboot_+3A_control">control</code></td>
<td>
<p> The options in <code>MLEobj$control</code> are used by default. If supplied here, must contain all of the following:
</p>

<dl>
<dt><code>max.iter</code></dt><dd><p> Maximum number of EM iterations. </p>
</dd> 
<dt><code>tol</code></dt><dd><p> Optional tolerance for log-likelihood change.  If log-likelihood decreases less than this amount relative to the previous iteration, the EM algorithm exits. </p>
</dd> 
<dt><code>allow.degen</code></dt><dd><p> Whether to try setting <code class="reqn">\mathbf{Q}</code> or <code class="reqn">\mathbf{R}</code> elements to zero if they appear to be going to zero. </p>
</dd>  
</dl>
 
</td></tr>
<tr><td><code id="MARSSboot_+3A_silent">silent</code></td>
<td>
<p> Suppresses printing of progress bar. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Approximate confidence intervals (CIs) on the model parameters can be calculated by the observed Fisher Information matrix (the Hessian of the negative log-likelihood function).  The Hessian CIs (<code>param.gen="hessian"</code>) are based on the asymptotic normality of ML estimates under a large-sample approximation. CIs that are not based on asymptotic theory can be calculated using parametric and non-parametric bootstrapping (<code>param.gen="MLE"</code>).  In this case, parameter estimates are generated by the ML estimates from each bootstrapped data set.  The MLE method (kem or BFGS) is determined by <code>MLEobj$method</code>.
</p>
<p>Stoffer and Wall (1991) present an algorithm for generating CIs via a non-parametric bootstrap for state-space models (<code>sim = "innovations"</code>).  The basic idea is that the Kalman filter can be used to generate estimates of the residuals of the model fit.  These residuals are then standardized and resampled and used to generate bootstrapped data using the MARSS model and its maximum-likelihood parameter estimates.  One of the limitations of the Stoffer and Wall algorithm is that it cannot be used when there are missing data, unless all data at time <code class="reqn">t</code> are missing.  An alternative approach is a parametric bootstrap (<code>sim = "parametric"</code>), in which the ML parameter estimates are used to produce bootstrapped data directly from the state-space model.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>boot.params</code></td>
<td>
<p> Matrix (number of params x nboot) of parameter estimates from the bootstrap. </p>
</td></tr>
<tr><td><code>boot.data</code></td>
<td>
<p> Array (n x t x nboot) of simulated (or bootstrapped) data (if requested and appropriate). </p>
</td></tr>
<tr><td><code>marss</code></td>
<td>
<p> The <code><a href="#topic+marssMODEL">marssMODEL</a></code> object (form=&quot;marss&quot;) that was passed in via <code>MLEobj$marss</code>. </p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p> Number of bootstraps performed. </p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p> Type of output returned.</p>
</td></tr> 
<tr><td><code>sim</code></td>
<td>
<p> Type of bootstrap. </p>
</td></tr>
<tr><td><code>param.gen</code></td>
<td>
<p> Parameter generation method: &quot;hessian&quot; or &quot;KalmanEM&quot;.  </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes and Eric Ward, NOAA, Seattle, USA.
</p>


<h3>References</h3>

 
<p>Holmes, E. E., E. J. Ward, and M. D. Scheuerell (2012) Analysis of multivariate time-series using the MARSS package. NOAA Fisheries, Northwest Fisheries Science
Center, 2725 Montlake Blvd E., Seattle, WA 98112   Type <code>RShowDoc("UserGuide",package="MARSS")</code> to open a copy.
</p>
<p>Stoffer, D. S., and K. D. Wall. 1991. Bootstrapping state-space models: Gaussian maximum likelihood estimation and the Kalman filter. Journal of the American Statistical Association 86:1024-1033.
</p>
<p>Cavanaugh, J. E., and R. H. Shumway. 1997. A bootstrap variant of AIC for state-space model selection. Statistica Sinica 7:473-496.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+marssMLE">marssMLE</a></code>,  <code><a href="#topic+marssMODEL">marssMODEL</a></code>,  <code><a href="#topic+MARSSaic">MARSSaic</a>()</code>, <code><a href="#topic+MARSShessian">MARSShessian</a>()</code>, <code><a href="#topic+MARSSFisherI">MARSSFisherI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># nboot is set low in these examples in order to run quickly
# normally nboot would be &gt;1000 at least
dat &lt;- t(kestrel)
dat &lt;- dat[2:3, ]
# maxit set low to speed up the example
kem &lt;- MARSS(dat,
  model = list(U = "equal", Q = diag(.01, 2)),
  control = list(maxit = 50)
)
# bootstrap parameters from a Hessian matrix
hess.list &lt;- MARSSboot(kem, param.gen = "hessian", nboot = 4)

# from resampling the innovations (no missing values allowed)
boot.innov.list &lt;- MARSSboot(kem, output = "all", sim = "innovations", nboot = 4)

# bootstrapped parameter estimates
hess.list$boot.params
</code></pre>

<hr>
<h2 id='MARSScv'>MARSScv is a wrapper for MARSS that re-fits the model with cross validated data.</h2><span id='topic+MARSScv'></span>

<h3>Description</h3>

<p>MARSScv is a wrapper for MARSS that re-fits the model with cross validated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSScv(
  y,
  model = NULL,
  inits = NULL,
  method = "kem",
  form = "marxss",
  silent = FALSE,
  control = NULL,
  fun.kf = c("MARSSkfas", "MARSSkfss"),
  fold_ids = NULL,
  future_cv = FALSE,
  n_future_cv = floor(ncol(y)/3),
  interval = "confidence",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSScv_+3A_y">y</code></td>
<td>
<p>A n x T matrix of n time series over T time steps. Only y
is required for the function. A ts object (univariate or multivariate)
can be used and this will be converted to a matrix with time in the
columns.</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_model">model</code></td>
<td>
<p>Model specification using a list of parameter matrix text shortcuts or matrices.
See Details and <code><a href="#topic+MARSS.marxss">MARSS.marxss()</a></code> for the default form.
Or better yet open the Quick Start Guide <code>RShowDoc("Quick_Start",package="MARSS")</code></p>
</td></tr>
<tr><td><code id="MARSScv_+3A_inits">inits</code></td>
<td>
<p>A list with the same form as the list output by <code>coef(fit)</code>
that specifies initial values for the parameters. See also <code><a href="#topic+MARSS.marxss">MARSS.marxss()</a></code>.</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_method">method</code></td>
<td>
<p>Estimation method. MARSS provides an EM algorithm (<code>method="kem"</code>)
(see <code><a href="#topic+MARSSkem">MARSSkem()</a></code>) and the BFGS algorithm (<code>method="BFGS"</code>)
(see <code><a href="#topic+MARSSoptim">MARSSoptim()</a></code>). Fast TMB fitting provided by the companion package marssTMB.</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_form">form</code></td>
<td>
<p>The equation form used in the <code>MARSS()</code> call.  The default is &quot;marxss&quot;.
See <code><a href="#topic+MARSS.marxss">MARSS.marxss()</a></code> or <code><a href="#topic+MARSS.dfa">MARSS.dfa()</a></code></p>
</td></tr>
<tr><td><code id="MARSScv_+3A_silent">silent</code></td>
<td>
<p>Setting to TRUE(1) suppresses printing of full error messages, warnings,
progress bars and convergence information. Setting to FALSE(0) produces
error output. Setting silent=2 will produce more verbose error messages and
progress information.</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_control">control</code></td>
<td>
<p>Estimation options for the maximization algorithm. The typically used
control options for method=&quot;kem&quot; are below but see  <a href="#topic+marssMLE">marssMLE</a> for the full
list of control options.  Note many of these are not allowed if method=&quot;BFGS&quot;;
see  <code><a href="#topic+MARSSoptim">MARSSoptim()</a></code> for the allowed control options for this method.</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_fun.kf">fun.kf</code></td>
<td>
<p>What Kalman filter function to use.  MARSS has two:
<code><a href="#topic+MARSSkfas">MARSSkfas()</a></code> which is based on the Kalman filter in the
<a href="https://cran.r-project.org/package=KFAS">KFAS</a> package based on
Koopman and Durbin and <code><a href="#topic+MARSSkfss">MARSSkfss()</a></code> which is a native
R implementation of the Kalman filter and smoother in Shumway and
Stoffer. The KFAS filter is much faster.  <code><a href="#topic+MARSSkfas">MARSSkfas()</a></code>
modifies the input and output in order to output the lag-one covariance
smoother needed for the EM algorithm (per page 321 in Shumway and Stoffer (2000).</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_fold_ids">fold_ids</code></td>
<td>
<p>A n x T matrix of integers, with values assigned by the user to folds.
If not included, data are randomly assigned to one of 10 folds</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_future_cv">future_cv</code></td>
<td>
<p>Whether or not to use future cross validation (defaults to FALSE), where data up to
time T-1 are used to predict data at time T. Data are held out by time slices, and
the <code>fold_ids</code> argument is ignored.</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_n_future_cv">n_future_cv</code></td>
<td>
<p>Number of time slices to hold out for future cross validation. Defaults
to floor(n_future_cv/3). Predictions are made for the last n_future_cv time steps</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_interval">interval</code></td>
<td>
<p>uncertainty interval for prediction. Can be one of &quot;confidence&quot; or &quot;prediction&quot;,
and defaults to &quot;confidence&quot;</p>
</td></tr>
<tr><td><code id="MARSScv_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, containing <code>cv_pred</code> (a matrix of predictions), <code>cv_se</code> (a matrix of SEs),
<code>fold_ids</code> (a matrix of fold ids used as data), and <code>df</code> (a dataframe containing
the original data, predictions, SEs, and folds)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4, ] # remove the year row
# fit a model with 1 hidden state and 3 observation time series
# cross validation here is random, 10 folds
fit &lt;- MARSScv(dat, model = list(
  Z = matrix(1, 3, 1),
  R = "diagonal and equal"
))

# second, demonstrate passing in pre-specified folds
fold_ids &lt;- matrix(
  sample(1:5, size = nrow(dat) * ncol(dat), replace = TRUE),
  nrow(dat), ncol(dat)
)
fit &lt;- MARSScv(dat, model = list(
  Z = matrix(1, 3, 1),
  R = "diagonal and equal"
), fold_ids = fold_ids)

# third, illustrate future cross validation
fit &lt;- MARSScv(dat, model = list(
  Z = matrix(1, 3, 1),
  R = "diagonal and equal"
), future_cv = TRUE, n_future_cv = 5)

</code></pre>

<hr>
<h2 id='MARSSFisherI'> Observed Fisher Information Matrix at the MLE </h2><span id='topic+MARSSFisherI'></span>

<h3>Description</h3>

<p>Returns the observed Fisher Information matrix for a <code><a href="#topic+marssMLE">marssMLE</a></code> object (a fitted MARSS model) via either the analytical algorithm of Harvey (1989) or a numerical estimate. 
</p>
<p>The observed Fisher Information is the negative of the second-order partial derivatives of the log-likelihood function evaluated at the MLE. The derivatives being with respect to the parameters. The Hessian matrix is the second-order partial derivatives of a scalar-valued function. Thus the observed Fisher Information matrix is the Hessian of the negative log-likelihood function evaluated at the MLE (or equivalently the negative of the Hessian of the log-likelihood function). The inverse of the observed Fisher Information matrix is an estimate of the asymptotic variance-covariance matrix for the estimated parameters. Use <code><a href="#topic+MARSShessian">MARSShessian</a>()</code> (which calls <code>MARSSFisherI()</code>) to return the parameter variance-covariance matrix computed from the observed Fisher Information matrix.
</p>
<p>Note for the numerically estimated Hessian, we pass in the negative log-likelihood function to a minimization function. As a result, the numerical functions return the Hessian of the negative log-likelihood function (which is the observed Fisher Information matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSFisherI(MLEobj, method = c("Harvey1989", "fdHess", "optim"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSFisherI_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. 
This object must have a <code>$par</code> element containing MLE parameter estimates from e.g. <code><a href="#topic+MARSSkem">MARSSkem</a>()</code>. </p>
</td></tr>
<tr><td><code id="MARSSFisherI_+3A_method">method</code></td>
<td>
<p> The method to use for computing the observed Fisher Information matrix. Options are <code>"Harvey1989"</code> to use the Harvey (1989) recursion, which is an analytical solution, <code>"fdHess"</code> or <code>"optim"</code> which are two numerical methods.  Although 'optim' can be passed to the function, 'fdHess' is used for all numerical estimates used in the MARSS package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method 'fdHess' uses <code><a href="nlme.html#topic+fdHess">fdHess</a>()</code> from package <code><a href="nlme.html#topic+nlme">nlme</a></code> to numerically estimate the Hessian of the negative log-likelihood function at the MLEs. Method 'optim' uses <code><a href="stats.html#topic+optim">optim</a>()</code> with <code>hessian=TRUE</code> and <code>list(maxit=0)</code> to ensure that the Hessian is computed at the values in the <code>par</code> element of the MLE object. The <code>par</code> element of the <code><a href="#topic+marssMLE">marssMLE</a></code> object is the MLE.  
</p>
<p>Method 'Harvey1989' (the default) uses the recursion in Harvey (1989) to compute the observed Fisher Information of a MARSS model analytically. See Holmes (2016c) for a discussion of the Harvey (1989) algorithm and see Holmes (2017) on how to implement the algorithm for MARSS models with linear constraints (the type of MARSS models that the MARSS R package addresses).
</p>
<p>There has been research on computing the observed Fisher Information matrix from the derivatives used by EM algorithms (discussed in Holmes (2016a, 2016b)), for example Louis (1982). Unfortunately, the EM algorithm used in the MARSS package is for time series data and the temporal correlation must be dealt with, e.g. Duan &amp; Fulop (2011). Oakes (1999) has an approach that only involves derivatives of <code class="reqn">\textrm{E}[LL(\Theta)|\mathbf{y},\Theta']</code> but one of the derivatives will be the derivative of the <code class="reqn">\textrm{E}[\mathbf{X}|\mathbf{y},\Theta']</code> with respect to <code class="reqn">\Theta'</code>.  It is not clear how to do that derivative.  Moon-Ho, Shumway and Ombao (2006) suggest (page 157) that this derivative is hard to compute.
</p>


<h3>Value</h3>

<p>Returns the observed Fisher Information matrix.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

 
<p>Harvey, A. C. (1989) Section 3.4.5 (Information matrix) in Forecasting, structural time series models and the Kalman filter. Cambridge University Press, Cambridge, UK.
</p>
<p>See also J. E. Cavanaugh and R. H. Shumway (1996) On computing the expected Fisher information matrix for state-space model parameters. Statistics &amp; Probability Letters 26: 347-355.  This paper discusses the Harvey (1989) recursion (and proposes an alternative).
</p>
<p>Holmes, E. E. 2016a. Notes on computing the Fisher Information matrix for MARSS models. Part I Background. Technical Report. https://doi.org/10.13140/RG.2.2.27306.11204/1  <a href="https://eeholmes.github.io/posts/2016-5-18-FI-recursion-1/">Notes</a>
</p>
<p>Holmes, E. E. 2016b. Notes on computing the Fisher Information matrix for MARSS models. Part II Louis 1982. Technical Report. https://doi.org/10.13140/RG.2.2.35694.72000  <a href="https://eeholmes.github.io/posts/2016-5-19-FI-recursion-2/">Notes</a>
</p>
<p>Holmes, E. E. 2016c. Notes on computing the Fisher Information matrix for MARSS models. Part III Overview of Harvey 1989. https://eeholmes.github.io/posts/2016-6-16-FI-recursion-3/
</p>
<p>Holmes, E. E. 2017. Notes on computing the Fisher Information matrix for MARSS models. Part IV Implementing the Recursion in Harvey 1989. https://eeholmes.github.io/posts/2017-5-31-FI-recursion-4/
</p>
<p>Duan, J. C. and A. Fulop. (2011) A stable estimator of the information matrix under EM for dependent data. Statistics and Computing 21: 83-91
</p>
<p>Louis, T. A. 1982. Finding the observed information matrix when using the EM algorithm. Journal of the Royal Statistical Society. Series B (Methodological). 44: 226-233.
</p>
<p>Oakes, D. 1999. Direct calculation of the information matrix via the EM algorithm. Journal of the Royal Statistical Society. Series B (Methodological). 61: 479-482.
</p>
<p>Moon-Ho, R. H., R. H. Shumway, and Ombao 2006. The state-space approach to modeling dynamic processes. Chapter 7 in Models for Intensive Longitudinal Data. Oxford University Press.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSharveyobsFI">MARSSharveyobsFI</a>()</code>, <code><a href="#topic+MARSShessian.numerical">MARSShessian.numerical</a></code>, <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a></code>, <code><a href="#topic+marssMLE">marssMLE</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[2:4, ]
MLEobj &lt;- MARSS(dat, model=list(Z=matrix(1,3,1), R="diagonal and equal"))
MARSSFisherI(MLEobj)
MARSSFisherI(MLEobj, method="fdHess")

</code></pre>

<hr>
<h2 id='MARSSfit'>Generic for fitting MARSS models</h2><span id='topic+MARSSfit'></span>

<h3>Description</h3>

<p>This is an internal function used by <code><a href="#topic+MARSS">MARSS()</a></code>. It is not
intended for use by users but needs to be exported so
the marssTMB package can use it. Uses the method of a marssMLE class object.
Will call a function such as <code><a href="#topic+MARSSkem">MARSSkem()</a></code>, <code><a href="#topic+MARSSoptim">MARSSoptim()</a></code> in the
MARSS package or <code>MARSStmb()</code> in the marssTMB package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSfit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSfit_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+marssMLE">marssMLE</a> object.</p>
</td></tr>
<tr><td><code id="MARSSfit_+3A_...">...</code></td>
<td>
<p>additional arguments for the fitting function</p>
</td></tr>
</table>

<hr>
<h2 id='MARSSharveyobsFI'> Hessian Matrix via the Harvey (1989) Recursion</h2><span id='topic+MARSSharveyobsFI'></span>

<h3>Description</h3>

<p>Calculates the observed Fisher Information analytically via the recursion by Harvey (1989) as adapted by Holmes (2017) for MARSS models with linear constraints.  This is the same as the Hessian of the negative log-likelihood function at the MLEs.  This is a utility function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code> and is not exported.  Use <code><a href="#topic+MARSShessian">MARSShessian</a>()</code> to access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSharveyobsFI(MLEobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSharveyobsFI_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. 
This object must have a <code>$par</code> element containing MLE parameter estimates from e.g. <code><a href="#topic+MARSSkem">MARSSkem</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The observed Fisher Information matrix computed via equation 3.4.69 in Harvey (1989).  The differentials in the equation are computed in the recursion in equations 3.4.73a to 3.4.74b.  See Holmes (2016c) for a discussion of the Harvey (1989) algorithm and Holmes (2017) for the specific implementation of the algorithm for MARSS models with linear constraints. 
</p>
<p>Harvey (1989) discusses missing observations in section 3.4.7.  However, the <code>MARSSharveyobsFI()</code> function implements the approach of Shumway and Stoffer (2006) in section 6.4 for the missing values.  See Holmes (2012) for a full discussion of the missing values modifications.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

 
<p>R. H. Shumway and D. S. Stoffer (2006).  Section 6.4 (Missing Data Modifications) in Time series analysis and its applications.  Springer-Verlag, New York.
</p>
<p>Harvey, A. C. (1989) Section 3.4.5 (Information matrix) in Forecasting, structural time series models and the Kalman filter. Cambridge University Press, Cambridge, UK.
</p>
<p>See also J. E. Cavanaugh and R. H. Shumway (1996) On computing the expected Fisher information matrix for state-space model parameters. Statistics &amp; Probability Letters 26: 347-355.  This paper discusses the Harvey (1989) recursion (and proposes an alternative).
</p>
<p>Holmes, E. E. (2012).  Derivation of the EM algorithm for constrained and unconstrained multivariate autoregressive state-space (MARSS) models.  Technical Report. arXiv:1302.3919 [stat.ME]
</p>
<p>Holmes, E. E. 2016c. Notes on computing the Fisher Information matrix for MARSS models. Part III Overview of Harvey 1989. https://eeholmes.github.io/posts/2016-6-16-FI-recursion-3/
</p>
<p>Holmes, E. E. 2017. Notes on computing the Fisher Information matrix for MARSS models. Part IV Implementing the Recursion in Harvey 1989. https://eeholmes.github.io/posts/2017-5-31-FI-recursion-4/
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSShessian">MARSShessian</a>()</code>, <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11), ]
fit &lt;- MARSS(dat)
MARSS:::MARSSharveyobsFI(fit)
</code></pre>

<hr>
<h2 id='MARSShatyt'> Compute Expected Value of Y, YY, and YX</h2><span id='topic+MARSShatyt'></span>

<h3>Description</h3>

<p>Computes the expected value of random variables involving <code class="reqn">\mathbf{Y}</code>.  Users can use <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code> or <code>print( MLEobj, what="Ey")</code> to access this output.  See <code><a href="#topic+print.marssMLE">print.marssMLE</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSShatyt(MLEobj, only.kem = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSShatyt_+3A_mleobj">MLEobj</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object with the <code>par</code> element of estimated parameters, <code>model</code> element with the model description and data. </p>
</td></tr>
<tr><td><code id="MARSShatyt_+3A_only.kem">only.kem</code></td>
<td>
<p> If TRUE, return only <code>ytT</code>, <code>OtT</code>, <code>yxtT</code>, and <code>yxttpT</code> (values conditioned on the data from <code class="reqn">1:T</code>) needed for the EM algorithm.  If <code>only.kem=FALSE</code>, then also return values conditioned on data from 1 to <code class="reqn">t-1</code> (<code>Ott1</code> and <code>ytt1</code>) and 1 to <code class="reqn">t</code> (<code>Ott</code> and <code>ytt</code>), <code>yxtt1T</code> (<code class="reqn">\textrm{var}[\mathbf{Y}_t, \mathbf{X}_{t-1}|\mathbf{y}_{1:T}]</code>), var.ytT (<code class="reqn">\textrm{var}[\mathbf{Y}_t|\mathbf{y}_{1:T}]</code>), and var.EytT (<code class="reqn">\textrm{var}_X[E_{Y|x}[\mathbf{Y}_t|\mathbf{y}_{1:T},\mathbf{x}_t]]</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For state space models, <code>MARSShatyt()</code> computes the expectations involving <code class="reqn">\mathbf{Y}</code>.  If <code class="reqn">\mathbf{Y}</code> is completely observed, this entails simply replacing <code class="reqn">\mathbf{Y}</code> with the observed <code class="reqn">\mathbf{y}</code>.  When <code class="reqn">\mathbf{Y}</code> is only partially observed, the expectation involves the conditional expectation of a multivariate normal. 
</p>


<h3>Value</h3>

 
<p>A list with the following components (n is the number of state processes). Following the notation in Holmes (2012), <code class="reqn">\mathbf{y}(1)</code> is the observed data (for <code class="reqn">t=1:T</code>) while <code class="reqn">\mathbf{y}(2)</code> is the unobserved data.  <code class="reqn">\mathbf{y}(1,1:t-1)</code> is the observed data from time 1 to <code class="reqn">t-1</code>.
</p>
<table>
<tr><td><code>ytT</code></td>
<td>
<p> E[Y(t) | Y(1,1:T)=y(1,1:T)] (n x T matrix). </p>
</td></tr>
<tr><td><code>ytt1</code></td>
<td>
<p> E[Y(t) | Y(1,1:t-1)=y(1,1:t-1)] (n x T matrix). </p>
</td></tr>
<tr><td><code>ytt</code></td>
<td>
<p> E[Y(t) | Y(1,1:t)=y(1,1:t)] (n x T matrix). </p>
</td></tr>
<tr><td><code>OtT</code></td>
<td>
<p> E[Y(t) t(Y(t)) | Y(1,1:T)=y(1,1:T)] (n x n x T array). </p>
</td></tr>
<tr><td><code>var.ytT</code></td>
<td>
<p> var[Y(t) | Y(1,1:T)=y(1,1:T)] (n x n x T array). </p>
</td></tr>
<tr><td><code>var.EytT</code></td>
<td>
<p> var_X[E_Y[Y(t) | Y(1,1:T)=y(1,1:T), X(t)=x(t)]] (n x n x T array). </p>
</td></tr>
<tr><td><code>Ott1</code></td>
<td>
<p>  E[Y(t) t(Y(t)) | Y(1,1:t-1)=y(1,1:t-1)] (n x n x T array). </p>
</td></tr>
<tr><td><code>var.ytt1</code></td>
<td>
<p> var[Y(t) | Y(1,1:t-1)=y(1,1:t-1)] (n x n x T array). </p>
</td></tr>
<tr><td><code>var.Eytt1</code></td>
<td>
<p> var_X[E_Y[Y(t) | Y(1,1:t-1)=y(1,1:t-1), X(t)=x(t)]] (n x n x T array). </p>
</td></tr>
<tr><td><code>Ott</code></td>
<td>
<p> E[Y(t) t(Y(t)) | Y(1,1:t)=y(1,1:t)] (n x n x T array). </p>
</td></tr>
<tr><td><code>yxtT</code></td>
<td>
<p> E[Y(t) t(X(t)) | Y(1,1:T)=y(1,1:T)] (n x m x T array). </p>
</td></tr>
<tr><td><code>yxtt1T</code></td>
<td>
<p> E[Y(t) t(X(t-1)) | Y(1,1:T)=y(1,1:T)] (n x m x T array). </p>
</td></tr>
<tr><td><code>yxttpT</code></td>
<td>
<p> E[Y(t) t(X(t+1)) | Y(1,1:T)=y(1,1:T)] (n x m x T array). </p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p> Any error messages due to ill-conditioned matrices. </p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p> (TRUE/FALSE) Whether errors were generated. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>Holmes, E. E. (2012) Derivation of the EM algorithm for constrained and unconstrained multivariate autoregressive state-space (MARSS) models. Technical report. arXiv:1302.3919 [stat.ME] Type <code>RShowDoc("EMDerivation",package="MARSS")</code> to open a copy. See the section on 'Computing the expectations in the update equations' and the subsections on expectations involving Y. 
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+MARSS">MARSS</a>()</code>, <code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+MARSSkem">MARSSkem</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[2:3, ]
fit &lt;- MARSS(dat)
EyList &lt;- MARSShatyt(fit)
</code></pre>

<hr>
<h2 id='MARSShessian'> Parameter Variance-Covariance Matrix from the Hessian Matrix</h2><span id='topic+MARSShessian'></span>

<h3>Description</h3>

<p>Calculates an approximate parameter variance-covariance matrix for the parameters using an inverse of the Hessian of the negative log-likelihood function at the MLEs (the observed Fisher Information matrix).   It appends <code>$Hessian</code>, <code>$parMean</code>, <code>$parSigma</code> to the <code><a href="#topic+marssMLE">marssMLE</a></code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSShessian(MLEobj, method=c("Harvey1989", "fdHess", "optim"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSShessian_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. 
This object must have a <code>$par</code> element containing MLE parameter estimates from e.g. <code><a href="#topic+MARSSkem">MARSSkem</a></code>. </p>
</td></tr>
<tr><td><code id="MARSShessian_+3A_method">method</code></td>
<td>
<p> The method to use for computing the Hessian. Options are <code>Harvey1989</code> to use the Harvey (1989) recursion, which is an analytical solution, <code>fdHess</code> or <code>optim</code> which are two numerical methods.  Although <code>optim</code> can be passed to this function, in the internal functions which call this function, <code>fdHess</code> will be used if a numerical estimate is requested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+MARSSFisherI">MARSSFisherI</a></code> for a discussion of the observed Fisher Information matrix and references.
</p>
<p>Method <code>fdHess</code> uses <code><a href="nlme.html#topic+fdHess">fdHess</a></code> from package nlme to numerically estimate the Hessian matrix (the matrix of partial 2nd derivatives of the negative log-likelihood function at the MLE).     Method <code>optim</code> uses <code><a href="stats.html#topic+optim">optim</a></code> with <code>hessian=TRUE</code> and <code>list(maxit=0)</code> to ensure that the Hessian is computed at the values in the <code>par</code> element of the MLE object. Method <code>Harvey1989</code> (the default) uses the recursion in Harvey (1989) to compute the observed Fisher Information of a MARSS model analytically.
</p>
<p>Note that the parameter confidence intervals computed with the observed Fisher Information matrix are based on the asymptotic normality of maximum-likelihood estimates under a large-sample approximation. 
</p>


<h3>Value</h3>

<p><code>MARSShessian()</code> attaches 
<code>Hessian</code>, <code>parMean</code> and <code>parSigma</code> to the <code><a href="#topic+marssMLE">marssMLE</a></code> object that is passed into the function.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

 
<p>Harvey, A. C. (1989) Section 3.4.5 (Information matrix) in Forecasting, structural time series models and the Kalman filter. Cambridge University Press, Cambridge, UK.
</p>
<p>See also J. E. Cavanaugh and R. H. Shumway (1996) On computing the expected Fisher information matrix for state-space model parameters. Statistics &amp; Probability Letters 26: 347-355.  This paper discusses the Harvey (1989) recursion (and proposes an alternative).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSFisherI">MARSSFisherI</a>()</code>, <code><a href="#topic+MARSSharveyobsFI">MARSSharveyobsFI</a>()</code>, <code><a href="#topic+MARSShessian.numerical">MARSShessian.numerical</a>()</code>, <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code>, <code><a href="#topic+marssMLE">marssMLE</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11), ]
MLEobj &lt;- MARSS(dat)
MLEobj.hessian &lt;- MARSShessian(MLEobj)

# show the approx Hessian
MLEobj.hessian$Hessian

# generate a parameter sample using the Hessian
# this uses the rmvnorm function in the mvtnorm package
hess.params &lt;- mvtnorm::rmvnorm(1,
  mean = MLEobj.hessian$parMean,
  sigma = MLEobj.hessian$parSigma
)
</code></pre>

<hr>
<h2 id='MARSShessian.numerical'> Hessian Matrix via Numerical Approximation</h2><span id='topic+MARSShessian.numerical'></span>

<h3>Description</h3>

<p>Calculates the Hessian of the log-likelihood function at the MLEs using either the  <code><a href="nlme.html#topic+fdHess">fdHess</a></code> function in the  nlme package or the  <code><a href="stats.html#topic+optim">optim</a></code> function.  This is a utility function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code> and is not exported.  Use <code><a href="#topic+MARSShessian">MARSShessian</a></code> to access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSShessian.numerical(MLEobj, fun=c("fdHess", "optim"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSShessian.numerical_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. 
This object must have a <code>$par</code> element containing MLE parameter estimates from e.g. <code><a href="#topic+MARSSkem">MARSSkem</a></code>. </p>
</td></tr>
<tr><td><code id="MARSShessian.numerical_+3A_fun">fun</code></td>
<td>
<p> The function to use for computing the Hessian. Options are 'fdHess' or 'optim'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method <code>fdHess</code> uses <code><a href="nlme.html#topic+fdHess">fdHess</a></code> from package nlme to numerically estimate the Hessian matrix (the matrix of partial 2nd derivatives) of the negative log-likelihood function with respect to the parameters.   Method <code>optim</code> uses <code><a href="stats.html#topic+optim">optim</a></code> with <code>hessian=TRUE</code> and <code>list(maxit=0)</code> to ensure that the Hessian is computed at the values in the <code>par</code> element of the MLE object.
</p>


<h3>Value</h3>

<p>The numerically estimated Hessian of the log-likelihood function at the maximum likelihood estimates.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSharveyobsFI">MARSSharveyobsFI</a>()</code>, <code><a href="#topic+MARSShessian">MARSShessian</a>()</code>, <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11), ]
MLEobj &lt;- MARSS(dat)
MARSS:::MARSShessian.numerical(MLEobj)
</code></pre>

<hr>
<h2 id='MARSSinfo'> MARSS Error Messages and Warnings </h2><span id='topic+MARSSinfo'></span>

<h3>Description</h3>

<p>Prints out more information for MARSS error messages and warnings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSinfo(number)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSinfo_+3A_number">number</code></td>
<td>
<p> An error or warning message number.    </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of information.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Show all the info options
MARSSinfo()
</code></pre>

<hr>
<h2 id='MARSSinits'> Initial Values for MLE </h2><span id='topic+MARSSinits'></span>

<h3>Description</h3>

<p>Sets up generic starting values for parameters for maximum-likelihood estimation algorithms that use an iterative maximization routine needing starting values.   Examples of such algorithms are the EM algorithm in <code><a href="#topic+MARSSkem">MARSSkem</a>()</code> and Newton methods in <code><a href="#topic+MARSSoptim">MARSSoptim</a>()</code>.   This is a utility function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>.  It is not exported to the user. Users looking for information on specifying initial conditions should look at the help file for <code><a href="#topic+MARSS">MARSS</a>()</code> and the User Guide section on initial conditions.
</p>
<p>The function assumes that the user passed in the inits list using the parameter names in whatever form was specified in the <code><a href="#topic+MARSS">MARSS</a>()</code> call.  The default is form=&quot;marxss&quot;.  The <code><a href="#topic+MARSSinits">MARSSinits</a>()</code> function calls MARSSinits_foo, where foo is the form specified in the <code><a href="#topic+MARSS">MARSS</a>()</code> call.  MARSSinits_foo translates the inits list in form foo into form marss.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSinits(MLEobj, inits=list(B=1, U=0, Q=0.05, Z=1, A=0, 
    R=0.05, x0=-99, V0=5, G=0, H=0, L=0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSinits_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. </p>
</td></tr>
<tr><td><code id="MARSSinits_+3A_inits">inits</code></td>
<td>
<p> A list of column vectors (matrices with one column) of the estimated values in each parameter matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an <code>inits</code> parameter list for use by iterative maximization algorithms.  
</p>
<p>Default values for <code>inits</code> is supplied in <code>MARSSsettings.R</code>. The user can alter these and supply any of the following (m is the dim of X and n is the dim of Y in the MARSS model): 
</p>

<ul>
<li><p>elem=<code>A,U</code> A numeric vector or matrix which will be constructed into <code>inits$elem</code> by the command <code>array(inits$elem),dim=c(n or m,1))</code>. If elem is fixed in the model, any <code>inits$elem</code> values will be overridden and replaced with the fixed value. Default is <code>array(0,dim=c(n or m,1))</code>. 
</p>
</li>
<li><p>elem=<code>Q,R,B</code> A numeric vector or matrix.  If length equals the length <code>MODELobj$fixed$elem</code> then <code>inits$elem</code> will be constructed by <code>array(inits$elem),dim=dim(MODELobj$fixed$elem))</code>. If length is 1 or equals dim of <code>Q</code> or dim of <code>R</code> then <code>inits$elem</code> will be constructed into a diagonal matrix by the command <code>diag(inits$elem)</code>. If elem is fixed in the model, any <code>inits$elem</code> values will be overridden and replaced with the fixed value. Default is <code>diag(0.05, dim of Q or R)</code> for <code>Q</code> and <code>R</code>.  Default is <code>diag(1,m)</code> for <code>B</code>.
</p>
</li>
<li><p><code>x0</code> If <code>inits$x0=-99</code>, then starting values for <code>x0</code> are estimated by a linear regression 
through the count data assuming <code>A</code> is all zero.  This will be a poor start if <code>inits$A</code> is not 0. If <code>inits$x0</code> is a numeric vector or matrix, <code>inits$x0</code> will be constructed by the command <code>array(inits$x0),dim=c(m,1))</code>. If <code>x0</code> is fixed in the model, any <code>inits$x0</code> values will be overridden and replaced with the fixed value. Default is <code>inits$x0=-99</code>. 
</p>
</li>
<li><p><code>Z</code> If <code>Z</code> is fixed in the model, <code>inits$Z</code> set to the fixed value. If <code>Z</code> is not fixed, then the user must supply <code>inits$Z</code>.  There is no default.
</p>
</li>
<li><p>elem=<code>V0</code> <code>V0</code> is never estimated, so this is never used.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with initial values for the estimated values for each parameter matrix in a MARSS model in marss form. So this will be a list with elements <code>B</code>, <code>U</code>, <code>Q</code>, <code>Z</code>, <code>A</code>, <code>R</code>, <code>x0</code>, <code>V0</code>, <code>G</code>, <code>H</code>, <code>L</code>.
</p>


<h3>Note</h3>

<p>Within the base code, a form-specific internal <code>MARSSinits</code> function is called to allow the output to vary based on form: <code>MARSSinits_dfa</code>, <code>MARSSinits_marss</code>, <code>MARSSinits_marxss</code>.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+MARSSkem">MARSSkem</a>()</code>, <code><a href="#topic+MARSSoptim">MARSSoptim</a>()</code> </p>

<hr>
<h2 id='MARSSinnovationsboot'> Bootstrapped Data using Stoffer and Wall's Algorithm </h2><span id='topic+MARSSinnovationsboot'></span>

<h3>Description</h3>

<p>Creates bootstrap data via sampling from the standardized innovations matrix.   This is an internal function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code> and is not exported. Users should access this with <code><a href="#topic+MARSSboot">MARSSboot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSinnovationsboot(MLEobj, nboot = 1000, minIndx = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSinnovationsboot_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. This object must have a <code>$par</code> element containing MLE parameter estimates from e.g. <code><a href="#topic+MARSSkem">MARSSkem</a>()</code> or <code><a href="#topic+MARSS">MARSS</a>()</code>. This algorithm may not be used if there are missing datapoints in the data. </p>
</td></tr>
<tr><td><code id="MARSSinnovationsboot_+3A_nboot">nboot</code></td>
<td>
<p> Number of bootstraps to perform. </p>
</td></tr>
<tr><td><code id="MARSSinnovationsboot_+3A_minindx">minIndx</code></td>
<td>
<p> Number of innovations to skip. Stoffer &amp; Wall suggest not sampling from innovations 1-3. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stoffer and Wall (1991) present an algorithm for generating CIs via a non-parametric bootstrap for state-space models.  The basic idea is that the Kalman filter can be used to generate estimates of the residuals of the model fit.  These residuals are then standardized and resampled and used to generate bootstrapped data using the MARSS model and its maximum-likelihood parameter estimates.  One of the limitations of the Stoffer and Wall algorithm is that it cannot be used when there are missing data, unless all data at time <code class="reqn">t</code> are missing.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>boot.states</code></td>
<td>
<p> Array (dim is m x tSteps x nboot) of simulated state processes. </p>
</td></tr>
<tr><td><code>boot.data</code></td>
<td>
<p> Array (dim is n x tSteps x nboot) of simulated data. </p>
</td></tr>
<tr><td><code>marss</code></td>
<td>
 <p><code><a href="#topic+marssMODEL">marssMODEL</a></code> object element of the <code><a href="#topic+marssMLE">marssMLE</a></code> object (<code>marssMLE$marss</code>) in &quot;marss&quot; form. </p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p> Number of bootstraps performed. </p>
</td></tr>
</table>
<p>m is the number state processes (x in the MARSS model) and n is the number of observation time series (y in the MARSS model).
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes and Eric Ward, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

 
<p>Stoffer, D. S., and K. D. Wall. 1991. Bootstrapping state-space models: Gaussian maximum likelihood estimation and the Kalman filter. Journal of the American Statistical Association 86:1024-1033.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+stdInnov">stdInnov</a>()</code>, <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code>, <code><a href="#topic+MARSSboot">MARSSboot</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(kestrel)
dat &lt;- dat[2:3, ]
fit &lt;- MARSS(dat, model = list(U = "equal", Q = diag(.01, 2)))
boot.obj &lt;- MARSSinnovationsboot(fit)
</code></pre>

<hr>
<h2 id='MARSSkem'> EM Algorithm function for MARSS models </h2><span id='topic+MARSSkem'></span>

<h3>Description</h3>

<p><code>MARSSkem()</code> performs maximum-likelihood estimation, using an EM algorithm for constrained and unconstrained MARSS models.  Users would not call this function directly normally.  The function <code><a href="#topic+MARSS">MARSS</a>()</code> calls <code>MARSSkem()</code>.  However users might want to use <code>MARSSkem()</code> directly if they need to avoid some of the error-checking overhead associated with the <code><a href="#topic+MARSS">MARSS</a>()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSkem(MLEobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSkem_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code><a href="#topic+marssMLE">marssMLE</a></code> may be built from scratch but are easier to construct using <code><a href="#topic+MARSS">MARSS</a>()</code> with <code>MARSS(..., fit=FALSE)</code>.
</p>
<p>Options for <code>MARSSkem()</code> may be set using <code>MLEobj$control</code>.  The commonly used elements of <code>control</code> are as follows (see <code><a href="#topic+marssMLE">marssMLE</a></code>):
</p>

<dl>
<dt><code>minit</code></dt><dd><p> Minimum number of EM iterations. You can use this to force the algorithm to do a certain number of iterations.  This is helpful if your solution is not converging.</p>
</dd> 
<dt><code>maxit</code></dt><dd><p> Maximum number of EM iterations. </p>
</dd> 
<dt><code>min.iter.conv.test</code></dt><dd><p> The minimum number of iterations before the log-log convergence test will be computed.  If <code>maxit</code> is set less than this, then convergence will not be computed (and the algorithm will just run for maxit iterations). </p>
</dd> 
<dt><code>kf.x0</code></dt><dd><p> Whether to set the prior at <code class="reqn">t=0</code> (<code>"x00"</code>) or at <code class="reqn">t=1</code> (<code>"x10"</code>). The default is <code>"x00"</code>. </p>
</dd> 
<dt><code>conv.test.deltaT</code></dt><dd><p> The number of iterations to use in the log-log convergence test.  This defaults to 9. </p>
</dd> 
<dt><code>abstol</code></dt><dd><p> Tolerance for log-likelihood change for the delta logLik convergence test.  If log-likelihood changes less than this amount relative to the previous iteration, the EM algorithm exits. This is normally (default) set to NULL and the log-log convergence test is used instead.</p>
</dd> 
<dt><code>allow.degen</code></dt><dd><p> Whether to try setting <code class="reqn">\mathbf{Q}</code> or <code class="reqn">\mathbf{R}</code> elements to zero if they appear to be going to zero. </p>
</dd>
<dt><code>trace</code></dt><dd><p> A positive integer. If not 0, a record will be created of each variable over all EM iterations and detailed warning messages (if appropriate) will be printed. </p>
</dd>
<dt><code>safe</code></dt><dd><p> If TRUE, <code>MARSSkem</code> will rerun <code><a href="#topic+MARSSkf">MARSSkf</a></code> after each individual parameter update rather than only after all parameters are updated.  The latter is slower and unnecessary for many models, but in some cases, the safer and slower algorithm is needed because the ML parameter matrices have high condition numbers. </p>
</dd>
<dt><code>silent</code></dt><dd><p> Suppresses printing of progress bars, error messages, warnings and convergence information. </p>
</dd>    
</dl>



<h3>Value</h3>

<p>The <code><a href="#topic+marssMLE">marssMLE</a></code> object which was passed in, with additional components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>String &quot;kem&quot;.</p>
</td></tr>
<tr><td><code>kf</code></td>
<td>
<p>Kalman filter output. </p>
</td></tr>
<tr><td><code>iter.record</code></td>
<td>
<p>If <code>MLEobj$control$trace = TRUE</code>, a list with <code>par</code> = a record of each estimated parameter over all EM iterations and <code>logLik</code> = a record of the log likelihood at each iteration. </p>
</td></tr>
<tr><td><code>numIter</code></td>
<td>
<p>Number of iterations needed for convergence.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p> Did estimation converge successfully? 
</p>

<dl>
<dt>convergence=0</dt><dd><p> Converged in both the abstol test and the log-log plot test. </p>
</dd>  
<dt>convergence=1</dt><dd><p>Some of the parameter estimates did not converge (based on the log-log plot test AND abstol tests) before <code>MLEobj$control$maxit</code> was reached. This is not an error per se.</p>
</dd>
<dt>convergence=3</dt><dd><p> No convergence diagnostics were computed because all parameters were fixed thus no fitting required. </p>
</dd>   
<dt>convergence=-1</dt><dd><p> No convergence diagnostics were computed because the MLE object was not fit (called with fit=FALSE). This isn't a convergence error just information. There is not par element so no functions can be run with the object. </p>
</dd>  
<dt>convergence=2</dt><dd><p>No convergence diagnostics were computed because the MLE object had problems and was not fit. This isn't a convergence error just information.</p>
</dd>
<dt>convergence=10</dt><dd><p>Abstol convergence only. Some of the parameter estimates did not converge (based on the log-log plot test) before <code>MLEobj$control$maxit</code> was reached.  However <code>MLEobj$control$abstol</code> was reached. </p>
</dd>
<dt>convergence=11</dt><dd><p>Log-log convergence only. Some of the parameter estimates did not converge (based on the abstol test) before <code>MLEobj$control$maxit</code> was reached.  However the log-log convergence test was passed. </p>
</dd>
<dt>convergence=12</dt><dd><p>Abstol convergence only. Log-log convergence test was not computed because <code>MLEobj$control$maxit</code> was set to less than <code>control$min.iter.conv.test</code>. </p>
</dd>  
<dt>convergence=13</dt><dd><p>Lack of convergence info. Parameter estimates did not converge based on the abstol test before <code>MLEobj$control$maxit</code> was reached.  No log-log information since <code>control$min.iter.conv.test</code> is less than <code>MLEobj$control$maxit</code> so no log-log plot test could be done. </p>
</dd>
<dt>convergence=42</dt><dd><p><code>MLEobj$control$abstol</code> was reached but the log-log plot test returned NAs.  This is an odd error and you should set <code>control$trace=TRUE</code> and look at the outputted <code>$iter.record</code> to see what is wrong. </p>
</dd>
<dt>convergence=52</dt><dd><p>The EM algorithm was abandoned due to numerical errors.  Usually this means one of the variances either went to zero or to all elements being equal.  This is not an error per se.  Most likely it means that your model is not very good for your data (too inflexible or too many parameters).  Try setting <code>control$trace=1</code> to view a detailed error report.</p>
</dd>
<dt>convergence=53</dt><dd><p> The algorithm was abandoned due to numerical errors in the likelihood calculation from <code><a href="#topic+MARSSkf">MARSSkf</a></code>.  </p>
</dd> 
<dt>convergence=62</dt><dd><p>The algorithm was abandoned due to errors in the log-log convergence test.  You should not get this error (it is included for debugging purposes to catch improper arguments passed into the log-log convergence test). </p>
</dd>
<dt>convergence=63</dt><dd><p>The algorithm was run for <code>control$maxit</code> iterations, <code>control$abstol</code> not reached, and the log-log convergence test returned errors.  You should not get this error (it is included for debugging purposes to catch improper arguments passed into the log-log convergence test).</p>
</dd>
<dt>convergence=72</dt><dd><p>Other convergence errors.  This is included for debugging purposes to catch misc. errors. </p>
</dd>        
</dl>

</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>Log-likelihood.</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>State estimates from the Kalman smoother.</p>
</td></tr>
<tr><td><code>states.se</code></td>
<td>
<p>Confidence intervals based on state standard errors, see caption of Fig 6.3 (p. 337) in Shumway &amp; Stoffer (2006).</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p>Any error messages.</p>
</td></tr>
</table>


<h3>Discussion</h3>

<p>To ensure that the global maximum-likelihood values are found, it is recommended that you test the fit under different initial parameter values, particularly if the model is not a good fit to the data.  This requires more computation time, but reduces the chance of the algorithm terminating at a local maximum and not reaching the true MLEs.   For many models and for draft analyses, this is unnecessary, but answers should be checked using an initial conditions search before reporting final values.  See the chapter on initial conditions in the User Guide for a discussion on how to do this.
</p>
<p><code>MARSSkem()</code> calls a Kalman filter/smoother <code><a href="#topic+MARSSkf">MARSSkf</a>()</code> for hidden state estimation.   The algorithm allows two options for the initial state conditions: fixed but unknown or a prior.  In the first case, x0 (whether at t=0 or t=1) is treated as fixed but unknown (estimated); in this case, <code>fixed$V0=0</code> and x0 is estimated.  This is the default behavior.  In the second case, the initial conditions are specified with a prior and V0!=0.   In the later case, x0 or V0 may be estimated.  MARSS will allow you to try to estimate both, but many researchers have noted that this is not robust so you should fix one or the other.
</p>
<p>If you get errors, you can type <code><a href="#topic+MARSSinfo">MARSSinfo</a>()</code> for help. Fitting problems often mean that the solution involves an ill-conditioned matrix.    For example, your <code class="reqn">\mathbf{Q}</code> or <code class="reqn">\mathbf{R}</code> matrix is going to a value in which all elements have the same value, for example zero.  If for example, you tried to fit a model with a fixed <code class="reqn">\mathbf{R}</code> matrix with high values on the diagonal and the variance in that <code class="reqn">\mathbf{R}</code> matrix (diagonal terms) was much higher than what is actually in the data, then you might drive <code class="reqn">\mathbf{Q}</code> to zero.   Also if you try to fit a structurally inadequate model, then it is not unusual that <code class="reqn">\mathbf{Q}</code> will be driven to zero.  For example, if you fit a model with 1 hidden state trajectory to data that clearly have 2 quite different hidden state trajectories, you might have this problem.  Comparing the likelihood of this model to a model with more structural flexibility should reveal that the structurally inflexible model is inadequate (much lower likelihood).
</p>
<p>Convergence testing is done via a combination of two tests.  The first test (abstol test) is the test that the change in the absolute value of the log-likelihood from one iteration to another is less than some tolerance value (abstol).  The second test (log-log test) is that the slope of a plot of the log of the parameter value or log-likelihood versus the log of the iteration number is less than some tolerance.  Both of these must be met to generate the Success! parameters converged output.  If you want to circumvent one of these tests, then set the tolerance for the unwanted test to be high.  That will guarantee that that test is met before the convergence test you want to use is met.  The tolerance for the abstol test is set by <code>control$abstol</code> and the tolerance for the log-log test is set by <code>control$conv.test.slope.tol</code>.  Anything over 1 is huge for both of these. 
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes and Eric Ward, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

 
<p>R. H. Shumway and D. S. Stoffer (2006).  Chapter 6 in Time series analysis and its applications.  Springer-Verlag, New York.
</p>
<p>Ghahramani, Z. and Hinton, G. E. (1996) Parameter estimation for linear dynamical systems. Technical Report CRG-TR-96-2, University of Toronto, Dept. of Computer Science. 
</p>
<p>Harvey, A. C. (1989) Chapter 5 in Forecasting, structural time series models and the
Kalman filter. Cambridge University Press, Cambridge, UK.
</p>
<p>The MARSS User Guide:  Holmes, E. E., E. J. Ward, and M. D. Scheuerell (2012) Analysis of multivariate time-series using the MARSS package. NOAA Fisheries, Northwest Fisheries Science
Center, 2725 Montlake Blvd E., Seattle, WA 98112   Go to <a href="https://cran.r-project.org/package=MARSS/vignettes/UserGuide.pdf">User Guide</a> to open the most recent version.
</p>
<p>Holmes, E. E. (2012).  Derivation of the EM algorithm for constrained and unconstrained multivariate autoregressive
state-space (MARSS) models.  Technical Report. arXiv:1302.3919 [stat.ME] <a href="https://cran.r-project.org/package=MARSS/vignettes/EMDerivation.pdf">EMDerivation</a> has the most recent version.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+MARSSkf">MARSSkf</a>()</code>, <code><a href="#topic+marssMLE">marssMLE</a></code>, <code><a href="#topic+MARSSoptim">MARSSoptim</a>()</code>, <code><a href="#topic+MARSSinfo">MARSSinfo</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[2:4, ]
# you can use MARSS to construct a proper marssMLE object.
fit &lt;- MARSS(dat, model = list(Q = "diagonal and equal", U = "equal"), fit = FALSE)
# Pass this marssMLE object to MARSSkem to do the fit.
kemfit &lt;- MARSSkem(fit)
</code></pre>

<hr>
<h2 id='MARSSkemcheck'> Model Checking for MLE objects Passed to MARSSkem </h2><span id='topic+MARSSkemcheck'></span>

<h3>Description</h3>

<p>This is a helper function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code> that checks that the model can be handled by the <code><a href="#topic+MARSSkem">MARSSkem</a></code> algorithm. It also returns the structure of the model as a list of text strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSkemcheck(MLEobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSkemcheck_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with of the model elements A, B, Q, R, U, x0, Z, V0 specifying the structure of the model using text strings).
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+MARSSkem">MARSSkem</a>()</code> </p>

<hr>
<h2 id='MARSSkf'> Kalman Filtering and Smoothing </h2><span id='topic+MARSSkf'></span><span id='topic+MARSSkfas'></span><span id='topic+MARSSkfss'></span>

<h3>Description</h3>

<p>Provides Kalman filter and smoother output for MARSS models with (or without) time-varying parameters. <code>MARSSkf()</code> is a small helper function to select which Kalman filter/smoother function to use based on the value in <code>MLEobj$fun.kf</code>.  The choices are <code>MARSSkfas()</code> which uses the filtering and smoothing algorithms in the <a href="https://CRAN.R-project.org/package=KFAS">KFAS</a> package based on algorithms in Koopman and Durbin (2001-2003), and <code>MARSSkfss()</code> which uses the algorithms in Shumway and Stoffer. The default function is <code>MARSSkfas()</code> which is faster and generally more stable (fewer matrix inversions), but there are some cases where <code>MARSSkfss()</code> might be more stable and it returns a variety of diagnostics that <code>MARSSkfas()</code> does not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSkf(MLEobj, only.logLik = FALSE, return.lag.one = TRUE, return.kfas.model = FALSE, 
           newdata = NULL, smoother = TRUE)
MARSSkfss(MLEobj, smoother=TRUE)
MARSSkfas(MLEobj, only.logLik=FALSE, return.lag.one=TRUE, return.kfas.model=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSkf_+3A_mleobj">MLEobj</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object with the <code>par</code> element of estimated parameters, <code>marss</code> element with the model description (in marss form) and data, and <code>control</code> element for the fitting algorithm specifications.  <code>control$debugkf</code> specifies that detailed error reporting will be returned (only used by <code>MARSSkf()</code>).  <code>model$diffuse=TRUE</code> specifies that a diffuse prior be used (only used by <code>MARSSkfas()</code>). See <a href="KFAS.html#topic+KFS">KFS</a> documentation. When the diffuse prior is set, <code>V0</code> should be non-zero since the diffuse prior variance is <code>V0*kappa</code>, where kappa goes to infinity.</p>
</td></tr>
<tr><td><code id="MARSSkf_+3A_smoother">smoother</code></td>
<td>
<p> Used by <code>MARSSkfss()</code>.  If set to FALSE, only the Kalman filter is run. The output <code>xtT</code>, <code>VtT</code>, <code>x0T</code>, <code>Vtt1T</code>, <code>V0T</code>, and <code>J0</code> will be NULL. </p>
</td></tr>
<tr><td><code id="MARSSkf_+3A_only.loglik">only.logLik</code></td>
<td>
<p> Used by <code>MARSSkfas()</code>.  If set, only the log-likelihood is returned using the <a href="KFAS.html#topic+KFAS">KFAS</a> package function <code><a href="KFAS.html#topic+logLik.SSModel">logLik.SSModel</a></code>.  This is much faster if only the log-likelihood is needed. </p>
</td></tr>
<tr><td><code id="MARSSkf_+3A_return.lag.one">return.lag.one</code></td>
<td>
<p> Used by <code>MARSSkfas()</code>.  If set to FALSE, the smoothed lag-one covariance  values are not returned (output <code>Vtt1T</code> is set to NULL).  This speeds up <code>MARSSkfas()</code> because to return the smoothed lag-one covariance a stacked MARSS model is used with twice the number of state vectors&mdash;thus the state matrices are larger and take more time to work with. </p>
</td></tr>
<tr><td><code id="MARSSkf_+3A_return.kfas.model">return.kfas.model</code></td>
<td>
<p> Used by <code>MARSSkfas()</code>.  If set to TRUE, it returns the MARSS model in <a href="KFAS.html#topic+KFAS">KFAS</a> model form (class <code><a href="KFAS.html#topic+SSModel">SSModel</a></code>).  This is useful if you want to use other KFAS functions or write your own functions to work with <code><a href="stats.html#topic+optim">optim</a>()</code> to do optimization.  This can speed things up since there is a bit of code overhead in <code><a href="#topic+MARSSoptim">MARSSoptim</a>()</code> associated with the <code><a href="#topic+marssMODEL">marssMODEL</a></code> model specification needed for the constrained EM algorithm (but not strictly needed for <code><a href="stats.html#topic+optim">optim</a>()</code>; useful but not required.). </p>
</td></tr>
<tr><td><code id="MARSSkf_+3A_newdata">newdata</code></td>
<td>
<p> A new matrix of data to use in place of the data used to fit the model (in the <code>model$data</code> and <code>marss$data</code> elements of a <code><a href="#topic+marssMLE">marssMLE</a></code> object). If the initial <code class="reqn">x</code> was estimated (in <code>x0</code>) then this estimate will be used for <code>newdata</code> and this may not be appropriate. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For state-space models, the Kalman filter and smoother provide optimal (minimum mean square error) estimates of the hidden states. The Kalman filter is a forward recursive algorithm which computes estimates of the states <code class="reqn">\mathbf{x}_t</code> conditioned on the data up to time <code class="reqn">t</code> (<code>xtt</code>). The Kalman smoother is a backward recursive algorithm which starts at time <code class="reqn">T</code> and works backwards to <code class="reqn">t = 1</code> to provide estimates of the states conditioned on all data (<code>xtT</code>).    The data may contain missing values (NAs).  All parameters may be time varying.
</p>
<p>The initial state is either an estimated parameter or treated as a prior (with mean and variance). The initial state can be specified at <code class="reqn">t=0</code> or <code class="reqn">t=1</code>.  The EM algorithm in the MARSS package (<code><a href="#topic+MARSSkem">MARSSkem</a>()</code>) provides both Shumway and Stoffer's derivation that uses <code class="reqn">t=0</code> and Ghahramani et al algorithm which uses <code class="reqn">t=1</code>.  The <code>MLEobj$model$tinitx</code> argument specifies whether the initial states (specified with <code>x0</code> and <code>V0</code> in the <code>model</code> list) is at <code class="reqn">t=0</code> (<code>tinitx=0</code>) or <code class="reqn">t=1</code> (<code>tinitx=1</code>). If <code>MLEobj$model$tinitx=0</code>, <code>x0</code> is defined as <code class="reqn">\textrm{E}[\mathbf{X}_0|\mathbf{y}_0]</code> and <code>V0</code> is defined as <code class="reqn">\textrm{E}[\mathbf{X}_0\mathbf{X}_0|\mathbf{y}_0]</code> which appear in the Kalman filter at <code class="reqn">t=1</code> (first set of equations). If <code>MLEobj$model$tinitx=1</code>, <code>x0</code> is defined as <code class="reqn">\textrm{E}[\mathbf{X}_1|\mathbf{y}_0]</code> and <code>V0</code> is defined as <code class="reqn">\textrm{E}[\mathbf{X}_1\mathbf{X}_1|\mathbf{y}_0]</code> which appear in the Kalman filter at <code class="reqn">t=1</code> (and the filter starts at t=1 at the 3rd and 4th equations in the Kalman filter recursion). Thus if <code>MLEobj$model$tinitx=1</code>, <code>x0=xtt1[,1]</code> and <code>V0=Vtt1[,,1]</code> in the Kalman filter output while if <code>MLEobj$model$tinitx=0</code>, the initial condition will not be in the filter output since time starts at 1 not 0 in the output.
</p>
<p><code>MARSSkfss()</code> is a native R implementation based on the Kalman filter and smoother equation as shown in Shumway and Stoffer (sec 6.2, 2006).  The equations have been altered to allow the initial state distribution to be to be specified at <code class="reqn">t=0</code> or <code class="reqn">t=1</code> (data starts at <code class="reqn">t=1</code>) per per Ghahramani and Hinton (1996).  In addition, the filter and smoother equations have been altered to allow partially deterministic models (some or all elements of the <code class="reqn">\mathbf{Q}</code> diagonals equal to 0), partially perfect observation models (some or all elements of the <code class="reqn">\mathbf{R}</code> diagonal equal to 0) and fixed (albeit unknown) initial states (some or all elements of the <code class="reqn">\mathbf{V0}</code> diagonal equal to 0) (per Holmes 2012).  The code includes numerous checks to alert the user if matrices are becoming ill-conditioned and the algorithm unstable.  
</p>
<p><code>MARSSkfas()</code> uses the (Fortran-based) Kalman filter and smoother function (<code><a href="KFAS.html#topic+KFS">KFS</a>()</code>) in the <a href="https://cran.r-project.org/package=KFAS">KFAS</a> package (Helske 2012) based on the algorithms of Koopman and Durbin (2000, 2001, 2003).  The Koopman and Durbin algorithm is faster and more stable since it avoids matrix inverses.  Exact diffuse priors are also allowed in the KFAS Kalman filter function.  The standard output from the KFAS functions do not include the lag-one covariance smoother needed for the EM algorithm.  <code>MARSSkfas</code> computes the smoothed lag-one covariance  using the Kalman filter applied to a stacked MARSS model as described on page 321 in Shumway and Stoffer (2000). Also the KFAS model specification only has the initial state at <code class="reqn">t=1</code> (as <code class="reqn">\mathbf{X}_1</code> conditioned on <code class="reqn">\mathbf{y}_0</code>, which is missing).  When the initial state is specified at <code class="reqn">t=0</code> (as <code class="reqn">\mathbf{X}_0</code> conditioned on <code class="reqn">\mathbf{y}_0</code>), <code>MARSSkfas()</code> computes the required  <code class="reqn">\textrm{E}[\mathbf{X}_1|\mathbf{y}_0</code> and <code class="reqn">\textrm{var}[\mathbf{X}_1|\mathbf{y}_0</code> using the Kalman filter equations per Ghahramani and Hinton (1996).  
</p>
<p>The likelihood returned for both functions is the exact likelihood when there are missing values rather than the approximate likelihood sometimes presented in texts for the missing values case.  The functions return the same filter, smoother and log-likelihood values.  The differences are that <code>MARSSkfas()</code> is faster (and more stable) but <code>MARSSkfss()</code> has many internal checks and error messages which can help debug numerical problems (but slow things down).  Also  <code>MARSSkfss()</code> returns some output specific to the traditional filter algorithm (<code>J</code> and <code>Kt</code>).  
</p>


<h3>Value</h3>

<p>A list with the following components. <code class="reqn">m</code> is the number of state processes and <code class="reqn">n</code> is the number of observation time series. &quot;V&quot; elements are called &quot;P&quot; in Shumway and Stoffer (2006, eqn 6.17 with s=T).  The output is referenced against equations in Shumway and Stoffer (2006) denoted S&amp;S; the Kalman filter and smoother implemented in MARSS is for a more general MARSS model than that shown in S&amp;S but the output has the same meaning.  In the expectations below, the parameters are left off; <code class="reqn">\textrm{E}[\mathbf{X} | \mathbf{y}_1^t]</code> is really <code class="reqn">\textrm{E}[\mathbf{X} | \Theta, \mathbf{Y}_1^t=\mathbf{y}_1^t]</code> where <code class="reqn">\Theta</code> is the parameter list. <code class="reqn">\mathbf{y}_1^t</code> denotes the data from <code class="reqn">t=1</code> to <code class="reqn">t=t</code>.
</p>
<p>The notation for the conditional expectations is <code class="reqn">\mathbf{x}_t^t</code> = <code class="reqn">\textrm{E}[\mathbf{X} | \mathbf{y}_1^t]</code>, <code class="reqn">\mathbf{x}_t^{t-1}</code> = <code class="reqn">\textrm{E}[\mathbf{X} | \mathbf{y}_1^{t-1}]</code> and <code class="reqn">\mathbf{x}_t^T</code> = <code class="reqn">\textrm{E}[\mathbf{X} | \mathbf{y}_1^T]</code>. The conditional variances and covariances use similar notation. Note that in the Holmes (2012), the EM Derivation, <code class="reqn">\mathbf{x}_t^T</code> and <code class="reqn">\mathbf{V}_t^T</code> are given special symbols because they appear repeatedly: <code class="reqn">\tilde{\mathbf{x}}_t</code> and <code class="reqn">\tilde{\mathbf{V}}_t</code> but here the more general notation is used.
</p>
<table>
<tr><td><code>xtT</code></td>
<td>
 <p><code class="reqn">\mathbf{x}_t^T</code> State first moment conditioned on <code class="reqn">\mathbf{y}_1^T</code>: <code class="reqn">\textrm{E}[\mathbf{X}_t|\mathbf{y}_1^T]</code> (m x T matrix). Kalman smoother output.</p>
</td></tr>
<tr><td><code>VtT</code></td>
<td>
 <p><code class="reqn">\mathbf{V}_t^T</code> State variance matrix conditioned on  <code class="reqn">\mathbf{y}_1^T</code>: <code class="reqn">\textrm{E}[(\mathbf{X}_t-\mathbf{x}_t^T)(\mathbf{X}_t-\mathbf{x}_t^T)^\top|\mathbf{y}_1^T]</code> (m x m x T array). Kalman smoother output. Denoted <code class="reqn">P_t^T</code> in S&amp;S (S&amp;S eqn 6.18 with <code class="reqn">s=T</code>, <code class="reqn">t1=t2=t</code>). The state second moment <code class="reqn">\textrm{E}[\mathbf{X}_t\mathbf{X}_t^\top|\mathbf{y}_1^T]</code> is equal to <code class="reqn">\mathbf{V}_t^T + \mathbf{x}_t^T(\mathbf{x}_t^T)^\top</code>. </p>
</td></tr>
<tr><td><code>Vtt1T</code></td>
<td>
 <p><code class="reqn">\mathbf{V}_{t,t-1}^T</code> State lag-one cross-covariance matrix <code class="reqn">\textrm{E}[(\mathbf{X}_t-\mathbf{x}_t^T)(\mathbf{X}_{t-1}-\mathbf{x}_{t-1}^T)^\top|\mathbf{y}_1^T]</code> (m x m x T). Kalman smoother output. <code class="reqn">P_{t,t-1}^T</code> in S&amp;S (S&amp;S eqn 6.18 with <code class="reqn">s=T</code>, <code class="reqn">t1=t</code>, <code class="reqn">t2=t-1</code>). State lag-one second moments <code class="reqn">\textrm{E}[\mathbf{X}_t\mathbf{X}_{t-1}^\top|\mathbf{y}_1^T]</code> is equal to <code class="reqn">\mathbf{V}_{t, t-1}^T + \mathbf{x}_t^T(\mathbf{x}_{t-1}^T)^\top</code>. </p>
</td></tr>
<tr><td><code>x0T</code></td>
<td>
<p> Initial smoothed state estimate <code class="reqn">\textrm{E}[\mathbf{X}_{t0}|\mathbf{y}_1^T</code> (m x 1). If <code>model$tinitx=0</code>, <code class="reqn">t0=0</code>; if <code>model$tinitx=1</code>, <code class="reqn">t0=1</code>. Kalman smoother output.</p>
</td></tr>
<tr><td><code>x01T</code></td>
<td>
<p> Smoothed state estimate <code class="reqn">\textrm{E}[\mathbf{X}_1|\mathbf{y}_1^T</code> (m x 1). </p>
</td></tr>
<tr><td><code>x00T</code></td>
<td>
<p> Smoothed state estimate <code class="reqn">\textrm{E}[\mathbf{X}_0 |\mathbf{y}_1^T</code> (m x 1). If <code>model$tinitx=1</code>, this will be NA. </p>
</td></tr>
<tr><td><code>V0T</code></td>
<td>
<p> Initial smoothed state covariance matrix <code class="reqn">\textrm{E}[\mathbf{X}_{t0}\mathbf{X}_0^\top | \mathbf{y}_1^T</code> (m x m). If <code>model$tinitx=0</code>, <code class="reqn">t0=0</code> and <code>V0T=V00T</code>; if <code>model$tinitx=1</code>, <code class="reqn">t0=1</code> and <code>V0T=V10T</code>.  In the case of <code>tinitx=0</code>, this is <code class="reqn">P_0^T</code> in S&amp;S.</p>
</td></tr>
<tr><td><code>V10T</code></td>
<td>
<p> Smoothed state covariance matrix <code class="reqn">\textrm{E}[\mathbf{X}_1\mathbf{X}_0^\top | \mathbf{y}_1^T</code> (m x m). </p>
</td></tr>
<tr><td><code>V00T</code></td>
<td>
<p> Smoothed state covariance matrix <code class="reqn">\textrm{E}[\mathbf{X}_0\mathbf{X}_0^\top | \mathbf{y}_1^T</code> (m x m). If <code>model$tinitx=1</code>, this will be NA. </p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p> (m x m x T) Kalman smoother output.  Only for <code>MARSSkfss()</code>. (ref S&amp;S eqn 6.49) </p>
</td></tr>
<tr><td><code>J0</code></td>
<td>
<p> J at the initial time (t=0 or t=1) (m x m x T). Kalman smoother output. Only for <code>MARSSkfss()</code>.</p>
</td></tr>
<tr><td><code>xtt</code></td>
<td>
<p> State first moment conditioned on <code class="reqn">\mathbf{y}_1^t</code>: <code class="reqn">\textrm{E}[\mathbf{X}_t | \mathbf{y}_1^t</code> (m x T).  Kalman filter output. (S&amp;S eqn 6.17 with <code class="reqn">s=t</code>) </p>
</td></tr>
<tr><td><code>xtt1</code></td>
<td>
<p> State first moment conditioned on <code class="reqn">\mathbf{y}_1^{t-1}</code>: <code class="reqn">\textrm{E}[\mathbf{X}_t | \mathbf{y}_1^{t-1}</code> (m x T).  Kalman filter output. (S&amp;S eqn 6.17 with <code class="reqn">s=t-1</code>) </p>
</td></tr>
<tr><td><code>Vtt</code></td>
<td>
<p> State variance conditioned on <code class="reqn">\mathbf{y}_1^t</code>: <code class="reqn">\textrm{E}[(\mathbf{X}_t-\mathbf{x}_t^t)(\mathbf{X}_t-\mathbf{x}_t^t)^\top|\mathbf{y}_1^t]</code> (m x m x T array). Kalman filter output. <code class="reqn">P_t^t</code> in S&amp;S (S&amp;S eqn 6.18 with s=t, t1=t2=t). The state second moment <code class="reqn">\textrm{E}[\mathbf{X}_t\mathbf{X}_t^\top|\mathbf{y}_1^t]</code> is equal to <code class="reqn">\mathbf{V}_t^t + \mathbf{x}_t^t(\mathbf{x}_t^t)^\top</code>. </p>
</td></tr>
<tr><td><code>Vtt1</code></td>
<td>
<p>  State variance conditioned on <code class="reqn">\mathbf{y}_1^{t-1}</code>: <code class="reqn">\textrm{E}[(\mathbf{X}_t-\mathbf{x}_t^{t-1})(\mathbf{X}_t-\mathbf{x}_t^{t-1})^\top|\mathbf{y}_1^{t-1}]</code> (m x m x T array). Kalman filter output. The state second moment <code class="reqn">\textrm{E}[\mathbf{X}_t\mathbf{X}_t^\top|\mathbf{y}_1^{t-1}]</code> is equal to <code class="reqn">\mathbf{V}_t^{t-1} + \mathbf{x}_t^{t-1}(\mathbf{x}_t^{t-1})^\top</code>. </p>
</td></tr>
<tr><td><code>Kt</code></td>
<td>
<p> Kalman gain (m x m x T). Kalman filter output (ref S&amp;S eqn 6.23). Only for <code>MARSSkfss()</code>.</p>
</td></tr>
<tr><td><code>Innov</code></td>
<td>
<p> Innovations <code class="reqn">\mathbf{y}_t-\textrm{E}[\mathbf{Y}_t|\mathbf{y}_1^{t-1}]</code> (n x T). Kalman filter output. Only returned with <code>MARSSkfss()</code>. (ref page S&amp;S 339). </p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p> Innovations covariance matrix. Kalman filter output. Only returned with <code>MARSSkfss()</code>. (ref S&amp;S eqn 6.61)</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p> Log-likelihood logL(y(1:T) | Theta) (ref S&amp;S eqn 6.62)</p>
</td></tr>
<tr><td><code>kfas.model</code></td>
<td>
<p> The model in <a href="KFAS.html#topic+KFAS">KFAS</a> model form (class <code><a href="KFAS.html#topic+SSModel">SSModel</a></code>). Only for <code>MARSSkfas</code>.</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p> Any error messages. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>A. C. Harvey (1989).  Chapter 5, Forecasting, structural time series models and the Kalman filter.  Cambridge University Press.
</p>
<p>R. H. Shumway and D. S. Stoffer (2006).  Time series analysis and its applications: with R examples.  Second Edition. Springer-Verlag, New York.
</p>
<p>Ghahramani, Z. and Hinton, G.E. (1996) Parameter estimation for linear dynamical systems.  University of Toronto Technical Report CRG-TR-96-2.
</p>
<p>Holmes, E. E. (2012).  Derivation of the EM algorithm for constrained and unconstrained multivariate autoregressive
state-space (MARSS) models.  Technical Report. arXiv:1302.3919 [stat.ME] <code>RShowDoc("EMDerivation",package="MARSS")</code> to open a copy.
</p>
<p>Jouni Helske (2012). KFAS: Kalman filter and smoother for exponential family state space models. <a href="https://CRAN.R-project.org/package=KFAS">https://CRAN.R-project.org/package=KFAS</a>
</p>
<p>Koopman, S.J. and Durbin J. (2000). Fast filtering and smoothing for non-stationary time series models, Journal of American Statistical Association, 92, 1630-38.
</p>
<p>Koopman, S.J. and Durbin J. (2001). Time series analysis by state space methods. Oxford: Oxford University Press.
</p>
<p>Koopman, S.J. and Durbin J. (2003). Filtering and smoothing of state vector for diffuse state space models, Journal of Time Series Analysis, Vol. 24, No. 1.
</p>
<p>The MARSS User Guide:  Holmes, E. E., E. J. Ward, and M. D. Scheuerell (2012) Analysis of multivariate time-series using the MARSS package. NOAA Fisheries, Northwest Fisheries Science Center, 2725 Montlake Blvd E., Seattle, WA 98112   Type <code>RShowDoc("UserGuide",package="MARSS")</code> to open a copy.     
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+MARSS">MARSS</a>()</code>, <code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+MARSSkem">MARSSkem</a>()</code>, <code><a href="KFAS.html#topic+KFAS">KFAS</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[2:nrow(dat), ]
# you can use MARSS to construct a marssMLE object
# MARSS calls MARSSinits to construct default initial values
# with fit = FALSE, the $par element of the marssMLE object will be NULL
fit &lt;- MARSS(dat, fit = FALSE)
# MARSSkf needs a marssMLE object with the par element set
fit$par &lt;- fit$start
# Compute the kf output at the params used for the inits
kfList &lt;- MARSSkf(fit)
</code></pre>

<hr>
<h2 id='marssMLE-class'>Class &quot;marssMLE&quot;</h2><span id='topic+marssMLE'></span>

<h3>Description</h3>

<p><code><a href="#topic+marssMLE">marssMLE</a></code> objects specify fitted multivariate autoregressive state-space models (maximum-likelihood) in the package <code><a href="#topic+MARSS-package">MARSS-package</a></code>.
</p>
<p>A marssMLE object in the  <code><a href="#topic+MARSS-package">MARSS-package</a></code> that has all the elements needed for maximum-likelihood estimation of multivariate autoregressive state-space model: the data, model, estimation methods, and any control options needed for the method.  If the model has been fit and parameters estimated, the object will also have the MLE parameters.  Other functions add other elements to the marssMLE object, such as CIs, s.e.'s, AICs, and the observed Fisher Information matrix. There are <code>print</code>, <code>summary</code>, <code>coef</code>, <code>fitted</code>, <code>residuals</code>, <code>predict</code> and <code>simulate</code> methods for <code><a href="#topic+marssMLE">marssMLE</a></code> objects and a bootstrap function.  Rather than working directly with the elements of a <code><a href="#topic+marssMLE">marssMLE</a></code> object, use <code><a href="#topic+print.marssMLE">print</a>()</code>, <code><a href="#topic+tidy.marssMLE">tidy</a>()</code>, <code><a href="#topic+fitted.marssMLE">fitted</a>()</code>, <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code>, <code><a href="#topic+predict.marssMLE">predict</a>()</code>, or <code><a href="#topic+residuals.marssMLE">residuals</a>()</code> to extract output.
</p>


<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "marssMLE")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
<dt>logLik</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
<dt>simulate</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
<dt>forecast</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
<dt>accuracy</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
<dt>toLatex</dt><dd><p><code>signature(object = "marssMLE")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

 
<p>Eli Holmes and Kellie Wills, NOAA, Seattle, USA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.marssMLE">is.marssMLE</a>()</code>, <code><a href="#topic+print.marssMLE">print.marssMLE</a>()</code>, <code><a href="#topic+summary.marssMLE">summary.marssMLE</a>()</code>, <code><a href="#topic+coef.marssMLE">coef.marssMLE</a>()</code>, <code><a href="#topic+residuals.marssMLE">residuals.marssMLE</a>()</code>, <code><a href="#topic+fitted.marssMLE">fitted.marssMLE</a>()</code>, <code><a href="#topic+tsSmooth.marssMLE">tsSmooth.marssMLE</a>()</code>, <code><a href="#topic+logLik.marssMLE">logLik.marssMLE</a>()</code>, <code><a href="#topic+simulate.marssMLE">simulate.marssMLE</a>()</code>, <code><a href="#topic+predict.marssMLE">predict.marssMLE</a>()</code>, <code><a href="#topic+forecast.marssMLE">forecast.marssMLE</a>()</code>, <code><a href="#topic+accuracy.marssMLE">accuracy.marssMLE</a>()</code>, <code><a href="#topic+toLatex.marssMLE">toLatex.marssMLE</a>()</code>
</p>

<hr>
<h2 id='marssMODEL-class'>Class &quot;marssMODEL&quot;</h2><span id='topic+marssMODEL'></span>

<h3>Description</h3>

<p><code>marssMODEL</code> objects describe a vectorized form for the multivariate autoregressive state-space models used in the package <code><a href="#topic+MARSS-package">MARSS-package</a></code>.
</p>


<h3>Details</h3>

<p>The object has the following attributes:
</p>

<dl>
<dt>form</dt><dd><p> The form that the model object is in. </p>
</dd>
<dt>par.names</dt><dd><p> The names of each parameter matrix in the model. </p>
</dd>
<dt>model.dims</dt><dd><p> A list with the dimensions of all the matrices in non-vectorized form. </p>
</dd>
<dt>X.names</dt><dd><p> Names for the X rows. </p>
</dd> 
<dt>Y.names</dt><dd><p> Names for the Y rows. </p>
</dd> 
<dt>equation</dt><dd><p> The model equation.  Used to write the model in LaTeX. </p>
</dd> 
</dl>

<p>These attributes are set in the MARSS_form.R file, in the <code>MARSS.form()</code> function and must be internally consistent with the elements of the model.  These attributes are used for internal error checking.
</p>
<p>Each parameter matrix in a MARSS equation can be written in vectorized form: vec(P) = f + Dp, where f is the fixed part, p are the estimated parameters, and D is the matrix that transforms the p into a vector to be added to f.
</p>
<p>An object of class <code>marssMODEL</code> is a list with elements:
</p>

<dl>
<dt>data</dt><dd><p> Data supplied by user. </p>
</dd>
<dt>fixed</dt><dd><p> A list with the f row vectors for each parameter matrix.  </p>
</dd>
<dt>free</dt><dd><p> A list with the D matrices for each parameter matrix. </p>
</dd>
<dt>tinitx</dt><dd><p> At what t, 0 or 1, is the initial x defined at? </p>
</dd> 
<dt>diffuse</dt><dd><p> Whether a diffuse initial prior is used.  TRUE or FALSE.  Not used unless <code>method="BFGS"</code> was used. </p>
</dd> 
</dl>

<p>For the marss form, the matrices are called:   Z, A, R, B, U, Q, x0, V0.  This is the form used by all internal algorithms, thus alternate forms must be transformed to marss form before fitting.  For the marxss form (the default form in a <code><a href="#topic+MARSS">MARSS</a>()</code> call), the matrices are called: Z,  A,  R,  B,  U, Q, D, C, d, c, x0, V0.
</p>
<p>Each form, should have a file called MARSS_form.R, with the following functions.  Let foo be some form.
</p>

<dl>
<dt>MARSS.foo(MARSS.call)</dt><dd><p> This is called in <code><a href="#topic+MARSS">MARSS</a>()</code> and takes the input from the <code><a href="#topic+MARSS">MARSS</a>()</code> call (a list called MARSS.call) and returns that list with two model objects added. First is a model object in marss form in the $marss element and a model object in the form foo.</p>
</dd>
<dt>marss_to_foo(marssMLE or marssMODEL)</dt><dd><p> If called with marssMODEL (in form marss), marss_to_foo returns a model in form foo.  If marss_to_foo is called with a <code><a href="#topic+marssMLE">marssMLE</a></code> object (which must have a $marss element by definition), it returns a $model element in form foo and all if the marssMLE object has par, par.se, par.CI, par.bias, start elements, these are also converted to foo form. The function is mainly used by print.foo which needs the par (and related) elements of a marssMLE object to be in foo form for printing.</p>
</dd>
<dt>foo_to_marss(marssMODEL or marssMLE)</dt><dd><p> This converts marssMODEL(form=foo) to marssMODEL(form=marss).  This transformation is always possible since MARSS only works for models for which this is possible. If called with marssMODEL, it returns only a <code><a href="#topic+marssMODEL">marssMODEL</a></code> object.  If called with a <code><a href="#topic+marssMLE">marssMLE</a></code> object, it adds the <code>$marss</code> element with a <code><a href="#topic+marssMODEL">marssMODEL</a></code> in &quot;marss&quot; form and if the par (or related) elements exists, these are converted to &quot;marss&quot; form. </p>
</dd>
<dt>print_foo(marssMLE or marssMODEL)</dt><dd><p> print.marssMLE prints the par (and par.se and start) element of a marssMLE object but does not make assumptions about its form. Normally this element is in form=marss.  print.marssMLE checks for a print_foo function and runs that on the marssMLE object first.  This allows one to call foo_to_marss() to covert the par (and related) element to foo form so they look familiar to the user (the marss form will look strange). If called with marssMLE, print_foo returns a marssMLE object with the par (and related) elements in foo form.  If called with a marssMODEL, print_foo returns a marssMODEL in foo form.</p>
</dd> 
<dt>coef_foo(marssMLE)</dt><dd><p> See print_foo.  coef.marssMLE also uses the par (and related) elements. </p>
</dd>
<dt>predict_foo(marssMLE)</dt><dd><p> Called by predict.marssMLE to do any needed conversions.  Typically a form will want the newdata element in a particular format and this will need to be converted to marss form. This returns an updated marssMLE object and newdata.</p>
</dd>
<dt>describe_foo(marssMODEL)</dt><dd><p> Called by describe.marssMODEL to do allow custom description output.</p>
</dd> 
<dt>is.marssMODEL_foo(marssMODEL)</dt><dd><p> Check that the model object in foo form has all the parts it needs and that these have the proper size and form.</p>
</dd>
<dt>MARSSinits_foo(marssMLE, inits.list)</dt><dd><p> Allows customization of the inits used by the form. Returns an inits list in marss form.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "marssMODEL")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "marssMODEL")</code>: ... </p>
</dd>
<dt>toLatex</dt><dd><p><code>signature(object = "marssMODEL")</code>: ... </p>
</dd>
<dt>model.frame</dt><dd><p><code>signature(object = "marssMODEL")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>

<hr>
<h2 id='MARSSoptim'>Parameter estimation for MARSS models using optim</h2><span id='topic+MARSSoptim'></span>

<h3>Description</h3>

<p>Parameter estimation for MARSS models using R's <code><a href="stats.html#topic+optim">optim</a>()</code> function.   This allows access to R's quasi-Newton algorithms available in that function.  The <code>MARSSoptim()</code> function is called when <code><a href="#topic+MARSS">MARSS</a>()</code> is called with <code>method="BFGS"</code>.  This is an internal function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSoptim(MLEobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSoptim_+3A_mleobj">MLEobj</code></td>
<td>
<p>An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code><a href="#topic+marssMLE">marssMLE</a></code> may be built from scratch but are easier to construct using <code><a href="#topic+MARSS">MARSS</a>()</code> called with <code>MARSS(..., fit=FALSE, method="BFGS")</code>.
</p>
<p>Options for <code><a href="stats.html#topic+optim">optim</a>()</code> are passed in using <code>MLEobj$control</code>.  See <code><a href="stats.html#topic+optim">optim</a>()</code> for a list of that function's control options.  If <code>lower</code> and <code>upper</code> for <code><a href="stats.html#topic+optim">optim</a>()</code> need to be passed in, they should be passed in as part of <code>control</code> as <code>control$lower</code> and <code>control$upper</code>. Additional <code>control</code> arguments affect printing and initial conditions.
</p>

<dl>
<dt><code>MLEobj$control$kf.x0</code></dt><dd><p> The initial condition is at $t=0$ if kf.x0=&quot;x00&quot;.  The initial condition is at $t=1$ if kf.x0=&quot;x10&quot;. </p>
</dd>    
<dt><code>MLEobj$marss$diffuse</code></dt><dd><p> If diffuse=TRUE, a diffuse initial condition is used. MLEobj$par$V0 is then the scaling function for the diffuse part of the prior.  Thus the prior is V0*kappa where kappa&ndash;&gt;Inf.  Note that setting a diffuse prior does not change the correlation structure within the prior. If diffuse=FALSE, a non-diffuse prior is used and MLEobj$par$V0 is the non-diffuse prior variance on the initial states. The the prior is V0.</p>
</dd>      <dt><code>MLEobj$control$silent</code></dt><dd><p> Suppresses printing of progress bars, error messages, warnings and convergence information. </p>
</dd>    
</dl>



<h3>Value</h3>

<p>The <code><a href="#topic+marssMLE">marssMLE</a></code> object which was passed in, with additional components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>String &quot;BFGS&quot;.</p>
</td></tr>
<tr><td><code>kf</code></td>
<td>
<p>Kalman filter output. </p>
</td></tr>
<tr><td><code>iter.record</code></td>
<td>
<p>If <code>MLEobj$control$trace = TRUE</code>, then this is the <code>$message</code> value from <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>numIter</code></td>
<td>
<p>Number of iterations needed for convergence.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p> Did estimation converge successfully? 
</p>

<dl>
<dt>convergence=0</dt><dd><p> Converged in less than <code>MLEobj$control$maxit</code> iterations and no evidence of degenerate solution. </p>
</dd> 
<dt>convergence=3</dt><dd><p> No convergence diagnostics were computed because all parameters were fixed thus no fitting required. </p>
</dd>   
<dt>convergence=-1</dt><dd><p> No convergence diagnostics were computed because the MLE object was not fit (called with fit=FALSE). This isn't a convergence error just information. There is not par element so no functions can be run with the object. </p>
</dd>  
<dt>convergence=1</dt><dd><p> Maximum number of iterations <code>MLEobj$control$maxit</code> was reached before <code>MLEobj$control$abstol</code> condition was satisfied. </p>
</dd> 
<dt>convergence=10</dt><dd><p> Some of the variance elements appear to be degenerate. </p>
</dd> 
<dt>convergence=52</dt><dd><p> The algorithm was abandoned due to errors from the &quot;L-BFGS-B&quot; method.  </p>
</dd> 
<dt>convergence=53</dt><dd><p> The algorithm was abandoned due to numerical errors in the likelihood calculation from <code><a href="#topic+MARSSkf">MARSSkf</a></code>.  If this happens with &quot;BFGS&quot;, it can sometimes be helped with a better initial condition.  Try using the EM algorithm first (<code>method="kem"</code>), and then using the parameter estimates from that to as initial conditions for <code>method="BFGS"</code>.  </p>
</dd> 
<dt>convergence=54</dt><dd><p> The algorithm successfully fit the model but the Kalman filter/smoother could not be run on the model. Consult <code>MARSSinfo('optimerror54')</code> for insight.  </p>
</dd> 
</dl>

</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>Log-likelihood.</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>State estimates from the Kalman smoother.</p>
</td></tr>
<tr><td><code>states.se</code></td>
<td>
<p>Confidence intervals based on state standard errors, see caption of Fig 6.3 (p. 337) in Shumway &amp; Stoffer (2006).</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p>Any error messages.</p>
</td></tr>
</table>


<h3>Discussion</h3>

<p>The function only returns parameter estimates.  To compute CIs, use <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a></code> but if you use parametric or non-parametric bootstrapping with this function, it will use the EM algorithm to compute the bootstrap parameter estimates!  The quasi-Newton estimates are too fragile for the bootstrap routine since one often needs to search to find a set of initial conditions that work (i.e. don't lead to numerical errors).
</p>
<p>Estimates from <code>MARSSoptim</code> (which come from <code><a href="stats.html#topic+optim">optim</a></code>) should be checked against estimates from the EM algorithm.  If the quasi-Newton algorithm works, it will tend to find parameters with higher likelihood faster than the EM algorithm.  However, the MARSS likelihood surface can be multimodal with sharp peaks at degenerate solutions where a <code class="reqn">\mathbf{Q}</code> or <code class="reqn">\mathbf{R}</code> diagonal element equals 0.  The quasi-Newton algorithm sometimes gets stuck on these peaks even when they are not the maximum.  Neither an initial conditions search nor starting near the known maximum (or from the parameters estimates after the EM algorithm) will necessarily solve this problem.   Thus it is wise to check against EM estimates to ensure that the BFGS estimates are close to the MLE estimates (and vis-a-versa, it's wise to rerun with method=&quot;BFGS&quot; after using method=&quot;kem&quot;).  Conversely, if there is a strong flat ridge in your likelihood, the EM algorithm can report early convergence while the BFGS may continue much further along the ridge and find very different parameter values.  Of course a likelihood surface with strong flat ridges makes the MLEs less informative...
</p>
<p>Note this is mainly a problem if the time series are short or very gappy.  If the time series are long, then the likelihood surface should be nice with a single interior peak.  In this case, the quasi-Newton algorithm works well but it can still be sensitive (and slow) if not started with a good initial condition.  Thus starting it with the estimates from the EM algorithm is often desirable.
</p>
<p>One should be aware that the prior set on the variance of the initial states at t=0  or t=1 can have catastrophic effects on one's estimates if the presumed prior covariance structure conflicts with the structure implied by the MARSS model.  For example, if you use a diagonal variance-covariance matrix for the prior but the model implies a variance-covariance matrix with non-zero covariances, your MLE estimates can be strongly influenced by the prior variance-covariance matrix.  Setting a diffuse prior does not help because the diffuse prior still has the correlation structure specified by V0.  One way to detect priors effects is to compare the BFGS estimates to the EM estimates.  Persistent differences typically signify a problem with the correlation structure in the prior conflicting with the implied correlation structure in the MARSS model. 
</p>


<h3>Author(s)</h3>

<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+MARSS">MARSS</a>()</code>, <code><a href="#topic+MARSSkem">MARSSkem</a>()</code>,  <code><a href="#topic+marssMLE">marssMLE</a>()</code>,  <code><a href="stats.html#topic+optim">optim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4, ] # remove the year row

# fit a model with EM and then use that fit as the start for BFGS
# fit a model with 1 hidden state where obs errors are iid
# R="diagonal and equal" is the default so not specified
# Q is fixed
kemfit &lt;- MARSS(dat, model = list(Z = matrix(1, 3, 1), Q = matrix(.01)))
bfgsfit &lt;- MARSS(dat,
  model = list(Z = matrix(1, 3, 1), Q = matrix(.01)),
  inits = coef(kemfit, form = "marss"), method = "BFGS"
)
</code></pre>

<hr>
<h2 id='MARSSparamCIs'> Standard Errors, Confidence Intervals and Bias for MARSS Parameters </h2><span id='topic+MARSSparamCIs'></span>

<h3>Description</h3>

<p>Computes standard errors, confidence intervals and bias for the maximum-likelihood estimates of MARSS model parameters.  If you want confidence intervals on the estimated hidden states, see <code><a href="#topic+print.marssMLE">print.marssMLE</a>()</code> and look for <code>states.cis</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSparamCIs(MLEobj, method = "hessian", alpha = 0.05, nboot =
    1000, silent = TRUE, hessian.fun = "Harvey1989")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSparamCIs_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. Must have a <code>$par</code> element containing the MLE parameter estimates. </p>
</td></tr>
<tr><td><code id="MARSSparamCIs_+3A_method">method</code></td>
<td>
<p> Method for calculating the standard errors: &quot;hessian&quot;, &quot;parametric&quot;, and &quot;innovations&quot; implemented currently. </p>
</td></tr>
<tr><td><code id="MARSSparamCIs_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for the 1-alpha confidence intervals. </p>
</td></tr>
<tr><td><code id="MARSSparamCIs_+3A_nboot">nboot</code></td>
<td>
<p> Number of bootstraps to use for &quot;parametric&quot; and &quot;innovations&quot; methods. </p>
</td></tr>
<tr><td><code id="MARSSparamCIs_+3A_hessian.fun">hessian.fun</code></td>
<td>
<p> The function to use for computing the Hessian. Options are &quot;Harvey1989&quot; (default analytical) or two numerical options: &quot;fdHess&quot; and &quot;optim&quot;. See <code><a href="#topic+MARSShessian">MARSShessian</a></code>.</p>
</td></tr>
<tr><td><code id="MARSSparamCIs_+3A_silent">silent</code></td>
<td>
<p> If false, a progress bar is shown for &quot;parametric&quot; and &quot;innovations&quot; methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Approximate confidence intervals (CIs) on the model parameters may be calculated from the observed Fisher Information matrix (&quot;Hessian CIs&quot;, see <code><a href="#topic+MARSSFisherI">MARSSFisherI</a>()</code>) or parametric or non-parametric (innovations) bootstrapping using <code>nboot</code> bootstraps.  The Hessian CIs are based on the asymptotic normality of MLE parameters under a large-sample approximation.  The Hessian computation for variance-covariance matrices is a symmetric approximation and the lower CIs for variances might be negative.  Bootstrap estimates of parameter bias are reported if method &quot;parametric&quot; or &quot;innovations&quot; is specified.
</p>
<p>Note, these are added to the <code>par</code>  elements of a <code><a href="#topic+marssMLE">marssMLE</a></code> object but are in &quot;marss&quot; form not &quot;marxss&quot; form. Thus the <code>MLEobj$par.upCI</code> and related elements that are added to the <code><a href="#topic+marssMLE">marssMLE</a></code> object may not look familiar to the user.  Instead the user should extract these elements using <code>print(MLEobj)</code> and passing in the argument <code>what</code> set to &quot;par.se&quot;,&quot;par.bias&quot;,&quot;par.lowCIs&quot;, or &quot;par.upCIs&quot;.  See <code><a href="#topic+print.marssMLE">print</a>()</code>. Or use <code><a href="#topic+tidy.marssMLE">tidy</a>()</code>.
</p>


<h3>Value</h3>

<p><code>MARSSparamCIs</code> returns the <code><a href="#topic+marssMLE">marssMLE</a></code> object passed in, with additional components <code>par.se</code>, <code>par.upCI</code>, <code>par.lowCI</code>, <code>par.CI.alpha</code>, <code>par.CI.method</code>, <code>par.CI.nboot</code> and <code>par.bias</code> (if method is &quot;parametric&quot; or &quot;innovations&quot;).
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.
</p>


<h3>References</h3>

 
<p>Holmes, E. E., E. J. Ward, and M. D. Scheuerell (2012) Analysis of multivariate time-series using the MARSS package. NOAA Fisheries, Northwest Fisheries Science
Center, 2725 Montlake Blvd E., Seattle, WA 98112   Type <code>RShowDoc("UserGuide",package="MARSS")</code> to open a copy.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSboot">MARSSboot</a>()</code>, <code><a href="#topic+MARSSinnovationsboot">MARSSinnovationsboot</a>()</code>, <code><a href="#topic+MARSShessian">MARSShessian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4, ]
kem &lt;- MARSS(dat, model = list(
  Z = matrix(1, 3, 1),
  R = "diagonal and unequal"
))
kem.with.CIs.from.hessian &lt;- MARSSparamCIs(kem)
kem.with.CIs.from.hessian
</code></pre>

<hr>
<h2 id='marssPredict-class'>Class &quot;marssPredict&quot;</h2><span id='topic+marssPredict'></span>

<h3>Description</h3>

<p><code>marssPredict</code> objects are returned by <code><a href="#topic+predict.marssMLE">predict.marssMLE</a></code> and <code><a href="#topic+forecast.marssMLE">forecast.marssMLE</a></code>.
</p>
<p>A marssPredict object in the  <code><a href="#topic+MARSS-package">MARSS-package</a></code> has the output with intervals, the original model and values needed for plotting. The object is mainly used for <code><a href="#topic+plot.marssPredict">plot.marssPredict</a>()</code> and <code><a href="#topic+print.marssPredict">print.marssPredict</a>()</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "marssPredict")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p><code>signature(object = "marssPredict")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, WA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.marssPredict">plot.marssPredict</a>()</code>, <code><a href="#topic+predict.marssMLE">predict.marssMLE</a>()</code>, <code><a href="#topic+forecast.marssMLE">forecast.marssMLE</a>()</code>
</p>

<hr>
<h2 id='MARSSresiduals'> MARSS Residuals </h2><span id='topic+MARSSresiduals'></span>

<h3>Description</h3>

<p>The normal residuals function is <code><a href="#topic+residuals.marssMLE">residuals</a>()</code>. <code>MARSSresiduals()</code> returns residuals as a list of matrices while <code><a href="#topic+residuals.marssMLE">residuals</a>()</code> returns the same information in a data frame.  This function calculates the residuals, residuals variance, and standardized residuals for the one-step-ahead (conditioned on data up to <code class="reqn">t-1</code>), the smoothed (conditioned on all the data), and contemporaneous (conditioned on data up to <code class="reqn">t</code>) residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSresiduals(object, ..., type = c("tT", "tt1", "tt"), 
    normalize = FALSE, silent = FALSE, 
    fun.kf = c("MARSSkfas", "MARSSkfss"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSresiduals_+3A_object">object</code></td>
<td>
<p> An object of class <code>marssMLE</code>.</p>
</td></tr>
<tr><td><code id="MARSSresiduals_+3A_...">...</code></td>
<td>
<p> Additional arguments to be passed to the residuals functions. For type=&quot;tT&quot;, <code>Harvey=TRUE</code> can be passed into to use the Harvey et al (1998) algorithm. </p>
</td></tr>
<tr><td><code id="MARSSresiduals_+3A_type">type</code></td>
<td>
 <p><code>"tT"</code> for smoothed residuals conditioned on all the data <code class="reqn">t=1</code> to <code class="reqn">T</code>, aka smoothation residuals. <code>"tt1"</code> for one-step-ahead residuals, aka innovations residuals. <code>"tt"</code> for contemporaneous residuals.</p>
</td></tr>
<tr><td><code id="MARSSresiduals_+3A_normalize">normalize</code></td>
<td>
<p> TRUE/FALSE See details.</p>
</td></tr>
<tr><td><code id="MARSSresiduals_+3A_silent">silent</code></td>
<td>
<p> If TRUE, do not print inversion warnings. </p>
</td></tr>
<tr><td><code id="MARSSresiduals_+3A_fun.kf">fun.kf</code></td>
<td>
<p> Kalman filter function to use. Can be ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For smoothed residuals, see <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>.
</p>
<p>For one-step-ahead residuals, see <code><a href="#topic+MARSSresiduals.tt1">MARSSresiduals.tt1</a>()</code>.
</p>
<p>For contemporaneous residuals, see <code><a href="#topic+MARSSresiduals.tt">MARSSresiduals.tt</a>()</code>.
</p>
<p><strong>Standardized residuals</strong>
</p>
<p>Standardized residuals have been adjusted by the variance of the residuals at time <code class="reqn">t</code> such that the variance of the residuals at time <code class="reqn">t</code> equals 1. Given the normality assumption, this means that one typically sees +/- 2 confidence interval lines on standardized residuals plots. 
</p>
<p><code>std.residuals</code> are Cholesky standardized residuals. These are the residuals multiplied by the inverse of the lower triangle of the Cholesky decomposition of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t^{-1/2} \hat{\mathbf{v}}_t.</code>
</p>

<p>These residuals are uncorrelated with each other, although they are not necessarily temporally uncorrelated (innovations residuals are temporally uncorrelated). 
</p>
<p>The interpretation of the Cholesky standardized residuals is not straight-forward when the <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code> variance-covariance matrices are non-diagonal.  The residuals which were generated by a non-diagonal variance-covariance matrices are transformed into orthogonal residuals in <code class="reqn">\textrm{MVN}(0,\mathbf{I})</code> space.  For example, if v is 2x2 correlated errors with variance-covariance matrix <code class="reqn">\mathbf{R}</code>. The transformed residuals (from this function) for the i-th row of v is a combination of the row 1 effect and the row 1 effect plus the row 2 effect.  So in this case, row 2 of the transformed residuals would not be regarded as solely the row 2 residual but rather how different row 2 is from row 1, relative to expected.  If the errors are highly correlated, then the Cholesky standardized residuals can look rather non-intuitive.
</p>
<p><code>mar.residuals</code> are the marginal standardized residuals. These are the residuals multiplied by the inverse of the diagonal matrix formed from the square-root of the diagonal of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{dg}(\hat{\Sigma}_t)^{-1/2} \hat{\mathbf{v}}_t,</code>
</p>
<p> where <code class="reqn">dg(A)</code> is the square matrix formed from the diagonal of <code class="reqn">A</code>, aka <code>diag(diag(A))</code>. These residuals will be correlated if the variance matrix is non-diagonal. 
</p>
<p>The Block Cholesky standardized residuals are like the Cholesky standardized residuals except that the full variance-covariance matrix is not used, only the variance-covariance matrix for the model or state residuals (respectively) is used for standardization. For the model residuals, the Block Cholesky standardized residuals will be the same as the Cholesky standardized residuals because the upper triangle of the lower triangle of the Cholesky decomposition (which is what we standardize by) is all zero. For <code>type="tt1"</code> and <code>type="tt"</code>, the Block Cholesky standardized state residuals will be the same as the Cholesky standardized state residuals because in the former, the model and state residuals are uncorrelated and in the latter, the state residuals do not exist. For <code>type="tT"</code>, the model and state residuals are correlated and the Block Cholesky standardized residuals will be different than the Cholesky standardized residuals.
</p>
<p><strong>Normalized residuals</strong>
</p>
<p>If <code>normalize=FALSE</code>, the unconditional variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> are <code class="reqn">\mathbf{R}</code> and <code class="reqn">\mathbf{Q}</code> and the model is assumed to be written as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{w}_t</code>
</p>

<p>If <code>normalize=TRUE</code>, the model is assumed to be written as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{H}\mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{G}\mathbf{w}_t</code>
</p>

<p>with the variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> equal to <code class="reqn">\mathbf{I}</code> (identity).
</p>
<p><strong>Missing or left-out data</strong>
</p>
<p>See the discussion of residuals for missing and left-out data in <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>.
</p>


<h3>Value</h3>

<p>A list of the following components
</p>
<table>
<tr><td><code>model.residuals</code></td>
<td>
<p> The model residuals (data minus model predicted values) as a n x T matrix. </p>
</td></tr>
<tr><td><code>state.residuals</code></td>
<td>
<p> The  state residuals. This is the state residual for the transition from <code class="reqn">t=t</code> to <code class="reqn">t+1</code> thus the last time step will be NA (since <code class="reqn">T+1</code> is past the data). State residuals do not exist for the <code>type="tt"</code> case (since this would required the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on data to <code class="reqn">t+1</code>). </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> The residuals as a (n+m) x T matrix with <code>model.residuals</code> on top and <code>state.residuals</code> below. </p>
</td></tr>
<tr><td><code>var.residuals</code></td>
<td>
<p> The variance of the model residuals and state residuals as a (n+m) x (n+m) x T matrix with the model residuals variance in rows/columns 1 to n and state residuals variances in rows/columns n+1 to n+m. The last time step will be all NA since the state residual is for <code class="reqn">t=t </code> to <code class="reqn">t+1</code>.</p>
</td></tr>
<tr><td><code>std.residuals</code></td>
<td>
<p> The Cholesky standardized residuals as a (n+m) x T matrix. This is <code>residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals</code>. </p>
</td></tr>
<tr><td><code>mar.residuals</code></td>
<td>
<p> The marginal standardized residuals as a (n+m) x T matrix. This is <code>residuals</code> multiplied by the inverse of the diagonal matrix formed by the square-root of the diagonal of <code>var.residuals</code>. </p>
</td></tr>
<tr><td><code>bchol.residuals</code></td>
<td>
<p> The Block Cholesky standardized residuals as a (n+m) x T matrix. This is <code>model.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[1:n,1:n,]</code> and <code>state.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[(n+1):(n+m),(n+1):(n+m),]</code>. </p>
</td></tr>
<tr><td><code>E.obs.residuals</code></td>
<td>
<p> The expected value of the model residuals conditioned on the observed data. Returned as a n x T matrix.  For observed data, this will be the observed model residuals. For unobserved data, this will be 0 if <code class="reqn">\mathbf{R}</code> is diagonal but non-zero if <code class="reqn">\mathbf{R}</code> is non-diagonal. See <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>. </p>
</td></tr>
<tr><td><code>var.obs.residuals</code></td>
<td>
<p> The variance of the model residuals conditioned on the observed data. Returned as a n x n x T matrix.  For observed data, this will be 0. See <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>. </p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p> Any warning messages. This will be printed unless Object$control$trace = -1 (suppress all error messages). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045.
</p>
<p>See also the discussion and references in <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>,  <code><a href="#topic+MARSSresiduals.tt1">MARSSresiduals.tt1</a>()</code> and <code><a href="#topic+MARSSresiduals.tt">MARSSresiduals.tt</a>()</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+residuals.marssMLE">residuals.marssMLE</a>()</code>, <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>, <code><a href="#topic+MARSSresiduals.tt1">MARSSresiduals.tt1</a>()</code>, <code><a href="#topic+plot.marssMLE">plot.marssMLE</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- t(harborSeal)
  dat &lt;- dat[c(2,11),]
  fit &lt;- MARSS(dat)
  
  #state smoothed residuals
  state.resids1 &lt;- MARSSresiduals(fit, type="tT")$state.residuals
  #this is the same as
  states &lt;- fit$states
  Q &lt;- coef(fit, type="matrix")$Q
  state.resids2 &lt;- states[,2:30]-states[,1:29]-matrix(coef(fit,type="matrix")$U,2,29)
  #compare the two
  cbind(t(state.resids1[,-30]), t(state.resids2))

  #normalize to variance of 1
  state.resids1 &lt;- MARSSresiduals(fit, type="tT", normalize=TRUE)$state.residuals
  state.resids2 &lt;- (solve(t(chol(Q))) %*% state.resids2)
  cbind(t(state.resids1[,-30]), t(state.resids2))

  #one-step-ahead standardized residuals
  MARSSresiduals(fit, type="tt1")$std.residuals
</code></pre>

<hr>
<h2 id='marssResiduals-class'>Class &quot;marssResiduals&quot;</h2><span id='topic+marssResiduals'></span>

<h3>Description</h3>

<p><code><a href="#topic+marssResiduals">marssResiduals</a></code> are the objects returned by <code><a href="#topic+residuals.marssMLE">residuals.marssMLE</a></code> in the package <code><a href="#topic+MARSS-package">MARSS-package</a></code>. It is a data frame in tibble format (but not tibble class).
</p>
<p><code>standardization</code> 
</p>

<ul>
<li><p> &quot;Cholesky&quot; means it is standardized by the Cholesky transformation of the full variance-covariance matrix of the model and state residuals. 
</p>
</li>
<li><p> &quot;marginal&quot; means that the residual is standardized by its standard deviation, i.e. the square root of the value on the diagonal of the variance-covariance matrix of the model and state residuals. 
</p>
</li></ul>

<p><code>type</code> 
</p>

<ul>
<li> <p><code>"tT"</code> means the fitted values are computed conditioned on all the data. See <code><a href="#topic+fitted.marssMLE">fitted</a>()</code> with <code>type="ytT"</code> or <code>type="xtT"</code>.
</p>
</li>
<li> <p><code>"tt1"</code> means the fitted values are computed conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t-1</code>. See <code><a href="#topic+fitted.marssMLE">fitted</a>()</code> with <code>type="ytt1"</code> or <code>type="xtt1"</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.marssMLE">residuals.marssMLE</a>()</code>, <code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code> 
</p>

<hr>
<h2 id='MARSSresiduals.tt'> MARSS Contemporaneous Residuals </h2><span id='topic+MARSSresiduals.tt'></span>

<h3>Description</h3>

<p>Calculates the standardized (or auxiliary) contemporaneous residuals, aka the residuals and their variance conditioned on the data up to time <code class="reqn">t</code>.  Contemporaneous residuals are only for the observations. Not exported. Access this function with <code>MARSSresiduals(object, type="tt")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSresiduals.tt(object, method = c("SS"), normalize = FALSE, 
    silent = FALSE, fun.kf = c("MARSSkfas", "MARSSkfss"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSresiduals.tt_+3A_object">object</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>.</p>
</td></tr>
<tr><td><code id="MARSSresiduals.tt_+3A_method">method</code></td>
<td>
<p> Algorithm to use. Currently only &quot;SS&quot;. </p>
</td></tr>
<tr><td><code id="MARSSresiduals.tt_+3A_normalize">normalize</code></td>
<td>
<p> TRUE/FALSE See details. </p>
</td></tr>
<tr><td><code id="MARSSresiduals.tt_+3A_silent">silent</code></td>
<td>
<p> If TRUE, don't print inversion warnings. </p>
</td></tr>
<tr><td><code id="MARSSresiduals.tt_+3A_fun.kf">fun.kf</code></td>
<td>
<p> Can be ignored. This will change the Kalman filter/smoother function from the value in object$fun.kf if desired. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the conditional expected value (mean) and variance of the model contemporaneous residuals.  'conditional' means in this context, conditioned on the observed data up to time <code class="reqn">t</code> and a set of parameters.  
</p>
<p><strong>Model residuals</strong>
</p>
<p><code class="reqn">\mathbf{v}_t</code> is the difference between the data and the predicted data at time <code class="reqn">t</code> given <code class="reqn">\mathbf{x}_t</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{v}_t = \mathbf{y}_t - \mathbf{Z} \mathbf{x}_t - \mathbf{a} - \mathbf{d}\mathbf{d}_{t}</code>
</p>

<p>The observed model residuals <code class="reqn">\hat{\mathbf{v}}_t</code> are the difference between the observed data and the predicted data at time <code class="reqn">t</code> using the fitted model. <code>MARSSresiduals.tt</code> fits the model using the data up to time <code class="reqn">t</code>. So
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{v}}_t = \mathbf{y}_t - \mathbf{Z}\mathbf{x}_t^{t} - \mathbf{a} - \mathbf{D}\mathbf{d}_{t}</code>
</p>

<p>where <code class="reqn">\mathbf{x}_t^{t}</code> is the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on the data from 1 to <code class="reqn">t</code> from the Kalman filter. <code class="reqn">\mathbf{y}_t</code> are your data and missing values will appear as NA. These will be returned in <code>residuals</code>.
</p>
<p><code>var.residuals</code> returned by the function is the conditional variance of the residuals conditioned on the data up to <code class="reqn">t</code> and the parameter set <code class="reqn">\Theta</code>.  The conditional variance is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t = \mathbf{R}+\mathbf{Z} \mathbf{V}_t^{t} \mathbf{Z}^\top </code>
</p>

<p>where <code class="reqn">\mathbf{V}_t^{t}</code> is the variance of <code class="reqn">\mathbf{X}_t</code> conditioned on the data up to time <code class="reqn">t</code>. This is returned by <code><a href="#topic+MARSSkfss">MARSSkfss</a></code> in <code>Vtt</code>.
</p>
<p><strong>Standardized residuals</strong>
</p>
<p><code>std.residuals</code> are Cholesky standardized residuals. These are the residuals multiplied by the inverse of the lower triangle of the Cholesky decomposition of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t^{-1/2} \hat{\mathbf{v}}_t</code>
</p>
<p>.
These residuals are uncorrelated unlike marginal residuals. 
</p>
<p>The interpretation of the Cholesky standardized residuals is not straight-forward when the <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code> variance-covariance matrices are non-diagonal.  The residuals which were generated by a non-diagonal variance-covariance matrices are transformed into orthogonal residuals in <code class="reqn">\textrm{MVN}(0,\mathbf{I})</code> space.  For example, if v is 2x2 correlated errors with variance-covariance matrix R. The transformed residuals (from this function) for the i-th row of v is a combination of the row 1 effect and the row 1 effect plus the row 2 effect.  So in this case, row 2 of the transformed residuals would not be regarded as solely the row 2 residual but rather how different row 2 is from row 1, relative to expected.  If the errors are highly correlated, then the Cholesky standardized residuals can look rather non-intuitive.
</p>
<p><code>mar.residuals</code> are the marginal standardized residuals. These are the residuals multiplied by the inverse of the diagonal matrix formed from the square-root of the diagonal of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{dg}(\hat{\Sigma}_t)^{-1/2} \hat{\mathbf{v}}_t</code>
</p>
<p>, where 'dg(A)' is the square matrix formed from the diagonal of A, aka <code>diag(diag(A))</code>. These residuals will be correlated if the variance matrix is non-diagonal. 
</p>
<p><strong>Normalized residuals</strong>
</p>
<p>If <code>normalize=FALSE</code>, the unconditional variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> are <code class="reqn">\mathbf{R}</code> and <code class="reqn">\mathbf{Q}</code> and the model is assumed to be written as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{w}_t</code>
</p>

<p>If normalize=TRUE, the model is assumed to be written
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{H}\mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{G}\mathbf{w}_t</code>
</p>

<p>with the variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> equal to <code class="reqn">\mathbf{I}</code> (identity).
</p>
<p><code>MARSSresiduals()</code> returns the residuals defined as in the first equations. To get normalized residuals (second equation) as used in Harvey et al. (1998), then use <code>normalize=TRUE</code>.  In that case the unconditional variance of residuals will be <code class="reqn">\mathbf{I}</code> instead of <code class="reqn">\mathbf{R}</code> and <code class="reqn">\mathbf{Q}</code>.  Note, that the normalized residuals are not the same as the standardized residuals.  In former, the unconditional residuals have a variance of <code class="reqn">\mathbf{I}</code> while in the latter it is the conditional residuals that have a variance of <code class="reqn">\mathbf{I}</code>.
</p>


<h3>Value</h3>

<p>A list with the following components  
</p>
<table>
<tr><td><code>model.residuals</code></td>
<td>
<p> The observed contemporaneous model residuals: data minus the model predictions conditioned on the data 1 to t. A n x T matrix. NAs will appear where the data are missing. </p>
</td></tr>
<tr><td><code>state.residuals</code></td>
<td>
<p> All NA. There are no contemporaneous residuals for the states. </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> The residuals. <code>model.residuals</code> are in rows 1:n and <code>state.residuals</code> are in rows n+1:n+m. </p>
</td></tr>
<tr><td><code>var.residuals</code></td>
<td>
<p> The joint variance of the residuals conditioned on observed data from 1 to t-. This only has values in the 1:n,1:n upper block for the model residuals. </p>
</td></tr>
<tr><td><code>std.residuals</code></td>
<td>
<p> The Cholesky standardized residuals as a n+m x T matrix. This is <code>residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals</code>. The model standardized residuals associated with the missing data are replaced with NA. Note because the contemporaneous state residuals do not exist, rows n+1:n+m are all NA. </p>
</td></tr>
<tr><td><code>mar.residuals</code></td>
<td>
<p> The marginal standardized residuals as a n+m x T matrix. This is <code>residuals</code> multiplied by the inverse of the diagonal matrix formed by the square-root of the diagonal of <code>var.residuals</code>.  The model marginal residuals associated with the missing data are replaced with NA. </p>
</td></tr>
<tr><td><code>bchol.residuals</code></td>
<td>
<p> Because state residuals do not exist, this will be equivalent to the Cholesky standardized residuals, <code>std.residuals</code>. </p>
</td></tr>
<tr><td><code>E.obs.residuals</code></td>
<td>
<p> The expected value of the model residuals conditioned on the observed data 1 to t. Returned as a n x T matrix. </p>
</td></tr>
<tr><td><code>var.obs.residuals</code></td>
<td>
<p> The variance of the model residuals conditioned on the observed data. Returned as a n x n x T matrix.  For observed data, this will be 0. See  <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code> for a discussion of these residuals and where they might be used. </p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p> Any warning messages. This will be printed unless Object$control$trace = -1 (suppress all error messages). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>, <code><a href="#topic+MARSSresiduals.tt1">MARSSresiduals.tt1</a>()</code>, <code><a href="#topic+fitted.marssMLE">fitted.marssMLE</a>()</code>, <code><a href="#topic+plot.marssMLE">plot.marssMLE</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- t(harborSeal)
  dat &lt;- dat[c(2,11),]
  fit &lt;- MARSS(dat)
  
  # Returns a matrix
  MARSSresiduals(fit, type="tt")$std.residuals
  # Returns a data frame in long form
  residuals(fit, type="tt")
</code></pre>

<hr>
<h2 id='MARSSresiduals.tT'> MARSS Smoothed Residuals </h2><span id='topic+MARSSresiduals.tT'></span>

<h3>Description</h3>

<p>Calculates the standardized (or auxiliary) smoothed residuals sensu Harvey, Koopman and Penzer (1998). The expected values and variance for missing (or left-out) data are also returned (Holmes 2014). Not exported. Access this function with <code>MARSSresiduals(object, type="tT")</code>. At time <code class="reqn">t</code> (in the returned matrices), the model residuals are for time <code class="reqn">t</code>, while the state residuals are for the transition from <code class="reqn">t</code> to <code class="reqn">t+1</code> following the convention in Harvey, Koopman and Penzer (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSresiduals.tT(object, Harvey = FALSE, normalize = FALSE, 
    silent = FALSE, fun.kf = c("MARSSkfas", "MARSSkfss"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSresiduals.tT_+3A_object">object</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>.</p>
</td></tr>
<tr><td><code id="MARSSresiduals.tT_+3A_harvey">Harvey</code></td>
<td>
<p> TRUE/FALSE. Use the Harvey et al. (1998) algorithm or use the Holmes (2014) algorithm. The values are the same except for missing values. </p>
</td></tr>
<tr><td><code id="MARSSresiduals.tT_+3A_normalize">normalize</code></td>
<td>
<p> TRUE/FALSE See details.</p>
</td></tr>
<tr><td><code id="MARSSresiduals.tT_+3A_silent">silent</code></td>
<td>
<p> If TRUE, don't print inversion warnings. </p>
</td></tr>
<tr><td><code id="MARSSresiduals.tT_+3A_fun.kf">fun.kf</code></td>
<td>
<p> Kalman filter function to use. Can be ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the raw, the Cholesky standardized and the marginal standardized smoothed model and state residuals.  'smoothed' means conditioned on all the observed data and a set of parameters. These are the residuals presented in Harvey, Koopman and Penzer (1998) pages 112-113, with the addition of the values for unobserved data (Holmes 2014).  If Harvey=TRUE, the function uses the algorithm on page 112 of Harvey, Koopman and Penzer (1998) to compute the conditional residuals and variance of the residuals.  If Harvey=FALSE, the function uses the equations in the technical report (Holmes 2014).  Unlike the innovations residuals, the smoothed residuals are autocorrelated (section 4.1 in Harvey and Koopman 1992) and thus an ACF test on these residuals would not reveal model inadequacy.
</p>
<p>The residuals matrix has a value for each time step.  The residuals in column <code class="reqn">t</code> rows 1 to n are the model residuals associated with the data at time <code class="reqn">t</code>. The residuals in rows n+1 to n+m are the state residuals associated with the transition from <code class="reqn">\mathbf{x}_{t}</code> to <code class="reqn">\mathbf{x}_{t+1}</code>, not the transition from <code class="reqn">\mathbf{x}_{t-1}</code> to <code class="reqn">\mathbf{x}_{t}</code>. Because <code class="reqn">\mathbf{x}_{t+1}</code> does not exist at time <code class="reqn">T</code>, the state residuals and associated variances at time <code class="reqn">T</code> are NA.
</p>
<p>Below the conditional residuals and their variance are discussed. The random variables are capitalized and the realizations from the random variables are lower case. The random variables are <code class="reqn">\mathbf{X}</code>, <code class="reqn">\mathbf{Y}</code>, <code class="reqn">\mathbf{V}</code> and <code class="reqn">\mathbf{W}</code>. There are two types of <code class="reqn">\mathbf{Y}</code>. The observed <code class="reqn">\mathbf{Y}</code> that are used to estimate the states <code class="reqn">\mathbf{x}</code>. These are termed <code class="reqn">\mathbf{Y}^{(1)}</code>. The unobserved  <code class="reqn">\mathbf{Y}</code> are termed <code class="reqn">\mathbf{Y}^{(2)}</code>. These are not used to estimate the states <code class="reqn">\mathbf{x}</code> and we may or may not know the values of <code class="reqn">\mathbf{y}^{(2)}</code>. Typically we treat <code class="reqn">\mathbf{y}^{(2)}</code> as unknown but it may be known but we did not include it in our model fitting.  Note that the model parameters <code class="reqn">\Theta</code> are treated as fixed or known. The 'fitting' does not involve estimating <code class="reqn">\Theta</code>; it involves estimating <code class="reqn">\mathbf{x}</code>. All MARSS parameters can be time varying but the <code class="reqn">t</code> subscripts are left off parameters to reduce clutter.
</p>
<p><strong>Model residuals</strong>
</p>
<p><code class="reqn">\mathbf{v}_{t}</code> is the difference between the data and the predicted data at time <code class="reqn">t</code> given <code class="reqn">\mathbf{x}_{t}</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{v}_{t} = \mathbf{y}_{t} - \mathbf{Z} \mathbf{x}_{t} - \mathbf{a} - \mathbf{D}\mathbf{d}_t</code>
</p>

<p><code class="reqn">\mathbf{x}_{t}</code> is unknown (hidden) and our data are one realization of <code class="reqn">\mathbf{y}_{t}</code>. The observed model residuals <code class="reqn">\hat{\mathbf{v}}_{t}</code> are the difference between the observed data and the predicted data at time <code class="reqn">t</code> using the fitted model. <code>MARSSresiduals.tT</code> fits the model using all the data, thus
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{v}}_{t} = \mathbf{y}_{t} - \mathbf{Z}\mathbf{x}_{t}^T - \mathbf{a} - \mathbf{D}\mathbf{d}_t</code>
</p>

<p>where <code class="reqn">\mathbf{x}_{t}^T</code> is the expected value of <code class="reqn">\mathbf{X}_{t}</code> conditioned on the data from 1 to <code class="reqn">T</code> (all the data), i.e. the Kalman smoother estimate of the states at time <code class="reqn">t</code>. <code class="reqn">\mathbf{y}_{t}</code> are your data and missing values will appear as NA in the observed model residuals. These are returned as <code>model.residuals</code> and rows 1 to <code class="reqn">n</code> of <code>residuals</code>.
</p>
<p><code>res1</code> and <code>res2</code> in the code below will be the same.
</p>
<pre>dat = t(harborSeal)[2:3,]
fit = MARSS(dat)
Z = coef(fit, type="matrix")$Z
A = coef(fit, type="matrix")$A
res1 = dat - Z %*% fit$states - A %*% matrix(1,1,ncol(dat))
res2 = MARSSresiduals(fit, type="tT")$model.residuals
</pre>
<p><strong>State residuals</strong>
</p>
<p><code class="reqn">\mathbf{w}_{t+1}</code> are the difference between the state at time <code class="reqn">t+1</code> and the expected value of the state at time <code class="reqn">t+1</code> given the state at time <code class="reqn">t</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{w}_{t+1} = \mathbf{x}_{t+1} - \mathbf{B} \mathbf{x}_{t} - \mathbf{u} - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>

<p>The estimated state residuals <code class="reqn">\hat{\mathbf{w}}_{t+1}</code> are the difference between estimate of <code class="reqn">\mathbf{x}_{t+1}</code> minus the estimate using <code class="reqn">\mathbf{x}_{t}</code>. 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{w}}_{t+1} = \mathbf{x}_{t+1}^T - \mathbf{B}\mathbf{x}_{t}^T - \mathbf{u} - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>

<p>where <code class="reqn">\mathbf{x}_{t+1}^T</code> is the Kalman smoother estimate of the states at time <code class="reqn">t+1</code> and <code class="reqn">\mathbf{x}_{t}^T</code> is the Kalman smoother estimate of the states at time <code class="reqn">t</code>.
The estimated state residuals <code class="reqn">\mathbf{w}_{t+1}</code> are returned in <code>state.residuals</code> and rows <code class="reqn">n+1</code> to <code class="reqn">n+m</code> of <code>residuals</code>. <code>state.residuals[,t]</code> is <code class="reqn">\mathbf{w}_{t+1}</code> (notice time subscript difference). There are no NAs in the estimated state residuals as an estimate of the state exists whether or not there are associated data.
</p>
<p><code>res1</code> and <code>res2</code> in the code below will be the same.
</p>
<pre>dat &lt;- t(harborSeal)[2:3,]
TT &lt;- ncol(dat)
fit &lt;- MARSS(dat)
B &lt;- coef(fit, type="matrix")$B
U &lt;- coef(fit, type="matrix")$U
statestp1 &lt;- MARSSkf(fit)$xtT[,2:TT]
statest &lt;- MARSSkf(fit)$xtT[,1:(TT-1)]
res1 &lt;- statestp1 - B %*% statest - U %*% matrix(1,1,TT-1)
res2 &lt;- MARSSresiduals(fit, type="tT")$state.residuals[,1:(TT-1)]
</pre>
<p>Note that the state residual at the last time step (not shown) will be NA because it is the residual associated with <code class="reqn">\mathbf{x}_T</code> to <code class="reqn">\mathbf{x}_{T+1}</code> and <code class="reqn">T+1</code> is beyond the data.  Similarly, the variance matrix at the last time step will have NAs for the same reason.
</p>
<p><strong>Variance of the residuals</strong>
</p>
<p>In a state-space model, <code class="reqn">\mathbf{X}</code> and <code class="reqn">\mathbf{Y}</code> are stochastic, and the model and state residuals are random variables <code class="reqn">\hat{\mathbf{V}}_{t}</code> and <code class="reqn">\hat{\mathbf{W}}_{t+1}</code>. To evaluate the residuals we observed (with <code class="reqn">\mathbf{y}^{(1)}</code>), we use the joint distribution of <code class="reqn">\hat{\mathbf{V}}_{t}, \hat{\mathbf{W}}_{t+1}</code> across all the different possible data sets that our MARSS equations with parameters <code class="reqn">\Theta</code> might generate. Denote the matrix of <code class="reqn">\hat{\mathbf{V}}_{t}, \hat{\mathbf{W}}_{t+1}</code>, as <code class="reqn">\widehat{\mathcal{E}}_{t}</code>. That distribution has an expected value (mean) and variance:
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{E}[\widehat{\mathcal{E}}_{t}] = 0; \textrm{var}[\widehat{\mathcal{E}}_{t}] = \hat{\Sigma}_{t} </code>
</p>

<p>Our observed residuals (returned in <code>residuals</code>) are one sample from this distribution.
To standardize the observed residuals, we will use <code class="reqn"> \hat{\Sigma}_{t} </code>. <code class="reqn"> \hat{\Sigma}_{t} </code> is returned in <code>var.residuals</code>. Rows/columns 1 to <code class="reqn">n</code> are the conditional variances of the model residuals and rows/columns <code class="reqn">n+1</code> to <code class="reqn">n+m</code> are the conditional variances of the state residuals. The off-diagonal blocks are the covariances between the two types of residuals.
</p>
<p><strong>Standardized residuals</strong>
</p>
<p><code>MARSSresiduals</code> will return the Cholesky standardized residuals sensu Harvey et al. (1998) in <code>std.residuals</code> for outlier and shock detection.  These are the model and state residuals multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals</code> (note <code>chol()</code> in R returns the upper triangle thus a transpose is needed). The standardized model residuals are set to NA when there are missing data. The standardized state residuals however always exist since the expected value of the states exist without data. The calculation of the standardized residuals for both the observations and states requires the full residuals variance matrix. Since the state residuals variance is NA at the last time step, the standardized residual in the last time step will be all NA (for both model and state residuals).
</p>
<p>The interpretation of the Cholesky standardized residuals is not straight-forward when the <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code> variance-covariance matrices are non-diagonal.  The residuals which were generated by a non-diagonal variance-covariance matrices are transformed into orthogonal residuals in <code class="reqn">\textrm{MVN}(0,\mathbf{I})</code> space.  For example, if v is 2x2 correlated errors with variance-covariance matrix R. The transformed residuals (from this function) for the i-th row of <code class="reqn">\mathbf{v}</code> is a combination of the row 1 effect and the row 1 effect plus the row 2 effect.  So in this case, row 2 of the transformed residuals would not be regarded as solely the row 2 residual but rather how different row 2 is from row 1, relative to expected.  If the errors are highly correlated, then the transformed residuals can look rather non-intuitive.
</p>
<p>The marginal standardized residuals are returned in <code>mar.residuals</code>. These are the model and state residuals multiplied by the inverse of the diagonal matrix formed by the square root of the diagonal of <code>var.residuals</code>. These residuals will be correlated (across the residuals at time <code class="reqn">t</code>) but are easier to interpret when <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code> are non-diagonal.
</p>
<p>The Block Cholesky standardized residuals are like the Cholesky standardized residuals except that the full variance-covariance matrix is not used, only the variance-covariance matrix for the model or state residuals (respectively) is used for standardization. For the model residuals, the Block Cholesky standardized residuals will be the same as the Cholesky standardized residuals because the upper triangle of the lower triangle of the Cholesky decomposition (which is what we standardize by) is all zero. For the state residuals, the Block Cholesky standardization will be different because Block Cholesky standardization treats the model and state residuals as independent (which they are not in the smoothations case). 
</p>
<p><strong>Normalized residuals</strong>
</p>
<p>If <code>normalize=FALSE</code>, the unconditional variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> are <code class="reqn">\mathbf{R}</code> and <code class="reqn">\mathbf{Q}</code> and the model is assumed to be written as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{w}_t</code>
</p>

<p>If normalize=TRUE, the model is assumed to be written
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{H}\mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{G}\mathbf{w}_t</code>
</p>

<p>with the variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> equal to <code class="reqn">\mathbf{I}</code> (identity).
</p>
<p><code>MARSSresiduals.tT</code> returns the residuals defined as in the first equations. To get the residuals defined as Harvey et al. (1998) define them (second equations), then use <code>normalize=TRUE</code>.  In that case the unconditional variance of residuals will be <code class="reqn">\mathbf{I}</code> instead of <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code>.
</p>
<p><strong>Missing or left-out data</strong>
</p>
<p><code class="reqn"> \textrm{E}[\widehat{\mathcal{E}}_{t}] </code> and <code class="reqn"> \textrm{var}[\widehat{\mathcal{E}}_{t}] </code> are for the distribution across all possible  <code class="reqn">\mathbf{X}</code> and <code class="reqn">\mathbf{Y}</code>. We can also compute the expected value and variance conditioned on a specific value of <code class="reqn">\mathbf{Y}</code>, the one we observed <code class="reqn">\mathbf{y}^{(1)}</code> (Holmes 2014). If there are no missing values, this is not very interesting as  <code class="reqn">\textrm{E}[\hat{\mathbf{V}}_{t}|\mathbf{y}^{(1)}]=\hat{\mathbf{v}}_{t}</code> and <code class="reqn">\textrm{var}[\hat{\mathbf{V}}_{t}|\mathbf{y}^{(1)}] = 0</code>. If we have data that are missing because we left them out, however, <code class="reqn">\textrm{E}[\hat{\mathbf{V}}_{t}|\mathbf{y}^{(1)}]</code> and <code class="reqn">\textrm{var}[\hat{\mathbf{V}}_{t}|\mathbf{y}^{(1)}]</code> are the values we need to evaluate whether the left-out data are unusual relative to what you expect given the data you did collect. 
</p>
<p><code>E.obs.residuals</code> is the conditional expected value <code class="reqn">\textrm{E}[\hat{\mathbf{V}}|\mathbf{y}^{(1)}]</code> (notice small <code class="reqn">\mathbf{y}</code>). It is 
</p>
<p style="text-align: center;"><code class="reqn">\textrm{E}[\mathbf{Y}_{t}|\mathbf{y}^{(1)}] - \mathbf{Z}\mathbf{x}_t^T - \mathbf{a} </code>
</p>

<p>It is similar to <code class="reqn">\hat{\mathbf{v}}_{t}</code>. The difference is the <code class="reqn">\mathbf{y}</code> term. <code class="reqn">\textrm{E}[\mathbf{Y}^{(1)}_{t}|\mathbf{y}^{(1)}] </code> is <code class="reqn">\mathbf{y}^{(1)}_{t}</code> for the non-missing values. For the missing values, the value depends on <code class="reqn">\mathbf{R}</code>. If <code class="reqn">\mathbf{R}</code> is diagonal, <code class="reqn">\textrm{E}[\mathbf{Y}^{(2)}_{t}|\mathbf{y}^{(1)}] </code> is <code class="reqn">\mathbf{Z}\mathbf{x}_t^T + \mathbf{a}</code> and the expected residual value is 0. If <code class="reqn">\mathbf{R}</code> is non-diagonal however, it will be non-zero.
</p>
<p><code>var.obs.residuals</code> is the conditional variance  <code class="reqn">\textrm{var}[\hat{\mathbf{V}}|\mathbf{y}^{(1)}]</code> (eqn 24 in Holmes (2014)).  For the non-missing values, this variance is 0 since <code class="reqn">\hat{\mathbf{V}}|\mathbf{y}^{(1)}</code> is a fixed value. For the missing values, <code class="reqn">\hat{\mathbf{V}}|\mathbf{y}^{(1)}</code> is not fixed because <code class="reqn">\mathbf{Y}^{(2)}</code> is a random variable. For these values, the variance of <code class="reqn">\hat{\mathbf{V}}|\mathbf{y}^{(1)}</code> is determined by the variance of <code class="reqn">\mathbf{Y}^{(2)}</code> conditioned on <code class="reqn">\mathbf{Y}^{(1)}=\mathbf{y}^{(1)}</code>. This variance matrix is returned in <code>var.obs.residuals</code>. The variance of <code class="reqn">\hat{\mathbf{W}}|\mathbf{y}^{(1)}</code> is 0 and thus is not included.
</p>
<p>The variance <code class="reqn">\textrm{var}[\hat{\mathbf{V}}_{t}|\mathbf{Y}^{(1)}] </code> (uppercase <code class="reqn"> \mathbf{Y} </code>) returned in the 1 to <code class="reqn">n</code> rows/columns of <code>var.residuals</code> may also be of interest depending on what you are investigating with regards to missing values. For example, it may be of interest in a simulation study or cases where you have multiple replicated <code class="reqn">\mathbf{Y}</code> data sets. <code>var.residuals</code> would allow you to determine if the left-out residuals are unusual with regards to what you would expect for left-out data in that location of the <code class="reqn">\mathbf{Y}</code> matrix but not specifically relative to the data you did collect. If <code class="reqn">\mathbf{R}</code> is non-diagonal and the <code class="reqn">\mathbf{y}^{(1)}</code> and <code class="reqn">\mathbf{y}^{(2)}</code> are highly correlated, the variance of <code class="reqn">\textrm{var}[\hat{\mathbf{V}}_{t}|\mathbf{Y}^{(1)}] </code> and variance of <code class="reqn">\textrm{var}[\hat{\mathbf{V}}_{t}|\mathbf{y}^{(1)}] </code> for the left-out data would be quite different. In the latter, the variance is low because <code class="reqn">\mathbf{y}^{(1)} </code> has strong information about <code class="reqn">\mathbf{y}^{(2)} </code>. In the former, we integrate over <code class="reqn">\mathbf{Y}^{(1)} </code> and the variance could be high (depending on the parameters).
</p>
<p>Note, if <code>Harvey=TRUE</code> then the rows and columns of <code>var.residuals</code> corresponding to missing values will be NA. This is because the Harvey et al. algorithm does not compute the residual variance for missing values.
</p>


<h3>Value</h3>

<p>A list with the following components  
</p>
<table>
<tr><td><code>model.residuals</code></td>
<td>
<p> The the observed smoothed model residuals: data minus the model predictions conditioned on all observed data. This is different than the Kalman filter innovations which use on the data up to time <code class="reqn">t-1</code> for the predictions. See details. </p>
</td></tr>
<tr><td><code>state.residuals</code></td>
<td>
<p> The smoothed state residuals <code class="reqn">\mathbf{x}_{t+1}^T - \mathbf{Z} \mathbf{x}_{t}^T - \mathbf{u}</code>. The last time step will be NA because the last step would be for T to T+1 (past the end of the data).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> The residuals conditioned on the observed data. Returned as a (n+m) x T matrix with <code>model.residuals</code> in rows 1 to n and <code>state.residuals</code> in rows n+1 to n+m.  NAs will appear in rows 1 to n in the places where data are missing. </p>
</td></tr>
<tr><td><code>var.residuals</code></td>
<td>
<p> The joint variance of the model and state residuals conditioned on observed data. Returned as a (n+m) x (n+m) x T matrix. For Harvey=FALSE, this is Holmes (2014) equation 57. For Harvey=TRUE, this is the residual variance in eqn. 24, page 113, in Harvey et al. (1998). They are identical except for missing values, for those Harvey=TRUE returns 0s. For the state residual variance, the last time step will be all NA because the last step would be for T to T+1 (past the end of the data).</p>
</td></tr>
<tr><td><code>std.residuals</code></td>
<td>
<p> The Cholesky standardized residuals as a (n+m) x T matrix. This is <code>residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals</code>. The model standardized residuals associated with the missing data are replaced with NA. </p>
</td></tr>
<tr><td><code>mar.residuals</code></td>
<td>
<p> The marginal standardized residuals as a (n+m) x T matrix. This is <code>residuals</code> multiplied by the inverse of the diagonal matrix formed by the square-root of the diagonal of <code>var.residuals</code>.  The model marginal residuals associated with the missing data are replaced with NA. </p>
</td></tr>
<tr><td><code>bchol.residuals</code></td>
<td>
<p> The Block Cholesky standardized residuals as a (n+m) x T matrix. This is <code>model.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[1:n,1:n,]</code> and <code>state.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[(n+1):(n+m),(n+1):(n+m),]</code>. </p>
</td></tr>
<tr><td><code>E.obs.residuals</code></td>
<td>
<p> The expected value of the model residuals conditioned on the observed data. Returned as a n x T matrix.  For observed data, this will be the observed residuals (values in <code>model.residuals</code>). For unobserved data, this will be 0 if <code class="reqn">\mathbf{R}</code> is diagonal but non-zero if <code class="reqn">\mathbf{R}</code> is non-diagonal. See details. </p>
</td></tr>
<tr><td><code>var.obs.residuals</code></td>
<td>
<p> The variance of the model residuals conditioned on the observed data. Returned as a n x n x T matrix.  For observed data, this will be 0. See details. </p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p> Any warning messages. This will be printed unless Object$control$trace = -1 (suppress all error messages). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>Harvey, A., S. J. Koopman, and J. Penzer. 1998. Messy time series: a unified approach. Advances in Econometrics 13: 103-144  (see page 112-113).  Equation 21 is the Kalman eqns.  Eqn 23 and 24 is the backward recursion to compute the smoothations.  This function uses the MARSSkf output for eqn 21 and then implements the backwards recursion in equation 23 and equation 24.  Pages 120-134 discuss the use of standardized residuals for outlier and structural break detection.
</p>
<p>de Jong, P. and J. Penzer. 1998. Diagnosing shocks in time series. Journal of the American Statistical Association 93: 796-806.  This one shows the same equations; see eqn 6.  This paper mentions the scaling based on the inverse of the sqrt (Cholesky decomposition) of the variance-covariance matrix for the residuals (model and state together).  This is in the right column, half-way down on page 800.
</p>
<p>Koopman, S. J., N. Shephard, and J. A. Doornik. 1999. Statistical algorithms for models in state space using SsfPack 2.2. Econometrics Journal 2: 113-166. (see pages 147-148).
</p>
<p>Harvey, A. and S. J. Koopman. 1992. Diagnostic checking of unobserved-components time series models. Journal of Business &amp; Economic Statistics 4: 377-389.
</p>
<p>Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code>, <code><a href="#topic+MARSSresiduals.tt1">MARSSresiduals.tt1</a>()</code>, <code><a href="#topic+fitted.marssMLE">fitted.marssMLE</a>()</code>, <code><a href="#topic+plot.marssMLE">plot.marssMLE</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- t(harborSeal)
  dat &lt;- dat[c(2,11),]
  fit &lt;- MARSS(dat)
  
  #state residuals
  state.resids1 &lt;- MARSSresiduals(fit, type="tT")$state.residuals
  #this is the same as hatx_t-(hatx_{t-1}+u)
  states &lt;- fit$states
  state.resids2 &lt;- states[,2:30]-states[,1:29]-matrix(coef(fit,type="matrix")$U,2,29)
  #compare the two
  cbind(t(state.resids1[,-30]), t(state.resids2))

  #normalize the state residuals to a variance of 1
  Q &lt;- coef(fit,type="matrix")$Q
  state.resids1 &lt;- MARSSresiduals(fit, type="tT", normalize=TRUE)$state.residuals
  state.resids2 &lt;- (solve(t(chol(Q))) %*% state.resids2)
  cbind(t(state.resids1[,-30]), t(state.resids2))

  #Cholesky standardized (by joint variance) model &amp; state residuals
  MARSSresiduals(fit, type="tT")$std.residuals
  
  # Returns residuals in a data frame in long form
  residuals(fit, type="tT")
</code></pre>

<hr>
<h2 id='MARSSresiduals.tt1'> MARSS One-Step-Ahead Residuals </h2><span id='topic+MARSSresiduals.tt1'></span>

<h3>Description</h3>

<p>Calculates the standardized (or auxiliary) one-step-ahead residuals, aka the innovations residuals and their variance.  Not exported. Access this function with <code>MARSSresiduals(object, type="tt1")</code>. To get the residuals as a data frame in long-form, use <code><a href="#topic+residuals.marssMLE">residuals</a>(object, type="tt1")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSresiduals.tt1(object, method = c("SS"), normalize = FALSE, 
    silent = FALSE, fun.kf = c("MARSSkfas", "MARSSkfss"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSresiduals.tt1_+3A_object">object</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>.</p>
</td></tr>
<tr><td><code id="MARSSresiduals.tt1_+3A_method">method</code></td>
<td>
<p> Algorithm to use. Currently only &quot;SS&quot;. </p>
</td></tr>
<tr><td><code id="MARSSresiduals.tt1_+3A_normalize">normalize</code></td>
<td>
<p> TRUE/FALSE See details. </p>
</td></tr>
<tr><td><code id="MARSSresiduals.tt1_+3A_silent">silent</code></td>
<td>
<p> If TRUE, don't print inversion warnings. </p>
</td></tr>
<tr><td><code id="MARSSresiduals.tt1_+3A_fun.kf">fun.kf</code></td>
<td>
<p> Can be ignored. This will change the Kalman filter/smoother function from the value in object$fun.kf if desired. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the conditional expected value (mean) and variance of the one-step-ahead residuals.  'conditional' means in this context, conditioned on the observed data up to time <code class="reqn">t-1</code> and a set of parameters.  
</p>
<p><strong>Model residuals</strong>
</p>
<p><code class="reqn">\mathbf{v}_t</code> is the difference between the data and the predicted data at time <code class="reqn">t</code> given <code class="reqn">\mathbf{x}_t</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{v}_t = \mathbf{y}_t - \mathbf{Z} \mathbf{x}_t - \mathbf{a} - \mathbf{D}\mathbf{d}_t</code>
</p>

<p>The observed model residuals <code class="reqn">\hat{\mathbf{v}}_t</code> are the difference between the observed data and the predicted data at time <code class="reqn">t</code> using the fitted model. <code>MARSSresiduals.tt1</code> fits the model using the data up to time <code class="reqn">t-1</code>. So
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{v}}_t = \mathbf{y}_t - \mathbf{Z}\mathbf{x}_t^{t-1} - \mathbf{a}  - \mathbf{D}\mathbf{d}_t</code>
</p>

<p>where <code class="reqn">\mathbf{x}_t^{t-1}</code> is the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on the data from $t=1$ to <code class="reqn">t-1</code> from the Kalman filter. <code class="reqn">\mathbf{y}_t</code> are your data and missing values will appear as NA. 
</p>
<p><strong>State residuals</strong>
</p>
<p><code class="reqn">\mathbf{w}_{t+1}</code> are the difference between the state at time <code class="reqn">t+1</code> and the expected value of the state at time <code class="reqn">t+1</code> given the state at time <code class="reqn">t</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{w}_{t+1} = \mathbf{x}_{t+1} - \mathbf{B} \mathbf{x}_{t} - \mathbf{u}  - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>

<p>The estimated state residuals <code class="reqn">\hat{\mathbf{w}}_{t+1}</code> are the difference between estimate of <code class="reqn">\mathbf{x}_{t+1}</code> minus the estimate using <code class="reqn">\mathbf{x}_{t}</code>. 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{w}}_{t+1} = \mathbf{x}_{t+1}^{t+1} - \mathbf{B}\mathbf{x}_{t}^t - \mathbf{u} - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>

<p>where <code class="reqn">\mathbf{x}_{t+1}^{t+1}</code> is the Kalman filter estimate of the states at time <code class="reqn">t+1</code> conditioned on the data up to time <code class="reqn">t+1</code> and <code class="reqn">\mathbf{x}_{t}^t</code> is the Kalman filter estimate of the states at time <code class="reqn">t</code> conditioned on the data up to time <code class="reqn">t</code>.
The estimated state residuals <code class="reqn">\mathbf{w}_{t+1}</code> are returned in <code>state.residuals</code> and rows <code class="reqn">n+1</code> to <code class="reqn">n+m</code> of <code>residuals</code>. <code>state.residuals[,t]</code> is <code class="reqn">\mathbf{w}_{t+1}</code> (notice time subscript difference). There are no NAs in the estimated state residuals (except for the last time step) as an estimate of the state exists whether or not there are associated data.
</p>
<p><code>res1</code> and <code>res2</code> in the code below will be the same.
</p>
<pre>dat &lt;- t(harborSeal)[2:3,]
TT &lt;- ncol(dat)
fit &lt;- MARSS(dat)
B &lt;- coef(fit, type="matrix")$B
U &lt;- coef(fit, type="matrix")$U
xt &lt;- MARSSkfss(fit)$xtt[,1:(TT-1)] # t 1 to TT-1
xtp1 &lt;- MARSSkfss(fit)$xtt[,2:TT] # t 2 to TT
res1 &lt;- xtp1 - B %*% xt - U %*% matrix(1,1,TT-1)
res2 &lt;- MARSSresiduals(fit, type="tt1")$state.residuals
</pre>
<p><strong>Joint residual variance</strong>
</p>
<p>In a state-space model, <code class="reqn">\mathbf{X}</code> and <code class="reqn">\mathbf{Y}</code> are stochastic, and the model and state residuals are random variables <code class="reqn">\hat{\mathbf{V}}_t</code> and <code class="reqn">\hat{\mathbf{W}}_{t+1}</code>. The joint distribution of <code class="reqn">\hat{\mathbf{V}}_{t}, \hat{\mathbf{W}}_{t+1}</code> is the distribution across all the different possible data sets that our MARSS equations with parameters <code class="reqn">\Theta</code> might generate. Denote the matrix of <code class="reqn">\hat{\mathbf{V}}_{t}, \hat{\mathbf{W}}_{t+1}</code>, as <code class="reqn">\widehat{\mathcal{E}}_{t}</code>. That distribution has an expected value (mean) and variance:
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{E}[\widehat{\mathcal{E}}_t] = 0; \textrm{var}[\widehat{\mathcal{E}}_t] = \hat{\Sigma}_t </code>
</p>

<p>Our observed residuals <code>residuals</code> are one sample from this distribution.
To standardize the observed residuals, we will use <code class="reqn"> \hat{\Sigma}_t </code>. <code class="reqn"> \hat{\Sigma}_t </code> is returned in <code>var.residuals</code>. Rows/columns 1 to <code class="reqn">n</code> are the conditional variances of the model residuals and rows/columns <code class="reqn">n+1</code> to <code class="reqn">n+m</code> are the conditional variances of the state residuals. The off-diagonal blocks are the covariances between the two types of residuals. For one-step-ahead residuals (unlike smoothation residuals <a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>), the covariance is zero.
</p>
<p><code>var.residuals</code> returned by this function is the conditional variance of the residuals conditioned on the data up to <code class="reqn">t-1</code> and the parameter set <code class="reqn">\Theta</code>.  The conditional variance for the model residuals is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t = \mathbf{R}+\mathbf{Z}_t \mathbf{V}_t^{t-1} \mathbf{Z}_t^\top </code>
</p>

<p>where <code class="reqn">\mathbf{V}_t^{t-1}</code> is the variance of <code class="reqn">\mathbf{X}_t</code> conditioned on the data up to time <code class="reqn">t-1</code>. This is returned by <code><a href="#topic+MARSSkf">MARSSkf</a></code> in <code>Vtt1</code>. The innovations variance is also returned in <code>Sigma</code> from <code><a href="#topic+MARSSkf">MARSSkf</a></code> and are used in the innovations form of the likelihood calculation.
</p>
<p><strong>Standardized residuals</strong>
</p>
<p><code>std.residuals</code> are Cholesky standardized residuals. These are the residuals multiplied by the inverse of the lower triangle of the Cholesky decomposition of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t^{-1/2} \hat{\mathbf{v}}_t</code>
</p>

<p>These residuals are uncorrelated unlike marginal residuals. 
</p>
<p>The interpretation of the Cholesky standardized residuals is not straight-forward when the <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code> variance-covariance matrices are non-diagonal.  The residuals which were generated by a non-diagonal variance-covariance matrices are transformed into orthogonal residuals in <code class="reqn">\textrm{MVN}(0,\mathbf{I})</code> space.  For example, if v is 2x2 correlated errors with variance-covariance matrix R. The transformed residuals (from this function) for the i-th row of v is a combination of the row 1 effect and the row 1 effect plus the row 2 effect.  So in this case, row 2 of the transformed residuals would not be regarded as solely the row 2 residual but rather how different row 2 is from row 1, relative to expected.  If the errors are highly correlated, then the Cholesky standardized residuals can look rather non-intuitive.
</p>
<p><code>mar.residuals</code> are the marginal standardized residuals. These are the residuals multiplied by the inverse of the diagonal matrix formed from the square-root of the diagonal of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{dg}(\hat{\Sigma}_t)^{-1/2} \hat{\mathbf{v}}_t</code>
</p>
<p>, where 'dg(A)' is the square matrix formed from the diagonal of A, aka <code>diag(diag(A))</code>. These residuals will be correlated if the variance matrix is non-diagonal. 
</p>
<p>The Block Cholesky standardized residuals are like the Cholesky standardized residuals except that the full variance-covariance matrix is not used, only the variance-covariance matrix for the model or state residuals (respectively) is used for standardization. For the one-step-ahead case, the model and state residuals are independent (unlike in the smoothations case) thus the Cholesky and Block Cholesky standardized residuals will be identical (unlike in the smoothations case). 
</p>
<p><strong>Normalized residuals</strong>
</p>
<p>If <code>normalize=FALSE</code>, the unconditional variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> are <code class="reqn">\mathbf{R}</code> and <code class="reqn">\mathbf{Q}</code> and the model is assumed to be written as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{w}_t</code>
</p>

<p>If normalize=TRUE, the model is assumed to be written
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{H}\mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{G}\mathbf{w}_t</code>
</p>

<p>with the variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> equal to <code class="reqn">\mathbf{I}</code> (identity).
</p>
<p><code>MARSSresiduals</code> returns the residuals defined as in the first equations. To get the residuals defined as Harvey et al. (1998) define them (second equations), then use <code>normalize=TRUE</code>.  In that case the unconditional variance of residuals will be <code class="reqn">\mathbf{I}</code> instead of <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code>.  Note, that the normalized residuals are not the same as the standardized residuals.  In former, the unconditional residuals have a variance of <code class="reqn">\mathbf{I}</code> while in the latter it is the conditional residuals that have a variance of <code class="reqn">\mathbf{I}</code>.
</p>


<h3>Value</h3>

<p>A list with the following components  
</p>
<table>
<tr><td><code>model.residuals</code></td>
<td>
<p> The the observed one-step-ahead model residuals: data minus the model predictions conditioned on the data <code class="reqn">t=1</code> to <code class="reqn">t-1</code>. These are termed innovations. A n x T matrix. NAs will appear where the data are missing. </p>
</td></tr>
<tr><td><code>state.residuals</code></td>
<td>
<p> The one-step-ahead state residuals <code class="reqn"> \mathbf{x}_{t+1}^{t+1} - \mathbf{B}\mathbf{x}_{t}^t - \mathbf{u} </code>
. Note, state residual at time <code class="reqn">t</code> is the transition from time <code class="reqn">t=t</code> to <code class="reqn">t+1</code>. </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> The residuals conditioned on the observed data up to time <code class="reqn">t-1</code>. Returned as a (n+m) x T matrix with <code>model.residuals</code> in rows 1 to n and <code>state.residuals</code> in rows n+1 to n+m.  NAs will appear in rows 1 to n in the places where data are missing. </p>
</td></tr>
<tr><td><code>var.residuals</code></td>
<td>
<p> The joint variance of the one-step-ahead residuals. Returned as a n+m x n+m x T matrix. </p>
</td></tr>
<tr><td><code>std.residuals</code></td>
<td>
<p> The Cholesky standardized residuals as a n+m x T matrix. This is <code>residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals</code>. The model standardized residuals associated with the missing data are replaced with NA. </p>
</td></tr>
<tr><td><code>mar.residuals</code></td>
<td>
<p> The marginal standardized residuals as a n+m x T matrix. This is <code>residuals</code> multiplied by the inverse of the diagonal matrix formed by the square-root of the diagonal of <code>var.residuals</code>.  The model marginal residuals associated with the missing data are replaced with NA. </p>
</td></tr>
<tr><td><code>bchol.residuals</code></td>
<td>
<p> The Block Cholesky standardized residuals as a (n+m) x T matrix. This is <code>model.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[1:n,1:n,]</code> and <code>state.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[(n+1):(n+m),(n+1):(n+m),]</code>.</p>
</td></tr>
<tr><td><code>E.obs.residuals</code></td>
<td>
<p> The expected value of the model residuals conditioned on the observed data <code class="reqn">t=1</code> to <code class="reqn">t-1</code>. Returned as a n x T matrix. Because all the data at time <code class="reqn">t</code> are unobserved for the purpose of estimation (since conditioning is from <code class="reqn">t=1</code> to <code class="reqn">t-1</code>), this will be all 0s (unlike the case where we condition on the data from <code class="reqn">t=1</code> to <code class="reqn">T</code> or to <code class="reqn">t</code>). This and <code>var.obs.residuals</code> are included for completeness since they are returned for <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>, but they are not relevant for one-step-ahead residuals. See the discussion there. </p>
</td></tr>
<tr><td><code>var.obs.residuals</code></td>
<td>
<p> For one-step-ahead residuals, this will be the same as the 1:n, 1:n upper diagonal block in <code>var.residuals</code> since none of the <code class="reqn">t</code> data affect the residuals at time <code class="reqn">t</code> (the model residuals are conditioned only on the data up to <code class="reqn">t-1</code>). This is different for smoothation residuals which are conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">T</code>. This and <code>E.obs.residuals</code> are included for completeness since they are returned for <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>, but they are not relevant for one-step-ahead residuals. See the discussion there. Note, also included as a code check. They are computed differently, but <code>var.obs.residuals</code> and <code>var.residuals</code> should always be the same.</p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p> Any warning messages. This will be printed unless <code>object$control$trace = -1</code> (suppress all error messages). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>R. H. Shumway and D. S. Stoffer (2006).  Section on the calculation of the likelihood of state-space models in Time series analysis and its applications.  Springer-Verlag, New York.
</p>
<p>Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a>()</code>, <code><a href="#topic+MARSSresiduals.tt">MARSSresiduals.tt</a>()</code>,  <code><a href="#topic+fitted.marssMLE">fitted.marssMLE</a>()</code>, <code><a href="#topic+plot.marssMLE">plot.marssMLE</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- t(harborSeal)
  dat &lt;- dat[c(2,11),]
  fit &lt;- MARSS(dat)
  
  MARSSresiduals(fit, type="tt1")$std.residuals
  residuals(fit, type="tt1")
</code></pre>

<hr>
<h2 id='MARSSsimulate'> Simulate Data from a MARSS Model </h2><span id='topic+MARSSsimulate'></span><span id='topic+simulate.marssMLE'></span>

<h3>Description</h3>

<p>Generates simulated data from a MARSS model with specified parameter estimates. This is a base function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSsimulate(object, tSteps = NULL, nsim = 1, silent = TRUE, 
    miss.loc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSsimulate_+3A_object">object</code></td>
<td>
<p> A fitted <code><a href="#topic+marssMLE">marssMLE</a></code> object, as output by <code><a href="#topic+MARSS">MARSS</a>()</code>. </p>
</td></tr>
<tr><td><code id="MARSSsimulate_+3A_tsteps">tSteps</code></td>
<td>
<p> Number of time steps in each simulation. If left off, it is taken to be consistent with <code>MLEobj</code>.</p>
</td></tr>
<tr><td><code id="MARSSsimulate_+3A_nsim">nsim</code></td>
<td>
<p> Number of simulated data sets to generate. </p>
</td></tr>
<tr><td><code id="MARSSsimulate_+3A_silent">silent</code></td>
<td>
<p> Suppresses progress bar. </p>
</td></tr>
<tr><td><code id="MARSSsimulate_+3A_miss.loc">miss.loc</code></td>
<td>
<p> Optional matrix specifying where to put missing values. See Details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optional argument <code>miss.loc</code> is an array of dimensions n x tSteps x nsim, specifying where to put missing values
in the simulated data. If missing, this would be constructed using <code>MLEobj$marss$data</code>.  If the locations of the missing values are the same for all simulations, <code>miss.loc</code> can be a matrix of <code>dim=c(n, tSteps)</code> (the original data for example).  The default, if <code>miss.loc</code> is left off, is that there are no missing values even if <code>MLEobj$marss$data</code> has missing values. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>sim.states</code></td>
<td>
<p> Array (dim m x tSteps x nsim) of state processes simulated from parameter estimates. m is the number of states (rows in X).</p>
</td></tr>
<tr><td><code>sim.data</code></td>
<td>
<p> Array (dim n x tSteps x nsim) of data simulated from parameter estimates. n is the number of rows of data (Y).</p>
</td></tr>
<tr><td><code>MLEobj</code></td>
<td>
<p> The <code><a href="#topic+marssMLE">marssMLE</a></code> object from which the data were simulated. </p>
</td></tr>
<tr><td><code>miss.loc</code></td>
<td>
<p> Matrix identifying where missing values were placed. It should be exactly the same dimensions as the data matrix. The location of NAs in the miss.loc matrix indicate where the missing values are. </p>
</td></tr>
<tr><td><code>tSteps</code></td>
<td>
<p> Number of time steps in each simulation. </p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p> Number of simulated data sets generated. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes and Eric Ward, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+marssMODEL">marssMODEL</a></code>, <code><a href="#topic+marssMLE">marssMLE</a></code>, <code><a href="#topic+MARSSboot">MARSSboot</a>()</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- harborSeal[, c(2, 11)]
dat &lt;- t(d)
fit &lt;- MARSS(dat)

# simulate data that are the
# same length as original data and no missing data
sim.obj &lt;- MARSSsimulate(fit, tSteps = dim(d)[1], nsim = 5)

# simulate data that are the
# same length as original data and have missing data in the same location
sim.obj &lt;- MARSSsimulate(fit, tSteps = dim(d)[1], nsim = 5, miss.loc = dat)
</code></pre>

<hr>
<h2 id='MARSSvectorizeparam'> Vectorize or Replace the par List </h2><span id='topic+MARSSvectorizeparam'></span>

<h3>Description</h3>

<p>Converts <code>MLEobj[["what"]]</code> to a vector or assigns a vector to <code>MLEobj[["what"]]</code>.  This is a utility function in the <code><a href="#topic+MARSS-package">MARSS-package</a></code> for <code><a href="#topic+marssMODEL">marssMODEL</a></code> objects of form=&quot;marss&quot; and is not exported.  Users achieve this functionality with <code><a href="#topic+coef.marssMLE">coef</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSSvectorizeparam(MLEobj, parvec = NA, what = "par")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSSvectorizeparam_+3A_mleobj">MLEobj</code></td>
<td>
<p> An object of class <code><a href="#topic+marssMLE">marssMLE</a></code>. </p>
</td></tr>
<tr><td><code id="MARSSvectorizeparam_+3A_parvec">parvec</code></td>
<td>
<p> NA or a vector. See Value. </p>
</td></tr>
<tr><td><code id="MARSSvectorizeparam_+3A_what">what</code></td>
<td>
<p> What part of the MLEobj is being replaced or vectorized.  Need to be a par list. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utility function to generate parameter vectors for optimization functions, and to set <code>MLEobj[[what]]</code> using a vector of values.  The function bases the unlisting and naming order on <code>names(MLEobj$marss$fixed)</code>.  Appends matrix name to the row names in the par list.
</p>


<h3>Value</h3>

<p>If parvec=NA, a vector of the elements of the <code>what</code> element. Otherwise, a <code><a href="#topic+marssMLE">marssMLE</a></code> object with <code>MLEobj[["what"]]</code> set by parvec.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes and Kellie Wills, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+marssMLE">marssMLE</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4, ]
kem &lt;- MARSS(dat)
paramvec &lt;- MARSS:::MARSSvectorizeparam(kem)
paramvec
</code></pre>

<hr>
<h2 id='match.arg.exact'> match.arg with exact matching </h2><span id='topic+match.arg.exact'></span>

<h3>Description</h3>

<p>The base R <code><a href="base.html#topic+match.arg">match.arg</a>()</code> uses <code><a href="base.html#topic+pmatch">pmatch</a>()</code> and does partial matching. This is a problem for many functions where <code>"xtt1"</code> is different than <code>"xtt"</code>, say. This function implements exact matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.arg.exact(arg, choices, several.ok = FALSE, exact = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.arg.exact_+3A_arg">arg</code></td>
<td>
<p> a character vector (of length one unless <code>several.ok</code> is <code>TRUE</code>). </p>
</td></tr>
<tr><td><code id="match.arg.exact_+3A_choices">choices</code></td>
<td>
<p> a character vector of candidate values </p>
</td></tr>
<tr><td><code id="match.arg.exact_+3A_several.ok">several.ok</code></td>
<td>
<p> logical specifying if <code>arg</code> should be allowed to have more than one element </p>
</td></tr>
<tr><td><code id="match.arg.exact_+3A_exact">exact</code></td>
<td>
<p> require exact matching </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># this fails
# MARSS:::match.arg.exact(c("a"), c("aa", "bb"))
# this does not
match.arg(c("a"), c("aa", "bb"))
</code></pre>

<hr>
<h2 id='model.frame.marssMODEL'> model.frame method for marssMLE and marssMODEL objects </h2><span id='topic+model.frame'></span><span id='topic+model.frame.marssMODEL'></span><span id='topic+model.frame.marssMLE'></span>

<h3>Description</h3>

<p><code>model.frame(M]LEobj)</code> or <code>model.frame(MODELobj)</code>, where MLEobj is a <code><a href="#topic+marssMLE">marssMLE</a></code> object output by a <code><a href="#topic+MARSS">MARSS</a>()</code> call and MODELobj is a <code><a href="#topic+marssMODEL">marssMODEL</a></code> object in the model element of a <code><a href="#topic+marssMLE">marssMLE</a></code> object, 
will return a data frame with the data (y) and inputs/covariates (c and d elements) for a MARSS model in &quot;marxss&quot; form. See <code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code>.  This is mainly a utility function to help with the functions <code><a href="#topic+tidy.marssMLE">tidy</a>()</code>, and <code><a href="#topic+glance.marssMLE">glance</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMODEL'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.marssMODEL_+3A_formula">formula</code></td>
<td>
<p> A <code><a href="#topic+marssMODEL">marssMODEL</a></code> object.  </p>
</td></tr>
<tr><td><code id="model.frame.marssMODEL_+3A_...">...</code></td>
<td>
<p> Other arguments not used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the data and inputs (c and d) in a MARSS model in &quot;marxss&quot; form.  See <code><a href="#topic+MARSS.marxss">MARSS.marxss</a></code>.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>

<hr>
<h2 id='plankton'> Plankton Data Sets </h2><span id='topic+plankton'></span><span id='topic+ivesDataLP'></span><span id='topic+ivesDataByWeek'></span><span id='topic+lakeWAplankton'></span><span id='topic+lakeWAplanktonRaw'></span><span id='topic+lakeWAplanktonTrans'></span>

<h3>Description</h3>

<p>Example plankton data sets for use in MARSS vignettes for the <code><a href="#topic+MARSS-package">MARSS-package</a></code>. 
</p>
<p>The <code>lakeWAplankton</code> data set consists for two data sets: <code>lakeWAplanktonRaw</code> and a dataset derived from the raw dataset, <code>lakeWAplanktonTrans</code>. <code>lakeWAplanktonRaw</code> is a 32-year time series (1962-1994) of monthly plankton counts from Lake Washington, Washington, USA. Columns 1 and 2 are year and month.  Column 3 is temperature (C), column 4 is total phosphorous, and column 5 is pH.  The next columns are the plankton counts in units of cells per mL for the phytoplankton and organisms per L for the zooplankton.   Since MARSS functions require time to be across columns, these data matrices must be transposed before passing into MARSS functions.
</p>
<p><code>lakeWAplanktonTrans</code> is a transformed version of <code>lakeWAplanktonRaw</code>.  Zeros have been replaced with NAs (missing).  The logged (natural log) raw plankton counts have been standardized to a mean of zero and variance of 1 (so logged and then z-scored). Temperature, TP &amp; pH were also z-scored but not logged (so z-score of the untransformed values for these covariates). The single missing temperature value was replaced with -1 and the single missing TP value was replaced with -0.3.
</p>
<p>The Ives data are from Ives et al. (2003) for West Long Lake (the low planktivory case).  The Ives data are unlogged.  <code>ivesDataLP</code> and <code>ivesDataByWeek</code> are the same data with LP having the missing weeks in winter removed while in ByWeek, the missing values are left in.  The phosporous column is the experimental input rate + the natural input rate for phosphorous, and Ives et al. used 0.1 for the natural input rate when no extra phosporous was added.  The phosporous input rates for weeks with no sampling (and no experimental phosphorous input) have been filled with 0.1 in the &quot;by week&quot; data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ivesDataLP)
data(ivesDataByWeek)
data(lakeWAplankton)
</code></pre>


<h3>Format</h3>

<p>The data are provided as a matrix with time running down the rows.
</p>


<h3>Source</h3>


<dl>
<dt><code>ivesDataLP</code> and <code>ivesDataByWeek</code></dt><dd><p> Ives, A. R. Dennis, B. Cottingham, K. L. Carpenter, S. R. (2003) Estimating community stability and ecological interactions from time-series data. Ecological Monographs, 73, 301-330. </p>
</dd>
<dt><code>lakeWAplanktonTrans</code></dt><dd><p> Hampton, S. E. Scheuerell, M. D. Schindler, D. E. (2006)  Coalescence in the Lake Washington story: Interaction strengths in a planktonic food web. Limnology and Oceanography, 51, 2042-2051. </p>
</dd>
<dt><code>lakeWAplanktonRaw</code></dt><dd><p> Adapted from the Lake Washington database of Dr. W. T. Edmondson, as funded by the Andrew Mellon Foundation; data courtesy of Dr. Daniel Schindler, University of Washington, Seattle, WA.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>str(ivesDataLP)
str(ivesDataByWeek)
</code></pre>

<hr>
<h2 id='plot.marssMLE'> Plot MARSS MLE objects </h2><span id='topic+plot.marssMLE'></span><span id='topic+autoplot.marssMLE'></span>

<h3>Description</h3>

<p>Plots fitted observations and estimated states with confidence intervals using base R graphics (<code>plot</code>) and ggplot2 (<code>autoplot</code>).  Diagnostic plots also shown.  By default a subset of standard diagnostic plots are plotted.  Individual plots can be plotted by passing in <code>plot.type</code>.  If an individual plot is made using <code>autoplot()</code>, the ggplot object is returned which can be further manipulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
plot(x, plot.type = c(
    "fitted.ytT", "fitted.ytt", "fitted.ytt1", 
    "ytT", "ytt", "ytt1",
    "fitted.xtT", "fitted.xtt1", 
    "xtT", "xtt", "xtt1",
    "model.resids.ytt1", "qqplot.model.resids.ytt1", "acf.model.resids.ytt1",
    "std.model.resids.ytt1", "qqplot.std.model.resids.ytt1", "acf.std.model.resids.ytt1",
    "model.resids.ytT", "qqplot.model.resids.ytT", "acf.model.resids.ytT",
    "std.model.resids.ytT", "qqplot.std.model.resids.ytT", "acf.std.model.resids.ytT",
    "model.resids.ytt", "qqplot.model.resids.ytt", "acf.model.resids.ytt",
    "std.model.resids.ytt", "qqplot.std.model.resids.ytt", "acf.std.model.resids.ytt",
    "state.resids.xtT", "qqplot.state.resids.xtT", "acf.state.resids.xtT",
    "std.state.resids.xtT", "qqplot.std.state.resids.xtT", "acf.std.state.resids.xtT",
    "residuals", "all"),
    form=c("marxss", "marss", "dfa"),
    standardization = c("Cholesky", "marginal", "Block.Cholesky"),
    conf.int=TRUE, conf.level=0.95, decorate=TRUE, pi.int = FALSE,
    plot.par = list(), ..., silent = FALSE)
## S3 method for class 'marssMLE'
autoplot(x, plot.type = c(
    "fitted.ytT", "fitted.ytt", "fitted.ytt1", 
    "ytT", "ytt", "ytt1",
    "fitted.xtT", "fitted.xtt1", 
    "xtT", "xtt", "xtt1",
    "model.resids.ytt1", "qqplot.model.resids.ytt1", "acf.model.resids.ytt1",
    "std.model.resids.ytt1", "qqplot.std.model.resids.ytt1", "acf.std.model.resids.ytt1",
    "model.resids.ytT", "qqplot.model.resids.ytT", "acf.model.resids.ytT",
    "std.model.resids.ytT", "qqplot.std.model.resids.ytT", "acf.std.model.resids.ytT",
    "model.resids.ytt", "qqplot.model.resids.ytt", "acf.model.resids.ytt",
    "std.model.resids.ytt", "qqplot.std.model.resids.ytt", "acf.std.model.resids.ytt",
    "state.resids.xtT", "qqplot.state.resids.xtT", "acf.state.resids.xtT",
    "std.state.resids.xtT", "qqplot.std.state.resids.xtT", "acf.std.state.resids.xtT",
    "residuals", "all"),
    form=c("marxss", "marss", "dfa"),
    standardization = c("Cholesky", "marginal", "Block.Cholesky"),
    conf.int=TRUE, conf.level=0.95, decorate=TRUE, pi.int = FALSE,
    fig.notes = TRUE, plot.par = list(), ..., silent = FALSE)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.marssMLE_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object.  </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_plot.type">plot.type</code></td>
<td>
<p> Type of plot.  If not passed in, a subset of the standard plots are drawn. See details for plot types.  </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_standardization">standardization</code></td>
<td>
<p> The type of standardization to be used plots, if the user wants to specify a specific standardization. Otherwise Cholesky standardization is used. </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_form">form</code></td>
<td>
<p> Optional. Form of the model.  This is normally taken from the form attribute of the MLE object (x), but the user can specify a different form. </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_conf.int">conf.int</code></td>
<td>
<p> TRUE/FALSE. Whether to include a confidence interval. </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_pi.int">pi.int</code></td>
<td>
<p> TRUE/FALSE. Whether to include a prediction interval on the observations plot </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level for CIs. </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_decorate">decorate</code></td>
<td>
<p> TRUE/FALSE. Add smoothing lines to residuals plots or qqline to qqplots and add data points plus residuals confidence intervals to states and observations plots. </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_plot.par">plot.par</code></td>
<td>
<p> A list of plot parameters to adjust the look of the plots.  See details. </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_fig.notes">fig.notes</code></td>
<td>
<p> Add notes to the bottom of the plots (only for <code>autoplot()</code>. </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_silent">silent</code></td>
<td>
<p> No console interaction or output. </p>
</td></tr>
<tr><td><code id="plot.marssMLE_+3A_...">...</code></td>
<td>
<p> Other arguments, not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot types are as follows:
</p>

<dl>
<dt><code>"fitted.y"</code></dt><dd><p> This plots the fitted <code class="reqn">\mathbf{y}</code>, which is the expected value of <code class="reqn">\mathbf{Y}</code> conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t-1</code>, <code class="reqn">t</code> or <code class="reqn">T</code>. It is <code class="reqn">\mathbf{Z}\mathbf{x}_t^T + \mathbf{a}</code>. The data are plotted for reference but note that the lines and intervals are for new data not the observed data.</p>
</dd>
<dt><code>"fitted.x"</code></dt><dd><p> This plots the fitted x, which is the expected value of <code class="reqn">\mathbf{X}</code> conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t-1</code> or <code class="reqn">T</code>. It is <code class="reqn">B \textrm{E}[\mathbf{X}_{t-1}|\mathbf{y}] + u</code>. The <code class="reqn">\textrm{E}[\mathbf{X}_t|\mathbf{y}]</code> are plotted for reference but note that the lines and intervals are for new <code class="reqn">\mathbf{x}</code>. This is not the estimated states; these are used for residuals calculations. If you want the state estimates use <code>xtT</code> (or <code>xtt</code>).</p>
</dd>
<dt><code>"xtT"</code></dt><dd><p>  The estimated states from the Kalman smoother (conditioned on all the data). </p>
</dd>
<dt><code>"xtt1"</code></dt><dd><p>  The estimated states conditioned on the data up to <code class="reqn">t-1</code>. Kalman filter output. </p>
</dd>
<dt><code>"model.resids.ytT"</code>, <code>"model.resids.ytt1"</code>, <code>"model.resids.ytt"</code></dt><dd><p>Model residuals (data minus fitted y). <code>ytT</code> indicates smoothation residuals, <code>ytt1</code> indicates innovation residuals (the standard state-space residuals), and <code>ytt</code> are the residuals conditioned on data up to <code class="reqn">t</code>. </p>
</dd>
<dt><code>"state.resids.xtT"</code></dt><dd><p> State smoothation residuals (E(x(t) | xtT(t-1)) minus xtT(t)). The intervals are the CIs for the smoothation residuals not one-step-ahead residuals. </p>
</dd>
<dt><code>"std"</code></dt><dd> <p><code>std</code> in front of any of the above plot names indicates that the plots are for the standardized residuals. </p>
</dd>
<dt><code>"qqplot"</code></dt><dd><p> Visual normality test for the residuals, model or state. </p>
</dd> 
<dt><code>"acf"</code></dt><dd><p> ACF of the residuals. The only residuals that should be temporally independent are the innovation residuals: <code>acf.model.residuals.ytt1</code> and <code>acf.std.model.residuals.ytt1</code>. This ACF is a standard residuals diagnostic for state-space models. The other ACF plots will show temporal dependence and are not used for diagnostics. </p>
</dd>
<dt><code>"ytT"</code></dt><dd><p> The expected value of <code class="reqn">\mathbf{Y}</code> conditioned on all the data. Use this for estimates of the missing data points. Note for non-missing <code class="reqn">\mathbf{y}</code> values, the expected value of <code class="reqn">\mathbf{Y}</code> is <code class="reqn">\mathbf{y}</code>. </p>
</dd> 
<dt><code>"ytt"</code>, <code>ytt1</code></dt><dd><p> The expected value of <code class="reqn">\mathbf{Y}</code> conditioned on the data from 1 to <code class="reqn">t</code> or <code class="reqn">t-1</code>. </p>
</dd> 
</dl>

<p>The plot parameters can be passed in as a list to change the look of the plots. For <code>plot.marssMLE()</code>, the default is <code>plot.par = list(point.pch = 19, point.col = "blue", point.fill = "blue", point.size = 1, line.col = "black", line.size = 1, line.linetype = "solid", ci.col = "grey70", ci.border = NA, ci.lwd = 1, ci.lty = 1)</code>. For <code>autoplot.marssMLE</code>, the default is <code>plot.par = list(point.pch = 19, point.col = "blue", point.fill = "blue", point.size = 1, line.col = "black", line.size = 1, line.linetype = "solid", ci.fill = "grey70", ci.col = "grey70", ci.linetype = "solid", ci.linesize = 0, ci.alpha = 0.6)</code>.
</p>


<h3>Value</h3>

<p><code>autoplot()</code> will invisibly return the list of ggplot2 plot objects. Use <code>plts &lt;- autoplot()</code> to obtain that list.
</p>


<h3>Author(s)</h3>

 
<p>Eric Ward and Eli Holmes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(harborSealWA)
model.list &lt;- list( Z = as.factor(c(1, 1, 1, 1, 2)), R = "diagonal and equal")
fit &lt;- MARSS(t(harborSealWA[, -1]), model = model.list)
plot(fit, plot.type = "fitted.ytT")

require(ggplot2)
autoplot(fit, plot.type = "fitted.ytT")

## Not run: 
# DFA example
dfa &lt;- MARSS(t(harborSealWA[, -1]), model = list(m = 2), form = "dfa")
plot(dfa, plot.type = "xtT")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.marssPredict'> Plot MARSS Forecast and Predict objects </h2><span id='topic+plot.marssPredict'></span><span id='topic+autoplot.marssPredict'></span>

<h3>Description</h3>

<p>Plots forecasts with prediction (default) or confidence intervals using base R graphics (<code>plot</code>) and ggplot2 (<code>autoplot</code>).  The plot function is built to mimic <code>plot.forecast</code> in the forecast package in terms of arguments and look.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssPredict'
plot(x, include, decorate = TRUE, main = NULL, showgap = TRUE, 
    shaded = TRUE, shadebars = (x$h &lt; 5 &amp; x$h != 0), shadecols = NULL, col = 1, 
    fcol = 4, pi.col = 1, pi.lty = 2, ylim = NULL, 
    xlab = "", ylab = "", type = "l", flty = 1, flwd = 2, ...)
## S3 method for class 'marssPredict'
autoplot(x, include, decorate = TRUE, plot.par = list(),  ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.marssPredict_+3A_x">x</code></td>
<td>
<p> marssPredict produced by <code><a href="#topic+forecast.marssMLE">forecast.marssMLE</a>()</code> or <code><a href="#topic+predict.marssMLE">predict.marssMLE</a>()</code>. </p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_include">include</code></td>
<td>
<p> number of time step from the training data to include before the forecast. Default is all values.</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_main">main</code></td>
<td>
<p> Text to add to plot titles. </p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_showgap">showgap</code></td>
<td>
<p> If showgap=FALSE, the gap between the training data and the forecasts is removed.</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_shaded">shaded</code></td>
<td>
<p> Whether prediction intervals should be shaded (TRUE) or lines (FALSE).</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_shadebars">shadebars</code></td>
<td>
<p> Whether prediction intervals should be plotted as shaded bars (if TRUE) or a shaded polygon (if FALSE). Ignored if shaded=FALSE. Bars are plotted by default if there are fewer than five forecast horizons.</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_shadecols">shadecols</code></td>
<td>
<p> Colors for shaded prediction intervals. </p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_col">col</code></td>
<td>
<p> Color for the data line.</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_fcol">fcol</code></td>
<td>
<p> Color for the forecast line.</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_pi.col">pi.col</code></td>
<td>
<p> If shaded=FALSE and PI=TRUE, the prediction intervals are plotted in this color.</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_pi.lty">pi.lty</code></td>
<td>
<p> If shaded=FALSE and PI=TRUE, the prediction intervals are plotted using this line type.</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_ylim">ylim</code></td>
<td>
<p> Limits on y-axis.</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_xlab">xlab</code></td>
<td>
<p> X-axis label. </p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_ylab">ylab</code></td>
<td>
<p> Y-axis label. </p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_type">type</code></td>
<td>
<p> Type of plot desired. As for plot.default.</p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_flty">flty</code></td>
<td>
<p> Line type for the forecast line. </p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_flwd">flwd</code></td>
<td>
<p> Line width for the forecast line. </p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_...">...</code></td>
<td>
<p> Other arguments, not used. </p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_decorate">decorate</code></td>
<td>
<p> TRUE/FALSE. Add data points and CIs or PIs to the plots. </p>
</td></tr>
<tr><td><code id="plot.marssPredict_+3A_plot.par">plot.par</code></td>
<td>
<p> A list of plot parameters to adjust the look of the plot.  The default is <code>list(point.pch = 19, point.col = "blue", point.fill = "blue", point.size = 1, line.col = "black", line.size = 1, line.type = "solid", ci.fill = NULL, ci.col = NULL, ci.linetype = "blank", ci.linesize = 0, ci.alpha = 0.6, f.col = "#0000AA", f.linetype = "solid", f.linesize=0.5, theme = theme_bw())</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Plots are plotted
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes and based off of <code>plot.forecast</code> in the forecast package written by Rob J Hyndman &amp; Mitchell O'Hara-Wild.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+predict.marssMLE">predict.marssMLE</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(harborSealWA)
dat &lt;- t(harborSealWA[, -1])
fit &lt;- MARSS(dat[1:2,])
fr &lt;- predict(fit, n.ahead=10)
plot(fr, include=10)

# forecast.marssMLE does the same thing as predict with h
fr &lt;- forecast(fit, n.ahead=10)
plot(fr)

# without h, predict will show the prediction intervals
fr &lt;- predict(fit)
plot(fr)

# you can fit to a new set of data using the same model and same x0
fr &lt;- predict(fit, newdata=list(y=dat[3:4,]), x0="use.model")
plot(fr)

# but you probably want to re-estimate x0
fr &lt;- predict(fit, newdata=list(y=dat[3:4,]), x0="reestimate")
plot(fr)

# forecast; note h not n.ahead is used for forecast()
fr &lt;- forecast(fit, h=10)
</code></pre>

<hr>
<h2 id='plot.marssResiduals'> Plot MARSS marssResiduals objects </h2><span id='topic+plot.marssResiduals'></span><span id='topic+autoplot.marssResiduals'></span>

<h3>Description</h3>

<p>Plots residuals using the output from a <code><a href="#topic+residuals.marssMLE">residuals</a>()</code> call. By default all available residuals plots are plotted.  Individual plots can be plotted by passing in <code>plot.type</code>.  If an individual plot is made using <code>autoplot()</code>, the ggplot object is returned which can be further manipulated. Plots are only shown for those residual types in the <code><a href="#topic+marssResiduals">marssResiduals</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssResiduals'
plot(x, plot.type = c("all", "residuals", "qqplot", "acf"), 
                   conf.int = TRUE, conf.level = 0.95, decorate = TRUE,
                   plot.par = list(), silent = FALSE, ...)
## S3 method for class 'marssResiduals'
autoplot(x, 
           plot.type = c("all", "residuals", "qqplot", "acf"), 
           conf.int = TRUE, conf.level = 0.95, decorate = TRUE, 
           plot.par = list(), 
           silent = FALSE)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.marssResiduals_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+marssResiduals">marssResiduals</a></code> object.  </p>
</td></tr>
<tr><td><code id="plot.marssResiduals_+3A_plot.type">plot.type</code></td>
<td>
<p> Type of plot.  If not passed in, all plots are drawn. See details for plot types.  </p>
</td></tr>
<tr><td><code id="plot.marssResiduals_+3A_conf.int">conf.int</code></td>
<td>
<p> TRUE/FALSE. Whether to include a confidence interval. </p>
</td></tr>
<tr><td><code id="plot.marssResiduals_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level for CIs. </p>
</td></tr>
<tr><td><code id="plot.marssResiduals_+3A_decorate">decorate</code></td>
<td>
<p> TRUE/FALSE. Add smoothing lines to residuals plots or qqline to qqplots and add data points plus residuals confidence intervals to states and observations plots. </p>
</td></tr>
<tr><td><code id="plot.marssResiduals_+3A_plot.par">plot.par</code></td>
<td>
<p> A list of plot parameters to adjust the look of the plots.  The default is list(point.pch = 19, point.col = &quot;blue&quot;, point.fill = &quot;blue&quot;, point.size = 1,
line.col = &quot;black&quot;, line.size = 1, line.linetype = &quot;solid&quot;,
ci.fill = &quot;grey70&quot;, ci.col = &quot;grey70&quot;, ci.linetype = &quot;solid&quot;, 
ci.linesize = 0, ci.alpha = 0.6). </p>
</td></tr>
<tr><td><code id="plot.marssResiduals_+3A_silent">silent</code></td>
<td>
<p> No console interaction or output. </p>
</td></tr>
<tr><td><code id="plot.marssResiduals_+3A_...">...</code></td>
<td>
<p> Not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>resids &lt;- residuals(x)</code> is used (default) where <code>x</code> is a <code>marssMLE</code> object from a <code>MARSS()</code> call, then <code>resids</code> has the innovations residuals, or one-step-ahead residuals. These are what are commonly used for residuals diagnostics in state-space modeling. However, other types of residuals are possible for state-space models; see <code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code> for details. The plot function for <code>marssResiduals</code> objects will handle all types of residuals that might be in the <code>marssResiduals</code> object. However if you simply use the default behavior, <code>resids &lt;- residuals(x)</code> and <code>plot(resids)</code>, you will get the standard model residuals diagnostics plots for state-space models, i.e. only model residuals plots and only plots for innovations model residuals (no smoothations model residuals).
</p>
<p>The plot types are as follows:
</p>

<dl>
<dt><code>"all"</code></dt><dd><p> All the residuals in the residuals object plus QQ plots and ACF plots. </p>
</dd>
<dt><code>"residuals"</code></dt><dd><p> Only residuals versus time. </p>
</dd>
<dt><code>"qqplot"</code></dt><dd><p> Only QQ plots. Visual normality test for the residuals.</p>
</dd> 
<dt><code>"acf"</code></dt><dd><p> ACF of the residuals. If <code>x$type is "ytt1"</code>, these are the one-step-ahead (aka innovations) residuals and they should be temporally independent. </p>
</dd>
</dl>



<h3>Value</h3>

<p>If an individual plot is selected using <code>plot.type</code> and <code>autoplot()</code> is called, then the ggplot object is returned invisibly.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(harborSealWA)
model.list &lt;- list( Z = as.factor(c(1, 1, 1, 1, 2)), R = "diagonal and equal")
fit &lt;- MARSS(t(harborSealWA[, -1]), model = model.list)
resids &lt;- residuals(fit)

require(ggplot2)
# plots of residuals versus time, QQ-norm plot, and ACF
autoplot(resids)

# only the ACF plots
# autoplot(resids, plot.type = "acf")

</code></pre>

<hr>
<h2 id='population-count-data'> Population Data Sets </h2><span id='topic+population-count-data'></span><span id='topic+graywhales'></span><span id='topic+grouse'></span><span id='topic+prairiechicken'></span><span id='topic+wilddogs'></span><span id='topic+rockfish'></span><span id='topic+okanaganRedds'></span><span id='topic+kestrel'></span><span id='topic+redstart'></span>

<h3>Description</h3>

<p>Example data sets for use in the <code><a href="#topic+MARSS-package">MARSS-package</a></code> User Guide. Some are logged and some unlogged population counts. See the details below on each data set.
</p>
<p>The data sets are matrices with year in the first column and counts in other columns.  Since MARSS functions require time to be across columns, these data matrices must be transposed before passing into MARSS functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(graywhales)
data(grouse)
data(prairiechicken)
data(wilddogs)
data(kestrel)
data(okanaganRedds)
data(rockfish)
data(redstart)
</code></pre>


<h3>Format</h3>

<p>The data are supplied as a matrix with years in the first column and counts in the second (and higher) columns.
</p>


<h3>Source</h3>


<dl>
<dt>graywhales </dt><dd><p> Gerber L. R., Master D. P. D. and Kareiva P. M. (1999) Gray whales and the value of monitoring data in implementing the U.S. Endangered Species Act.  Conservation Biology, 13, 1215-1219.</p>
</dd>
<dt>grouse </dt><dd><p> Hays D. W., Tirhi M. J. and Stinson D. W. (1998) Washington state status report for the sharptailed grouse. Washington Department Fish and Wildlife, Olympia, WA. 57 pp.</p>
</dd>
<dt>prairiechicken </dt><dd><p> Peterson M. J. and Silvy N. J. (1996) Reproductive stages limiting productivity of the endangered Attwater's prairie chicken. Conservation Biology, 10, 1264-1276.</p>
</dd>
<dt>wilddogs </dt><dd><p> Ginsberg, J. R., Mace, G. M. and Albon, S. (1995). Local extinction in a small and declining population: Wild Dogs in the Serengeti. Proc. R. Soc. Lond. B, 262, 221-228.</p>
</dd>
<dt>okanaganRedds </dt><dd><p> A data set of Chinook salmon redd (egg nest) surveys.  This data comes from the Okanagan River in Washington state, a major tributary of the Columbia River (headwaters in British Columbia). Unlogged.</p>
</dd>
<dt>rockfish </dt><dd><p> Logged catch per unit effort data for Puget Sound total total rockfish (mix of species) from a series of different types of surveys.</p>
</dd>
<dt>kestrel </dt><dd><p> Three time series of American kestrel logged abundance from adjacent Canadian provinces along a longitudinal gradient (British Columbia, Alberta, Saskatchewan).  Data have been collected annually, corrected for changes in observer coverage and detectability, and logged.</p>
</dd>
<dt>redstart</dt><dd><p> 1966 to 1995 counts for American Redstart from the North American Breeding Bird Survey (BBS record number 0214332808636; Peterjohn 1994) used in Dennis et al. (2006).  Peterjohn, B.G. 1994. The North American Breeding Bird Survey. Birding 26, 386&ndash;398. and Dennis et al. 2006. Estimating density dependence, process noise, and observation error. Ecological Monographs 76:323-341.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>str(graywhales)
str(grouse)
str(prairiechicken)
str(wilddogs)
str(kestrel)
str(okanaganRedds)
str(rockfish)
</code></pre>

<hr>
<h2 id='predict'> predict and forecast MARSS MLE objects </h2><span id='topic+predict'></span><span id='topic+forecast'></span>

<h3>Description</h3>

<p>See the following help files:
</p>

<ul>
<li><p><code><a href="#topic+predict.marssMLE">predict.marssMLE</a>()</code> Predict and forecast. 
</p>
</li>
<li><p><code><a href="#topic+forecast.marssMLE">forecast.marssMLE</a>()</code> Forecast. Use <code><a href="#topic+predict.marssMLE">predict.marssMLE</a>()</code> to call with argument <code>h</code>. 
</p>
</li>
<li><p><code><a href="#topic+plot.marssPredict">plot.marssPredict</a>()</code> Plot a prediction or forecast.    
</p>
</li>
<li><p><code><a href="#topic+autoplot.marssPredict">autoplot.marssPredict</a>()</code> Plot a prediction or forecast using ggplot2 package.  
</p>
</li>
<li><p><code><a href="#topic+print.marssPredict">print.marssPredict</a>()</code> Print prediction or forecast. If <code>h!=0</code>, i.e. forecast, only the forecast is printed but the <code><a href="#topic+marssPredict">marssPredict</a></code> object (in <code>pred</code>) has all the historical time steps also.  
</p>
</li></ul>


<hr>
<h2 id='predict.marssMLE'> predict and forecast MARSS MLE objects </h2><span id='topic+predict.marssMLE'></span>

<h3>Description</h3>

<p>This function will return the modeled value of <code class="reqn">\mathbf{y}_t</code> or <code class="reqn">\mathbf{x}_t</code> conditioned on the data (either the data used to fit the model or data in <code>newdata</code>). For <code class="reqn">\mathbf{y}_t</code>, this is <code class="reqn">\mathbf{Z}_t \mathbf{x}_t^T+\mathbf{a}_t+\mathbf{D}_t\mathbf{d}_t</code>. For <code class="reqn">\mathbf{x}_t</code>, this is <code class="reqn">\mathbf{B}_t \mathbf{x}_{t-1}^T+\mathbf{u}_t+\mathbf{C}_t\mathbf{c}_{t}</code>.  <code class="reqn">\mathbf{x}_t^T</code> is the smoothed state estimate at time <code class="reqn">t</code> conditioned on all the data (either data used to fit the model or the optional data passed into <code>newdata</code>).
</p>
<p>If you want the estimate of <code class="reqn">\mathbf{x}_t</code> conditioned on all the data (i.e. output from the Kalman filter or smoother), then use <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code>. Note that the prediction of <code class="reqn">\mathbf{x}_t</code> conditioned on the data up to time <code class="reqn">t</code> is not provided since that would require the estimate of <code class="reqn">\mathbf{x}_t</code> conditioned on data 1 to <code class="reqn">t+1</code>, which is not output from the Kalman filter or smoother.
</p>
<p>If <code>h</code> is passed in, <code>predict(object)</code> will return a forecast <code class="reqn">h</code> steps past the end of the model data. <code>predict(object)</code> returns a <code><a href="#topic+marssPredict">marssPredict</a></code> object which can be passed to <code>plot()</code> or <code>ggplot2::autoplot()</code>for automatic plotting of predictions and forecasts with intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
predict(object, n.ahead = 0, 
     level = c(0.80, 0.95), 
     type = c("ytt1", "ytT", "xtT", "ytt", "xtt1"), 
     newdata = list(t=NULL, y=NULL, c=NULL, d=NULL), 
     interval = c("none", "confidence", "prediction"), 
     fun.kf = c("MARSSkfas", "MARSSkfss"), 
     x0 = "reestimate", ...)
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.marssMLE_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object.  </p>
</td></tr>
<tr><td><code id="predict.marssMLE_+3A_n.ahead">n.ahead</code></td>
<td>
<p> Number of steps ahead to forecast. If <code>n.ahead !=0</code>, then <code>newdata</code> is for the forecast, i.e. for the n.ahead time steps after the end of the model data. See details. </p>
</td></tr>
<tr><td><code id="predict.marssMLE_+3A_level">level</code></td>
<td>
<p> Level for the intervals if <code>interval != "none".</code></p>
</td></tr>
<tr><td><code id="predict.marssMLE_+3A_type">type</code></td>
<td>
 <p><code>ytT</code>, <code>ytt</code> or <code>ytt1</code>: predictions for the observations based on the states estimate at time <code class="reqn">t</code> conditioned on all the data, data up to <code class="reqn">t</code> or data up to <code class="reqn">t-1</code>. <code>xtT</code> or <code>xtt1</code>: predictions for the states at time <code class="reqn">t</code> based on the states estimate at time <code class="reqn">t-1</code> conditioned on all the data or data up to <code class="reqn">t-1</code>. The data are the data used to fit the model unless <code>y</code> is passed in in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict.marssMLE_+3A_newdata">newdata</code></td>
<td>
<p> An optional list with new <code>y</code> (data), <code>c</code> or <code>d</code> (covariates) to use for the predictions or forecasts. <code>y</code>, <code>c</code> or <code>d</code> must have the same structure (matrix dimensions) as used in the <code><a href="#topic+MARSS">MARSS</a>()</code> call but the number of time steps can be different. <code>t</code> is used if there is ambuiquity as to which time steps the <code>newdata</code> refer to. See examples and details. </p>
</td></tr>
<tr><td><code id="predict.marssMLE_+3A_interval">interval</code></td>
<td>
<p> If <code>interval="confidence"</code>, then the standard error and confidence intervals of the predictions are returned. If <code>interval="prediction"</code>, prediction intervals are returned. See <code><a href="#topic+fitted.marssMLE">fitted</a></code> for a discussion of the intervals. </p>
</td></tr>
<tr><td><code id="predict.marssMLE_+3A_fun.kf">fun.kf</code></td>
<td>
<p> Only if you want to change the default Kalman filter. Can be ignored. </p>
</td></tr>
<tr><td><code id="predict.marssMLE_+3A_x0">x0</code></td>
<td>
<p> If &quot;reestimate&quot; (the default), then the initial value for the states is re-estimated. If <code>"use.model"</code>, then the initial values in the fitted model (<code>object</code>) are used. If you change the data, then this initial condition may not be appropriate. You can also pass in a new <code>x0</code> to use. It must be a matrix that is the same dimensions as <code>x0</code> in the model. <code>x0</code> is ignored if <code>h!=0</code> since in that case a forecast is being done. See example. </p>
</td></tr>
<tr><td><code id="predict.marssMLE_+3A_...">...</code></td>
<td>
<p> Other arguments. Not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Forecasts <code>n.ahead != 0</code></strong>
</p>
<p>The <code>type="xtT"</code> forecast is the states forecast conditioned on all the data. If <code>n.ahead !=0</code>, then 'data' that is being conditioned on is the original data (model data) plus any data in <code>newdata$y</code> for the h forecast time steps. Note, typically forecasts would not have data, since they are forecasts, but <code>predict.marssMLE()</code> allows you to specify data for the forecast time steps if you need to. If the model includes covariates (<code class="reqn">\mathbf{c}</code> and/or <code class="reqn">\mathbf{d}</code> matrices passed into the <code>model</code> list in the <code><a href="#topic+MARSS">MARSS</a>()</code> call), then <code>c</code> and/or <code>d</code> must be passed into <code>newdata</code>. 
</p>
<p>The <code>type="ytT"</code> forecast is the expected value of NEW data (<code class="reqn">\mathbf{Y}</code>) conditioned on the data used for fitting. The data used for fitting is the same as for <code>type="xtT"</code> (above). The <code class="reqn">\mathbf{y}</code> forecast is <code>Z xtT[,T+i] + A + D d[,T+i]</code>. 
</p>
<p>If the model has time-varying parameters, the value of the parameters at the last time step are used for the forecast.
</p>
<p><strong>Model predictions <code>n.ahead == 0</code></strong>
</p>
<p>If <code>newdata</code> is not passed in, then the model data (<code class="reqn">\mathbf{y}</code>) and <code class="reqn">\mathbf{c}</code> and <code class="reqn">\mathbf{d}</code> (if part of model) are used for the predictions. <code><a href="#topic+fitted.marssMLE">fitted</a>(object, type="ytT")</code> is the internal function for model predictions in that case.
</p>
<p>If <code>newdata</code> is passed in, then the predictions are computed using <code>newdata</code> but with the MARSS model estimated from the original data, essentially the Kalman filter/smoother is run using the estimated MARSS model but with data (and <code class="reqn">\mathbf{c}</code> and <code class="reqn">\mathbf{d}</code> if in the model) in <code>newdata</code>.  <code>y</code>, <code>c</code> and <code>d</code> in the <code>newdata</code> list must all have the same number of columns (time-steps) and the length of <code>t</code> in <code>newdata</code> must be the same as the number of columns and must be sequential.
</p>
<p>For <code>type="ytT"</code>, the predictions are conceptually the same as predictions returned by <code>predict.lm</code> for a linear regression. The confidence interval is the interval for the expected value of NEW data. The prediction interval is the interval for NEW data. Prediction intervals will always be wider (or equal if R=0) to confidence intervals. The difference is that the uncertainty in <code>predict.lm</code> comes from parameter uncertainty and the data error while in <code>predict.marssMLE</code>, the uncertainty is from <code class="reqn">\mathbf{x}</code> uncertainty and data error. Parameter uncertainty does not enter the interval calculations; parameters are treated as known at their point estimates. This is not specific to the MARSS package. This is how prediction and confidence intervals are presented for MARSS models in the literature, i.e. no parameter uncertainty. 
</p>

<dl>
<dt><code>t</code> in <code>newdata</code>:</dt><dd><p> If the model has time-varying parameters, <code>t</code> in <code>newdata</code> removes any ambiguity as to which parameter values (time steps) will be used for prediction. In this case, <code>t</code> specifies which time values of the parameters you want to use. If you leave off <code>t</code>, then it is assumed that <code>t</code> starts at the first time step in the data used to fit the original model. If the model is time-constant, <code>t</code> is used to set the time step values (used for plotting, etc.). </p>
</dd>
<dt>The model has <code class="reqn">\mathbf{c}</code> and/or <code class="reqn">\mathbf{d}</code>:</dt><dd> <p><code>c</code> and/or <code>d</code> must be included in <code>newdata</code>. If <code>y</code> (new data) is not in <code>newdata</code>, it is assumed to be absent (all NA). That is, the default behavior if <code>y</code> is absent but <code>c</code> and/or <code>d</code> is present is <code>y="none"</code>. If you want to use the original data used to fit the model, then pass in <code>y="model"</code> in <code>newdata</code>. Pass in <code>t</code> in <code>newdata</code> if it is ambiguous which time steps of the model data to use.</p>
</dd>
<dt>The model has time-varying parameters:</dt><dd><p> You have to pass in <code>t</code> in <code>newdata</code> to specify what parameter values to use. If any <code class="reqn">t &gt; T</code> (<code class="reqn">T</code> equals the last time step in the model data), then it is assumed that you want to use the parameter values at the last time step of the original time series for values beyond the last time step. See examples. </p>
</dd>
<dt><code>y</code>, <code>c</code> and <code>d</code> in <code>newdata</code> have more time steps than the original data: </dt><dd><p>If the model has time-varying parameters, you will need to pass in <code>t</code>. If the model is time-constant, then <code>t</code> is assumed to start at the first time step in the original data but you can pass in <code>t</code> to change that. It will not change the prediction, but will change the t column in the output.</p>
</dd>
</dl>

<p><strong>x0 estimation</strong> If you are passing in <code>y</code> in <code>newdata</code>, then it is likely that you will need to re-estimate the <code class="reqn">\mathbf{x}</code> initial condition. The default behavior of <code>predict.marssMLE</code>. Use <code>x0 = "use.model"</code> to use the initial values in the estimated model (<code>object</code>).
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>The method used for fitting, e.g. MARSS kem. </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The <code><a href="#topic+marssMLE">marssMLE</a></code> object passed into predict(). </p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>The <code>newdata</code> list if passed in.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The confidence or prediction intervals <code>level</code>.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>A data frame the predictions or forecasts along with the intervals. </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The <code>type</code> passed in.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The time steps in the pred data frame.</p>
</td></tr>
<tr><td><code>n.ahead and h</code></td>
<td>
<p>The number of forecast time steps.</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>The x0 used for the predictions.</p>
</td></tr>
<tr><td><code>tinitx</code></td>
<td>
<p>The tinitx used.</p>
</td></tr>
</table>
<p>The pred data frame has the following columns:
</p>
<table>
<tr><td><code>.rownames</code></td>
<td>
<p> Names of the data or states. </p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p> Time step. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> The data if <code>type</code> is <code>"ytT"</code>, <code>"ytt"</code> or <code>"ytt1"</code>. </p>
</td></tr>
<tr><td><code>xtT</code></td>
<td>
<p> The estimate of <code class="reqn">\mathbf{x}_t</code> conditioned on all the data if <code>type="xtT"</code>. From <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code>. </p>
</td></tr>
<tr><td><code>xtt</code></td>
<td>
<p> The estimate of <code class="reqn">\mathbf{x}_t</code> conditioned on the data 1 to <code class="reqn">t</code> if <code>type="xtt1"</code>. From <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>()</code>. </p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Model predicted values of observations (<code class="reqn">\mathbf{y}</code>) or the states (<code class="reqn">\mathbf{x}</code>). See details.</p>
</td></tr>
</table>
<p>If intervals are returned, the following are added to the data frame:
</p>
<table>
<tr><td><code>se</code></td>
<td>
<p> Standard errors of the predictions. </p>
</td></tr>
<tr><td><code>Lo ...</code></td>
<td>
<p> Lower confidence level at <code>alpha = 1-level</code>. The interval is approximated using qnorm(alpha/2)*se + prediction. </p>
</td></tr>
<tr><td><code>Hi ...</code></td>
<td>
<p> Upper confidence level. The interval is approximated using qnorm(1-alpha/2)*se + prediction. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.marssPredict">plot.marssPredict</a>()</code>, <code><a href="#topic+fitted.marssMLE">fitted.marssMLE</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4,] #remove the year row
fit &lt;- MARSS(dat, model=list(R="diagonal and equal"))

# 2 steps ahead forecast
fr &lt;- predict(fit, type="ytT", n.ahead=2)
plot(fr)

# use model data with the estimated initial values (at t=0) for 
# initial values at t=9
# This would be a somewhat strange thing to do and the value at t=10 will look wrong.
fr &lt;- predict(fit,  newdata=list(t=10:20, y=dat[,10:20]), x0 = "use.model")
plot(fr)

# pass in new data and give it new t; initial conditions will be estimated
fr &lt;- predict(fit,  newdata=list(t=23:33, y=matrix(10,3,11)))
plot(fr, ylim=c(8,12))


# Covariate example
fulldat &lt;- lakeWAplanktonTrans
years &lt;- fulldat[,"Year"]&gt;=1965 &amp; fulldat[,"Year"]&lt;1975
dat &lt;- t(fulldat[years,c("Greens", "Bluegreens")])
dat &lt;- zscore(dat)
covariates &lt;- rbind(
  Temp = fulldat[years, "Temp"],
  TP = fulldat[years, "TP"])
covariates &lt;- zscore(covariates)
A &lt;- U &lt;- "zero"
B &lt;- Z &lt;- "identity"
R &lt;- diag(0.16,2)
Q &lt;- "equalvarcov"
C &lt;- "unconstrained"
model.list &lt;- list(B=B,U=U,Q=Q,Z=Z,A=A,R=R,C=C,c=covariates)
fit &lt;- MARSS(dat, model=model.list)

# Use a new c (covariate) but no data.
fr &lt;- predict(fit,  newdata=list(c=matrix(5,2,10)), x0="use.model")
plot(fr)

# Use first 10 time steps of model data
plot(predict(fit, newdata=list(y=dat[,1:10], c=matrix(5,2,10))))

# Use all model data but new covariates
# Why does it look so awful? Because this is a one-step ahead
# prediction and there is no info on what the c will be at t
plot(predict(fit,  newdata=list(y=dat, c=matrix(5,2,120))))

# Use all model data but new covariates with ytT type
# this looks better because is uses all the c data to estimate (so knows what c is at t and beyond)
plot(predict(fit,  newdata=list(y=dat, c=matrix(5,2,120)), type="ytT"))

# Use no data; cannot estimate initial conditions without data
# so x0 must be "use.model"
fr &lt;- predict(fit,  newdata=list(c=matrix(5,2,22)), x0="use.model")
plot(fr)

# forecast with covariates
# n.ahead and the number column in your covariates in newdata must match
plot(predict(fit,  newdata=list(c=matrix(5,2,10)), n.ahead=10))

# forecast with covariates and only show last 10 steps of original data
plot(predict(fit,  newdata=list(c=matrix(5,2,10)), n.ahead=10), include=10)
    
</code></pre>

<hr>
<h2 id='print.marssMLE'> Printing functions for MARSS MLE objects </h2><span id='topic+print.marssMLE'></span>

<h3>Description</h3>

<p><code><a href="#topic+MARSS">MARSS</a>()</code> outputs <code><a href="#topic+marssMLE">marssMLE</a></code> objects.  <code>print(MLEobj)</code>, where <code>MLEobj</code> is a <code><a href="#topic+marssMLE">marssMLE</a></code> object, will print out information on the fit.  However, <code>print</code> can be used to print a variety of information (residuals, smoothed states, imputed missing values, etc) from a <code><a href="#topic+marssMLE">marssMLE</a></code> object using the <code>what</code> argument in the print call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
print(x, digits = max(3, getOption("digits")-4), ..., 
    what = "fit", form = NULL, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.marssMLE_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object.  </p>
</td></tr>
<tr><td><code id="print.marssMLE_+3A_digits">digits</code></td>
<td>
<p> Number of digits for printing.  </p>
</td></tr>
<tr><td><code id="print.marssMLE_+3A_...">...</code></td>
<td>
<p> Other arguments for print. </p>
</td></tr>
<tr><td><code id="print.marssMLE_+3A_what">what</code></td>
<td>
<p> What to print.  Default is &quot;fit&quot;.  If you input what as a vector, print returns a list. See examples.
</p>

<dl>
<dt> &quot;model&quot;</dt><dd><p> The model parameters with names for the estimated parameters.  The output is customized by the form of the model that was fit.  This info is in <code> attr(x$model, "form") </code>. </p>
</dd>
<dt> &quot;par&quot; </dt><dd><p> A list of only the estimated values in each matrix. Each model matrix has it's own list element. Standard function: <code>coef(x)</code></p>
</dd>
<dt> &quot;start&quot; or &quot;inits&quot; </dt><dd><p> The values that the optimization algorithm was started at. Note, <code>x$start</code> shows this in form=&quot;marss&quot; while <code>print</code> shows it in whatever form is in <code> attr(x$model, "form") </code>.</p>
</dd>
<dt> &quot;paramvector&quot; </dt><dd><p> A vector of all the estimated values in each matrix. Standard function: <code>coef(x, type="vector")</code>.  See <code><a href="#topic+coef.marssMLE">coef</a>()</code>.</p>
</dd>
<dt> &quot;par.se&quot;,&quot;par.bias&quot;,&quot;par.lowCIs&quot;,&quot;par.upCIs&quot; </dt><dd><p> A vector the estimated parameter standard errors, parameter bias, lower and upper confidence intervals. Standard function: <code>MARSSparamCIs(x)</code>  See <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code>.</p>
</dd>
<dt> &quot;xtT&quot; or &quot;states&quot; </dt><dd><p> The estimated states conditioned on all the data. <code>x$states</code></p>
</dd>
<dt> &quot;data&quot; </dt><dd><p> The data. This is in <code>x$model$data</code></p>
</dd>
<dt> &quot;logLik&quot; </dt><dd><p> The log-likelihood. Standard function: <code>x$logLik</code>.  See <code><a href="#topic+MARSSkf">MARSSkf</a>()</code> for a discussion of the computation of the log-likelihood for MARSS models. </p>
</dd>
<dt> &quot;ytT&quot; </dt><dd><p> The expected value of the data conditioned on all the data.  Returns the data if present and the expected value if missing. This is in <code>x$ytT</code> (ytT is analogous to xtT).</p>
</dd>
<dt> &quot;states.se&quot; </dt><dd><p> The state standard errors. <code>x$states.se</code> </p>
</dd>
<dt> &quot;states.cis&quot; </dt><dd><p> Approximate confidence intervals for the states. See <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code>.</p>
</dd>
<dt> &quot;model.residuals&quot; </dt><dd><p> The one-step ahead model residuals or innovations. <code class="reqn">\mathbf{y}_t - \textrm{E}[\mathbf{Y}_t|\mathbf{y}_1^{t-1}]</code>, aka actual data at time <code class="reqn">t</code> minus the expected value of the data conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t-1</code>. Standard function: <code>residuals(x, type="tt1")</code>  See <code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code> for a discussion of residuals in the context of MARSS models.</p>
</dd>
<dt> &quot;state.residuals&quot; </dt><dd><p> The smoothed state residuals. <code class="reqn">\mathbf{x}_t^T- \textrm{E}[\mathbf{X}_t|\mathbf{x}_{t-1}^T]</code>, aka the expected value of the states at time <code class="reqn">t</code> conditioned on all the data minus the expected value of the states at time <code class="reqn">t</code> conditioned on <code class="reqn">\mathbf{x}_{t-1}^T]</code>. Standard function: <code>residuals(x, type="tT")</code>  See <code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code>.</p>
</dd>
<dt> parameter name </dt><dd><p> Returns the parameter matrix for that parameter with fixed values at their fixed values and the estimated values at their estimated values. Standard function: <code>coef(x, type="matrix")$elem</code> </p>
</dd>
<dt> &quot;kfs&quot; </dt><dd><p> The Kalman filter and smoother output.  See <code><a href="#topic+MARSSkf">MARSSkf</a>()</code> for a description of the output. The full kf output is not normally attached to the output from a <code><a href="#topic+MARSS">MARSS</a>()</code> call.  This will run the filter/smoother if needed and return the list invisibly.  So assign the output as <code>foo=print(x,what="kfs")</code></p>
</dd>
<dt> &quot;Ey&quot; </dt><dd><p> The expectations involving y conditioned on all the data.  See <code><a href="#topic+MARSShatyt">MARSShatyt</a>()</code> for a discussion of these expectations.  This output is not normally attached to the output from a <code><a href="#topic+MARSS">MARSS</a>()</code> call&ndash;except <code>ytT</code> which is the predicted value of any missing y. The list is returned invisibly so assign the output as <code>foo=print(x,what="Ey")</code>.</p>
</dd>
</dl>
 </td></tr>
<tr><td><code id="print.marssMLE_+3A_form">form</code></td>
<td>
<p> By default, print uses the model form specified in the call to <code><a href="#topic+MARSS">MARSS</a>()</code>.  This information is in <code> attr(marssMLE$model, "form") </code>, however you can specify a different form.  <code> form="marss" </code> should always work since this is the model form in which the model objects are stored (in <code>marssMLE$marss</code>).</p>
</td></tr>
<tr><td><code id="print.marssMLE_+3A_silent">silent</code></td>
<td>
<p> If TRUE, do not print just return the object.  If print call is assigned, nothing will be printed.  See examples.  If <code>what="fit"</code>, there is always output printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of information.  If you assign the print call to a value, then you can reference the output.  See the examples.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  dat &lt;- t(harborSeal)
  dat &lt;- dat[c(2,11),]
  MLEobj &lt;- MARSS(dat)
  
  print(MLEobj)
  
  print(MLEobj, what="model")
  
  print(MLEobj,what="par")
  
  #silent doesn't mean silent unless the print output is assigned
  print(MLEobj, what="paramvector", silent=TRUE)
  tmp &lt;- print(MLEobj, what="paramvector", silent=TRUE)
  #silent means some info on what you are printing is shown whether
  #or not the print output is assigned
  print(MLEobj, what="paramvector", silent=FALSE)
  tmp &lt;- print(MLEobj, what="paramvector", silent=FALSE)
  
  cis &lt;- print(MLEobj, what="states.cis")
  cis$up95CI
  
  vars &lt;- print(MLEobj, what=c("R","Q"))
</code></pre>

<hr>
<h2 id='print.marssMODEL'> Printing marssMODEL Objects </h2><span id='topic+print.marssMODEL'></span><span id='topic+summary.marssMODEL'></span>

<h3>Description</h3>

<p><code>print(MODELobj)</code>, where <code>MODELobj</code> is a <code><a href="#topic+marssMODEL">marssMODEL</a></code> object, will print out information on the model in short form (e.g. 'diagonal and equal').
</p>
<p><code>summary(marssMODEL)</code>, where <code><a href="#topic+marssMODEL">marssMODEL</a></code> is a marssMODEL object, will print out detailed information on each parameter matrix showing where the estimated values (and their names) occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMODEL'
print(x, ...)
## S3 method for class 'marssMODEL'
summary(object, ..., silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.marssMODEL_+3A_x">x</code></td>
<td>
<p> A marssMODEL object.  </p>
</td></tr>
<tr><td><code id="print.marssMODEL_+3A_object">object</code></td>
<td>
<p> A marssMODEL object.  </p>
</td></tr>
<tr><td><code id="print.marssMODEL_+3A_...">...</code></td>
<td>
<p> Other arguments . </p>
</td></tr>
<tr><td><code id="print.marssMODEL_+3A_silent">silent</code></td>
<td>
<p> TRUE/FALSE Whether to print output. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print(marssMODEL)</code> prints out of the structure of each parameter matrix in 'English' (e.g. 'diagonal and unequal') and returns invisibly the list.  If you assign the print call to a value, then you can reference the output. 
</p>
<p><code>summary(marssMODEL)</code> prints out of the structure of each parameter matrix in as list matrices showing where each estimated value occurs in each matrix and returns invisibly the list.  The output can be verbose, especially if parameter matrices are time-varying.  Pass in <code>silent=TRUE</code> and assign output (a list with each parameter matrix) to a variable.  Then specific parameters can be looked at.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11), ]
fit &lt;- MARSS(dat)

print(fit$model)
# this is identical to
print(fit, what = "model")
</code></pre>

<hr>
<h2 id='print.marssPredict'> Printing function for MARSS Predict objects </h2><span id='topic+print.marssPredict'></span>

<h3>Description</h3>

<p><code><a href="#topic+MARSS">MARSS</a>()</code> outputs <code><a href="#topic+marssMLE">marssMLE</a></code> objects.  <code>predict(object)</code>, where object is <code><a href="#topic+marssMLE">marssMLE</a></code> object, will return the predictions of <code class="reqn">\mathbf{y}_t</code> or the smoothed value of <code class="reqn">\mathbf{x}_t</code> for <code>h</code> steps past the end of the model data. <code>predict(object)</code> returns a <code><a href="#topic+marssPredict">marssPredict</a></code> object which can be passed to <code>print.marssPredict()</code> for automatic printing. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssPredict'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.marssPredict_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+marssPredict">marssPredict</a></code> object.  </p>
</td></tr>
<tr><td><code id="print.marssPredict_+3A_...">...</code></td>
<td>
<p> Other arguments for print. Not used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the predictions as a data frame.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4,] #remove the year row
fit &lt;- MARSS(dat, model=list(R="diagonal and equal"))

# 2 steps ahead forecast
predict(fit, type="ytT", n.ahead=2)

# smoothed x estimates with intervals
predict(fit, type="xtT")

</code></pre>

<hr>
<h2 id='residuals.marssMLE'>Model and state fitted values, residuals, and residual sigma</h2><span id='topic+residuals.marssMLE'></span>

<h3>Description</h3>

<p><code>residuals.marssMLE</code> returns a data frame with fitted values, residuals, residual standard deviation (sigma), and standardized residuals. A residual is the difference between the &quot;value&quot; of the model (<code class="reqn">\mathbf{y}</code>) or  state (<code class="reqn">\mathbf{x}</code>) and the fitted value.  At time <code class="reqn">t</code> (in the returned data frame), the model residuals are for time <code class="reqn">t</code>. For the the state residuals, the residual is for the transition from <code class="reqn">t</code> to <code class="reqn">t+1</code> following the convention in Harvey, Koopman and Penzer (1998). For the the state innovation residuals, this means that <code>state.residual[,t]</code> is for the transition from <code class="reqn">t</code> to <code class="reqn">t+1</code> and is conditioned on data 1 to <code class="reqn">t</code> while <code>model.residual[,t]</code> is is conditioned on data 1 to <code class="reqn">t-1</code>. State innovation residuals are not normally used while state smoothation residuals are used in trend outlier analysis. If warnings are reported, use <code>attr(residuals(fit), "msg")</code> to retrieve the messages.
</p>
<p>Because the state residuals is for the transition from <code class="reqn">t</code> to <code class="reqn">t+1</code>, this means that the state residual <code>.resids[t]</code> is <code>value[t-1]</code> minus <code>.fitted[t-1]</code> in the outputted data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
residuals(object, ..., 
           type=c("tt1", "tT", "tt"),
           standardization=c("Cholesky", "marginal", "Block.Cholesky"),
           form=attr(object[["model"]], "form")[1],
           clean=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.marssMLE_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+marssMLE">marssMLE</a></code> object</p>
</td></tr>
<tr><td><code id="residuals.marssMLE_+3A_type">type</code></td>
<td>
<p><code>tt1</code> means innovations residuals. The fitted values are computed conditioned on the data up to <code class="reqn">t-1</code>. See <code><a href="#topic+fitted.marssMLE">fitted</a>()</code> with <code>type="ytt1"</code> or <code>type="xtt1"</code>. <code>tT</code> means smoothation residuals. the fitted values are computed conditioned on all the data. See <code><a href="#topic+fitted.marssMLE">fitted</a>()</code> with <code>type="ytT"</code> or <code>type="xtT"</code>. <code>tt</code> means contemporaneous residuals. The fitted values are computed conditioned on the data up to <code class="reqn">t</code>. In MARSS functions, estimates at time <code class="reqn">t</code> conditioned on data 1 to <code class="reqn">T</code> are denoted <code>tT</code>, conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t-1</code> are denoted <code>tt1</code> and conditioned on data 1 to <code class="reqn">t</code> are <code>tt</code>.</p>
</td></tr>
<tr><td><code id="residuals.marssMLE_+3A_standardization">standardization</code></td>
<td>
<p>&quot;Cholesky&quot; means it is standardized by the lower triangle of the Cholesky transformation of the full variance-covariance matrix of the model and state residuals. 
&quot;marginal&quot; means that the residual is standardized by its standard deviation, i.e. the square root of the value on the diagonal of the variance-covariance matrix of the model and state residuals. 
&quot;Block.Cholesky&quot; means the model or state residuals are standardized by the lower triangle of the Cholesky transformation of only their variance-covariance matrix (not the joint model and state variance-covariance matrix). </p>
</td></tr>
<tr><td><code id="residuals.marssMLE_+3A_form">form</code></td>
<td>
<p> For developers. Can be ignored. If you want the function to use a different function than <code>residuals_form</code>.  This might be useful if you manually specified a DFA model and want to use <code>residuals_dfa</code> for rotating.</p>
</td></tr>
<tr><td><code id="residuals.marssMLE_+3A_clean">clean</code></td>
<td>
<p> Can be ignored. For <code>type="tt1"</code>, state residuals are not used for residuals analysis and for <code>type="tt"</code>, they don't exist (all NA). They are used only for smoothation residuals, <code>type="tT"</code>.  For <code>type="tt1"</code> and <code>type="tt"</code>, the data frame is cleaned by removing <code>name=="state"</code> when <code>clean=TRUE</code>. </p>
</td></tr>
<tr><td><code id="residuals.marssMLE_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+MARSSresiduals">MARSSresiduals</a></code> for a discussion of the residuals calculations for MARSS models.
</p>
<p><strong>value</strong> and <strong>.fitted</strong>
</p>
<p>See the discussion below on the meaning of these for <code class="reqn">\mathbf{y}</code> associated residuals (model residuals) or <code class="reqn">\mathbf{x}</code> associated residuals (state residuals).
</p>
<p><strong>model residuals</strong>
</p>
<p>The model residuals are in the data frame with <code>name=="model"</code>.
</p>
<p>The model residuals are the familiar type of residuals, they are the difference between the data at time <code class="reqn">t</code> and the predicted value at time <code class="reqn">t</code>, labeled <code>.fitted</code> in the data frame. For the model residuals, the &quot;value&quot;&quot; is the data (or NA if data are missing). If <code>type="tT"</code>, the predicted value is the expected value of <code class="reqn">\mathbf{Y}</code> conditioned on all the data, i.e. is computed using the smoothed estimate of <code class="reqn">\mathbf{x}</code> at time <code class="reqn">t</code> (<code>xtT</code>).  If <code>type="tt1"</code>, the predicted value is the expected value of <code class="reqn">\mathbf{Y}</code> conditioned on the data up to time <code class="reqn">t-1</code>, i.e. is computed using the estimate of <code class="reqn">\mathbf{x}</code> at time <code class="reqn">t</code> conditioned on the data up to time <code class="reqn">t-1</code> (<code>xtt1</code>). These are known as the one-step-ahead predictions and the residuals are known as the innovations. 
</p>
<p>The standard errors help visualize how well the model fits to the data.  See <code><a href="#topic+fitted.marssMLE">fitted</a></code> for a discussion of the calculation of the model predictions for the observations.  The standardized smoothation residuals can be used for outlier detection.  See the references in <code><a href="#topic+MARSSresiduals">MARSSresiduals</a></code> and the chapter on shock detection in the MARSS User Guide.
</p>
<p><strong>state residuals</strong>
</p>
<p>The state residuals are in the data frame with <code>name=="state"</code>.
</p>
<p>If you want the expected value of the states and an estimate of their standard errors (for confidence intervals), then <code>residuals()</code> is not what you want to use.  You want to use <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>(..., type="xtT")</code> to return the smoothed estimate of the state or you can find the states in the <code>states</code> element of the <code><a href="#topic+marssMLE">marssMLE</a></code> object returned by a <code>MARSS()</code> call. For the one-step-ahead state estimates, use <code><a href="#topic+tsSmooth.marssMLE">tsSmooth</a>(..., type="xtt1")</code>.
</p>
<p>The state residuals are only for state-space models. At time <code class="reqn">t</code>, the state residuals are the difference between the state estimate at time <code class="reqn">t+1</code> and the predicted value of the state at time <code class="reqn">t+1</code> given the estimate of the state at time <code class="reqn">t</code>. For smoothation state residuals, this is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{w}}_{t+1} = \mathbf{x}_{t+1}^T - \mathbf{B}\mathbf{x}_{t}^T - \mathbf{u} - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>

<p>For &quot;tt1&quot; state residuals, this is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{w}}_{t+1} = \mathbf{x}_{t+1}^{t+1} - \mathbf{B}\mathbf{x}_{t}^t - \mathbf{u}  - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>
<p>.
Note the t indexing is offset. The state residual at time t is the estimate at time t+1 minus the fitted value at t+1.
</p>
<p>Smoothation state residuals are used for outlier detection or shock detection in the state process.  See <code><a href="#topic+MARSSresiduals">MARSSresiduals</a></code> and read the references cited. Note that the state residual at time <code class="reqn">T</code> (the last time step) is NA since this would be the transition from <code class="reqn">T</code> to <code class="reqn">T+1</code> (past the end of the data).
</p>
<p>Note, because the state residuals are for the transition from <code class="reqn">t</code> to <code class="reqn">t+1</code>, this means that in the outputted data frame, the state residual <code>.resids[t]</code> is <code>value[t-1]</code> minus <code>.fitted[t-1]</code>.
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>tT, tt1 or tt</p>
</td></tr>
<tr><td><code>.rownames</code></td>
<td>
<p>The names of the observation rows or the state rows.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>model or state</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>time step</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The data value if <code>name</code> equals &quot;model&quot; or the <code class="reqn">x</code> estimate if <code>name</code> equals &quot;state&quot; at time <code class="reqn">t</code>. See details.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Model predicted values of observations or states at time <code class="reqn">t</code>. See details.</p>
</td></tr>
<tr><td><code>.resids</code></td>
<td>
<p>Model or states residuals. See details.</p>
</td></tr>
<tr><td><code>.sigma</code></td>
<td>
<p>The standard error of the model or state residuals. Intervals for the residuals can be constructed from <code>.sigma</code> using <code>qnorm(alpha/2)*.sigma + .fitted.</code></p>
</td></tr>
<tr><td><code>.std.resids</code></td>
<td>
<p>Standardized residuals. See <code><a href="#topic+MARSSresiduals">MARSSresiduals</a></code> for a discussion of residual standardization.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045. 
</p>
<p>See also the discussion and references in <code><a href="#topic+MARSSresiduals.tT">MARSSresiduals.tT</a></code>, <code><a href="#topic+MARSSresiduals.tt1">MARSSresiduals.tt1</a></code> and <code><a href="#topic+MARSSresiduals.tt">MARSSresiduals.tt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11, 12), ]
fit &lt;- MARSS(dat, model = list(Z = factor(c("WA", "OR", "OR"))))

library(ggplot2)
theme_set(theme_bw())

## Not run: 
# Show a series of standard residuals diagnostic plots for state-space models
autoplot(fit, plot.type="residuals")

## End(Not run)

d &lt;- residuals(fit, type="tt1")
## Not run: 
# Make a series of diagnostic plots from a residuals object
autoplot(d)

## End(Not run)

# Manually make a plot of the model residuals (innovations) with intervals
d$.conf.low &lt;- d$.fitted+qnorm(0.05/2)*d$.sigma
d$.conf.up &lt;- d$.fitted-qnorm(0.05/2)*d$.sigma
ggplot(data = d) +
  geom_line(aes(t, .fitted)) +
  geom_point(aes(t, value), na.rm=TRUE) +
  geom_ribbon(aes(x = t, ymin = .conf.low, ymax = .conf.up), linetype = 2, alpha = 0.1) +
  ggtitle("Model residuals (innovations)") +
  xlab("Time Step") + ylab("Count") +
  facet_grid(~.rownames)

# NOTE state residuals are for t to t+1 while the value and fitted columns 
# are for t. So (value-fitted)[t] matches .resids[t+1] NOT .resids[t]
# This is only for state residuals. For model residuals, the time-indexing matches.
d &lt;- residuals(fit, type="tT")
dsub &lt;- subset(d, name=="state")
# note t in col 1 matches t+1 in col 2
head(cbind(.resids=dsub$.resids, valminusfitted=dsub$value-dsub$.fitted))

# Make a plot of the smoothation residuals
ggplot(data = d) +
  geom_point(aes(t, value-.fitted), na.rm=TRUE) +
  facet_grid(~.rownames+name) +
  ggtitle("Smoothation residuals (state and model)") +
  xlab("Time Step") + ylab("Count")

# Make a plot of xtT versus prediction of xt from xtT[t-1]
# This is NOT the estimate of the smoothed states with CIs. Use tsSmooth() for that.
ggplot(data = subset(d, name=="state")) +
  geom_point(aes(t, value), na.rm=TRUE) +
  geom_line(aes(x = t, .fitted), color="blue") +
  facet_grid(~.rownames) +
  xlab("Time Step") + ylab("Count") +
  ggtitle("xtT (points) and prediction (line)")

# Make a plot of y versus prediction of yt from xtT[t]
# Why doesn't the OR line go through the points?
# Because there is only one OR state line and it needs to go through
# both sets of OR data.
ggplot(data = subset(d, name=="model")) +
  geom_point(aes(t, value), na.rm=TRUE) +
  geom_line(aes(x = t, .fitted), color="blue") +
  facet_grid(~.rownames) +
  xlab("Time Step") + ylab("Count") +
  ggtitle("data (points) and prediction (line)")

</code></pre>

<hr>
<h2 id='SalmonSurvCUI'> Salmon Survival Indices </h2><span id='topic+SalmonSurvCUI'></span>

<h3>Description</h3>

<p>Example data set for use in MARSS vignettes for the DLM chapter in the <code><a href="#topic+MARSS-package">MARSS-package</a></code> <a href="https://cran.r-project.org/package=MARSS/vignettes/UserGuide.pdf">User Guide</a>. This is a 42-year time-series of the logit of juvenile salmon survival along with an index of April coastal upwelling.  See the source for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SalmonSurvCUI)
</code></pre>


<h3>Format</h3>

<p>The data are provided as a matrix with time running down the rows.  Column 1 is year, column 2 is the logit of the proportion of juveniles that survive to adulthood, column 3 is an index of the April coastal upwelling index.
</p>


<h3>Source</h3>

<p>Scheuerell, Mark D., and John G. Williams. &quot;Forecasting climate-induced changes in the survival of Snake River spring/summer Chinook salmon (Oncorhynchus tshawytscha).&quot; Fisheries Oceanography 14.6 (2005): 448-457.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(SalmonSurvCUI)
</code></pre>

<hr>
<h2 id='stdInnov'> Standardized Innovations </h2><span id='topic+stdInnov'></span>

<h3>Description</h3>

<p>Standardizes Kalman filter innovations. This is a helper function called by <code><a href="#topic+MARSSinnovationsboot">MARSSinnovationsboot</a>()</code> in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdInnov(SIGMA, INNOV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdInnov_+3A_sigma">SIGMA</code></td>
<td>
<p> n x n x T array of Kalman filter innovations variances.  This is output from <code><a href="#topic+MARSSkf">MARSSkf</a></code>. </p>
</td></tr>
<tr><td><code id="stdInnov_+3A_innov">INNOV</code></td>
<td>
<p> n x T matrix of Kalman filter innovations.  This is output from  <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>n = number of observation (y) time series.   T = number of time steps in the time series.
</p>


<h3>Value</h3>

<p>n x T matrix of standardized innovations.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

 
<p>Stoffer, D. S., and K. D. Wall. 1991. Bootstrapping state-space models: Gaussian maximum likelihood estimation and the Kalman filter. Journal of the American Statistical Association 86:1024-1033.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+MARSSboot">MARSSboot</a>()</code>, <code><a href="#topic+MARSSkf">MARSSkf</a>()</code>, <code><a href="#topic+MARSSinnovationsboot">MARSSinnovationsboot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  std.innovations &lt;- stdInnov(kfList$Sigma, kfList$Innov)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.marssMLE'> Summary methods for marssMLE objects </h2><span id='topic+summary.marssMLE'></span>

<h3>Description</h3>

<p>A brief summary of the fit: number of state and observation time series and the estimates. See also <code><a href="#topic+glance.marssMLE">glance</a>()</code> and <code><a href="#topic+tidy.marssMLE">tidy</a>()</code> for other summary like output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
summary(object, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.marssMLE_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object.  </p>
</td></tr>
<tr><td><code id="summary.marssMLE_+3A_digits">digits</code></td>
<td>
<p> Number of digits for printing.  </p>
</td></tr>
<tr><td><code id="summary.marssMLE_+3A_...">...</code></td>
<td>
<p> Not used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns 'object' invisibly.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+glance.marssMLE">glance</a>()</code>, <code><a href="#topic+tidy.marssMLE">tidy</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  dat &lt;- t(harborSeal)
  dat &lt;- dat[c(2,11),]
  fit &lt;- MARSS(dat)
  
  summary(fit)
  glance(fit)
  tidy(fit)
  </code></pre>

<hr>
<h2 id='sysdata'> Palettes </h2><span id='topic+hcl_palette_52'></span><span id='topic+hcl_palette_100'></span>

<h3>Description</h3>

<p>Palettes to use in the plotting functions. This is from <code>colorspace::sequential_hcl(n)</code> with n=100 or n=52.
</p>

<hr>
<h2 id='tidy.marssMLE'>Return estimated parameters with summary information</h2><span id='topic+tidy'></span><span id='topic+tidy.marssMLE'></span>

<h3>Description</h3>

<p><code>tidy.marssMLE</code> is the method for the tidy generic. It returns  the parameter estimates and their confidence intervals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
tidy(x, conf.int = TRUE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.marssMLE_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+marssMLE">marssMLE</a></code> object</p>
</td></tr>
<tr><td><code id="tidy.marssMLE_+3A_conf.int">conf.int</code></td>
<td>
<p> Whether to compute confidence and prediction intervals on the estimates. </p>
</td></tr>
<tr><td><code id="tidy.marssMLE_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level. <code>alpha=1-conf.level</code></p>
</td></tr>
<tr><td><code id="tidy.marssMLE_+3A_...">...</code></td>
<td>
<p>Optional arguments.  If <code>conf.int=TRUE</code>, then arguments to specify how CIs are computed can be passed in. See details and <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tidy.marssMLE()</code> assembles information available via the <code><a href="#topic+print.marssMLE">print</a>()</code> and <code><a href="#topic+coef.marssMLE">coef</a>()</code> functions into a data frame that summarizes the estimates.  If <code>conf.int=TRUE</code>, <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code> will be run to add confidence intervals to the model object if these are not already added.  The default CIs are calculated using a analytically computed Hessian matrix.  This can be changed by passing in optional arguments for <code><a href="#topic+MARSSparamCIs">MARSSparamCIs</a>()</code>. 
</p>


<h3>Value</h3>

<p>A data frame with estimates, sample standard errors, and confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11, 12), ]
fit &lt;- MARSS(dat)

# A data frame of the estimated parameters
tidy(fit)

</code></pre>

<hr>
<h2 id='toLatex.marssMODEL'> Create a LaTeX Version of the Model </h2><span id='topic+toLatex.marssMODEL'></span><span id='topic+toLatex.marssMLE'></span>

<h3>Description</h3>

<p>Creates LaTex and a PDF (if LaTeX compiler available) using the tools in the Hmisc package. The files are saved in the working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMODEL'
toLatex(object, ..., file = NULL, digits = 2, greek = TRUE, orientation = "landscape", 
math.sty = "amsmath", output = c("pdf", "tex", "rawtex"), replace = TRUE, simplify = TRUE)
## S3 method for class 'marssMLE'
toLatex(object, ..., file = NULL, digits = 2, greek = TRUE, orientation = "landscape", 
math.sty = "amsmath", output = c("pdf", "tex", "rawtex"), replace = TRUE, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toLatex.marssMODEL_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+marssMODEL">marssMODEL</a></code> or <code><a href="#topic+marssMLE">marssMLE</a></code> object.  </p>
</td></tr>
<tr><td><code id="toLatex.marssMODEL_+3A_...">...</code></td>
<td>
<p> Other arguments. Not used. </p>
</td></tr>
<tr><td><code id="toLatex.marssMODEL_+3A_file">file</code></td>
<td>
<p> Name of file to save to. Optional. </p>
</td></tr>
<tr><td><code id="toLatex.marssMODEL_+3A_digits">digits</code></td>
<td>
<p> Number of digits to display for numerical values (if real). </p>
</td></tr>
<tr><td><code id="toLatex.marssMODEL_+3A_greek">greek</code></td>
<td>
<p> Use greek symbols. </p>
</td></tr>
<tr><td><code id="toLatex.marssMODEL_+3A_orientation">orientation</code></td>
<td>
<p> Orientation to use. landscape or portrait. </p>
</td></tr>
<tr><td><code id="toLatex.marssMODEL_+3A_math.sty">math.sty</code></td>
<td>
<p> LaTeX math styling to use. </p>
</td></tr>
<tr><td><code id="toLatex.marssMODEL_+3A_output">output</code></td>
<td>
<p> pdf, tex or rawtex. If blank, both are output. </p>
</td></tr>
<tr><td><code id="toLatex.marssMODEL_+3A_replace">replace</code></td>
<td>
<p> Replace existing file if present. </p>
</td></tr>
<tr><td><code id="toLatex.marssMODEL_+3A_simplify">simplify</code></td>
<td>
<p> If TRUE, then if <code class="reqn">\mathbf{B}</code> or <code class="reqn">\mathbf{Z}</code> are identity, they do not appear. Any zero-ed out elements also do not appear. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A LaTeX and or PDF file of the model.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Example with linear constraints
dat &lt;- t(harborSeal)
dat &lt;- dat[c(2:4), ]
Z1 &lt;- matrix(list("1*z1+-1*z2",0,"z2","2*z1","z1",0),3,2)
A1 &lt;- matrix(list("a1",0,0),3,1)
MLEobj &lt;- MARSS(dat, model=list(Z=Z1, A=A1, Q=diag(0.01,2)))
 ## Not run: 
 toLatex(MLEobj)
 toLatex(MLEobj$model)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='tsSmooth.marssMLE'> Smoothed and filtered x and y time series </h2><span id='topic+tsSmooth.marssMLE'></span><span id='topic+tsSmooth'></span>

<h3>Description</h3>

<p><code>tsSmooth.marssMLE</code> returns the estimated state and observations conditioned on the data. This function will return either the smoothed values (conditioned on all the data) or the filtered values (conditioned on data 1 to <code class="reqn">t</code> or <code class="reqn">t-1</code>). This is output from the Kalman filter and smoother <code><a href="#topic+MARSSkf">MARSSkf</a>()</code> for the <code class="reqn">\mathbf{x}</code> and from the corresponding function <code><a href="#topic+MARSShatyt">MARSShatyt</a>()</code> for the <code class="reqn">\mathbf{y}</code>. 
</p>
<p>These are the expected value of the full right side of the MARSS equations with the error terms (expected value of <code class="reqn">\mathbf{X}_t</code> and <code class="reqn">\mathbf{Y}_t</code>). Conditioning on data <code class="reqn">t=1</code> to <code class="reqn">t-1</code> (one-step ahead), <code class="reqn">t</code> (contemporaneous), or <code class="reqn">T</code> (smoothed) is provided. This is in contrast to <code><a href="#topic+fitted.marssMLE">fitted</a>()</code> which returns the expected value of the right side without the error term, aka model predictions.
</p>
<p>In the state-space literature, the <code class="reqn">\mathbf{y}</code> &quot;estimates&quot; would normally refer to the expected value of the right-side of the <code class="reqn">\mathbf{y}</code> equation without the error term (i.e. the expected value of <code class="reqn">\mathbf{Z} \mathbf{X}_t + \mathbf{a} + \mathbf{D}\mathbf{d}_t</code>). That is provided in <code><a href="#topic+fitted.marssMLE">fitted</a>()</code>. <code>tsSmooth.marssMLE()</code> provides the expected value with the error terms conditioned on the data from 1 to <code class="reqn">t-1</code>, <code class="reqn">t</code>, or <code class="reqn">T</code>. These estimates are used to estimate missing values in the data. If <code class="reqn">\mathbf{y}</code> is multivariate, some <code class="reqn">y</code> are missing at time <code class="reqn">t</code> and some not, and <code class="reqn">\mathbf{R}</code> is non-diagonal, then the expected value of <code class="reqn">\mathbf{Y}_t</code> from the right-side of the <code class="reqn">\mathbf{y}</code> without the error terms would be incorrect because it would not take into account the information in the observed data at time <code class="reqn">t</code> on the missing data at time <code class="reqn">t</code> (except as it influences <code class="reqn">\mathrm{E}[\mathbf{x}_t]</code>). 
</p>
<p>Note, if there are no missing values, the expected value of <code class="reqn">\mathbf{Y}_t</code> (with error terms) conditioned on the data from 1 to <code class="reqn">t</code> or <code class="reqn">T</code> is simply <code class="reqn">\mathbf{y}_t</code>. The expectation is only useful when there are missing values for which an estimate is needed. The expectation of the <code class="reqn">\mathbf{Y}</code> with the error terms is used in the EM algorithm for the general missing values case and the base function is <code><a href="#topic+MARSShatyt">MARSShatyt</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marssMLE'
tsSmooth(object, 
    type = c("xtT", "xtt", "xtt1", "ytT", "ytt", "ytt1"),
    interval = c("none", "confidence", "prediction"),
    level = 0.95, fun.kf = c("MARSSkfas", "MARSSkfss"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsSmooth.marssMLE_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+marssMLE">marssMLE</a></code> object.</p>
</td></tr>
<tr><td><code id="tsSmooth.marssMLE_+3A_type">type</code></td>
<td>
<p> Type of estimates to return. Smoothed states (<code>xtT</code>), one-step-ahead states (<code>xtt1</code>), contemporaneous states (<code>xtt</code>), the model <code>ytT</code> (<code>Z xtT + A + D d(t)</code>), the model <code>ytt</code> (<code>Z xtt + A + D d(t)</code>), the model <code>ytt1</code> (<code>Z xtt1 + A + D d(t)</code>), the expected value of <code class="reqn">\mathbf{Y}_t</code> conditioned on data 1 to <code class="reqn">t-1</code> (<code>ytt1</code>), the expected value of <code class="reqn">\mathbf{Y}_t</code> conditioned on data 1 to <code class="reqn">t</code> (<code>ytt</code>), or the expected value of <code class="reqn">\mathbf{Y}_t</code> conditioned on data 1 to <code class="reqn">T</code> (<code>ytT</code>). See details.</p>
</td></tr>
<tr><td><code id="tsSmooth.marssMLE_+3A_interval">interval</code></td>
<td>
<p> If <code>interval="confidence"</code>, then the standard error and confidence intervals are returned. There are no prediction intervals for estimated states and observations except for <code>ytT</code> (which is a unusual case.) If you are looking for prediction intervals, then you want <code><a href="#topic+fitted.marssMLE">fitted</a>()</code> or <code><a href="#topic+predict.marssMLE">predict</a>()</code>.</p>
</td></tr>
<tr><td><code id="tsSmooth.marssMLE_+3A_level">level</code></td>
<td>
<p> Confidence level. alpha=1-level </p>
</td></tr>
<tr><td><code id="tsSmooth.marssMLE_+3A_fun.kf">fun.kf</code></td>
<td>
<p> By default, <code>tsSmooth()</code> will use the Kalman filter/smoother function in <code>object$fun.kf</code> (either <code><a href="#topic+MARSSkfas">MARSSkfas</a>()</code> or <code><a href="#topic+MARSSkfss">MARSSkfss</a>()</code>). You can pass in <code>fun.kf</code> to force a particular Kalman filter/smoother function to be used. </p>
</td></tr>
<tr><td><code id="tsSmooth.marssMLE_+3A_...">...</code></td>
<td>
<p>Optional arguments.  If form=&quot;dfa&quot;, <code>rotate=TRUE</code> can be passed in to rotate the trends (only trends not the <code class="reqn">\mathbf{Z}</code> matrix).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below, X and Y refers to the random variable and x and y refer to a specific realization from this random variable.
</p>
<p><strong>state estimates (x)</strong>
</p>
<p>For <code>type="xtT"</code>, <code>tsSmooth.marssMLE</code> returns the confidence intervals of the state at time <code class="reqn">t</code> conditioned on the data from 1 to <code class="reqn">T</code> using the estimated model parameters as true values. These are the standard intervals that are shown for the estimated states in state-space models. For example see, Shumway and Stoffer (2000), edition 4, Figure 6.4. As such, this is probably what you are looking for if you want to put intervals on the estimated states (the <code class="reqn">\mathbf{x}</code>). However, these intervals do not include parameter uncertainty. If you want state residuals (for residuals analysis), use <code><a href="#topic+MARSSresiduals">MARSSresiduals</a>()</code> or <code><a href="#topic+residuals.marssMLE">residuals</a>()</code>.
</p>
<p><strong>Quantiles</strong> The state <code class="reqn">\mathbf{X}_t</code> in a MARSS model has a conditional multivariate normal distribution, that can be computed from the model parameters and data. In Holmes (2012, Equation 11) notation, its expected value conditioned on all the observed data and the model parameters <code class="reqn">\Theta</code> is denoted <code class="reqn">\tilde{\mathbf{x}}_t</code> or equivalently <code class="reqn">\mathbf{x}_t^T</code> (where the $T$ superscript is not a power but the upper extent of the time conditioning). In <code><a href="#topic+MARSSkf">MARSSkf</a></code>, this is <code>xtT[,t]</code>. The variance of <code class="reqn">\mathbf{X}_t</code> conditioned on all the observed data and <code class="reqn">\Theta</code> is <code class="reqn">\tilde{\mathbf{V}}_t</code> (<code>VtT[,,t]</code>). Note that <code>VtT[,,t] != B VtT[,,t-1] t(B) + Q</code>, which you might think by looking at the MARSS equations. That is because the variance of <code class="reqn">\mathbf{W}_t</code> conditioned on the data (past, current and FUTURE) is not equal to  <code class="reqn">\mathbf{Q}</code> (<code class="reqn">\mathbf{Q}</code> is the unconditional variance).
</p>
<p><code class="reqn">\mathbf{x}_t^T</code> (<code>xtT[,t]</code>) is an estimate of <code class="reqn">\mathbf{x}_t</code> and the standard error of that estimate is given by <code class="reqn">\mathbf{V}_t^T</code> (<code>VtT[,,t]</code>). Let <code>se.xt</code> denote the sqrt of the diagonal of <code>VtT</code>. The equation for the <code class="reqn">\alpha/2</code> confidence interval is (<code>qnorm(alpha/2)*se.xt + xtT</code>). <code class="reqn">\mathbf{x}_t</code> is multivariate and this interval is for one of the <code class="reqn">x</code>'s in isolation. You could compute the m-dimensional confidence region for the multivariate <code class="reqn">\mathbf{x}_t</code>, also, but <code>tsSmooth.marssMLE</code> returns the univariate confidence intervals. 
</p>
<p>The variance <code>VtT</code> gives information on the uncertainty of the true location of <code class="reqn">\mathbf{x}_t</code> conditioned on the observed data. As more data are collected (or added to the analysis), this variance will shrink since the data, especially data at time <code class="reqn">t</code>, increases the information about the locations of <code class="reqn">\mathbf{x}_t</code>. This does not affect the estimation of the model parameters, those are fixed (we are assuming), but rather our information about the states at time <code class="reqn">t</code>.
</p>
<p>If you have a DFA model (form='dfa'), you can pass in <code>rotate=TRUE</code> to return the rotated trends.  If you want the rotated loadings, you will need to compute those yourself:
</p>
<pre>
dfa &lt;- MARSS(t(harborSealWA[,-1]), model=list(m=2), form="dfa")
Z.est &lt;- coef(dfa, type="matrix")$Z
H.inv &lt;- varimax(coef(dfa, type="matrix")$Z)$rotmat
Z.rot &lt;- Z.est %*% H.inv
</pre>
<p>For <code>type="xtt"</code> and <code>type=="xtt1"</code>, the calculations and interpretations of the intervals are the same but the conditioning is for data <code class="reqn">t=1</code> to <code class="reqn">t</code> or <code class="reqn">t=1</code> to <code class="reqn">t-1</code>. 
</p>
<p><strong>observation estimates (y)</strong>
</p>
<p>For <code>type="ytT"</code>, this returns the expected value and standard error of <code class="reqn">\mathbf{Y}_t</code> (left-hand side of the <code class="reqn">\mathbf{y}</code> equation) conditioned on <code class="reqn">\mathbf{Y}_t=y_t</code>. If you have no missing data, this just returns your data set. But you have missing data, this what you want in order to estimate the values of missing data in your data set. The expected value of <code class="reqn">\mathbf{Y}_t|\mathbf{Y}=\mathbf{y}(1:T)</code> is in <code>ytT</code> in <code><a href="#topic+MARSShatyt">MARSShatyt</a>()</code> output and the variance is <code>OtT-tcrossprod(ytT)</code> from the <code><a href="#topic+MARSShatyt">MARSShatyt</a>()</code> output. 
</p>
<p>The intervals reported by <code>tsSmooth.marssMLE</code> for the missing values take into account all the information in the data, specifically the correlation with other data at time <code class="reqn">t</code> if <code class="reqn">\mathbf{R}</code> is not diagonal. This is what you want to use for interpolating missing data. You do not want to use <code>predict.marssMLE()</code> as those predictions are for entirely new data sets and thus will ignore relevant information if <code class="reqn">\mathbf{y}_t</code> is multivariate, not all <code class="reqn">\mathbf{y}_t</code> are missing, and the <code class="reqn">\mathbf{R}</code> matrix is not diagonal.
</p>
<p>The standard error and confidence interval for the expected value of the missing data along with the standard deviation and prediction interval for the missing data are reported. The former uses the variance of <code class="reqn">\textrm{E}[\mathbf{Y}_t]</code> conditioned on the data while the latter uses variance of <code class="reqn">\mathbf{Y}_t</code> conditioned on the data. <code><a href="#topic+MARSShatyt">MARSShatyt</a>()</code> returns these variances and expected values. See Holmes (2012) for a discussion of the derivation of expectation and variance of <code class="reqn">\mathbf{Y}_t</code> conditioned on the observed data (in the section 'Computing the expectations in the update equations').
</p>
<p>For <code>type="ytt"</code>, only the estimates are provided. <code><a href="#topic+MARSShatyt">MARSShatyt</a>()</code> does not return the necessary variances matrices for the standard errors for this cases.
</p>


<h3>Value</h3>

<p>A data frame with the following columns is returned. Values computed from the model are prefaced with &quot;.&quot;.
</p>
<p>If <code>interval="none"</code>, the following are returned:
</p>
<table>
<tr><td><code>.rownames</code></td>
<td>
<p> Names of the data or states. </p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p> Time step. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> The data if <code>type</code> is <code>"ytT"</code>, <code>"ytt"</code> or <code>"ytt1"</code>. </p>
</td></tr>
<tr><td><code>.estimate</code></td>
<td>
<p> The estimated values. See details. </p>
</td></tr>
</table>
<p>If <code>interval = "confidence"</code>, the following are also returned:
</p>
<table>
<tr><td><code>.se</code></td>
<td>
<p> Standard errors of the estimates. </p>
</td></tr>
<tr><td><code>.conf.low</code></td>
<td>
<p> Lower confidence level at <code>alpha = 1-level</code>. The interval is approximated using qnorm(alpha/2)*se + estimate </p>
</td></tr>
<tr><td><code>.conf.up</code></td>
<td>
<p> Upper confidence level. The interval is approximated using qnorm(1-alpha/2)*se + estimate </p>
</td></tr>
</table>
<p>If <code>interval = "prediction"</code>, the following are also returned:
</p>
<table>
<tr><td><code>.sd</code></td>
<td>
<p> Standard deviation of new <code class="reqn">\mathbf{y}_t</code> values. </p>
</td></tr>
<tr><td><code>.lwr</code></td>
<td>
<p> Lower range at <code>alpha = 1-level</code>. The interval is approximated using qnorm(alpha/2)*sd + estimate </p>
</td></tr>
<tr><td><code>.upr</code></td>
<td>
<p> Upper range at <code>level</code>. The interval is approximated using qnorm(1-alpha/2)*sd + estimate </p>
</td></tr>
</table>


<h3>References</h3>

 
<p>R. H. Shumway and D. S. Stoffer (2000).  Time series analysis and its applications. Edition 4. Springer-Verlag, New York.
</p>
<p>Holmes, E. E. (2012).  Derivation of the EM algorithm for constrained and unconstrained multivariate autoregressive state-space (MARSS) models.  Technical Report. arXiv:1302.3919 [stat.ME]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11, 12), ]
fit &lt;- MARSS(dat)

# Make a plot of the estimated states
library(ggplot2)
d &lt;- tsSmooth(fit, type = "xtT", interval="confidence")
ggplot(data = d) +
  geom_line(aes(t, .estimate)) +
  geom_ribbon(aes(x = t, ymin = .conf.low, ymax = .conf.up), linetype = 2, alpha = 0.3) +
  facet_grid(~.rownames) +
  xlab("Time Step") + ylab("State estimate")

# Make a plot of the estimates for the missing values
library(ggplot2)
d &lt;- tsSmooth(fit, type = "ytT", interval="confidence")
d2 &lt;- tsSmooth(fit, type = "ytT", interval="prediction")
d$.lwr &lt;- d2$.lwr
d$.upr &lt;- d2$.upr
ggplot(data = d) +
  geom_point(aes(t, .estimate)) +
  geom_line(aes(t, .estimate)) +
  geom_point(aes(t, y), color = "blue", na.rm=TRUE) +
  geom_ribbon(aes(x = t, ymin = .conf.low, ymax = .conf.up), alpha = 0.3) +
  geom_line(aes(t, .lwr), linetype = 2) +
  geom_line(aes(t, .upr), linetype = 2) +
  facet_grid(~.rownames) +
  xlab("Time Step") + ylab("Count") +
  ggtitle("Blue=data, Black=estimate, grey=CI, dash=prediction interval")

# Contrast this with the model prediction of y(t), i.e., put a line through the points
# Intervals are for new data not the blue dots 
# (which were used to fit the model so are not new)
library(ggplot2)
d &lt;- fitted(fit, type = "ytT", interval="confidence", level=0.95)
d2 &lt;- fitted(fit, type = "ytT", interval="prediction", level=0.95)
d$.lwr &lt;- d2$.lwr
d$.upr &lt;- d2$.upr
ggplot(data = d) +
  geom_line(aes(t, .fitted), linewidth = 1) +
  geom_point(aes(t, y), color = "blue", na.rm=TRUE) +
  geom_ribbon(aes(x = t, ymin = .conf.low, ymax = .conf.up), alpha = 0.3) +
  geom_line(aes(t, .lwr), linetype = 2) +
  geom_line(aes(t, .upr), linetype = 2) +
  facet_grid(~.rownames) +
  xlab("Time Step") + ylab("Count") +
  ggtitle("Blue=data, Black=estimate, grey=CI, dash=prediction interval")
</code></pre>

<hr>
<h2 id='utility.functions'> Utility Functions </h2><span id='topic+utility.functions'></span><span id='topic+makediag'></span><span id='topic+takediag'></span><span id='topic+is.blockdiag'></span><span id='topic+is.design'></span><span id='topic+is.diagonal'></span><span id='topic+is.equaltri'></span><span id='topic+is.fixed'></span><span id='topic+is.identity'></span><span id='topic+is.solvable'></span><span id='topic+is.timevarying'></span><span id='topic+is.unitcircle'></span><span id='topic+is.validvarcov'></span><span id='topic+is.zero'></span><span id='topic+vec'></span><span id='topic+unvec'></span><span id='topic+is.wholenumber'></span><span id='topic+Imat'></span><span id='topic+rwishart'></span><span id='topic+mystrsplit'></span><span id='topic+convert.model.mat'></span><span id='topic+parmat'></span><span id='topic+fixed.free.to.formula'></span><span id='topic+matrix.power'></span><span id='topic+sub3D'></span><span id='topic+pinv'></span><span id='topic+pcholinv'></span><span id='topic+pchol'></span><span id='topic+vector.all.equal'></span><span id='topic+fully.spec.x'></span><span id='topic+marssMODEL.to.list'></span>

<h3>Description</h3>

<p>Utility functions for MARSS functions in the <code><a href="#topic+MARSS-package">MARSS-package</a></code>.  These are not exported but can be accessed using the <code>MARSS:::</code> prefix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector.all.equal(x)
convert.model.mat(param.matrix)
fixed.free.to.formula(fixed,free,dim)
fully.spec.x(Z, R)
Imat(x)
is.blockdiag(x)
is.design(x, strict=TRUE, dim=NULL, zero.rows.ok=FALSE, zero.cols.ok=FALSE)
is.diagonal(x, na.rm=FALSE)
is.equaltri(x)
is.fixed(x, by.row=FALSE)
is.identity(x, dim=NULL)
is.timevarying(MLEobj)
is.solvable(A,y=NULL)
is.validvarcov(x, method="kem")
is.wholenumber(x, tol = .Machine$double.eps^0.5)
is.unitcircle(x, tol = .Machine$double.eps^0.5)
is.zero(x)
makediag(x, nrow=NA)
marssMODEL.to.list(MODELobj)
matrix.power(x, n)
mystrsplit(x)
parmat(MLEobj, elem = c("B", "U", "Q", "Z", "A", "R", "x0", "V0", "G", "H", "L"), 
    t = 1, dims = NULL, model.loc = "marss")
pinv(x)
pcholinv(x, chol = TRUE)
pchol(x) 
rwishart(nu, V)
sub3D(x,t=1)
takediag(x)
unvec(x, dim=NULL)
vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.functions_+3A_x">x</code>, <code id="utility.functions_+3A_a">A</code>, <code id="utility.functions_+3A_y">y</code></td>
<td>
<p> A matrix (or vector for '<code>makediag</code>' or string for '<code>mystrsplit</code>'.). </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_z">Z</code>, <code id="utility.functions_+3A_r">R</code></td>
<td>
 <p><code>Z</code> matrix and <code>R</code> matrix </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_na.rm">na.rm</code></td>
<td>
<p> How to treat NAs in the block diag test. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_dim">dim</code>, <code id="utility.functions_+3A_dims">dims</code></td>
<td>
<p> Matrix dimensions. Some functions will take the vec of a matrix.  In this case, the optional dim arg specifies the matrix dimensions. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_fixed">fixed</code></td>
<td>
<p> A fixed matrix per the MARSS specification for fixed matrix syntax. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_free">free</code></td>
<td>
<p> A free matrix per the MARSS specification for free matrix syntax. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_nrow">nrow</code></td>
<td>
<p> Number of rows. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_tol">tol</code></td>
<td>
<p> Tolerance. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_method">method</code></td>
<td>
<p> kem or BFGS.  Used to add extra test for MARSSoptim(). </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_t">t</code></td>
<td>
<p> The time index or third dimension of a 3D matrix </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_nu">nu</code>, <code id="utility.functions_+3A_v">V</code></td>
<td>
<p> Parameters of a Wishart distribution. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_param.matrix">param.matrix</code></td>
<td>
<p> The list matrix version of a time-invariant MARSS model. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_n">n</code></td>
<td>
<p> An integer for the power function. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_zero.rows.ok">zero.rows.ok</code>, <code id="utility.functions_+3A_zero.cols.ok">zero.cols.ok</code></td>
<td>
<p> Means the design matrix can have all zero rows or columns. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_strict">strict</code></td>
<td>
<p> Specifies whether the design matrix must be only 0s and 1s. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_by.row">by.row</code></td>
<td>
<p> For is.fixed, reports whether is.fixed by row rather than for the whole matrix. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_chol">chol</code></td>
<td>
<p> For pcholinv, use <code>chol2inv(chol())</code> if TRUE otherwise use solve(). </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_mleobj">MLEobj</code></td>
<td>
<p> A <code><a href="#topic+marssMLE">marssMLE</a></code> object. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_modelobj">MODELobj</code></td>
<td>
<p> A <code><a href="#topic+marssMODEL">marssMODEL</a></code> object. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_elem">elem</code></td>
<td>
<p> The parameter matrix of a marss model to return. </p>
</td></tr>
<tr><td><code id="utility.functions_+3A_model.loc">model.loc</code></td>
<td>
<p> Whether to use the marss or model marssMODEL in the <code><a href="#topic+marssMLE">marssMLE</a></code> object. </p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>is...</code> tests for various matrix properties.  isDiagonal() from the Matrix package is used to test numeric matrices for diagonality.  is.diagonal() is only used to determine if list matrices (that combine numeric and character values) are diagonal. is.zero tests for near zeroness and gives TRUE for is.zero((.5-.3)-(.3-.1)) unlike ==0.
</p>
</li>
<li> <p><code>is.timevarying(MLEobj)</code> returns a list of which parameters are time-varying.
</p>
</li>
<li> <p><code>vec(x)</code> creates a column vector from a matrix per the standard vec math function.
</p>
</li>
<li> <p><code>unvec(c,dim)</code> takes the vector c and creates a matrix with the specified dimensions.
</p>
</li>
<li> <p><code>Imat(nrow)</code> returns the identity matrix of dimension nrow.
</p>
</li>
<li> <p><code> fixed.free.to.formula </code> takes a fixed and free pair and constructs a list matrix (or array if time-varying) with formulas in each matrix element.
</p>
</li>
<li> <p><code> marssMODEL.to.list </code> uses <code> fixed.free.to.formula </code> on all the elements of a <code><a href="#topic+marssMODEL">marssMODEL</a></code> to create a list that can be passed to <code><a href="#topic+MARSS">MARSS</a>()</code> as the <code>model</code> argument.
</p>
</li>
<li> <p><code> convert.model.mat </code> takes a list matrix with formulas in each element and converts to a fixed/free pair.
</p>
</li>
<li> <p><code> sub3D </code> returns a 2D matrix after subsetting a 3D matrix on the third (time) dimension. Ensures that R always returns a matrix.
</p>
</li>
<li> <p><code> mystrsplit </code> is a customized string splitter used by <code>convert.model.mat</code>.
</p>
</li>
<li> <p><code> rwishart </code> generates random draws from a wishart distribution.
</p>
</li>
<li> <p><code> matrix.power </code> is a faster way to get the n-th power of a matrix.
</p>
</li>
<li> <p><code> pinv </code> is the pseudoinverse based on singular value decomposition PInv=UD^+V' where a diagonal matrix with non-zero diagonal values of D (from svd) replaced with 1/D.
</p>
</li>
<li> <p><code> pcholinv </code> is the inverse based on the Cholesky decomposition but modified to allow 0s on the diagonal of x (with corresponding 0 row/column).  These appear as 0 row/columns in the returned inverse.
</p>
</li>
<li> <p><code> pchol </code> returns the Cholesky decomposition but modified to allow 0s on the diagonal of x (with corresponding 0 row/column).
</p>
</li>
<li> <p><code> is.solvable </code> returns information on the solvability of the linear system y=Ax using the SVD decomposition.
</p>
</li>
<li> <p><code> vector.all.equal </code> tests if the all the elements in a vector, matrix, or array are all equal.  Works on list matrices too.
</p>
</li>
<li> <p><code> parmat </code> constructs the parameter matrix with both the fixed and free values from the vectorized form in a <code><a href="#topic+marssMLE">marssMLE</a></code> object.  Users should use <code><a href="#topic+coef.marssMLE">coef</a></code>.
</p>
</li>
<li> <p><code> fully.spec.x </code> returns a list with 0 and 1 showing which x are fully specified by data when <code>R</code> has zeros on the diagonal. Used by <code><a href="#topic+MARSSkfss">MARSSkfss</a>()</code>.
</p>
</li></ul>
 


<h3>Value</h3>

<p>See above.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes and Eric Ward, NOAA, Seattle, USA.  
</p>

<hr>
<h2 id='zscore'> z-score a vector or matrix </h2><span id='topic+zscore'></span>

<h3>Description</h3>

<p>Removes the mean and standardizes the variance to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zscore(x, mean.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zscore_+3A_x">x</code></td>
<td>
<p> n x T matrix of numbers </p>
</td></tr>
<tr><td><code id="zscore_+3A_mean.only">mean.only</code></td>
<td>
<p> If TRUE, only remove the mean. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>n = number of observation (y) time series.   T = number of time steps in the time series.
</p>
<p>The z-scored values (z) of a matrix of y values are
<code class="reqn">z_i = \Sigma^{-1}(y_i-\bar{y})</code> where <code class="reqn">\Sigma</code> is a diagonal matrix with the standard deviations of each time series (row) along the diagonal, and <code class="reqn">\bar{y}</code> is a vector of the means. 
</p>


<h3>Value</h3>

<p>n x T matrix of z-scored values.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zscore(1:10)
x &lt;- zscore(matrix(c(NA, rnorm(28), NA), 3, 10))
# mean is 0 and variance is 1
apply(x, 1, mean, na.rm = TRUE)
apply(x, 1, var, na.rm = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
