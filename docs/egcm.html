<!DOCTYPE html><html lang="en"><head><title>Help for package egcm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {egcm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#egcm-package'>
<p>Simplified Engle-Granger Cointegration Models</p></a></li>
<li><a href='#acor'><p>autocorrelation</p></a></li>
<li><a href='#allpairs.egcm'><p>Perform cointegration tests for all pairs of securities in a list</p></a></li>
<li><a href='#bvr.test'>
<p>Unit root test based upon Breitung's variance ratio</p></a></li>
<li><a href='#detrend'>
<p>Remove a linear trend from a vector</p></a></li>
<li><a href='#egcm'><p>Simplified Engle-Granger Cointegration Model</p></a></li>
<li><a href='#egcm.defaults'>
<p>Set and get defaults for Engle-Granger cointegration models</p></a></li>
<li><a href='#pgff.test'>
<p>Unit root test of Pantula, Gonzales-Farias and Fuller</p></a></li>
<li><a href='#rar1'><p>Random AR(1) vector</p></a></li>
<li><a href='#rcoint'><p>Random generation of cointegrated sequences</p></a></li>
<li><a href='#sim.egcm'>
<p>Generate simulated data from an Engle-Granger cointegration model</p></a></li>
<li><a href='#ur_power'><p>Power assessment for unit root tests</p></a></li>
<li><a href='#yegcm'>
<p>Engle-Granger cointegration model from Yahoo! price series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Engle-Granger Cointegration Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.13</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-26</td>
</tr>
<tr>
<td>Description:</td>
<td>An easy-to-use implementation of the Engle-Granger
  two-step procedure for identifying pairs of cointegrated series.  It is
  geared towards the analysis of pairs of securities.  Summary and plot
  functions are provided, and the package is able to fetch closing prices of
  securities from Yahoo.  A variety of unit root tests are supported, and 
  an improved unit root test is included.  </td>
</tr>
<tr>
<td>Depends:</td>
<td>zoo, xts</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, ggplot2, tseries, MASS, urca, parallel, pracma, stats,
quantmod, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-27 01:33:28 UTC; matthewclegg</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Clegg [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Clegg &lt;matthewcleggphd@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-27 09:42:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='egcm-package'>
Simplified Engle-Granger Cointegration Models
</h2><span id='topic+egcm-package'></span>

<h3>Description</h3>

<p>This package provides a simplified implementation of the Engle-Granger
cointegration model that is geared towards the analysis of securities prices.
Summary and plot functions are provided, and a convenient interface to
<span class="pkg">quantmod</span> is given. A variety of standard unit root tests are supported,
and an improved unit root test is included.
</p>


<h3>Details</h3>

<p>This package implements a test for a simplified form of cointegration. Namely,
it checks whether or not a linear combination of two time series follows an
autoregressive model of order one. In other words, given two series <code class="reqn">X</code> and
<code class="reqn">Y</code>, it searches for parameters <code class="reqn">\alpha</code>, <code class="reqn">\beta</code> and <code class="reqn">\rho</code>
such that:
</p>
<p style="text-align: center;"><code class="reqn">Y[i] = \alpha + \beta * X[i] + R[i]</code>
</p>

<p style="text-align: center;"><code class="reqn">R[i] = \rho * R[i-1] + \epsilon</code>
</p>

<p>If <code class="reqn">|\rho| &lt; 1</code>, then <code class="reqn">X</code> and <code class="reqn">Y</code> are cointegrated.
</p>
<p>Cointegration is a useful tool in many areas of economics, but this
implementation is especially geared towards the analysis of securities
prices.  Testing for cointegration has been proposed as means for assessing
whether or not two securities are suitable candidates for pairs trading.
</p>
<p>In addition, this package implements two previously unavailable unit root tests.
A test based upon the weighted symmetric estimator <code class="reqn">\rho_{ws}</code> of Pantula,
Gonzales-Farias and Fuller is implemented as <code>pgff.test</code>. This test seems
to provide superior performance to the standard Dickey-Fuller test
<code>adf.test</code> and also improves upon the performance of a number of other
tests previously available in <span class="rlang"><b>R</b></span>.
</p>
<p>The variance ratio test proposed by J. Breitung is implemented as
<code>bvr.test</code>.  It has the advantage that it is a non-parametric test,
and it seems to provide superior performance to other variance ratio
tests available in <span class="rlang"><b>R</b></span>, although it does not perform as well as <code>pgff.test</code>.
</p>
<p>Users who wish to explore more general models for cointegration are
referred to the <code><a href="urca.html#topic+ca.jo">urca</a></code> package of Bernard Pfaff.
</p>


<h3>Disclaimer</h3>

<p>DISCLAIMER: The software in this package is for general information purposes
only. It is hoped that it will be useful, but it is provided WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. It is not intended to form the basis of any investment
decision. USE AT YOUR OWN RISK!
</p>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>References</h3>

<p>Breitung, J. (2002). 
Nonparametric tests for unit roots and cointegration. 
<em>Journal of econometrics</em>, 108(2), 343-363.
</p>
<p>Chan, E. (2013). 
<em>Algorithmic trading: winning strategies and their rationale</em>.
(Vol. 625). John Wiley &amp; Sons.
</p>
<p>Clegg, M. (2014). On the Persistence of Cointegration in Pairs Trading (January 28, 2014). 
Available at SSRN:  http://ssrn.com/abstract=2491201
</p>
<p>Ehrman, D.S. (2006).
<em>The handbook of pairs trading: strategies using equities, options, 
and futures</em>. 
(Vol. 240). John Wiley &amp; Sons.
</p>
<p>Engle, R. F. and C. W. Granger.  (1987)
Co-integration and error correction: representation, estimation, and testing.
<em>Econometrica</em>, 251-276.
</p>
<p>Pantula, S. G., Gonzalez-Farias, G., and Fuller, W. A. (1994).
A comparison of unit-root test criteria.
<em>Journal of Business &amp; Economic Statistics</em>, 12(4), 449-459. 
</p>
<p>Pfaff, B. (2008) 
<em>Analysis of Integrated and Cointegrated Time Series with R. Second Edition</em>. 
Springer, New York. ISBN 0-387-27960-1
</p>
<p>Vidyamurthy, G.  (2004).
<em>Pairs trading: quantitative methods and analysis</em>.
(Vol 217).  Wiley.com.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+egcm">egcm</a></code> Further documentation of the Engle-Granger 
cointegration model
</p>
<p><code><a href="#topic+pgff.test">pgff.test</a></code> Unit root test based on the weighted
symmetric estimator of Pantula, Gonzales-Farias and Fuller
</p>
<p><code><a href="#topic+bvr.test">bvr.test</a></code> Unit root test based on Breitung's 
variance ratio
</p>
<p><code><a href="tseries.html#topic+adf.test">adf.test</a></code>, <code><a href="tseries.html#topic+pp.test">pp.test</a></code> Unit root
tests included in the base R distribution
</p>
<p><code><a href="urca.html#topic+ca.jo">urca</a></code> An extensive collection of unit root tests and
cointegration tests implemented by Bernard Pfaff
</p>
<p><code><a href="pracma.html#topic+hurstexp">hurstexp</a></code> Unit root tests based on variance ratios
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(quantmod)
prices.spy &lt;- getSymbols("SPY", from="2013-01-01", to="2014-01-01",
                          auto.assign = FALSE)$SPY.Adjusted
prices.voo &lt;- getSymbols("VOO", from="2013-01-01", to="2014-01-01",
                          auto.assign = FALSE)$VOO.Adjusted
egcm(prices.spy, prices.voo)
plot(egcm(prices.spy, prices.voo))
summary(egcm(prices.spy, prices.voo))

# The yegcm method provides a convenient interface to the TTR
# package, which can fetch closing prices from Yahoo.  Thus, 
# the above can be simplified as follows:

e &lt;- yegcm("SPY", "VOO", start="2013-01-01", end="2014-01-01")
print(e)
plot(e)
summary(e)

## End(Not run)</code></pre>

<hr>
<h2 id='acor'>autocorrelation</h2><span id='topic+acor'></span>

<h3>Description</h3>

<p>autocorrelation of a sequence</p>


<h3>Usage</h3>

<pre><code class='language-R'>acor(X, k = 1, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acor_+3A_x">X</code></td>
<td>
<p>a numeric vector or <code><a href="zoo.html#topic+zoo">zoo</a></code> vector</p>
</td></tr>
<tr><td><code id="acor_+3A_k">k</code></td>
<td>
<p>the number of lags for which to compute the autocorrelation.  Default: 1</p>
</td></tr>
<tr><td><code id="acor_+3A_na.rm">na.rm</code></td>
<td>
<p>a boolean, which if TRUE, indicates that NA values should be removed
from the series prior to computing the autocorrelation.  Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the lag <code>k</code> autocorrelation of <code>X</code>, e.g., the correlation
of <code>X[i]</code> with <code>X[i-k]</code>.  
</p>


<h3>Note</h3>

<p>It's a bit surprising that this is not a part of the core <span class="rlang"><b>R</b></span> distribution,
but I can't find it.  Perhaps it was thought to be too trivial to include.
</p>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+acf">acf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acor(1:10)                # a perfect correlation
acor(rnorm(100))          # should be close to zero
acor(cumsum(rnorm(100)))  # slightly less than one
acor(rar1(1000, a1=0.8))  # slightly less than 0.8
acor(rar1(1000, a1=0.8), k=2)  # about 0.64
acor(rar1(1000, a1=0.8), k=3)  # about 0.51
</code></pre>

<hr>
<h2 id='allpairs.egcm'>Perform cointegration tests for all pairs of securities in a list</h2><span id='topic+allpairs.egcm'></span>

<h3>Description</h3>

<p>Given a list of ticker symbols, downloads the adjusted daily closing prices
of each of the symbols from Yahoo, and performs a cointegration test for
each pair of symbols.  Returns a <code>data.frame</code> containing the results of the
tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allpairs.egcm(tickers, 
  startdate = format(Sys.Date() - 365, "%Y-%m-%d"), 
  enddate =   format(Sys.Date(), "%Y-%m-%d"), clear.na.inf=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allpairs.egcm_+3A_tickers">tickers</code></td>
<td>
<p> A list of ticker symbols whose data is to be downloaded
from Yahoo!.  Alternatively, this may be a <code>data.frame</code> containing
the price series to be checked, one series per column.</p>
</td></tr>
<tr><td><code id="allpairs.egcm_+3A_startdate">startdate</code></td>
<td>
<p>The starting date for which to download the data.  
Given in the form <code>"YYYY-MM-DD"</code>.  Defaults to one year ago.</p>
</td></tr>
<tr><td><code id="allpairs.egcm_+3A_enddate">enddate</code></td>
<td>
<p>The ending date for which to download the data.
Given in the form <code>"YYYY-MM-DD"</code>.  Defaults to today.</p>
</td></tr>
<tr><td><code id="allpairs.egcm_+3A_clear.na.inf">clear.na.inf</code></td>
<td>
<p>if TRUE, NA and Inf price values are replaced by the last available price.  Default:TRUE.</p>
</td></tr>
<tr><td><code id="allpairs.egcm_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code><a href="#topic+egcm">egcm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the following columns:
</p>

<ul>
<li><p>series1:  Name of the first ticker in this cointegration test
</p>
</li>
<li><p>series2:  Name of the second ticker in this cointegration test
</p>
</li>
<li><p>log:      Boolean which if TRUE indicates that the cointegration
test is performed on the logs of the series
</p>
</li>
<li><p>i1test:   Name of the test used for checking that the series are
integrated.
</p>
</li>
<li><p>urtest:   Name of the test used for checking for a unit root in
the residual series
</p>
</li>
<li><p>alpha:    Constant term of the linear relation between the series
</p>
</li>
<li><p>alpha.se: Standard error of alpha
</p>
</li>
<li><p>beta:     Linear term of the linear relation between the series
</p>
</li>
<li><p>beta.se:  Standard error of beta
</p>
</li>
<li><p>rho:      Coefficient of mean reversion
</p>
</li>
<li><p>rho.se:   Standard error of rho
</p>
</li>
<li><p>s1.i1.stat: Statistic computed for integration test of first series
</p>
</li>
<li><p>s1.i1.p:   p-value for integration test of first series
</p>
</li>
<li><p>s2.i1.stat: Statistic computed for integration test of second series
</p>
</li>
<li><p>s2.i1.p:   p-value for integration test of second series
</p>
</li>
<li><p>r.stat:    Statistic computed for cointegration test (e.g. whether
the residual series contains a unit root)
</p>
</li>
<li><p>r.p:       p-value associated with r.stat
</p>
</li>
<li><p>eps.ljungbox.stat:  Ljung-Box statistic computed on the innovations
of the series
</p>
</li>
<li><p>eps.ljungbox.p:  p-value associated with the Ljung-Box statistic
</p>
</li>
<li><p>s1.dsd:    Standard deviation of the first differences of the first series
</p>
</li>
<li><p>s2.dsd:    Standard deviation of the first differences of the second series
</p>
</li>
<li><p>residuals.sd: Standard deviation of the residual series
</p>
</li>
<li><p>eps.sd:    Standard deviation of the innovations
</p>
</li>
<li><p>is.cointegrated: <code>TRUE</code> if the pair is cointegrated at the 5% confidence level
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+egcm">egcm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Check if any of the oil majors are cointegrated:
    allpairs.egcm(c("BP","CVX","RDS.A","TOT","XOM"))

## End(Not run)
</code></pre>

<hr>
<h2 id='bvr.test'>
Unit root test based upon Breitung's variance ratio
</h2><span id='topic+bvr.test'></span><span id='topic+bvr_rho'></span>

<h3>Description</h3>

<p>Unit root test based upon Breitung's variance ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvr.test(Y, detrend = FALSE)
bvr_rho(Y, detrend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bvr.test_+3A_y">Y</code></td>
<td>
<p>A vector or zoo-vector</p>
</td></tr>
<tr><td><code id="bvr.test_+3A_detrend">detrend</code></td>
<td>
<p>A boolean, which if TRUE, indicates that the test should
be performed after removing a linear trend from <code>Y</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Breitung's variance ratio is given by the formula:
</p>
<p style="text-align: center;"><code class="reqn">\rho_T = \frac{T^{-2} \sum_{t=1}^T Y_t^2}{T^{-1} \sum_{t=1}^T y_t^2}</code>
</p>

<p>where <code class="reqn">T</code> is the length of the vector <code class="reqn">Y</code>.  (See equation (5) 
of his paper.)
</p>
<p>The advantage of Breitung's variance ratio is that, in contrast to
the Dickey-Fuller test and other related tests, it is a nonparametric
statistic.  In simulations, it seems to perform favorably with respect
to the Hurst exponent.
</p>
<p>Simulation has been used to determine the distribution of the statistic,
and table lookup is used to determine p-values.
</p>
<p>If <code>detrend=TRUE</code>, then a linear trend is removed from the data
prior to computing the estimator <code class="reqn">\rho_{T}</code>.  A separate table has been
computed of the distribution of values of <code class="reqn">\rho_{T}</code> after detrending.
</p>


<h3>Value</h3>

<p><code>bvr_rho</code> returns the value <code class="reqn">\rho_{T}</code> of Breitung's variance
ratio.
</p>
<p><code>bvr.test</code> returns a list with class <code>"htest"</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the truncation lag parameter.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a></p>


<h3>References</h3>

<p>Breitung, J. (2002). 
Nonparametric tests for unit roots and cointegration. 
<em>Journal of econometrics</em>, 108(2), 343-363.
</p>
<p>Breitung, J. and Taylor, A.M.R. (2003)
Corrigendum to &quot;Nonparametric tests for unit roots and cointegration&quot;
[J. Econom. 108 (2002) 343-363]
<em>Journal of econometrics</em>, 117(2), 401-404.
</p>


<h3>See Also</h3>

<p><code><a href="pracma.html#topic+hurstexp">hurstexp</a></code>
<code><a href="#topic+egcm">egcm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following should produce a low p-value
bvr_rho(rnorm(100))
bvr.test(rnorm(100))

# The following should produce a high p-value
bvr_rho(cumsum(rnorm(100)))
bvr.test(cumsum(rnorm(100)))

# Test with an autoregressive sequence where rho = 0.8
bvr.test(rar1(100, a1=0.8))

# If there is a linear trend, bvr.test with detrend=FALSE
# is likely to find a unit root when there is none:
bvr.test(1:100 + rnorm(100))
bvr.test(1:100 + rnorm(100), detrend=TRUE)

# Display the power of the test for various values of rho and n:
bvr_power(a1=0.8, n=100, nrep=100)
bvr_power(a1=0.9, n=250, nrep=100)
bvr_power(a1=0.95, n=250, nrep=100)

# This is to be compared to the power of the adf.test at this level:
adf_power(a1=0.8, n=100, nrep=100)
adf_power(a1=0.9, n=250, nrep=100)
adf_power(a1=0.95, n=250, nrep=100)
</code></pre>

<hr>
<h2 id='detrend'>
Remove a linear trend from a vector
</h2><span id='topic+detrend'></span>

<h3>Description</h3>

<p>Given a numeric vector <code>Y</code>, removes a linear trend from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend(Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detrend_+3A_y">Y</code></td>
<td>
<p>numeric vector to be de-trended</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector <code>X</code> where <code>X[i] = Y[i] - a - b * i</code>,
where <code>a</code> and <code>b</code> describe the linear trend in Y.
</p>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>detrend(rep(1,10))  # == 0 0 0 0 0 0 0 0 0 0
detrend(1:10)       # == 0 0 0 0 0 0 0 0 0 0
detrend((1:10)^2)   # == 12  4 -2 -6 -8 -8 -6 -2  4 12

mean(detrend(rnorm(1:100) + 1:100))  # should be very close to 0
sd(rnorm(1:100) + 1:100)             # approximately 29
sd(detrend(rnorm(1:100) + 1:100))    # approximately 1
</code></pre>

<hr>
<h2 id='egcm'>Simplified Engle-Granger Cointegration Model</h2><span id='topic+egcm'></span><span id='topic+plot.egcm'></span><span id='topic+summary.egcm'></span><span id='topic+is.cointegrated'></span><span id='topic+is.ar1'></span>

<h3>Description</h3>

<p>Performs the two-step Engle Granger cointegration procedure on a pair of time
series, and creates an object representing the results of the analysis.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egcm(X, Y, na.action, log = FALSE, normalize = FALSE, 
  debias = TRUE, robust=FALSE, include.const=TRUE,
  i1test = egcm.default.i1test(), 
  urtest = egcm.default.urtest(), 
  p.value = egcm.default.pvalue())

is.cointegrated(E)
is.ar1(E)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="egcm_+3A_x">X</code></td>
<td>

<p>the first time series to be considered in the cointegration test.
A plain or <code><a href="zoo.html#topic+zoo">zoo</a></code> vector.  Alternatively, a two-column 
matrix or data.frame, in which case <code>Y</code> should be omitted.
</p>
</td></tr>
<tr><td><code id="egcm_+3A_y">Y</code></td>
<td>

<p>the second time series to be considered in the cointegration test.
A plain or <code><a href="zoo.html#topic+zoo">zoo</a></code> vector.
</p>
</td></tr>
<tr><td><code id="egcm_+3A_e">E</code></td>
<td>

<p>an object of class <code>"egcm"</code> returned from a previous call to <code>egcm</code>
</p>
</td></tr>
<tr><td><code id="egcm_+3A_na.action">na.action</code></td>
<td>

<p>a function that indicates what should happen when the data contain NAs.
See <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
</td></tr>
<tr><td><code id="egcm_+3A_log">log</code></td>
<td>

<p>a boolean value which if <code>TRUE</code>, indicates that the model should be
fit to the logs of the input vectors <code>X</code> and <code>Y</code>.  Default: FALSE.
</p>
</td></tr>
<tr><td><code id="egcm_+3A_normalize">normalize</code></td>
<td>

<p>a boolean value which if <code>TRUE</code>, indicates that each series should be 
normalized to start at 1.  This is performed by dividing the series
by its first element.  Default: FALSE.
</p>
</td></tr>
<tr><td><code id="egcm_+3A_debias">debias</code></td>
<td>

<p>a boolean value which if <code>TRUE</code>, indicates that the value of <code class="reqn">rho</code>
that is reported should be debiased.  Default: TRUE.
</p>
</td></tr>
<tr><td><code id="egcm_+3A_robust">robust</code></td>
<td>

<p>a boolean value which if <code>TRUE</code>, indicates that the two-step
Engle-Granger procedure should be performed using a robust linear
model rather than a standard linear model.  See <code><a href="MASS.html#topic+rlm">rlm</a></code>.
Default: FALSE.
</p>
</td></tr>
<tr><td><code id="egcm_+3A_include.const">include.const</code></td>
<td>

<p>a boolean which if <code>TRUE</code>, indicates that the constant term <code class="reqn">alpha</code>
should be included in the model.  Otherwise, sets <code class="reqn">alpha=0</code>.
Default:  TRUE.
</p>
</td></tr>
<tr><td><code id="egcm_+3A_i1test">i1test</code></td>
<td>

<p>a mnemonic indicating the name of the test that should be used for
checking if the input series <code>X</code> and <code>Y</code> are integrated.  
If none is specified, then defaults to the value reported by
<code>egcm.default.i1test()</code>.  The installation default is <code>"pp"</code>.
The following tests are supported:
</p>

<ul>
<li> <p><code>"adf"</code> Augmented Dickey-Fuller test (see <code><a href="tseries.html#topic+adf.test">adf.test</a></code>)
</p>
</li>
<li> <p><code>"pp"</code>  Phillips-Perron test (see <code><a href="tseries.html#topic+pp.test">pp.test</a></code>)
</p>
</li>
<li> <p><code>"pgff"</code> Pantula, Gonzales-Farias and Fuller weighted
symmetric estimate (see <code><a href="#topic+pgff.test">pgff.test</a></code>)
</p>
</li>
<li> <p><code>"bvr"</code> Breitung's variance ratio (see <code><a href="#topic+bvr.test">bvr.test</a></code>)
</p>
</li></ul>

</td></tr>
<tr><td><code id="egcm_+3A_urtest">urtest</code></td>
<td>

<p>a mnemonic indicating the name of the test that should be used for
checking if the residual series contains a unit root.  If none is
specified, then defaults to the value reported by 
<code>egcm.default.urtest()</code>.  The installation default is <code>"pp"</code>.
The following tests are supported:
</p>

<ul>
<li> <p><code>"adf"</code> Augmented Dickey-Fuller test (see <code><a href="tseries.html#topic+adf.test">adf.test</a></code>)
</p>
</li>
<li> <p><code>"pp"</code>  Phillips-Perron test (see <code><a href="tseries.html#topic+pp.test">pp.test</a></code>)
</p>
</li>
<li> <p><code>"pgff"</code> Pantula, Gonzales-Farias and Fuller weighted
symmetric estimate (see <code><a href="#topic+pgff.test">pgff.test</a></code>)
</p>
</li>
<li> <p><code>"bvr"</code> Breitung's variance ratio (see <code><a href="#topic+bvr.test">bvr.test</a></code>)
</p>
</li>
<li> <p><code>"jo-e"</code> Johansen's eigenvalue test (see <code><a href="urca.html#topic+ca.jo">ca.jo</a></code>)
</p>
</li>
<li> <p><code>"jo-t"</code> Johansen's trace test (see <code><a href="urca.html#topic+ca.jo">ca.jo</a></code>)
</p>
</li>
<li> <p><code>"ers-p"</code> Elliott, Rothenberg and Stock point optimal test
(see <code><a href="urca.html#topic+ur.ers">ur.ers</a></code>)
</p>
</li>
<li> <p><code>"ers-d"</code> Elliott, Rothenberg and Stock DF-GLS test
(see <code><a href="urca.html#topic+ur.ers">ur.ers</a></code>)
</p>
</li>
<li> <p><code>"sp-r"</code> Schmidt and Phillips rho statistic
(see <code><a href="urca.html#topic+ur.sp">ur.sp</a></code>)
</p>
</li>
<li> <p><code>"hurst"</code> Hurst exponent calculated using the
corrected empirical method (see <code><a href="pracma.html#topic+hurstexp">hurstexp</a></code>)
</p>
</li></ul>
 
</td></tr> 
<tr><td><code id="egcm_+3A_p.value">p.value</code></td>
<td>
<p>the p-value to be used in the above tests.
If none is specified, then defaults to the value reported
by <code>egcm.default.pvalue()</code>.  The installation default is 0.05.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two-step Engle Granger procedure searches for parameters
<code class="reqn">\alpha</code>, <code class="reqn">\beta</code>, and <code class="reqn">\rho</code> that yield the best
fit to the following model:
</p>
<p style="text-align: center;"><code class="reqn">Y[i] = \alpha + \beta * X[i] + R[i]</code>
</p>

<p style="text-align: center;"><code class="reqn">R[i] = \rho * R[i-1] + \epsilon[i]</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon[i] \sim N(0, \sigma^2)</code>
</p>

<p>In the first step, <code class="reqn">alpha</code> and <code class="reqn">beta</code> are found using
a linear fit of <code>X[i]</code> with respect to <code>Y[i]</code>.  The 
residual sequence <code>R[i]</code> is then determined.
Then, in the second step, <code class="reqn">\rho</code> is determined, again using
a linear fit.  
</p>
<p>Engle and Granger showed that if <code class="reqn">X</code> and <code class="reqn">Y</code> are cointegrated,
then this procedure will yield consistent estimates of the parameters.
However, there are several ways in which this estimation procedure
can fail:
</p>

<ul>
<li><p> Either <code>X</code> or <code>Y</code> (or both) may already be
mean-reverting.  In this case, there is no point in forming
the difference <code class="reqn">Y - \beta X</code>.  If one series is mean-reverting
and the other is not, then any non-trivial linear combination will
not be mean-reverting.
</p>
</li>
<li><p> The residual series <code>R[i]</code> may not be mean-reverting.
In the language of cointegration theory, it is then said to
contain a unit root.  In this case, there is no benefit to
forming the linear combination <code class="reqn">Y - \beta X</code>.
</p>
</li>
<li><p> The residual series <code>R[i]</code> may be mean-reverting, but
the relation <code class="reqn">R[i] = \rho R[i-1] + \epsilon[i]</code> may not be
the right model.  In other words, the residual series
may not be adequately described by an auto-regressive
series of order one.  In this case, the parameters <code class="reqn">\alpha</code>
and <code class="reqn">\beta</code> will be correct, however the specification for
the residuals <code>R[i]</code> will not be.  The user may wish to try
fitting the residuals using another function, such as <code><a href="stats.html#topic+arima">arima</a></code>.
</p>
</li></ul>

<p>The <code>egcm</code> function checks for each of the above contingencies,
using an appropriate statistical test.
If one of the above conditions is found, then a warning message is
displayed when the model is printed.
</p>
<p>The p-value used in the above tests is given by the
parameter <code>p.value</code>.  This can be changed by setting the value
of the parameter, or by changing the default value with
<code><a href="#topic+egcm.set.default.pvalue">egcm.set.default.pvalue</a></code>.  For all of the unit root
tests, the p-values of the corresponding test statistics have been
recomputed through simulation and a table lookup is used.  The
Ljung-Box test (see <code><a href="stats.html#topic+Box.test">Box.test</a></code>) is used to assess whether
or not the residual series can be adequately fit with an autoregressive
series of order one.
</p>
<p>The estimates of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are not only
consistent but also unbiased.  Unfortunately, the estimate obtained
for <code class="reqn">\rho</code> may be biased.  Therefore, a bias correction has been
implemented for <code class="reqn">\rho</code>.  A pre-computed table of biases has been
determined through simulation, and a table lookup is performed to
determine the appropriate bias correction.  To turn off this
feature, set <code>debias = FALSE</code>.
</p>
<p>The helper function <code>is.cointegrated()</code> takes as input an <code>"egcm"</code>
object <code>E</code>.  It returns TRUE if <code>E</code>
appears to represent a valid pair of cointegrated series.  In other words, it checks that both <code>X</code> and <code>Y</code> are
integrated and that the residual series <code>R</code> is free of unit roots.
The helper function <code>is.ar1()</code> also takes as input an <code>"egcm"</code>
object <code>E</code>.  It returns TRUE if the
residual series <code>R</code> can be adequately fit by an autoregressive model
of order one.  
</p>
<p>From the standpoint of securities trading, cointegration is thought
to provide a useful model for pairs trading.  If the price series of
two securities are cointegrated, then the corresponding residual
series <code>R[i]</code> will be mean-reverting.  When the magnitude of the residual
<code>R[N]</code> is large, a trader might establish a long position in the
undervalued security and a short position in the overvalued security.
With high probability, the positions will converge in value, and a
profit can be collected.  Numerous scholarly articles and several
books have been written on pairs trading.
</p>
<p>Data mining for cointegrated pairs is not recommended, though.
As with any statistical test, the cointegration test will generate
false positives.  Experience shows that at least in the case of the
components of the S&amp;P 500, the number of false positives overwhelms
the number of truly cointegrated series.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>"egcm"</code>.  This can then be
<code>print</code>ed or <code>plot</code>ted.  There is also a <code>summary</code> method.
</p>
<p>The following is a copy of the printed output that was obtained from 
running the first example below:
</p>
<pre>
VOO[i] =   0.9201 SPY[i] -   0.6845 + R[i], 
          (0.0005)          (0.0845)     
R[i] =  -0.0004 R[i-1] + eps[i], eps ~ N(0,  0.0779^2)
        (0.0633)
R[2013-12-31] = -0.0987 (t = -1.265)</pre>
<p>The first line of the output shows the fit that was found.  
The parameters were determined to be <code class="reqn">\beta = 0.9201</code>,
<code class="reqn">\alpha = -0.6845</code> and <code class="reqn">\rho = -0.0004</code>.  The standard
deviation of the sequence <code class="reqn">\epsilon</code> of innovations was
found to be <code class="reqn">0.0779</code>.  The standard errors of <code class="reqn">\alpha</code>,
<code class="reqn">\beta</code> and <code class="reqn">\rho</code> were found to be <code class="reqn">0.0845</code>,
<code class="reqn">0.0005</code> and <code class="reqn">0.0633</code> respectively.
</p>
<p>The third line of output shows the value of the residual as
of the last observation in the series.  The sign of the value
<code class="reqn">-0.0987</code> indicates that <code>VOO</code> was relatively undervalued
on this date and that the difference between the two series was
<code class="reqn">-1.265</code> standard deviations from their historical mean.
<br />
<br />
</p>
<p>The fields of the <code>"egcm"</code> object are as follows:
</p>
<table role = "presentation">
<tr><td><code>S1</code></td>
<td>
<p>the first data series (<code>X[i]</code>)</p>
</td></tr>
<tr><td><code>S2</code></td>
<td>
<p>the second data series (<code>Y[i]</code>)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residual series (<code>R[i]</code>)</p>
</td></tr>
<tr><td><code>innovations</code></td>
<td>
<p>the sequence of innovations (<code class="reqn">\epsilon</code><code>[i]</code>)</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>the index vector for the series</p>
</td></tr>
<tr><td><code>i1test</code></td>
<td>
<p>the name of the test used for verifying
that <code>X</code> and <code>Y</code> are integrated</p>
</td></tr>
<tr><td><code>urtest</code></td>
<td>
<p>the name of the test used for
verifying that the residual series does not contain
a unit root</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>the p-value that is used for the various tests used
by this model</p>
</td></tr>
<tr><td><code>log</code></td>
<td>
<p>Boolean, which if true indicates that S1 and S2 are logged</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the computed value of <code class="reqn">\alpha</code></p>
</td></tr>
<tr><td><code>alpha.se</code></td>
<td>
<p>standard error of the estimate of <code class="reqn">\alpha</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the computed value of <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code>beta.se</code></td>
<td>
<p>standard error of the estimate of <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>the computed and debiased value of <code class="reqn">\rho</code></p>
</td></tr>
<tr><td><code>rho.raw</code></td>
<td>
<p>the value of <code class="reqn">\rho</code> determined prior to debiasing</p>
</td></tr>
<tr><td><code>rho.se</code></td>
<td>
<p>standard error of the estimate of <code class="reqn">\rho</code></p>
</td></tr>
<tr><td><code>s1.i1.stat</code></td>
<td>
<p>test statistic found when checking that S1 is integrated</p>
</td></tr>
<tr><td><code>s1.i1.p</code></td>
<td>
<p>p-value associated to <code>s1.i1.stat</code></p>
</td></tr>
<tr><td><code>s2.i1.stat</code></td>
<td>
<p>test statistic found when checking that S2 is integrated</p>
</td></tr>
<tr><td><code>s2.i1.p</code></td>
<td>
<p>p-value associated to <code>s2.i1.stat</code></p>
</td></tr>
<tr><td><code>r.stat</code></td>
<td>
<p>test statistic found when checking whether the residual series
contains a unit root</p>
</td></tr>
<tr><td><code>r.p</code></td>
<td>
<p>p-value associated to <code>r.stat</code></p>
</td></tr>
<tr><td><code>eps.ljungbox.stat</code></td>
<td>
<p>test statistic found when checking whether an
AR(1) model adequately fits the residual series</p>
</td></tr>
<tr><td><code>eps.ljungbox.p</code></td>
<td>
<p>p-value associated to <code>eps.ljungbox.stat</code></p>
</td></tr>
<tr><td><code>s1.dsd</code></td>
<td>
<p>standard deviation of <code>diff(S1)</code></p>
</td></tr>
<tr><td><code>s2.dsd</code></td>
<td>
<p>standard deviation of <code>diff(S2)</code></p>
</td></tr>
<tr><td><code>r.sd</code></td>
<td>
<p>standard deviation of <code>residuals</code></p>
</td></tr>
<tr><td><code>eps.sd</code></td>
<td>
<p>standard deviation of the innovations <code class="reqn">\epsilon[i]</code></p>
</td></tr>
</table>


<h3>Disclaimer</h3>

<p>The software in this package is for general information purposes
only. It is hoped that it will be useful, but it is provided WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. It is not intended to form the basis of any investment
decision. USE AT YOUR OWN RISK!
</p>


<h3>Note</h3>

<p>Cointegration is a more general concept than has been presented here.
Users who wish to explore more general models for cointegration are
referred to the <code><a href="urca.html#topic+ca.jo">urca</a></code> package of Bernard Pfaff.
</p>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>References</h3>

<p>Chan, E. (2013). 
<em>Algorithmic trading: winning strategies and their rationale</em>.
(Vol. 625). John Wiley &amp; Sons.
</p>
<p>Clegg, M. (2014). On the Persistence of Cointegration in Pairs Trading (January 28, 2014). 
Available at SSRN:  http://ssrn.com/abstract=2491201
</p>
<p>Ehrman, D.S. (2006).
<em>The handbook of pairs trading: strategies using equities, options, 
and futures</em>. 
(Vol. 240). John Wiley &amp; Sons.
</p>
<p>Engle, R. F. and C. W. Granger.  (1987)
Co-integration and error correction: representation, estimation, and testing.
<em>Econometrica</em>, 251-276.
</p>
<p>Pfaff, B. (2008) 
<em>Analysis of Integrated and Cointegrated Time Series with R. Second Edition</em>. 
Springer, New York. ISBN 0-387-27960-1
</p>
<p>Vidyamurthy, G.  (2004).
<em>Pairs trading: quantitative methods and analysis</em>.
(Vol 217).  Wiley.com.
</p>


<h3>See Also</h3>

<p><a href="#topic+yegcm">yegcm</a>
<a href="#topic+egcm.default.i1test">egcm.default.i1test</a>
<a href="#topic+egcm.default.urtest">egcm.default.urtest</a>
<a href="#topic+egcm.default.pvalue">egcm.default.pvalue</a>
<a href="#topic+sim.egcm">sim.egcm</a>
<a href="#topic+pgff.test">pgff.test</a>
<a href="#topic+bvr.test">bvr.test</a>
<a href="urca.html#topic+ca.jo">ca.jo</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(quantmod)

# SPY and IVV are both ETF's that track the S&amp;P 500.
# One would expect them to be cointegrated, and in 2013 they were.
spy2013 &lt;- getSymbols("SPY", from = "2013-01-01",
          to = "2013-12-31",auto.assign = FALSE)$SPY.Adjusted
ivv2013 &lt;- getSymbols("IVV", from = "2013-01-01", 
         to = "2013-12-31",auto.assign = FALSE)$IVV.Adjusted
egcm(spy2013, ivv2013)

# egcm has a plot method, which can be useful
# In this plot, it appears that there is only one price series,
# but that is because the two price series are so close to each
# other that they are indistinguishable.
plot(egcm(spy2013, ivv2013))

# The yegcm method provides a convenient interface to the quantmod
# package, which can fetch closing prices from Yahoo.  Thus, 
# the above can be simplified as follows:

e &lt;- yegcm("SPY", "VOO", start="2013-01-01", end="2014-01-01")
print(e)
plot(e)
summary(e)

# GLD and IAU both track the price of gold.  
# They too tend to be very tightly cointegrated.
gld.iau.2013 &lt;- yegcm("GLD", "IAU", start="2013-01-01", end="2013-12-31")
gld.iau.2013
plot(gld.iau.2013)

# Coca-cola and Pepsi are often mentioned as an
# example of a pair of securities for which pairs trading
# may be fruitful.  However, at least in 2013, they were not
# cointegrated.
ko.pep.2013 &lt;- yegcm("KO", "PEP", start="2013-01-01", end="2013-12-31")
ko.pep.2013
plot(ko.pep.2013)

# Ford and GM seemed to be even more tightly linked.
# Yet, the degree of linkage was not high enough to pass the
# cointegration test.
f.gm.2013 &lt;- yegcm("F","GM", start="2013-01-01", end="2013-12-31")
f.gm.2013
plot(f.gm.2013)

## End(Not run)</code></pre>

<hr>
<h2 id='egcm.defaults'>
Set and get defaults for Engle-Granger cointegration models
</h2><span id='topic+egcm.set.default.i1test'></span><span id='topic+egcm.set.default.urtest'></span><span id='topic+egcm.set.default.pvalue'></span><span id='topic+egcm.default.i1test'></span><span id='topic+egcm.default.urtest'></span><span id='topic+egcm.default.pvalue'></span><span id='topic+egcm.i1tests'></span><span id='topic+egcm.urtests'></span>

<h3>Description</h3>

<p>Set and get defaults for Engle-Granger cointegration models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egcm.set.default.i1test(i1test)
egcm.default.i1test()
egcm.i1tests()

egcm.set.default.urtest(urtest)
egcm.default.urtest()
egcm.urtests()

egcm.set.default.pvalue(p)
egcm.default.pvalue()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="egcm.defaults_+3A_i1test">i1test</code></td>
<td>

<p>a mnemonic indicating the name of the test that should be used for
checking if the input series are integrated.  
The following tests are supported:
</p>

<ul>
<li> <p><code>"adf"</code> Augmented Dickey-Fuller test (see <code><a href="tseries.html#topic+adf.test">adf.test</a></code>)
</p>
</li>
<li> <p><code>"pp"</code>  Phillips-Perron test (see <code><a href="tseries.html#topic+pp.test">pp.test</a></code>)
</p>
</li>
<li> <p><code>"pgff"</code> Pantula, Gonzales-Farias and Fuller weighted
symmetric estimate (see <code><a href="#topic+pgff.test">pgff.test</a></code>)
</p>
</li>
<li> <p><code>"bvr"</code> Breitung's variance ratio (see <code><a href="#topic+bvr.test">bvr.test</a></code>)
</p>
</li></ul>

</td></tr>
<tr><td><code id="egcm.defaults_+3A_urtest">urtest</code></td>
<td>

<p>a mnemonic indicating the name of the test that should be used for
checking if the residual series contains a unit root.  
The following tests are supported:
</p>

<ul>
<li> <p><code>"adf"</code> Augmented Dickey-Fuller test (see <code><a href="tseries.html#topic+adf.test">adf.test</a></code>)
</p>
</li>
<li> <p><code>"pp"</code>  Phillips-Perron test (see <code><a href="tseries.html#topic+pp.test">pp.test</a></code>)
</p>
</li>
<li> <p><code>"pgff"</code> Pantula, Gonzales-Farias and Fuller weighted
symmetric estimate (see <code><a href="#topic+pgff.test">pgff.test</a></code>)
</p>
</li>
<li> <p><code>"bvr"</code> Breitung's variance ratio (see <code><a href="#topic+bvr.test">bvr.test</a></code>)
</p>
</li>
<li> <p><code>"jo-e"</code> Johansen's eigenvalue test (see <code><a href="urca.html#topic+ca.jo">ca.jo</a></code>)
</p>
</li>
<li> <p><code>"jo-t"</code> Johansen's trace test (see <code><a href="urca.html#topic+ca.jo">ca.jo</a></code>)
</p>
</li>
<li> <p><code>"ers-p"</code> Elliott, Rothenberg and Stock point optimal test
(see <code><a href="urca.html#topic+ur.ers">ur.ers</a></code>)
</p>
</li>
<li> <p><code>"ers-d"</code> Elliott, Rothenberg and Stock DF-GLS test
(see <code><a href="urca.html#topic+ur.ers">ur.ers</a></code>)
</p>
</li>
<li> <p><code>"sp-r"</code> Schmidt and Phillips rho statistic
(see <code><a href="urca.html#topic+ur.sp">ur.sp</a></code>)
</p>
</li>
<li> <p><code>"hurst"</code> Hurst exponent calculated using the
corrected empirical method (see <code><a href="pracma.html#topic+hurstexp">hurstexp</a></code>)
</p>
</li></ul>
 
</td></tr> 
<tr><td><code id="egcm.defaults_+3A_p">p</code></td>
<td>

<p>the p-value should be used for rejecting the null hypothesis in
the various statistical tests conducted by <code><a href="#topic+egcm">egcm</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>egcm.default.i1test</code>, returns the string representing the
currently selected default I(1) test.  For <code>egcm.i1tests</code>,
returns a list of all available I(1) tests.
</p>
<p>For <code>egcm.default.urtest</code>, returns the string represeting the
currently selected unit root test.  For <code>egcm.urtests</code>,
returns a list of all available unit root tests.
</p>
<p>For <code>egcm.default.pvalue</code>, returns the default p-value that
will be used for rejecting the null hypothesis in the various
statistical tests conducted by <code><a href="#topic+egcm">egcm</a></code>.
</p>
<p>The setter functions do not return a value.  
</p>


<h3>Note</h3>

<p>Changing the default value only affects <code>egcm</code> objects created
after the change is made. 
</p>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+egcm">egcm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get and set the current default I(1) test
egcm.default.i1test()
egcm.set.default.i1test("adf")

# Get and set the current default unit root test
egcm.default.urtest()
egcm.set.default.urtest("pp")

# Get and set the current default p-value
egcm.default.pvalue()
egcm.set.default.pvalue(0.01)
</code></pre>

<hr>
<h2 id='pgff.test'>
Unit root test of Pantula, Gonzales-Farias and Fuller
</h2><span id='topic+pgff.test'></span><span id='topic+pgff_rho_ws'></span>

<h3>Description</h3>

<p>Unit root test based upon the weighted symmetric estimator of
Pantula, Gonzales-Farias and Fuller
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgff.test(Y, detrend = FALSE)
pgff_rho_ws(Y, detrend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pgff.test_+3A_y">Y</code></td>
<td>
<p>A vector or zoo-vector</p>
</td></tr>
<tr><td><code id="pgff.test_+3A_detrend">detrend</code></td>
<td>
<p>A boolean, which if TRUE, indicates that the test should
be performed after removing a linear trend from <code>Y</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weighted symmetric estimator <code class="reqn">\rho_{WS}</code> of Pantula, 
Gonzales-Farias and Fuller is given as follows:
</p>
<p style="text-align: center;"><code class="reqn">\hat{\rho}_{WS}=\frac{\sum_{t=2}^n Y_{t-1} Y_t}{%
  \sum_{t=2}^{n-1} Y_t^2 + n^{-1} \sum_{t=1}^n Y_t^2}</code>
</p>

<p>where <code class="reqn">n</code> is the length of the sequence <code>Y</code>.
</p>
<p>The authors give an associated pivotal statistic and derive the limiting distribution for it, however the approach taken in this implementation was
simply to determine the distribution of <code class="reqn">\rho_{WS}</code> through simulation.
Table lookup is used to determine the p-value associated with a given
value of the statistic.
</p>
<p>If <code>detrend=TRUE</code>, then a linear trend is removed from the data
prior to computing the estimator <code class="reqn">\rho_{WS}</code>.  A separate table has been
computed of the distribution of values of <code class="reqn">\rho_{WS}</code> after detrending.
</p>
<p>This unit root test is intended to identify autoregressive sequences
of order one.  However, the authors state that, 
&quot;A Monte Carlo study indicates that the weighted symmetric estimator
performs well in second order processes.&quot;
</p>


<h3>Value</h3>

<p><code>pgff_rho_ws</code> returns the value <code class="reqn">\rho_{WS}</code> of the weighted
symmetric estimator.
</p>
<p><code>pgff.test</code> returns a list with class <code>"htest"</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the truncation lag parameter.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>References</h3>

<p>Pantula, S. G., Gonzalez-Farias, G., and Fuller, W. A. (1994).
A comparison of unit-root test criteria.
<em>Journal of Business &amp; Economic Statistics</em>, 12(4), 449-459. 
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+adf.test">adf.test</a></code>
<code><a href="#topic+egcm">egcm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following should produce a low p-value
pgff_rho_ws(rnorm(100))
pgff.test(rnorm(100))

# The following should produce a high p-value
pgff_rho_ws(cumsum(rnorm(100)))
pgff.test(cumsum(rnorm(100)))

# Test with an autoregressive sequence where rho = 0.8
pgff.test(rar1(100, a1=0.8))

# If there is a linear trend, pgff.test with detrend=FALSE
# is likely to find a unit root when there is none:
pgff.test(1:100 + rnorm(100))
pgff.test(1:100 + rnorm(100), detrend=TRUE)

# Display the power of the test for various values of rho and n:
pgff_power(a1=0.8, n=100, nrep=100)
pgff_power(a1=0.9, n=250, nrep=100)
pgff_power(a1=0.95, n=250, nrep=100)

# This is to be compared to the power of the adf.test at this level:
adf_power(a1=0.8, n=100, nrep=100)
adf_power(a1=0.9, n=250, nrep=100)
adf_power(a1=0.95, n=250, nrep=100)
</code></pre>

<hr>
<h2 id='rar1'>Random AR(1) vector</h2><span id='topic+rar1'></span>

<h3>Description</h3>

<p>Generates a random realization of an AR(1) sequence</p>


<h3>Usage</h3>

<pre><code class='language-R'>rar1(n, a0 = 0, a1 = 1, trend = 0, sd = 1, x0 = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rar1_+3A_n">n</code></td>
<td>
<p>Length of vector to produce</p>
</td></tr>
<tr><td><code id="rar1_+3A_a0">a0</code></td>
<td>
<p>Constant term in AR(1) sequence</p>
</td></tr>
<tr><td><code id="rar1_+3A_a1">a1</code></td>
<td>
<p>Coefficient of mean-reversion</p>
</td></tr>
<tr><td><code id="rar1_+3A_trend">trend</code></td>
<td>
<p>Linear trend</p>
</td></tr>
<tr><td><code id="rar1_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of sequence of innovations</p>
</td></tr>
<tr><td><code id="rar1_+3A_x0">x0</code></td>
<td>
<p>Starting value of sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>trend=0</code>, returns a vector of length <code>n</code> representing 
a simulation of an AR(1) process   
</p>
<p style="text-align: center;"><code class="reqn">X[k] = a_0 +  a_1 * X[k-1] + \epsilon[t]</code>
</p>

<p>where <code class="reqn">\epsilon[t]</code> is a sequence of independent and identically 
distributed samples from a normal distribution with mean zero and
standard deviation <code>sd</code>.
</p>
<p>If <code>trend != 0</code>, returns a vector of length <code>n</code> representing
a simulation of a trend-stationary AR(1) process
</p>
<p style="text-align: center;"><code class="reqn">R[k] = a_0 +  a_1 * R[k-1] + \epsilon[t]</code>
</p>

<p style="text-align: center;"><code class="reqn">X[k] = k * trend + R[k]</code>
</p>



<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcoint">rcoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rar1(100, 0, 0)          # Equivalent to rnorm(100)
rar1(100, 0, 1)          # Equivalent to cumsum(rnorm(100))
acor(rar1(100, 1, .5))   # Should be about 0.5
tseries::adf.test(rar1(100, 0, .5))  # Should have a low p-value
</code></pre>

<hr>
<h2 id='rcoint'>Random generation of cointegrated sequences</h2><span id='topic+rcoint'></span>

<h3>Description</h3>

<p>Generates a random pair of cointegrated sequences</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcoint(n, 
  alpha = runif(1, -10, 10), 
  beta = runif(1, -10, 10), 
  rho = runif(1, 0, 1), 
  sd_eps = 1, 
  sd_delta = 1,
  X0=0,
  Y0=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcoint_+3A_n">n</code></td>
<td>
<p>number of observations in each sequence</p>
</td></tr>
<tr><td><code id="rcoint_+3A_alpha">alpha</code></td>
<td>
<p>constant term of linear relation</p>
</td></tr>
<tr><td><code id="rcoint_+3A_beta">beta</code></td>
<td>
<p>slope term of linear relation</p>
</td></tr>
<tr><td><code id="rcoint_+3A_rho">rho</code></td>
<td>
<p>coefficient of mean reversion</p>
</td></tr>
<tr><td><code id="rcoint_+3A_sd_eps">sd_eps</code></td>
<td>
<p>standard deviation of innovations in first sequence</p>
</td></tr>
<tr><td><code id="rcoint_+3A_sd_delta">sd_delta</code></td>
<td>
<p>standard deviation of innovations in residual sequence</p>
</td></tr>
<tr><td><code id="rcoint_+3A_x0">X0</code></td>
<td>
<p>initial value of first sequence</p>
</td></tr>
<tr><td><code id="rcoint_+3A_y0">Y0</code></td>
<td>
<p>initial value of second sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a random pair of cointegrated sequences.  The sequences are constructed
by first generating two random sequences that are independent and normally distributed.  
The elements of the first sequence, <code class="reqn">\epsilon[i]</code>, 
have standard deviation <code>sd_eps</code>,
while those of the second sequence, <code class="reqn">\delta[i]</code>, 
have standard deviation <code>sd_delta</code>.
Having generated these two sequences, the cointegrated sequences <code>X[i]</code> and
<code>Y[i]</code> are generated according to the following relations:
</p>
<p style="text-align: center;"><code class="reqn">X[i] = X[i-1] + \epsilon[i]</code>
</p>

<p style="text-align: center;"><code class="reqn">R[i] = \rho R[i-1] + \delta[i]</code>
</p>

<p style="text-align: center;"><code class="reqn">Y[i] = \alpha + \beta X[i] + R[i]</code>
</p>



<h3>Value</h3>

<p>Returns a two-column data.frame containing the randomly generated
cointegrated sequences.
</p>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rar1">rar1</a></code>
<code><a href="#topic+sim.egcm">sim.egcm</a></code>
<code><a href="#topic+egcm">egcm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy &lt;- rcoint(1000, alpha = 1, beta = 2, rho = 0.8)
egcm(xy)
</code></pre>

<hr>
<h2 id='sim.egcm'>
Generate simulated data from an Engle-Granger cointegration model
</h2><span id='topic+sim.egcm'></span>

<h3>Description</h3>

<p>Given an Engle-Granger cointegration model and the number of steps 
to simulate, generates a simulated realization of that model for 
the specified number of steps.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.egcm(E, nsteps, X0, Y0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.egcm_+3A_e">E</code></td>
<td>

<p>the Engle-Granger model to be simulated.  See <code><a href="#topic+egcm">egcm</a></code>
</p>
</td></tr>
<tr><td><code id="sim.egcm_+3A_nsteps">nsteps</code></td>
<td>

<p>the number of steps to simulate
</p>
</td></tr>
<tr><td><code id="sim.egcm_+3A_x0">X0</code></td>
<td>

<p>the starting value of <code>X</code> to be used in the simulation.
If not specified, uses the last value of <code>X</code> in <code>E</code>.
</p>
</td></tr>
<tr><td><code id="sim.egcm_+3A_y0">Y0</code></td>
<td>

<p>the starting value of <code>Y</code> to be used in the simulation.
If not specified, uses the last value of <code>Y</code> in <code>E</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a two-column data.frame, where the first column contains the simulated values of <code>X</code>, and the second column contains the simulated
values of <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+egcm">egcm</a></code>
<code><a href="#topic+rcoint">rcoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random pair of cointegrated vectors
cv1 &lt;- rcoint(1000)
# Construct a cointegration model from them
e1 &lt;- egcm(cv1)
# Simulate the model for an additional 1000 steps
cv2 &lt;- sim.egcm(e1, 1000)
# Construct a cointegration model from the simulated data
e2 &lt;- egcm(cv2)
# Compare the original model to the model obtained from simulation
e1
e2
</code></pre>

<hr>
<h2 id='ur_power'>Power assessment for unit root tests</h2><span id='topic+ur_power'></span><span id='topic+adf_power'></span><span id='topic+bvr_power'></span><span id='topic+pgff_power'></span><span id='topic+ur_power_table'></span><span id='topic+adf_power_table'></span><span id='topic+bvr_power_table'></span><span id='topic+pgff_power_table'></span>

<h3>Description</h3>

<p>A collection of functions designed to assist in determining
the power of various unit root tests</p>


<h3>Usage</h3>

<pre><code class='language-R'>ur_power (ur_test, a0 = 0, a1 = 0.95, trend=0, n = 250, 
    nrep = 10000, p.value = 0.05, ...)
adf_power (a0=0, a1=0.95, trend=0, n=250, 
    nrep=10000, p.value=0.05, k=1)
bvr_power (a0=0, a1=0.95, trend=0, n=250, 
    nrep=10000, p.value=0.05, detrend=FALSE)
pgff_power (a0=0, a1=0.95, trend=0, n=250, 
    nrep=10000, p.value=0.05, detrend=FALSE)

ur_power_table (ur_test, nrep=1000, p.value=0.05,
    a1=c(0.995, 0.99, 0.98, 0.97, 0.96, 0.95),
    trend=0,
    n=c(100, 250, 500, 750, 1000, 1250),
    ...)
adf_power_table (nrep=1000, p.value=0.05,
    a1=c(0.995, 0.99, 0.98, 0.97, 0.96, 0.95),
    trend=0,
    n=c(250, 500, 750, 1000, 1250),
    k=1)
bvr_power_table (nrep=1000, p.value=0.05,
    a1=c(0.995, 0.99, 0.98, 0.97, 0.96, 0.95),
    trend=0,
    n=c(100, 250, 500, 750, 1000, 1250),
    detrend=FALSE)     
pgff_power_table (nrep=1000, p.value=0.05,
    a1=c(0.995, 0.99, 0.98, 0.97, 0.96, 0.95),
    trend=0,
    n=c(100, 250, 500, 750, 1000, 1250),
    detrend=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ur_power_+3A_ur_test">ur_test</code></td>
<td>
<p>A function that performs a unit root test.  It should accept
an argument consisting of a vector of real numbers, and it should return
an object with the p-value stored in the field <code>p.value</code>.  Example
functions that satisfy this criterion include <code><a href="tseries.html#topic+adf.test">adf.test</a></code>,
<code><a href="tseries.html#topic+pp.test">pp.test</a></code>, <code><a href="#topic+pgff.test">pgff.test</a></code> and <code><a href="#topic+bvr.test">bvr.test</a></code>
</p>
</td></tr>
<tr><td><code id="ur_power_+3A_a0">a0</code></td>
<td>

<p>Constant term of AR(1) series
</p>
</td></tr>
<tr><td><code id="ur_power_+3A_a1">a1</code></td>
<td>

<p>Linear term of AR(1) series (e.g. coefficient of mean reversion).  
For the <code>*_power_table</code> variants, this may be a vector of numbers,
representing different values of the linear term that should be tried.
</p>
</td></tr>
<tr><td><code id="ur_power_+3A_trend">trend</code></td>
<td>

<p>Trend parameter.  This may either
be a scalar or it may be a vector of length <code>nrep</code>.  In the latter
case, each replication of the test is performed with a different value
from <code>trend</code>.
</p>
</td></tr>
<tr><td><code id="ur_power_+3A_n">n</code></td>
<td>

<p>Length of AR(1) series.
For the <code>*_power_table</code> variants, this may be a vector of numbers,
representing different sequence lengths that should be tried.
</p>
</td></tr>
<tr><td><code id="ur_power_+3A_nrep">nrep</code></td>
<td>

<p>Number of repetitions to perform
</p>
</td></tr>
<tr><td><code id="ur_power_+3A_p.value">p.value</code></td>
<td>

<p>p-value used as cutoff point for rejecting the null hypothesis
</p>
</td></tr>
<tr><td><code id="ur_power_+3A_detrend">detrend</code></td>
<td>

<p>A boolean which, if TRUE, indicates that linear trends should be
removed from the AR(1) series prior to performing the unit root
test.
</p>
</td></tr>
<tr><td><code id="ur_power_+3A_k">k</code></td>
<td>
<p>Number of lags to consider in Dickey-Fuller test</p>
</td></tr>
<tr><td><code id="ur_power_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the unit root test <code>ur_test</code>.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The purpose of this family of functions is to provide a means for investigating the
power of various unit root tests. The power of a statistical test is the probability
that it will reject the null hypothesis when the null hypothesis is false.
</p>
<p>For unit root tests, a common practice for assessing power is to
randomly generate AR(1) sequences of a fixed length and with a fixed coefficient of
mean reversion, and to quantify the power in terms of these two parameters. 
That is the approach taken here.
</p>
<p>The <code>*_power</code> functions generate <code>nrep</code> random AR(1) sequences
of length <code>n</code> having the parameters <code>a0</code> and <code>a1</code>.  For
each such sequence, the unit root test is performed and a check is made
to see if the null hypothesis is rejected at the level given by
<code>p.value</code>.  The frequency of rejections is then reported.
</p>
<p>The <code>*_power_table</code> functions generate a table of powers for various
choices of <code>n</code> and <code>a1</code>.  These functions can take quite a while
to run.
</p>
<p><code>adf_power</code> and <code>adf_power_table</code> report the power of the
augmented Dickey-Fuller test as implemented in <code><a href="tseries.html#topic+adf.test">adf.test</a></code>.
<code>bvr_power</code> and <code>bvr_power_table</code> report the power of 
Breitung's variance ratio as implemented in <code><a href="#topic+bvr.test">bvr.test</a></code>.
<code>pgff_power</code> and <code>pgff_power_table</code> report the power of
the weighted symmetric estimator of Pantula, Gonzalez-Farias and Fuller
as implemented in <code><a href="#topic+pgff.test">pgff.test</a></code>.
</p>


<h3>Value</h3>

<p>For the <code>*_power</code> functions, returns the frequency of rejections
of the null hypothesis.
</p>
<p>For the <code>*_power_table</code> functions, returns a <code>data.frame</code>.
Each column corresponds to a value of the mean reversion coefficient
given in the vector <code>a1</code>, and each row corresponds to a sample
length given in the vector <code>n</code>.  An entry in the table records
the frequency of rejections of the null hypothesis for the given
sample length and coefficient of mean reversion.
</p>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>References</h3>

<p>Breitung, J. (2002). 
Nonparametric tests for unit roots and cointegration. 
<em>Journal of econometrics</em>, 108(2), 343-363.
</p>
<p>Dickey, D. A., &amp; Fuller, W. A. (1979). 
Distribution of the estimators for autoregressive time series with a unit root.     
<em>Journal of the American statistical association</em>, 74(366a), 427-431.
</p>
<p>Pantula, S. G., Gonzalez-Farias, G., and Fuller, W. A. (1994).
A comparison of unit-root test criteria.
<em>Journal of Business &amp; Economic Statistics</em>, 12(4), 449-459. 
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+adf.test">adf.test</a></code>
<code><a href="tseries.html#topic+pp.test">pp.test</a></code>
<code><a href="#topic+bvr.test">bvr.test</a></code>
<code><a href="#topic+pgff.test">pgff.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following examples may take a long time to run
    
# Compare the power of various unit root tests for specific
# parameter values:
# adf_power(a1=0.9, n=125, p.value=0.1)
# bvr_power(a1=0.9, n=125, p.value=0.1)
# pgff_power(a1=0.9, n=125, p.value=0.1)

# library(tseries)
# ur_power(pp.test, a1=0.9, n=125, p.value=0.1)

# The following illustrates the importance of de-trending
# pgff_power(a1=0.9, n=125, p.value=0.1, trend=10)
# pgff_power(a1=0.9, n=125, p.value=0.1, trend=10, detrend=TRUE)

# Generate tables comparing the powers of various unit root tests:
# adf_power_table()
# bvr_power_table()
# pgff_power_table()
# ur_power_table(pp.test)
</code></pre>

<hr>
<h2 id='yegcm'>
Engle-Granger cointegration model from Yahoo! price series
</h2><span id='topic+yegcm'></span>

<h3>Description</h3>

<p>Fetches the Yahoo! price series for two securities and constructs an 
Engle-Granger cointegration model from them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yegcm(ticker1, 
      ticker2, 
      start = format(Sys.Date() - 365, "%Y-%m-%d"),
      end = format(Sys.Date(), "%Y-%m-%d"),
      clear.na.inf=TRUE,
      ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yegcm_+3A_ticker1">ticker1</code></td>
<td>
<p>the ticker symbol of the first security</p>
</td></tr>
<tr><td><code id="yegcm_+3A_ticker2">ticker2</code></td>
<td>
<p>the ticker symbol of the second security</p>
</td></tr>
<tr><td><code id="yegcm_+3A_start">start</code></td>
<td>
<p>starting date, given in the format &quot;YYYY-MM-DD&quot;.  Default: One year ago.</p>
</td></tr>
<tr><td><code id="yegcm_+3A_end">end</code></td>
<td>
<p>ending date, given in the format &quot;YYYY-MM-DD&quot;.  Default: Today.</p>
</td></tr>
<tr><td><code id="yegcm_+3A_clear.na.inf">clear.na.inf</code></td>
<td>
<p>if TRUE, NA and Inf price values are replaced by the last available price.  Default:TRUE.</p>
</td></tr>
<tr><td><code id="yegcm_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="#topic+egcm">egcm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the <code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> function of the <code>quantmod</code> package
to retrieve the adjusted closing prices of the two securities over
the specified date range.  Then, constructs an Engle-Granger cointegration
model from this data, and returns it.
</p>


<h3>Value</h3>

<p>An Engle-Granger cointegration model
</p>


<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a>
</p>


<h3>References</h3>

<p>Engle, R. F. and C. W. Granger.  (1987)
Co-integration and error correction: representation, estimation, and testing.
<em>Econometrica</em>, 251-276.
</p>


<h3>See Also</h3>

<p><a href="#topic+egcm">egcm</a>
<a href="quantmod.html#topic+getSymbols">getSymbols</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
e &lt;- yegcm("SPY", "VOO", start="2013-01-01", end="2014-01-01")
print(e)
plot(e)
summary(e)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
