<!DOCTYPE html><html><head><title>Help for package geos</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geos}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_geos_geometry.wk_xy'><p>Create GEOS Geometry Vectors</p></a></li>
<li><a href='#geos_area'><p>Extract information from a GEOS geometry</p></a></li>
<li><a href='#geos_basic_strtree'><p>Create a basic GEOS STRTree</p></a></li>
<li><a href='#geos_buffer'><p>Buffer a geometry</p></a></li>
<li><a href='#geos_centroid'><p>Geometry transformers</p></a></li>
<li><a href='#geos_create_rectangle'><p>Create rectangles from bounds</p></a></li>
<li><a href='#geos_delaunay_triangles'><p>Delaunay triagulations and Voronoi diagrams</p></a></li>
<li><a href='#geos_disjoint'><p>Binary predicates</p></a></li>
<li><a href='#geos_disjoint_matrix'><p>Matrix predicates</p></a></li>
<li><a href='#geos_distance'><p>Distance calculations</p></a></li>
<li><a href='#geos_empty'><p>Create empty geometries</p></a></li>
<li><a href='#geos_geometry_n'><p>Access child geometries</p></a></li>
<li><a href='#geos_inner_join'><p>Generate inner join keys based on a GEOS predicate</p></a></li>
<li><a href='#geos_intersection'><p>Binary geometry operators</p></a></li>
<li><a href='#geos_is_valid'><p>Geometry validity</p></a></li>
<li><a href='#geos_largest_empty_circle_spec'><p>Circular approximations</p></a></li>
<li><a href='#geos_make_point'><p>Create geometries from vectors of coordinates</p></a></li>
<li><a href='#geos_nearest'><p>Find the closest feature</p></a></li>
<li><a href='#geos_polygonize'><p>Create polygons from noded edges</p></a></li>
<li><a href='#geos_project'><p>Linear referencing</p></a></li>
<li><a href='#geos_read_wkt'><p>Read and write well-known text</p></a></li>
<li><a href='#geos_relate'><p>Dimensionally extended 9 intersection model</p></a></li>
<li><a href='#geos_segment_intersection'><p>Segment operations</p></a></li>
<li><a href='#geos_strtree'><p>Create a GEOS STRTree</p></a></li>
<li><a href='#geos_unnest'><p>Unnest nested geometries</p></a></li>
<li><a href='#geos_version'><p>GEOS version information</p></a></li>
<li><a href='#geos-package'><p>geos: Open Source Geometry Engine ('GEOS') R API</p></a></li>
<li><a href='#plot.geos_geometry'><p>Plot GEOS geometries</p></a></li>
<li><a href='#vctrs-methods'><p>Vctrs methods</p></a></li>
<li><a href='#wk-methods'><p>Compatibility with the wk package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Open Source Geometry Engine ('GEOS') R API</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an R API to the Open Source Geometry Engine
  ('GEOS') library (<a href="https://libgeos.org/">https://libgeos.org/</a>) and a vector format 
  with which to efficiently store 'GEOS' geometries. High-performance functions 
  to extract information from, calculate relationships between, and
  transform geometries are provided. Finally, facilities to import 
  and export geometry vectors to other spatial formats are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), vctrs, sf</td>
</tr>
<tr>
<td>Imports:</td>
<td>libgeos (&ge; 3.8.1-4), wk (&ge; 0.4.1)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paleolimbot.github.io/geos/">https://paleolimbot.github.io/geos/</a>,
<a href="https://github.com/paleolimbot/geos/">https://github.com/paleolimbot/geos/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paleolimbot/geos/issues">https://github.com/paleolimbot/geos/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>libgeos, wk</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 02:22:08 UTC; deweydunnington</td>
</tr>
<tr>
<td>Author:</td>
<td>Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dewey Dunnington &lt;dewey@fishandwhistle.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 05:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_geos_geometry.wk_xy'>Create GEOS Geometry Vectors</h2><span id='topic+as_geos_geometry.wk_xy'></span><span id='topic+as_geos_geometry.wk_xyz'></span><span id='topic+as_geos_geometry'></span><span id='topic+as_geos_geometry.geos_geometry'></span><span id='topic+as_geos_geometry.default'></span><span id='topic+as_geos_geometry.character'></span><span id='topic+as_geos_geometry.blob'></span><span id='topic+as_geos_geometry.WKB'></span><span id='topic+geos_geometry'></span>

<h3>Description</h3>

<p>Create GEOS Geometry Vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wk_xy'
as_geos_geometry(x, ...)

## S3 method for class 'wk_xyz'
as_geos_geometry(x, ...)

as_geos_geometry(x, ...)

## S3 method for class 'geos_geometry'
as_geos_geometry(x, ...)

## Default S3 method:
as_geos_geometry(x, ...)

## S3 method for class 'character'
as_geos_geometry(x, ..., crs = NULL)

## S3 method for class 'blob'
as_geos_geometry(x, ..., crs = NULL)

## S3 method for class 'WKB'
as_geos_geometry(x, ..., crs = NULL)

geos_geometry(crs = wk::wk_crs_inherit())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_geos_geometry.wk_xy_+3A_x">x</code></td>
<td>
<p>An object to be coerced to a geometry vector</p>
</td></tr>
<tr><td><code id="as_geos_geometry.wk_xy_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="as_geos_geometry.wk_xy_+3A_crs">crs</code></td>
<td>
<p>An object that can be interpreted as a CRS. See <code><a href="wk.html#topic+wk_crs">wk::wk_crs()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A geos geometry vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_geos_geometry("LINESTRING (0 1, 3 9)")

</code></pre>

<hr>
<h2 id='geos_area'>Extract information from a GEOS geometry</h2><span id='topic+geos_area'></span><span id='topic+geos_length'></span><span id='topic+geos_x'></span><span id='topic+geos_y'></span><span id='topic+geos_z'></span><span id='topic+geos_xmin'></span><span id='topic+geos_ymin'></span><span id='topic+geos_xmax'></span><span id='topic+geos_ymax'></span><span id='topic+geos_minimum_clearance'></span><span id='topic+geos_is_empty'></span><span id='topic+geos_is_simple'></span><span id='topic+geos_is_ring'></span><span id='topic+geos_has_z'></span><span id='topic+geos_is_closed'></span><span id='topic+geos_type_id'></span><span id='topic+geos_type'></span><span id='topic+geos_precision'></span><span id='topic+geos_srid'></span><span id='topic+geos_num_coordinates'></span><span id='topic+geos_num_geometries'></span><span id='topic+geos_num_interior_rings'></span><span id='topic+geos_num_rings'></span><span id='topic+geos_dimension'></span><span id='topic+geos_coordinate_dimension'></span><span id='topic+geos_is_clockwise'></span><span id='topic+geos_hilbert_code'></span>

<h3>Description</h3>

<p>Note that <code><a href="#topic+geos_x">geos_x()</a></code>, <code><a href="#topic+geos_y">geos_y()</a></code>, and <code><a href="#topic+geos_z">geos_z()</a></code> do not handle
empty points (use <code><a href="#topic+geos_write_xy">geos_write_xy()</a></code> if you need to handle this case).
Similarly, the min/max functions will error on empty geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_area(geom)

geos_length(geom)

geos_x(geom)

geos_y(geom)

geos_z(geom)

geos_xmin(geom)

geos_ymin(geom)

geos_xmax(geom)

geos_ymax(geom)

geos_minimum_clearance(geom)

geos_is_empty(geom)

geos_is_simple(geom)

geos_is_ring(geom)

geos_has_z(geom)

geos_is_closed(geom)

geos_type_id(geom)

geos_type(geom)

geos_precision(geom)

geos_srid(geom)

geos_num_coordinates(geom)

geos_num_geometries(geom)

geos_num_interior_rings(geom)

geos_num_rings(geom)

geos_dimension(geom)

geos_coordinate_dimension(geom)

geos_is_clockwise(geom)

geos_hilbert_code(geom, extent = wk::wk_bbox(geom), level = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_area_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_area_+3A_extent">extent</code></td>
<td>
<p>A geometry describing the extent of <code>geom</code> within which
Hilbert codes should be computed. Defaults to <code><a href="wk.html#topic+wk_bbox">wk::wk_bbox()</a></code> of <code>geom</code>.</p>
</td></tr>
<tr><td><code id="geos_area_+3A_level">level</code></td>
<td>
<p>The Hilbert level of precision (between 0 and 15).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>geom</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_area("POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))")
geos_length("POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))")
geos_x("POINT Z (1 2 3)")
geos_y("POINT Z (1 2 3)")
geos_z("POINT Z (1 2 3)")
geos_xmin("LINESTRING (0 1, 2 3)")
geos_ymin("LINESTRING (0 1, 2 3)")
geos_xmax("LINESTRING (0 1, 2 3)")
geos_ymax("LINESTRING (0 1, 2 3)")
geos_minimum_clearance("POLYGON ((0 0, 10 0, 10 10, 3 5, 0 10, 0 0))")

geos_is_empty(c("POINT EMPTY", "POINT (0 1)"))
geos_is_simple(c("LINESTRING (0 0, 1 1)", "LINESTRING (0 0, 1 1, 1 0, 0 1)"))
geos_is_ring(
  c(
    "LINESTRING (0 0, 1 0, 1 1, 0 1, 0 0)",
    "LINESTRING (0 0, 1 0, 1 1, 0 1)"
   )
)
geos_is_closed(
  c(
    "LINESTRING (0 0, 1 0, 1 1, 0 1, 0 0)",
    "LINESTRING (0 0, 1 0, 1 1, 0 1)"
   )
)
geos_has_z(c("POINT Z (1 2 3)", "POINT (1 2)"))

geos_type_id(c("POINT (0 0)", "LINESTRING (0 0, 1 1)"))
geos_srid(wk::as_wkb(c("SRID=1234;POINT (0 0)", "POINT (0 0)")))
geos_num_coordinates(c("POINT (0 0)", "MULTIPOINT (0 0, 1 1)"))
geos_num_geometries(c("POINT (0 0)", "MULTIPOINT (0 0, 1 1)"))
geos_num_interior_rings("POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))")
geos_dimension(c("POINT (0 0)", "LINESTRING (0 0, 1 1)"))
geos_coordinate_dimension(c("POINT (0 0)", "POINT Z (0 0 1)"))

</code></pre>

<hr>
<h2 id='geos_basic_strtree'>Create a basic GEOS STRTree</h2><span id='topic+geos_basic_strtree'></span><span id='topic+geos_basic_strtree_size'></span><span id='topic+geos_basic_strtree_finalized'></span><span id='topic+geos_basic_strtree_insert'></span><span id='topic+geos_basic_strtree_query'></span><span id='topic+geos_basic_strtree_query_filtered'></span>

<h3>Description</h3>

<p>An experimental alternative to the <code><a href="#topic+geos_strtree">geos_strtree()</a></code> that provides a more
flexible interface and potentially faster spatial joins. Notably,
<code><a href="#topic+geos_basic_strtree_insert">geos_basic_strtree_insert()</a></code> uses <code><a href="wk.html#topic+wk_bbox">wk::wk_envelope()</a></code> instead of
<code><a href="#topic+as_geos_geometry">as_geos_geometry()</a></code> and does not keep the underlying geometry in memory.
For object types like <code><a href="wk.html#topic+xy">wk::xy()</a></code> with an optimized <code><a href="wk.html#topic+wk_bbox">wk::wk_envelope()</a></code>
method, this is very efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_basic_strtree(items = NULL, node_capacity = 10L)

geos_basic_strtree_size(tree)

geos_basic_strtree_finalized(tree)

geos_basic_strtree_insert(tree, items)

geos_basic_strtree_query(tree, query, limit = NA, fill = FALSE)

geos_basic_strtree_query_filtered(
  tree,
  query,
  tree_geom,
  fun,
  ...,
  .chunk_size = 65536
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_basic_strtree_+3A_items">items</code></td>
<td>
<p>Items to add to the tree index</p>
</td></tr>
<tr><td><code id="geos_basic_strtree_+3A_node_capacity">node_capacity</code></td>
<td>
<p>The maximum number of child nodes that a node may have.
The minimum recommended capacity value is 4. If unsure, use a
default node capacity of 10.</p>
</td></tr>
<tr><td><code id="geos_basic_strtree_+3A_tree">tree</code></td>
<td>
<p>A <code><a href="#topic+geos_basic_strtree">geos_basic_strtree()</a></code></p>
</td></tr>
<tr><td><code id="geos_basic_strtree_+3A_query">query</code></td>
<td>
<p>Items with which to query the tree</p>
</td></tr>
<tr><td><code id="geos_basic_strtree_+3A_limit">limit</code></td>
<td>
<p>The maximum number of matches in the tree to return</p>
</td></tr>
<tr><td><code id="geos_basic_strtree_+3A_fill">fill</code></td>
<td>
<p>If <code>TRUE</code>, always returns <code>limit</code> matches per item in <code>query</code>
padded with <code>NA</code> if fewer than <code>limit</code> matches are found.</p>
</td></tr>
<tr><td><code id="geos_basic_strtree_+3A_tree_geom">tree_geom</code></td>
<td>
<p>A vctr coercible to <code><a href="#topic+geos_geometry">geos_geometry()</a></code> whose indices
align with <code>tree</code>.</p>
</td></tr>
<tr><td><code id="geos_basic_strtree_+3A_fun">fun</code></td>
<td>
<p>A vectorized binary predicate (e.g. <code><a href="#topic+geos_intersects">geos_intersects()</a></code>) that
will be called with the tree geometry, the query geometry and any <code>...</code>
args passed.</p>
</td></tr>
<tr><td><code id="geos_basic_strtree_+3A_...">...</code></td>
<td>
<p>Passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="geos_basic_strtree_+3A_.chunk_size">.chunk_size</code></td>
<td>
<p>The approximate number of comparisons to pass to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A geos_basic_strtree object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- geos_basic_strtree(wk::xy(1:5, 1:5))
geos_basic_strtree_size(tree)
(geos_basic_strtree_insert(tree, wk::xy(6:10, 6:10)))
geos_basic_strtree_query(tree, as_geos_geometry("LINESTRING (3 0, 0 3)"))

</code></pre>

<hr>
<h2 id='geos_buffer'>Buffer a geometry</h2><span id='topic+geos_buffer'></span><span id='topic+geos_offset_curve'></span><span id='topic+geos_buffer_params'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+geos_buffer">geos_buffer()</a></code> returns a polygon or multipolygon geometry.
</p>
</li>
<li> <p><code><a href="#topic+geos_offset_curve">geos_offset_curve()</a></code> returns a linestring offset to the left by <code>distance</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>geos_buffer(geom, distance, params = geos_buffer_params())

geos_offset_curve(geom, distance, params = geos_buffer_params())

geos_buffer_params(
  quad_segs = 30,
  end_cap_style = c("round", "flat", "square"),
  join_style = c("round", "mitre", "bevel"),
  mitre_limit = 1,
  single_sided = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_buffer_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_buffer_+3A_distance">distance</code></td>
<td>
<p>The buffer distance. Can be negative to buffer
or offset on the righthand side of the geometry.</p>
</td></tr>
<tr><td><code id="geos_buffer_+3A_params">params</code></td>
<td>
<p>A <code><a href="#topic+geos_buffer_params">geos_buffer_params()</a></code></p>
</td></tr>
<tr><td><code id="geos_buffer_+3A_quad_segs">quad_segs</code></td>
<td>
<p>The number of segments per quadrant. A higher number
here will increase the apparent resolution of the resulting polygon.</p>
</td></tr>
<tr><td><code id="geos_buffer_+3A_end_cap_style">end_cap_style</code></td>
<td>
<p>One of &quot;round&quot;, &quot;flat&quot;, or &quot;square&quot;.</p>
</td></tr>
<tr><td><code id="geos_buffer_+3A_join_style">join_style</code></td>
<td>
<p>One of &quot;round&quot;, &quot;mitre&quot;, or &quot;bevel&quot;.</p>
</td></tr>
<tr><td><code id="geos_buffer_+3A_mitre_limit">mitre_limit</code></td>
<td>
<p>If <code>join_style</code> is &quot;mitre&quot;, the relative extent (from zero to one)
of the join.</p>
</td></tr>
<tr><td><code id="geos_buffer_+3A_single_sided">single_sided</code></td>
<td>
<p>Use <code>TRUE</code> to buffer on only the right side
of the geometry. This does not apply to <code><a href="#topic+geos_offset_curve">geos_offset_curve()</a></code>, which is always
one-sided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a> along the recycled
length of <code>geom</code> and <code>distance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_buffer("POINT (0 0)", 1)
geos_offset_curve("LINESTRING (0 0, 0 10, 10 0)", 1)

</code></pre>

<hr>
<h2 id='geos_centroid'>Geometry transformers</h2><span id='topic+geos_centroid'></span><span id='topic+geos_boundary'></span><span id='topic+geos_minimum_width'></span><span id='topic+geos_minimum_clearance_line'></span><span id='topic+geos_minimum_rotated_rectangle'></span><span id='topic+geos_unary_union'></span><span id='topic+geos_unary_union_prec'></span><span id='topic+geos_coverage_union'></span><span id='topic+geos_point_on_surface'></span><span id='topic+geos_node'></span><span id='topic+geos_make_valid'></span><span id='topic+geos_make_valid_params'></span><span id='topic+geos_unique_points'></span><span id='topic+geos_reverse'></span><span id='topic+geos_merge_lines'></span><span id='topic+geos_build_area'></span><span id='topic+geos_envelope'></span><span id='topic+geos_envelope_rct'></span><span id='topic+geos_extent'></span><span id='topic+geos_convex_hull'></span><span id='topic+geos_concave_hull'></span><span id='topic+geos_concave_hull_of_polygons'></span><span id='topic+geos_polygon_hull_simplify'></span><span id='topic+geos_point_start'></span><span id='topic+geos_point_end'></span><span id='topic+geos_line_merge'></span><span id='topic+geos_line_merge_directed'></span><span id='topic+geos_transform_xy'></span><span id='topic+geos_clone'></span><span id='topic+geos_set_srid'></span><span id='topic+geos_point_n'></span><span id='topic+geos_simplify'></span><span id='topic+geos_remove_repeated_points'></span><span id='topic+geos_simplify_preserve_topology'></span><span id='topic+geos_set_precision'></span><span id='topic+geos_normalize'></span><span id='topic+geos_densify'></span><span id='topic+geos_clip_by_rect'></span>

<h3>Description</h3>

<p>Geometry transformers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_centroid(geom)

geos_boundary(geom)

geos_minimum_width(geom)

geos_minimum_clearance_line(geom)

geos_minimum_rotated_rectangle(geom)

geos_unary_union(geom)

geos_unary_union_prec(geom, grid_size)

geos_coverage_union(geom)

geos_point_on_surface(geom)

geos_node(geom)

geos_make_valid(geom, make_valid_params = geos_make_valid_params())

geos_make_valid_params(
  keep_collapsed = TRUE,
  method = c("make_valid_linework", "make_valid_structure")
)

geos_unique_points(geom)

geos_reverse(geom)

geos_merge_lines(geom)

geos_build_area(geom)

geos_envelope(geom)

geos_envelope_rct(geom)

geos_extent(geom)

geos_convex_hull(geom)

geos_concave_hull(geom, ratio, allow_holes = FALSE)

geos_concave_hull_of_polygons(
  geom,
  ratio,
  is_tight = TRUE,
  allow_holes = FALSE
)

geos_polygon_hull_simplify(
  geom,
  ratio,
  hull_type = c("outer", "inner"),
  ratio_mode = c("vertex", "area")
)

geos_point_start(geom)

geos_point_end(geom)

geos_line_merge(geom)

geos_line_merge_directed(geom)

geos_transform_xy(geom, trans)

geos_clone(geom)

geos_set_srid(geom, srid)

geos_point_n(geom, index)

geos_simplify(geom, tolerance)

geos_remove_repeated_points(geom, tolerance)

geos_simplify_preserve_topology(geom, tolerance)

geos_set_precision(
  geom,
  grid_size,
  preserve_topology = TRUE,
  keep_collapsed = FALSE
)

geos_normalize(geom)

geos_densify(geom, tolerance)

geos_clip_by_rect(geom, rect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_centroid_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_grid_size">grid_size</code></td>
<td>
<p>For <code style="white-space: pre;">&#8288;_prec()&#8288;</code> variants, the grid size such that all vertices of
the resulting geometry will lie on the grid.</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_make_valid_params">make_valid_params</code></td>
<td>
<p>A <code><a href="#topic+geos_make_valid_params">geos_make_valid_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_keep_collapsed">keep_collapsed</code></td>
<td>
<p>Should items that become EMPTY due to rounding
be kept in the output?</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_method">method</code></td>
<td>
<p>The method to use for <code><a href="#topic+geos_make_valid">geos_make_valid()</a></code>.  One of:
</p>

<ul>
<li><p> &quot;make_valid_linework&quot; combines all rings into a set of noded lines
and then extracts valid polygons from that linework.
</p>
</li>
<li><p> &quot;make_valid_structure&quot; Structured method, first makes all rings valid
then merges shells and subtracts holes from shells to generate valid
result. Assumes that holes and shells are correctly categorized.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geos_centroid_+3A_ratio">ratio</code></td>
<td>
<p>The normalized ratio between the shape of the concave hull
and the area of the return value. Use 1 for the convex hull; use 0
for maximum concave-ness.</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_allow_holes">allow_holes</code></td>
<td>
<p>Use <code>TRUE</code> to allow the concave hull to contain holes</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_is_tight">is_tight</code></td>
<td>
<p>Use <code>FALSE</code> to allow concave hull to expand beyond the
convex hull.</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_hull_type">hull_type</code></td>
<td>
<p>One of &quot;outer&quot; or &quot;inner&quot;.</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_ratio_mode">ratio_mode</code></td>
<td>
<p>One of &quot;vertex&quot; or &quot;area&quot;, describing the normalized
proportion type for which <code>ratio</code> represents.</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_trans">trans</code></td>
<td>
<p>A <a href="wk.html#topic+wk_trans_inverse">wk transform</a> object.</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_srid">srid</code></td>
<td>
<p>An integer spatial reference identifier.</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_index">index</code></td>
<td>
<p>The index of the point or geometry to extract.</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_tolerance">tolerance</code></td>
<td>
<p>A minimum distance to use for simplification or
densification. Use a higher value for more simplification (or
less densification).</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_preserve_topology">preserve_topology</code></td>
<td>
<p>Should topology internal to each feature
be preserved?</p>
</td></tr>
<tr><td><code id="geos_centroid_+3A_rect">rect</code></td>
<td>
<p>A <code>list()</code> representing rectangles in the form
<code>list(xmin, ymin, xmax, ymax)</code>. List items with length 1 will be
recycled to the length of the longest item.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a> of length <code>geom</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_centroid(c("POINT (0 1)", "LINESTRING (0 0, 1 1)"))
geos_boundary(c("POLYGON ((0 0, 1 0, 0 1, 0 0))", "LINESTRING (0 0, 1 1)"))
geos_minimum_width("POLYGON ((0 0, 1 0, 0 1, 0 0))")
geos_minimum_clearance_line("POLYGON ((0 0, 10 0, 10 10, 3 5, 0 10, 0 0))")
geos_minimum_rotated_rectangle("POLYGON ((0 0, 1 0, 0.5 0.5, 0 0))")
geos_minimum_bounding_circle("LINESTRING (-1 -1, 1 1)")
geos_unary_union("MULTIPOINT (0 1, 0 1)")
geos_point_on_surface("LINESTRING (0 1, 0.2 3, 10 10)")
geos_node("POLYGON ((0 0, 1 0, 0 1, 0 0))")
geos_make_valid("POLYGON ((0 0, 1 1, 1 0, 0 1, 0 0))")
geos_unique_points("POLYGON ((0 0, 1 0, 0 1, 0 0))")
geos_reverse("LINESTRING (0 0, 1 1)")
geos_merge_lines(
  "MULTILINESTRING ((0 0, 0.5 0.5, 2 2), (0.5 0.5, 2 2))"
)
geos_build_area("LINESTRING (0 0, 1 0, 0 1, 0 0)")
geos_envelope("LINESTRING (0 0, 1 2)")
geos_convex_hull("MULTIPOINT (0 0, 1 0, 0 2, 0 0)")
geos_point_start("LINESTRING (0 0, 1 1)")
geos_point_end("LINESTRING (0 0, 1 1)")

geos_simplify("LINESTRING (0 0, 0 1, 0 2)", 0.1)
geos_simplify_preserve_topology("LINESTRING (0 0, 0 1, 0 2)", 0.1)

</code></pre>

<hr>
<h2 id='geos_create_rectangle'>Create rectangles from bounds</h2><span id='topic+geos_create_rectangle'></span>

<h3>Description</h3>

<p>Create rectangles from bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_create_rectangle(xmin, ymin, xmax, ymax, crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_create_rectangle_+3A_xmin">xmin</code></td>
<td>
<p>Left bound of envelope</p>
</td></tr>
<tr><td><code id="geos_create_rectangle_+3A_ymin">ymin</code></td>
<td>
<p>Lower bound of envelope</p>
</td></tr>
<tr><td><code id="geos_create_rectangle_+3A_xmax">xmax</code></td>
<td>
<p>Right bound of envelope</p>
</td></tr>
<tr><td><code id="geos_create_rectangle_+3A_ymax">ymax</code></td>
<td>
<p>Upper bound of envelope</p>
</td></tr>
<tr><td><code id="geos_create_rectangle_+3A_crs">crs</code></td>
<td>
<p>An object that can be interpreted as a CRS. See <code><a href="wk.html#topic+wk_crs">wk::wk_crs()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+geos_geometry">geos_geometry()</a></code> consisting of a polygon
</p>

<hr>
<h2 id='geos_delaunay_triangles'>Delaunay triagulations and Voronoi diagrams</h2><span id='topic+geos_delaunay_triangles'></span><span id='topic+geos_constrained_delaunay_triangles'></span><span id='topic+geos_delaunay_edges'></span><span id='topic+geos_voronoi_polygons'></span><span id='topic+geos_voronoi_edges'></span>

<h3>Description</h3>

<p>These functions return one triangulation/diagram per feature as a
multi geometry. These functions are not vectorized along their parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_delaunay_triangles(geom, tolerance = 0)

geos_constrained_delaunay_triangles(geom)

geos_delaunay_edges(geom, tolerance = 0)

geos_voronoi_polygons(geom, env = NULL, tolerance = 0)

geos_voronoi_edges(geom, env = NULL, tolerance = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_delaunay_triangles_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a> whose nodes will be used
as input.</p>
</td></tr>
<tr><td><code id="geos_delaunay_triangles_+3A_tolerance">tolerance</code></td>
<td>
<p>A snapping tolerance or 0 to disable snapping</p>
</td></tr>
<tr><td><code id="geos_delaunay_triangles_+3A_env">env</code></td>
<td>
<p>A boundary for the diagram, or <code>NULL</code> to construct one
based on the input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a> of length <code>geom</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_delaunay_triangles("MULTIPOINT (0 0, 1 0, 0 1)")
geos_delaunay_edges("MULTIPOINT (0 0, 1 0, 0 1)")

geos_voronoi_polygons("MULTIPOINT (0 0, 1 0, 0 1)")
geos_voronoi_edges("MULTIPOINT (0 0, 1 0, 0 1)")

</code></pre>

<hr>
<h2 id='geos_disjoint'>Binary predicates</h2><span id='topic+geos_disjoint'></span><span id='topic+geos_touches'></span><span id='topic+geos_intersects'></span><span id='topic+geos_crosses'></span><span id='topic+geos_within'></span><span id='topic+geos_contains'></span><span id='topic+geos_overlaps'></span><span id='topic+geos_equals'></span><span id='topic+geos_equals_exact'></span><span id='topic+geos_covers'></span><span id='topic+geos_covered_by'></span><span id='topic+geos_prepared_disjoint'></span><span id='topic+geos_prepared_touches'></span><span id='topic+geos_prepared_intersects'></span><span id='topic+geos_prepared_crosses'></span><span id='topic+geos_prepared_within'></span><span id='topic+geos_prepared_contains'></span><span id='topic+geos_prepared_contains_properly'></span><span id='topic+geos_prepared_overlaps'></span><span id='topic+geos_prepared_covers'></span><span id='topic+geos_prepared_covered_by'></span>

<h3>Description</h3>

<p>Binary predicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_disjoint(geom1, geom2)

geos_touches(geom1, geom2)

geos_intersects(geom1, geom2)

geos_crosses(geom1, geom2)

geos_within(geom1, geom2)

geos_contains(geom1, geom2)

geos_overlaps(geom1, geom2)

geos_equals(geom1, geom2)

geos_equals_exact(geom1, geom2, tolerance = .Machine$double.eps^2)

geos_covers(geom1, geom2)

geos_covered_by(geom1, geom2)

geos_prepared_disjoint(geom1, geom2)

geos_prepared_touches(geom1, geom2)

geos_prepared_intersects(geom1, geom2)

geos_prepared_crosses(geom1, geom2)

geos_prepared_within(geom1, geom2)

geos_prepared_contains(geom1, geom2)

geos_prepared_contains_properly(geom1, geom2)

geos_prepared_overlaps(geom1, geom2)

geos_prepared_covers(geom1, geom2)

geos_prepared_covered_by(geom1, geom2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_disjoint_+3A_geom1">geom1</code>, <code id="geos_disjoint_+3A_geom2">geom2</code></td>
<td>
<p><a href="#topic+as_geos_geometry">GEOS geometry vectors</a>,
recycled to a common length.</p>
</td></tr>
<tr><td><code id="geos_disjoint_+3A_tolerance">tolerance</code></td>
<td>
<p>The maximum separation of vertices that should
be considered equal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector along the recycled length of <code>geom1</code> and <code>geom2</code>
</p>

<hr>
<h2 id='geos_disjoint_matrix'>Matrix predicates</h2><span id='topic+geos_disjoint_matrix'></span><span id='topic+geos_touches_matrix'></span><span id='topic+geos_intersects_matrix'></span><span id='topic+geos_crosses_matrix'></span><span id='topic+geos_within_matrix'></span><span id='topic+geos_contains_matrix'></span><span id='topic+geos_contains_properly_matrix'></span><span id='topic+geos_overlaps_matrix'></span><span id='topic+geos_equals_matrix'></span><span id='topic+geos_equals_exact_matrix'></span><span id='topic+geos_covers_matrix'></span><span id='topic+geos_covered_by_matrix'></span><span id='topic+geos_disjoint_any'></span><span id='topic+geos_touches_any'></span><span id='topic+geos_intersects_any'></span><span id='topic+geos_crosses_any'></span><span id='topic+geos_within_any'></span><span id='topic+geos_contains_any'></span><span id='topic+geos_contains_properly_any'></span><span id='topic+geos_overlaps_any'></span><span id='topic+geos_equals_any'></span><span id='topic+geos_equals_exact_any'></span><span id='topic+geos_covers_any'></span><span id='topic+geos_covered_by_any'></span>

<h3>Description</h3>

<p>Matrix predicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_disjoint_matrix(geom, tree)

geos_touches_matrix(geom, tree)

geos_intersects_matrix(geom, tree)

geos_crosses_matrix(geom, tree)

geos_within_matrix(geom, tree)

geos_contains_matrix(geom, tree)

geos_contains_properly_matrix(geom, tree)

geos_overlaps_matrix(geom, tree)

geos_equals_matrix(geom, tree)

geos_equals_exact_matrix(geom, tree, tolerance = .Machine$double.eps^2)

geos_covers_matrix(geom, tree)

geos_covered_by_matrix(geom, tree)

geos_disjoint_any(geom, tree)

geos_touches_any(geom, tree)

geos_intersects_any(geom, tree)

geos_crosses_any(geom, tree)

geos_within_any(geom, tree)

geos_contains_any(geom, tree)

geos_contains_properly_any(geom, tree)

geos_overlaps_any(geom, tree)

geos_equals_any(geom, tree)

geos_equals_exact_any(geom, tree, tolerance = .Machine$double.eps^2)

geos_covers_any(geom, tree)

geos_covered_by_any(geom, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_disjoint_matrix_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_disjoint_matrix_+3A_tree">tree</code></td>
<td>
<p>A <code><a href="#topic+geos_strtree">geos_strtree()</a></code></p>
</td></tr>
<tr><td><code id="geos_disjoint_matrix_+3A_tolerance">tolerance</code></td>
<td>
<p>The maximum separation of vertices that should
be considered equal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list()</code> of integer vectors containing the indices of <code>tree</code>
for which the predicate would return TRUE.
</p>

<hr>
<h2 id='geos_distance'>Distance calculations</h2><span id='topic+geos_distance'></span><span id='topic+geos_prepared_distance'></span><span id='topic+geos_distance_indexed'></span><span id='topic+geos_distance_hausdorff'></span><span id='topic+geos_distance_frechet'></span><span id='topic+geos_is_within_distance'></span><span id='topic+geos_prepared_is_within_distance'></span>

<h3>Description</h3>

<p>Distance calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_distance(geom1, geom2)

geos_prepared_distance(geom1, geom2)

geos_distance_indexed(geom1, geom2)

geos_distance_hausdorff(geom1, geom2, densify = NULL)

geos_distance_frechet(geom1, geom2, densify = NULL)

geos_is_within_distance(geom1, geom2, distance)

geos_prepared_is_within_distance(geom1, geom2, distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_distance_+3A_geom1">geom1</code>, <code id="geos_distance_+3A_geom2">geom2</code></td>
<td>
<p><a href="#topic+as_geos_geometry">GEOS geometry vectors</a>,
recycled to a common length.</p>
</td></tr>
<tr><td><code id="geos_distance_+3A_densify">densify</code></td>
<td>
<p>A fraction between 0 and 1 denoting the degree to which
edges should be subdivided (smaller value means more subdivisions).
Use NULL to calculate the distance as-is.</p>
</td></tr>
<tr><td><code id="geos_distance_+3A_distance">distance</code></td>
<td>
<p>A threshold distance, below which <code><a href="#topic+geos_is_within_distance">geos_is_within_distance()</a></code>
and <code><a href="#topic+geos_prepared_is_within_distance">geos_prepared_is_within_distance()</a></code> will return <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector along the recycled length of <code>geom1</code> and <code>geom2</code>
</p>

<hr>
<h2 id='geos_empty'>Create empty geometries</h2><span id='topic+geos_empty'></span><span id='topic+as_geos_type_id'></span><span id='topic+as_geos_type_id.default'></span><span id='topic+as_geos_type_id.character'></span><span id='topic+as_geos_type_id.numeric'></span>

<h3>Description</h3>

<p>Create empty geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_empty(type_id = "geometrycollection", crs = wk::wk_crs_inherit())

as_geos_type_id(type_id)

## Default S3 method:
as_geos_type_id(type_id)

## S3 method for class 'character'
as_geos_type_id(type_id)

## S3 method for class 'numeric'
as_geos_type_id(type_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_empty_+3A_type_id">type_id</code></td>
<td>
<p>The numeric type identifier for which an
empty should be returned, an object from which
one can be extracted using <code><a href="#topic+as_geos_type_id">as_geos_type_id()</a></code>
(default to calling <code><a href="#topic+geos_type_id">geos_type_id()</a></code>). This is most
usefully a character vector with the geometry type
(e.g., point, linestring, polygon).</p>
</td></tr>
<tr><td><code id="geos_empty_+3A_crs">crs</code></td>
<td>
<p>An object that can be interpreted as a CRS. See <code><a href="wk.html#topic+wk_crs">wk::wk_crs()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_empty(c("point", "linestring", "polygon"))
geos_empty(1:7)
geos_empty(geos_read_wkt(c("POINT (0 1)", "LINESTRING (0 0, 1 1)")))

</code></pre>

<hr>
<h2 id='geos_geometry_n'>Access child geometries</h2><span id='topic+geos_geometry_n'></span><span id='topic+geos_ring_n'></span>

<h3>Description</h3>

<p>Access child geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_geometry_n(geom, n)

geos_ring_n(geom, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_geometry_n_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_geometry_n_+3A_n">n</code></td>
<td>
<p>The (one-based) index of the child geometry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a> along the recycled
length of <code>geom</code> and <code>i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>multipoint &lt;- "MULTIPOINT (0 0, 1 1, 2 2)"
geos_geometry_n(multipoint, seq_len(geos_num_geometries(multipoint)))

poly &lt;- "POLYGON ((0 0, 0 1, 1 0, 0 0), (0.1 0.1, 0.1 0.2, 0.2 0.1, 0.1 0.1))"
geos_ring_n(poly, seq_len(geos_num_rings(poly)))

</code></pre>

<hr>
<h2 id='geos_inner_join'>Generate inner join keys based on a GEOS predicate</h2><span id='topic+geos_inner_join'></span><span id='topic+geos_inner_join_keys'></span>

<h3>Description</h3>

<p>Experimental low-level spatial join infrastructure based on the
<code><a href="#topic+geos_basic_strtree">geos_basic_strtree()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_inner_join(
  x,
  y,
  predicate = "intersects",
  distance = NA,
  suffix = c(".x", ".y")
)

geos_inner_join_keys(x, y, predicate = "intersects", distance = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_inner_join_+3A_x">x</code>, <code id="geos_inner_join_+3A_y">y</code></td>
<td>
<p>Geometry vectors with a <code><a href="wk.html#topic+wk_handle">wk::wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="geos_inner_join_+3A_predicate">predicate</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> intersects
</p>
</li>
<li><p> contains
</p>
</li>
<li><p> contains_properly
</p>
</li>
<li><p> covered_by
</p>
</li>
<li><p> covers
</p>
</li>
<li><p> crosses
</p>
</li>
<li><p> equals
</p>
</li>
<li><p> equals_exact
</p>
</li>
<li><p> intersects
</p>
</li>
<li><p> within_distance
</p>
</li>
<li><p> overlaps
</p>
</li>
<li><p> touches
</p>
</li></ul>
</td></tr>
<tr><td><code id="geos_inner_join_+3A_distance">distance</code></td>
<td>
<p>Passed to <code><a href="#topic+geos_is_within_distance">geos_is_within_distance()</a></code> when <code>predicate</code>
is &quot;within_distance&quot;; passed to <code><a href="#topic+geos_equals_exact">geos_equals_exact()</a></code> when <code>predicate</code>
is &quot;equals_exact.</p>
</td></tr>
<tr><td><code id="geos_inner_join_+3A_suffix">suffix</code></td>
<td>
<p>A character vector of length 2 with suffixes for the left
and right sides for output columns with duplicated names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns x and y corresponding to the 1-based
indices on pairs of <code>x</code> and <code>y</code> for which <code>predicate</code> is TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  col_x = "a",
  geometry = as_geos_geometry("POINT (10 10)")
)

y &lt;- data.frame(
  col_y = "a",
  geometry = as_geos_geometry("POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))")
)

geos_inner_join(x, y, "intersects")

geos_inner_join_keys(
  "POINT (5 5)",
  "POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))",
  "intersects"
)

</code></pre>

<hr>
<h2 id='geos_intersection'>Binary geometry operators</h2><span id='topic+geos_intersection'></span><span id='topic+geos_difference'></span><span id='topic+geos_sym_difference'></span><span id='topic+geos_union'></span><span id='topic+geos_intersection_prec'></span><span id='topic+geos_difference_prec'></span><span id='topic+geos_sym_difference_prec'></span><span id='topic+geos_union_prec'></span><span id='topic+geos_shared_paths'></span><span id='topic+geos_snap'></span><span id='topic+geos_clearance_line_between'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+geos_intersection">geos_intersection()</a></code> returns the set of points common to both <code>x</code>
and <code>y</code>.
</p>
</li>
<li> <p><code><a href="#topic+geos_difference">geos_difference()</a></code> returns the set of points from <code>x</code> that are
not contained by <code>y</code>.
</p>
</li>
<li> <p><code><a href="#topic+geos_sym_difference">geos_sym_difference()</a></code> returns the set of points that are <em>not</em>
common to <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code><a href="#topic+geos_union">geos_union()</a></code> returns the set of points contained by either <code>x</code>
or <code>y</code>.
</p>
</li>
<li> <p><code><a href="#topic+geos_shared_paths">geos_shared_paths()</a></code> returns a GEOMETRYCOLLECTION containing two
MULTILINESTRINGS: the first containing paths in the same direction,
the second containing common paths in the opposite direction.
</p>
</li>
<li> <p><code><a href="#topic+geos_snap">geos_snap()</a></code> snaps the vertices of <code>x</code> within <code>tolerance</code> of <code>y</code>
to <code>y</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>geos_intersection(geom1, geom2)

geos_difference(geom1, geom2)

geos_sym_difference(geom1, geom2)

geos_union(geom1, geom2)

geos_intersection_prec(geom1, geom2, grid_size)

geos_difference_prec(geom1, geom2, grid_size)

geos_sym_difference_prec(geom1, geom2, grid_size)

geos_union_prec(geom1, geom2, grid_size)

geos_shared_paths(geom1, geom2)

geos_snap(geom1, geom2, tolerance = .Machine$double.eps^2)

geos_clearance_line_between(geom1, geom2, prepare = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_intersection_+3A_geom1">geom1</code>, <code id="geos_intersection_+3A_geom2">geom2</code></td>
<td>
<p><a href="#topic+as_geos_geometry">GEOS geometry vectors</a>,
recycled to a common length.</p>
</td></tr>
<tr><td><code id="geos_intersection_+3A_grid_size">grid_size</code></td>
<td>
<p>For <code style="white-space: pre;">&#8288;_prec()&#8288;</code> variants, the grid size such that all vertices of
the resulting geometry will lie on the grid.</p>
</td></tr>
<tr><td><code id="geos_intersection_+3A_tolerance">tolerance</code></td>
<td>
<p>The maximum separation of vertices that should
be considered equal.</p>
</td></tr>
<tr><td><code id="geos_intersection_+3A_prepare">prepare</code></td>
<td>
<p>Use prepared geometries to calculate clearance line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a> along the recycled
length of <code>geom1</code> and <code>geom2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poly1 &lt;- "POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))"
poly2 &lt;- "POLYGON ((5 5, 5 15, 15 15, 15 5, 5 5))"

geos_intersection(poly1, poly2)
geos_difference(poly1, poly2)
geos_sym_difference(poly1, poly2)
geos_union(poly1, poly2)

line &lt;- "LINESTRING (11 0, 11 10)"
geos_snap(poly1, line, tolerance = 2)

geos_shared_paths("LINESTRING (0 0, 1 1, 2 2)", "LINESTRING (3 3, 2 2, 1 1)")

</code></pre>

<hr>
<h2 id='geos_is_valid'>Geometry validity</h2><span id='topic+geos_is_valid'></span><span id='topic+geos_is_valid_detail'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+geos_is_valid">geos_is_valid()</a></code> returns a logical vector denoting if each feature
is a valid geometry.
</p>
</li>
<li> <p><code><a href="#topic+geos_is_valid_detail">geos_is_valid_detail()</a></code> returns a data frame with columns <code>is_valid</code> (logical),
<code>reason</code> (character), and <code>location</code> (<a href="#topic+as_geos_geometry">geos_geometry</a>).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>geos_is_valid(geom)

geos_is_valid_detail(geom, allow_self_touching_ring_forming_hole = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_is_valid_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_is_valid_+3A_allow_self_touching_ring_forming_hole">allow_self_touching_ring_forming_hole</code></td>
<td>
<p>It's all in the name</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>geos_is_valid(
  c(
    "POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))",
    "POLYGON ((0 0, 1 1, 1 0, 0 1, 0 0))"
  )
)

geos_is_valid_detail(
  c(
    "POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))",
    "POLYGON ((0 0, 1 1, 1 0, 0 1, 0 0))"
  )
)

</code></pre>

<hr>
<h2 id='geos_largest_empty_circle_spec'>Circular approximations</h2><span id='topic+geos_largest_empty_circle_spec'></span><span id='topic+geos_largest_empty_crc'></span><span id='topic+geos_minimum_bounding_circle'></span><span id='topic+geos_minimum_bounding_crc'></span><span id='topic+geos_maximum_inscribed_circle_spec'></span><span id='topic+geos_maximum_inscribed_crc'></span>

<h3>Description</h3>

<p>Circular approximations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_largest_empty_circle_spec(geom, boundary, tolerance)

geos_largest_empty_crc(geom, boundary, tolerance)

geos_minimum_bounding_circle(geom)

geos_minimum_bounding_crc(geom)

geos_maximum_inscribed_circle_spec(geom, tolerance)

geos_maximum_inscribed_crc(geom, tolerance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_largest_empty_circle_spec_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_largest_empty_circle_spec_+3A_boundary">boundary</code></td>
<td>
<p>An outer boundary for the largest empty circle
algorithm.</p>
</td></tr>
<tr><td><code id="geos_largest_empty_circle_spec_+3A_tolerance">tolerance</code></td>
<td>
<p>Threshold for considering circles to be touching
a boundary.</p>
</td></tr>
</table>

<hr>
<h2 id='geos_make_point'>Create geometries from vectors of coordinates</h2><span id='topic+geos_make_point'></span><span id='topic+geos_make_linestring'></span><span id='topic+geos_make_polygon'></span><span id='topic+geos_make_collection'></span>

<h3>Description</h3>

<p>These functions transform raw coordinates into point, line, polygon,
features, or nest a vector of geometries into a MULTI* type or
GEOMETRYCOLLECTION. See <code><a href="wk.html#topic+wk_vertices">wk::wk_coords()</a></code>, <code><a href="#topic+geos_unnest">geos_unnest()</a></code>, or
<code><a href="wk.html#topic+wk_flatten">wk::wk_flatten()</a></code> to perform inverse operations; see <code><a href="wk.html#topic+xy">wk::xy()</a></code>,
<code><a href="wk.html#topic+wk_linestring">wk::wk_linestring()</a></code>, <code><a href="wk.html#topic+wk_linestring">wk::wk_polygon()</a></code>, or <code><a href="wk.html#topic+wk_linestring">wk::wk_collection()</a></code> for
generic versions that work with non-GEOS types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_make_point(x, y, z = NA_real_, crs = NULL)

geos_make_linestring(x, y, z = NA_real_, feature_id = 1L, crs = NULL)

geos_make_polygon(
  x,
  y,
  z = NA_real_,
  feature_id = 1L,
  ring_id = 1L,
  crs = NULL
)

geos_make_collection(geom, type_id = "geometrycollection", feature_id = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_make_point_+3A_x">x</code>, <code id="geos_make_point_+3A_y">y</code>, <code id="geos_make_point_+3A_z">z</code></td>
<td>
<p>Vectors of coordinate values</p>
</td></tr>
<tr><td><code id="geos_make_point_+3A_crs">crs</code></td>
<td>
<p>An object that can be interpreted as a CRS. See <code><a href="wk.html#topic+wk_crs">wk::wk_crs()</a></code>.</p>
</td></tr>
<tr><td><code id="geos_make_point_+3A_feature_id">feature_id</code>, <code id="geos_make_point_+3A_ring_id">ring_id</code></td>
<td>
<p>Vectors for which a change in sequential values
indicates a new feature or ring. Use <code><a href="base.html#topic+factor">factor()</a></code> to convert from a character
vector.</p>
</td></tr>
<tr><td><code id="geos_make_point_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_make_point_+3A_type_id">type_id</code></td>
<td>
<p>The numeric type identifier for which an
empty should be returned, an object from which
one can be extracted using <code><a href="#topic+as_geos_type_id">as_geos_type_id()</a></code>
(default to calling <code><a href="#topic+geos_type_id">geos_type_id()</a></code>). This is most
usefully a character vector with the geometry type
(e.g., point, linestring, polygon).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_make_point(1:3, 1:3)
geos_make_linestring(1:3, 1:3)
geos_make_polygon(c(0, 1, 0), c(0, 0, 1))
geos_make_collection("POINT (1 1)")

</code></pre>

<hr>
<h2 id='geos_nearest'>Find the closest feature</h2><span id='topic+geos_nearest'></span><span id='topic+geos_nearest_indexed'></span><span id='topic+geos_nearest_hausdorff'></span><span id='topic+geos_nearest_frechet'></span>

<h3>Description</h3>

<p>Finds the closest item index in <code>tree</code> to <code>geom</code>, vectorized along <code>geom</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_nearest(geom, tree)

geos_nearest_indexed(geom, tree)

geos_nearest_hausdorff(geom, tree, densify = NULL)

geos_nearest_frechet(geom, tree, densify = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_nearest_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_nearest_+3A_tree">tree</code></td>
<td>
<p>A <code><a href="#topic+geos_strtree">geos_strtree()</a></code></p>
</td></tr>
<tr><td><code id="geos_nearest_+3A_densify">densify</code></td>
<td>
<p>A fraction between 0 and 1 denoting the degree to which
edges should be subdivided (smaller value means more subdivisions).
Use NULL to calculate the distance as-is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of length <code>geom</code> containing the index
of <code>tree</code> that is closest to each feature in <code>geom</code>.
</p>

<hr>
<h2 id='geos_polygonize'>Create polygons from noded edges</h2><span id='topic+geos_polygonize'></span><span id='topic+geos_polygonize_valid'></span><span id='topic+geos_polygonize_cut_edges'></span><span id='topic+geos_polygonize_full'></span>

<h3>Description</h3>

<p>Create polygons from noded edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_polygonize(collection)

geos_polygonize_valid(collection)

geos_polygonize_cut_edges(collection)

geos_polygonize_full(collection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_polygonize_+3A_collection">collection</code></td>
<td>
<p>A GEOMETRYCOLLECTION or MULTILINESTRING of
edges that meet at their endpoints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A GEOMETRYCOLLECTION of polygons
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_polygonize("MULTILINESTRING ((0 0, 0 1), (0 1, 1 0), (1 0, 0 0))")
geos_polygonize_valid("MULTILINESTRING ((0 0, 0 1), (0 1, 1 0), (1 0, 0 0))")
geos_polygonize_cut_edges("MULTILINESTRING ((0 0, 0 1), (0 1, 1 0), (1 0, 0 0))")

</code></pre>

<hr>
<h2 id='geos_project'>Linear referencing</h2><span id='topic+geos_project'></span><span id='topic+geos_project_normalized'></span><span id='topic+geos_interpolate'></span><span id='topic+geos_interpolate_normalized'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+geos_project">geos_project()</a></code> and <code><a href="#topic+geos_project_normalized">geos_project_normalized()</a></code> return
the distance of point <code>geom2</code> projected on <code>geom1</code> from the origin
of <code>geom1</code>, which must be a lineal geometry.
</p>
</li>
<li> <p><code><a href="#topic+geos_interpolate">geos_interpolate()</a></code> performs an
inverse operation, returning the point along <code>geom</code> representing
the given <code>distance</code> from the origin along the geometry.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_normalized()&#8288;</code> variants use a distance normalized to the
<code><a href="#topic+geos_length">geos_length()</a></code> of the geometry.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>geos_project(geom1, geom2)

geos_project_normalized(geom1, geom2)

geos_interpolate(geom, distance)

geos_interpolate_normalized(geom, distance_normalized)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_project_+3A_geom1">geom1</code>, <code id="geos_project_+3A_geom2">geom2</code></td>
<td>
<p><a href="#topic+as_geos_geometry">GEOS geometry vectors</a>,
recycled to a common length.</p>
</td></tr>
<tr><td><code id="geos_project_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_project_+3A_distance">distance</code></td>
<td>
<p>Distance along the linestring to interpolate</p>
</td></tr>
<tr><td><code id="geos_project_+3A_distance_normalized">distance_normalized</code></td>
<td>
<p>Distance along the linestring to interpolate
relative to the length of the linestring.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>geos_interpolate("LINESTRING (0 0, 1 1)", 1)
geos_interpolate_normalized("LINESTRING (0 0, 1 1)", 1)

geos_project("LINESTRING (0 0, 10 10)", "POINT (5 5)")
geos_project_normalized("LINESTRING (0 0, 10 10)", "POINT (5 5)")

</code></pre>

<hr>
<h2 id='geos_read_wkt'>Read and write well-known text</h2><span id='topic+geos_read_wkt'></span><span id='topic+geos_write_wkt'></span><span id='topic+geos_read_geojson'></span><span id='topic+geos_write_geojson'></span><span id='topic+geos_read_wkb'></span><span id='topic+geos_write_wkb'></span><span id='topic+geos_read_hex'></span><span id='topic+geos_write_hex'></span><span id='topic+geos_read_xy'></span><span id='topic+geos_write_xy'></span>

<h3>Description</h3>

<p>Read and write well-known text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_read_wkt(wkt, fix_structure = FALSE, crs = NULL)

geos_write_wkt(geom, include_z = TRUE, precision = 16, trim = TRUE)

geos_read_geojson(geojson, crs = NULL)

geos_write_geojson(geom, indent = -1)

geos_read_wkb(wkb, fix_structure = FALSE, crs = NULL)

geos_write_wkb(
  geom,
  include_z = TRUE,
  include_srid = FALSE,
  endian = 1,
  flavor = c("extended", "iso")
)

geos_read_hex(hex, fix_structure = FALSE, crs = NULL)

geos_write_hex(
  geom,
  include_z = TRUE,
  include_srid = FALSE,
  endian = 1,
  flavor = c("extended", "iso")
)

geos_read_xy(point)

geos_write_xy(geom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_read_wkt_+3A_wkt">wkt</code></td>
<td>
<p>a <code>character()</code> vector of well-known text</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_fix_structure">fix_structure</code></td>
<td>
<p>Set the reader to automatically repair structural errors
in the input (currently just unclosed rings) while reading.</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_crs">crs</code></td>
<td>
<p>An object that can be interpreted as a CRS. See <code><a href="wk.html#topic+wk_crs">wk::wk_crs()</a></code>.</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_include_z">include_z</code>, <code id="geos_read_wkt_+3A_include_srid">include_srid</code></td>
<td>
<p>Include the values of the Z and M coordinates and/or
SRID in the output?
Use <code>FALSE</code> to omit, <code>TRUE</code> to include, or <code>NA</code> to
include only if present. Note that using <code>TRUE</code> may result
in an error if there is no value present in the original.</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_precision">precision</code></td>
<td>
<p>The number of significant digits to include iin WKT
output.</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_trim">trim</code></td>
<td>
<p>Trim unnecessary zeroes in the output?</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_geojson">geojson</code></td>
<td>
<p>A <code>character()</code> vector fo GeoJSON features</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_indent">indent</code></td>
<td>
<p>The number of spaces to use when indenting a formatted
version of the output. Use -1 to indicate no formatting.</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code>raw()</code> vectors (or <code>NULL</code> representing
an <code>NA</code> value).</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_endian">endian</code></td>
<td>
<p>0 for big endian or 1 for little endian.</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_flavor">flavor</code></td>
<td>
<p>One of &quot;extended&quot; (i.e., EWKB) or &quot;iso&quot;.</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_hex">hex</code></td>
<td>
<p>A hexidecimal representation of well-known binary</p>
</td></tr>
<tr><td><code id="geos_read_wkt_+3A_point">point</code></td>
<td>
<p>A <code>list()</code> representing points in the form <code>list(x, y)</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>geos_read_wkt("POINT (30 10)")
geos_write_wkt(geos_read_wkt("POINT (30 10)"))

</code></pre>

<hr>
<h2 id='geos_relate'>Dimensionally extended 9 intersection model</h2><span id='topic+geos_relate'></span><span id='topic+geos_relate_pattern'></span><span id='topic+geos_relate_pattern_match'></span><span id='topic+geos_relate_pattern_create'></span>

<h3>Description</h3>

<p>See the <a href="https://en.wikipedia.org/wiki/DE-9IM">Wikipedia entry on DE-9IM</a>
for how to interpret <code>pattern</code>, <code>match</code>, and the result of <code><a href="#topic+geos_relate">geos_relate()</a></code>
and/or <code><a href="#topic+geos_relate_pattern_create">geos_relate_pattern_create()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_relate(geom1, geom2, boundary_node_rule = "mod2")

geos_relate_pattern(geom1, geom2, pattern, boundary_node_rule = "mod2")

geos_relate_pattern_match(match, pattern)

geos_relate_pattern_create(
  II = "*",
  IB = "*",
  IE = "*",
  BI = "*",
  BB = "*",
  BE = "*",
  EI = "*",
  EB = "*",
  EE = "*"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_relate_+3A_geom1">geom1</code>, <code id="geos_relate_+3A_geom2">geom2</code></td>
<td>
<p><a href="#topic+as_geos_geometry">GEOS geometry vectors</a>,
recycled to a common length.</p>
</td></tr>
<tr><td><code id="geos_relate_+3A_boundary_node_rule">boundary_node_rule</code></td>
<td>
<p>One of &quot;mod2&quot;, &quot;endpoint&quot;, &quot;multivalent_endpoint&quot;,
or &quot;monovalent_endpoint&quot;.</p>
</td></tr>
<tr><td><code id="geos_relate_+3A_pattern">pattern</code>, <code id="geos_relate_+3A_match">match</code></td>
<td>
<p>A character vector representing the match</p>
</td></tr>
<tr><td><code id="geos_relate_+3A_ii">II</code>, <code id="geos_relate_+3A_ib">IB</code>, <code id="geos_relate_+3A_ie">IE</code>, <code id="geos_relate_+3A_bi">BI</code>, <code id="geos_relate_+3A_bb">BB</code>, <code id="geos_relate_+3A_be">BE</code>, <code id="geos_relate_+3A_ei">EI</code>, <code id="geos_relate_+3A_eb">EB</code>, <code id="geos_relate_+3A_ee">EE</code></td>
<td>
<p>One of &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;T&quot;, &quot;F&quot;, or &quot;*&quot;
describing the dimension of the intersection between the interior (I),
boundary (B), and exterior (E).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>geos_relate_pattern_match("FF*FF1***", c(NA, "FF*FF****", "FF*FF***F"))
geos_relate("POINT (0 0)", "POINT (0 0)")
geos_relate_pattern("POINT (0 0)", "POINT (0 0)", "T********")
geos_relate_pattern_create(II = "T")

</code></pre>

<hr>
<h2 id='geos_segment_intersection'>Segment operations</h2><span id='topic+geos_segment_intersection'></span><span id='topic+geos_orientation_index'></span>

<h3>Description</h3>

<p>Segment operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_segment_intersection(a, b)

geos_orientation_index(a, point)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_segment_intersection_+3A_a">a</code>, <code id="geos_segment_intersection_+3A_b">b</code></td>
<td>
<p>A <code>list()</code> representing segments in the form
<code>list(x0, y0, x1, y1)</code>. List items with length 1 will be
recycled to the length of the longest item.</p>
</td></tr>
<tr><td><code id="geos_segment_intersection_+3A_point">point</code></td>
<td>
<p>A <code>list()</code> representing points in the form <code>list(x, y)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+geos_segment_intersection">geos_segment_intersection()</a></code> returns a <code>list(x, y)</code>;
<code><a href="#topic+geos_orientation_index">geos_orientation_index()</a></code> returns -1, 0 or 1, depending if
the <code>point</code> lies to the right of (-1), is colinear with (0) or
lies to the left of (1) the segment (as judged from the start
of the segment looking towards the end).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_segment_intersection(
  list(0, 0, 10, 10),
  list(10, 0, 0, 10)
)

geos_orientation_index(
  list(0, 0, 10, 10),
  list(15, c(12, 15, 17))
)

</code></pre>

<hr>
<h2 id='geos_strtree'>Create a GEOS STRTree</h2><span id='topic+geos_strtree'></span><span id='topic+geos_strtree_query'></span><span id='topic+geos_strtree_data'></span><span id='topic+as_geos_strtree'></span><span id='topic+as_geos_strtree.default'></span><span id='topic+as_geos_strtree.geos_strtree'></span><span id='topic+as_geos_strtree.geos_geometry'></span>

<h3>Description</h3>

<p>Create a GEOS STRTree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_strtree(geom, node_capacity = 10L)

geos_strtree_query(tree, geom)

geos_strtree_data(tree)

as_geos_strtree(x, ...)

## Default S3 method:
as_geos_strtree(x, ...)

## S3 method for class 'geos_strtree'
as_geos_strtree(x, ...)

## S3 method for class 'geos_geometry'
as_geos_strtree(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_strtree_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_strtree_+3A_node_capacity">node_capacity</code></td>
<td>
<p>The maximum number of child nodes that a node may have.
The minimum recommended capacity value is 4. If unsure, use a
default node capacity of 10.</p>
</td></tr>
<tr><td><code id="geos_strtree_+3A_tree">tree</code></td>
<td>
<p>A <code><a href="#topic+geos_strtree">geos_strtree()</a></code></p>
</td></tr>
<tr><td><code id="geos_strtree_+3A_x">x</code></td>
<td>
<p>An object to convert to a <code><a href="#topic+geos_strtree">geos_strtree()</a></code></p>
</td></tr>
<tr><td><code id="geos_strtree_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A geos_str_tree object
</p>

<hr>
<h2 id='geos_unnest'>Unnest nested geometries</h2><span id='topic+geos_unnest'></span>

<h3>Description</h3>

<p>Ths function flattens nested geometries (i.e., multi or
geometrycollection types) into a vector with the same or fewer levels of
nesting. See <code><a href="#topic+geos_geometry_n">geos_geometry_n()</a></code> to access individual geometries within a
collection; see <code><a href="wk.html#topic+wk_flatten">wk::wk_flatten()</a></code> for a version of this function that
works with non-GEOS geometries; see <code><a href="#topic+geos_make_collection">geos_make_collection()</a></code> and
<code><a href="wk.html#topic+wk_linestring">wk::wk_collection()</a></code> for functions that perform the inverse operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_unnest(geom, keep_empty = FALSE, keep_multi = TRUE, max_depth = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_unnest_+3A_geom">geom</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="geos_unnest_+3A_keep_empty">keep_empty</code></td>
<td>
<p>If <code>TRUE</code>, EMPTY geomtries are left as-is rather than
collapsing to length 0.</p>
</td></tr>
<tr><td><code id="geos_unnest_+3A_keep_multi">keep_multi</code></td>
<td>
<p>If <code>TRUE</code>, MULTI* geometries are not expanded to
sub-features (i.e., only GEOMETRYCOLLECTIONs are).</p>
</td></tr>
<tr><td><code id="geos_unnest_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum recursive GEOMETRYCOLLECTION depth to unnest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a>, with a length
greater than or equal to <code>geom</code> with an attribute &quot;lengths&quot;
that can be used to map elements of the result to the
original item.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_unnest("GEOMETRYCOLLECTION (POINT (1 2), POINT (3 4))")

</code></pre>

<hr>
<h2 id='geos_version'>GEOS version information</h2><span id='topic+geos_version'></span>

<h3>Description</h3>

<p>GEOS version information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_version(runtime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_version_+3A_runtime">runtime</code></td>
<td>
<p>Use FALSE to return the build-time
GEOS version, which may be different than the runtime
version if a different version of the
<a href="libgeos.html#topic+libgeos_version">libgeos package</a> was used to build
this package.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>geos_version()
geos_version(runtime = FALSE)

# check for a minimum version of GEOS
geos_version() &gt;= "3.8.1"

</code></pre>

<hr>
<h2 id='geos-package'>geos: Open Source Geometry Engine ('GEOS') R API</h2><span id='topic+geos'></span><span id='topic+geos-package'></span>

<h3>Description</h3>

<p>Provides an R API to the Open Source Geometry Engine ('GEOS') library (<a href="https://libgeos.org/">https://libgeos.org/</a>) and a vector format with which to efficiently store 'GEOS' geometries. High-performance functions to extract information from, calculate relationships between, and transform geometries are provided. Finally, facilities to import and export geometry vectors to other spatial formats are provided.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dewey Dunnington <a href="mailto:dewey@fishandwhistle.net">dewey@fishandwhistle.net</a> (<a href="https://orcid.org/0000-0002-9415-4582">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Edzer Pebesma <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> (<a href="https://orcid.org/0000-0001-8049-7069">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://paleolimbot.github.io/geos/">https://paleolimbot.github.io/geos/</a>
</p>
</li>
<li> <p><a href="https://github.com/paleolimbot/geos/">https://github.com/paleolimbot/geos/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/paleolimbot/geos/issues">https://github.com/paleolimbot/geos/issues</a>
</p>
</li></ul>


<hr>
<h2 id='plot.geos_geometry'>Plot GEOS geometries</h2><span id='topic+plot.geos_geometry'></span>

<h3>Description</h3>

<p>Plot GEOS geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geos_geometry'
plot(
  x,
  ...,
  asp = 1,
  bbox = NULL,
  xlab = "",
  ylab = "",
  rule = "evenodd",
  add = FALSE,
  simplify = 1,
  crop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.geos_geometry_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+as_geos_geometry">GEOS geometry vector</a></p>
</td></tr>
<tr><td><code id="plot.geos_geometry_+3A_...">...</code></td>
<td>
<p>Passed to plotting functions for features: <code><a href="graphics.html#topic+points">graphics::points()</a></code>
for point and multipoint geometries, <code><a href="graphics.html#topic+lines">graphics::lines()</a></code> for linestring
and multilinestring geometries, and <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code> for polygon
and multipolygon geometries.</p>
</td></tr>
<tr><td><code id="plot.geos_geometry_+3A_asp">asp</code>, <code id="plot.geos_geometry_+3A_xlab">xlab</code>, <code id="plot.geos_geometry_+3A_ylab">ylab</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code></p>
</td></tr>
<tr><td><code id="plot.geos_geometry_+3A_bbox">bbox</code></td>
<td>
<p>The limits of the plot as a <code><a href="wk.html#topic+rct">rct()</a></code> or compatible object</p>
</td></tr>
<tr><td><code id="plot.geos_geometry_+3A_rule">rule</code></td>
<td>
<p>The rule to use for filling polygons (see <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code>)</p>
</td></tr>
<tr><td><code id="plot.geos_geometry_+3A_add">add</code></td>
<td>
<p>Should a new plot be created, or should <code>handleable</code> be added to the
existing plot?</p>
</td></tr>
<tr><td><code id="plot.geos_geometry_+3A_simplify">simplify</code></td>
<td>
<p>A relative tolerance to use for simplification of
geometries. Use 0 to disable simplification; use a higher number
to make simplification coarser.</p>
</td></tr>
<tr><td><code id="plot.geos_geometry_+3A_crop">crop</code></td>
<td>
<p>Use <code>TRUE</code> to crop the input to the extent of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(as_geos_geometry("LINESTRING (0 0, 1 1)"))
plot(as_geos_geometry("POINT (0.5 0.4)"), add = TRUE)

</code></pre>

<hr>
<h2 id='vctrs-methods'>Vctrs methods</h2><span id='topic+vctrs-methods'></span><span id='topic+vec_cast.geos_geometry'></span><span id='topic+vec_ptype2.geos_geometry'></span>

<h3>Description</h3>

<p>Vctrs methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_cast.geos_geometry(x, to, ...)

vec_ptype2.geos_geometry(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vctrs-methods_+3A_x">x</code>, <code id="vctrs-methods_+3A_y">y</code>, <code id="vctrs-methods_+3A_to">to</code>, <code id="vctrs-methods_+3A_...">...</code></td>
<td>
<p>See <code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code> and <code><a href="vctrs.html#topic+vec_ptype2">vctrs::vec_ptype2()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='wk-methods'>Compatibility with the wk package</h2><span id='topic+wk-methods'></span><span id='topic+wk_handle.geos_geometry'></span><span id='topic+geos_geometry_writer'></span><span id='topic+wk_writer.geos_geometry'></span>

<h3>Description</h3>

<p>Compatibility with the wk package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geos_geometry'
wk_handle(handleable, handler, ...)

geos_geometry_writer()

## S3 method for class 'geos_geometry'
wk_writer(handleable, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk-methods_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="wk.html#topic+wkb">wkb()</a></code>, <code><a href="wk.html#topic+wkt">wkt()</a></code>, <code><a href="wk.html#topic+xy">xy()</a></code>,
<code><a href="wk.html#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="wk.html#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk-methods_+3A_handler">handler</code></td>
<td>
<p>A <a href="wk.html#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk-methods_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="wk.html#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the <code>handler</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(wk)
wk_handle(as_geos_geometry("POINT (1 2)"), wk::wkt_writer())

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
