<!DOCTYPE html><html lang="en-GB"><head><title>Help for package vaultr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vaultr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vaultr-package'><p>Vault Client for Secrets and Sensitive Data</p></a></li>
<li><a href='#vault_api_client'><p>Vault Low-Level Client</p></a></li>
<li><a href='#vault_client'><p>Make a vault client</p></a></li>
<li><a href='#vault_client_audit'><p>Vault Audit Devices</p></a></li>
<li><a href='#vault_client_auth'><p>Vault Authentication Configuration</p></a></li>
<li><a href='#vault_client_auth_approle'><p>Vault AppRole Authentication Configuration</p></a></li>
<li><a href='#vault_client_auth_github'><p>Vault GitHub Authentication Configuration</p></a></li>
<li><a href='#vault_client_auth_ldap'><p>Vault LDAP Authentication Configuration</p></a></li>
<li><a href='#vault_client_auth_userpass'><p>Vault Username/Password Authentication Configuration</p></a></li>
<li><a href='#vault_client_cubbyhole'><p>Cubbyhole secret store</p></a></li>
<li><a href='#vault_client_kv1'><p>Key-Value Store (Version 1)</p></a></li>
<li><a href='#vault_client_kv2'><p>Key-Value Store (Version 2)</p></a></li>
<li><a href='#vault_client_object'><p>Base object type</p></a></li>
<li><a href='#vault_client_operator'><p>Vault Administration</p></a></li>
<li><a href='#vault_client_policy'><p>Vault Policy Configuration</p></a></li>
<li><a href='#vault_client_secrets'><p>Vault Secret Configuration</p></a></li>
<li><a href='#vault_client_token'><p>Vault Tokens</p></a></li>
<li><a href='#vault_client_tools'><p>Vault Tools</p></a></li>
<li><a href='#vault_client_transit'><p>Transit Engine</p></a></li>
<li><a href='#vault_resolve_secrets'><p>Resolve secrets from R objects</p></a></li>
<li><a href='#vault_test_server'><p>Control a test vault server</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Vault Client for Secrets and Sensitive Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an interface to a 'HashiCorp' vault server over
  its http API (typically these are self-hosted; see
  <a href="https://www.vaultproject.io">https://www.vaultproject.io</a>).  This allows for secure storage and
  retrieval of secrets over a network, such as tokens, passwords and
  certificates.  Authentication with vault is supported through
  several backends including user name/password and authentication via
  'GitHub'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vimc/vaultr">https://github.com/vimc/vaultr</a>,
<a href="https://www.vaccineimpact.org/vaultr/">https://www.vaccineimpact.org/vaultr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vimc/vaultr/issues">https://github.com/vimc/vaultr/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>vault</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, getPass, httr, jsonlite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mockery, processx, rmarkdown, testthat, withr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-09 11:17:25 UTC; rfitzjoh</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut, cre],
  Robert Ashton [aut],
  Wes Hinsley [aut],
  Imperial College of Science, Technology and Medicine [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rich FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-09 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='vaultr-package'>Vault Client for Secrets and Sensitive Data</h2><span id='topic+vaultr'></span><span id='topic+vaultr-package'></span>

<h3>Description</h3>

<p>Vault client for secrets and sensitive data; this package provides
wrappers for HashiCorp's <a href="https://vaultproject.io">vault server</a>.
The package wraps most of the high-level API, and includes support
for authentication via a number of backends (tokens, username and
password, github, and &quot;AppRole&quot;), as well as a number of secrets
engines (two key-value stores, vault's cubbyhole and the transit
backend for encryption-as-a-service).
</p>


<h3>Details</h3>

<p>To get started, you might want to start with the &quot;vaultr&quot;
vignette, available from the package with <code>vignette("vaultr")</code>.
</p>
<p>The basic design of the package is that it has very few
entrypoints - for most uses one will interact almost entirely with
the <a href="#topic+vault_client">vault_client</a> function.  That function returns an
R6 object with several methods (functions) but also several
objects that themselves contain more methods and objects, creating
a nested tree of functionality.
</p>
<p>From any object, online help is available via the help method, for
example
</p>
<div class="sourceCode"><pre>client &lt;- vaultr::vault_client()
client$secrets$transit$help()
</pre></div>
<p>For testing packages that rely on vault, there is support for
creating temporary vault servers; see <code>vaultr::vault_test_server</code>
and the &quot;packages&quot; vignette.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Rich FitzJohn <a href="mailto:rich.fitzjohn@gmail.com">rich.fitzjohn@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Robert Ashton
</p>
</li>
<li><p> Wes Hinsley
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Imperial College of Science, Technology and Medicine [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/vimc/vaultr">https://github.com/vimc/vaultr</a>
</p>
</li>
<li> <p><a href="https://www.vaccineimpact.org/vaultr/">https://www.vaccineimpact.org/vaultr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/vimc/vaultr/issues">https://github.com/vimc/vaultr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='vault_api_client'>Vault Low-Level Client</h2><span id='topic+vault_api_client'></span>

<h3>Description</h3>

<p>Vault Low-Level Client
</p>
<p>Vault Low-Level Client
</p>


<h3>Details</h3>

<p>Low-level API client.  This can be used to directly communicate
with the vault server.  This object will primarily be useful for
debugging, testing or developing new vault methods, but is
nonetheless described here.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_api_client</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>addr</code></dt><dd><p>The vault address (with protocol, hostname and port)</p>
</dd>
<dt><code>base_url</code></dt><dd><p>The base url (with protocol, hostname, port and
api version path)</p>
</dd>
<dt><code>tls_config</code></dt><dd><p>Information used in TLS config, if used</p>
</dd>
<dt><code>namespace</code></dt><dd><p>The vault namespace, if used</p>
</dd>
<dt><code>token</code></dt><dd><p>The vault token, if authenticated</p>
</dd>
<dt><code>version</code></dt><dd><p>The vault server version, once queried</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_api_client-new"><code>vault_api_client$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-request"><code>vault_api_client$request()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-is_authenticated"><code>vault_api_client$is_authenticated()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-set_token"><code>vault_api_client$set_token()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-verify_token"><code>vault_api_client$verify_token()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-server_version"><code>vault_api_client$server_version()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-GET"><code>vault_api_client$GET()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-LIST"><code>vault_api_client$LIST()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-POST"><code>vault_api_client$POST()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-PUT"><code>vault_api_client$PUT()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_api_client-DELETE"><code>vault_api_client$DELETE()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_api_client-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new api client
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$new(addr = NULL, tls_config = NULL, namespace = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>addr</code></dt><dd><p>Address of the vault server</p>
</dd>
<dt><code>tls_config</code></dt><dd><p>Optional TLS config</p>
</dd>
<dt><code>namespace</code></dt><dd><p>Optional namespace</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_api_client-request"></a>



<h4>Method <code>request()</code></h4>

<p>Make a request to the api. Typically you should use
one of the higher-level wrappers, such as <code style="white-space: pre;">&#8288;$GET&#8288;</code> or <code style="white-space: pre;">&#8288;$POST&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$request(verb, path, ..., token = self$token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verb</code></dt><dd><p>The HTTP verb to use, as a <code>httr</code> function (e.g.,
pass <code>httr::GET</code> for a <code>GET</code> request).</p>
</dd>
<dt><code>path</code></dt><dd><p>The request path</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments passed to the <code>httr</code> function</p>
</dd>
<dt><code>token</code></dt><dd><p>Optional token, overriding the client token</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_api_client-is_authenticated"></a>



<h4>Method <code>is_authenticated()</code></h4>

<p>Test if the vault client currently holds a vault token.
This method does not verify the token - only test that is present.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$is_authenticated()</pre></div>


<hr>
<a id="method-vault_api_client-set_token"></a>



<h4>Method <code>set_token()</code></h4>

<p>Set a token within the client
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$set_token(token, verify = FALSE, quiet = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>String, with the new vault client token</p>
</dd>
<dt><code>verify</code></dt><dd><p>Logical, indicating if we should test that the token
is valid. If <code>TRUE</code>, then we use <code style="white-space: pre;">&#8288;$verify_token()&#8288;</code> to test the
token before setting it and if it is not valid an error will be
thrown and the token not set.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>Logical, if <code>TRUE</code>, then informational messages will be
suppressed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_api_client-verify_token"></a>



<h4>Method <code>verify_token()</code></h4>

<p>Test that a token is valid with the vault.
This will call vault's <code style="white-space: pre;">&#8288;/sys/capabilities-self&#8288;</code> endpoint with the
token provided and check the <code style="white-space: pre;">&#8288;/sys&#8288;</code> path.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$verify_token(token, quiet = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>String, with the vault client token to test</p>
</dd>
<dt><code>quiet</code></dt><dd><p>Logical, if <code>TRUE</code>, then informational messages will be
suppressed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_api_client-server_version"></a>



<h4>Method <code>server_version()</code></h4>

<p>Retrieve the vault server version.  This is by default
cached within the client for a session.  Will return an R
<a href="base.html#topic+numeric_version">numeric_version</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$server_version(refresh = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>refresh</code></dt><dd><p>Logical, indicating if the server version information
should be refreshed even if known.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_api_client-GET"></a>



<h4>Method <code>GET()</code></h4>

<p>Send a <code>GET</code> request to the vault server
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$GET(path, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The server path to use.  This is the &quot;interesting&quot;
part of the path only, with the server base url and api version
information added.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional <code>httr</code>-compatible options.  These will be named
parameters or <code>httr</code> &quot;request&quot; objects.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_api_client-LIST"></a>



<h4>Method <code>LIST()</code></h4>

<p>Send a <code>LIST</code> request to the vault server
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$LIST(path, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The server path to use.  This is the &quot;interesting&quot;
part of the path only, with the server base url and api version
information added.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional <code>httr</code>-compatible options.  These will be named
parameters or <code>httr</code> &quot;request&quot; objects.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_api_client-POST"></a>



<h4>Method <code>POST()</code></h4>

<p>Send a <code>POST</code> request to the vault server
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$POST(path, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The server path to use.  This is the &quot;interesting&quot;
part of the path only, with the server base url and api version
information added.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional <code>httr</code>-compatible options.  These will be named
parameters or <code>httr</code> &quot;request&quot; objects.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_api_client-PUT"></a>



<h4>Method <code>PUT()</code></h4>

<p>Send a <code>PUT</code> request to the vault server
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$PUT(path, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The server path to use.  This is the &quot;interesting&quot;
part of the path only, with the server base url and api version
information added.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional <code>httr</code>-compatible options.  These will be named
parameters or <code>httr</code> &quot;request&quot; objects.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_api_client-DELETE"></a>



<h4>Method <code>DELETE()</code></h4>

<p>Send a <code>DELETE</code> request to the vault server
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_api_client$DELETE(path, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The server path to use.  This is the &quot;interesting&quot;
part of the path only, with the server base url and api version
information added.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional <code>httr</code>-compatible options.  These will be named
parameters or <code>httr</code> &quot;request&quot; objects.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  # Ordinarily, we would use the "vault_client" object for
  # high-level access to the vault server
  client &lt;- server$client()
  client$status()

  # The api() method returns the "api client" object:
  api &lt;- client$api()
  api

  # This allows running arbitrary HTTP requests against the server:
  api$GET("/sys/seal-status")

  # this is how vaultr is internally implemented so anything can
  # be done here, for example following vault's API documentation
  # https://www.vaultproject.io/api/secret/kv/kv-v1.html#sample-request-2
  api$POST("/secret/mysecret", body = list(key = "value"))
  api$GET("/secret/mysecret")
  api$DELETE("/secret/mysecret")

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client'>Make a vault client</h2><span id='topic+vault_client'></span><span id='topic+vault_client_'></span>

<h3>Description</h3>

<p>Make a vault client.  This must be done before accessing the
vault.  The default values for arguments are controlled by
environment variables (see Details) and values provided as
arguments override these defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vault_client(
  login = FALSE,
  ...,
  addr = NULL,
  tls_config = NULL,
  namespace = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vault_client_+3A_login">login</code></td>
<td>
<p>Login method.  Specify a string to be passed along as
the <code>method</code> argument to <code style="white-space: pre;">&#8288;$login&#8288;</code>.  The default
<code>FALSE</code> means not to login.  <code>TRUE</code> means to login
using a default method specified by the environment variable
<code>VAULTR_AUTH_METHOD</code> - if that variable is not set, an
error is thrown.  The value of <code>NULL</code> is the same as
<code>TRUE</code> but does not throw an error if
<code>VAULTR_AUTH_METHOD</code> is not set.  Supported methods are
<code>token</code>, <code>github</code>, <code>approle</code>, <code>ldap</code>, and <code>userpass</code>.</p>
</td></tr>
<tr><td><code id="vault_client_+3A_...">...</code></td>
<td>
<p>Additional arguments passed along to the authentication
method indicated by <code>login</code>, if used.</p>
</td></tr>
<tr><td><code id="vault_client_+3A_addr">addr</code></td>
<td>
<p>The vault address <em>including protocol and port</em>,
e.g., <code style="white-space: pre;">&#8288;https://vault.example.com:8200&#8288;</code>.  If not given, the
default is the environment variable <code>VAULT_ADDR</code>, which is
the same as used by vault's command line client.</p>
</td></tr>
<tr><td><code id="vault_client_+3A_tls_config">tls_config</code></td>
<td>
<p>TLS (https) configuration.  For most uses this
can be left blank.  However, if your vault server uses a
self-signed certificate you will need to provide this.  Defaults
to the environment variable <code>VAULT_CAPATH</code>, which is the
same as vault's command line client.</p>
</td></tr>
<tr><td><code id="vault_client_+3A_namespace">namespace</code></td>
<td>
<p>A vault namespace, when using enterprise
vault. If given, then this must be a string, and your vault must
support namespaces, which is an enterprise feature. If the
environment variable <code>VAULT_NAMESPACE</code> is set, we use that
namespace when <code>NULL</code> is provided as an argument (this is the
same variable as used by vault's command line client).</p>
</td></tr>
</table>


<h3>Environment variables</h3>

<p>The creation of a client is affected by a number of environment
variables, following the main vault command line client.
</p>

<ul>
<li> <p><code>VAULT_ADDR</code>: The url of the vault server.  Must
include a protocol (most likely <code style="white-space: pre;">&#8288;https://&#8288;</code> but in testing
<code style="white-space: pre;">&#8288;http://&#8288;</code> might be used)
</p>
</li>
<li> <p><code>VAULT_CAPATH</code>: The path to CA certificates
</p>
</li>
<li> <p><code>VAULT_TOKEN</code>: A vault token to use in authentication.
Only used for token-based authentication
</p>
</li>
<li> <p><code>VAULT_AUTH_GITHUB_TOKEN</code>: As for the command line
client, a github token for authentication using the github
authentication backend
</p>
</li>
<li> <p><code>VAULTR_AUTH_METHOD</code>: The method to use for
authentication
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>auth</code></dt><dd><p>Authentication backends: <a href="#topic+vault_client_auth">vault_client_auth</a></p>
</dd>
<dt><code>audit</code></dt><dd><p>Audit methods: <a href="#topic+vault_client_audit">vault_client_audit</a></p>
</dd>
<dt><code>cubbyhole</code></dt><dd><p>The vault cubbyhole key-value store:
<a href="#topic+vault_client_cubbyhole">vault_client_cubbyhole</a></p>
</dd>
<dt><code>operator</code></dt><dd><p>Operator methods: <a href="#topic+vault_client_operator">vault_client_operator</a></p>
</dd>
<dt><code>policy</code></dt><dd><p>Policy methods: <a href="#topic+vault_client_policy">vault_client_policy</a></p>
</dd>
<dt><code>secrets</code></dt><dd><p>Secret backends: <a href="#topic+vault_client_secrets">vault_client_secrets</a></p>
</dd>
<dt><code>token</code></dt><dd><p>Token methods: <a href="#topic+vault_client_token">vault_client_token</a></p>
</dd>
<dt><code>tools</code></dt><dd><p>Vault tools: <a href="#topic+vault_client_tools">vault_client_tools</a></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client-new"><code>vault_client_$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client-api"><code>vault_client_$api()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client-read"><code>vault_client_$read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client-write"><code>vault_client_$write()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client-delete"><code>vault_client_$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client-list"><code>vault_client_$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client-login"><code>vault_client_$login()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client-status"><code>vault_client_$status()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client-unwrap"><code>vault_client_$unwrap()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client-wrap_lookup"><code>vault_client_$wrap_lookup()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new vault client. Not typically called
directly, but via the <code>vault_client</code> method.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$new(addr, tls_config, namespace)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>addr</code></dt><dd><p>The vault address, including protocol and port</p>
</dd>
<dt><code>tls_config</code></dt><dd><p>The TLS config, if used</p>
</dd>
<dt><code>namespace</code></dt><dd><p>The namespace, if used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client-api"></a>



<h4>Method <code>api()</code></h4>

<p>Returns an api client object that can be used to
directly interact with the vault server.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$api()</pre></div>


<hr>
<a id="method-vault_client-read"></a>



<h4>Method <code>read()</code></h4>

<p>Read a value from the vault.  This can be used to
read any value that you have permission to read, and can also
be used as an interface to a version 1 key-value store (see
<a href="#topic+vault_client_kv1">vault_client_kv1</a>.  Similar to the vault CLI command
<code style="white-space: pre;">&#8288;vault read&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$read(path, field = NULL, metadata = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path for the secret to read, such as
<code style="white-space: pre;">&#8288;/secret/mysecret&#8288;</code></p>
</dd>
<dt><code>field</code></dt><dd><p>Optional field to read from the secret.  Each
secret is stored as a key/value set (represented in R as a
named list) and this is equivalent to using <code style="white-space: pre;">&#8288;[[field]]&#8288;</code> on
the return value.  The default, <code>NULL</code>, returns the full set
of values.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>Logical, indicating if we should return
metadata for this secret (lease information etc) as an
attribute along with the values itself.  Ignored if <code>field</code>
is specified.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client-write"></a>



<h4>Method <code>write()</code></h4>

<p>Write data into the vault.  This can be used to
write any value that you have permission to write, and can
also be used as an interface to a version 1 key-value store
(see <a href="#topic+vault_client_kv1">vault_client_kv1</a>.  Similar to the vault CLI
command <code style="white-space: pre;">&#8288;vault write&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$write(path, data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path for the secret to write, such as
<code style="white-space: pre;">&#8288;/secret/mysecret&#8288;</code></p>
</dd>
<dt><code>data</code></dt><dd><p>A named list of values to write into the vault at
this path.  This <em>replaces</em> any existing values.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Delete a value from the vault
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$delete(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The path to delete</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client-list"></a>



<h4>Method <code>list()</code></h4>

<p>List data in the vault at a given path.  This can
be used to list keys, etc (e.g., at <code style="white-space: pre;">&#8288;/secret&#8288;</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$list(path, full_names = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The path to list</p>
</dd>
<dt><code>full_names</code></dt><dd><p>Logical, indicating if full paths (relative
to the vault root) should be returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A character vector (of zero length if no keys are
found).  Paths that are &quot;directories&quot; (i.e., that contain
keys and could themselves be listed) will be returned with a
trailing forward slash, e.g. <code style="white-space: pre;">&#8288;path/&#8288;</code>
</p>


<hr>
<a id="method-vault_client-login"></a>



<h4>Method <code>login()</code></h4>

<p>Login to the vault.  This method is more
complicated than most.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$login(
  ...,
  method = "token",
  mount = NULL,
  renew = FALSE,
  quiet = FALSE,
  token_only = FALSE,
  use_cache = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional named parameters passed through to the
underlying method</p>
</dd>
<dt><code>method</code></dt><dd><p>Authentication method to use, as a string.
Supported values include <code>token</code> (the default), <code>github</code>,
<code>approle</code>, <code>ldap</code>, and <code>userpass</code>.</p>
</dd>
<dt><code>mount</code></dt><dd><p>The mount path for the authentication backend, <em>if
it has been mounted in a nonstandard location</em>.  If not
given, then it is assumed that the backend was mounted at a
path corresponding to the method name.</p>
</dd>
<dt><code>renew</code></dt><dd><p>Login, even if we appear to hold a valid token.
If <code>FALSE</code> and we have a token then <code>login</code> does nothing.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>Suppress some informational messages</p>
</dd>
<dt><code>token_only</code></dt><dd><p>Logical, indicating that we do not want to
actually log in, but instead just generate a token and return
that.  IF given then <code>renew</code> is ignored and we always
generate a new token.</p>
</dd>
<dt><code>use_cache</code></dt><dd><p>Logical, indicating if we should look in the
session cache for a token for this client.  If this is <code>TRUE</code>
then when we log in we save a copy of the token for this
session and any subsequent calls to <code>login</code> at this vault
address that use <code>use_cache = TRUE</code> will be able to use this
token.  Using cached tokens will make using some
authentication backends that require authentication with
external resources (e.g., <code>github</code>) much faster.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client-status"></a>



<h4>Method <code>status()</code></h4>

<p>Return the status of the vault server, including
whether it is sealed or not, and the vault server version.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$status()</pre></div>


<hr>
<a id="method-vault_client-unwrap"></a>



<h4>Method <code>unwrap()</code></h4>

<p>Returns the original response inside the given
wrapping token. The vault endpoints used by this method
perform validation checks on the token, returns the original
value on the wire rather than a JSON string representation of
it, and ensures that the response is properly audit-logged.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$unwrap(token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>Specifies the wrapping token ID</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client-wrap_lookup"></a>



<h4>Method <code>wrap_lookup()</code></h4>

<p>Look up properties of a wrapping token.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_$wrap_lookup(token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>Specifies the wrapping token ID to lookup</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Rich FitzJohn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# We work with a test vault server here (see ?vault_test_server) for
# details.  To use it, you must have a vault binary installed on your
# system.  These examples will not affect any real running vault
# instance that you can connect to.
server &lt;- vaultr::vault_test_server(if_disabled = message)

if (!is.null(server)) {
  # Create a vault_client object by providing the address of the vault
  # server.
  client &lt;- vaultr::vault_client(addr = server$addr)

  # The client has many methods, grouped into a structure:
  client

  # For example, token related commands:
  client$token

  # The client is not authenticated by default:
  try(client$list("/secret"))

  # A few methods are unauthenticated and can still be run
  client$status()

  # Login to the vault, using the token that we know from the server -
  # ordinarily you would use a login approach suitable for your needs
  # (see the vault documentation).
  token &lt;- server$token
  client$login(method = "token", token = token)

  # The vault contains no secrets at present
  client$list("/secret")

  # Secrets can contain any (reasonable) number of key-value pairs,
  # passed in as a list
  client$write("/secret/users/alice", list(password = "s3cret!"))

  # The whole list can be read out
  client$read("/secret/users/alice")
  # ...or just a field
  client$read("/secret/users/alice", "password")

  # Reading non-existant values returns NULL, not an error
  client$read("/secret/users/bob")

  client$delete("/secret/users/alice")
}
</code></pre>

<hr>
<h2 id='vault_client_audit'>Vault Audit Devices</h2><span id='topic+vault_client_audit'></span>

<h3>Description</h3>

<p>Vault Audit Devices
</p>
<p>Vault Audit Devices
</p>


<h3>Details</h3>

<p>Interact with vault's audit devices.  For more details, see
https://developer.hashicorp.com/vault/docs/audit
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_audit</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_audit-new"><code>vault_client_audit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_audit-list"><code>vault_client_audit$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_audit-enable"><code>vault_client_audit$enable()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_audit-disable"><code>vault_client_audit$disable()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_audit-hash"><code>vault_client_audit$hash()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_audit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an audit object
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_audit$new(api_client)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>a <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_audit-list"></a>



<h4>Method <code>list()</code></h4>

<p>List active audit devices.  Returns a <a href="base.html#topic+data.frame">data.frame</a>
of names, paths and descriptions of active audit devices.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_audit$list()</pre></div>


<hr>
<a id="method-vault_client_audit-enable"></a>



<h4>Method <code>enable()</code></h4>

<p>This endpoint enables a new audit device at the
supplied path.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_audit$enable(
  type,
  description = NULL,
  options = NULL,
  path = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>Name of the audit device to enable</p>
</dd>
<dt><code>description</code></dt><dd><p>Human readable description for this audit device</p>
</dd>
<dt><code>options</code></dt><dd><p>Options to configure the device with.  These vary
by device. This must be a named list of strings.</p>
</dd>
<dt><code>path</code></dt><dd><p>Path to mount the audit device.  By default, <code>type</code> is used
as the path.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_audit-disable"></a>



<h4>Method <code>disable()</code></h4>

<p>Disable an audit device
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_audit$disable(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path of the audit device to remove</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_audit-hash"></a>



<h4>Method <code>hash()</code></h4>

<p>The <code>hash</code> method is used to calculate the hash of the
data used by an audit device's hash function and salt. This can be
used to search audit logs for a hashed value when the original
value is known.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_audit$hash(input, device)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input</code></dt><dd><p>The input string to hash</p>
</dd>
<dt><code>device</code></dt><dd><p>The path of the audit device</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()
  # By default no audit engines are enabled with the testing server
  client$audit$list()

  # Create a file-based audit device on a temporary file:
  path &lt;- tempfile()
  client$audit$enable("file", options = list(file_path = path))
  client$audit$list()

  # Generate some activity on the server:
  client$write("/secret/mysecret", list(key = "value"))

  # The audit logs contain details about the activity - see the
  # vault documentation for details in interpreting this
  readLines(path)

  # cleanup
  server$kill()
  unlink(path)
}
</code></pre>

<hr>
<h2 id='vault_client_auth'>Vault Authentication Configuration</h2><span id='topic+vault_client_auth'></span>

<h3>Description</h3>

<p>Vault Authentication Configuration
</p>
<p>Vault Authentication Configuration
</p>


<h3>Details</h3>

<p>Interact with vault's authentication backends.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_auth</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>approle</code></dt><dd><p>Interact with vault's AppRole authentication.  See
<code><a href="#topic+vault_client_auth_approle">vault_client_auth_approle</a></code> for more information.</p>
</dd>
<dt><code>github</code></dt><dd><p>Interact with vault's GitHub authentication.  See
<code><a href="#topic+vault_client_auth_github">vault_client_auth_github</a></code> for more information.</p>
</dd>
<dt><code>token</code></dt><dd><p>Interact with vault's token authentication.  See
<code><a href="#topic+vault_client_token">vault_client_token</a></code> for more information.</p>
</dd>
<dt><code>userpass</code></dt><dd><p>Interact with vault's username/password based
authentication.  See <code><a href="#topic+vault_client_auth_userpass">vault_client_auth_userpass</a></code> for
more information.</p>
</dd>
<dt><code>ldap</code></dt><dd><p>Interact with vault's LDAP based
authentication.  See <code><a href="#topic+vault_client_auth_ldap">vault_client_auth_ldap</a></code> for
more information.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_auth-new"><code>vault_client_auth$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth-backends"><code>vault_client_auth$backends()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth-list"><code>vault_client_auth$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth-enable"><code>vault_client_auth$enable()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth-disable"><code>vault_client_auth$disable()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_auth-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_auth</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth$new(api_client)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth-backends"></a>



<h4>Method <code>backends()</code></h4>

<p>Return a character vector of supported
authentication backends.  If a backend <code>x</code> is present, then
you can access it with <code style="white-space: pre;">&#8288;$auth$x&#8288;</code>.  Note that vault calls
these authentication <em>methods</em> but we use <em>backends</em> here to
differentiate with R6 methods.  Note that these are backends
supported by <code>vaultr</code> and not necessarily supported by the
server - the server may not have enabled some of these
backends, and may support other authentication backends not
directly supported by vaultr.  See the <code style="white-space: pre;">&#8288;$list()&#8288;</code> method to
query what the server supports.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth$backends()</pre></div>


<hr>
<a id="method-vault_client_auth-list"></a>



<h4>Method <code>list()</code></h4>

<p>List authentication backends supported by the
vault server, including information about where these
backends are mounted.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth$list(detailed = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>detailed</code></dt><dd><p>Logical, indicating if detailed information
should be returned</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth-enable"></a>



<h4>Method <code>enable()</code></h4>

<p>Enable an authentication backend in the vault
server.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth$enable(type, description = NULL, local = FALSE, path = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>The type of authentication backend (e.g.,
<code>userpass</code>, <code>github</code>, <code>ldap</code>)</p>
</dd>
<dt><code>description</code></dt><dd><p>Human-friendly description of the backend;
will be returned by <code style="white-space: pre;">&#8288;$list()&#8288;</code></p>
</dd>
<dt><code>local</code></dt><dd><p>Specifies if the auth method is local only. Local
auth methods are not replicated nor (if a secondary) removed
by replication.</p>
</dd>
<dt><code>path</code></dt><dd><p>Specifies the path in which to enable the auth
method. Defaults to be the same as <code>type</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth-disable"></a>



<h4>Method <code>disable()</code></h4>

<p>Disable an active authentication backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth$disable(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The path of the authentication backend to disable.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()

  # List configured authentication backends
  client$auth$list()

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client_auth_approle'>Vault AppRole Authentication Configuration</h2><span id='topic+vault_client_auth_approle'></span>

<h3>Description</h3>

<p>Vault AppRole Authentication Configuration
</p>
<p>Vault AppRole Authentication Configuration
</p>


<h3>Details</h3>

<p>Interact with vault's AppRole authentication backend.  For more
details about this, see the vault documentation at
https://developer.hashicorp.com/vault/docs/auth/approle
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_auth_approle</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_auth_approle-new"><code>vault_client_auth_approle$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-custom_mount"><code>vault_client_auth_approle$custom_mount()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-role_list"><code>vault_client_auth_approle$role_list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-role_write"><code>vault_client_auth_approle$role_write()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-role_read"><code>vault_client_auth_approle$role_read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-role_delete"><code>vault_client_auth_approle$role_delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-role_id_read"><code>vault_client_auth_approle$role_id_read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-role_id_write"><code>vault_client_auth_approle$role_id_write()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-secret_id_generate"><code>vault_client_auth_approle$secret_id_generate()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-secret_id_list"><code>vault_client_auth_approle$secret_id_list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-secret_id_read"><code>vault_client_auth_approle$secret_id_read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-secret_id_delete"><code>vault_client_auth_approle$secret_id_delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_approle-login"><code>vault_client_auth_approle$login()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_auth_approle-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_approle</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$new(api_client, mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
<dt><code>mount</code></dt><dd><p>Mount point for the backend</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-custom_mount"></a>



<h4>Method <code>custom_mount()</code></h4>

<p>Set up a <code>vault_client_auth_approle</code> object at a
custom mount. For example, suppose you mounted the <code>approle</code>
authentication backend at <code style="white-space: pre;">&#8288;/approle-dev&#8288;</code> you might use <code>ar &lt;- vault$auth$approle2$custom_mount("/approle-dev")</code> - this pattern
is repeated for other secret and authentication backends.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$custom_mount(mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mount</code></dt><dd><p>String, indicating the path that the engine is mounted at.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-role_list"></a>



<h4>Method <code>role_list()</code></h4>

<p>This endpoint returns a list the existing AppRoles in the method.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$role_list()</pre></div>


<hr>
<a id="method-vault_client_auth_approle-role_write"></a>



<h4>Method <code>role_write()</code></h4>

<p>Creates a new AppRole or updates an existing AppRole. This
endpoint supports both create and update capabilities. There can
be one or more constraints enabled on the role. It is required to
have at least one of them enabled while creating or updating a
role.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$role_write(
  role_name,
  bind_secret_id = NULL,
  secret_id_bound_cidrs = NULL,
  token_bound_cidrs = NULL,
  policies = NULL,
  secret_id_num_uses = NULL,
  secret_id_ttl = NULL,
  token_num_uses = NULL,
  token_ttl = NULL,
  token_max_ttl = NULL,
  period = NULL,
  enable_local_secret_ids = NULL,
  token_type = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name of the AppRole</p>
</dd>
<dt><code>bind_secret_id</code></dt><dd><p>Require secret_id to be presented when
logging in using this AppRole (boolean, default is <code>TRUE</code>).</p>
</dd>
<dt><code>secret_id_bound_cidrs</code></dt><dd><p>Character vector of CIDR blocks;
if set, specifies blocks of IP addresses which can perform
the login operation.</p>
</dd>
<dt><code>token_bound_cidrs</code></dt><dd><p>Character vector of if set, specifies
blocks of IP addresses which can use the auth tokens
generated by this role.</p>
</dd>
<dt><code>policies</code></dt><dd><p>Character vector of policies set on tokens
issued via this AppRole.</p>
</dd>
<dt><code>secret_id_num_uses</code></dt><dd><p>Number of times any particular
SecretID can be used to fetch a token from this AppRole,
after which the SecretID will expire. A value of zero will
allow unlimited uses.</p>
</dd>
<dt><code>secret_id_ttl</code></dt><dd><p>Duration, after which any SecretID expires.</p>
</dd>
<dt><code>token_num_uses</code></dt><dd><p>Number of times issued tokens can be
used. A value of 0 means unlimited uses</p>
</dd>
<dt><code>token_ttl</code></dt><dd><p>Duration to set as the TTL for issued tokens
and at renewal time.</p>
</dd>
<dt><code>token_max_ttl</code></dt><dd><p>Duration, after which the issued token can
no longer be renewed.</p>
</dd>
<dt><code>period</code></dt><dd><p>A duration; when set, the token generated using
this AppRole is a periodic token; so long as it is renewed it
never expires, but the TTL set on the token at each renewal
is fixed to the value specified here. If this value is
modified, the token will pick up the new value at its next
renewal.</p>
</dd>
<dt><code>enable_local_secret_ids</code></dt><dd><p>Boolean, if <code>TRUE</code>, then the
secret IDs generated using this role will be cluster
local. This can only be set during role creation and once
set, it can't be reset later.</p>
</dd>
<dt><code>token_type</code></dt><dd><p>The type of token that should be generated
via this role. Can be <code>service</code>, <code>batch</code>, or <code>default</code> to use
the mount's default (which unless changed will be service
tokens).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-role_read"></a>



<h4>Method <code>role_read()</code></h4>

<p>Reads the properties of an existing AppRole.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$role_read(role_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name of the AppRole</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-role_delete"></a>



<h4>Method <code>role_delete()</code></h4>

<p>Deletes an existing AppRole from the method.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$role_delete(role_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name of the AppRole to delete</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-role_id_read"></a>



<h4>Method <code>role_id_read()</code></h4>

<p>Reads the RoleID of an existing AppRole.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$role_id_read(role_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name of the AppRole</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-role_id_write"></a>



<h4>Method <code>role_id_write()</code></h4>

<p>Updates the RoleID of an existing AppRole to a
custom value.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$role_id_write(role_name, role_id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name of the AppRole (string)</p>
</dd>
<dt><code>role_id</code></dt><dd><p>Value to be set as RoleID (string)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-secret_id_generate"></a>



<h4>Method <code>secret_id_generate()</code></h4>

<p>Generates and issues a new SecretID on an existing
AppRole. Similar to tokens, the response will also contain a
<code>secret_id_accessor</code> value which can be used to read the
properties of the SecretID without divulging the SecretID
itself, and also to delete the SecretID from the AppRole.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$secret_id_generate(
  role_name,
  metadata = NULL,
  cidr_list = NULL,
  token_bound_cidrs = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name of the AppRole.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>Metadata to be tied to the SecretID. This
should be a named list of key-value pairs. This metadata will
be set on tokens issued with this SecretID, and is logged in
audit logs in plaintext.</p>
</dd>
<dt><code>cidr_list</code></dt><dd><p>Character vector CIDR blocks enforcing secret
IDs to be used from specific set of IP addresses. If
<code>bound_cidr_list</code> is set on the role, then the list of CIDR
blocks listed here should be a subset of the CIDR blocks
listed on the role.</p>
</dd>
<dt><code>token_bound_cidrs</code></dt><dd><p>Character vector of CIDR blocks; if
set, specifies blocks of IP addresses which can use the auth
tokens generated by this SecretID. Overrides any role-set
value but must be a subset.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-secret_id_list"></a>



<h4>Method <code>secret_id_list()</code></h4>

<p>Lists the accessors of all the SecretIDs issued
against the AppRole. This includes the accessors for &quot;custom&quot;
SecretIDs as well.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$secret_id_list(role_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name of the AppRole</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-secret_id_read"></a>



<h4>Method <code>secret_id_read()</code></h4>

<p>Reads out the properties of a SecretID.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$secret_id_read(
  role_name,
  secret_id,
  accessor = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name of the AppRole</p>
</dd>
<dt><code>secret_id</code></dt><dd><p>Secret ID attached to the role</p>
</dd>
<dt><code>accessor</code></dt><dd><p>Logical, if <code>TRUE</code>, treat <code>secret_id</code> as an
accessor rather than a secret id.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-secret_id_delete"></a>



<h4>Method <code>secret_id_delete()</code></h4>

<p>Delete an AppRole secret ID
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$secret_id_delete(
  role_name,
  secret_id,
  accessor = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name of the AppRole</p>
</dd>
<dt><code>secret_id</code></dt><dd><p>Secret ID attached to the role</p>
</dd>
<dt><code>accessor</code></dt><dd><p>Logical, if <code>TRUE</code>, treat <code>secret_id</code> as an
accessor rather than a secret id.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_approle-login"></a>



<h4>Method <code>login()</code></h4>

<p>Log into the vault using AppRole authentication.
Normally you would not call this directly but instead use
<code style="white-space: pre;">&#8288;$login&#8288;</code> with <code>method = "approle"</code> and proving the <code>role_id</code>
and <code>secret_id</code> arguments.  This function returns a vault
token but does not set it as the client token.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_approle$login(role_id, secret_id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_id</code></dt><dd><p>RoleID of the AppRole</p>
</dd>
<dt><code>secret_id</code></dt><dd><p>SecretID belonging to AppRole</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
vaultr::vault_client(addr = "https://localhost:8200")$auth$approle
</code></pre>

<hr>
<h2 id='vault_client_auth_github'>Vault GitHub Authentication Configuration</h2><span id='topic+vault_client_auth_github'></span>

<h3>Description</h3>

<p>Vault GitHub Authentication Configuration
</p>
<p>Vault GitHub Authentication Configuration
</p>


<h3>Details</h3>

<p>Interact with vault's GitHub authentication backend.  For more
details, please see the vault documentation at
https://developer.hashicorp.com/vault/docs/auth/github
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_auth_github</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_auth_github-new"><code>vault_client_auth_github$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_github-custom_mount"><code>vault_client_auth_github$custom_mount()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_github-configure"><code>vault_client_auth_github$configure()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_github-configuration"><code>vault_client_auth_github$configuration()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_github-write"><code>vault_client_auth_github$write()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_github-read"><code>vault_client_auth_github$read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_github-login"><code>vault_client_auth_github$login()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_auth_github-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_github</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_github$new(api_client, mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
<dt><code>mount</code></dt><dd><p>Mount point for the backend</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_github-custom_mount"></a>



<h4>Method <code>custom_mount()</code></h4>

<p>Set up a <code>vault_client_auth_github</code> object at a
custom mount.  For example, suppose you mounted the <code>github</code>
authentication backend at <code style="white-space: pre;">&#8288;/github-myorg&#8288;</code> you might use <code>gh &lt;- vault$auth$github2$custom_mount("/github-myorg")</code> - this
pattern is repeated for other secret and authentication
backends.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_github$custom_mount(mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mount</code></dt><dd><p>String, indicating the path that the engine is
mounted at.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_github-configure"></a>



<h4>Method <code>configure()</code></h4>

<p>Configures the connection parameters for
GitHub-based authentication.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_github$configure(
  organization,
  base_url = NULL,
  ttl = NULL,
  max_ttl = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>organization</code></dt><dd><p>The organization users must be part of
(note American spelling).</p>
</dd>
<dt><code>base_url</code></dt><dd><p>The API endpoint to
use. Useful if you are running GitHub Enterprise or an
API-compatible authentication server.</p>
</dd>
<dt><code>ttl</code></dt><dd><p>Duration after which authentication will be expired</p>
</dd>
<dt><code>max_ttl</code></dt><dd><p>Maximum duration after which authentication will
be expired</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_github-configuration"></a>



<h4>Method <code>configuration()</code></h4>

<p>Reads the connection parameters for GitHub-based
authentication.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_github$configuration()</pre></div>


<hr>
<a id="method-vault_client_auth_github-write"></a>



<h4>Method <code>write()</code></h4>

<p>Write a mapping between a GitHub team or user and
a set of vault policies.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_github$write(team_name, policies, user = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>team_name</code></dt><dd><p>String, with the GitHub team name</p>
</dd>
<dt><code>policies</code></dt><dd><p>A character vector of vault policies that this
user or team will have for vault access if they match this
team or user.</p>
</dd>
<dt><code>user</code></dt><dd><p>Scalar logical - if <code>TRUE</code>, then <code>team_name</code> is
interpreted as a <em>user</em> instead.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_github-read"></a>



<h4>Method <code>read()</code></h4>

<p>Write a mapping between a GitHub team or user and
a set of vault policies.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_github$read(team_name, user = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>team_name</code></dt><dd><p>String, with the GitHub team name</p>
</dd>
<dt><code>user</code></dt><dd><p>Scalar logical - if <code>TRUE</code>, then <code>team_name</code> is
interpreted as a <em>user</em> instead.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_github-login"></a>



<h4>Method <code>login()</code></h4>

<p>Log into the vault using GitHub authentication.
Normally you would not call this directly but instead use
<code style="white-space: pre;">&#8288;$login&#8288;</code> with <code>method = "github"</code> and proving the <code>token</code>
argument.  This function returns a vault token but does not
set it as the client token.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_github$login(token = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>A GitHub token to authenticate with.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>server &lt;- vaultr::vault_test_server(if_disabled = message)
token &lt;- Sys.getenv("VAULT_TEST_AUTH_GITHUB_TOKEN")
if (!is.null(server) &amp;&amp; nzchar(token)) {
  client &lt;- server$client()

  client$auth$enable("github")
  # To enable login for members of the organisation "example":
  client$auth$github$configure(organization = "example")
  # To map members of the "robots" team *within* that organisation
  # to the "defaut" policy:
  client$auth$github$write("development", "default")

  # Once configured like this, if we have a PAT for a member of
  # the "development" team saved as an environment variable
  # "VAULT_AUTH_GITHUB_TOKEN" then doing
  #
  #   vaultr::vault_client(addr = ..., login = "github")
  #
  # will contact GitHub to verify the user token and vault will
  # then issue a client token

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client_auth_ldap'>Vault LDAP Authentication Configuration</h2><span id='topic+vault_client_auth_ldap'></span>

<h3>Description</h3>

<p>Vault LDAP Authentication Configuration
</p>
<p>Vault LDAP Authentication Configuration
</p>


<h3>Details</h3>

<p>Interact with vault's LDAP authentication backend.  This backend
can be used to configure users based on their presence or group
membership in an LDAP server.  For more information, please see
the vault documentation
https://developer.hashicorp.com/vault/docs/auth/ldap
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_auth_ldap</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_auth_ldap-new"><code>vault_client_auth_ldap$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_ldap-custom_mount"><code>vault_client_auth_ldap$custom_mount()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_ldap-configure"><code>vault_client_auth_ldap$configure()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_ldap-configuration"><code>vault_client_auth_ldap$configuration()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_ldap-write"><code>vault_client_auth_ldap$write()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_ldap-read"><code>vault_client_auth_ldap$read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_ldap-list"><code>vault_client_auth_ldap$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_ldap-delete"><code>vault_client_auth_ldap$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_ldap-login"><code>vault_client_auth_ldap$login()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_auth_ldap-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_auth_ldap</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_ldap$new(api_client, mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
<dt><code>mount</code></dt><dd><p>Mount point for the backend</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_ldap-custom_mount"></a>



<h4>Method <code>custom_mount()</code></h4>

<p>Set up a <code>vault_client_auth_ldap</code> object at a
custom mount. For example, suppose you mounted the <code>ldap</code>
authentication backend at <code style="white-space: pre;">&#8288;/ldap-dev&#8288;</code> you might use <code>ldap &lt;- vault$auth$ldap2$custom_mount("/ldap-dev")</code> - this pattern
is repeated for other secret and authentication backends.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_ldap$custom_mount(mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mount</code></dt><dd><p>String, indicating the path that the engine is mounted at.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_ldap-configure"></a>



<h4>Method <code>configure()</code></h4>

<p>Configures the connection parameters for
LDAP-based authentication. Note that there are many options
here and not all may be well supported. You are probably best
to configure your vault-LDAP interaction elsewhere, and this
method should be regarded as experimental and for testing
purposes only.
</p>
<p>See the official docs
(https://developer.hashicorp.com/vault/api-docs/auth/ldap,
&quot;Configure LDAP&quot;) for the list of accepted parameters here
via the dots argument; these are passed through directly
(with the exception of <code>url</code> which is the only required
parameter and for which concatenation of multiple values is
done for you.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_ldap$configure(url, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>The LDAP server to connect to. Examples:
<code style="white-space: pre;">&#8288;ldap://ldap.myorg.com&#8288;</code>,
<code style="white-space: pre;">&#8288;ldaps://ldap.myorg.com:636&#8288;</code>. Multiple URLs can be specified
with a character vector, e.g. <code>c("ldap://ldap.myorg.com", , "ldap://ldap2.myorg.com")</code>; these will be tried in-order.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments passed through with the body</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_ldap-configuration"></a>



<h4>Method <code>configuration()</code></h4>

<p>Reads the connection parameters for LDAP-based
authentication.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_ldap$configuration()</pre></div>


<hr>
<a id="method-vault_client_auth_ldap-write"></a>



<h4>Method <code>write()</code></h4>

<p>Create or update a policy
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_ldap$write(name, policies, user = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the group (or user)</p>
</dd>
<dt><code>policies</code></dt><dd><p>A character vector of vault policies that this
group (or user) will have for vault access.</p>
</dd>
<dt><code>user</code></dt><dd><p>Scalar logical - if <code>TRUE</code>, then <code>name</code> is
interpreted as a <em>user</em> instead of a group.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_ldap-read"></a>



<h4>Method <code>read()</code></h4>

<p>Write a mapping between a LDAP group or user and
a set of vault policies.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_ldap$read(name, user = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the group (or user)</p>
</dd>
<dt><code>user</code></dt><dd><p>Scalar logical - if <code>TRUE</code>, then <code>name</code> is
interpreted as a <em>user</em> instead of a group.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_ldap-list"></a>



<h4>Method <code>list()</code></h4>

<p>List groups or users known to vault via LDAP
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_ldap$list(user = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>user</code></dt><dd><p>Scalar logical - if <code>TRUE</code>, then list users
instead of groups.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_ldap-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Delete a group or user (just the mapping to vault,
no data on the LDAP server is modified).
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_ldap$delete(name, user = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the group (or user)</p>
</dd>
<dt><code>user</code></dt><dd><p>Scalar logical - if <code>TRUE</code>, then <code>name</code> is
interpreted as a <em>user</em> instead of a group.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_ldap-login"></a>



<h4>Method <code>login()</code></h4>

<p>Log into the vault using LDAP authentication.
Normally you would not call this directly but instead use
<code style="white-space: pre;">&#8288;$login&#8288;</code> with <code>method = "ldap"</code> and proving the <code>username</code>
and optionally the <code>password</code> argument.
argument.  This function returns a vault token but does not
set it as the client token.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_ldap$login(username, password)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>username</code></dt><dd><p>Username to authenticate with</p>
</dd>
<dt><code>password</code></dt><dd><p>Password to authenticate with. If omitted or
<code>NULL</code> and the session is interactive, the password will be
prompted for.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  root &lt;- server$client()

  # The ldap authentication backend is not enabled by default,
  # so we need to enable it first
  root$auth$enable("ldap")

  # Considerable configuration is required to make this work. Here
  # we use the public server available at
  # https://www.forumsys.com/2022/05/10/online-ldap-test-server/
  root$auth$ldap$configure(
    url = "ldap://ldap.forumsys.com",
    binddn = "cn=read-only-admin,dc=example,dc=com",
    bindpass = "password",
    userdn = "dc=example,dc=com",
    userattr = "uid",
    groupdn = "dc=example,dc=com",
    groupattr = "ou",
    groupfilter = "(uniqueMember={{.UserDN}})")

  # You can associate groups of users with policies:
  root$auth$ldap$write("scientists", "default")

  # Create a new client and login with this user:
  newton &lt;- vaultr::vault_client(
    addr = server$addr,
    login = "ldap",
    username = "newton",
    password = "password")

  # (it is not recommended to login with the password like this as
  # it will end up in the command history, but in interactive use
  # you will be prompted securely for password)

  # Isaac Newton has now logged in and has only "default" policies
  newton$auth$token$lookup_self()$policies

  # (wheras our original root user has the "root" policy)
  root$auth$token$lookup_self()$policies
}
</code></pre>

<hr>
<h2 id='vault_client_auth_userpass'>Vault Username/Password Authentication Configuration</h2><span id='topic+vault_client_auth_userpass'></span>

<h3>Description</h3>

<p>Vault Username/Password Authentication Configuration
</p>
<p>Vault Username/Password Authentication Configuration
</p>


<h3>Details</h3>

<p>Interact with vault's username/password authentication backend.
This backend can be used to configure basic username+password
authentication, suitable for human users.  For more information,
please see the vault documentation
https://developer.hashicorp.com/vault/docs/auth/userpass
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_auth_userpass</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_auth_userpass-new"><code>vault_client_auth_userpass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_userpass-custom_mount"><code>vault_client_auth_userpass$custom_mount()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_userpass-write"><code>vault_client_auth_userpass$write()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_userpass-read"><code>vault_client_auth_userpass$read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_userpass-delete"><code>vault_client_auth_userpass$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_userpass-update_password"><code>vault_client_auth_userpass$update_password()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_userpass-update_policies"><code>vault_client_auth_userpass$update_policies()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_userpass-list"><code>vault_client_auth_userpass$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_auth_userpass-login"><code>vault_client_auth_userpass$login()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_auth_userpass-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_userpass</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_userpass$new(api_client, mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
<dt><code>mount</code></dt><dd><p>Mount point for the backend</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_userpass-custom_mount"></a>



<h4>Method <code>custom_mount()</code></h4>

<p>Set up a <code>vault_client_auth_userpass</code> object at a
custom mount.  For example, suppose you mounted the
<code>userpass</code> authentication backend at <code style="white-space: pre;">&#8288;/userpass2&#8288;</code> you might
use <code>up &lt;- vault$auth$userpass2$custom_mount("/userpass2")</code> -
this pattern is repeated for other secret and authentication
backends.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_userpass$custom_mount(mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mount</code></dt><dd><p>String, indicating the path that the engine is mounted at.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_userpass-write"></a>



<h4>Method <code>write()</code></h4>

<p>Create or update a user.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_userpass$write(
  username,
  password = NULL,
  policies = NULL,
  ttl = NULL,
  max_ttl = NULL,
  bound_cidrs = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>username</code></dt><dd><p>Username for the user</p>
</dd>
<dt><code>password</code></dt><dd><p>Password for the user (required when creating a
user only)</p>
</dd>
<dt><code>policies</code></dt><dd><p>Character vector of policies for the user</p>
</dd>
<dt><code>ttl</code></dt><dd><p>The lease duration which decides login expiration</p>
</dd>
<dt><code>max_ttl</code></dt><dd><p>Maximum duration after which login should expire</p>
</dd>
<dt><code>bound_cidrs</code></dt><dd><p>Character vector of CIDRs.  If set,
restricts usage of the login and token to client IPs falling
within the range of the specified CIDR(s).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_userpass-read"></a>



<h4>Method <code>read()</code></h4>

<p>Reads the properties of an existing username.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_userpass$read(username)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>username</code></dt><dd><p>Username to read</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_userpass-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Delete a user
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_userpass$delete(username)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>username</code></dt><dd><p>Username to delete</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_userpass-update_password"></a>



<h4>Method <code>update_password()</code></h4>

<p>Update password for a user
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_userpass$update_password(username, password)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>username</code></dt><dd><p>Username for the user to update</p>
</dd>
<dt><code>password</code></dt><dd><p>New password for the user</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_userpass-update_policies"></a>



<h4>Method <code>update_policies()</code></h4>

<p>Update vault policies for a user
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_userpass$update_policies(username, policies)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>username</code></dt><dd><p>Username for the user to update</p>
</dd>
<dt><code>policies</code></dt><dd><p>Character vector of policies for this user</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_auth_userpass-list"></a>



<h4>Method <code>list()</code></h4>

<p>List users known to vault
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_userpass$list()</pre></div>


<hr>
<a id="method-vault_client_auth_userpass-login"></a>



<h4>Method <code>login()</code></h4>

<p>Log into the vault using username/password
authentication.  Normally you would not call this directly
but instead use <code style="white-space: pre;">&#8288;$login&#8288;</code> with <code>method = "userpass"</code> and
proving the <code>username</code> argument and optionally the <code>password</code>
argument.  This function returns a vault token but does not
set it as the client token.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_auth_userpass$login(username, password = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>username</code></dt><dd><p>Username to authenticate with</p>
</dd>
<dt><code>password</code></dt><dd><p>Password to authenticate with. If omitted or
<code>NULL</code> and the session is interactive, the password will be
prompted for.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  root &lt;- server$client()

  # The userpass authentication backend is not enabled by default,
  # so we need to enable it first
  root$auth$enable("userpass")

  # Then we can add users:
  root$auth$userpass$write("alice", "p4ssw0rd")

  # Create a new client and login with this user:
  alice &lt;- vaultr::vault_client(
    addr = server$addr,
    login = "userpass",
    username = "alice",
    password = "p4ssw0rd")

  # (it is not recommended to login with the password like this as
  # it will end up in the command history, but in interactive use
  # you will be prompted securely for password)

  # Alice has now logged in and has only "default" policies
  alice$auth$token$lookup_self()$policies

  # (wheras our original root user has the "root" policy)
  root$auth$token$lookup_self()$policies
}
</code></pre>

<hr>
<h2 id='vault_client_cubbyhole'>Cubbyhole secret store</h2><span id='topic+vault_client_cubbyhole'></span>

<h3>Description</h3>

<p>Cubbyhole secret store
</p>
<p>Cubbyhole secret store
</p>


<h3>Details</h3>

<p>Interact with vault's cubbyhole key-value store.  This is useful
for storing simple key-value data without versioning or metadata
(c.f. <a href="#topic+vault_client_kv2">vault_client_kv2</a>) that is scoped to your
current token only and not accessible to anyone else.  For more
details please see the vault documentation
https://developer.hashicorp.com/vault/docs/secrets/cubbyhole
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_cubbyhole</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_cubbyhole-new"><code>vault_client_cubbyhole$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_cubbyhole-read"><code>vault_client_cubbyhole$read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_cubbyhole-write"><code>vault_client_cubbyhole$write()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_cubbyhole-list"><code>vault_client_cubbyhole$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_cubbyhole-delete"><code>vault_client_cubbyhole$delete()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_cubbyhole-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_cubbyhole</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_cubbyhole$new(api_client)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_cubbyhole-read"></a>



<h4>Method <code>read()</code></h4>

<p>Read a value from your cubbyhole
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_cubbyhole$read(path, field = NULL, metadata = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path for the secret to read, such as
<code style="white-space: pre;">&#8288;/cubbyhole/mysecret&#8288;</code></p>
</dd>
<dt><code>field</code></dt><dd><p>Optional field to read from the secret.  Each
secret is stored as a key/value set (represented in R as a
named list) and this is equivalent to using <code style="white-space: pre;">&#8288;[[field]]&#8288;</code>
on the return value.  The default, <code>NULL</code>, returns the
full set of values.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>Logical, indicating if we should return
metadata for this secret (lease information etc) as an
attribute along with the values itself.  Ignored if
<code>field</code> is specified.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_cubbyhole-write"></a>



<h4>Method <code>write()</code></h4>

<p>Write data into your cubbyhole.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_cubbyhole$write(path, data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path for the secret to write, such as
<code style="white-space: pre;">&#8288;/cubbyhole/mysecret&#8288;</code></p>
</dd>
<dt><code>data</code></dt><dd><p>A named list of values to write into the vault at
this path.  This <em>replaces</em> any existing values.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_cubbyhole-list"></a>



<h4>Method <code>list()</code></h4>

<p>List data in the vault at a give path.  This can
be used to list keys, etc (e.g., at <code style="white-space: pre;">&#8288;/cubbyhole&#8288;</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_cubbyhole$list(path, full_names = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The path to list</p>
</dd>
<dt><code>full_names</code></dt><dd><p>Logical, indicating if full paths (relative
to the vault root) should be returned.</p>
</dd>
<dt><code>value</code></dt><dd><p>A character vector (of zero length if no keys are
found).  Paths that are &quot;directories&quot; (i.e., that contain
keys and could themselves be listed) will be returned with
a trailing forward slash, e.g. <code style="white-space: pre;">&#8288;path/&#8288;</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_cubbyhole-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Delete a value from the vault
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_cubbyhole$delete(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The path to delete</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()

  # Shorter path for easier reading:
  cubbyhole &lt;- client$secrets$cubbyhole
  cubbyhole

  # Write a value
  cubbyhole$write("cubbyhole/secret", list(key = "value"))
  # List it
  cubbyhole$list("cubbyhole")
  # Read it
  cubbyhole$read("cubbyhole/secret")
  # Delete it
  cubbyhole$delete("cubbyhole/secret")

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client_kv1'>Key-Value Store (Version 1)</h2><span id='topic+vault_client_kv1'></span>

<h3>Description</h3>

<p>Key-Value Store (Version 1)
</p>
<p>Key-Value Store (Version 1)
</p>


<h3>Details</h3>

<p>Interact with vault's version 1 key-value store.  This is useful
for storing simple key-value data without versioning or metadata
(see <a href="#topic+vault_client_kv2">vault_client_kv2</a> for a richer key-value store).
</p>
<p>Up to vault version 0.12.0 this was mounted by default at
<code style="white-space: pre;">&#8288;/secret&#8288;</code>.  It can be accessed from vault with either the <code style="white-space: pre;">&#8288;$read&#8288;</code>,
<code style="white-space: pre;">&#8288;$write&#8288;</code>, <code style="white-space: pre;">&#8288;$list&#8288;</code> and <code style="white-space: pre;">&#8288;$delete&#8288;</code> methods on the main
<a href="#topic+vault_client">vault_client</a> object or by the <code style="white-space: pre;">&#8288;$kv1&#8288;</code> member of the
<code>secrets</code> member of the main vault client
(<a href="#topic+vault_client_secrets">vault_client_secrets</a>)
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_kv1</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_kv1-new"><code>vault_client_kv1$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv1-custom_mount"><code>vault_client_kv1$custom_mount()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv1-read"><code>vault_client_kv1$read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv1-write"><code>vault_client_kv1$write()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv1-list"><code>vault_client_kv1$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv1-delete"><code>vault_client_kv1$delete()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_kv1-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_kv1</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv1$new(api_client, mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
<dt><code>mount</code></dt><dd><p>Mount point for the backend</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv1-custom_mount"></a>



<h4>Method <code>custom_mount()</code></h4>

<p>Set up a <code>vault_client_kv1</code> object at a custom
mount.  For example, suppose you mounted another copy of the
<code>kv1</code> secret backend at <code style="white-space: pre;">&#8288;/secret2&#8288;</code> you might use <code>kv &lt;- vault$secrets$kv1$custom_mount("/secret2")</code> - this pattern is
repeated for other secret and authentication backends.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv1$custom_mount(mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mount</code></dt><dd><p>String, indicating the path that the engine is
mounted at.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv1-read"></a>



<h4>Method <code>read()</code></h4>

<p>Read a value from the vault.  This can be used to
read any value that you have permission to read in this
store.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv1$read(path, field = NULL, metadata = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path for the secret to read, such as
<code style="white-space: pre;">&#8288;/secret/mysecret&#8288;</code></p>
</dd>
<dt><code>field</code></dt><dd><p>Optional field to read from the secret.  Each
secret is stored as a key/value set (represented in R as a
named list) and this is equivalent to using <code style="white-space: pre;">&#8288;[[field]]&#8288;</code> on
the return value.  The default, <code>NULL</code>, returns the full set
of values.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>Logical, indicating if we should return
metadata for this secret (lease information etc) as an
attribute along with the values itself.  Ignored if <code>field</code>
is specified.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv1-write"></a>



<h4>Method <code>write()</code></h4>

<p>Write data into the vault.  This can be used to
write any value that you have permission to write in this
store.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv1$write(path, data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path for the secret to write, such as
<code style="white-space: pre;">&#8288;/secret/mysecret&#8288;</code></p>
</dd>
<dt><code>data</code></dt><dd><p>A named list of values to write into the vault at
this path.  This <em>replaces</em> any existing values.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv1-list"></a>



<h4>Method <code>list()</code></h4>

<p>List data in the vault at a give path.  This can
be used to list keys, etc (e.g., at <code style="white-space: pre;">&#8288;/secret&#8288;</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv1$list(path, full_names = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The path to list</p>
</dd>
<dt><code>full_names</code></dt><dd><p>Logical, indicating if full paths (relative
to the vault root) should be returned.</p>
</dd>
<dt><code>value</code></dt><dd><p>A character vector (of zero length if no keys are
found).  Paths that are &quot;directories&quot; (i.e., that contain
keys and could themselves be listed) will be returned with a
trailing forward slash, e.g. <code style="white-space: pre;">&#8288;path/&#8288;</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv1-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Delete a value from the vault
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv1$delete(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The path to delete</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()

  # Write secrets
  client$secrets$kv1$write("/secret/path/mysecret", list(key = "value"))

  # List secrets - note the trailing "/" indicates a folder
  client$secrets$kv1$list("/secret")
  client$secrets$kv1$list("/secret/path")

  # Read secrets
  client$secrets$kv1$read("/secret/path/mysecret")
  client$secrets$kv1$read("/secret/path/mysecret", field = "key")

  # Delete secrets
  client$secrets$kv1$delete("/secret/path/mysecret")
  client$secrets$kv1$read("/secret/path/mysecret")

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client_kv2'>Key-Value Store (Version 2)</h2><span id='topic+vault_client_kv2'></span>

<h3>Description</h3>

<p>Key-Value Store (Version 2)
</p>
<p>Key-Value Store (Version 2)
</p>


<h3>Details</h3>

<p>Interact with vault's version 2 key-value store.  This is useful
for storing simple key-value data that can be versioned and for
storing metadata alongside the secrets (see
<a href="#topic+vault_client_kv1">vault_client_kv1</a> for a simpler key-value store, and see
https://developer.hashicorp.com/vault/docs/secrets/kv/kv-v2 for
detailed information about this secret store.
</p>
<p>A <code>kv2</code> store can be mounted anywhere, so all methods accept
a <code>mount</code> argument.  This is different to the CLI which lets
you try and read values from any vault path, but similar to other
secret and auth backends which accept arguments like
<code>-mount-point</code>.  So if the <code>kv2</code> store is mounted at
<code style="white-space: pre;">&#8288;/project-secrets&#8288;</code> for example, with a vault client
<code>vault</code> one could write
</p>
<div class="sourceCode"><pre>vault$secrets$kv2$get("/project-secrets/mysecret",
                      mount = "project-secrets")
</pre></div>
<p>or
</p>
<div class="sourceCode"><pre>kv2 &lt;- vault$secrets$kv2$custom_mount("project-secrets")
kv2$get("mysecret")
</pre></div>
<p>If the leading part of of a path to secret within a <code>kv2</code>
store does not match the mount point, <code>vaultr</code> will throw an
error.  This approach results in more predictable error messages,
though it is a little more typing than for the CLI vault client.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_kv2</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_kv2-new"><code>vault_client_kv2$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-config"><code>vault_client_kv2$config()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-custom_mount"><code>vault_client_kv2$custom_mount()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-delete"><code>vault_client_kv2$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-destroy"><code>vault_client_kv2$destroy()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-get"><code>vault_client_kv2$get()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-list"><code>vault_client_kv2$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-metadata_get"><code>vault_client_kv2$metadata_get()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-metadata_put"><code>vault_client_kv2$metadata_put()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-metadata_delete"><code>vault_client_kv2$metadata_delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-put"><code>vault_client_kv2$put()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_kv2-undelete"><code>vault_client_kv2$undelete()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_kv2-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_kv2</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$new(api_client, mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
<dt><code>mount</code></dt><dd><p>Mount point for the backend</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-config"></a>



<h4>Method <code>config()</code></h4>

<p>Fetch the configuration for this <code>kv2</code> store.
Returns a named list of values, the contents of which will
depend on the vault version.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$config(mount = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-custom_mount"></a>



<h4>Method <code>custom_mount()</code></h4>

<p>Set up a <code>vault_client_kv2</code> object at a custom
mount.  For example, suppose you mounted another copy of the
<code>kv2</code> secret backend at <code style="white-space: pre;">&#8288;/secret2&#8288;</code> you might use <code>kv &lt;- vault$secrets$kv2$custom_mount("/secret2")</code> - this pattern is
repeated for other secret and authentication backends.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$custom_mount(mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mount</code></dt><dd><p>String, indicating the path that the engine is
mounted at.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Delete a secret from the vault.  This marks the
version as deleted and will stop it from being returned from
reads, but the underlying data will not be removed. A delete
can be undone using the undelete method.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$delete(path, version = NULL, mount = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path to delete</p>
</dd>
<dt><code>version</code></dt><dd><p>Optional version to delete.  If <code>NULL</code> (the
default) then the latest version of the secret is deleted.
Otherwise, <code>version</code> can be a vector of integer versions to
delete.</p>
</dd>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-destroy"></a>



<h4>Method <code>destroy()</code></h4>

<p>Delete a secret entirely.  Unlike <code>delete</code> this
operation is irreversible and is more like the <code>delete</code>
operation on <code><a href="#topic+vault_client_kv1">vault_client_kv1</a></code> stores.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$destroy(path, version, mount = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path to delete</p>
</dd>
<dt><code>version</code></dt><dd><p>Version numbers to delete, as a vector of
integers (this is required)</p>
</dd>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-get"></a>



<h4>Method <code>get()</code></h4>

<p>Read a secret from the vault
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$get(
  path,
  version = NULL,
  field = NULL,
  metadata = FALSE,
  mount = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path of the secret to read</p>
</dd>
<dt><code>version</code></dt><dd><p>Optional version of the secret to read.  If
<code>NULL</code> (the default) then the most recent version is read.
Otherwise this must be a scalar integer.</p>
</dd>
<dt><code>field</code></dt><dd><p>Optional field to read from the secret.  Each
secret is stored as a key/value set (represented in R as a
named list) and this is equivalent to using <code style="white-space: pre;">&#8288;[[field]]&#8288;</code> on
the return value.  The default, <code>NULL</code>, returns the full set
of values.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>Logical, indicating if we should return
metadata for this secret (lease information etc) as an
attribute along with the values itself.  Ignored if <code>field</code>
is specified.</p>
</dd>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-list"></a>



<h4>Method <code>list()</code></h4>

<p>List data in the vault at a give path.  This can
be used to list keys, etc (e.g., at <code style="white-space: pre;">&#8288;/secret&#8288;</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$list(path, full_names = FALSE, mount = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The path to list</p>
</dd>
<dt><code>full_names</code></dt><dd><p>Logical, indicating if full paths (relative
to the vault root) should be returned.</p>
</dd>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
<dt><code>value</code></dt><dd><p>A character vector (of zero length if no keys are
found).  Paths that are &quot;directories&quot; (i.e., that contain
keys and could themselves be listed) will be returned with a
trailing forward slash, e.g. <code style="white-space: pre;">&#8288;path/&#8288;</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-metadata_get"></a>



<h4>Method <code>metadata_get()</code></h4>

<p>Read secret metadata and versions at the specified
path
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$metadata_get(path, mount = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path of secret to read metadata for</p>
</dd>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-metadata_put"></a>



<h4>Method <code>metadata_put()</code></h4>

<p>Update metadata for a secret.  This is allowed
even if a secret does not yet exist, though this requires the
<code>create</code> vault permission at this path.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$metadata_put(
  path,
  cas_required = NULL,
  max_versions = NULL,
  mount = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path of secret to update metadata for</p>
</dd>
<dt><code>cas_required</code></dt><dd><p>Logical, indicating that if If true the key
will require the cas parameter to be set on all write
requests (see <code>put</code>). If <code>FALSE</code>, the backend's configuration
will be used.</p>
</dd>
<dt><code>max_versions</code></dt><dd><p>Integer, indicating the
maximum number of versions to keep per key.  If not set, the
backend's configured max version is used. Once a key has more
than the configured allowed versions the oldest version will
be permanently deleted.</p>
</dd>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-metadata_delete"></a>



<h4>Method <code>metadata_delete()</code></h4>

<p>This method permanently deletes the key metadata
and all version data for the specified key. All version
history will be removed.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$metadata_delete(path, mount = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path to delete</p>
</dd>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-put"></a>



<h4>Method <code>put()</code></h4>

<p>Create or update a secret in this store.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$put(path, data, cas = NULL, mount = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path for the secret to write, such as
<code style="white-space: pre;">&#8288;/secret/mysecret&#8288;</code></p>
</dd>
<dt><code>data</code></dt><dd><p>A named list of values to write into the vault at
this path.</p>
</dd>
<dt><code>cas</code></dt><dd><p>Integer, indicating the &quot;cas&quot; value to use a
&quot;Check-And-Set&quot; operation. If not set the write will be
allowed. If set to 0 a write will only be allowed if the key
doesn't exist. If the index is non-zero the write will only
be allowed if the key's current version matches the version
specified in the cas parameter.</p>
</dd>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_kv2-undelete"></a>



<h4>Method <code>undelete()</code></h4>

<p>Undeletes the data for the provided version and
path in the key-value store. This restores the data, allowing
it to be returned on get requests.  This works with data
deleted with <code style="white-space: pre;">&#8288;$delete&#8288;</code> but not with <code style="white-space: pre;">&#8288;$destroy&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_kv2$undelete(path, version, mount = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>The path to undelete</p>
</dd>
<dt><code>version</code></dt><dd><p>Integer vector of versions to undelete</p>
</dd>
<dt><code>mount</code></dt><dd><p>Custom mount path to use for this store (see <code>Details</code>).</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()
  # With the test server as created by vaultr, the kv2 storage
  # engine is not enabled.  To use the kv2 store we must first
  # enable it; the command below will add it at the path /kv on
  # our vault server
  client$secrets$enable("kv", version = 2)

  # For ease of reading, create a 'kv' object for interacting with
  # the store (see below for the calls without this object)
  kv &lt;- client$secrets$kv2$custom_mount("kv")
  kv$config()

  # The version-2 kv store can be treated largely the same as the
  # version-1 store, though with slightly different command names
  # (put instead of write, get instead of read)
  kv$put("/kv/path/secret", list(key = "value"))
  kv$get("/kv/path/secret")

  # But it also allows different versions to be stored at the same path:
  kv$put("/kv/path/secret", list(key = "s3cret!"))
  kv$get("/kv/path/secret")

  # Old versions can be retrieved still:
  kv$get("/kv/path/secret", version = 1)

  # And metadata about versions can be retrieved
  kv$metadata_get("/kv/path/secret")

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client_object'>Base object type</h2><span id='topic+vault_client_object'></span>

<h3>Description</h3>

<p>Base object type
</p>
<p>Base object type
</p>


<h3>Details</h3>

<p>Base object used by vaultr for all objects
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_object-new"><code>vault_client_object$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_object-format"><code>vault_client_object$format()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_object-help"><code>vault_client_object$help()</code></a>
</p>
</li></ul>


<hr>
<a id="method-vault_client_object-new"></a>



<h4>Method <code>new()</code></h4>

<p>Construct an object
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_object$new(description)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>description</code></dt><dd><p>Description for the object, will be printed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_object-format"></a>



<h4>Method <code>format()</code></h4>

<p>Format method, overriding the R6 default
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_object$format(brief = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>brief</code></dt><dd><p>Logical, indicating if this is the full format or
a brief (one line) format.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_object-help"></a>



<h4>Method <code>help()</code></h4>

<p>Display help for this object
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_object$help()</pre></div>




<h3>Examples</h3>

<pre><code class='language-R'>
server &lt;- vaultr::vault_test_server(if_disabled = message)

if (!is.null(server)) {
  client &lt;- vaultr::vault_client(addr = server$addr)
  client$operator$format()
  client$operator$format(TRUE)
}
</code></pre>

<hr>
<h2 id='vault_client_operator'>Vault Administration</h2><span id='topic+vault_client_operator'></span>

<h3>Description</h3>

<p>Vault Administration
</p>
<p>Vault Administration
</p>


<h3>Details</h3>

<p>Administration commands for vault operators.  Very few of these
commands should be used without consulting the vault documentation
as they affect the administration of a vault server, but they are
included here for completeness.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_operator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_operator-new"><code>vault_client_operator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-key_status"><code>vault_client_operator$key_status()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-is_initialized"><code>vault_client_operator$is_initialized()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-init"><code>vault_client_operator$init()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-leader_status"><code>vault_client_operator$leader_status()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-rekey_status"><code>vault_client_operator$rekey_status()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-rekey_start"><code>vault_client_operator$rekey_start()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-rekey_cancel"><code>vault_client_operator$rekey_cancel()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-rekey_submit"><code>vault_client_operator$rekey_submit()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-rotate"><code>vault_client_operator$rotate()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-seal"><code>vault_client_operator$seal()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-seal_status"><code>vault_client_operator$seal_status()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_operator-unseal"><code>vault_client_operator$unseal()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_operator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_operator</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$new(api_client)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_operator-key_status"></a>



<h4>Method <code>key_status()</code></h4>

<p>Return information about the current encryption
key of Vault.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$key_status()</pre></div>


<hr>
<a id="method-vault_client_operator-is_initialized"></a>



<h4>Method <code>is_initialized()</code></h4>

<p>Returns the initialization status of Vault
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$is_initialized()</pre></div>


<hr>
<a id="method-vault_client_operator-init"></a>



<h4>Method <code>init()</code></h4>

<p>This endpoint initializes a new Vault. The Vault
must not have been previously initialized.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$init(secret_shares, secret_threshold)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>secret_shares</code></dt><dd><p>Integer, specifying the number of shares
to split the master key into</p>
</dd>
<dt><code>secret_threshold</code></dt><dd><p>Integer, specifying the number of
shares required to reconstruct the master key. This must be
less than or equal secret_shares</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_operator-leader_status"></a>



<h4>Method <code>leader_status()</code></h4>

<p>Check the high availability status and current
leader of Vault
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$leader_status()</pre></div>


<hr>
<a id="method-vault_client_operator-rekey_status"></a>



<h4>Method <code>rekey_status()</code></h4>

<p>Reads the configuration and progress of the
current rekey attempt
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$rekey_status()</pre></div>


<hr>
<a id="method-vault_client_operator-rekey_start"></a>



<h4>Method <code>rekey_start()</code></h4>

<p>This method begins a new rekey attempt. Only a
single rekey attempt can take place at a time, and changing
the parameters of a rekey requires cancelling and starting a
new rekey, which will also provide a new nonce.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$rekey_start(secret_shares, secret_threshold)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>secret_shares</code></dt><dd><p>Integer, specifying the number of shares
to split the master key into</p>
</dd>
<dt><code>secret_threshold</code></dt><dd><p>Integer, specifying the number of
shares required to reconstruct the master key. This must be
less than or equal secret_shares</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_operator-rekey_cancel"></a>



<h4>Method <code>rekey_cancel()</code></h4>

<p>This method cancels any in-progress rekey. This
clears the rekey settings as well as any progress made. This
must be called to change the parameters of the rekey. Note
verification is still a part of a rekey. If rekeying is
cancelled during the verification flow, the current unseal
keys remain valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$rekey_cancel()</pre></div>


<hr>
<a id="method-vault_client_operator-rekey_submit"></a>



<h4>Method <code>rekey_submit()</code></h4>

<p>This method is used to enter a single master key
share to progress the rekey of the Vault. If the threshold
number of master key shares is reached, Vault will complete
the rekey. Otherwise, this method must be called multiple
times until that threshold is met. The rekey nonce operation
must be provided with each call.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$rekey_submit(key, nonce)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>Specifies a single master share key (a string)</p>
</dd>
<dt><code>nonce</code></dt><dd><p>Specifies the nonce of the rekey operation (a
string)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_operator-rotate"></a>



<h4>Method <code>rotate()</code></h4>

<p>This method triggers a rotation of the backend
encryption key. This is the key that is used to encrypt data
written to the storage backend, and is not provided to
operators. This operation is done online. Future values are
encrypted with the new key, while old values are decrypted
with previous encryption keys.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$rotate()</pre></div>


<hr>
<a id="method-vault_client_operator-seal"></a>



<h4>Method <code>seal()</code></h4>

<p>Seal the vault, preventing any access to it.
After the vault is sealed, it must be unsealed for further
use.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$seal()</pre></div>


<hr>
<a id="method-vault_client_operator-seal_status"></a>



<h4>Method <code>seal_status()</code></h4>

<p>Check the seal status of a Vault.  This method can
be used even when the client is not authenticated with the
vault (which will the case for a sealed vault).
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$seal_status()</pre></div>


<hr>
<a id="method-vault_client_operator-unseal"></a>



<h4>Method <code>unseal()</code></h4>

<p>Submit a portion of a key to unseal the vault.
This method is typically called by multiple different
operators to assemble the master key.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_operator$unseal(key, reset = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>The master key share</p>
</dd>
<dt><code>reset</code></dt><dd><p>Logical, indicating if the unseal process should
start be started again.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()

  # Our test server is by default unsealed:
  client$status()$sealed

  # We can seal the vault to prevent all access:
  client$operator$seal()
  client$status()$sealed

  # And then unseal it again
  client$operator$unseal(server$keys)
  client$status()$sealed
}
</code></pre>

<hr>
<h2 id='vault_client_policy'>Vault Policy Configuration</h2><span id='topic+vault_client_policy'></span>

<h3>Description</h3>

<p>Vault Policy Configuration
</p>
<p>Vault Policy Configuration
</p>


<h3>Details</h3>

<p>Interact with vault's policies.  To get started, you may want to
read up on policies as described in the vault manual, here:
https://developer.hashicorp.com/vault/docs/concepts/policies
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_policy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_policy-new"><code>vault_client_policy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_policy-delete"><code>vault_client_policy$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_policy-list"><code>vault_client_policy$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_policy-read"><code>vault_client_policy$read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_policy-write"><code>vault_client_policy$write()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_policy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_policy</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_policy$new(api_client)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_policy-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>This endpoint deletes the policy with the given
name. This will immediately affect all users associated with
this policy.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_policy$delete(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Specifies the name of the policy to delete.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_policy-list"></a>



<h4>Method <code>list()</code></h4>

<p>Lists all configured policies.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_policy$list()</pre></div>


<hr>
<a id="method-vault_client_policy-read"></a>



<h4>Method <code>read()</code></h4>

<p>Retrieve the policy body for the named policy
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_policy$read(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Specifies the name of the policy to retrieve</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_policy-write"></a>



<h4>Method <code>write()</code></h4>

<p>Create or update a policy.  Once a policy is
updated, it takes effect immediately to all associated users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_policy$write(name, rules)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the policy to update</p>
</dd>
<dt><code>rules</code></dt><dd><p>Specifies the policy document.  This is a string
in &quot;HashiCorp configuration language&quot;.  At present this must
be read in as a single string (not a character vector of
strings); future versions of vaultr may allow more flexible
specification such as <code style="white-space: pre;">&#8288;@filename&#8288;</code></p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()

  # The test server starts with only the policies "root" (do
  # everything) and "default" (do nothing).
  client$policy$list()

  # Here let's make a policy that allows reading secrets from the
  # path /secret/develop/* but nothing else
  rules &lt;- 'path "secret/develop/*" {policy = "read"}'
  client$policy$write("read-secret-develop", rules)

  # Our new rule is listed and can be read
  client$policy$list()
  client$policy$read("read-secret-develop")

  # For testing, let's create a secret under this path, and under
  # a different path:
  client$write("/secret/develop/password", list(value = "password"))
  client$write("/secret/production/password", list(value = "k2e89be@rdC#"))

  # Create a token that can use this policy:
  token &lt;- client$auth$token$create(policies = "read-secret-develop")

  # Login to the vault using this token:
  alice &lt;- vaultr::vault_client(addr = server$addr,
                                login = "token", token = token)

  # We can read the paths that we have been granted access to:
  alice$read("/secret/develop/password")

  # We can't read secrets that are outside our path:
  try(alice$read("/secret/production/password"))

  # And we can't write:
  try(alice$write("/secret/develop/password", list(value = "secret")))

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client_secrets'>Vault Secret Configuration</h2><span id='topic+vault_client_secrets'></span>

<h3>Description</h3>

<p>Vault Secret Configuration
</p>
<p>Vault Secret Configuration
</p>


<h3>Details</h3>

<p>Interact with vault's secret backends.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_secrets</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>cubbyhole</code></dt><dd><p>The cubbyhole backend:
<a href="#topic+vault_client_cubbyhole">vault_client_cubbyhole</a></p>
</dd>
<dt><code>kv1</code></dt><dd><p>The version 1 key-value backend:
<a href="#topic+vault_client_kv1">vault_client_kv1</a></p>
</dd>
<dt><code>kv2</code></dt><dd><p>The version 2 key-value backend:
<a href="#topic+vault_client_kv2">vault_client_kv2</a></p>
</dd>
<dt><code>transit</code></dt><dd><p>The transit backend:
<a href="#topic+vault_client_transit">vault_client_transit</a></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_secrets-new"><code>vault_client_secrets$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_secrets-disable"><code>vault_client_secrets$disable()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_secrets-enable"><code>vault_client_secrets$enable()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_secrets-list"><code>vault_client_secrets$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_secrets-move"><code>vault_client_secrets$move()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_secrets-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_secrets</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_secrets$new(api_client)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_secrets-disable"></a>



<h4>Method <code>disable()</code></h4>

<p>Disable a previously-enabled secret engine
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_secrets$disable(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path of the secret engine</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_secrets-enable"></a>



<h4>Method <code>enable()</code></h4>

<p>Enable a secret backend in the vault server
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_secrets$enable(
  type,
  path = type,
  description = NULL,
  version = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>The type of secret backend (e.g., <code>transit</code>, <code>kv</code>).</p>
</dd>
<dt><code>path</code></dt><dd><p>Specifies the path in which to enable the auth
method. Defaults to be the same as <code>type</code>.</p>
</dd>
<dt><code>description</code></dt><dd><p>Human-friendly description of the backend;
will be returned by <code style="white-space: pre;">&#8288;$list()&#8288;</code></p>
</dd>
<dt><code>version</code></dt><dd><p>Used only for the <code>kv</code> backend, where an integer
is used to select between <a href="#topic+vault_client_kv1">vault_client_kv1</a> and
<a href="#topic+vault_client_kv2">vault_client_kv2</a> engines.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_secrets-list"></a>



<h4>Method <code>list()</code></h4>

<p>List enabled secret engines
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_secrets$list(detailed = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>detailed</code></dt><dd><p>Logical, indicating if detailed output is
wanted.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_secrets-move"></a>



<h4>Method <code>move()</code></h4>

<p>Move the path that a secret engine is mounted at
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_secrets$move(from, to)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>from</code></dt><dd><p>Original path</p>
</dd>
<dt><code>to</code></dt><dd><p>New path</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()

  # To remove the default version 1 kv store and replace with a
  # version 2 store:
  client$secrets$disable("/secret")
  client$secrets$enable("kv", "/secret", version = 2)

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client_token'>Vault Tokens</h2><span id='topic+vault_client_token'></span>

<h3>Description</h3>

<p>Vault Tokens
</p>
<p>Vault Tokens
</p>


<h3>Details</h3>

<p>Interact with vault's token methods.  This includes support for
querying, creating and deleting tokens.  Tokens are fundamental to
the way that vault works, so there are a lot of methods here.  The
vault documentation has a page devoted to token concepts:
https://developer.hashicorp.com/vault/docs/concepts/tokens - there
is also a page with commands:
https://developer.hashicorp.com/vault/docs/commands/token - these
have names very similar to the names used here.
</p>


<h3>Token Accessors</h3>

<p>Many of the methods use &quot;token accessors&quot; - whenever a token is
created, an &quot;accessor&quot; is created at the same time.  This is
another token that can be used to perform limited actions with the
token such as
</p>

<ul>
<li><p> Look up a token's properties (not including the actual token ID)
</p>
</li>
<li><p> Look up a token's capabilities on a path
</p>
</li>
<li><p> Revoke the token
</p>
</li></ul>

<p>However, accessors cannot be used to login, nor to retrieve the
actual token itself.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_token</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_token-new"><code>vault_client_token$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-list"><code>vault_client_token$list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-capabilities"><code>vault_client_token$capabilities()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-capabilities_self"><code>vault_client_token$capabilities_self()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-capabilities_accessor"><code>vault_client_token$capabilities_accessor()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-client"><code>vault_client_token$client()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-create"><code>vault_client_token$create()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-lookup"><code>vault_client_token$lookup()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-lookup_self"><code>vault_client_token$lookup_self()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-lookup_accessor"><code>vault_client_token$lookup_accessor()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-renew"><code>vault_client_token$renew()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-renew_self"><code>vault_client_token$renew_self()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-revoke"><code>vault_client_token$revoke()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-revoke_self"><code>vault_client_token$revoke_self()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-revoke_accessor"><code>vault_client_token$revoke_accessor()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-revoke_and_orphan"><code>vault_client_token$revoke_and_orphan()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-role_read"><code>vault_client_token$role_read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-role_list"><code>vault_client_token$role_list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-role_write"><code>vault_client_token$role_write()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-role_delete"><code>vault_client_token$role_delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-tidy"><code>vault_client_token$tidy()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_token-login"><code>vault_client_token$login()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_token-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_token</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$new(api_client)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-list"></a>



<h4>Method <code>list()</code></h4>

<p>List token accessors, returning a character vector
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$list()</pre></div>


<hr>
<a id="method-vault_client_token-capabilities"></a>



<h4>Method <code>capabilities()</code></h4>

<p>Fetch the capabilities of a token on the given
paths. The capabilities returned will be derived from the
policies that are on the token, and from the policies to
which the token is entitled to through the entity and
entity's group memberships.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$capabilities(path, token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Vector of paths on which capabilities are being
queried</p>
</dd>
<dt><code>token</code></dt><dd><p>Single token for which capabilities are being
queried</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-capabilities_self"></a>



<h4>Method <code>capabilities_self()</code></h4>

<p>As for the <code>capabilities</code> method, but for the
client token used to make the request.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$capabilities_self(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Vector of paths on which capabilities are being
queried</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-capabilities_accessor"></a>



<h4>Method <code>capabilities_accessor()</code></h4>

<p>As for the <code>capabilities</code> method, but using a
token <em>accessor</em> rather than a token itself.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$capabilities_accessor(path, accessor)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Vector of paths on which capabilities are being
queried</p>
</dd>
<dt><code>accessor</code></dt><dd><p>Accessor of the token for which capabilities
are being queried</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-client"></a>



<h4>Method <code>client()</code></h4>

<div class="sourceCode"><pre>Return the current client token
</pre></div>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$client()</pre></div>


<hr>
<a id="method-vault_client_token-create"></a>



<h4>Method <code>create()</code></h4>

<p>Create a new token
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$create(
  role_name = NULL,
  id = NULL,
  policies = NULL,
  meta = NULL,
  orphan = FALSE,
  no_default_policy = FALSE,
  max_ttl = NULL,
  display_name = NULL,
  num_uses = 0L,
  period = NULL,
  ttl = NULL,
  wrap_ttl = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>The name of the token role</p>
</dd>
<dt><code>id</code></dt><dd><p>The ID of the client token. Can only be specified by
a root token. Otherwise, the token ID is a randomly generated
value</p>
</dd>
<dt><code>policies</code></dt><dd><p>A character vector of policies for the
token. This must be a subset of the policies belonging to the
token making the request, unless root. If not specified,
defaults to all the policies of the calling token.</p>
</dd>
<dt><code>meta</code></dt><dd><p>A named list of strings as metadata to pass through
to audit devices.</p>
</dd>
<dt><code>orphan</code></dt><dd><p>Logical, indicating if the token created should
be an orphan (they will have no parent). As such, they will
not be automatically revoked by the revocation of any other
token.</p>
</dd>
<dt><code>no_default_policy</code></dt><dd><p>Logical, if <code>TRUE</code>, then the default
policy will not be contained in this token's policy set.</p>
</dd>
<dt><code>max_ttl</code></dt><dd><p>Provides a maximum lifetime for any tokens
issued against this role, including periodic tokens. Unlike
direct token creation, where the value for an explicit max
TTL is stored in the token, for roles this check will always
use the current value set in the role. The main use of this
is to provide a hard upper bound on periodic tokens, which
otherwise can live forever as long as they are renewed. This
is an integer number of seconds</p>
</dd>
<dt><code>display_name</code></dt><dd><p>The display name of the token</p>
</dd>
<dt><code>num_uses</code></dt><dd><p>Maximum number of uses that a token can have.
This can be used to create a one-time-token or limited use
token. The default, or the value of 0, has no limit to the
number of uses.</p>
</dd>
<dt><code>period</code></dt><dd><p>If specified, the token will be periodic; it will
have no maximum TTL (unless a <code>max_ttl</code> is also set) but
every renewal will use the given period. Requires a
root/sudo token to use.</p>
</dd>
<dt><code>ttl</code></dt><dd><p>The TTL period of the token, provided as &quot;1h&quot;, where
hour is the largest suffix. If not provided, the token is
valid for the default lease TTL, or indefinitely if the root
policy is used.</p>
</dd>
<dt><code>wrap_ttl</code></dt><dd><p>Indicates that the secret should be wrapped.
This is discussed in the vault documentation:
https://developer.hashicorp.com/vault/docs/concepts/response-wrapping
When this option is used, <code>vault</code> will take the response it
would have sent to an HTTP client and instead insert it into
the cubbyhole of a single-use token, returning that
single-use token instead. Logically speaking, the response is
wrapped by the token, and retrieving it requires an unwrap
operation against this token (see the <code style="white-space: pre;">&#8288;$unwrap&#8288;</code> method
<a href="#topic+vault_client">vault_client</a>.  Must be specified as a valid
duration (e.g., <code style="white-space: pre;">&#8288;1h&#8288;</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-lookup"></a>



<h4>Method <code>lookup()</code></h4>

<p>Returns information about the client token
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$lookup(token = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>The token to lookup</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-lookup_self"></a>



<h4>Method <code>lookup_self()</code></h4>

<p>Returns information about the current client token
(as if calling <code style="white-space: pre;">&#8288;$lookup&#8288;</code> with the token the client is using.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$lookup_self()</pre></div>


<hr>
<a id="method-vault_client_token-lookup_accessor"></a>



<h4>Method <code>lookup_accessor()</code></h4>

<p>Returns information about the client token from
the accessor.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$lookup_accessor(accessor)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>accessor</code></dt><dd><p>The token accessor to lookup</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-renew"></a>



<h4>Method <code>renew()</code></h4>

<p>Renews a lease associated with a token. This is
used to prevent the expiration of a token, and the automatic
revocation of it. Token renewal is possible only if there is
a lease associated with it.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$renew(token, increment = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>The token to renew</p>
</dd>
<dt><code>increment</code></dt><dd><p>An optional requested lease increment can be
provided. This increment may be ignored.  If given, it should
be a duration (e.g., <code style="white-space: pre;">&#8288;1h&#8288;</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-renew_self"></a>



<h4>Method <code>renew_self()</code></h4>

<p>Renews a lease associated with the calling
token. This is used to prevent the expiration of a token, and
the automatic revocation of it. Token renewal is possible
only if there is a lease associated with it.  This is
equivalent to calling <code style="white-space: pre;">&#8288;$renew()&#8288;</code> with the client token.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$renew_self(increment = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>increment</code></dt><dd><p>An optional requested lease increment can be
provided. This increment may be ignored.  If given, it should
be a duration (e.g., <code style="white-space: pre;">&#8288;1h&#8288;</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-revoke"></a>



<h4>Method <code>revoke()</code></h4>

<p>Revokes a token and all child tokens. When the
token is revoked, all dynamic secrets generated with it are
also revoked.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$revoke(token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>The token to revoke</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-revoke_self"></a>



<h4>Method <code>revoke_self()</code></h4>

<p>Revokes the token used to call it and all child
tokens. When the token is revoked, all dynamic secrets
generated with it are also revoked.  This is equivalent to
calling <code style="white-space: pre;">&#8288;$revoke()&#8288;</code> with the client token.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$revoke_self()</pre></div>


<hr>
<a id="method-vault_client_token-revoke_accessor"></a>



<h4>Method <code>revoke_accessor()</code></h4>

<p>Revoke the token associated with the accessor and
all the child tokens. This is meant for purposes where there
is no access to token ID but there is need to revoke a token
and its children.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$revoke_accessor(accessor)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>accessor</code></dt><dd><p>Accessor of the token to revoke.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-revoke_and_orphan"></a>



<h4>Method <code>revoke_and_orphan()</code></h4>

<p>Revokes a token but not its child tokens. When the
token is revoked, all secrets generated with it are also
revoked. All child tokens are orphaned, but can be revoked
subsequently using /auth/token/revoke/. This is a
root-protected method.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$revoke_and_orphan(token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>The token to revoke</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-role_read"></a>



<h4>Method <code>role_read()</code></h4>

<p>Fetches the named role configuration.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$role_read(role_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>The name of the token role.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-role_list"></a>



<h4>Method <code>role_list()</code></h4>

<p>List available token roles.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$role_list()</pre></div>


<hr>
<a id="method-vault_client_token-role_write"></a>



<h4>Method <code>role_write()</code></h4>

<p>Creates (or replaces) the named role. Roles
enforce specific behaviour when creating tokens that allow
token functionality that is otherwise not available or would
require sudo/root privileges to access. Role parameters, when
set, override any provided options to the create
endpoints. The role name is also included in the token path,
allowing all tokens created against a role to be revoked
using the <code style="white-space: pre;">&#8288;/sys/leases/revoke-prefix&#8288;</code> endpoint.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$role_write(
  role_name,
  allowed_policies = NULL,
  disallowed_policies = NULL,
  orphan = NULL,
  period = NULL,
  renewable = NULL,
  explicit_max_ttl = NULL,
  path_suffix = NULL,
  bound_cidrs = NULL,
  token_type = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>Name for the role - this will be used later to
refer to the role (e.g., in <code style="white-space: pre;">&#8288;$create&#8288;</code> and other <code style="white-space: pre;">&#8288;$role_*&#8288;</code>
methods.</p>
</dd>
<dt><code>allowed_policies</code></dt><dd><p>Character vector of policies allowed
for this role.  If set, tokens can be created with any subset
of the policies in this list, rather than the normal
semantics of tokens being a subset of the calling token's
policies. The parameter is a comma-delimited string of policy
names. If at creation time <code>no_default_policy</code> is not set and
&quot;default&quot; is not contained in disallowed_policies, the
&quot;default&quot; policy will be added to the created token
automatically.</p>
</dd>
<dt><code>disallowed_policies</code></dt><dd><p>Character vector of policies
forbidden for this role.  If set, successful token creation
via this role will require that no policies in the given list
are requested. Adding &quot;default&quot; to this list will prevent
&quot;default&quot; from being added automatically to created tokens.</p>
</dd>
<dt><code>orphan</code></dt><dd><p>If <code>TRUE</code>, then tokens created against this
policy will be orphan tokens (they will have no parent). As
such, they will not be automatically revoked by the
revocation of any other token.</p>
</dd>
<dt><code>period</code></dt><dd><p>A duration (e.g., <code style="white-space: pre;">&#8288;1h&#8288;</code>).  If specified, the token
will be periodic; it will have no maximum TTL (unless an
&quot;explicit-max-ttl&quot; is also set) but every renewal will use
the given period. Requires a root/sudo token to use.</p>
</dd>
<dt><code>renewable</code></dt><dd><p>Set to <code>FALSE</code> to disable the ability of the
token to be renewed past its initial TTL. The default value
of <code>TRUE</code> will allow the token to be renewable up to the
system/mount maximum TTL.</p>
</dd>
<dt><code>explicit_max_ttl</code></dt><dd><p>An integer number of seconds.  Provides
a maximum lifetime for any tokens issued against this role,
including periodic tokens. Unlike direct token creation,
where the value for an explicit max TTL is stored in the
token, for roles this check will always use the current value
set in the role. The main use of this is to provide a hard
upper bound on periodic tokens, which otherwise can live
forever as long as they are renewed. This is an integer
number of seconds.</p>
</dd>
<dt><code>path_suffix</code></dt><dd><p>A string.  If set, tokens created against
this role will have the given suffix as part of their path in
addition to the role name. This can be useful in certain
scenarios, such as keeping the same role name in the future
but revoking all tokens created against it before some point
in time. The suffix can be changed, allowing new callers to
have the new suffix as part of their path, and then tokens
with the old suffix can be revoked via
<code style="white-space: pre;">&#8288;/sys/leases/revoke-prefix&#8288;</code>.</p>
</dd>
<dt><code>bound_cidrs</code></dt><dd><p>Character vector of CIDRS.  If set,
restricts usage of the generated token to client IPs falling
within the range of the specified CIDR(s). Unlike most other
role parameters, this is not reevaluated from the current
role value at each usage; it is set on the token itself. Root
tokens with no TTL will not be bound by these CIDRs; root
tokens with TTLs will be bound by these CIDRs.</p>
</dd>
<dt><code>token_type</code></dt><dd><p>Specifies the type of tokens that should be
returned by the role. If either service or batch is
specified, that kind of token will always be returned. If
<code>default-service</code>, then <code>service</code> tokens will be returned
unless the client requests a batch type token at token
creation time. If <code>default-batch</code>, then <code>batch</code> tokens will
be returned unless the client requests a service type token
at token creation time.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-role_delete"></a>



<h4>Method <code>role_delete()</code></h4>

<p>Delete a named token role
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$role_delete(role_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_name</code></dt><dd><p>The name of the role to delete</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_token-tidy"></a>



<h4>Method <code>tidy()</code></h4>

<p>Performs some maintenance tasks to clean up
invalid entries that may remain in the token
store. Generally, running this is not needed unless upgrade
notes or support personnel suggest it. This may perform a lot
of I/O to the storage method so should be used sparingly.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$tidy()</pre></div>


<hr>
<a id="method-vault_client_token-login"></a>



<h4>Method <code>login()</code></h4>

<p>Unlike other auth backend <code>login</code> methods, this
does not actually log in to the vault.  Instead it verifies
that a token can be used to communicate with the vault.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_token$login(token = NULL, quiet = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>The token to test</p>
</dd>
<dt><code>quiet</code></dt><dd><p>Logical scalar, set to <code>TRUE</code> to suppress
informational messages.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()

  # There are lots of token methods here:
  client$token

  # To demonstrate, it will be useful to create a restricted
  # policy that can only read from the /secret path
  rules &lt;- 'path "secret/*" {policy = "read"}'
  client$policy$write("read-secret", rules)
  client$write("/secret/path", list(key = "value"))

  # Create a token that has this policy
  token &lt;- client$auth$token$create(policies = "read-secret")
  alice &lt;- vaultr::vault_client(addr = server$addr)
  alice$login(method = "token", token = token)
  alice$read("/secret/path")

  client$token$lookup(token)

  # We can query the capabilities of this token
  client$token$capabilities("secret/path", token)

  # Tokens are not safe to pass around freely because they *are*
  # the ability to login, but the `token$create` command also
  # provides an accessor:
  accessor &lt;- attr(token, "info")$accessor

  # It is not possible to derive the token from the accessor, but
  # we can use the accessor to ask vault what it could do if it
  # did have the token (and do things like revoke the token)
  client$token$capabilities_accessor("secret/path", accessor)

  client$token$revoke_accessor(accessor)
  try(client$token$capabilities_accessor("secret/path", accessor))

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client_tools'>Vault Tools</h2><span id='topic+vault_client_tools'></span>

<h3>Description</h3>

<p>Vault Tools
</p>
<p>Vault Tools
</p>


<h3>Details</h3>

<p>Interact with vault's cryptographic tools.  This provides support
for high-quality random numbers and cryptographic hashes.  This
functionality is also available through the transit secret engine.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_tools</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_tools-new"><code>vault_client_tools$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_tools-random"><code>vault_client_tools$random()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_tools-hash"><code>vault_client_tools$hash()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_tools-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_tools</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_tools$new(api_client)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_tools-random"></a>



<h4>Method <code>random()</code></h4>

<p>Generates high-quality random bytes of the
specified length.  This is totally independent of R's random
number stream and provides random numbers suitable for
cryptographic purposes.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_tools$random(bytes = 32, format = "hex")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bytes</code></dt><dd><p>Number of bytes to generate (as an integer)</p>
</dd>
<dt><code>format</code></dt><dd><p>The output format to produce; must be one of
<code>hex</code> (a single hex string such as <code>d1189e2f83b72ab6</code>),
<code>base64</code> (a single base64 encoded string such as
<code style="white-space: pre;">&#8288;8TDJekY0mYs=&#8288;</code>) or <code>raw</code> (a raw vector of length <code>bytes</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_tools-hash"></a>



<h4>Method <code>hash()</code></h4>

<p>Generates a cryptographic hash of given data using
the specified algorithm.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_tools$hash(data, algorithm = NULL, format = "hex")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A raw vector of data to hash.  To generate a raw
vector from an R object, one option is to use <code>unserialize(x, NULL)</code> but be aware that version information may be included.
Alternatively, for a string, one might use <code>charToRaw</code>.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>A string indicating the hash algorithm to use.
The exact set of supported algorithms may depend by vault
server version, but as of version 1.0.0 vault supports
<code>sha2-224</code>, <code>sha2-256</code>, <code>sha2-384</code> and <code>sha2-512</code>.  The
default is <code>sha2-256</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output - must be one of <code>hex</code>
or <code>base64</code>.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()

  # Random bytes in hex
  client$tools$random()
  # base64
  client$tools$random(format = "base64")
  # raw
  client$tools$random(10, format = "raw")

  # Hash data:
  data &lt;- charToRaw("hello vault")
  # will produce 55e702...92efd40c2a4
  client$tools$hash(data)

  # sha2-512 hash:
  client$tools$hash(data, "sha2-512")

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_client_transit'>Transit Engine</h2><span id='topic+vault_client_transit'></span>

<h3>Description</h3>

<p>Transit Engine
</p>
<p>Transit Engine
</p>


<h3>Details</h3>

<p>Interact with vault's <code>transit</code> engine.  This is useful for
encrypting arbitrary data without storing it in the vault - like
&quot;cryptography as a service&quot; or &quot;encryption as a service&quot;. The
transit secrets engine can also sign and verify data; generate
hashes and HMACs of data; and act as a source of random bytes.
See
https://developer.hashicorp.com/vault/docs/secrets/transit
for an introduction to the capabilities of the <code>transit</code>
engine.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_client_transit</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_client_transit-new"><code>vault_client_transit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-custom_mount"><code>vault_client_transit$custom_mount()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_create"><code>vault_client_transit$key_create()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_read"><code>vault_client_transit$key_read()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_list"><code>vault_client_transit$key_list()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_delete"><code>vault_client_transit$key_delete()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_update"><code>vault_client_transit$key_update()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_rotate"><code>vault_client_transit$key_rotate()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_export"><code>vault_client_transit$key_export()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-data_encrypt"><code>vault_client_transit$data_encrypt()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-data_decrypt"><code>vault_client_transit$data_decrypt()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-data_rewrap"><code>vault_client_transit$data_rewrap()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-datakey_create"><code>vault_client_transit$datakey_create()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-random"><code>vault_client_transit$random()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-hash"><code>vault_client_transit$hash()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-hmac"><code>vault_client_transit$hmac()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-sign"><code>vault_client_transit$sign()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-verify_signature"><code>vault_client_transit$verify_signature()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-verify_hmac"><code>vault_client_transit$verify_hmac()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_backup"><code>vault_client_transit$key_backup()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_restore"><code>vault_client_transit$key_restore()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_client_transit-key_trim"><code>vault_client_transit$key_trim()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_client_transit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_client_transit</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$new(api_client, mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api_client</code></dt><dd><p>A <a href="#topic+vault_api_client">vault_api_client</a> object</p>
</dd>
<dt><code>mount</code></dt><dd><p>Mount point for the backend</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-custom_mount"></a>



<h4>Method <code>custom_mount()</code></h4>

<p>Set up a <code>vault_client_transit</code> object at a custom
mount.  For example, suppose you mounted the <code>transit</code> secret
backend at <code style="white-space: pre;">&#8288;/transit2&#8288;</code> you might use <code>tr &lt;- vault$secrets$transit$custom_mount("/transit2")</code> - this
pattern is repeated for other secret and authentication
backends.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$custom_mount(mount)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mount</code></dt><dd><p>String, indicating the path that the engine is
mounted at.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-key_create"></a>



<h4>Method <code>key_create()</code></h4>

<p>Create a new named encryption key of the specified
type. The values set here cannot be changed after key
creation.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_create(
  name,
  key_type = NULL,
  convergent_encryption = NULL,
  derived = NULL,
  exportable = NULL,
  allow_plaintext_backup = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name for the key.  This will be used in all future
interactions with the key - the key itself is not returned.</p>
</dd>
<dt><code>key_type</code></dt><dd><p>Specifies the type of key to create.  The default is
<code>aes256-gcm96</code>. The currently-supported types are:
</p>

<ul>
<li> <p><code>aes256-gcm96</code>: AES-256 wrapped with GCM using a 96-bit nonce
size AEAD (symmetric, supports derivation and convergent
encryption)
</p>
</li>
<li> <p><code>chacha20-poly1305</code>: ChaCha20-Poly1305 AEAD (symmetric,
supports derivation and convergent encryption)
</p>
</li>
<li> <p><code>ed25519</code>: ED25519 (asymmetric, supports derivation). When
using derivation, a sign operation with the same context will
derive the same key and signature; this is a signing analogue
to <code>convergent_encryption</code>
</p>
</li>
<li> <p><code>ecdsa-p256</code>: ECDSA using the P-256 elliptic curve
(asymmetric)
</p>
</li>
<li> <p><code>rsa-2048</code>: RSA with bit size of 2048 (asymmetric)
</p>
</li>
<li> <p><code>rsa-4096</code>: RSA with bit size of 4096 (asymmetric)
</p>
</li></ul>
</dd>
<dt><code>convergent_encryption</code></dt><dd><p>Logical with default of <code>FALSE</code>.
If <code>TRUE</code>, then the key will support convergent encryption,
where the same plaintext creates the same ciphertext. This
requires derived to be set to true. When enabled, each
encryption(/decryption/rewrap/datakey) operation will derive
a <code>nonce</code> value rather than randomly generate it.</p>
</dd>
<dt><code>derived</code></dt><dd><p>Specifies if key derivation is to be used. If
enabled, all encrypt/decrypt requests to this named key must
provide a context which is used for key derivation (default
is <code>FALSE</code>).</p>
</dd>
<dt><code>exportable</code></dt><dd><p>Enables keys to be exportable. This allows
for all the valid keys in the key ring to be exported. Once
set, this cannot be disabled (default is <code>FALSE</code>).</p>
</dd>
<dt><code>allow_plaintext_backup</code></dt><dd><p>If set, enables taking backup of
named key in the plaintext format. Once set, this cannot be
disabled (default is <code>FALSE</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-key_read"></a>



<h4>Method <code>key_read()</code></h4>

<p>Read information about a previously generated key.
The returned object shows the creation time of each key
version; the values are not the keys themselves. Depending on
the type of key, different information may be returned,
e.g. an asymmetric key will return its public key in a
standard format for the type.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_read(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the key to read</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-key_list"></a>



<h4>Method <code>key_list()</code></h4>

<p>List names of all keys
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_list()</pre></div>


<hr>
<a id="method-vault_client_transit-key_delete"></a>



<h4>Method <code>key_delete()</code></h4>

<p>Delete a key by name.  It will no longer be
possible to decrypt any data encrypted with the named
key. Because this is a potentially catastrophic operation,
the <code>deletion_allowed</code> tunable must be set using
<code style="white-space: pre;">&#8288;$key_update()&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_delete(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the key to delete.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-key_update"></a>



<h4>Method <code>key_update()</code></h4>

<p>This method allows tuning configuration values for
a given key. (These values are returned during a read
operation on the named key.)
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_update(
  name,
  min_decryption_version = NULL,
  min_encryption_version = NULL,
  deletion_allowed = NULL,
  exportable = NULL,
  allow_plaintext_backup = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the key to update</p>
</dd>
<dt><code>min_decryption_version</code></dt><dd><p>Specifies the minimum version of
ciphertext allowed to be decrypted, as an integer (default is
<code>0</code>). Adjusting this as part of a key rotation policy can
prevent old copies of ciphertext from being decrypted, should
they fall into the wrong hands. For signatures, this value
controls the minimum version of signature that can be
verified against. For HMACs, this controls the minimum
version of a key allowed to be used as the key for
verification.</p>
</dd>
<dt><code>min_encryption_version</code></dt><dd><p>Specifies the minimum version of
the key that can be used to encrypt plaintext, sign payloads,
or generate HMACs, as an integer (default is <code>0</code>).  Must be 0
(which will use the latest version) or a value greater or
equal to <code>min_decryption_version</code>.</p>
</dd>
<dt><code>deletion_allowed</code></dt><dd><p>Specifies if the key is allowed to be
deleted, as a logical (default is <code>FALSE</code>).</p>
</dd>
<dt><code>exportable</code></dt><dd><p>Enables keys to be exportable. This allows
for all the valid keys in the key ring to be exported. Once
set, this cannot be disabled.</p>
</dd>
<dt><code>allow_plaintext_backup</code></dt><dd><p>If set, enables taking backup of
named key in the plaintext format. Once set, this cannot be
disabled.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-key_rotate"></a>



<h4>Method <code>key_rotate()</code></h4>

<p>Rotates the version of the named key. After
rotation, new plaintext requests will be encrypted with the
new version of the key. To upgrade ciphertext to be encrypted
with the latest version of the key, use the rewrap
endpoint. This is only supported with keys that support
encryption and decryption operations.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_rotate(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the key to rotate</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-key_export"></a>



<h4>Method <code>key_export()</code></h4>

<p>Export the named key. If version is specified, the
specific version will be returned. If latest is provided as
the version, the current key will be provided. Depending on
the type of key, different information may be returned. The
key must be exportable to support this operation and the
version must still be valid.
</p>
<p>For more details see
https://github.com/hashicorp/vault/issues/2667 where
HashiCorp says &quot;Part of the &quot;contract&quot; of transit is that the
key is never exposed outside of Vault. We added the ability
to export keys because some enterprises have key escrow
requirements, but it leaves a permanent mark in the key
metadata. I suppose we could at some point allow importing a
key and also leave such a mark.&quot;
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_export(name, key_type, version = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the key to export</p>
</dd>
<dt><code>key_type</code></dt><dd><p>Specifies the type of the key to export. Valid
values are <code>encryption-key</code>, <code>signing-key</code> and <code>hmac-key</code>.</p>
</dd>
<dt><code>version</code></dt><dd><p>Specifies the version of the key to read. If
omitted, all versions of the key will be returned. If the
version is set to latest, the current key will be returned</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-data_encrypt"></a>



<h4>Method <code>data_encrypt()</code></h4>

<p>This endpoint encrypts the provided plaintext
using the named key.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$data_encrypt(
  key_name,
  data,
  key_version = NULL,
  context = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key_name</code></dt><dd><p>Specifies the name of the encryption key to
encrypt against.</p>
</dd>
<dt><code>data</code></dt><dd><p>Data to encrypt, as a raw vector</p>
</dd>
<dt><code>key_version</code></dt><dd><p>Key version to use, as an integer. If not
set, uses the latest version. Must be greater than or equal
to the key's <code>min_encryption_version</code>, if set.</p>
</dd>
<dt><code>context</code></dt><dd><p>Specifies the context for key derivation. This
is required if key derivation is enabled for this key.  Must
be a raw vector.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-data_decrypt"></a>



<h4>Method <code>data_decrypt()</code></h4>

<p>Decrypts the provided ciphertext using the named
key.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$data_decrypt(key_name, data, context = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key_name</code></dt><dd><p>Specifies the name of the encryption key to
decrypt with.</p>
</dd>
<dt><code>data</code></dt><dd><p>The data to decrypt.  Must be a string, as returned
by <code style="white-space: pre;">&#8288;$data_encrypt&#8288;</code>.</p>
</dd>
<dt><code>context</code></dt><dd><p>Specifies the context for key derivation. This
is required if key derivation is enabled for this key.  Must
be a raw vector.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-data_rewrap"></a>



<h4>Method <code>data_rewrap()</code></h4>

<p>Rewraps the provided ciphertext using the latest
version of the named key. Because this never returns
plaintext, it is possible to delegate this functionality to
untrusted users or scripts.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$data_rewrap(
  key_name,
  data,
  key_version = NULL,
  context = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key_name</code></dt><dd><p>Specifies the name of the encryption key to
re-encrypt against</p>
</dd>
<dt><code>data</code></dt><dd><p>The data to decrypt.  Must be a string, as returned
by <code style="white-space: pre;">&#8288;$data_encrypt&#8288;</code>.</p>
</dd>
<dt><code>key_version</code></dt><dd><p>Specifies the version of the key to use for
the operation. If not set, uses the latest version. Must be
greater than or equal to the key's <code>min_encryption_version</code>,
if set.</p>
</dd>
<dt><code>context</code></dt><dd><p>Specifies the context for key derivation. This
is required if key derivation is enabled for this key.  Must
be a raw vector.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-datakey_create"></a>



<h4>Method <code>datakey_create()</code></h4>

<p>This endpoint generates a new high-entropy key and
the value encrypted with the named key. Optionally return the
plaintext of the key as well.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$datakey_create(
  name,
  plaintext = FALSE,
  bits = NULL,
  context = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Specifies the name of the encryption key to use to
encrypt the datakey</p>
</dd>
<dt><code>plaintext</code></dt><dd><p>Logical, indicating if the plaintext key
should be returned.</p>
</dd>
<dt><code>bits</code></dt><dd><p>Specifies the number of bits in the desired
key. Can be 128, 256, or 512.</p>
</dd>
<dt><code>context</code></dt><dd><p>Specifies the context for key derivation. This
is required if key derivation is enabled for this key.  Must
be a raw vector.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-random"></a>



<h4>Method <code>random()</code></h4>

<p>Generates high-quality random bytes of the
specified length.  This is totally independent of R's random
number stream and provides random numbers suitable for
cryptographic purposes.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$random(bytes = 32, format = "hex")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bytes</code></dt><dd><p>Number of bytes to generate (as an integer)</p>
</dd>
<dt><code>format</code></dt><dd><p>The output format to produce; must be one of
<code>hex</code> (a single hex string such as <code>d1189e2f83b72ab6</code>),
<code>base64</code> (a single base64 encoded string such as
<code style="white-space: pre;">&#8288;8TDJekY0mYs=&#8288;</code>) or <code>raw</code> (a raw vector of length <code>bytes</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-hash"></a>



<h4>Method <code>hash()</code></h4>

<p>Generates a cryptographic hash of given data using
the specified algorithm.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$hash(data, algorithm = NULL, format = "hex")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A raw vector of data to hash.  To generate a raw
vector from an R object, one option is to use <code>unserialize(x, NULL)</code> but be aware that version information may be included.
Alternatively, for a string, one might use <code>charToRaw</code>.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>A string indicating the hash algorithm to use.
The exact set of supported algorithms may depend by vault
server version, but as of version 1.0.0 vault supports
<code>sha2-224</code>, <code>sha2-256</code>, <code>sha2-384</code> and <code>sha2-512</code>.  The
default is <code>sha2-256</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output - must be one of <code>hex</code>
or <code>base64</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-hmac"></a>



<h4>Method <code>hmac()</code></h4>

<p>This endpoint returns the digest of given data
using the specified hash algorithm and the named key. The key
can be of any type supported by the <code>transit</code> engine; the raw
key will be marshalled into bytes to be used for the HMAC
function. If the key is of a type that supports rotation, the
latest (current) version will be used.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$hmac(name, data, key_version = NULL, algorithm = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Specifies the name of the encryption key to
generate hmac against</p>
</dd>
<dt><code>data</code></dt><dd><p>The input data, as a raw vector</p>
</dd>
<dt><code>key_version</code></dt><dd><p>Specifies the version of the key to use for
the operation. If not set, uses the latest version. Must be
greater than or equal to the key's <code>min_encryption_version</code>,
if set.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Specifies the hash algorithm to
use. Currently-supported algorithms are <code>sha2-224</code>,
<code>sha2-256</code>, <code>sha2-384</code> and <code>sha2-512</code>.  The default is
<code>sha2-256</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-sign"></a>



<h4>Method <code>sign()</code></h4>

<p>Returns the cryptographic signature of the given
data using the named key and the specified hash
algorithm. The key must be of a type that supports signing.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$sign(
  name,
  data,
  key_version = NULL,
  hash_algorithm = NULL,
  prehashed = FALSE,
  signature_algorithm = NULL,
  context = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Specifies the name of the encryption key to use for
signing</p>
</dd>
<dt><code>data</code></dt><dd><p>The input data, as a raw vector</p>
</dd>
<dt><code>key_version</code></dt><dd><p>Specifies the version of the key to use for
signing. If not set, uses the latest version. Must be greater
than or equal to the key's <code>min_encryption_version</code>, if set.</p>
</dd>
<dt><code>hash_algorithm</code></dt><dd><p>Specifies the hash algorithm to
use. Currently-supported algorithms are <code>sha2-224</code>,
<code>sha2-256</code>, <code>sha2-384</code> and <code>sha2-512</code>.  The default is
<code>sha2-256</code>.</p>
</dd>
<dt><code>prehashed</code></dt><dd><p>Set to true when the input is already
hashed. If the key type is <code>rsa-2048</code> or <code>rsa-4096</code>, then the
algorithm used to hash the input should be indicated by the
<code>hash_algorithm</code> parameter.</p>
</dd>
<dt><code>signature_algorithm</code></dt><dd><p>When using a RSA key, specifies the
RSA signature algorithm to use for signing. Supported
signature types are <code>pss</code> (the default) and <code>pkcs1v15</code>.</p>
</dd>
<dt><code>context</code></dt><dd><p>Specifies the context for key derivation. This
is required if key derivation is enabled for this key.  Must
be a raw vector.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-verify_signature"></a>



<h4>Method <code>verify_signature()</code></h4>

<p>Determine whether the provided signature is valid
for the given data.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$verify_signature(
  name,
  data,
  signature,
  hash_algorithm = NULL,
  signature_algorithm = NULL,
  context = NULL,
  prehashed = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the key</p>
</dd>
<dt><code>data</code></dt><dd><p>Data to verify, as a raw vector</p>
</dd>
<dt><code>signature</code></dt><dd><p>The signed data, as a string.</p>
</dd>
<dt><code>hash_algorithm</code></dt><dd><p>Specifies the hash algorithm to use. This
can also be specified as part of the URL (see <code style="white-space: pre;">&#8288;$sign&#8288;</code> and
<code style="white-space: pre;">&#8288;$hmac&#8288;</code> for details).</p>
</dd>
<dt><code>signature_algorithm</code></dt><dd><p>When using a RSA key, specifies the
RSA signature algorithm to use for signature verification</p>
</dd>
<dt><code>context</code></dt><dd><p>Specifies the context for key derivation. This
is required if key derivation is enabled for this key.  Must
be a raw vector.</p>
</dd>
<dt><code>prehashed</code></dt><dd><p>Set to <code>TRUE</code> when the input is already hashed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-verify_hmac"></a>



<h4>Method <code>verify_hmac()</code></h4>

<p>Determine whether the provided signature is valid
for the given data.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$verify_hmac(
  name,
  data,
  signature,
  hash_algorithm = NULL,
  signature_algorithm = NULL,
  context = NULL,
  prehashed = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the key</p>
</dd>
<dt><code>data</code></dt><dd><p>Data to verify, as a raw vector</p>
</dd>
<dt><code>signature</code></dt><dd><p>The signed data, as a string.</p>
</dd>
<dt><code>hash_algorithm</code></dt><dd><p>Specifies the hash algorithm to use. This
can also be specified as part of the URL (see <code style="white-space: pre;">&#8288;$sign&#8288;</code> and
<code style="white-space: pre;">&#8288;$hmac&#8288;</code> for details).</p>
</dd>
<dt><code>signature_algorithm</code></dt><dd><p>When using a RSA key, specifies the
RSA signature algorithm to use for signature verification</p>
</dd>
<dt><code>context</code></dt><dd><p>Specifies the context for key derivation. This
is required if key derivation is enabled for this key.  Must
be a raw vector.</p>
</dd>
<dt><code>prehashed</code></dt><dd><p>Set to <code>TRUE</code> when the input is already hashed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-key_backup"></a>



<h4>Method <code>key_backup()</code></h4>

<p>Returns a plaintext backup of a named key. The
backup contains all the configuration data and keys of all
the versions along with the HMAC key. The response from this
endpoint can be used with <code style="white-space: pre;">&#8288;$key_restore&#8288;</code> to restore the key.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_backup(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the key to backup</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-key_restore"></a>



<h4>Method <code>key_restore()</code></h4>

<p>Restores the backup as a named key. This will
restore the key configurations and all the versions of the
named key along with HMAC keys. The input to this method
should be the output of <code style="white-space: pre;">&#8288;$key_restore&#8288;</code> method.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_restore(name, backup, force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the restored key.</p>
</dd>
<dt><code>backup</code></dt><dd><p>Backed up key data to be restored. This should be
the output from the <code style="white-space: pre;">&#8288;$key_backup&#8288;</code> endpoint.</p>
</dd>
<dt><code>force</code></dt><dd><p>Logical.  If <code>TRUE</code>, then force the restore to
proceed even if a key by this name already exists.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_client_transit-key_trim"></a>



<h4>Method <code>key_trim()</code></h4>

<p>This endpoint trims older key versions setting a
minimum version for the keyring. Once trimmed, previous
versions of the key cannot be recovered.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_client_transit$key_trim(name, min_version)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Key to trim</p>
</dd>
<dt><code>min_version</code></dt><dd><p>The minimum version for the key ring. All
versions before this version will be permanently
deleted. This value can at most be equal to the lesser of
<code>min_decryption_version</code> and <code>min_encryption_version</code>. This
is not allowed to be set when either <code>min_encryption_version</code>
or <code>min_decryption_version</code> is set to zero.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>server &lt;- vaultr::vault_test_server(if_disabled = message)
if (!is.null(server)) {
  client &lt;- server$client()

  client$secrets$enable("transit")
  transit &lt;- client$secrets$transit

  # Before encrypting anything, create a key.  Note that it will
  # not be returned to you, and is accessed purely by name
  transit$key_create("test")

  # Some text to encrypt
  plaintext &lt;- "hello world"

  # Encrypted:
  cyphertext &lt;- transit$data_encrypt("test", charToRaw(plaintext))

  # Decrypt the data
  res &lt;- transit$data_decrypt("test", cyphertext)
  rawToChar(res)

  # This approach works with R objects too, if used with serialise.
  # First, serialise an R object to a raw vector:
  data &lt;- serialize(mtcars, NULL)

  # Then encrypt this data:
  enc &lt;- transit$data_encrypt("test", data)

  # The resulting string can be safely passed around (e.g., over
  # email) or written to disk, and can later be decrypted by
  # anyone who has access to the "test" key in the vault:
  data2 &lt;- transit$data_decrypt("test", enc)

  # Once decrypted, the data can be "unserialised" back into an R
  # object:
  unserialize(data2)

  # cleanup
  server$kill()
}
</code></pre>

<hr>
<h2 id='vault_resolve_secrets'>Resolve secrets from R objects</h2><span id='topic+vault_resolve_secrets'></span>

<h3>Description</h3>

<p>Use vault to resolve secrets.  This is a convenience function that
wraps a pattern that we have used in a few applications of vault.
The idea is to allow replacement of data in configuration with
special strings that indicate that the string refers to a vault
secret.  This function resolves those secrets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vault_resolve_secrets(x, ..., login = TRUE, vault_args = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vault_resolve_secrets_+3A_x">x</code></td>
<td>
<p>List of values, some of which may refer to vault secrets
(see Details for pattern).  Any values that are not strings or
do not match the pattern of a secret are left as-is.</p>
</td></tr>
<tr><td><code id="vault_resolve_secrets_+3A_...">...</code></td>
<td>
<p>Args to be passed to <a href="#topic+vault_client">vault_client</a> call.</p>
</td></tr>
<tr><td><code id="vault_resolve_secrets_+3A_login">login</code></td>
<td>
<p>Login method to be passed to call to
<a href="#topic+vault_client">vault_client</a>.</p>
</td></tr>
<tr><td><code id="vault_resolve_secrets_+3A_vault_args">vault_args</code></td>
<td>
<p>As an alternative to using <code>login</code> and <code>...</code>, a
list of (named) arguments can be provided here, equivalent to
the full set of arguments that you might pass to
<a href="#topic+vault_client">vault_client</a>.  If provided, then <code>login</code> is ignored
and if additional arguments are provided through <code>...</code> an error
will be thrown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each element of the data, if a string matches the form:
</p>
<div class="sourceCode"><pre>  VAULT:&lt;path to secret&gt;:&lt;field&gt;
</pre></div>
<p>then it will be treated as a vault secret and resolved.  The
<code style="white-space: pre;">&#8288;&lt;path to get&gt;&#8288;</code> will be something like
<code style="white-space: pre;">&#8288;/secret/path/password&#8288;</code> and the <code style="white-space: pre;">&#8288;&lt;field&gt;&#8288;</code> the name of a
field in the key/value data stored at that path.  For example,
suppose you have the data <code>list(username = "alice", password = "s3cret!")</code> stored at <code style="white-space: pre;">&#8288;/secret/database/user&#8288;</code>, then the
string
</p>
<div class="sourceCode"><pre>  VAULT:/secret/database/user:password
</pre></div>
<p>would refer to the value <code style="white-space: pre;">&#8288;s3cret!&#8288;</code>
</p>


<h3>Value</h3>

<p>List of properties with any vault secrets resolved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
server &lt;- vaultr::vault_test_server(if_disabled = message)

if (!is.null(server)) {
  client &lt;- server$client()
  # The example from above:
  client$write("/secret/database/user",
               list(username = "alice", password = "s3cret!"))

  # A list of data that contains a mix of secrets to be resolved
  # and other data:
  x &lt;- list(user = "alice",
            password = "VAULT:/secret/database/user:password",
            port = 5678)

  # Explicitly pass in the login details and resolve the secrets:
  vaultr::vault_resolve_secrets(x, login = "token", token = server$token,
                                addr = server$addr)

  # Alternatively, if appropriate environment variables are set
  # then this can be done more easily:
  if (requireNamespace("withr", quietly = TRUE)) {
    env &lt;- c(VAULTR_AUTH_METHOD = "token",
             VAULT_TOKEN = server$token,
             VAULT_ADDR = server$addr)
    withr::with_envvar(env, vault_resolve_secrets(x))
  }
}
</code></pre>

<hr>
<h2 id='vault_test_server'>Control a test vault server</h2><span id='topic+vault_test_server'></span><span id='topic+vault_server_instance'></span>

<h3>Description</h3>

<p>Control a server for use with testing.  This is designed to be
used only by other packages that wish to run tests against a vault
server.  You will need to set <code>VAULTR_TEST_SERVER_BIN_PATH</code> to
point at the directory containing the vault binary, to the binary
itself, or to the value <code>auto</code> to try and find it on your <code>PATH</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vault_test_server(
  https = FALSE,
  init = TRUE,
  if_disabled = testthat::skip,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vault_test_server_+3A_https">https</code></td>
<td>
<p>Logical scalar, indicating if a https-using server
should be created, rather than the default vault dev-mode
server.  This is still <em>entirely</em> insecure, and uses self
signed certificates that are bundled with the package.</p>
</td></tr>
<tr><td><code id="vault_test_server_+3A_init">init</code></td>
<td>
<p>Logical scalar, indicating if the https-using server
should be initialised.</p>
</td></tr>
<tr><td><code id="vault_test_server_+3A_if_disabled">if_disabled</code></td>
<td>
<p>Callback function to run if the vault server is
not enabled.  The default, designed to be used within tests, is
<code>testthat::skip</code>.  Alternatively, inspect the
<code style="white-space: pre;">&#8288;$enabled&#8288;</code> property of the returned object.</p>
</td></tr>
<tr><td><code id="vault_test_server_+3A_quiet">quiet</code></td>
<td>
<p>Logical, indicating if startup should be quiet and
not print messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once created with <code>vault_test_server</code>, a server will stay
alive for as long as the R process is alive <em>or</em> until the
<code>vault_server_instance</code> object goes out of scope and is
garbage collected.  Calling <code style="white-space: pre;">&#8288;$kill()&#8288;</code> will explicitly stop
the server, but this is not strictly needed.  See below for
methods to control the server instance.
</p>


<h3>Warning</h3>

<p>Starting a server in test mode must <em>not</em> be used for production
under any circumstances.  As the name suggests,
<code>vault_test_server</code> is a server suitable for <em>tests</em> only and
lacks any of the features required to make vault secure.  For
more information, please see the the official Vault
documentation on development servers:
https://developer.hashicorp.com/vault/docs/concepts/dev-server
</p>


<h3>Super class</h3>

<p><code><a href="#topic+vault_client_object">vaultr::vault_client_object</a></code> -&gt; <code>vault_server_instance</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>port</code></dt><dd><p>The vault port (read-only).</p>
</dd>
<dt><code>addr</code></dt><dd><p>The vault address; this is suitable for using with
<a href="#topic+vault_client">vault_client</a> (read-only).</p>
</dd>
<dt><code>token</code></dt><dd><p>The vault root token, from when the testing vault
server was created.  If the vault is rekeyed this will no
longer be accurate (read-only).</p>
</dd>
<dt><code>keys</code></dt><dd><p>Key shares from when the vault was initialised
(read-only).</p>
</dd>
<dt><code>cacert</code></dt><dd><p>Path to the https certificate, if running in
https mode (read-only).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-vault_server_instance-new"><code>vault_server_instance$new()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_server_instance-version"><code>vault_server_instance$version()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_server_instance-client"><code>vault_server_instance$client()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_server_instance-env"><code>vault_server_instance$env()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_server_instance-export"><code>vault_server_instance$export()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_server_instance-clear_cached_token"><code>vault_server_instance$clear_cached_token()</code></a>
</p>
</li>
<li> <p><a href="#method-vault_server_instance-kill"><code>vault_server_instance$kill()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="format"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-format'><code>vaultr::vault_client_object$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vaultr" data-topic="vault_client_object" data-id="help"><a href='../../vaultr/html/vault_client_object.html#method-vault_client_object-help'><code>vaultr::vault_client_object$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-vault_server_instance-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>vault_server_instance</code> object. Not typically
called by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_server_instance$new(bin, port, https, init, quiet = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bin</code></dt><dd><p>Path to the vault binary</p>
</dd>
<dt><code>port</code></dt><dd><p>Port to use</p>
</dd>
<dt><code>https</code></dt><dd><p>Logical, indicating if we should use TLS/https</p>
</dd>
<dt><code>init</code></dt><dd><p>Logical, indicating if we should initialise</p>
</dd>
<dt><code>quiet</code></dt><dd><p>Logical, indicating if startup should be quiet</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_server_instance-version"></a>



<h4>Method <code>version()</code></h4>

<p>Return the server version, as a <a href="base.html#topic+numeric_version">numeric_version</a>
object.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_server_instance$version()</pre></div>


<hr>
<a id="method-vault_server_instance-client"></a>



<h4>Method <code>client()</code></h4>

<p>Create a new client that can use this server.  The
client will be a <a href="#topic+vault_client">vault_client</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_server_instance$client(login = TRUE, quiet = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>login</code></dt><dd><p>Logical, indicating if the client should login to
the server (default is <code>TRUE</code>).</p>
</dd>
<dt><code>quiet</code></dt><dd><p>Logical, indicating if informational messages
should be suppressed.  Default is <code>TRUE</code>, in contrast with
most other methods.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-vault_server_instance-env"></a>



<h4>Method <code>env()</code></h4>

<p>Return a named character vector of environment
variables that can be used to communicate with this vault
server (<code>VAULT_ADDR</code>, <code>VAULT_TOKEN</code>, etc).
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_server_instance$env()</pre></div>


<hr>
<a id="method-vault_server_instance-export"></a>



<h4>Method <code>export()</code></h4>

<p>Export the variables returned by the <code style="white-space: pre;">&#8288;$env()&#8288;</code>
method to the environment.  This makes them available to
child processes.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_server_instance$export()</pre></div>


<hr>
<a id="method-vault_server_instance-clear_cached_token"></a>



<h4>Method <code>clear_cached_token()</code></h4>

<p>Clear any session-cached token for this server.
This is intended for testing new authentication backends.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_server_instance$clear_cached_token()</pre></div>


<hr>
<a id="method-vault_server_instance-kill"></a>



<h4>Method <code>kill()</code></h4>

<p>Kill the server.
</p>


<h5>Usage</h5>

<div class="r"><pre>vault_server_instance$kill()</pre></div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Try and start a server; if one is not enabled (see details
# above) then this will return NULL
server &lt;- vault_test_server(if_disabled = message)

if (!is.null(server)) {
  # We now have a server running on an arbitrary high port - note
  # that we are running over http and in dev mode: this is not at
  # all suitable for production use, just for tests
  server$addr

  # Create clients using the client method - by default these are
  # automatically authenticated against the server
  client &lt;- server$client()
  client$write("/secret/password", list(value = "s3cret!"))
  client$read("/secret/password")

  # The server stops automatically when the server object is
  # garbage collected, or it can be turned off with the
  # 'kill' method:
  server$kill()
  tryCatch(client$status(), error = function(e) message(e$message))
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
