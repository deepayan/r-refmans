<!DOCTYPE html><html lang="en"><head><title>Help for package ioanalysis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ioanalysis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agg.region'><p>Aggregate Regions</p></a></li>
<li><a href='#agg.sector'><p>Aggregate Sectors</p></a></li>
<li><a href='#as.inputoutput'><p>Creating an Input-Output Object</p></a></li>
<li><a href='#check.RS'>
<p>Do all regions have the same sectors?</p></a></li>
<li><a href='#easy.select'><p>Region and Sector Selection Interface</p></a></li>
<li><a href='#export.coef'><p>Calculates the Matrix of Trade Coefficients</p></a></li>
<li><a href='#export.total'><p>Calculates Total Exports for InputOutput Objects</p></a></li>
<li><a href='#extraction'><p>Hypothetical Extraction</p></a></li>
<li><a href='#f.influence'><p>Field of Influence</p></a></li>
<li><a href='#f.influence.total'><p>Field of Influence (Total)</p></a></li>
<li><a href='#feedback.loop'><p>Feedback Loop Analysis</p></a></li>
<li><a href='#ghosh.inv'><p>Ghoshian Inverse</p></a></li>
<li><a href='#heatmap.io'><p>Heatmap Visualization</p></a></li>
<li><a href='#hist3d.io'><p>3D Histogram of Input-Output object</p></a></li>
<li><a href='#inverse.important'>
<p>Inverse.Important Coefficients</p></a></li>
<li><a href='#ioanalysis'><p>ioanalysis</p></a></li>
<li><a href='#key.sector'><p>Impact Analysis via Backward and Forward Linkages</p></a></li>
<li><a href='#leontief.inv'><p>Leontief Inverse</p></a></li>
<li><a href='#linkages'><p>Backward and Forward Linkages</p></a></li>
<li><a href='#locate.mismatch'><p>Identify Sectors not in All Regions</p></a></li>
<li><a href='#lq'>
<p>Simple Location Quotient Updating</p></a></li>
<li><a href='#mpm'><p>Multiplier Product Matrix</p></a></li>
<li><a href='#multipliers'><p>Multiplier Analysis</p></a></li>
<li><a href='#output.decomposition'><p>Decomposition of Output Changes</p></a></li>
<li><a href='#ras'>
<p>ras Updating Proejcting</p></a></li>
<li><a href='#rsp'><p>Regional Supply Percentage Updating</p></a></li>
<li><a href='#toy.ES'><p>An example dataset of class <code>EasySelect</code></p></a></li>
<li><a href='#toy.FullIOTable'><p>An example data set to illustrate as.inputoutput</p></a></li>
<li><a href='#toy.IO'>
<p>An example dataset of class <code>InputOutput</code></p></a></li>
<li><a href='#upstream'>
<p>Upstreamness - Average Distance from Final Use</p></a></li>
<li><a href='#vs'><p>Vertical Specialization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Input Output Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Author:</td>
<td>John Wade [aut, cre],
  Ignacio Sarmiento-Barbieri [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Wade &lt;jjpwade2@illinois.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates fundamental IO matrices (Leontief, Wassily W. (1951) &lt;<a href="https://doi.org/10.1038%2Fscientificamerican1051-15">doi:10.1038/scientificamerican1051-15</a>&gt;); within period analysis via various rankings and coefficients (Sonis and Hewings (2006) &lt;<a href="https://doi.org/10.1080%2F09535319200000013">doi:10.1080/09535319200000013</a>&gt;, Blair and Miller (2009) &lt;ISBN:978-0-521-73902-3&gt;, Antras et al (2012) &lt;<a href="https://doi.org/10.3386%2Fw17819">doi:10.3386/w17819</a>&gt;, Hummels, Ishii, and Yi (2001) &lt;<a href="https://doi.org/10.1016%2FS0022-1996%2800%2900093-3">doi:10.1016/S0022-1996(00)00093-3</a>&gt;); across period analysis with impact analysis (Dietzenbacher, van der Linden, and Steenge (2006) &lt;<a href="https://doi.org/10.1080%2F09535319300000017">doi:10.1080/09535319300000017</a>&gt;, Sonis, Hewings, and Guo (2006) &lt;<a href="https://doi.org/10.1080%2F09535319600000002">doi:10.1080/09535319600000002</a>&gt;); and a variety of table operators.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), ggplot2, plot3D, lpSolve, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.real.illinois.edu">http://www.real.illinois.edu</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-18 17:12:50 UTC; johnj</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-18 17:40:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='agg.region'>Aggregate Regions</h2><span id='topic+agg.region'></span>

<h3>Description</h3>

<p><code>agg.sector</code> takes specified regions and creates a &quot;new&quot; joint region. This produces a new <code>InputOutput</code> object. Note the Leontief Inverse and Ghoshian Inverse are elements. All regions must have exactly the same sectors. See <code><a href="#topic+locate.mismatch">locate.mismatch</a></code>.
</p>
<p>Caution: Inverting large matrices will take a long time. R does a computation roughly every 8e-10 second. The number of computations per matrix inversion is n^3 where n is the dimension of the square matrix. For n = 5000 it should take 100 seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg.region(io, regions, newname = "newname")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agg.region_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="agg.region_+3A_regions">regions</code></td>
<td>
<p>Character. Specific regions to be aggregated. Can either be a character that exactly matches the name of the region in <code>RS_label</code> or the number of the region in the order it appears in <code>RS_label</code>. May also be <code>'all'</code> to select all regions.</p>
</td></tr>
<tr><td><code id="agg.region_+3A_newname">newname</code></td>
<td>
<p>Character. The name to give to the new aggregated region.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an aggregation matrix similar to that of <code><a href="#topic+agg.sector">agg.sector</a></code>. See  Blair and Miller 2009 for more details.
</p>


<h3>Value</h3>

<p>A new <code>InputOutput</code> object is created. See <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>.</p>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri</p>


<h3>References</h3>

<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code>, <code><a href="#topic+locate.mismatch">locate.mismatch</a></code>, <code><a href="#topic+agg.region">agg.region</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
agg.region(toy.IO, regions = c(1,2), newname = "Magic")

</code></pre>

<hr>
<h2 id='agg.sector'>Aggregate Sectors</h2><span id='topic+agg.sector'></span>

<h3>Description</h3>

<p><code>agg.sector</code> takes specified sectors and creates a &quot;new&quot; joint sector. This produces a new <code>InputOutput</code> object. Note the Leontief Inverse and Ghoshian Inverse are elements. There is deliberately no warning if the sector does not occur in all regions. See <code><a href="#topic+locate.mismatch">locate.mismatch</a></code>.
</p>
<p>Caution: Inverting large matrices will take a long time. R does a computation roughly every 8e-10 second. The number of computations per matrix inversion is n^3 where n is the dimension of the square matrix. For n = 5000 it should take 100 seconds.</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg.sector(io, sectors, newname = "newname")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agg.sector_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="agg.sector_+3A_sectors">sectors</code></td>
<td>
<p>Character. Specific sectors to be aggregated. Can either be a character that exactly matches the name of the sector in <code>RS_label</code> or the number of the sector in the order it appears in <code>RS_label</code>. May also be <code>'all'</code> to select all sectors.</p>
</td></tr>
<tr><td><code id="agg.sector_+3A_newname">newname</code></td>
<td>
<p>Character. The name to give to the new aggregated sector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates the aggregation matrix to pre (and/or post when appropriate) to aggregate the matrices in the <code>InputOutput</code> object. Say you have 1 region with n sectors and you wish to aggregate sectors i and i+1. A diagonal matrix is converted into a n-1xn matrix where rows i and i+1 are additively combined together. This matrix is then used to create new aggregated tables. The &quot;new&quot; sector is then stored in location i. See  Blair and Miller 2009 for more details.</p>


<h3>Value</h3>

<p>A new <code>InputOutput</code> object is created. See <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>.</p>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri</p>


<h3>References</h3>

<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code>, <code><a href="#topic+locate.mismatch">locate.mismatch</a></code>, <code><a href="#topic+agg.region">agg.region</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
newIO &lt;- agg.sector(toy.IO, sectors = c(1,2), newname = "Party.Supplies")
</code></pre>

<hr>
<h2 id='as.inputoutput'>Creating an Input-Output Object</h2><span id='topic+as.inputoutput'></span>

<h3>Description</h3>

<p>Creates a list of class <code>InputOutput</code> for easier use of the other functions within <code>ioanalysis</code>.
The Leontief inverse and Ghoshian inverse are calculated.
A little work now to save a bunch of work in the future.
For most functions in the package, this is a prerequisite.
At a minimum, <code>Z</code>, <code>X</code>, and <code>RS_label</code> must be provided.
See <code>Usage</code> for details.
</p>
<p>Caution: Inverting large matrices will take a long time. R does a computation roughly every 8e-10 second. The number of computations per matrix inversion is n^3 where n is the dimension of the square matrix. For n = 5000 it should take 100 seconds.</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.inputoutput(Z, RS_label, f, f_label, E, E_label, X, V, V_label, M, M_label, 
               fV, fV_label, P, P_label, A, B, L, G)
</code></pre>


<h3>Arguments</h3>

<p>Let n = #sectors*#regions, l = # of labels, m = arbitrary length, r = #regions
</p>
<table role = "presentation">
<tr><td><code id="as.inputoutput_+3A_z">Z</code></td>
<td>
<p>Required. A nxn matrix of intermediate transactions between sectors and regions. It should be in units of currency, kg, etc.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_rs_label">RS_label</code></td>
<td>
<p>Required. A nx2 &quot;column&quot; matrix of the regions in column 1 and sector in column 2. Other functions use those locations to correctly identify elements in the matices. If there is only one region, it still needs to be specified in column 1.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_f">f</code></td>
<td>
<p>Not required. A nxm matrix of final demand. Exports SHOULD NOT be included in this matrix. Instead, put exports in the <code>E</code> matrix. However, net exports should stay. </p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_f_label">f_label</code></td>
<td>
<p>Not required. A 2xn &quot;row&quot; matrix of the region and accounts to help identify the elements of <code>f</code>. The first row should be regions and the second should be regional account labels.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_e">E</code></td>
<td>
<p>Not required. A nxr matrix of exports. Multiple columns per region is accepted.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_e_label">E_label</code></td>
<td>
<p>Not required. A 2xn &quot;row&quot; matrix of the region and type of export to help identify the elements of <code>E</code>. </p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_x">X</code></td>
<td>
<p>Required. A 1xn vector of total production for each sector across all regions. <code>RS_label</code> identifies the objects</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_v">V</code></td>
<td>
<p>Not required. A nxm matrix of value added. Imports SHOULD NOT be included in this matrix. Instead, put exports in the <code>M</code> matrix.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_v_label">V_label</code></td>
<td>
<p>Not required. A mx1 &quot;column&quot; matrix where the only column is the type of value added. This helps identify the rows of value added. <code>RS_label</code> identifies the columns.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_m">M</code></td>
<td>
<p>Not required. A mxn matrix of import. Multiple types of imports is accepted.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_m_label">M_label</code></td>
<td>
<p>Not required. A mx1 &quot;column&quot; matrix to identify the rows of imports. <code>RS_label</code> identifies the columns.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_fv">fV</code></td>
<td>
<p>Not Required. The matrix of final demand's value added</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_fv_label">fV_label</code></td>
<td>
<p>Not Required. Column matrix to identify the row elements of <code>fV</code></p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_p">P</code></td>
<td>
<p>Not Required. The matrix of intermediate transactions in physical units</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_p_label">P_label</code></td>
<td>
<p>Not Required. A nx2 matrix to identify the regions and sectors of <code>P</code></p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_a">A</code></td>
<td>
<p>Not required. A nxn matrix of technical input coefficients. If not provided, <code>A</code> is calculated for you.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_b">B</code></td>
<td>
<p>Not required. A nxn matrix of technical output coefficients. If not provided, <code>B</code> is calculated for you.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_l">L</code></td>
<td>
<p>Not required. The Leontief inverse. If not provided, <code>L</code> is calculated for you.</p>
</td></tr>
<tr><td><code id="as.inputoutput_+3A_g">G</code></td>
<td>
<p>Not required. The Ghoshian inverse. If not provided, <code>G</code> is calculated for you.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>A</code> matrix is not provided, it is calculated as follows: </p>
<p style="text-align: center;"><code class="reqn">a_{ij} = z_{ij}/x_j</code>
</p>

<p>If the <code>B</code> matrix is not provided, it is calculated as follows: </p>
<p style="text-align: center;"><code class="reqn">b_{ij} = z_{ij}/x_i</code>
</p>

<p>If the <code>L</code> matrix is not provided, it is calculated as follows: </p>
<p style="text-align: center;"><code class="reqn">L = (I-A)^{-1}</code>
</p>

<p>If the <code>G</code> matrix is not provided, it is calculated as follows: </p>
<p style="text-align: center;"><code class="reqn">G = (I-B)^{-1}</code>
</p>



<h3>Value</h3>

<p><code>as.inputouput</code> retuns an object of <code><a href="base.html#topic+class">class</a> "InputOutput"</code>. Once created, it is sufficient to provide this object in all further functions in the <code>ioanalysis</code> package.
</p>
<table role = "presentation">
<tr><td><code>Z</code></td>
<td>
<p>Intermediate Transactions Matrix</p>
</td></tr>
<tr><td><code>RS_label</code></td>
<td>
<p>Column matrix of labels for the region and sectors used to identify elements in <code>A, Z, X, L, ...</code></p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Final Demand</p>
</td></tr>
<tr><td><code>f_label</code></td>
<td>
<p>Row matrix of labels for accounts for <code>f</code></p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Exports</p>
</td></tr>
<tr><td><code>E_label</code></td>
<td>
<p>Row matrix of labels for exports by sector and region for <code>E</code></p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Total Production</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>Value added</p>
</td></tr>
<tr><td><code>V_label</code></td>
<td>
<p>Column matrix of labels for types of value added for <code>V</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Imports</p>
</td></tr>
<tr><td><code>M_label</code></td>
<td>
<p>Colum matrix of labels for type of imports for <code>M</code></p>
</td></tr>
<tr><td><code>fV</code></td>
<td>
<p>The matrix of final demand's value added</p>
</td></tr>
<tr><td><code>fV_label</code></td>
<td>
<p>Column matrix to identify the row elements of <code>fV</code></p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Technical Input Coefficients</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Technical Input Coefficients</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Leontief inverse</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Ghoshian inverse</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, there is no use for an intermediate transaction matrix in physical units (P). If you wish to carry this with the matrix then you can create the <code>InputOutput</code> object and add to it by using <code>io$P &lt;- P</code>.
</p>


<h3>Author(s)</h3>

<p>John J. P. wade
</p>


<h3>References</h3>

<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. <em>PyIO. Input-Output Analysis with Python</em>. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In toy,FullIOTable it is a full matrix of characters: a pseudo worst case scenario
data(toy.FullIOTable)
Z &lt;- matrix(as.numeric(toy.FullIOTable[3:12, 3:12]), ncol = 10)
f &lt;- matrix(as.numeric(toy.FullIOTable[3:12, c(13:15, 17:19)]), nrow = dim(Z)[1])
E &lt;- matrix(as.numeric(toy.FullIOTable[3:12, c(16, 20)]), nrow = 10)
X &lt;- matrix(as.numeric(toy.FullIOTable[3:12, 21]), ncol = 1)
V &lt;- matrix(as.numeric(toy.FullIOTable[13:15, 3:12]), ncol = 10)
M &lt;- as.numeric(toy.FullIOTable[16, 3:12])
fV &lt;- matrix(as.numeric(toy.FullIOTable[15:16, c(13:15,17:19)]), nrow = 2)

# Note toy.FullIOTable is a matrix of characters: non-numeric
toy.IO &lt;- as.inputoutput(Z = Z, RS_label = toy.FullIOTable[3:12, 1:2],
                         f = f, f_label = toy.FullIOTable[1:2, c(13:15, 17:19)],
                         E = E, E_label = toy.FullIOTable[1:2, c(16, 20)],
                         X = X,
                         V = V, V_label = toy.FullIOTable[13:15, 2],
                         M = M, M_label = toy.FullIOTable[16,2],
                         fV = fV, fV_label = toy.FullIOTable[15:16, 2])

# Notice we do not need to supply the matrix of technical coefficients (A)
</code></pre>

<hr>
<h2 id='check.RS'>
Do all regions have the same sectors?
</h2><span id='topic+check.RS'></span>

<h3>Description</h3>

<p>Produces a logical answer to the question do all regions have the same sectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.RS(io)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.RS_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the <code>RS_label</code> to determine if all regions have the same sectors
</p>


<h3>Value</h3>

<p>Produces either <code>TRUE</code> or <code>FALSE</code>
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locate.mismatch">locate.mismatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
check.RS(toy.IO)
</code></pre>

<hr>
<h2 id='easy.select'>Region and Sector Selection Interface</h2><span id='topic+easy.select'></span>

<h3>Description</h3>

<p>This is a user interface, answering prompts to significantly simplify choosing sectors and regions in large models. You can either search through the regions and sectors using keywords, partial phrases, or partial words. There is alternatively an option to select across the comprehensive list of all regions and then sectors. Once selections are made, you can view and edit the list once selections are made. Outputs a matrix to be input into other functions to help identify desired region-sector combinations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>easy.select(io)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="easy.select_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> object. See <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>easy.select</code> calls upon the <code>RS_label</code> object in <code>io</code> to sort through regions and sectors. The regions should be in the first column and sectors should be in the second.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>EasySelect</code></td>
<td>
<p> A numeric vector of class <code>EasySelect</code> that can be used to identify desired elements for future functions.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>John J. P. Wade</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>

<hr>
<h2 id='export.coef'>Calculates the Matrix of Trade Coefficients
</h2><span id='topic+export.coef'></span><span id='topic+import.coef'></span>

<h3>Description</h3>

<p>Uses the matrix of technical input coefficients (<code>A</code>) to calculate either the matrix of import coefficients or the matrix of export coefficients. It does require that all regions have the same sectors. This can be verified using <code><a href="#topic+check.RS">check.RS</a></code>
</p>
<p>This function is intended to be a helper function for <code><a href="#topic+vs">vs</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.coef(io, region)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export.coef_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="export.coef_+3A_region">region</code></td>
<td>
<p>Integer. Specific region to be used. The number of the region in the order it appears in <code>RS_label</code>. You can only do one region at a time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds appropriate blocks of the matrix of technical input coefficients to calculate the matrix of import/export coefficients. If there is an export matrix or an import matrix as a part of the <code>InputOutput</code> object, the results in the generated matrix may be biased.
</p>


<h3>Value</h3>

<p>Produces a nxn matrix, where n is the number of sectors.
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check.RS">check.RS</a></code>, <code><a href="#topic+locate.mismatch">locate.mismatch</a></code>, <code><a href="#topic+upstream">upstream</a></code>, <code><a href="#topic+vs">vs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
import.coef(toy.IO, 1)
</code></pre>

<hr>
<h2 id='export.total'>Calculates Total Exports for InputOutput Objects
</h2><span id='topic+export.total'></span><span id='topic+import.total'></span>

<h3>Description</h3>

<p>Uses values of the intermediate transaction matrix (<code>Z</code>) and when applicable final demand (<code>f</code>), and either exports (<code>E</code>) or imports (<code>M</code>) to calculate the total exports or imports for each region sector combination.
</p>
<p>This function is intended to be a helper function for <code><a href="#topic+upstream">upstream</a></code> and <code><a href="#topic+vs">vs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.total(io)
import.total(io)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export.total_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a nameless vector of total exports.
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade
</p>


<h3>See Also</h3>

<p><code><a href="#topic+export.coef">export.coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
export.total(toy.IO)
import.total(toy.IO)
</code></pre>

<hr>
<h2 id='extraction'>Hypothetical Extraction</h2><span id='topic+extraction'></span>

<h3>Description</h3>

<p>Computes the hypothetical extraction as outlined in Dietzenbacher et al. (1993) and as outlined in Blar and Miller (2009).
</p>
<p>Caution: Inverting large matrices will take a long time. Each individual hypothetical extraction requires the inversion of a matrix. R does a computation roughly every 8e-10 second. The number of computations per matrix inversion is n^3 where n is the dimension of the square matrix. For n = 5000 it should take 100 seconds. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extraction(io, ES = NULL, regions = 1, sectors = 1, type = "backward.total",
           aggregate = FALSE, simultaneous = FALSE, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extraction_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="extraction_+3A_es">ES</code></td>
<td>
<p>An <code>EasySelect</code> class object from <code><a href="#topic+easy.select">easy.select</a></code> to specify which region and sector combinations to use.</p>
</td></tr>
<tr><td><code id="extraction_+3A_regions">regions</code></td>
<td>
<p>Character or Integer. Specific regions to be used. Can either be a character that exactly matches the name of the region in <code>RS_label</code> or the number of the region in the order it appears in <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="extraction_+3A_sectors">sectors</code></td>
<td>
<p>Character or Integer. Specific sectors to be used. Can either be a character that exactly matches the name of the sector in <code>RS_label</code> or the number of the sector in the order it <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="extraction_+3A_type">type</code></td>
<td>
<p>Character. Any combination of <code>"backward"</code>, <code>"forward"</code>, <code>"backward.total"</code>, and/or <code>"forward.total"</code>. See details.</p>
</td></tr>
<tr><td><code id="extraction_+3A_aggregate">aggregate</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code> produces the value of the impact over all sectors. If <code>FALSE</code> produces the impact for each sector.</p>
</td></tr>
<tr><td><code id="extraction_+3A_simultaneous">simultaneous</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Determines whether to extract all specified regions sequentially or simultaneously.</p>
</td></tr>
<tr><td><code id="extraction_+3A_normalize">normalize</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Whether or not to divide each linkage by total production.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>type</code>
</p>
<p>(1) <code>backward</code> - Calculates the impact of hypothetically extracting the jth region/sector using the formula
</p>
<p style="text-align: center;"><code class="reqn">X - (I - A_c)^{-1} f</code>
</p>

<p>where <code class="reqn">A_c</code> is the matrix of technical input coefficients with the jth column replaced by zeros
</p>
<p>(2)<code>forward</code> - Calculates the impact of hypothetically extracting the jth region/sector using the formula
</p>
<p style="text-align: center;"><code class="reqn">X - V (I - B_r)^{-1}</code>
</p>

<p>where <code class="reqn">B_r</code> is the matrix of technical output coefficients with the jth row replaced by zeros
</p>
<p>(3) <code>backward.total</code> - Calculates the impact of hypothetically extracting the jth region/sector using the formula
</p>
<p style="text-align: center;"><code class="reqn">X - (I - A_{cr})^{-1} f</code>
</p>

<p>where <code class="reqn">A_{cr}</code> is the matrix of technical input coefficients with the jth column and jth row replaced by zeros except for the diagonal element.
</p>
<p>(4) <code>forward.total</code> - Calculates the impact of hypothetically extracting the jth region/sector using the formula
</p>
<p style="text-align: center;"><code class="reqn">X - V (I - B_{cr})^{-1}</code>
</p>

<p>where <code class="reqn">B_{cr}</code> is the matrix of technical output coefficients with the jth column and jth row replaced by zeros except for the diagonal element.
</p>
<p><code>aggregate</code>
</p>
<p>If <code>TRUE</code> multiplies the impact vector by a vector of ones to received the summed value of the impact from hypothetical extraction.
</p>
<p><code>normalize</code>
</p>
<p>If <code>TRUE</code> each component in the impact vector is divided by the total output of that sector/region combination.
</p>


<h3>Value</h3>

<p>Produces a list over regions of a list over type of extraction. If there is only one region and one type, then a matrix is returned. For example, items can be called by using <code>extraction$region$type</code>.</p>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri</p>


<h3>References</h3>

<p>Dietzenbacher Erik &amp; van der Linden Jan A. &amp;  Steenge Alben E.  (1993). The Regional Extraction Method: EC Input-Output Comparisons. Economic Systems Research. Vol. 5, Iss. 2, 1993
</p>
<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code>, <code><a href="#topic+easy.select">easy.select</a></code>, <code><a href="#topic+linkages">linkages</a></code>, <code><a href="#topic+key.sector">key.sector</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
E1 &lt;- extraction(toy.IO)

# Using an EasySelect object
data(toy.IO)
class(toy.IO)
E2 &lt;- extraction(toy.IO, toy.ES)
E2$Hogwarts

# Using more options
E3 &lt;- extraction(toy.IO, regions = c(1,2), sectors = c("Wii", "Minions"), 
                 type = c("backward", "backward.total"), aggregate = TRUE)
E3$Hogwarts$backward.total

# Multiple regions and types
E4 &lt;- extraction(toy.IO, type = c("forward","forward.total"), normalize = TRUE)
E4$Hogwarts$forward.total
</code></pre>

<hr>
<h2 id='f.influence'>Field of Influence</h2><span id='topic+f.influence'></span>

<h3>Description</h3>

<p>Calculates the field of influence. Can handle first to nth order field of influence. Uses the method as Sonis &amp; Hewings 1992. This is a recursive technique, so computation time depends on the size of the data and order of field of influence.
</p>
<p>NOTE: If you want to examine a % productivity shock to a specific region-sector, see <code><a href="#topic+inverse.important">inverse.important</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.influence(io, i , j)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f.influence_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="f.influence_+3A_i">i</code></td>
<td>
<p>Numeric. The row component(s) of the coefficient(s) of interest</p>
</td></tr>
<tr><td><code id="f.influence_+3A_j">j</code></td>
<td>
<p>Numeric. The column component(S) of the coefficient(s) of interest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First Order Field of Influence - This is simply the product of the jth column of the Leontief inverse multiplied by the ith row of the Leontief inverse. In matrix notation:
</p>
<p style="text-align: center;"><code class="reqn">F_1[i, j] = L_{.j} L_{i.}</code>
</p>

<p>where <code class="reqn">F</code> denotes the field of influence, and i and j are scalars
</p>
<p>Nth Order Field of Influence - This is a recursive function used to calculate higher order fields of influence. The order cannot exceed the size of the Intermediate Transaction Matrix (Z). I.e. if Z is 20x20, you can only calculate up to the 19th order. The formula is as follows:
</p>
<p style="text-align: center;"><code class="reqn">F_k[(i_1,...,i_k), (j_1,...,j_k)] = \frac{1}{k-1} \sum_{s=1}^k\sum_{r=1}^k (-1)^{s+r+1} l_{i_s,j_r} F_{k-1}[i_{-s}, j_{-r}] </code>
</p>

<p>where F is the field of influence, k is order of influence, l_ij is the ith row and jth column element of the Leontief Inverse and -s indicates the sth element has been removed.
</p>


<h3>Value</h3>

<p>Returns a matrix of the Field of Influence
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri
</p>


<h3>References</h3>

<p>Sonis, Michael &amp; Hewings, Geoffrey J.D. (1992), &quot;Coefficient Chang in Input-Output Models: Theory and Applications,&quot; Economic Systems Research, 4:2, 143-158 (<a href="https://doi.org/10.1080/09535319200000013">https://doi.org/10.1080/09535319200000013</a>)
</p>
<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inverse.important">inverse.important</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
# First order field of influence on L[3,2]
i &lt;- 3
j &lt;- 2
f.influence(toy.IO, i, j)

# Second order field of influence on L[3,2], L[4,5], L[6, 3], and L[1,10]
i &lt;- c(3, 4, 6,  1)
j &lt;- c(2, 5, 3, 10)
f.influence(toy.IO, i, j)

</code></pre>

<hr>
<h2 id='f.influence.total'>Field of Influence (Total)
</h2><span id='topic+f.influence.total'></span>

<h3>Description</h3>

<p>Calculates the total field of influence for the input-output system using <code><a href="#topic+f.influence">f.influence</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.influence.total(io)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f.influence.total_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total field of influence calculates the sum of all first order field of influences:
</p>
<p style="text-align: center;"><code class="reqn">F^{total} = \sum_i \sum_j F_{i,j}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{i, j} = L_{.j} L_{i.}</code>
</p>

<p>such that <code class="reqn">L_{.j}</code> is the jth column of the Leontief inverse and <code class="reqn">L_{i.}</code> is the ith row of the Leontief inverse.
</p>


<h3>Value</h3>

<p>Returns a matrix of the total field of influence.
</p>


<h3>Note</h3>

<p>If the input-output system is large, then the computation can become cumbersome. Consequently, a progress bar will be printed if the algorithm determines it to be relevant.
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade
</p>


<h3>See Also</h3>

<p><code><a href="#topic+f.influence">f.influence</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)

fit = f.influence.total(toy.IO)

</code></pre>

<hr>
<h2 id='feedback.loop'>Feedback Loop Analysis</h2><span id='topic+feedback.loop'></span><span id='topic+feedback.loop.matrix'></span>

<h3>Description</h3>

<p>Calculates the complete hierarchical feedback loop as described in Sonis et al. (1995). A feed back loop is complete if it contains all region-sector pairs. Much like a sudoku puzzle, there may only be one identified cell in each row and one identified cell in each column per loop. The loops are hierarchical in the sense that first loop maximizes the intermediate transactions given the aforementioned constraints.
</p>
<p>There are TWO functions for RAM concerns. A singular function storing all feedback loop matrices grows at rate n^3. Alternatively, constructing feedback loop matrices one at a time translates to the output of <code>feedback.loop</code> growth rate of roughly 2n^2.
</p>
<p>Note: A feedback loop solves the Linear Programming Assignment problem.
</p>
<p>Warning: Computation time depends on size of the system. A progress bar is printed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>feedback.loop(io, agg.sectors, agg.regions, n.loops)
feedback.loop.matrix(fl, loop)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feedback.loop_+3A_io">io</code></td>
<td>
<p>An object of class <code>InputOutput</code> calculated from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="feedback.loop_+3A_agg.sectors">agg.sectors</code></td>
<td>
<p>An option to aggregate the sectors to compare regions only. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="feedback.loop_+3A_agg.regions">agg.regions</code></td>
<td>
<p>An option to aggregate the regions to compare sectors only. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="feedback.loop_+3A_n.loops">n.loops</code></td>
<td>
<p>The number of loops you wish to calculate. The default is <code>"all"</code>. Must either be an integer or <code>"all"</code></p>
</td></tr>
<tr><td><code id="feedback.loop_+3A_fl">fl</code></td>
<td>
<p>An object of class <code>FeedbackLoop</code> created from <code>feedback.loop</code></p>
</td></tr>
<tr><td><code id="feedback.loop_+3A_loop">loop</code></td>
<td>
<p>The loop from which you want the selector matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The feedback loop solves the following optimization problem:
</p>
<p style="text-align: center;"><code class="reqn">max_S vec(Z)'vec(S)</code>
</p>

<p>such that:
</p>
<p style="text-align: center;"><code class="reqn">i) A_{col}vec(S) = vec(1)</code>
</p>

<p style="text-align: center;"><code class="reqn">ii) A_{row}vec(S) = vec(1)</code>
</p>

<p style="text-align: center;"><code class="reqn">iii) vec(0) \le vec(S) \le vec(1)</code>
</p>

<p>where <code class="reqn">Z</code> is the intermediate transaction matrix from <code>io</code>, <code class="reqn">S</code> is a selctor matrix of the cells in <code class="reqn">Z</code>, <code class="reqn">A_{col}</code> is a constraint matrix to ensure only one cell per column is selected, <code class="reqn">A_{row}</code> is a constraint matrix to ensure only one cell per row is selected, and constraint <code class="reqn">iii)</code> ensures the values in the selector matrix are either one or zero. 
</p>
<p>After each loop, the selected cells are set to an extremely negative number to prevent selection in the next loop.
</p>
<p>See the documentation on http://www.real.illinois.edu/ for more details and interpretation of the loops.
</p>


<h3>Value</h3>

<p>Produces a nested list: <code>fl</code>
</p>
<table role = "presentation">
<tr><td><code>fl</code></td>
<td>
<p>Contains <code>"value"</code>, <code>"loop_1"</code>, <code>"loop_2"</code>, ..., and <code>"loop_n"</code></p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Contains a vector of the total value of intermediate transactions for each loop.</p>
</td></tr>
<tr><td><code>loop_i</code></td>
<td>
<p>Contains a list over each loop's subloops. Retrieve by calling <code>fl$loop_i$subloop_j</code>. Note each loop will likely have a different number of subloops.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John J. P. Wade, Xiuli Liu
</p>


<h3>References</h3>

<p>Sonis, M., Hewings, G. J., &amp; Gazel, R (1995). The structure of multi-regional trade flows: hierarchy, feedbacks and spatial linkages. <em>The Annals of Regional Science</em>, 29(4) 409-430.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################
# The base feedback loop #
##########################
data(toy.IO)
class(toy.IO)

fbl = feedback.loop(toy.IO)
fbl$loop_1

fl_3 = feedback.loop.matrix(fbl, 3)
heatmap.io(fl_3, RS_label = toy.IO$RS_label)

fbl$value
fbl$per = fbl$value / sum(fbl$value) * 100

obj = data.frame(x = 1:length(fbl$per), y = fbl$per)

ggplot(obj, aes(x = x, y = y)) + 
  geom_line() + geom_point() +
  labs(x = 'Loop', y = 'Percent', title = 'Proportion of Total Intermediate Transactions per Loop')

###############################
# An aggregated feedback loop #
###############################
fbl_agg = feedback.loop(toy.IO, agg.regions = TRUE)
io_agg  = agg.region(toy.IO, regions = 'all', newname = 'magic')

fl_agg_1 = feedback.loop.matrix(fbl_agg, loop = 1)

heatmap.io(fl_agg_1, RS_label = io_agg$RS_label)
</code></pre>

<hr>
<h2 id='ghosh.inv'>Ghoshian Inverse</h2><span id='topic+ghosh.inv'></span>

<h3>Description</h3>

<p>Computes the Ghoshian (ouput) inverse. <code>ghosh.inv</code> has inputs to invert a subset of all regions if desired. If not using an <code>InputOutput</code> object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>, the functionality is limited. See example for more details.
</p>
<p>Caution: Inverting large matrices will take a long time. R does a computation roughly every 8e-10 second. The number of computations per matrix inversion is n^3 where n is the dimension of the square matrix. For n = 5000 it should take 100 seconds. </p>


<h3>Usage</h3>

<pre><code class='language-R'>ghosh.inv(Z = NULL, X, B, RS_label, regions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ghosh.inv_+3A_z">Z</code></td>
<td>
<p>Either an object class of <code>InputOutput</code> calculated from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code> or the intermediate transaction matrix. Do NOT use matrix of technical coefficients.</p>
</td></tr>
<tr><td><code id="ghosh.inv_+3A_x">X</code></td>
<td>
<p>Vector. Total production vector. Not required if Z is an object with <code>InputOutput</code> class.</p>
</td></tr>
<tr><td><code id="ghosh.inv_+3A_b">B</code></td>
<td>
<p>Matrix. Matrix of technical output coefficients.</p>
</td></tr>
<tr><td><code id="ghosh.inv_+3A_rs_label">RS_label</code></td>
<td>
<p>Matrix. A nx2 column matrix of labels for regions and sectors. The first column must be regions and the second column must be sectors. This is used to match with the intermediate transaction matrix.</p>
</td></tr>
<tr><td><code id="ghosh.inv_+3A_regions">regions</code></td>
<td>
<p>Character or Integer. Specific regions to be used. Can either be a character that exactly matches the name of the region in <code>RS_label</code> or the number of the region in the order it appears in <code>RS_label</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Ghoshian inverse is derived from the input-output table A=[a_ij] where
</p>
<p style="text-align: center;"><code class="reqn">b_ij=z_ij/X_i</code>
</p>

<p>where z_ij is the input from i required in the production of j. X_i is the corresponding input in each row. The Leontief inverse is then computed as
</p>
<p style="text-align: center;"><code class="reqn">(I-B)^{-1}</code>
</p>

<p>Observe we result with the following system
</p>
<p style="text-align: center;"><code class="reqn">X'=V'G</code>
</p>

<p>Therefore, the element <code class="reqn">g_{ij}</code> is interpreted as the ratio of sector i's value added contributing to the total production of sector j.
</p>


<h3>Value</h3>

<p>Returns a matrix with the Ghoshian Inverse
</p>


<h3>Author(s)</h3>

<p>Ignacio Sarmiento-Barbieri, John J. P. Wade
</p>


<h3>References</h3>

<p>Ghosh, A. (1958). &quot;Input-output Approach in an Allocation System,&quot; <em>Econometrica</em>, New Series, Vol. 25, No. 97 (Feb., 1958), pp. 58-64.
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. <em>PyIO. Input-Output Analysis with Python</em>. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using an "InputOutput" object
data(toy.IO)
class(toy.IO)

G1 &lt;- ghosh.inv(toy.IO, region = "Narnia")

# Otherwise
Z &lt;- toy.IO$Z
X &lt;- toy.IO$X
G3 &lt;- ghosh.inv(Z, X)
</code></pre>

<hr>
<h2 id='heatmap.io'>Heatmap Visualization</h2><span id='topic+heatmap.io'></span>

<h3>Description</h3>

<p>A visualization tool for matrices belonging to an input-output system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap.io(obj, RS_label = NULL, regions_x = 'all', sectors_x = 'all', 
           regions_y = 'all', sectors_y = 'all',
           ES_x = NULL, ES_y = NULL, FUN = NULL, low = NULL, high = NULL,
           min = NA, max = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmap.io_+3A_obj">obj</code></td>
<td>
<p>The object you wish to create a heat map for that corresponds to the RS_label</p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_rs_label">RS_label</code></td>
<td>
<p>The RS_label located in an <code>InputOutput</code> object. See <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_regions_x">regions_x</code></td>
<td>
<p>The regions you wish to plot on the x-axis. This can either be the numerical order the regions occur or the name of the regions. The default is <code>'all'</code>.</p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_sectors_x">sectors_x</code></td>
<td>
<p>The sectors you wish to plot on the x-axis. This can either be the numerical order the sectors occur or the name of the sectors. The default is <code>'all'</code>.</p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_regions_y">regions_y</code></td>
<td>
<p>The regions you wish to plot on the y-axis. This can either be the numerical order the regions occur or the name of the regions. The default is <code>'all'</code>.</p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_sectors_y">sectors_y</code></td>
<td>
<p>The sectors you wish to plot on the y-axis. This can either be the numerical order the sectors occur or the name of the sectors. The default is <code>'all'</code>.</p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_es_x">ES_x</code></td>
<td>
<p>Instead of specifying regions and sectors individually, you can use an <code>EasySelect</code> object (see <code><a href="#topic+easy.select">easy.select</a></code>). If supplied, the <code>regions</code> and <code>sectors</code> are overridden. </p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_es_y">ES_y</code></td>
<td>
<p>See ES_x  </p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_fun">FUN</code></td>
<td>
<p>The transformation of the elements in <code>obj</code> such as <code>log()</code></p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_low">low</code></td>
<td>
<p>The color of the low values. Default is <code>"yellow"</code>. </p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_high">high</code></td>
<td>
<p>The color of the high values. Default is <code>"blue"</code>. </p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_min">min</code></td>
<td>
<p>The minimum value for the color legend. Default of NA == min(obj). Both min and max must be provided to change default.</p>
</td></tr>
<tr><td><code id="heatmap.io_+3A_max">max</code></td>
<td>
<p>The maximum value for the color legend. Default of NA == max(obj). Both min and max must be provided to change default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>heatmap.io</code> uses ggplot2::geom_tiles() to create the visualization of the object.
</p>


<h3>Note</h3>

<p>The coloring follows the temperatures of stars!
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)

RS_label = toy.IO$RS_label
obj = toy.IO$L
heatmap.io(obj, RS_label, FUN = log, max = 3)

cuberoot = function(x){x^(1/3)}
heatmap.io(obj, RS_label, FUN = cuberoot)

# Total field of influence
fit = f.influence.total(toy.IO)
heatmap.io(fit, RS_label, sectors_x = c(1,3,4,5), regions_y = c(2), sectors = 1:3)

data(toy.ES)
ES2 = matrix(c(1,5,6,8,9))
class(ES2) = 'EasySelect'
heatmap.io(fit, RS_label, ES_x = toy.ES, ES_y = ES2, 
           low = '#00fcef', high = 'blueviolet')


</code></pre>

<hr>
<h2 id='hist3d.io'>3D Histogram of Input-Output object </h2><span id='topic+hist3d.io'></span>

<h3>Description</h3>

<p>Produces a three dimensional histogram from plot3d</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist3d.io(obj, alpha = 1, phi = 65, theta = 45, limits, 
                   colors = ramp.col(c('yellow', 'violet', 'blue')))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist3d.io_+3A_obj">obj</code></td>
<td>
<p>The nxm matrix to be plotted</p>
</td></tr>
<tr><td><code id="hist3d.io_+3A_alpha">alpha</code></td>
<td>
<p>The transparency of bars where 1 is opaque and 0 is complete transparency. Default is 1</p>
</td></tr>
<tr><td><code id="hist3d.io_+3A_phi">phi</code></td>
<td>
<p>Colatitude rotation (shaking head left and right)</p>
</td></tr>
<tr><td><code id="hist3d.io_+3A_theta">theta</code></td>
<td>
<p>Colatitude rotation (nodding up and down)</p>
</td></tr>
<tr><td><code id="hist3d.io_+3A_limits">limits</code></td>
<td>
<p>The lower and upper bound for color limits</p>
</td></tr>
<tr><td><code id="hist3d.io_+3A_colors">colors</code></td>
<td>
<p>A <code>ramp.col()</code> for the 3D histogram</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>hist3D</code> from the package <code>plot3d</code> to generate a 3D plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
obj = toy.IO$Z[1:5, 1:5]

hist3d.io(obj, alpha = 0.7)
  
</code></pre>

<hr>
<h2 id='inverse.important'>
Inverse.Important Coefficients
</h2><span id='topic+inverse.important'></span>

<h3>Description</h3>

<p>Calculates the inverse-important coefficients as in Blair and Miller (2009)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse.important(io, i, j, delta.aij)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse.important_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="inverse.important_+3A_i">i</code></td>
<td>
<p>Integer. The row component of the change in the matrix of technical input coefficients</p>
</td></tr>
<tr><td><code id="inverse.important_+3A_j">j</code></td>
<td>
<p>Integer. The column component of the change in the matrix of technical input coefficients</p>
</td></tr>
<tr><td><code id="inverse.important_+3A_delta.aij">delta.aij</code></td>
<td>
<p>Integer. By how much aij should change by</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse-important coefficients is the change in the Leontief matrix due to a specified change in one element of the matrix of technical input coefficients (A). This uses the formula:
</p>
<p style="text-align: center;"><code class="reqn"> \Delta L = \frac{\Delta a_{ij}}{1-l_{ji}\Delta a_{ij}} F_1(i,j) </code>
</p>

<p>where F_1(X,Y) is the first order field of influence.
</p>


<h3>Value</h3>

<p>Returns the change in the Leontief matrix due the change in one element of the matrix of technical input coefficients. To find the new Leontief inverse induced by this change, use io$L + inverse.important().
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri
</p>


<h3>References</h3>

<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
i &lt;- 3
j &lt;- 4
delta.aij &lt;- 0.5
II &lt;- inverse.important(toy.IO, i, j, delta.aij)
</code></pre>

<hr>
<h2 id='ioanalysis'>ioanalysis</h2><span id='topic+ioanalysis'></span>

<h3>Description</h3>

<p>A collection of input-output table analytical functions used to analyze <code>InputOutput</code> objects. See <code><a href="#topic+as.inputoutput">as.inputoutput</a></code> for details.
</p>
<p>For a list of available functions, see <code>help(package = "ioanalysis")</code>
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade
</p>


<h3>See Also</h3>

<p>For detailed documentation and .R files see <a href="https://github.com/joolman/ioanalysis">https://github.com/joolman/ioanalysis</a>
</p>

<hr>
<h2 id='key.sector'>Impact Analysis via Backward and Forward Linkages</h2><span id='topic+key.sector'></span>

<h3>Description</h3>

<p>Uses backward and forward <code><a href="#topic+linkages">linkages</a></code> to identify key sectors in the system. Can calculate total and direct linkages. If the data is multiregional, intraregional and interregional linkages can be calculated. Can also be used on a specified subset of all regions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>key.sector(io, ES = NULL, crit = 1, regions = "all", sectors = "all", 
           type = c("direct"), intra.inter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="key.sector_+3A_io">io</code></td>
<td>
<p>An object of class <code>InputOutput</code> calculated from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>.</p>
</td></tr>
<tr><td><code id="key.sector_+3A_es">ES</code></td>
<td>
<p>An object of class <code>EasySelect</code> from <code><a href="#topic+easy.select">easy.select</a></code></p>
</td></tr>
<tr><td><code id="key.sector_+3A_crit">crit</code></td>
<td>
<p>Integer. The value to compare linkages above or below to classify sectors. Default is 1.</p>
</td></tr>
<tr><td><code id="key.sector_+3A_regions">regions</code></td>
<td>
<p>Character or Integer. Specific regions to be used. Can either be a character that exactly matches the name of the region in <code>RS_label</code> or the number of the region in the order it appears in <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="key.sector_+3A_sectors">sectors</code></td>
<td>
<p>Character or Integer. Specific sectors to be used. Can either be a character that exactly matches the name of the sector in <code>RS_label</code> or the number of the sector in the order it <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="key.sector_+3A_type">type</code></td>
<td>
<p>Character. Identifying the type of backward and forward linkages to be calculated. Options are <code>"total"</code> and <code>"direct"</code>.</p>
</td></tr>
<tr><td><code id="key.sector_+3A_intra.inter">intra.inter</code></td>
<td>
<p>Logical. Only applies to multiregional systems. Determines whether or not to calculate intraregional and interregional backward and forward linkages in addition to aggregate linkages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the (various) specified backward and forward <code><a href="#topic+linkages">linkages</a></code> to calculate a key to identify dependence using the specified critical value.
</p>
<p><code>I</code>   BL &lt; crit, FL &lt; crit - Generally independent
</p>
<p><code>II</code>  BL &lt; crit, FL &gt; crit - Dependent on interindustry demand
</p>
<p><code>III</code> BL &gt; crit, FL &gt; crit - Generally dependent
</p>
<p><code>IV</code>  BL &gt; crit, FL &lt; crit - Dependent on interindustry supply
</p>


<h3>Value</h3>

<p>If there is only one region, key sector binds to the output from <code><a href="#topic+linkages">linkages</a></code> to make a table. Otherwise, it produces a list of key sector codes for each country using the names of regions provided. See Examples for more details.</p>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri
</p>


<h3>References</h3>

<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkages">linkages</a></code>, <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
key1 &lt;- key.sector(toy.IO)
key1$Narnia

# A more detailed example
# Using critical value of 2 because this is randomly generated data and better 
# illustrates functionality
key2 &lt;- key.sector(toy.IO, intra.inter = TRUE, type = c("direct"), crit = 2)
key2

key3 &lt;- key.sector(toy.IO, regions = c(1:2), sectors = c(1:3,5))
key3
</code></pre>

<hr>
<h2 id='leontief.inv'>Leontief Inverse</h2><span id='topic+leontief.inv'></span>

<h3>Description</h3>

<p>Computes the Leontief (input) inverse. <code>leontief.inv</code> has inputs to invert a subset of all regions if desired. If not using an <code>InputOutput</code> object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>, the functionality is limited. See example for more details.
</p>
<p>Note: if you have a non <code>InputOutput</code> object and you wish to use only a subset of all regions, you must supply the intermediate transaction matrix (<code>Z</code>) and total production matrix (<code>X</code>). Otherwise use <code>L &lt;- Z %*% diag(c(1/X))</code>
</p>
<p>Caution: Inverting large matrices will take a long time. R does a computation roughly every 8e-10 second. The number of computations per matrix inversion is n^3 where n is the dimension of the square matrix. For n = 5000 it should take 100 seconds.</p>


<h3>Usage</h3>

<pre><code class='language-R'>leontief.inv(Z = NULL, X, A, RS_label, regions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leontief.inv_+3A_z">Z</code></td>
<td>
<p>Either an object class of <code>InputOutput</code> calculated from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code> or the intermediate transaction matrix. Do NOT use matrix of technical coefficients.</p>
</td></tr>
<tr><td><code id="leontief.inv_+3A_x">X</code></td>
<td>
<p>vector. Total production vector. Not required if Z is an object with <code>InputOutput</code> class.</p>
</td></tr>
<tr><td><code id="leontief.inv_+3A_a">A</code></td>
<td>
<p>Matrix. Technical Matrix of Input Coefficients. If provided and the data is large, the computations will be noticeably sped up.</p>
</td></tr>
<tr><td><code id="leontief.inv_+3A_rs_label">RS_label</code></td>
<td>
<p>Matrix. A nx2 column matrix of labels for regions and sectors. The first column must be regions and the second column must be sectors. This is used to match with the intermediate transaction matrix.</p>
</td></tr>
<tr><td><code id="leontief.inv_+3A_regions">regions</code></td>
<td>
<p>Character or Integer. Specific regions to be used. Can either be a character that exactly matches the name of the region in <code>RS_label</code> or the number of the region in the order it appears in <code>RS_label</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Leontief inverse is derived from the input-output table A=[a_ij] where
</p>
<p style="text-align: center;"><code class="reqn">a_ij=z_ij/X_j</code>
</p>

<p>where z_ij is the input from i required in the production of j. X_j is the corresponding input in each column. The Leontief inverse is then computed as
</p>
<p style="text-align: center;"><code class="reqn">(I-A)^{-1}</code>
</p>

<p>Observe we result with the following system
</p>
<p style="text-align: center;"><code class="reqn">X = Lf</code>
</p>

<p>Therefore, element <code class="reqn">l_{ij}</code> is interpreted as the ratio of final demand for sector j contributing to the total production in sector i.
</p>


<h3>Value</h3>

<p>Returns a matrix with the Leontief Inverse.
</p>


<h3>Author(s)</h3>

<p>Ignacio Sarmiento-Barbieri, John J. P. Wade
</p>


<h3>References</h3>

<p>Leontief, Wassily W. (1951). &quot;Input-Output Economics.&quot; <em>Scientific American</em>, Vol. 185, No. 4 (October 1951), pp. 15-21.
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. <em>PyIO. Input-Output Analysis with Python</em>. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using an "InputOutput" object
data(toy.IO)
class(toy.IO)

L1 &lt;- leontief.inv(toy.IO, region = "Narnia")

# Otherwise
Z &lt;- toy.IO$Z
X &lt;- toy.IO$X
L2 &lt;- leontief.inv(Z, X)
</code></pre>

<hr>
<h2 id='linkages'>Backward and Forward Linkages</h2><span id='topic+linkages'></span>

<h3>Description</h3>

<p>Calculates backward and forward linkages with an option to normalize values. Can calculate total and direct linkages. If the data is multiregional, intraregional and interregional linkages can be calculated. Can also be used on a specified subset of all regions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkages(io, ES = NULL, regions = "all", sectors = "all", type = c("total"),
         normalize = FALSE, intra.inter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linkages_+3A_io">io</code></td>
<td>
<p>An object of class <code>InputOutput</code> calculated from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>.</p>
</td></tr>
<tr><td><code id="linkages_+3A_es">ES</code></td>
<td>
<p>An object of class <code>EasySelect</code> from <code><a href="#topic+easy.select">easy.select</a></code></p>
</td></tr>
<tr><td><code id="linkages_+3A_regions">regions</code></td>
<td>
<p>Character or Integer. Specific regions to be used. Can either be a character that exactly matches the name of the region in <code>RS_label</code> or the number of the region in the order it appears in <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="linkages_+3A_sectors">sectors</code></td>
<td>
<p>Character or Integer. Specific sectors to be used. Can either be a character that exactly matches the name of the sector in <code>RS_label</code> or the number of the sector in the order it <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="linkages_+3A_type">type</code></td>
<td>
<p>Character. Identifying the type of backward and forward linkages to be calculated. Options are <code>"total"</code> and <code>"direct"</code>.</p>
</td></tr>
<tr><td><code id="linkages_+3A_normalize">normalize</code></td>
<td>
<p>Logical. Identifying whether or not to calculate normalized or raw linkages. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="linkages_+3A_intra.inter">intra.inter</code></td>
<td>
<p>Logical. Only applies to multiregional systems. Determines whether or not to calculate intraregional and interregional backward and forward linkages in addition to aggregate linkages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are arguments for <code>type</code> of linkages, <code>normalized</code> linkages, and <code>intra.inter</code> linkages. Let (r) denote the dimension of the block in the transaction matrix of the region of interest and (s) denote the dimension of the rest. If there are (n) sectors and (m) regions then r = n and s = (m - 1)*s
</p>
<p><code>type</code>: For the following types, if <code>normalize = TRUE</code> then the calculation takes the specified form below. Otherwise if <code>normalize = FALSE</code> then the denominator is removed:
</p>
<p><code>"total"</code> caclculates the total backward and forward linkages. For backward linkages, this is the column sum of the Leontief inverse.
</p>
<p style="text-align: center;"><code class="reqn">BL_{j}=\frac{\sum_{i=1}^{n}l_{ij}}{\frac{1}{n} \sum_{j=1}^{n}\sum_{i=1}^{n}l_{ij}}</code>
</p>

<p>For forward linkages, this is the row sum of the Goshian inverse.
</p>
<p style="text-align: center;"><code class="reqn">FL_{i}=\frac{\frac{1}{n}\sum_{j=1}^{n}g_{ij}}{\frac{1}{n^{2}}\sum_{j=1}^{n}\sum_{i=1}^{n}g_{ij}}</code>
</p>

<p><code>"direct"</code> calculates the direct backward and forward linkages. For backward linkages, this is the column sum of the input matrix of technical coefficients (A):
</p>
<p style="text-align: center;"><code class="reqn">BL_{j}=\frac{\sum_{i=1}^{n}a_{ij}}{\frac{1}{n} \sum_{j=1}^{n}\sum_{i=1}^{n}a_{ij}}</code>
</p>

<p>For forward linkages, this is the row sum of the output matrix of technical coefficients (B):
</p>
<p style="text-align: center;"><code class="reqn">FL_{i}=\frac{\frac{1}{n}\sum_{j=1}^{n}b_{ij}}{\frac{1}{n^{2}}\sum_{j=1}^{n}\sum_{i=1}^{n}b_{ij}}</code>
</p>

<p><code>intra.inter</code>: This calculates the intraregional, interregional and aggregate backward and forward linkages. If <code>intra.inter = FALSE</code>, then only calculates the aggregate. If <code>normalize = FALSE</code> then the aggregate linkage is equivalent to the sum of the intraregional and interregional linkages. If <code>normalize = TRUE</code>, then this is not the case. Note that normalizing adds the denominator to the following equations. Using matrix notation we have
</p>
<p style="text-align: center;"><code class="reqn">BL.intra = \frac{1_r^\prime J_{rr}}{ \frac{1}{n*m} 1_r^\prime J_{rr} 1_r}</code>
</p>

<p style="text-align: center;"><code class="reqn">FL.intra = \frac{ J_{rr} 1_r}{ \frac{1}{n*m} 1_r^\prime J_{rr} 1_r}</code>
</p>

<p style="text-align: center;"><code class="reqn">BL.inter = \frac{1_s^\prime J_{sr}}{\frac{1}{n*m} 1_s J_{sr} 1_r }</code>
</p>

<p style="text-align: center;"><code class="reqn">FL.inter = \frac{J_{rs} 1_s}{\frac{1}{n*m} 1_r J_{rs} 1_s}</code>
</p>

<p style="text-align: center;"><code class="reqn">BL.agg = \frac{ 1 J_{.r}}{\frac{1}{n*m} 1 J_{.r} 1_r}</code>
</p>

<p style="text-align: center;"><code class="reqn">FL.agg = \frac{ J_{r.} 1}{\frac{1}{n*m} 1_r J_{r.}} 1 </code>
</p>



<h3>Value</h3>

<p>Returns a <code>data.frame</code>. The following are assigned to the column names to help identify which column is belongs to which. The first element of the column label is the region of interest, grabbed from <code>RS_label</code>.
</p>
<table role = "presentation">
<tr><td><code>.BL</code></td>
<td>
<p>Backward linkages</p>
</td></tr>
<tr><td><code>.FL</code></td>
<td>
<p>Forward linkages</p>
</td></tr>
<tr><td><code>.intra</code></td>
<td>
<p>Intraregional linkages</p>
</td></tr>
<tr><td><code>.inter</code></td>
<td>
<p>Interregional linkages</p>
</td></tr>
<tr><td><code>.agg</code></td>
<td>
<p>Aggregate linkages</p>
</td></tr>
<tr><td><code>.tot</code></td>
<td>
<p>Total linkages</p>
</td></tr>
<tr><td><code>.dir</code></td>
<td>
<p>Direct linkages</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri
</p>


<h3>References</h3>

<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+leontief.inv">leontief.inv</a></code>, <code><a href="#topic+ghosh.inv">ghosh.inv</a></code>, <code><a href="#topic+key.sector">key.sector</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
link1 &lt;- linkages(toy.IO)
link1$Hogwarts

data(toy.ES)
class(toy.ES)
link2 &lt;- linkages(toy.IO, toy.ES)
link2

# More detailed
link3 &lt;- linkages(toy.IO, regions = "Narnia", sectors = c("Wii","Pizza"), 
                  type = c("total", "direct"), normalize = FALSE, intra.inter = TRUE)
link3

link4 &lt;- linkages(toy.IO, regions = 1:2, sectors = c(1:3,5))
link4

</code></pre>

<hr>
<h2 id='locate.mismatch'>Identify Sectors not in All Regions</h2><span id='topic+locate.mismatch'></span>

<h3>Description</h3>

<p><code>locate.mismatch</code> finds which sectors are not found in all regions. If a sector is not in all regions a report is generated to indicate which regions have that sector, which regions don't have that sector, and where this sector is in the repository.</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate.mismatch(io)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate.mismatch_+3A_io">io</code></td>
<td>
<p>An object of class <code>InputOutput</code> created from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>locate.mismatch</code> begins by identifying all sectors. Then if a sector is not in every region, the function identifies which regions have the sector, which regions don't have the sector, and where this sector is located. If it is important to have all regions having the same sectors, the location output can be used in <code><a href="#topic+agg.sector">agg.sector</a></code>. For a full list of sectors, use <code><a href="#topic+easy.select">easy.select</a></code>.
</p>


<h3>Value</h3>

<p>Produces a list of sectors. Each sector has a list of <code>location</code>, <code>regionswith</code>, and <code>regionswithout</code>. For example to find the regions that have a mismatched sector, use 
</p>
<p><code>(mismatch.object)$sector$regionswith</code></p>


<h3>Author(s)</h3>

<p>John J. P. Wade</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code>, <code><a href="#topic+agg.sector">agg.sector</a></code>, <code><a href="#topic+easy.select">easy.select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
# No mismatches
MM1 &lt;- locate.mismatch(toy.IO)

# Making toy.IO have mismatches
toy.IO$RS_label &lt;- rbind(toy.IO$RS_label,
                         c("Valhalla", "Wii"),
                         c("Valhalla", "Pizza"),
                         c("Valhalla", "Pizza"),
                         c("Valhalla", "Minions"))
MM2 &lt;- locate.mismatch(toy.IO)
MM2$Lightsabers
</code></pre>

<hr>
<h2 id='lq'>
Simple Location Quotient Updating
</h2><span id='topic+lq'></span>

<h3>Description</h3>

<p>Uses simple linear quotient technique to update the matrix of technical input coefficients (<code>A</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lq(io)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lq_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the simple linear quotient technique as follows:
</p>
<p style="text-align: center;"><code class="reqn">lq_i = \frac{X_i^r / X^r}{X_i^n / X^n}</code>
</p>

<p>where <code class="reqn">X^n</code> is the total production, <code class="reqn">X^r</code> is the total production for region r, <code class="reqn">X^r_i</code> is the production for region r sector i, and <code class="reqn">X^n_i</code> is the total production for the ith sector.
</p>
<p>Then lq is converted such that if <code class="reqn">lq_i &gt; 1</code>, then <code class="reqn">lq_i = 1</code>. Then lq is converted into a diagonal matrix of values less than or equal to 1, which gives us our final results
</p>
<p style="text-align: center;"><code class="reqn">\hat{A} = A lq</code>
</p>



<h3>Value</h3>

<p>Produces the forecast of the matrix of technical input coefficients (<code>A</code>) using the Slq technique.
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade
</p>


<h3>References</h3>

<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)

Anew &lt;- lq(toy.IO)
</code></pre>

<hr>
<h2 id='mpm'>Multiplier Product Matrix</h2><span id='topic+mpm'></span>

<h3>Description</h3>

<p><code>mpm</code> calculates the multiplier product matrix using an <code>InputOutput</code> object calculated from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>. The method is described below.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm(io)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpm_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">L</code> be the Leontief inverse. Then the multiplier product matrix <code class="reqn">M</code> is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">M = 1/v L_c L_r</code>
</p>

<p>where <code class="reqn">v = t(1) L 1</code> such that <code class="reqn">1</code> is a column matrix of ones, <code class="reqn">L_c = L 1</code> is a column matrix of row sums, and <code class="reqn">L_r = t(1) L</code> is a row matrix of column sums.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>M</code></td>
<td>
<p>Multiplier Product Matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John J. P. Wade
</p>


<h3>References</h3>

<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
M &lt;- mpm(toy.IO)
</code></pre>

<hr>
<h2 id='multipliers'>Multiplier Analysis
</h2><span id='topic+multipliers'></span>

<h3>Description</h3>

<p><code>multipliers</code> is currently able to calculate four different multipliers: <code>output</code>, <code>input</code>, <code>income</code>, and <code>employment</code>. See details for formulas.</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipliers(io, ES, regions = "all", sectors = "all", multipliers, wage.row, 
            employ.closed.row, employ.physical.row)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multipliers_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="multipliers_+3A_es">ES</code></td>
<td>
<p>An <code>EasySelect</code> class object from <code><a href="#topic+easy.select">easy.select</a></code> to specify which region and sector combinations to use.</p>
</td></tr>
<tr><td><code id="multipliers_+3A_regions">regions</code></td>
<td>
<p>Character or Integer. Specific regions to be used. Can either be a character that exactly matches the name of the region in <code>RS_label</code> or the number of the region in the order it appears in <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="multipliers_+3A_sectors">sectors</code></td>
<td>
<p>Character or Integer. Specific sectors to be used. Can either be a character that exactly matches the name of the sector in <code>RS_label</code> or the number of the sector in the order it <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="multipliers_+3A_multipliers">multipliers</code></td>
<td>
<p>Character. Any combination of the following: <code>output</code>, <code>input</code>, <code>wage</code>, and/or <code>employment</code></p>
</td></tr>
<tr><td><code id="multipliers_+3A_wage.row">wage.row</code></td>
<td>
<p>Integer. The row(s) in Value Added where wages is stored. See <code>io$V_label</code> if you do not know. This is not to be confused with the labor located in the intermediate transaction matrix (<code>Z</code>)</p>
</td></tr>
<tr><td><code id="multipliers_+3A_employ.closed.row">employ.closed.row</code></td>
<td>
<p>Integer. The row(s) in the intermediate transaction matrix (<code>Z</code>) where labor is stored. This is not to be confused with &quot;wages&quot; or &quot;employee compensation&quot; etc.</p>
</td></tr>
<tr><td><code id="multipliers_+3A_employ.physical.row">employ.physical.row</code></td>
<td>
<p>character or Integer. The row(s) in the phtsical matrix (<code>P</code>) where labor is stored. This is not to be confused with &quot;wages&quot; or &quot;employee compensation&quot; etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are four different multipliers able to be calculated:
</p>
<p>(1) <code>output</code> - Output multipliers are calculated as the sum over rows from the Leontief matrix:
</p>
<p style="text-align: center;"><code class="reqn">O_j = \sum_{i=1}^n l_{ij}  </code>
</p>

<p>where <code class="reqn">l_{ij}</code> is the ith row and jth column element of the Leontief matrix.
</p>
<p>(2)<code>input</code> - Input multipliers are calculated as the sum over columns from the Ghoshian matrix:
</p>
<p style="text-align: center;"><code class="reqn">I_i = \sum_{j=1}^n g_{ij}</code>
</p>

<p>where <code class="reqn">g_ij</code> is the ith row and jth column element of the Ghoshian matrix
</p>
<p>(3) <code>wage</code> - Income multipliers are calculated using value add due to employee compensation or wages. Multiple types of wages are supported. Wages are standardized and multiplied by the Leontief matrix:
</p>
<p style="text-align: center;"><code class="reqn">W_j = \sum_{i=1}^n \omega _i l_{ij} </code>
</p>

<p>where <code class="reqn">\omega _i = w_i/X_i</code> is the wage divided by the total production for that region-sector combination, and <code class="reqn">l_{ij}</code> is the ith row and jth column element of the Leontief matrix.
</p>
<p>(4) <code>employment</code> - Employment multipliers are calculated using the employment row in the matrix of technical input coefficients (<code>A</code>):
</p>
<p style="text-align: center;"><code class="reqn">E_j = \sum_{i=1}^n \epsilon _{ei} l_{ij} </code>
</p>

<p>where <code class="reqn">\epsilon _{ei}</code> is the row(s) corresponding to labor at the ith column, and <code class="reqn">l_{ij}</code> is the ith row and jth column element of the Leontief matrix.
</p>


<h3>Value</h3>

<p>Produces a list over regions of multilpliers.
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri
</p>


<h3>References</h3>

<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>
<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code>, <code><a href="#topic+key.sector">key.sector</a></code>, <code><a href="#topic+linkages">linkages</a></code>, <code><a href="#topic+output.decomposition">output.decomposition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
M1 &lt;- multipliers(toy.IO, multipliers = "wage", wage.row = 1)
M2 &lt;- multipliers(toy.IO, multipliers = "employment.closed", employ.closed.row = "Minions")

data(toy.ES)
class(toy.ES)
M3 &lt;- multipliers(toy.IO, toy.ES, multipliers = c("input", "output"))
</code></pre>

<hr>
<h2 id='output.decomposition'>Decomposition of Output Changes
</h2><span id='topic+output.decomposition'></span>

<h3>Description</h3>

<p>Performs decomposition of output changes given two periods of data. You can decompose by origin over internal, external, or total and you can additionally decompose by changes due to final demand, technical change, or total. This follows the technique of Sonis et al (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output.decomposition(io1, io2, origin = "all", cause = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="output.decomposition_+3A_io1">io1</code></td>
<td>
<p>The first period <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="output.decomposition_+3A_io2">io2</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="output.decomposition_+3A_origin">origin</code></td>
<td>
<p>Character. Choosing to decompose changes to the sectors due to <code>internal</code> changes, <code>external</code> changes, and/or <code>total</code></p>
</td></tr>
<tr><td><code id="output.decomposition_+3A_cause">cause</code></td>
<td>
<p>Character. Choosing to decompose changes to the sectors due to changes in <code>fianldemand</code> (<code>f</code>), technical changes <code>leontief</code> (<code>L</code>), or <code>total</code> changes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A superscript of <code class="reqn">f</code> indicates changes due to final demand, <code class="reqn">l</code> indicates changes due to the Leontief inverse, and no superscript indicates total. A subscript of <code class="reqn">s</code> indicates changes in output originating internally of the sectors, <code class="reqn">n</code> indicates externally, and no subscript indicates total. <code class="reqn">L</code> is the Leontief inverse and <code class="reqn">f</code> is aggregated final demand. Analysis is over changes from period 1 to period 2. The values are calculated as follows:
</p>
<p>Originating: Total
</p>
<p style="text-align: center;"><code class="reqn">\Delta X^f = L_1\Delta f</code>
</p>

<p style="text-align: center;"><code class="reqn">\Delta X^l = \Delta L f_1</code>
</p>

<p style="text-align: center;"><code class="reqn">\Delta X   = \Delta L \Delta f</code>
</p>

<p>Originating: Internal
</p>
<p style="text-align: center;"><code class="reqn">\Delta X_s^f = diag(L_1)\Delta f</code>
</p>

<p style="text-align: center;"><code class="reqn">\Delta X_s^l = diag(\Delta L) f_1</code>
</p>

<p style="text-align: center;"><code class="reqn">\Delta X_s   = diag(\Delta L) \Delta f</code>
</p>

<p>Originating: External
</p>
<p style="text-align: center;"><code class="reqn">\Delta X_n^f = \Delta X^f - \Delta X_s^f</code>
</p>

<p style="text-align: center;"><code class="reqn">\Delta X_n^l = \Delta X^l - \Delta X_s^l</code>
</p>

<p style="text-align: center;"><code class="reqn">\Delta X_n   = \Delta X   - \Delta x_s</code>
</p>



<h3>Value</h3>

<p>The function always outputs a named row of some variant of <code>delta.X</code>. A prefix indicates the changes origin where total is blank. A suffix indicates the cause of the change where total is also blank.
</p>
<table role = "presentation">
<tr><td><code>int</code></td>
<td>
<p>A prefix for internal</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>A prefix for external</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>A suffix for final demand</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>A suffix for technical or Leontief</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri</p>


<h3>References</h3>

<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. <em>PyIO. Input-Output Analysis with Python</em>. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>
<p>Sonis, Michael &amp; Geoffrey JD Hewings, &amp; Jiemin Guo. <em>Sources of structural change in input-output systems: a field of influence approach</em>. Economic Systems Research 8, no. 1 (1996): 15-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
data(toy.IO2)
class(toy.IO)
class(toy.IO) == class(toy.IO2)

OD1 &lt;- output.decomposition(toy.IO, toy.IO2)
OD1$Hogwarts

OD2 &lt;- output.decomposition(toy.IO, toy.IO2, origin = "external", 
                            cause = c("finaldemand","leontief"))
OD2
</code></pre>

<hr>
<h2 id='ras'>
ras Updating Proejcting
</h2><span id='topic+ras'></span>

<h3>Description</h3>

<p>Uses the ras technique to update the matrix of technical input coefficients <code>A</code>. You must have knowledge of or forecasts for the following three objects: (1) row sums <code>u1</code> of <code>A</code>, (2) column sums <code>v1</code> of <code>A</code>, and (3) total production <code>x1</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ras(io, x1, u1, v1, tol, maxiter, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ras_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="ras_+3A_x1">x1</code></td>
<td>
<p>Vector. The forecast for future total production of each region-sector combination, matching the <code>X</code> object in <code>io</code></p>
</td></tr>
<tr><td><code id="ras_+3A_u1">u1</code></td>
<td>
<p>Vector. The forecast for future row sums of the matrix of technical input coefficients in <code>A</code> from <code>io</code></p>
</td></tr>
<tr><td><code id="ras_+3A_v1">v1</code></td>
<td>
<p>Vector. The forecast for future column sums of the matrix of technical input coefficients in <code>A</code> from <code>io</code></p>
</td></tr>
<tr><td><code id="ras_+3A_tol">tol</code></td>
<td>
<p>Numeric. The tolerance for convergence. Default: <code>1e-06</code></p>
</td></tr>
<tr><td><code id="ras_+3A_maxiter">maxiter</code></td>
<td>
<p>Numeric. The maximum number of iterations to try for convergence. Defualt: 10000</p>
</td></tr>
<tr><td><code id="ras_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> will print the iteration and norm at each step. This is useful if the dataset is large. Deafult: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the ras iterative technique for updating the matrix of technical input coefficients. This takes the form:
</p>
<p style="text-align: center;"><code class="reqn">lim_{n \Rightarrow \infty} A^{2n} = lim_{n \Rightarrow \infty} [\hat{R}^n ... \hat{R}^1]A_t[\hat{S}^1 ... \hat{S}^n] = \hat{A}_{t+1}</code>
</p>

<p>where <code class="reqn">R^1 = diag(u_{t+1}/u_0)</code>, <code class="reqn">u_0 = A_tX</code>, and <code class="reqn">u_{t+1} = </code><code>u1</code>. Similarly <code class="reqn">S^1 = diag(v_{t+1}/v_0)</code>, <code class="reqn">v_0 = XR^1A_t</code>.
</p>
<p>Each iteration calculates the full <code class="reqn">ras</code> object; that is, 2 steps are caluclated per iteration.
</p>
<p>See Blair and Miller (2009) for more details.
</p>


<h3>Value</h3>

<p>Produces the forecast of the matrix of technical input coefficients given the forecasted row sums, column sums, and total production.
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade
</p>


<h3>References</h3>

<p>Blair, P.D. and Miller, R.E. (2009). &quot;Input-Output Analysis: Foundations and Extensions&quot;. Cambridge University Press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code>, <code><a href="#topic+lq">lq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)

set.seed(117)
growth &lt;- 1 + 0.1 * runif(10)
sort(growth)

X &lt;- toy.IO$X
X1 &lt;- X * growth
U &lt;- rowSums(toy.IO$Z)
U1 &lt;- U * growth
V &lt;- colSums(toy.IO$Z)
V1 &lt;- V * growth

ras &lt;- ras(toy.IO, X1, U1, V1, maxiter = 10, verbose = TRUE)
</code></pre>

<hr>
<h2 id='rsp'>Regional Supply Percentage Updating</h2><span id='topic+rsp'></span>

<h3>Description</h3>

<p><code>rsp</code> uses the RSP technique to update the matrix of technical input coefficients <code>A</code> from an <code>InputOutput</code> object created from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>. The function calls upon <code><a href="#topic+import.total">import.total</a></code> and <code><a href="#topic+export.total">export.total</a></code> to calculate the imports and exports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsp(io)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsp_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new matrix of technical coefficients is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">A_{new} = \hat{p} A</code>
</p>

<p>where <code class="reqn">\hat{p}</code> is a diagonal matrix with each diagonal componenet calculated as
</p>
<p style="text-align: center;"><code class="reqn">p_i = \frac{X_i - E_i}{X_i - E_i + M_i}</code>
</p>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Anew</code></td>
<td>
<p>The updated matrix of technical input coefficients</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John J. P. Wade
</p>


<h3>References</h3>

<p>Nazara, Suahasil &amp; Guo, Dong &amp; Hewings, Geoffrey J.D., &amp; Dridi, Chokri, 2003. &quot;PyIO. Input-Output Analysis with Python&quot;. REAL Discussion Paper 03-t-23. University of Illinois at Urbana-Champaign. (<a href="http://www.real.illinois.edu/d-paper/03/03-t-23.pdf">http://www.real.illinois.edu/d-paper/03/03-t-23.pdf</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import.total">import.total</a></code>, <code><a href="#topic+export.total">export.total</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)

Anew &lt;- rsp(toy.IO)
</code></pre>

<hr>
<h2 id='toy.ES'>An example dataset of class <code>EasySelect</code></h2><span id='topic+toy.ES'></span>

<h3>Description</h3>

<p>An object of <code>EasySelect</code> class created from <code><a href="#topic+easy.select">easy.select</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("toy.ES")</code></pre>


<h3>Format</h3>

<p>A character matrix with three columns and 5 rows with class <code>EasySelect</code>. The first row indicates which rows/columns of <code>toy.IO</code> are of interest. The second and third column are the regions and sectors that respectively match the the first column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.ES)
class(toy.ES)
</code></pre>

<hr>
<h2 id='toy.FullIOTable'>An example data set to illustrate as.inputoutput
</h2><span id='topic+toy.FullIOTable'></span><span id='topic+toy.FullIOTable2'></span>

<h3>Description</h3>

<p>This data is designed to be a small dimension worst case scenario. The numbers are saved as a string and there are many <code>NA</code>s floating around. The data itself was randomly generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("toy.FullIOTable")</code></pre>


<h3>Format</h3>

<p>An input output matrix with two regions, five sectors, four national accounts categories (including exports), four values added (including imports), and total production.
</p>


<h3>Details</h3>

<p>toy,FullIOTable was created using the following code where <code>toy.FullIOTable</code> was created using the seed of <code>117</code> and <code>toy.FullIOTable2</code> was created using the seed <code>112358</code>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+toy.IO">toy.IO</a></code>, <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(117)
# Creating the T (transaction) matrix

T11 &lt;- matrix(sample(1:100, 25), ncol = 5, nrow = 5)
T12 &lt;- matrix(sample(1:100, 25), ncol = 5, nrow = 5)
T21 &lt;- matrix(sample(1:100, 25), ncol = 5, nrow = 5)
T22 &lt;- matrix(sample(1:100, 25), ncol = 5, nrow = 5)
Trd &lt;- rbind(cbind(T11,T12),cbind(T21,T22))
# Creating Labels
region &lt;- c(rep("Hogwarts",5),rep("Narnia",5))
sector &lt;- c("Pizza","Wii","Spaceships","Lightsabers","Minions")
sector &lt;- c(sector,sector)
id &lt;- rbind(region,sector)
blank &lt;- matrix(NA, ncol = 2, nrow = 2)
Trd &lt;- rbind( cbind(blank, id), cbind(t(id), Trd))
# Creating value added matrix
V &lt;- matrix(sample(100:300, 30), ncol = 10, nrow = 3)
label &lt;- matrix(c("Employee Compensation", "Proprietor Income", "Indirect Business Tax"),
                ncol = 1)
blank &lt;- matrix(NA, ncol = 1, nrow = 3)
V &lt;- cbind(blank, label, V)
# Creating final demand matrix
f &lt;- matrix(sample(1:300, 80), ncol = 8, nrow = 10)
label &lt;- c("Household", "Government", "Investment", " Exports")
label &lt;- matrix(c(label, label), nrow = 1)
id &lt;- rbind(region[c(1:4,6:9)], label)
f &lt;- rbind(id, f)
# Creating total production
one.10 &lt;- matrix(rep(1, 10), ncol = 1)
one.8 &lt;- matrix(rep(1, 8), ncol = 1)
X &lt;- matrix(as.numeric(Trd[3:12, 3:12]), nrow = 10)%*%one.10 + 
     matrix(as.numeric(f[3:12,]), nrow = 10)%*%one.8
label &lt;- matrix(c(NA,"Total"))
X &lt;- rbind(label, X)
# Creating imports (in this case it is a residual)
M &lt;- matrix(NA, nrow = 1, ncol = 12)
one.3 &lt;- matrix(rep(1, 3), ncol = 1)
M[1, 3:12] &lt;- t(one.10)%*%matrix(as.numeric(Trd[3:12, 3:12]), nrow = 10) + 
              t(one.3)%*%matrix(as.numeric(V[,3:12]), nrow = 3)
M[1, 2] &lt;- "Imports"
# Putting this beast together
blank &lt;- matrix(NA, nrow=5, ncol = 9)
holder &lt;- cbind(f, X)
holder &lt;- rbind(holder, blank)
hold &lt;- rbind(Trd, V, M, t(X))
toy.FullIOTable &lt;- cbind(hold, holder)
# Creating an FV matrix
a &lt;- matrix(round(80*runif(12)), nrow = 2, ncol = 6)
toy.FullIOTable[15:16, c(13:15, 17:19)] &lt;- a
</code></pre>

<hr>
<h2 id='toy.IO'>
An example dataset of class <code>InputOutput</code>
</h2><span id='topic+toy.IO'></span><span id='topic+toy.IO2'></span>

<h3>Description</h3>

<p>An object of <code>InputOutput</code> class created from <code><a href="#topic+toy.FullIOTable">toy.FullIOTable</a></code> using <code><a href="#topic+as.inputoutput">as.inputoutput</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("toy.IO")</code></pre>


<h3>Format</h3>

<p>toy.IO is a list with 14 elements: 7 matrices and 7 labels.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Z</code></td>
<td>
<p>Intermediate Transactions</p>
</td></tr>
<tr><td><code>RS_label</code></td>
<td>
<p>Column matrix of labels for region and sector</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Final Demand</p>
</td></tr>
<tr><td><code>f_label</code></td>
<td>
<p>Row matrix of labels for accounts for <code>f</code></p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Exports</p>
</td></tr>
<tr><td><code>E_label</code></td>
<td>
<p>Row matrix of labels for exports by sector and region for <code>E</code></p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Total Production</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>Value added</p>
</td></tr>
<tr><td><code>V_label</code></td>
<td>
<p>Column matrix of labels for types of value added for <code>V</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Imports</p>
</td></tr>
<tr><td><code>M_label</code></td>
<td>
<p>Colum matrix of labels for type of imports for <code>M</code></p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Technical Coefficients</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Leontief Inverse</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
</code></pre>

<hr>
<h2 id='upstream'>
Upstreamness - Average Distance from Final Use
</h2><span id='topic+upstream'></span>

<h3>Description</h3>

<p>Measures upstreamness as in Antras et al. (2012), equation (9) page 5. The value is weakly bounded below by one, where a value close to one indicates it is near its final use on average and a higher value indicates it is further away from final use on average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upstream(io, ES, regions = "all", sectors = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upstream_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="upstream_+3A_es">ES</code></td>
<td>
<p>An <code>EasySelect</code> class object from <code><a href="#topic+easy.select">easy.select</a></code> to specify which region and sector combinations to use.</p>
</td></tr>
<tr><td><code id="upstream_+3A_regions">regions</code></td>
<td>
<p>Character or Integer. Specific regions to be used. Can either be a character that exactly matches the name of the region in <code>RS_label</code> or the number of the region in the order it appears in <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="upstream_+3A_sectors">sectors</code></td>
<td>
<p>Character or Integer. Specific sectors to be used. Can either be a character that exactly matches the name of the sector in <code>RS_label</code> or the number of the sector in the order it <code>RS_label</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The upstreamness is calculated as follows, where, A is the matrix of technical input coefficients, X is total production, E is exports, and M is imports.
</p>
<p style="text-align: center;"><code class="reqn">d_{ij} = a_{ij} \frac{x_i}{x_i + e_{ij} - m_{ij}}</code>
</p>

<p style="text-align: center;"><code class="reqn">U = (I - D)^{-1}</code>
</p>

<p style="text-align: center;"><code class="reqn">u_i = \sum_{j=1}^n U_{ij}</code>
</p>



<h3>Value</h3>

<p>Produces a list over regions of each region's sectors upstreamness measure.
</p>


<h3>Note</h3>

<p>If the import (M) and/or export (E) is a matrix (i.e. not a nx1 vector) they are summed across region-sector combinations.
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri
</p>


<h3>References</h3>

<p>Pol Antras &amp; Davin Chor &amp; Thibault Fally &amp; Russell Hillberry, 2012. <em>Measuring the Upstreamness of Production and Trade Flows</em>. NBER Working Papers 17819, National Bureau of Economic Research, Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.inputoutput">as.inputoutput</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
u1 &lt;- upstream(toy.IO)
u1$Hogwarts
</code></pre>

<hr>
<h2 id='vs'>Vertical Specialization</h2><span id='topic+vs'></span>

<h3>Description</h3>

<p>Calculates the vertical specialization share of total exports of each sector as described by Hummels et al. (2001), equation 3. Creates a value between zero and one to indicate relative specialization. For each region, a Leontief inverse is calculated. You need a multi-region input-output dataset for <code>vs</code> to be relevant.
</p>
<p>Caution: Inverting large matrices will take a long time. Each individual hypothetical extraction requires the inversion of a matrix. R does a computation roughly every 8e-10 second. The number of computations per matrix inversion is n^3 where n is the dimension of the square matrix. For n = 5000 it should take 100 seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vs(io, ES, regions = "all", sectors = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vs_+3A_io">io</code></td>
<td>
<p>An <code>InputOutput</code> class object from <code><a href="#topic+as.inputoutput">as.inputoutput</a></code></p>
</td></tr>
<tr><td><code id="vs_+3A_es">ES</code></td>
<td>
<p>An <code>EasySelect</code> class object from <code><a href="#topic+easy.select">easy.select</a></code> to specify which region and sector combinations to use.</p>
</td></tr>
<tr><td><code id="vs_+3A_regions">regions</code></td>
<td>
<p>Character or Integer. Specific regions to be used. Can either be a character that exactly matches the name of the region in <code>RS_label</code> or the number of the region in the order it appears in <code>RS_label</code>.</p>
</td></tr>
<tr><td><code id="vs_+3A_sectors">sectors</code></td>
<td>
<p>Character or Integer. Specific sectors to be used. Can either be a character that exactly matches the name of the sector in <code>RS_label</code> or the number of the sector in the order it <code>RS_label</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vertical specialization share of total exports is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">
\frac{vs_r}{X_r^{total}} = \frac{1}{X_r^{total}} A^M_r L_r X_r
</code>
</p>

<p>where <code class="reqn">X_r^{total}</code> is the total exports for region r, <code class="reqn">A^M_r</code> is the matrix of technical import coefficients, <code class="reqn">L_r</code> is the domestic Leontief inverse calculated from the domestic matrix of technical coefficients i.e. <code class="reqn">A_{rr}</code> not the full <code class="reqn">A</code> matrix, and <code class="reqn">X_r</code> is the vector of total exports.
</p>


<h3>Value</h3>

<p>Creates a region list of vs share of total exports.
</p>


<h3>Author(s)</h3>

<p>John J. P. Wade, Ignacio Sarmiento-Barbieri
</p>


<h3>References</h3>

<p>Hummels, David &amp; Ishii, Jun &amp; Yi, Kei-Mu, 2001. <em>The nature and growth of vertical specialization in world trade</em>. Journal of International Economics, Elsevier, vol. 54(1), pages 75-96, June.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import.coef">import.coef</a></code>, <code><a href="#topic+export.total">export.total</a></code>, <code><a href="#topic+check.RS">check.RS</a></code>, <code><a href="#topic+leontief.inv">leontief.inv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toy.IO)
class(toy.IO)
(vs1 &lt;- vs(toy.IO, regions = "all"))
vs1$Hogwarts
sum(vs1$Hogwarts)

data(toy.ES)
class(toy.ES)
vs2 &lt;- vs(toy.IO, toy.ES)
vs2
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
