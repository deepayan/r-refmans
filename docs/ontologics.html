<!DOCTYPE html><html><head><title>Help for package ontologics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ontologics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#edit_matches'><p>Edit matches manually in a csv-table</p></a></li>
<li><a href='#export_as_rdf'><p>Export an ontology as RDF</p></a></li>
<li><a href='#get_class'><p>Get class(es) in an ontology</p></a></li>
<li><a href='#get_concept'><p>Get a concept in an ontology</p></a></li>
<li><a href='#get_source'><p>Get source(e) in an ontology</p></a></li>
<li><a href='#load_ontology'><p>Load an ontology</p></a></li>
<li><a href='#make_tree'><p>Make a tree of an ontology</p></a></li>
<li><a href='#new_class'><p>Add a new valid class to an ontology</p></a></li>
<li><a href='#new_concept'><p>Add a new concept to an ontology</p></a></li>
<li><a href='#new_mapping'><p>Add a new mapping to an ontology</p></a></li>
<li><a href='#new_source'><p>Add a new valid source to an ontology</p></a></li>
<li><a href='#onto-class'><p>Ontology class (S4) and methods</p></a></li>
<li><a href='#show,onto-method'><p>Print onto in the console</p></a></li>
<li><a href='#start_ontology'><p>Start an ontology</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Code-Logics to Handle Ontologies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools to build and work with an ontology of linked (open) 
    data in a tidy workflow. It is inspired by the Food and Agrilculture 
    Organizations (FAO) caliper platform 
    <a href="https://www.fao.org/statistics/caliper/web/">https://www.fao.org/statistics/caliper/web/</a> and 
    makes use of the Simple Knowledge Organisation System (SKOS).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/luckinet/ontologics">https://github.com/luckinet/ontologics</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/luckinet/ontologics/issues">https://github.com/luckinet/ontologics/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, dplyr, httr, magrittr, methods, purrr, readr,
rlang, stringr, tibble, tidyr, tidyselect, rdflib, fuzzyjoin,
beepr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-10 08:55:39 UTC; se87kuhe</td>
</tr>
<tr>
<td>Author:</td>
<td>Steffen Ehrmann <a href="https://orcid.org/0000-0002-2958-0796"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Arne RÃ¼mmler <a href="https://orcid.org/0000-0001-8637-9071"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Carsten Meyer <a href="https://orcid.org/0000-0003-3927-5856"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steffen Ehrmann &lt;steffen.ehrmann@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-10 09:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='edit_matches'>Edit matches manually in a csv-table</h2><span id='topic+edit_matches'></span>

<h3>Description</h3>

<p>Allows the user to match concepts with an already existing ontology, without
actually writing into the ontology, but instead storing the resulting
matching table as csv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edit_matches(
  new,
  target = NULL,
  source = NULL,
  ontology = NULL,
  matchDir = NULL,
  verbose = TRUE,
  beep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edit_matches_+3A_new">new</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame(.)</a></code><br /> the new concepts that shall be
manually matched.</p>
</td></tr>
<tr><td><code id="edit_matches_+3A_target">target</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame(.)</a></code><br /> the attributes, in terms of
columns in the ontology, of new concepts that help to match new and target
concepts manually.</p>
</td></tr>
<tr><td><code id="edit_matches_+3A_source">source</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> any character uniquely
identifying the source dataset of the new concepts.</p>
</td></tr>
<tr><td><code id="edit_matches_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology.</p>
</td></tr>
<tr><td><code id="edit_matches_+3A_matchdir">matchDir</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the directory where to store
source-specific matching tables.</p>
</td></tr>
<tr><td><code id="edit_matches_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to give detailed
information on the process of this function.</p>
</td></tr>
<tr><td><code id="edit_matches_+3A_beep">beep</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> Number specifying what sound to be
played to signal the user that a point of interaction is reached by the
program, see <code><a href="beepr.html#topic+beep">beep</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to match new concepts into an already existing ontology, it
may become necessary to carry out manual matches of the new concepts with
already harmonised concepts, for example, when the new concepts are
described with terms that are not yet in the ontology. This function puts
together a table, in which the user would edit matches by hand. Whith the
argument <code>verbose = TRUE</code>, detailed information about the edit process
are shown to the user. After defining matches, and even if not all
necessary matches are finished, the function stores a specific &quot;matching
table&quot; with the name <em>match_SOURCE.csv</em> in the respective directory
(<code>matchDir</code>), from where work can be picked up and continued at
another time.
</p>
<p>Fuzzy matching is carried out and matches with 0, 1 or 2 differing
charcters are presented in a respective column.
</p>


<h3>Value</h3>

<p>A table that contains all new matches, or if none of the new concepts
weren't already in the ontology, a table of the already sucessful matches.
</p>

<hr>
<h2 id='export_as_rdf'>Export an ontology as RDF</h2><span id='topic+export_as_rdf'></span>

<h3>Description</h3>

<p>Export an ontology as RDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_as_rdf(ontology, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_as_rdf_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> an already loaded or created
ontology object.</p>
</td></tr>
<tr><td><code id="export_as_rdf_+3A_filename">filename</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the filename of the exported
ontology. The format of the exported ontology is guessed by the extension
of the filename. The guessing is performed by the rdflib package. Valid
extensions are &quot;.rdf&quot; for &quot;rdfxml&quot;, &quot;.nt&quot; for &quot;ntriples&quot;, &quot;.ttl&quot; for
&quot;turtle&quot; or &quot;.json&quot; for &quot;jsonld&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for the side effect of exporting an ontology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ontoDir &lt;- system.file("extdata", "crops.rds", package = "ontologics")
onto &lt;- load_ontology(path = ontoDir)

## Not run: 

  export_as_rdf(ontology = onto, filename = "onto.ttl")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_class'>Get class(es) in an ontology</h2><span id='topic+get_class'></span>

<h3>Description</h3>

<p>Get class(es) in an ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_class(..., regex = FALSE, external = FALSE, ontology = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_class_+3A_...">...</code></td>
<td>
<p>combination of column name and value to filter that column by. The
value to filter by can be provided as regular expression, if <code>regex =
  TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_class_+3A_regex">regex</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not the value in
<code>...</code> shall be matched in full, or whether any partial match should be
returned.</p>
</td></tr>
<tr><td><code id="get_class_+3A_external">external</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not the external
classes (TRUE), or the harmonized classes should be returned (FALSE,
default).</p>
</td></tr>
<tr><td><code id="get_class_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of the class(es) in the ontology according to the values in
<code>...</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ontoDir &lt;- system.file("extdata", "crops.rds", package = "ontologics")
onto &lt;- load_ontology(path = ontoDir)

# exact classes from a loaded ontology ...
get_class(label = "class", ontology = onto)

# ... or one stored on the harddisc
get_class(id = ".xx.xx", ontology = ontoDir)

# use regular expressions ...
get_class(label = "ro", regex = TRUE, ontology = onto)

# get all sources
get_class(ontology = onto)
</code></pre>

<hr>
<h2 id='get_concept'>Get a concept in an ontology</h2><span id='topic+get_concept'></span>

<h3>Description</h3>

<p>Get a concept in an ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_concept(..., external = FALSE, ontology = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_concept_+3A_...">...</code></td>
<td>
<p>combination of column name and value to filter that column by. The
value to filter by can be provided as regular expression, if <code>regex =
  TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_concept_+3A_external">external</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to return merely
the table of external concepts.</p>
</td></tr>
<tr><td><code id="get_concept_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of a subset of the ontology according to the values in
<code>...</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ontoDir &lt;- system.file("extdata", "crops.rds", package = "ontologics")
onto &lt;- load_ontology(path = ontoDir)

# exact matches from a loaded ontology ...
get_concept(label = "FODDER CROPS", ontology = onto)

# ... or a path
get_concept(label = c("FODDER CROPS", "CEREALS"), ontology = ontoDir)

# ignore querries that would not be valid in filter()
get_concept(label != 'Bioenergy woody' &amp; has_broader == '.01', ontology = onto)

# extract concepts based on regular expressions
library(stringr)
get_concept(str_detect(label, "crop") &amp; str_detect(id, ".03$"), ontology = ontoDir)

</code></pre>

<hr>
<h2 id='get_source'>Get source(e) in an ontology</h2><span id='topic+get_source'></span>

<h3>Description</h3>

<p>Get source(e) in an ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_source(..., regex = FALSE, ontology = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_source_+3A_...">...</code></td>
<td>
<p>combination of column name and value to filter that column by. The
value to filter by can be provided as regular expression, if <code>regex =
  TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_source_+3A_regex">regex</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not the value in
<code>...</code> shall be matched in full, or whether any partial match should be
returned.</p>
</td></tr>
<tr><td><code id="get_source_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of the source(s) in the ontology according to the values in
<code>...</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ontoDir &lt;- system.file("extdata", "crops.rds", package = "ontologics")
onto &lt;- load_ontology(path = ontoDir)

# exact sources from a loaded ontology ...
get_source(label = "harmonised", ontology = onto)

# ... or one stored on the harddisc
get_source(version = "0.0.1", ontology = ontoDir)

# get all sources
get_source(ontology = onto)
</code></pre>

<hr>
<h2 id='load_ontology'>Load an ontology</h2><span id='topic+load_ontology'></span>

<h3>Description</h3>

<p>Load an ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_ontology(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_ontology_+3A_path">path</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the path where the ontology to
load is stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of the full ontology (i.e., where attribute and mapping
tables are joined).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load an already existing ontology
load_ontology(path = system.file("extdata", "crops.rds", package = "ontologics"))

</code></pre>

<hr>
<h2 id='make_tree'>Make a tree of an ontology</h2><span id='topic+make_tree'></span>

<h3>Description</h3>

<p>Make a tree of an ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tree(..., reverse = FALSE, ontology = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_tree_+3A_...">...</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the concepts that shall be the
target, combination of <em>'column name = value'</em>.</p>
</td></tr>
<tr><td><code id="make_tree_+3A_reverse">reverse</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to make a tree that
gives the parents, instead of the children, of target concepts.</p>
</td></tr>
<tr><td><code id="make_tree_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology.</p>
</td></tr>
</table>

<hr>
<h2 id='new_class'>Add a new valid class to an ontology</h2><span id='topic+new_class'></span>

<h3>Description</h3>

<p>Add a new valid class to an ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_class(new, target, description = NULL, ontology = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_class_+3A_new">new</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the new class label.</p>
</td></tr>
<tr><td><code id="new_class_+3A_target">target</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the class to which the new class
shall be related.</p>
</td></tr>
<tr><td><code id="new_class_+3A_description">description</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> a verbatim description of
the new class.</p>
</td></tr>
<tr><td><code id="new_class_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the updated ontology that contains the new class(es) defined here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ontoDir &lt;- system.file("extdata", "crops.rds", package = "ontologics")
onto &lt;- load_ontology(path = ontoDir)

onto &lt;- new_class(new = "use type", target = "class", description = "something",
                  ontology = onto)

</code></pre>

<hr>
<h2 id='new_concept'>Add a new concept to an ontology</h2><span id='topic+new_concept'></span>

<h3>Description</h3>

<p>This adds a new concept to an existing ontology to semantically integrate and
thus harmonise it with the already existing ontology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_concept(
  new,
  broader = NULL,
  description = NULL,
  class = NULL,
  ontology = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_concept_+3A_new">new</code></td>
<td>
<p><code><a href="base.html#topic+character">character(.)</a></code><br /> the english label(s) of new
concepts that shall be included in the ontology.</p>
</td></tr>
<tr><td><code id="new_concept_+3A_broader">broader</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame(.)</a></code><br /> the english label(s) of
already harmonised concepts to which the new concept shall be semantically
linked via a
<a href="https://www.w3.org/TR/skos-reference/#semantic-relations">skos:broader</a>
relation, see Details.</p>
</td></tr>
<tr><td><code id="new_concept_+3A_description">description</code></td>
<td>
<p><code><a href="base.html#topic+character">character(.)</a></code><br /> a verbatim description of
the new concept(s).</p>
</td></tr>
<tr><td><code id="new_concept_+3A_class">class</code></td>
<td>
<p><code><a href="base.html#topic+character">character(.)</a></code><br /> the class(es) of the new labels.</p>
</td></tr>
<tr><td><code id="new_concept_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns invisibly a table of the new harmonised concepts that were
added to the ontology, or a message that nothing new was added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ontoDir &lt;- system.file("extdata", "crops.rds", package = "ontologics")
onto &lt;- load_ontology(path = ontoDir)

# add fully known concepts
concepts &lt;- data.frame(
  old = c("Bioenergy woody", "Bioenergy herbaceous"),
  new = c("acacia", "miscanthus")
)

onto &lt;- new_source(
  version = "0.0.1",
  name = "externalDataset",
  description = "a vocabulary",
  homepage = "https://www.something.net",
  license = "CC-BY-0",
  ontology = onto
)

onto &lt;- new_concept(
  new = concepts$new,
  broader = get_concept(label = concepts$old, ontology = onto),
  class = "crop",
  ontology = onto
)

# add concepts where the nesting is clear, but not the new class
concepts &lt;- data.frame(
  old = c("Barley", "Barley"),
  new = c("food", "bio-energy")
)

onto &lt;- new_concept(
  new = concepts$new,
  broader = get_concept(label = concepts$old, ontology = onto),
  ontology = onto
)

# define that class ...
onto &lt;- new_class(
  new = "use type", target = "class",
  description = "the way a crop is used", ontology = onto
)

# ... and set the concepts again
onto &lt;- new_concept(
  new = concepts$new,
  broader = get_concept(label = concepts$old, ontology = onto),
  class = "use type",
  ontology = onto
)

</code></pre>

<hr>
<h2 id='new_mapping'>Add a new mapping to an ontology</h2><span id='topic+new_mapping'></span>

<h3>Description</h3>

<p>Extend an ontology by creating mappings between classes and concepts of
external vocabularies and the harmonised classes and concepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_mapping(
  new = NULL,
  target,
  source = NULL,
  lut = NULL,
  match = NULL,
  certainty = NULL,
  type = "concept",
  ontology = NULL,
  verbose = FALSE,
  beep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_mapping_+3A_new">new</code></td>
<td>
<p><code><a href="base.html#topic+character">character(.)</a></code><br /> the english external label(s) that
shall be mapped to labels that do already exist in the ontology.</p>
</td></tr>
<tr><td><code id="new_mapping_+3A_target">target</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame(.)</a></code><br /> the already harmonised English
label(s) to which the external labels shall be mapped; derive with get_concept().</p>
</td></tr>
<tr><td><code id="new_mapping_+3A_source">source</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> any character uniquely
identifying the source dataset of the new label.</p>
</td></tr>
<tr><td><code id="new_mapping_+3A_lut">lut</code></td>
<td>
<p><code><a href="base.html#topic+character">character(.)</a></code><br /> in case the terms used for mapping
are from a look up table (i.e. a standardised set of terms with a
description), provide this table with column names 'label' and
'description' here.</p>
</td></tr>
<tr><td><code id="new_mapping_+3A_match">match</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the
<a href="https://www.w3.org/TR/skos-reference/#mapping">skos mapping property</a>
used to describe the link, possible values are <code>"close"</code>,
<code>"exact"</code>, <code>"broad"</code> and <code>"narrow"</code>.</p>
</td></tr>
<tr><td><code id="new_mapping_+3A_certainty">certainty</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> the certainty of the match.
Possible values are between 1 and 4, with meaning </p>
<ul>
<li><p> 1 =
probably unreliable </p>
</li>
<li><p> 2 = unclear, assigned according to a given
definition </p>
</li>
<li><p> 3 = clear, assigned according to a given definition </p>
</li>
<li>
<p>4 = original, harmonised term (can't be assigned by a user)</p>
</li></ul>
<p>.</p>
</td></tr>
<tr><td><code id="new_mapping_+3A_type">type</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> whether the new labels are mapped
to a <code>"concept"</code>, or to a <code>"class"</code>.</p>
</td></tr>
<tr><td><code id="new_mapping_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology.</p>
</td></tr>
<tr><td><code id="new_mapping_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to give detailed
information on the process of this function.</p>
</td></tr>
<tr><td><code id="new_mapping_+3A_beep">beep</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> Number specifying what sound to be
played to signal the user that a point of interaction is reached by the
program, see <code><a href="beepr.html#topic+beep">beep</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for the side effect of adding new mappings to
an ontology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ontoDir &lt;- system.file("extdata", "crops.rds", package = "ontologics")
onto &lt;- load_ontology(path = ontoDir)

mapping &lt;- data.frame(old = c("BIOENERGY CROPS", "Bioenergy woody",
                              "Other bioenergy crops"),
                      new = c("bioenergy plants", "Wood plantation for fuel",
                              "Algae for bioenergy"),
                      type = c("close", "broader", "broader"))

onto &lt;- new_source(name = "externalDataset",
                   version = "0.0.1",
                   description = "a vocabulary",
                   homepage = "https://www.something.net",
                   license = "CC-BY-0",
                   ontology = onto)

onto &lt;- get_concept(label = mapping$old, ontology = onto) %&gt;%
  new_mapping(new = mapping$new,
              target = .,
              match = mapping$type,
              source = "externalDataset",
              certainty = 3,
              ontology = onto)

</code></pre>

<hr>
<h2 id='new_source'>Add a new valid source to an ontology</h2><span id='topic+new_source'></span>

<h3>Description</h3>

<p>Add a new valid source to an ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_source(
  ontology = NULL,
  name = NULL,
  version = NULL,
  date = NULL,
  description = NULL,
  homepage = NULL,
  uri_prefix = NULL,
  license = NULL,
  notes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_source_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology into which the new source should be
included.</p>
</td></tr>
<tr><td><code id="new_source_+3A_name">name</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the name of the new source (must
not contain empty spaces).</p>
</td></tr>
<tr><td><code id="new_source_+3A_version">version</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> an optional version of the new
source (any value is allowed, but should be a value that follows
<a href="https://semver.org/">semantic versioning</a>). Either version or date
need to be given.</p>
</td></tr>
<tr><td><code id="new_source_+3A_date">date</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> an optional date at which that
version of an external vocabulary has been created. Should be a value of
the form YYYY-MM-DD. Either version or date need to be given.</p>
</td></tr>
<tr><td><code id="new_source_+3A_description">description</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> a verbatim description of
the new source.</p>
</td></tr>
<tr><td><code id="new_source_+3A_homepage">homepage</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the homepage of the new
source, typically the place where additional information or meta-data could
be retrieved in a non-formalised way.</p>
</td></tr>
<tr><td><code id="new_source_+3A_uri_prefix">uri_prefix</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the basic uniform resource
locator (URL) all concepts of a new source have in common and which is thus
the basis to construct the concept specific URI.</p>
</td></tr>
<tr><td><code id="new_source_+3A_license">license</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the licenses under which the
new source is published.</p>
</td></tr>
<tr><td><code id="new_source_+3A_notes">notes</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> any notes on the new source that
don't fit into any of the other meta-data fields here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fundamentally, there are two types of sources that can be defined
with this function. </p>
<ul>
<li> <p><em>attribute collections</em>: where a
collection of terms or concepts are associated as a descriptive attribute
to the harmonised concepts, and </p>
</li>
<li> <p><em>linked open data</em>: where the
concepts that occur in another vocabulary or ontology and which are
themselves part of linked datasets (and hence have a valid URI) are
associated as related concepts to the harmonised concepts.</p>
</li></ul>
<p> In the latter
case, each mapped concept should be provided by its ID and the source needs
to have a URL that allows in combination with the concept IDs to construct
the URI under which the mapped concepts are stored in the semantic web.
</p>


<h3>Value</h3>

<p>the updated ontology that contains the new source defined here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ontoDir &lt;- system.file("extdata", "crops.rds", package = "ontologics")
onto &lt;- load_ontology(path = ontoDir)

onto &lt;- new_source(name = "externalDataset",
                   version = "0.0.1",
                   description = "a vocabulary",
                   homepage = "https://www.something.net",
                   license = "CC-BY-0",
                   ontology = onto)
</code></pre>

<hr>
<h2 id='onto-class'>Ontology class (S4) and methods</h2><span id='topic+onto-class'></span><span id='topic+onto'></span>

<h3>Description</h3>

<p>Ontology class (S4) and methods
</p>


<h3>Slots</h3>


<dl>
<dt><code>sources</code></dt><dd><p><code><a href="base.html#topic+data.frame">data.frame(.)</a></code><br /></p>
</dd>
<dt><code>classes</code></dt><dd><p><code><a href="base.html#topic+data.frame">data.frame(.)</a></code><br /></p>
</dd>
<dt><code>concepts</code></dt><dd><p><code><a href="base.html#topic+data.frame">data.frame(.)</a></code><br /></p>
</dd>
</dl>

<hr>
<h2 id='show+2Conto-method'>Print onto in the console</h2><span id='topic+show+2Conto-method'></span>

<h3>Description</h3>

<p>Print onto in the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onto'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Conto-method_+3A_object">object</code></td>
<td>
<p>object to <code>show</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='start_ontology'>Start an ontology</h2><span id='topic+start_ontology'></span>

<h3>Description</h3>

<p>Start an ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_ontology(
  name = NULL,
  version = NULL,
  path = NULL,
  code = ".xx",
  description = NULL,
  homepage = NULL,
  uri_prefix = NULL,
  license = NULL,
  notes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_ontology_+3A_name">name</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the path of the ontology.</p>
</td></tr>
<tr><td><code id="start_ontology_+3A_version">version</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the version of the ontology.</p>
</td></tr>
<tr><td><code id="start_ontology_+3A_path">path</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the path where the ontology shall
be stored.</p>
</td></tr>
<tr><td><code id="start_ontology_+3A_code">code</code></td>
<td>
<p><code><a href="base.html#topic+double">double(1)</a></code><br /> format of a single code snippet that is
concatenated for nested levels.</p>
</td></tr>
<tr><td><code id="start_ontology_+3A_description">description</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> a brief description of the
new ontology.</p>
</td></tr>
<tr><td><code id="start_ontology_+3A_homepage">homepage</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the URL to the homepage of the
new ontology.</p>
</td></tr>
<tr><td><code id="start_ontology_+3A_uri_prefix">uri_prefix</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the basic URL to construct
URIs for all concepts.</p>
</td></tr>
<tr><td><code id="start_ontology_+3A_license">license</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> any string describing the
license under which this ontology can be (re)used.</p>
</td></tr>
<tr><td><code id="start_ontology_+3A_notes">notes</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> any notes that might apply to
this ontology.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>it returns the new, empty ontology and also stores that within the
directory specified in <code>path</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>start_ontology(name = "crops", path = tempdir())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
