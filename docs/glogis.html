<!DOCTYPE html><html><head><title>Help for package glogis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glogis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#breakpoints.glogisfit'><p>Segmented Fitting of the Generalized Logistic Distribution</p></a></li>
<li><a href='#glogis'><p>The Generalized Logistic Distribution (Type I: Skew-Logitic)</p></a></li>
<li><a href='#glogisfit'><p>Fitting the Generalized Logistic Distribution</p></a></li>
<li><a href='#HICP'><p>Harmonised Index of Consumer Prices (1990&ndash;2010, OECD)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting and Testing Generalized Logistic Distributions</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for the generalized logistic distribution (Type I,
             also known as skew-logistic distribution), encompassing
	     basic distribution functions (p, q, d, r, score), maximum
	     likelihood estimation, and structural change methods.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>strucchange, fxregime, lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, sandwich</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-19 07:43:01 UTC; zeileis</td>
</tr>
<tr>
<td>Author:</td>
<td>Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Thomas Windberger [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-19 12:12:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='breakpoints.glogisfit'>Segmented Fitting of the Generalized Logistic Distribution</h2><span id='topic+breakpoints.glogisfit'></span><span id='topic+coef.breakpoints.glogisfit'></span><span id='topic+fitted.breakpoints.glogisfit'></span><span id='topic+refit.breakpoints.glogisfit'></span><span id='topic+index.breakpoints.glogisfit'></span><span id='topic+confint.breakpoints.glogisfit'></span><span id='topic+breakdates.confint.breakpoints.glogisfit'></span><span id='topic+print.confint.breakpoints.glogisfit'></span><span id='topic+lines.confint.breakpoints.glogisfit'></span>

<h3>Description</h3>

<p>Fitting univariate generalized logisitc distributions (Type I: skew-logistic with
location, scale, and shape parameters) to segments of time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glogisfit'
breakpoints(obj, h = 0.15, breaks = NULL, ic = "LWZ",
  hpc = "none", ...)

## S3 method for class 'breakpoints.glogisfit'
refit(object, ...)

## S3 method for class 'breakpoints.glogisfit'
coef(object, log = TRUE, ...)

## S3 method for class 'breakpoints.glogisfit'
fitted(object, type = c("mean", "variance", "skewness"), ...)

## S3 method for class 'breakpoints.glogisfit'
confint(object, parm = NULL, level = 0.95, breaks = NULL, 
  meat. = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breakpoints.glogisfit_+3A_obj">obj</code></td>
<td>
<p>an object of class <code><a href="#topic+glogisfit">glogisfit</a></code>.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_h">h</code></td>
<td>
<p>numeric. Minimal segment size either given as fraction relative to the
sample size or as an integer giving the minimal number of observations
in each segment.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_breaks">breaks</code></td>
<td>
<p>integer specifying the maximal number of breaks to be calculated.
By default the maximal number allowed by <code>h</code> is used.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_ic">ic</code></td>
<td>
<p>character specifying the default information criterion that should
be employed for selecting the number of breakpoints. Default is <code>"LWZ"</code>
(Liu-Wu-Zidek criterion, a modified BIC). Instead the classic <code>"BIC"</code>
can be used.</p>
</td></tr>  
<tr><td><code id="breakpoints.glogisfit_+3A_hpc">hpc</code></td>
<td>
<p>a character specifying the high performance computing support.
Default is <code>"none"</code>, can be set to <code>"foreach"</code>.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_object">object</code></td>
<td>
<p>an object of class <code>breakpoints.glogisfit</code> as returned by
the <code><a href="strucchange.html#topic+breakpoints">breakpoints</a></code> method.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_log">log</code></td>
<td>
<p>logical option in <code>coef</code> method indicating whether scale and
shape parameters should be reported in logs (default) or the original
levels.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_type">type</code></td>
<td>
<p>character specifying which moments of the segmented fitted distribution
should be extracted.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_parm">parm</code></td>
<td>
<p>integer. Either <code>parm</code> or <code>breaks</code> may be set, see below.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_level">level</code></td>
<td>
<p>numeric. The confidence level to be used.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_meat.">meat.</code></td>
<td>
<p>function. A function for extracting the meat of a sandwich estimator
from a fitted object. By default, the inverse of <code><a href="sandwich.html#topic+bread">bread</a></code>
is used, i.e., a correctly specified model is assumed.</p>
</td></tr>
<tr><td><code id="breakpoints.glogisfit_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To test whether sequences (typically time series) of observations follow the same
generalized logistic distribution, the stability of the parameters can be tested.
If there is evidence for parameter instability, breakpoints can be estimated to
find segments with stable parameters.
</p>
<p>The methods from the <span class="pkg">strucchange</span> and <span class="pkg">fxregime</span> packages are leveraged.
For testing, the generalized M-fluctuation tests from <span class="pkg">strucchange</span> can directly
be employed using <code><a href="strucchange.html#topic+gefp">gefp</a></code>. For breakpoint estimation,
the methods documented here provide a user interface to some internal functionality
from the <span class="pkg">fxregime</span> packages. They employ the (unexported) workhorse function
<code>gbreakpoints</code> which is modeled after <code><a href="strucchange.html#topic+breakpoints">breakpoints</a></code> 
from the <span class="pkg">strucchange</span> package but employing user-defined estimation methods.
</p>
<p>Optional support for high performance computing is available in the <code>breakpoints</code>
method based on the <span class="pkg">foreach</span> package for the dynamic programming algorithm.
If <code>hpc = "foreach"</code> is to be used, a parallel backend should be registered
before. See <code><a href="strucchange.html#topic+breakpoints">breakpoints</a></code> for more information.
</p>


<h3>Value</h3>

<p><code>breakpoints.glogisfit</code> returns an object of class <code>"breakpoints.glogisfit"</code> that
inherits from <code>"gbreakpointsfull"</code>.
</p>


<h3>References</h3>

<p>Windberger T, Zeileis A (2014). Structural Breaks in Inflation Dynamics within the
European Monetary Union. <em>Eastern European Economics</em>, <b>52</b>(3), 66&ndash;88.
</p>
<p>Zeileis A, Shah A, Patnaik I (2010). Testing, Monitoring, and Dating Structural
Changes in Exchange Rate Regimes. <em>Computational Statistics and Data Analysis</em>,
<b>54</b>(6), 1696&ndash;1706. doi: <a href="https://doi.org/10.1016/j.csda.2009.12.005">10.1016/j.csda.2009.12.005</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glogisfit">glogisfit</a></code>, <code><a href="fxregime.html#topic+fxregimes">fxregimes</a></code>, <code><a href="strucchange.html#topic+breakpoints">breakpoints</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## artifical data with one structural change
set.seed(1071)
x &lt;- c(rglogis(50, -1, scale = 0.5, shape = 3), rglogis(50, 1, scale = 0.5, shape = 1))
x &lt;- zoo(x, yearmon(seq(2000, by = 1/12, length = 100)))

## full sample estimation
gf &lt;- glogisfit(x)

if(require("strucchange")) {

## structural change testing
gf_scus &lt;- gefp(gf, fit = NULL)
plot(gf_scus, aggregate = FALSE)
plot(gf_scus, functional = meanL2BB)
sctest(gf_scus)
sctest(gf_scus, functional = meanL2BB)


## breakpoint estimation
gf_bp &lt;- breakpoints(gf)
plot(gf_bp)
summary(gf_bp)
breakdates(gf_bp)
coef(gf_bp)
confint(gf_bp)

## fitted model
plot(x)
lines(gf_bp)
lines(fitted(gf_bp, type = "mean"), col = 4)
lines(confint(gf_bp))

}
</code></pre>

<hr>
<h2 id='glogis'>The Generalized Logistic Distribution (Type I: Skew-Logitic)</h2><span id='topic+dglogis'></span><span id='topic+pglogis'></span><span id='topic+qglogis'></span><span id='topic+rglogis'></span><span id='topic+sglogis'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the logistic distribution with parameters
<code>location</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dglogis(x, location = 0, scale = 1, shape = 1, log = FALSE)
pglogis(q, location = 0, scale = 1, shape = 1, lower.tail = TRUE, log.p = FALSE)
qglogis(p, location = 0, scale = 1, shape = 1, lower.tail = TRUE, log.p = FALSE)
rglogis(n, location = 0, scale = 1, shape = 1)
sglogis(x, location = 0, scale = 1, shape = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glogis_+3A_x">x</code>, <code id="glogis_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="glogis_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="glogis_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="glogis_+3A_location">location</code>, <code id="glogis_+3A_scale">scale</code>, <code id="glogis_+3A_shape">shape</code></td>
<td>
<p>location, scale, and shape parameters (see below).</p>
</td></tr>
<tr><td><code id="glogis_+3A_log">log</code>, <code id="glogis_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="glogis_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>location</code>, <code>scale</code>, or <code>shape</code> are omitted, they assume the
default values of <code>0</code>, <code>1</code>, and <code>1</code>, respectively.
</p>
<p>The generalized logistic distribution with <code>location</code> <code class="reqn">= \mu</code>,
<code>scale</code> <code class="reqn">= \sigma</code>, and <code>shape</code> <code class="reqn">= \gamma</code> has distribution function
</p>
<p style="text-align: center;"><code class="reqn">
    F(x) = \frac{1}{(1 + e^{-(x-\mu)/\sigma})^\gamma}%
  </code>
</p>
<p>.
</p>
<p>The mean is given by <code>location + (digamma(shape) - digamma(1)) * scale</code>, the variance by
<code>(psigamma(shape, deriv = 1) + psigamma(1, deriv = 1)) * scale^2)</code> and the skewness by
<code>(psigamma(shape, deriv = 2) - psigamma(1, deriv = 2)) / (psigamma(shape, deriv = 1) + psigamma(1, deriv = 1))^(3/2))</code>.
</p>
<p><code>[dpq]glogis</code> are calculated by leveraging the <code>[dpq]logis</code>
and adding the shape parameter. <code>rglogis</code> uses inversion.
</p>


<h3>Value</h3>

<p><code>dglogis</code> gives the probability density function,
<code>pglogis</code> gives the cumulative distribution function,
<code>qglogis</code> gives the quantile function, and
<code>rglogis</code> generates random deviates.
<code>sglogis</code> gives the score function (gradient of the log-density with
respect to the parameter vector).
</p>


<h3>References</h3>

<p>Johnson NL, Kotz S, Balakrishnan N (1995)
<em>Continuous Univariate Distributions</em>, volume 2.
John Wiley &amp; Sons, New York.
</p>
<p>Shao Q (2002). Maximum Likelihood Estimation for Generalised Logistic Distributions.
<em>Communications in Statistics &ndash; Theory and Methods</em>, <b>31</b>(10), 1687&ndash;1700.
</p>
<p>Windberger T, Zeileis A (2014). Structural Breaks in Inflation Dynamics within the
European Monetary Union. <em>Eastern European Economics</em>, <b>52</b>(3), 66&ndash;88.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PDF and CDF
par(mfrow = c(1, 2))
x &lt;- -100:100/10
plot(x, dglogis(x, shape = 2), type = "l", col = 4, main = "PDF", ylab = "f(x)")
lines(x, dglogis(x, shape = 1))
lines(x, dglogis(x, shape = 0.5), col = 2)
legend("topleft", c("generalized (0, 1, 2)", "standard (0, 1, 1)",
  "generalized (0, 1, 0.5)"), lty = 1, col = c(4, 1, 2), bty = "n")
plot(x, pglogis(x, shape = 2), type = "l", col = 4, main = "CDF", ylab = "F(x)")
lines(x, pglogis(x, shape = 1))
lines(x, pglogis(x, shape = 0.5), col = 2)

## artifical empirical example
set.seed(2)
x &lt;- rglogis(1000, -1, scale = 0.5, shape = 3)
gf &lt;- glogisfit(x)
plot(gf)
summary(gf)
</code></pre>

<hr>
<h2 id='glogisfit'>Fitting the Generalized Logistic Distribution</h2><span id='topic+glogisfit'></span><span id='topic+glogisfit.default'></span><span id='topic+glogisfit.formula'></span><span id='topic+bread.glogisfit'></span><span id='topic+coef.glogisfit'></span><span id='topic+estfun.glogisfit'></span><span id='topic+hist.glogisfit'></span><span id='topic+lines.glogisfit'></span><span id='topic+logLik.glogisfit'></span><span id='topic+plot.glogisfit'></span><span id='topic+print.glogisfit'></span><span id='topic+print.summary.glogisfit'></span><span id='topic+residuals.glogisfit'></span><span id='topic+summary.glogisfit'></span><span id='topic+vcov.glogisfit'></span>

<h3>Description</h3>

<p>Fit a univariate generalized logisitc distribution (Type I: skew-logistic with
location, scale, and shape parameters) to a sample of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glogisfit(x, ...)
## Default S3 method:
glogisfit(x, weights = NULL, start = NULL, fixed = c(NA, NA, NA),
  method = "BFGS", hessian = TRUE, ...)
## S3 method for class 'formula'
glogisfit(formula, data, subset, na.action, weights, x = TRUE, ...)

## S3 method for class 'glogisfit'
plot(x, main = "", xlab = NULL, fill = "lightgray",
  col = "blue", lwd = 1, lty = 1, xlim = NULL, ylim = NULL,
  legend = "topright", moments = FALSE, ...)

## S3 method for class 'glogisfit'
summary(object, log = TRUE, breaks = NULL, ...)
## S3 method for class 'glogisfit'
coef(object, log = TRUE, ...)
## S3 method for class 'glogisfit'
vcov(object, log = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glogisfit_+3A_x">x</code></td>
<td>
<p>a vector of observation (may be a <code><a href="stats.html#topic+ts">ts</a></code> or <code><a href="zoo.html#topic+zoo">zoo</a></code>
time series).</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_start">start</code></td>
<td>
<p>optional vector of starting values. The parametrization has to be
in terms of <code>location</code>, <code>log(scale)</code>, <code>log(shape)</code> where the
original parameters (without logs) are as in <code><a href="#topic+dglogis">dglogis</a></code>. Default
is to use <code>c(0, 0, 0)</code> (i.e., standard logistic). For details see below.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_fixed">fixed</code></td>
<td>
<p>specification of fixed parameters (see description of <code>start</code>).
<code>NA</code> signals that the corresponding parameter should be estimated.
A standard logistic distribution could thus be fitted via <code>fixed = c(NA, NA, 0)</code>.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_method">method</code></td>
<td>
<p>character string specifying optimization method, see <code><a href="stats.html#topic+optim">optim</a></code>
for the available options. Further options can be passed to <code>optim</code> through
<code>...</code>.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_hessian">hessian</code></td>
<td>
<p>logical. Should the Hessian be used to compute the variance/covariance
matrix? If <code>FALSE</code>, no covariances or standard errors will be available in
subsequent computations.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, currently only <code>x ~ 1</code> is
supported.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_data">data</code>, <code id="glogisfit_+3A_subset">subset</code>, <code id="glogisfit_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_main">main</code>, <code id="glogisfit_+3A_xlab">xlab</code>, <code id="glogisfit_+3A_fill">fill</code>, <code id="glogisfit_+3A_col">col</code>, <code id="glogisfit_+3A_lwd">lwd</code>, <code id="glogisfit_+3A_lty">lty</code>, <code id="glogisfit_+3A_xlim">xlim</code>, <code id="glogisfit_+3A_ylim">ylim</code></td>
<td>
<p>standard graphical parameters, see
<code><a href="graphics.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_legend">legend</code></td>
<td>
<p>logical or character specification where to place a legend.
<code>legend = FALSE</code> suppresses the legend.
See <code><a href="graphics.html#topic+legend">legend</a></code> for the character specification.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_moments">moments</code></td>
<td>
<p>logical. If a legend is produced, it can either show the parameter
estimates (<code>moments = FALSE</code>, default) or the implied moments of the
distribution.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_object">object</code></td>
<td>
<p>a fitted <code>glogisfit</code> object.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_log">log</code></td>
<td>
<p>logical option in some extractor methods indicating whether scale and
shape parameters should be reported in logs (default) or the original
levels.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_breaks">breaks</code></td>
<td>
<p>interval breaks for the chi-squared goodness-of-fit test.
Either a numeric vector of two or more cutpoints or a single number (greater than or
equal to 2) giving the number of intervals.</p>
</td></tr>
<tr><td><code id="glogisfit_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>glogisfit</code> estimates the generalized logistic distribution (Type I: skew-logistic)
as given by <code><a href="#topic+dglogis">dglogis</a></code>. Optimization is performed numerically by
<code><a href="stats.html#topic+optim">optim</a></code> using analytical gradients. For obtaining numerically more
stable results the scale and shape parameters are specified in logs. Starting values
are chosen as <code>c(0, 0, 0)</code>, i.e., corresponding to a standard (symmetric) logistic
distribution. If these fail, better starting values are obtained by running a Nelder-Mead
optimization on the original problem (without logs) first.  
</p>
<p>A large list of standard extractor methods is supplied to conveniently compute
with the fitted objects, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>
(reusing <code><a href="graphics.html#topic+hist">hist</a></code> and <code><a href="graphics.html#topic+lines">lines</a></code>), <code><a href="stats.html#topic+coef">coef</a></code>, 
<code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>,  <code><a href="stats.html#topic+residuals">residuals</a></code>,
and <code><a href="sandwich.html#topic+estfun">estfun</a></code> and
<code><a href="sandwich.html#topic+bread">bread</a></code> (from the <span class="pkg">sandwich</span> package).  
</p>
<p>The methods for <code>coef</code>, <code>vcov</code>, <code>summary</code>, and <code>bread</code> report computations
pertaining to the scale/shape parameters in logs by default, but allow for switching back to
the original levels (employing the delta method).
</p>
<p>Visualization employs a histogramm of the original data along with lines for the estimated
density.
</p>
<p>Further structural change methods for <code>"glogisfit"</code> objects are described in
<code><a href="#topic+breakpoints.glogisfit">breakpoints.glogisfit</a></code>.
</p>


<h3>Value</h3>

<p><code>glogisfit</code> returns an object of class <code>"glogisfit"</code>, i.e., a list with components as follows.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimated parameters from the model (with scale/shape in logs, if included),</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>associated estimated covariance matrix,</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>number of estimated parameters,</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights,</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights used (if any),</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>output from the <code>optim</code> call for maximizing the log-likelihood,</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method argument passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>the full set of model parameters (location/scale/shape), including
estimated and fixed parameters, all in original levels (without logs),</p>
</td></tr>
<tr><td><code>moments</code></td>
<td>
<p>associated mean/variance/skewness,</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>the starting values for the parameters passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>the original specification of fixed parameters,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call,</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the original data,</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical indicating successful convergence of <code>optim</code>,</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms objects for the model (if the <code>formula</code> method was used).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Shao Q (2002). Maximum Likelihood Estimation for Generalised Logistic Distributions.
<em>Communications in Statistics &ndash; Theory and Methods</em>, <b>31</b>(10), 1687&ndash;1700.
</p>
<p>Windberger T, Zeileis A (2014). Structural Breaks in Inflation Dynamics within the
European Monetary Union. <em>Eastern European Economics</em>, <b>52</b>(3), 66&ndash;88.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dglogis">dglogis</a></code>, <code><a href="stats.html#topic+dlogis">dlogis</a></code>, <code><a href="#topic+breakpoints.glogisfit">breakpoints.glogisfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple artificial example
set.seed(2)
x &lt;- rglogis(1000, -1, scale = 0.5, shape = 3)
gf &lt;- glogisfit(x)
plot(gf)
summary(gf)

## query parameters and associated moments
coef(gf)
coef(gf, log = FALSE)
gf$parameters
gf$moments
</code></pre>

<hr>
<h2 id='HICP'>Harmonised Index of Consumer Prices (1990&ndash;2010, OECD)</h2><span id='topic+HICP'></span><span id='topic+hicps'></span>

<h3>Description</h3>

<p>Time series data with HICP (Harmonised Index of Consumer Prices)
for 21 countries (plus EU) for 1990&ndash;2010 as provided by the OECD; and
corresponding seasonally adjusted inflation ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data("HICP")

  data("hicps")  
</code></pre>


<h3>Format</h3>

<p>Monthly multiple <code>"zooreg"</code> time series with <code>"yearmon"</code> index
from Jan 1990 (<code>HICP</code>) or Feb 1990 (<code>hicps</code>) to Dec 2010 for
21 countries (plus EU).
</p>


<h3>Details</h3>

<p><code>HICP</code> contains the raw unadjusted Harmonised Index of Consumer Prices
as provided by the OECD from which unadjusted inflation rates can be easily
computed (see examples).
</p>
<p>As the different countries have rather different seasonal patterns which
vary over time (especially in the 2000s), they will typically require seasonal
adjustment before modeling. Hence, a seasonally adjusted version of the
inflation rate series is provided as <code>hicps</code>, where X-12-ARIMA (version 0.3)
has been employed for adjusted. An alternative seasonal adjustment can be easily
computed use <code><a href="stats.html#topic+stl">stl</a></code> (see examples).
</p>


<h3>Source</h3>

<p>Organisation for Economic Co-operation and Development (OECD)
</p>
<p><a href="https://stats.oecd.org/">https://stats.oecd.org/</a>
</p>


<h3>References</h3>

<p>Wikipedia (2010). &quot;Harmonised Index of Consumer Prices &ndash; Wikipedia, The Free Encyclopedia.&quot;
<a href="https://en.wikipedia.org/wiki/Harmonised_Index_of_Consumer_Prices">https://en.wikipedia.org/wiki/Harmonised_Index_of_Consumer_Prices</a>, accessed 2010-06-10.
</p>
<p>Windberger T, Zeileis A (2014). Structural Breaks in Inflation Dynamics within the
European Monetary Union. <em>Eastern European Economics</em>, <b>52</b>(3), 66&ndash;88.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## price series
data("HICP", package = "glogis")

## corresponding raw unadjusted inflation rates (in percent)
hicp &lt;- 100 * diff(log(HICP))

## seasonal adjustment of inflation rates (via STL)
hicps1 &lt;- do.call("merge", lapply(1:ncol(hicp), function(i) {
  z &lt;- na.omit(hicp[,i])
  coredata(z) &lt;- coredata(as.ts(z) - stl(as.ts(z), s.window = 13)$time.series[, "seasonal"])
  z
}))
colnames(hicps1) &lt;- colnames(hicp)

## load X-12-ARIMA adjusted inflation rates
data("hicps", package = "glogis")

## compare graphically for one country (Austria)
plot(hicp[, "Austria"], lwd = 2, col = "lightgray")
lines(hicps1[, "Austria"], col = "red")
lines(hicps[, "Austria"], col = "blue")
legend("topleft", c("unadjusted", "STL", "X-12-ARIMA"), lty = c(1, 1, 1),
  col = c("lightgray", "red", "blue"), bty = "n")

## compare graphically across all countries (via lattice)
if(require("lattice")) {
trellis.par.set(theme = canonical.theme(color = FALSE))
xyplot(merge(hicp, hicps1, hicps), 
  screen = names(hicp)[rep(1:ncol(hicp), 3)],
  col = c("lightgray", "red", "blue")[rep(1:3, each = ncol(hicp))],
  lwd = c(2, 1, 1)[rep(1:3, each = ncol(hicp))])
}


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
