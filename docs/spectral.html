<!DOCTYPE html><html><head><title>Help for package spectral</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spectral}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onAttach'><p>Setting up multithread BLAS library</p></a></li>
<li><a href='#.onDetach'><p>Reset multithread BLAS to default</p></a></li>
<li><a href='#amax'><p>Local Maxima</p></a></li>
<li><a href='#analyticFunction'><p>Analytic function</p></a></li>
<li><a href='#BP'><p>Simple bandpass function</p></a></li>
<li><a href='#deconvolve'><p>Deconvolve Sampling Spectrum for Equidistant Sampling</p></a></li>
<li><a href='#envelope'><p>Calculates the envelope of a band limited signal</p></a></li>
<li><a href='#filter.fft'><p>Filter in the frequency domain</p></a></li>
<li><a href='#filter.lomb'><p>Filter and reconstruction of data analysed via spec.lomb</p></a></li>
<li><a href='#gLmb'><p>generalized Lomb-Scargle estimation function</p></a></li>
<li><a href='#H'><p>The Hilbert transformation</p></a></li>
<li><a href='#interpolate.fft'><p>interpolates data using the Fourier back transform</p></a></li>
<li><a href='#lmb'><p>Lomb-Scargle estimation function</p></a></li>
<li><a href='#plot.fft'><p>Plot <code>fft</code>-objects</p></a></li>
<li><a href='#plot.lomb'><p>plot method for Lomb-Scargle periodograms</p></a></li>
<li><a href='#print.fft'><p>FFT-Plotting Function</p></a></li>
<li><a href='#print.lomb'><p>Lomb-Plotting Function</p></a></li>
<li><a href='#spec.fft'><p>1D/2D/nD (multivariate) spectrum of the Fourier transform</p></a></li>
<li><a href='#spec.lomb'><p>Lomb-Scargle Periodigram</p></a></li>
<li><a href='#summary.fft'><p>Summarize FFT objects</p></a></li>
<li><a href='#summary.lomb'><p>Summarize Lomb objects</p></a></li>
<li><a href='#waterfall'><p>Estimate the local frequencies</p></a></li>
<li><a href='#win.cos'><p>Cosine window function</p></a></li>
<li><a href='#win.hann'><p>Hanning window function</p></a></li>
<li><a href='#win.nutt'><p>Nuttall window function</p></a></li>
<li><a href='#win.tukey'><p>Tukey window function</p></a></li>
<li><a href='#Windowfunctions'><p>Windowfunctions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Common Methods of Spectral Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Seilmayer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Seilmayer &lt;martin.seilmayer@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>On discrete data spectral analysis is performed by Fourier and Hilbert
    transforms as well as with model based analysis called Lomb-Scargle method.
    Fragmented and irregularly spaced data can be processed in almost all methods. Both,
    FFT as well as LOMB methods take multivariate data and return standardized PSD. 
    For didactic reasons an analytical approach for deconvolution of noise spectra and 
    sampling function is provided.
    A user friendly interface helps to interpret the results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>rasterImage,lattice,RhpcBLASctl,pbapply, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>FALSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-28 17:29:07 UTC; martinseilmayer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-29 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onAttach'>Setting up multithread BLAS library</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>The number of used cores is set to <code>RhpcBLASctl::get_num_cores()</code> on the
attach event of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>a character string giving the library directory where the package defining the namespace was found.</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>a character string giving the name of the package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algebra system of R relies on a BLAS library
which can be set to use many threads / cores. This
feature is considered as experimental since there are many differences across
the operating systems R is running on. If there is an issue and there is a need
to run R in multi-thread mode, consider to install
a different optimized version of BLAS.
If necessary, the number of cores required can also be changed manually
by calling <code>blas_set_num_threads(nCores)</code> and
<code>omp_set_num_threads(nCores)</code>.
</p>
<p>This function is invoked automatically
</p>

<hr>
<h2 id='.onDetach'>Reset multithread BLAS to default</h2><span id='topic+.onDetach'></span>

<h3>Description</h3>

<p>This function is invoked automatically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onDetach(libpath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onDetach_+3A_libpath">libpath</code></td>
<td>
<p>a character string giving the complete path to the package.</p>
</td></tr>
</table>

<hr>
<h2 id='amax'>Local Maxima</h2><span id='topic+amax'></span>

<h3>Description</h3>

<p>Determines all local maxima from a real valued vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amax(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amax_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose is to detect all local maxima in a real valued 1D vector.
If the first element <code>x[1]</code> is the global maximum, it is ignored,
because there is no information about the previous element. If there
is a plateau, the first edge is detected.
</p>


<h3>Value</h3>

<p>returns the indicies of local maxima. If <code>x[1] = max</code>, then
it is ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- c(1,2,3,2,1,5,5,4)
amax(a) # 3, 6
</code></pre>

<hr>
<h2 id='analyticFunction'>Analytic function</h2><span id='topic+analyticFunction'></span>

<h3>Description</h3>

<p>In general a causal real valued signal in time has negative
frequencies, when a Fourier transform is applied. To overcome this,
a complex complement can be calculated to compensate the negative
frequency spectrum. The result is called analytic signal or analytic
function, which provides a one sided spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyticFunction(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyticFunction_+3A_x">x</code></td>
<td>
<p>real valued data vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An analytic function <code class="reqn">xa</code> is composed of the real valued signal
representation <code class="reqn">y</code> and its Hilber transform <code class="reqn">H(y)</code> as the
complex complement </p>
<p style="text-align: center;"><code class="reqn">xa(t) = x(t)+i H(x(t))</code>
</p>
<p>.
In consequence, the analytic function has a one sided spectrum,
which is more natural. Calculating the discrete Fourier transform
of such a signal will give a complex vector, which is only non zero
until the half of the length. Every component higher than the half
of the sampling frequency is zero. Still, the analytic signal
and its spectrum are a unique representation of the original signal
<code class="reqn">x(t)</code>. The new properties enables us to do certain filtering
and calculations more efficient in the spectral space compared to the
standard FFT approach. Some examples are:
</p>

<dl>
<dt>Filtering</dt><dd><p>because the spectrum is one sided, the user must
only modifiy values in the lower half of the vector. This strongly
reduces mistakes in indexing.
See <code><a href="#topic+filter.fft">filter.fft</a></code></p>
</dd>
<dt>Envelope functions</dt><dd><p>Since the Hilbert transform is a perfect phase shifter
by pi/2, the envelope of a band limited signal can be calculated.
See <code><a href="#topic+envelope">envelope</a></code></p>
</dd>
<dt>Calculations</dt><dd><p>Deriving and integrating on band limited discrete data becomes
possible, without taking the symmetry of the discrete Fourier transform into
account. The secound example of the <code><a href="#topic+spec.fft">spec.fft</a></code> function calculates
the derivative as well, but plays with a centered spectrum and its corresponding
&quot;true&quot; negative frequencies</p>
</dd>
</dl>

<p>A slightly different approach on the analytic signal can be found in R. Hoffmann
&quot;Signalanalyse und -erkennung&quot; (Chap. 6.1.2). Here the signal <code class="reqn">x(t)</code> is split
into the even and odd part. According to Marko (1985) and Fritzsche (1995)
this two parts can be composed to the analytic signal, which lead to the
definition with the Hilbert transform above.
</p>


<h3>Value</h3>

<p>Complex valued analytic function
</p>


<h3>References</h3>

<p>R. Hoffmann, Signalanalyse und -erkennung: eine Einfuehrung fuer
Informationstechniker, Berlin; Heidelberg: Springer, 1998.
</p>
<p>H. Marko, Systemtheorie: Methoden und Anwendungen fuer ein- und mehrdimensionale
Systeme. 3. Aufl., Berlin: Springer, 1995.
</p>
<p>G. Fritzsche, Signale und Funktionaltransformationen - Informationselektronik.
Berlin: VEB Verlag Technik, 1985
</p>

<hr>
<h2 id='BP'>Simple bandpass function</h2><span id='topic+BP'></span>

<h3>Description</h3>

<p>This function represents a simple weightening procedure for spectral filtering accoring
to the type (<code>"poly", "sinc", "bi-cubic", "gauss"</code>) provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BP(f, fc, BW, n = 3, type = "poly")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BP_+3A_f">f</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code id="BP_+3A_fc">fc</code></td>
<td>
<p>center frequency</p>
</td></tr>
<tr><td><code id="BP_+3A_bw">BW</code></td>
<td>
<p>bandwidth, with <code>w[ abs(f - fc) &gt; BW ] == min</code></p>
</td></tr>
<tr><td><code id="BP_+3A_n">n</code></td>
<td>
<p>degree of the polynom, <code>n</code> can be real, e.g. <code>n = 1.6 as sinc alike</code></p>
</td></tr>
<tr><td><code id="BP_+3A_type">type</code></td>
<td>
<p>Type of weightening function: &quot;poly&quot;, &quot;sinc&quot;, &quot;bi-cubic&quot;, &quot;exp&quot;, can be abbreviated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The band pass is represented troughout a function in the form of four different types:
</p>
<p>1. polynominial function </p>
<p style="text-align: center;"><code class="reqn">w = 1 - |((f - fc) / BW)|^n </code>
</p>
<p> with the degree <code class="reqn">n</code>. The parameter <code class="reqn">fc</code>
controlls the center frequency and desired band width <code>BW</code>. Outside the band width
</p>
<p style="text-align: center;"><code class="reqn">|f - fc| &gt; BW</code>
</p>
<p> the result is forced to zero. With <code>n =  1.6</code> a quasi sinc-filter
without side bands can be constructed. A quasi rectangular window can be gained by setting
<code>n &gt; 5</code>.
</p>
<p>2. sinc function corresponds to a rectangular observation window in time domain
with </p>
<p style="text-align: center;"><code class="reqn">\Delta T ~ 1/BW</code>
</p>
<p>. It values ALL frequencies according to the si(x) function.
Calculation speed might be reduced.
</p>
<p>3. bi-cubic encounters 2nd order interpolation kernel, providing a quasi rectangular observation window.
</p>
<p>4. exponential Gauss curve. Here the band width is defined as the value of 90
</p>


<h3>Value</h3>

<p>This function returns a weight vector [0..1], which is to apply to the frequency
vector <code>f</code> in a top level function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- seq(-50,50,by = 1e-2)
fc &lt;- 0.3
BW &lt;- 0.75


par(mfrow = c(2,1))

curve(BP(x,fc = fc, BW = BW, type = "p"), -2,2, ylim = c(-0.2,1)
      ,main = "Filter weights"
      ,xlab = "fx",ylab = "w"
)
curve(BP(x,fc = fc, BW = BW, type = "s"), add = TRUE, lty = 2)
curve(BP(x,fc = fc, BW = BW, type = "b"), add = TRUE, lty = 3)
curve(BP(x,fc = fc, BW = BW, type = "g"), add = TRUE, lty = 4)

abline(v = c(fc,fc+BW,fc-BW), lty = 3, col = "grey")

# the corresponding Fourier-Transforms

ty &lt;- c("p","s","b","g")
A0 &lt;- integrate(BP,fc = fc, BW = BW, type = "s",lower = -2,upper = 2)$value

plot(NA,NA,xlab = "x", ylab = "|A|"
     ,main = "corresponding convolution kernels"
     ,xlim = 2*c(-1,1),ylim = c(0, sqrt(2)*A0/(length(f)*BW*min(diff(f))) )
)
for(i in 1:length(ty))
{
  FT &lt;- spec.fft(y = BP(f,fc,BW,type = ty[i]))
  lines(FT$fx * length(FT$fx) / diff(range(f)),Mod(FT$A),lty = i)

}
</code></pre>

<hr>
<h2 id='deconvolve'>Deconvolve Sampling Spectrum for Equidistant Sampling</h2><span id='topic+deconvolve'></span>

<h3>Description</h3>

<p>The function removes the probable alias
peaks in the power spectral density. These projections originate
from correlated gaps, missing values and interactions with noise.
The function should be considered as *experimental* but with didactic background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconvolve(x, y, SNR.enable = T, SNR.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconvolve_+3A_x">x</code></td>
<td>
<p>sampling instances</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_y">y</code></td>
<td>
<p>values</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_snr.enable">SNR.enable</code></td>
<td>
<p>binary value, include or exclude the noise</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_snr.level">SNR.level</code></td>
<td>
<p>theshold in the sense of a multiple of mean()
noise level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the special case of a non complete equidistant grid
containing the data and missing values (<code>NA</code>), this function
performs the deconvolution of <code>Y = fft(y)</code> from the
sampling spectrum of the aquisition series <code>x</code>. The data
is assumed to exist on a equidistant grid with missing values and
gaps.
</p>
<p>Given a one dimensional vector <code>y</code> of data this function reverses
the spectral convolution of <code class="reqn">Y = S * X + N</code>, if * describes the convolution
operation and <code class="reqn">Y = F(y)</code> denotes the discrete Fourier transform
via the operator <code class="reqn">F(.)</code>. If, the sampling series <code>x</code> is considered to be purely deterministic,
which should be the case for captured data, or the distortions
(missing values, gaps) are *correlated* (see example), then there exists an analytic inversion of
the convolution. Given the general definition of power spectral density
<code class="reqn">|Y|^2 = |S * X + N|^2</code> the challenge is to prove <code class="reqn">|S * X + N|^2 ~ |S|^2 * |X|^2 + |N|^2</code>.
Here <code class="reqn">N</code> describes a stochastic term of gaussian noise. This issue is
solved in correlation space, where convolution becomes a multiplitation. The
auto correlation function (acf) of <code class="reqn">y</code> is given by <code class="reqn">Ry = F(|Y|^2)</code>.
As a remark, IF we consider the special case of
equispaced sampling, modeled by the Diraq distribution <code class="reqn">\delta</code>(x),
it is easy to show that the correlation function of a product
is the product of individual correaltaion functions, <code class="reqn">F(|S*X|^2) = F(|S|^2) . F(|X|^2)</code>.
</p>
<p>The aim is, to approximate <code class="reqn">S</code> as the &quot;true&quot; spectrum. To the cost
of the phase information, the result is the standardized power spectral
density. The spectral noise term <code class="reqn">F(N)</code> is approximated by a theshold in
Fourier space. Here <code>SNR.level</code> sets the factor of <code>mean(fft(y))</code> below
which noise level is assumed. Above this value, the signal should be present.
As a parameter to play with, <code>SNR.enable</code> enables or disables the noise term.
This parameter was introduced to be consistent with present approaches,
not considering the presence of noise.
</p>


<h3>Value</h3>

<p>list of frequency <code>f</code> and spectral density function <code>S</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Deconvolution ###
#
#
# we define a test function with gaps and noise
# we show:
# - the aliased Fourier spectrum and for comparison Lomb Spectrum
# - the corrected spectrum
#

## definition of the sampling series
x &lt;- seq(0,pi/2,by = 5e-3)
n &lt;- rnorm(length(x),sd = 0.1)

## definition of the test function
## with 2 frequencies
yf &lt;- function(x)
{
  cos(2*pi*5.123*x) +
  cos(2*pi*17*x)
}

y &lt;- yf(x)
y &lt;- y - mean(y)

## define strongly correlated gaps
i &lt;- NULL

i &lt;- c(i,which(sin(2*pi / 0.3 * x) - 0.5 &gt; 0))
i &lt;- c(i,which(sin(2*pi / 0.04 * x + 1.123) - 0.5 &gt; 0))
i &lt;- sort(unique(i))


xs &lt;- x
ys &lt;- yf(xs) + n # add some noise
ys[i] &lt;- NA

## for comparison we calculate a Lomb-Spectrum
LT &lt;- spec.lomb(x = xs,y = ys
                ,f = seq(0,250,by = 0.02)
                ,mode = "generalized"
)

WS &lt;- deconvolve(x = xs, y = ys,SNR.enable = 1,SNR.level = 1)
FT &lt;- spec.fft(x = xs, y = ys,center = FALSE)
FTS &lt;- spec.fft(x = xs, y = is.na(ys),center = FALSE)
LTS &lt;- spec.lomb(x = xs, y = is.na(ys),f = seq(0,250,by = 0.02))

### results ###
#
# - signal spectrum (solid) dominant peaks at around f0 = {5, 17}
# - (minor) alias peaks (grey line, FFT dots) at f0 +/- fs
# - sampling spectrum (dashed) with fs = {3.3, 25} (dominant modes)
# - deconvolved spectrum (solid black) rejects the aliases and sampling
#
#

### time series

par(mfrow = c(1,1),mar = c(4,4,3,0.3))
curve(yf,0,max(x), col = "grey",n = 1000
      ,xlim = c(0,max(x)),ylim = c(-2,3)
      ,xlab = "Time", ylab = "y(t)"
      ,main = "Fragmented Time Series"
      )
points(xs,ys)
points(xs[is.na(ys)],yf(xs[is.na(ys)]),pch = 16,cex = 0.5)

legend("topright",c("y(t)","y(tn) + n(tn)","NA's")
       ,lty = c(1,NA,NA)
       ,lwd = c(1,NA,NA)
       ,pch = c(NA,1,16)
       ,col = c("darkgrey","black","black")
       ,bg = "white"
       ,cex = 0.8
)

## plot spectra
par(mfrow = c(1,1),mar = c(4,4,3,0.3))
with(FT,plot(fx,PSD,type="p",log = "x"
     # ,col="grey"
     ,xlim = c(1,100),ylim = c(1e-2,0.75)
     ,xlab = "f", ylab = "PSD"
     ,pch = 1
     ,lwd = 1
     ,main = "Spectra"
))
with(LT,lines(f,PSD,col = "grey",lwd = 4))
with(WS,lines(f,S, lwd = 2, col = "black"))
with(LTS,lines(f,PSD,lty = 2))
abline(h = c(1,0.5),lty = 3)
legend("topright",c("Fourier","Lomb","Decon.","Sampling")
       ,lty = c(NA,1,1,2)
       ,lwd = c(2,2,2,2)
       ,pch = c(1,NA,NA,NA)
       ,col = c("black","grey","black","black")
       ,bg = "white"
       ,cex = 0.8
       ,ncol = 2
)
</code></pre>

<hr>
<h2 id='envelope'>Calculates the envelope of a band limited signal</h2><span id='topic+envelope'></span>

<h3>Description</h3>

<p>The envelope of an amplitude modulated signal can be calculated by using the
Hilbert transform <code class="reqn">H(y)</code> of the signal or the analytic signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envelope(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope_+3A_y">y</code></td>
<td>
<p>numeric vector of the signal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An amplitude modulated function <code class="reqn">y(x) = A(x) * cos(\omega * x)</code> can be
demodulated as follows:
</p>
<p style="text-align: center;"><code class="reqn">A(x)^2 = y(x)^2 + H(y(x))^2</code>
</p>

<p>If the signal is not band limited, strange things can happen. See the ripple
at the edges in the example below. Pay attention, that the envelope is always
the real part of the returned value.
</p>


<h3>Value</h3>

<p>real valued envelope function of the signal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## noisy signal with amplitude modulation
x &lt;- seq(0,1, length.out=2e2)

# original data
y &lt;- (abs(x-0.5))*sin(20*2*pi*x)

ye &lt;- base::Re(envelope(y))

# plot results
plot(x,y,type="l",lwd=1,col="darkgrey",lty=2,ylab="y",main="Spectral filtering")
lines(x,ye)
legend("bottomright",c("modulated","envelope"),col=c("grey","black"),lty=c(2,1))
</code></pre>

<hr>
<h2 id='filter.fft'>Filter in the frequency domain</h2><span id='topic+filter.fft'></span>

<h3>Description</h3>

<p>This function provides a method to band pass filter in the frequency domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.fft(
  y = stop("y-value is missing"),
  x = NULL,
  fc = 0,
  BW = 0,
  n = 3,
  type = "poly"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.fft_+3A_y">y</code></td>
<td>
<p>numeric data vector</p>
</td></tr>
<tr><td><code id="filter.fft_+3A_x">x</code></td>
<td>
<p>optional x-coordinate</p>
</td></tr>
<tr><td><code id="filter.fft_+3A_fc">fc</code></td>
<td>
<p>center frequency of the bandpass</p>
</td></tr>
<tr><td><code id="filter.fft_+3A_bw">BW</code></td>
<td>
<p>bandwith of the bandpass</p>
</td></tr>
<tr><td><code id="filter.fft_+3A_n">n</code></td>
<td>
<p>parameter to control the stiffness of the bandpass</p>
</td></tr>
<tr><td><code id="filter.fft_+3A_type">type</code></td>
<td>
<p>type of weightening function: &quot;poly&quot;, &quot;sinc&quot;, &quot;bi-cubic&quot;,&quot;gauss&quot;, can be abbreviated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A signal <code class="reqn">y</code> is meant to be equaly spaced and causal, which means it starts
at <code class="reqn">t=0</code>. For times <code class="reqn">y &lt; 0</code> the signal is not defined. The filtering
itself takes place with the analytic function of <code class="reqn">y</code> which provides an one sided
spectrum. Applying the Fourier transform, all properties of <code class="reqn">y</code> will be
preserved.
</p>
<p>The band pass is represented throughout a function in the form of four different types, i.e.
&quot;polynom&quot;, &quot;sin(x)/x&quot;, &quot;bi-cubic&quot;, &quot;gauss&quot;. A detailed
description about these types can be found in <code><a href="#topic+BP">BP</a></code>.
</p>
<p>Setting <code>fc = 0</code> one can achieve a low pass filter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## noisy signal with amplitude modulation
x &lt;- seq(0,1, length.out=500)

# original data
y_org &lt;- (1+sin(2*2*pi*x))*sin(20*2*pi*x)

# overlay some noise
y_noise &lt;- y_org+rnorm(length(x),sd=0.2)

# filter the noisy data
y_filt &lt;- filter.fft(y_noise,x,fc=20,BW=4,n=50)

# plot results
plot(x,y_noise,type="l",lwd=1,col="darkgrey",lty=2,ylab="y",main="Spectral filtering")
lines(x,y_org,lwd=5,col="grey")
lines(x,y_filt)
legend("topright",c("org","noisy","filtered"),col=c("grey","darkgrey","black")
        ,lty=c(1,2,1),lwd=c(5,1,1))
</code></pre>

<hr>
<h2 id='filter.lomb'>Filter and reconstruction of data analysed via spec.lomb</h2><span id='topic+filter.lomb'></span>

<h3>Description</h3>

<p>Given an object of class <code>lomb</code>, this function allows the
reconstruction of the input signal using (a) a frequency selection
of single or multiple frequency (ranges), and/or (b) the most
significant peaks in the periodogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.lomb(
  l = stop("No Lomb-Data"),
  newx = NULL,
  threshold = 6,
  filt = NULL,
  phase = "nextnb"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.lomb_+3A_l">l</code></td>
<td>
<p>lomb object</p>
</td></tr>
<tr><td><code id="filter.lomb_+3A_newx">newx</code></td>
<td>
<p>vector of new values at which the restored function is to be evaluated</p>
</td></tr>
<tr><td><code id="filter.lomb_+3A_threshold">threshold</code></td>
<td>
<p>statistical threshold in terms of a standard deaviation of
the amplidudes. It determines which frequencies are used. Lower values give
more frequencies.</p>
</td></tr>
<tr><td><code id="filter.lomb_+3A_filt">filt</code></td>
<td>
<p>vector or matix of frequencies (ranges) in which to select the frequencies</p>
</td></tr>
<tr><td><code id="filter.lomb_+3A_phase">phase</code></td>
<td>
<p>set the method to determine the phase at a given frequency</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To properly reconstruct the signal out of the calculated
<code>lomb</code>-object, three different methods are available, which are
controlled by the <code>filt</code>-argument.
</p>

<ol>
<li><p> If <code>filt=NULL</code>, the most significant values in the (dense) spectrum
are used.
</p>
</li>
<li><p> If <code>filt=c(f1, .., fn)</code>, the given frequencies are used. The corresponding
phase is approximated.
</p>
</li>
<li><p> If <code>class(filt)=="matrix"</code>, each row of the 2 x n matrix defines a
frequency range. With in each range the &quot;significant&quot; frequencies are selected for
reconstruction.
</p>
</li></ol>

<p>Prior to the reconstruction the <code>filter.lomb</code>-function calculates the
most significant amplitudes and corresponding phases. As a measure to select
the &quot;correct&quot; frequencies, the <code>threshold</code> argument can be adjusted.
The corresponding phases of the underlying sine/cosine-waves are estimated by
one of the four following methods.
</p>

<ol>
<li> <p><code>phase=="nextnb"</code>... use the phase of the bin of nearest neighbour.
</p>
</li>
<li> <p><code>phase=="lin"</code>... linear interpolation between the two closest bins.
</p>
</li>
<li> <p><code>phase=="lockin"</code>... principle of lock-in amplification, also known as
quadrature-demodulation technique.
</p>
</li>
<li> <p><code>phase=="fit"</code>... non-linear least squares fit with <code>stats::nls</code>
</p>
</li></ol>



<h3>Value</h3>

<p>This function returns a list which contains the reconstruction according to the
<code>lomb</code>-object and <code>newx</code> for the given data <code>x</code> and <code>y</code>. The returned
object contains the following:
</p>

<dl>
<dt><code>x,y</code></dt><dd><p>reconstructed signal</p>
</dd>
<dt><code>f,A,phi</code></dt><dd><p>used parameters from the <code>lomb</code>-object</p>
</dd>
<dt><code>p</code></dt><dd><p>corresponding significance values</p>
</dd>
</dl>


<hr>
<h2 id='gLmb'>generalized Lomb-Scargle estimation function</h2><span id='topic+gLmb'></span>

<h3>Description</h3>

<p>calculates the generalized Lomb-Scargle estimation after Zechmeister et al. (2009)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gLmb(f, dat, w, Y, hYY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gLmb_+3A_f">f</code></td>
<td>
<p>frequency</p>
</td></tr>
<tr><td><code id="gLmb_+3A_dat">dat</code></td>
<td>
<p>spatial vector including locations and values</p>
</td></tr>
<tr><td><code id="gLmb_+3A_w">w</code></td>
<td>
<p>vector of weights</p>
</td></tr>
<tr><td><code id="gLmb_+3A_y">Y</code></td>
<td>
<p>weighted sum of values</p>
</td></tr>
<tr><td><code id="gLmb_+3A_hyy">hYY</code></td>
<td>
<p>weighted sum of squared values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is based on the generalized approach
</p>
<p><code class="reqn">y(t) = a*cos(w*t) + b*sin(w*t) + c</code>
</p>
<p>which contains the floating average value <code class="reqn">c</code> of the model function above.
The calculation is vectorized to enhance calculation
speed.
</p>

<hr>
<h2 id='H'>The Hilbert transformation</h2><span id='topic+H'></span>

<h3>Description</h3>

<p>The Hilbert transform is a phase shifter, which represents the complex complement
to a real vauled signal. It is calculated in the complex frequency space of the
signal by using the Fourier transform. Finally, calculating <code class="reqn">f = y + i*H(y)</code>
gives the analytic signal, with a one sided spectrum. (See <code><a href="#topic+analyticFunction">analyticFunction</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H_+3A_x">x</code></td>
<td>
<p>real valued time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric real valued vector is returned
</p>

<hr>
<h2 id='interpolate.fft'>interpolates data using the Fourier back transform</h2><span id='topic+interpolate.fft'></span>

<h3>Description</h3>

<p>There are two ways to interpolate data from a given spectrum.
Frist, one can do zero padding to cover <code>n</code> new data points. Or, secound
the complex amplitude with the associated frequency is taken and evaluated
at given points <code>xout</code>. Doing that for all frequencies and amplitudes
will give the interpolation. The result is compared to linear approximation
for didactic reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate.fft(y, x = NULL, n = NULL, xout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate.fft_+3A_y">y</code></td>
<td>
<p>numeric data vector to be interpolated</p>
</td></tr>
<tr><td><code id="interpolate.fft_+3A_x">x</code></td>
<td>
<p>numeric data vector with reference points</p>
</td></tr>
<tr><td><code id="interpolate.fft_+3A_n">n</code></td>
<td>
<p>number of new points</p>
</td></tr>
<tr><td><code id="interpolate.fft_+3A_xout">xout</code></td>
<td>
<p>a vector new points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a <code>x</code> and <code>y</code> component is returned. The <code>e99</code>
value evaluates the error of the interpolation with respect to linear approximation
with the <code>approx()</code> function.
</p>

<hr>
<h2 id='lmb'>Lomb-Scargle estimation function</h2><span id='topic+lmb'></span>

<h3>Description</h3>

<p>calculates the standard Lomb-Scargle estimation. The calculation is vectorized
to enhance calculation speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmb(f, dat, var_val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmb_+3A_f">f</code></td>
<td>
<p>frequency</p>
</td></tr>
<tr><td><code id="lmb_+3A_dat">dat</code></td>
<td>
<p>spatial vector including locations and values</p>
</td></tr>
<tr><td><code id="lmb_+3A_var_val">var_val</code></td>
<td>
<p>variance of the data</p>
</td></tr>
</table>

<hr>
<h2 id='plot.fft'>Plot <code>fft</code>-objects</h2><span id='topic+plot.fft'></span>

<h3>Description</h3>

<p>This is a wrapper function to plot <code>fft</code>-class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fft'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fft_+3A_x">x</code></td>
<td>
<p>Object of the class <code>fft</code></p>
</td></tr>
<tr><td><code id="plot.fft_+3A_...">...</code></td>
<td>
<p>further arguments to the plot functions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spec.fft">spec.fft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See spec.fft
</code></pre>

<hr>
<h2 id='plot.lomb'>plot method for Lomb-Scargle periodograms</h2><span id='topic+plot.lomb'></span>

<h3>Description</h3>

<p>This method plots a standard Lomb-Scargle periodogram, which contains the
normalized power spectra <code>PSD</code> and the corresponding false alarm
probability <code>p</code>. For more details refer to Zechmeister et al. (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lomb'
plot(
  x,
  FAPcol = 1,
  FAPlwd = 1,
  FAPlty = "dashed",
  FAPlim = c(1, 0.001),
  FAPlab = "FAP",
  legend.pos = "topleft",
  legend.cex = 1,
  legend.on = T,
  legend.text = c("Spectrum", "False Alarm Probability"),
  legend.lwd = NULL,
  legend.lty = NULL,
  legend.col = NULL,
  xlab = "Frequency",
  ylab = "Normalized PSD",
  main = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lomb_+3A_x">x</code></td>
<td>
<p>object of class <code>lomb</code></p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_fapcol">FAPcol</code></td>
<td>
<p>color of the FAP line</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_faplwd">FAPlwd</code></td>
<td>
<p>line width of the FAP line</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_faplty">FAPlty</code></td>
<td>
<p>line type for the FAP graph</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_faplim">FAPlim</code></td>
<td>
<p>limits to the FAP</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_faplab">FAPlab</code></td>
<td>
<p>label of the right vertical axis</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_legend.pos">legend.pos</code></td>
<td>
<p>position of the legend</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_legend.cex">legend.cex</code></td>
<td>
<p>cex value for the legend</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_legend.on">legend.on</code></td>
<td>
<p>logical, wheater to draw a legend or not</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_legend.text">legend.text</code></td>
<td>
<p>legend text</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_legend.lwd">legend.lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_legend.lty">legend.lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_legend.col">legend.col</code></td>
<td>
<p>color vector of the legend elements</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to a description of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to a description of <code>y</code>.</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_main">main</code></td>
<td>
<p>setting the title of the plot</p>
</td></tr>
<tr><td><code id="plot.lomb_+3A_...">...</code></td>
<td>
<p>further parameters to the plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.lomb</code> function is a wrapper function for R's standard scatter <code>plot</code>
To switch off certain properties, simply overwrite the parameter. For example
<code>log = ""</code> will reset the plot axis back to non-log scale.
</p>


<h3>References</h3>

<p>M. Zechmeister and M. Kurster, &quot;The generalised Lomb-Scargle periodogram.
A new formalism for the floating-mean and Keplerian periodograms&quot;,
Astronomy &amp; Astrophysics, 496(2), pp. 577&ndash;584, 2009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec.lomb">spec.lomb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See spec.lomb

</code></pre>

<hr>
<h2 id='print.fft'>FFT-Plotting Function</h2><span id='topic+print.fft'></span>

<h3>Description</h3>

<p>It calls the summary function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fft'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fft_+3A_x">x</code></td>
<td>
<p>lomb object</p>
</td></tr>
<tr><td><code id="print.fft_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see summary.lomb() function
</code></pre>

<hr>
<h2 id='print.lomb'>Lomb-Plotting Function</h2><span id='topic+print.lomb'></span>

<h3>Description</h3>

<p>It calls the summary function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lomb'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lomb_+3A_x">x</code></td>
<td>
<p>lomb object</p>
</td></tr>
<tr><td><code id="print.lomb_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see summary.lomb() function
</code></pre>

<hr>
<h2 id='spec.fft'>1D/2D/nD (multivariate) spectrum of the Fourier transform</h2><span id='topic+spec.fft'></span>

<h3>Description</h3>

<p>This function calculates the Fourier spectrum and power spectral density
of a given data object. The dimension of the array can be of arbitary size
e. g. 3D or 4D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec.fft(y = NULL, x = NULL, z = NULL, center = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec.fft_+3A_y">y</code></td>
<td>
<p>1D data vector, y coordinate of a 2D matrix, nD (even 2D) array
or object of class <code>fft</code></p>
</td></tr>
<tr><td><code id="spec.fft_+3A_x">x</code></td>
<td>
<p>x-coordinate of the data in <code>y</code> or <code>z</code>. If <code>y</code> is an array, <code>x</code> must be a named list <code>x = list(x = ..., y = ...)</code>.</p>
</td></tr>
<tr><td><code id="spec.fft_+3A_z">z</code></td>
<td>
<p>optional 2D matrix</p>
</td></tr>
<tr><td><code id="spec.fft_+3A_center">center</code></td>
<td>
<p>logical vector, indicating which axis to center in frequency space</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns an user friendly object, which contains as much frequency
vectors as ordinates of the array. <code>spec.fft</code> provides the
ability to center the spectrum along multiple axis. The amplitude output is already
normalized to the sample count and the frequencies are given in terms of
<code class="reqn">1/\Delta x</code>-units.
</p>


<h3>Value</h3>

<p>An object of the type <code>fft</code> is returned. It contains the
spectrum <code>A</code>, with &quot;reasonable&quot; frequency vectors along each ordinate. <code>psd</code> represents
the standardized power spectral density, [0,1]. The false alarm probability (FAP)
<code>p</code> is given similar to the Lomb-Scargle method, see <a href="#topic+spec.lomb">spec.lomb</a>.
</p>


<h3>Missing Values</h3>

<p>Given a regualar grid <code class="reqn">x_i = \delta x \cdot i</code> there might be missing values
marked with <code>NA</code>, which are treated by the function as 0's.
This &quot;zero-padding&quot; leads to a loss of signal energy being
roughly proportional to the number of missing values.
The correction factor is then <code class="reqn">(1 - Nna/N)</code> as long as <code class="reqn">Nna / N &lt; 0.2</code>.
If the locations of missing values are randomly
distributed the implemented procedure workes quite robust. If correalted
gaps are present, the proposed correction is faulty and
scales wrong. This is because a convolution of the incomplete
sampling vector with the the signal takes place. An aliasing effect
takes place distorting the spectral content.
</p>
<p>To be compatible with the underlying Fourier transform, the amplitudes
are not affected by this rescaling.
Only the power spectral density (PSD) is corrected in terms of the energy
content, which is experimental for the moment.
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.fft">plot.fft</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1D Example with two frequencies
#################################

x &lt;- seq(0, 1, length.out = 1e3)
y &lt;- sin(4 * 2 * pi * x) + 0.5 * sin(20 * 2 * pi * x)
FT &lt;- spec.fft(y, x)
par(mfrow = c(2, 1))
plot(x, y, type = "l", main = "Signal")
plot(
  FT,
  ylab = "Amplitude",
  xlab = "Frequency",
  type = "l",
  xlim = c(-30, 30),
  main = "Spectrum"
)
summary(FT)

# 2D example with a propagating wave
####################################

x &lt;- seq(0, 1, length.out = 50)
y &lt;- seq(0, 1, length.out = 50)

# calculate the data
m &lt;- matrix(0, length(x), length(y))
for (i in 1:length(x))
  for (j in 1:length(y))
    m[i, j] &lt;- sin(4 * 2 * pi * x[i] + 10 * 2 * pi * y[j])

# calculate the spectrum
FT &lt;- spec.fft(x = x, y = y, z = m)

# plot
par(mfrow = c(2, 1))
rasterImage2(x = x,
           y = y,
           z = m,
           main = "Propagating Wave")
plot(
  FT,
  main = "2D Spectrum",
  palette = "wb"
  ,
  xlim = c(-20, 20),
  ylim = c(-20, 20),
  zlim = c(0, 0.51)
  ,
  xlab = "fx",
  ylab = "fy",
  zlab = "A",
  ndz = 3,
  z.adj = c(0, 0.5)
  ,
  z.cex = 1
)
summary(FT)

# 3D example with a propagating wave
####################################

# sampling vector
x &lt;- list(x = seq(0,2,by = 0.1)[-1]
          ,y = seq(0,1, by = 0.1)[-1]
          ,z = seq(0,1, by = 0.1)[-1]
)

# initializing array
m &lt;- array(data = 0,dim = sapply(x, length))

for(i in 1:length(x$x))
  for(j in 1:length(x$y))
    for(k in 1:length(x$z))
      m[i,j,k] &lt;- cos(2*pi*(1*x$x[i] + 2*x$y[j] + 2*x$z[k])) + sin(2*pi*(1.5*x$x[i]))^2

FT &lt;- spec.fft(x = x, y = m, center = c(TRUE,TRUE,FALSE))

par(mfrow = c(2,2))
# plotting m = 0
rasterImage2( x = FT$fx
              ,y = FT$fy
              ,z = abs(FT$A[,,1])
              ,zlim = c(0,0.5)
              ,main="m = 0"
              )

# plotting m = 1
rasterImage2( x = FT$fx
              ,y = FT$fy
              ,z = abs(FT$A[,,2])
              ,zlim = c(0,0.5)
              ,main="m = 1"
)

# plotting m = 2
rasterImage2( x = FT$fx
              ,y = FT$fy
              ,z = abs(FT$A[,,3])
              ,zlim = c(0,0.5)
              ,main="m = 2"
)
rasterImage2( x = FT$fx
              ,y = FT$fy
              ,z = abs(FT$A[,,4])
              ,zlim = c(0,0.5)
              ,main="m = 3"
)

summary(FT)


# calculating the derivative with the help of FFT
################################################
#
# Remember, a signal has to be band limited.
# !!! You must use a window function !!!
#

# preparing the data
x &lt;- seq(-2, 2, length.out = 1e4)
dx &lt;- mean(diff(x))
y &lt;- win.tukey(x) * (-x ^ 3 + 3 * x)

# calcualting spectrum
FT &lt;- spec.fft(y = y, center = TRUE)
# calculating the first derivative
FT$A &lt;- FT$A * 2 * pi * 1i * FT$fx
# back transform
dm &lt;- spec.fft(FT)

# plot
par(mfrow=c(1,1))
plot(
  x,
  c(0, diff(y) / dx),
  type = "l",
  col = "grey",
  lty = 2,
  ylim = c(-4, 3)
)
# add some points to the line for the numerical result
points(approx(x, Re(dm$y) / dx, n = 100))
# analytical result
curve(-3 * x ^ 2 + 3,
      add = TRUE,
      lty = 3,
      n = length(x))

legend(
  "topright",
  c("analytic", "numeric", "spectral"),
  title = "diff",
  lty = c(3, 2, NA),
  pch = c(NA, NA, 1),
  col=c("black","grey","black")
)
title(expression(d / dx ~ (-x ^ 3 + 3 * x)))
</code></pre>

<hr>
<h2 id='spec.lomb'>Lomb-Scargle Periodigram</h2><span id='topic+spec.lomb'></span>

<h3>Description</h3>

<p>The Lomb-Scargle periodigram represents a statistical estimator for the
amplitude and phase at a given frequency. This function takes also multivariate
(n-dimensional) input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec.lomb(
  x = NULL,
  y = stop("Missing y-Value"),
  f = NULL,
  ofac = 1,
  w = NULL,
  mode = "normal",
  maxMem = 8,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec.lomb_+3A_x">x</code></td>
<td>
<p>sampling vector or data frame <code>data.frame(x1, x2, x3, ...)</code></p>
</td></tr>
<tr><td><code id="spec.lomb_+3A_y">y</code></td>
<td>
<p>input data vector or data frame <code>data.frame(x1, x2, ..., val)</code></p>
</td></tr>
<tr><td><code id="spec.lomb_+3A_f">f</code></td>
<td>
<p>optional frequency vector / data frame. If not supplied <code>f</code> is calculated.</p>
</td></tr>
<tr><td><code id="spec.lomb_+3A_ofac">ofac</code></td>
<td>
<p>in case <code>f=NULL</code> this value controlls the amount of frequency
oversampling.</p>
</td></tr>
<tr><td><code id="spec.lomb_+3A_w">w</code></td>
<td>
<p>weights for data. It must be a 1D vector.</p>
</td></tr>
<tr><td><code id="spec.lomb_+3A_mode">mode</code></td>
<td>
<p><code>"normal"</code> calculates the normal Lomb-Scargle periodogram;
<code>"generalized"</code> calculates the generalized Lomb-Scargle periodogram including
floating average and weights.</p>
</td></tr>
<tr><td><code id="spec.lomb_+3A_maxmem">maxMem</code></td>
<td>
<p>sets the amount of memory (in MB) to utilize, as a rough approximate.</p>
</td></tr>
<tr><td><code id="spec.lomb_+3A_cl">cl</code></td>
<td>
<p>if <code>numeric</code>, it defines the number of workers to use, or provides a cluster
definition of class <code>cluster</code> or <code>SocketCluster</code> from <code>parallel</code> package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the given time series does not need to be evenly sampled, the data
mainly consists of data pairs <code>x1, x2, x3, ...</code> (sampling points) and (one)
corresponding value <code>y</code>, which stores the realisation/measurement data.
As can be seen from the data definition above, multivariate (n-dimensional)
input data is allowed and properly processed.
</p>
<p>Two different methods are implemented: the standard Lomb-Scargle method with
</p>
<p><code class="reqn">y(t) = a * cos(\omega (t - \tau)) + b * sin(\omega (t - \tau))</code>
</p>
<p>as model function and the generalized Lomb-Scargle (after Zechmeister 2009)
method with
</p>
<p><code class="reqn">y(t) = a * cos(\omega t) + b * sin(\omega t) + c</code>
</p>
<p>as model function, which investigates a floating average parameter <code class="reqn">c</code>
as well.
</p>
<p>Both methods can be supplied by an artifical dense frequency vector <code>f</code>.
In conjunction with the resulting phase information the user might be able to
build a &quot;Fourier&quot;-like spectrum to reconstruct or interpolate the timeseries in equally
spaced sampling. Remind the band limitation which must be fulfilled for this.
</p>

<dl>
<dt>f</dt><dd><p>The frequencies should be stored in a 1D vector or &ndash; in case of
multivariate analysis &ndash; in a <code>data.frame</code> structure to preserve variable names</p>
</dd>
<dt><code>ofac</code></dt><dd><p>If the user does not provide a corresponding frequency
vector, the <code>ofac</code> parameter causes the function to estimate
</p>
<p style="text-align: center;"><code class="reqn">nf = ofac*length(x)/2</code>
</p>
<p> equidistant frequencies.</p>
</dd>
<dt><code>p</code>-value</dt><dd><p>The <code>p</code>-value (aka false alarm probability FAP)
gives the probability, wheter the estimated amplitude is NOT significant.
However, if <code>p</code> tends to zero the
amplidutde is significant. The user must decide which maximum value is acceptable,
until an amplitude is not valid.</p>
</dd>
</dl>

<p>If missing values <code>NA</code> or <code>NaN</code> appear in any column, the corresponding row
is excluded from calculation.
</p>


<h3>Value</h3>

<p>The <code>spec.lomb</code> function returns an object of the class <code>lomb</code>,
which is a <code>list</code> containg the following information:
</p>

<dl>
<dt><code>A</code></dt><dd><p>A vector with amplitude spectrum</p>
</dd>
<dt><code>f</code></dt><dd><p>corresponding frequency vector</p>
</dd>
<dt><code>phi</code></dt><dd><p>phase vector</p>
</dd>
<dt><code>PSD</code></dt><dd><p>power spectral density normalized to the sample variance</p>
</dd>
<dt><code>floatAvg</code></dt><dd><p>floating average value only in case of
<code>mode == "generalized"</code></p>
</dd>
<dt><code>w</code></dt><dd><p>if, <code>mode == "generalized"</code> contains the weighting vector</p>
</dd>
<dt><code>x,y</code></dt><dd><p>original data</p>
</dd>
<dt>p</dt><dd><p>p-value False Alarm Probability</p>
</dd>
</dl>



<h3>Speed Up</h3>

<p>In general the function calculates everything in a vectorized manner, which
speeds up the procedure. If the memory requirement is more than <code>maxMem</code>,
the calculation is split into chunks which fit in the memory (cache). Depending on the
problem size (number of frequencies and data size) a tuning of this value
enhances speed.
</p>
<p>Please consider to replpace the BLAS library by a multithreaded version. For example
<a href="https://prs.ism.ac.jp/~nakama/SurviveGotoBLAS2/binary/windows/x64/">https://prs.ism.ac.jp/~nakama/SurviveGotoBLAS2/binary/windows/x64/</a> is hosting
some Windows RBlas.dll files. Refer to <a href="https://mattstats.wordpress.com/2016/02/07/r-with-gotoblas-on-windows-10/">https://mattstats.wordpress.com/2016/02/07/r-with-gotoblas-on-windows-10/</a>
for further information.
</p>
<p>The parameter <code>cl</code> controls a possible cluster, which can be invoked. It takes an
integer number of workers (i. e. <code>cl = 4</code>), a list with node names <code>c("localhost",...)</code>
or an object of class <code>'cluster'</code> or similar. The first two options cause the
function to create the cluster internally. This takes time due to the initialization.
The faster way is to provide an already initialized cluster to the function.
</p>


<h3>References</h3>

<p>A. Mathias, F. Grond, R. Guardans, D. Seese, M. Canela, H. H. Diebner,
and G. Baiocchi, &quot;Algorithms for spectral analysis of irregularly sampled
time series&quot;, Journal of Statistical Software, 11(2), pp. 1&ndash;30, 2004.
</p>
<p>J. D. Scargle, &quot;Studies in astronomical time series analysis. II - Statistical
aspects of spectral analysis of unevenly spaced data&quot;, The Astrophysical Journal,
263, pp. 835&ndash;853, 1982.
</p>
<p>M. Zechmeister and M. Kurster, &quot;The generalised Lomb-Scargle periodogram.
A new formalism for the floating-mean and Keplerian periodograms&quot;,
Astronomy &amp; Astrophysics, 496(2), pp. 577&ndash;584, 2009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.lomb">filter.lomb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create two sin-functions
x_orig &lt;- seq(0,1,by=1e-2)
y_orig &lt;- 2*sin(10*2*pi*x_orig) + 1.5*sin(2*2*pi*x_orig)

# make a 10% gap
i &lt;- round(length(x_orig)*0.2) : round(length(x_orig)*0.3)
x &lt;- x_orig
y &lt;- y_orig
x[i] &lt;- NA
y[i] &lt;- NA


# calculating the lomb periodogram
l &lt;- spec.lomb(x = x, y = y,ofac = 20,mode = "normal")

# select a frequency range
m &lt;- rbind(c(9,11))
# select and reconstruct the most significant component
l2 = filter.lomb(l, x_orig, filt = m)

# plot everything
par(mfrow=c(2,1),mar = c(4,4,2,4))
plot(x,y,"l", main = "Gapped signal")
lines(l2$x, l2$y,lty=2)
legend("bottomleft",c("gapped","10Hz component"),lty=c(1,2))

plot(l,main = "Spectrum")

summary(l)

### Multivariate -- 3D Expample ###
require(lattice)
fx &lt;- 8.1
fy &lt;- 5
fz &lt;- 2

# creating frequency space
f &lt;- expand.grid( fx = seq(-10,10,by = 0.5)
                  ,fy = seq(-10,10,by = 0.5)
                  ,fz = 0:3
)

# creating spatial space
pts &lt;- expand.grid( x = seq(0,1,by = 0.02)
                   ,y = seq(0,1,by = 0.02)
                   ,z = seq(0,1,by = 0.02)
)

# gapping 30%
i &lt;- sample(1:dim(pts)[1],0.7*dim(pts)[1])
pts &lt;- pts[i,]

# caluculating function
pts$val &lt;- cos(2*pi*(  fx*pts$x
                     + fy*pts$y
                     + fz*pts$z
                    ) + pi/4
              ) +
  0.5 * cos(2*pi*(  - 0.5 * fx*pts$x
              + 0.5*fy*pts$y
              + 1 * pts$z
  ) + pi/4
  )

# display with lattice
levelplot(val~x+y,pts,subset = z == 0,main = "with z = 0")

# calculating lomb takes a while
# or we sample only a few points
# which enlarges the noise but accelerates the calculation
l &lt;- spec.lomb(y = pts[sample(1:dim(pts)[1],2e3),]
               ,f = f
               # ,mode = "generalized"
               )

# name the stripes
l$fz_lev &lt;- factor(x = paste("fz =",l$fz)
)

# display output
levelplot(PSD~fx+fy|fz_lev,l)

# the result is an oversampled spectrum of a non equidistant
# sampled function. We recognize a 3D analysis in all provided
# spatial directions x, y, z.

summary(l)
</code></pre>

<hr>
<h2 id='summary.fft'>Summarize FFT objects</h2><span id='topic+summary.fft'></span>

<h3>Description</h3>

<p>The function summarizes properties from the <code>class(fft)</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fft'
summary(object, p0 = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fft_+3A_object">object</code></td>
<td>
<p><code>lomb</code> object</p>
</td></tr>
<tr><td><code id="summary.fft_+3A_p0">p0</code></td>
<td>
<p>False Alarm Probability (FAP) threshold, default 1%</p>
</td></tr>
<tr><td><code id="summary.fft_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The false alarm probability threshold <code>p0</code> value can be
changed to modify the amount of significant peaks.
</p>


<h3>Value</h3>

<p>a list of significant values of the spectral analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see spec.fft() example

</code></pre>

<hr>
<h2 id='summary.lomb'>Summarize Lomb objects</h2><span id='topic+summary.lomb'></span>

<h3>Description</h3>

<p>The function summarizes properties from the Lomb object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lomb'
summary(object, p0 = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lomb_+3A_object">object</code></td>
<td>
<p><code>lomb</code> object</p>
</td></tr>
<tr><td><code id="summary.lomb_+3A_p0">p0</code></td>
<td>
<p>False Alarm Probability threshold, default 1%</p>
</td></tr>
<tr><td><code id="summary.lomb_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The false alarm probability threshold <code>p0</code> value will
adjust the number of peaks.
</p>
<p>The <code>effectiveBandWidth</code> describes the coverage of processed
frequencies by the <code>spec.lomb</code> function. If the ratio to
<code>averageSampling</code> is almost 2, then the Nyquist criterion can
be assumed to be fullfilled. If the ratio is much less than 2
then only a fraction of information is analysed.
</p>
<p>The <code>minFreqStep</code> is an estimate of the minimum frequency
step determined from the Lomb-Object.
</p>
<p>Average sampling is calculated from the median distance between
two spatial points.
</p>
<p>The possible frequency resolution originates also from the spatial
(temporal) input data by <code>1/(diff(range(x)))</code>, if <code>x</code> is
the spatial (temporal) coordinate.
</p>


<h3>Value</h3>

<p>a list of significant values of the spectral analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see spec.lomb() example
</code></pre>

<hr>
<h2 id='waterfall'>Estimate the local frequencies</h2><span id='topic+waterfall'></span>

<h3>Description</h3>

<p>A <code>waterfall</code>-diagramm displays the local frequency in dependence of
or spatial vector. One can then locate an event in time or space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waterfall(
  y = stop("y value is missing"),
  x = NULL,
  nf = 3,
  type = "b",
  width = 7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waterfall_+3A_y">y</code></td>
<td>
<p>numeric real valued data vector</p>
</td></tr>
<tr><td><code id="waterfall_+3A_x">x</code></td>
<td>
<p>numeric real valued spatial vector. (time or space)</p>
</td></tr>
<tr><td><code id="waterfall_+3A_nf">nf</code></td>
<td>
<p>steepness of the bandpass filter, degree of the polynomial.</p>
</td></tr>
<tr><td><code id="waterfall_+3A_type">type</code></td>
<td>
<p>type of weightening function: &quot;poly&quot;, &quot;sinc&quot;, &quot;bi-cubic&quot;,&quot;gauss&quot;, can be abbreviated</p>
</td></tr>
<tr><td><code id="waterfall_+3A_width">width</code></td>
<td>
<p>normalized maximum &quot;inverse&quot; width of the bandpass <code class="reqn">bw = fc/width</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each frequency is evaluated by calculating the amplitude demodulation, which
is equivalent to the envelope function of the band pass filtered signal.
The frequency of interest defines automatically the center frequency <code class="reqn">fc</code> of the
applied band pass with the bandwidth <code class="reqn">BW</code>:
</p>
<p style="text-align: center;"><code class="reqn">BW = fc / width, BW &lt; width -&gt; BW = width, BW &gt; width -&gt; BW = fc / width</code>
</p>

<p>The frequency is normalized so the minimal frequency is <code class="reqn">1</code>.
With increasing frequency the bandwidth becomes wider, which lead to a variable
resolution in space and frequency. This is comparable to the wavelet
(or Gabor) transform,
which scales the wavelet (window) according to the frequency.
However, the necessary bandwidth is changed by frequency to take the
uncertainty principle into account. Slow oscillating events are measured precisely
in frequency and fast changing processes can be determined more exact in space.
This means for a signal with steady
increasing frequency the <code>waterfall</code> function will produce a diagonally
stripe. See the examples below.
</p>


<h3>Value</h3>

<p>a special <code>fft</code>-object is returned. It has mode &quot;waterfall&quot; and
<code>x</code> and <code>fx</code> present, so it is only plotable.
</p>


<h3>Missing values</h3>

<p>Given a regualar grid <code class="reqn">x_i = \delta x \cdot i</code> there might be missing values
marked with <code>NA</code>, which are treated by the function as 0's.
This &quot;zero-padding&quot; leads to a loss of signal energy being
roughly proportional to the number of missing values.
The correction factor is then <code class="reqn">(1 - Nna/N)</code> as long as <code class="reqn">Nna / N &lt; 0.2</code>.
As long as the locations of missing values are randomly
distributed the implemented procedure workes quite robust. If, in any case,
the distribution becomes correlated the proposed correction is faulty and
projects the wrong energies.
</p>
<p>The amplitudes and PSD values are compensated to show up an estimate of the
&quot;correct&quot; value. Therefore this method is experimental
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### noisy signal with amplitude modulation ####
x &lt;- seq(0,3, length.out = 1000)
# original data
# extended example from envelope function
y &lt;- 1*(abs(x-1.5))*sin(10*2*pi*x) + ifelse(x &gt; 1.5,sin(15*(1+0.25*(x - 1.5))*2*pi*x),0)
ye &lt;- base::Re(envelope(y))

par(mfrow=c(2,1),mar=c(1,3.5,3,3),mgp=c(2.5,1,0))

# plot results
plot(x,y,type="l",lwd=1,col="darkgrey",lty=2,ylab="y",main="Original Data",xaxt="n",xlab="")
lines(x,ye)
legend("bottomright",c("modulated","envelope"),col=c("grey","black"),lty=c(2,1))

par(mar=c(3.5,3.5,2,0))
wf &lt;- waterfall(y,x,nf = 3)
# rasterImage2(x = wf$x, y = wf$fx, z = wf$A
#              ,ylim = c(0,60))

plot(wf,ylim=c(0,40),main="Waterfall")


#### uncertainty principle ####
#
# take a look at the side effects
# at [0,30] and [1,0]
#
# With a large steepness e.g. n = 50 you will gain
# artefacts.
#
# if frequency is not stationary
# PSD becomes &gt; 1 depending on the type of band filter.
#
###############################
x &lt;- seq(0,1, length.out=1500)
y &lt;- sin(100*x*x)

FT &lt;- spec.fft(x = x, y = y)
wf &lt;- waterfall(y,x)

par(mfrow=c(2,1),mar=c(1,3.5,3,3),mgp=c(2.5,1,0))
# plot results
plot(x,y,type="l",lwd=1,col="darkgrey",lty=2,ylab="y",main="Original Data",xaxt="n",xlab="")

par(mar=c(3.5,3.5,2,0))
plot(wf
             ,ylim=c(0,40),main="Waterfall"
             )
abline(h = 25, lty = 3, lwd = 3, col = "grey")
range(wf$PSD,na.rm = TRUE)
range(wf$A)

###### effect of missing values #####
#
# 10% random missing values cause a
# distortion and a miss scaling of
# the PSD value, which becomes &gt;1 now.
# This depends on the type of band pass
# filter selected.
#
#####################################
x &lt;- seq(0,5, length.out=500)
y &lt;- sin(2*pi * 15 * x + 2*1*cos(2*pi*0.5*x))

# delete 10% of the data
y[sample(length(y),size = 50)] &lt;- NA

wf &lt;- waterfall(y,x,type = "b")

par(mfrow=c(2,1),mar=c(1,3.5,3,3),mgp=c(2.5,1,0))
# plot results
plot(x,y,type="l",lwd=1,col="darkgrey",lty=2,ylab="y",main="Original Data",xaxt="n",xlab="")

par(mar=c(3.5,3.5,2,0))
plot(wf
     ,ylim=c(10,20),main="Waterfall"
)
abline(h = 25, lty = 3, lwd = 3, col = "grey")

# check the PSD range
range(wf$PSD)
range(wf$A)
</code></pre>

<hr>
<h2 id='win.cos'>Cosine window function</h2><span id='topic+win.cos'></span>

<h3>Description</h3>

<p>This window function returns a vector of weights with means of a cosine window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win.cos(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="win.cos_+3A_n">n</code></td>
<td>
<p>data vector to be windowed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Windowfunctions">Windowfunctions</a></code>
</p>

<hr>
<h2 id='win.hann'>Hanning window function</h2><span id='topic+win.hann'></span>

<h3>Description</h3>

<p>This window function returns a vector of weights with means of a
generlized Hann-window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win.hann(n, a = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="win.hann_+3A_n">n</code></td>
<td>
<p>data vector to be windowed</p>
</td></tr>
<tr><td><code id="win.hann_+3A_a">a</code></td>
<td>
<p>order of the window, default <code>a = 2</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Windowfunctions">Windowfunctions</a></code>
</p>

<hr>
<h2 id='win.nutt'>Nuttall window function</h2><span id='topic+win.nutt'></span>

<h3>Description</h3>

<p>This window function returns a vector of weights with means of a
Nuttall-window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win.nutt(n, a = c(0.355768, 0.487396, 0.144232, 0.012604, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="win.nutt_+3A_n">n</code></td>
<td>
<p>data vector to be windowed</p>
</td></tr>
<tr><td><code id="win.nutt_+3A_a">a</code></td>
<td>
<p>coefficients default <code>a = c(0.355768, 0.487396, 0.144232, 0.012604,0)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This window function provides a continuous first derivative everywhere,
like the Hann window. Adopted from the idea of Hann this window consists of
up to 5 trigonometric polynominial terms, i.e.
</p>
<p style="text-align: center;"><code class="reqn">w_{n} = a_1 - a_2  \cos(2\pi n/M) + a_3  \cos(4\pi n/M) - a_4 \cos(6\pi n/M)
              + a_5 \cos(8\pi n/M) </code>
</p>

<p>Different sets of coefficients:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>Nuttall(Default)</strong> </td><td style="text-align: left;">  <code>c(0.355768, 0.487396, 0.144232, 0.012604,0)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <strong>Blackman-Nuttall</strong> </td><td style="text-align: left;">  <code>c(0.3635819, 0.4891775, 0.1365995, 0.0106411,0)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <strong>Blackman-Harris</strong>  </td><td style="text-align: left;">  <code>c(0.35875, 0.48829, 0.14128, 0.01168,0)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <strong>Flat-Top</strong>         </td><td style="text-align: left;">  <code>c(0.211557895, 0.41663158, 0.277263158, 0.083578947, 0.006947368)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+Windowfunctions">Windowfunctions</a></code>
</p>

<hr>
<h2 id='win.tukey'>Tukey window function</h2><span id='topic+win.tukey'></span>

<h3>Description</h3>

<p>This window function returns a vector of weights with means of a
Tukey-window. In contrast to a cosine window this function is more steep
at the beginning and the end. And it is 1 in the middle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win.tukey(n, a = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="win.tukey_+3A_n">n</code></td>
<td>
<p>data vector to be windowed</p>
</td></tr>
<tr><td><code id="win.tukey_+3A_a">a</code></td>
<td>
<p>width of the rising and falling edge as ratio of the total data length</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Windowfunctions">Windowfunctions</a></code>
</p>

<hr>
<h2 id='Windowfunctions'>Windowfunctions</h2><span id='topic+Windowfunctions'></span>

<h3>Description</h3>

<p>Some typical windowfunctions are defined below:
</p>


<h3>Details</h3>


<dl>
<dt><code>win.cos()</code></dt><dd><p>cosine window</p>
</dd>
<dt><code>win.tukey()</code></dt><dd><p>Tukey window</p>
</dd>
<dt><code>win.hann()</code></dt><dd><p>Hann window</p>
</dd>
<dt><code>win.nutt()</code></dt><dd><p>Nutt window</p>
</dd>
</dl>

<p>A window function weights a given dataset in a way, that the new data set is
coerced to be periodic. This method reduces the leakage effects of the
discrete Fourier transform.
</p>


<h3>Value</h3>

<p>All window functions return a wighting vector with the same length
as the provided data vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- 1:100
y_cos &lt;- y * win.cos(y)
y_tuk &lt;- y * win.tukey(y)
y_han &lt;- y * win.hann(y)

# Plot the original data
plot(y,main="Effect of window functions")
legend("topleft",c("original","cos","tukey","han"),pch=c(1,16,17,18))
points(y_cos,pch=16)
points(y_tuk,pch=17)
points(y_han,pch=18)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
