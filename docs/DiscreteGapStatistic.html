<!DOCTYPE html><html lang="en"><head><title>Help for package DiscreteGapStatistic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiscreteGapStatistic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BhattacharyyaDist'><p>Bhattacharyya distance</p></a></li>
<li><a href='#ChisqDist'><p>Chi-square distance</p></a></li>
<li><a href='#clusGapDiscr'><p>Discrete application of clusGap</p></a></li>
<li><a href='#clusGapDiscr0'><p>Discrete application of clusGap - core function.</p></a></li>
<li><a href='#clusterFunSel'><p>Clustering generating function</p></a></li>
<li><a href='#concussion'><p>Concussion Data</p></a></li>
<li><a href='#cramersVmod'><p>Cramer's V modified pairwise vector function based on the function found in lsr package</p></a></li>
<li><a href='#CramerV'><p>Cramer's V distance</p></a></li>
<li><a href='#dissbhattacharyya'><p>Bhattacharyya's distance (wrapper)</p></a></li>
<li><a href='#disschisquare'><p>Chi-square distance (wrapper)</p></a></li>
<li><a href='#disscramerv'><p>Cramer's V distance (wrapper)</p></a></li>
<li><a href='#disshamming'><p>Hamming distance wrapper function</p></a></li>
<li><a href='#disshellinger'><p>Hellinger distance (wrapper)</p></a></li>
<li><a href='#distanceHeat'><p>Sample-to-sample heatmap</p></a></li>
<li><a href='#distancematrix'><p>Calculate categorical distance matrix for discrete data</p></a></li>
<li><a href='#findK'><p>Criteria to determine number of clusters k</p></a></li>
<li><a href='#HellingerDist'><p>Hellinger distance</p></a></li>
<li><a href='#kmodesD'><p>Adapted k-modes algorithm</p></a></li>
<li><a href='#likert.heat.plot2'><p>Summary Heatmap for categorical data</p></a></li>
<li><a href='#mass'><p>mass data</p></a></li>
<li><a href='#ResHeatmap'><p>Discrete Data Heatmap</p></a></li>
<li><a href='#SimData'><p>Simulate Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An Extension of the Gap Statistic for Ordinal/Categorical Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The gap statistic approach is extended to estimate the number of clusters for categorical response format data. This approach and accompanying software is designed to be used with the output of any clustering algorithm and with distances specifically designed for categorical (i.e. multiple choice) or ordinal survey response data.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ecortesgomez/DiscreteGapStatistic">https://github.com/ecortesgomez/DiscreteGapStatistic</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>cultevo, magrittr, utils, ggplot2, pheatmap, dplyr,
Polychrome, RColorBrewer, reshape2, tidyr, ComplexHeatmap,
cluster, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>kableExtra, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-06 03:14:05 UTC; ED33454</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey Miecznikowski [aut],
  Eduardo Cortes <a href="https://orcid.org/0000-0002-0966-6488"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo Cortes &lt;ecortesg@buffalo.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-06 03:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BhattacharyyaDist'>Bhattacharyya distance</h2><span id='topic+BhattacharyyaDist'></span>

<h3>Description</h3>

<p>Bhattacharyya distance core function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BhattacharyyaDist(x, adj = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BhattacharyyaDist_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="BhattacharyyaDist_+3A_adj">adj</code></td>
<td>
<p>Small quantity added to avoid indefinite log(0) values. DEFAULT=0.001</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance R object
</p>

<hr>
<h2 id='ChisqDist'>Chi-square distance</h2><span id='topic+ChisqDist'></span>

<h3>Description</h3>

<p>Chi-square distance core function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChisqDist(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ChisqDist_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance R object
</p>

<hr>
<h2 id='clusGapDiscr'>Discrete application of clusGap</h2><span id='topic+clusGapDiscr'></span>

<h3>Description</h3>

<p>Based on the implementation of the function found in the 'cluster' R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusGapDiscr(
  x,
  clusterFUN,
  K.max,
  B = nrow(x),
  value.range = "DS",
  verbose = interactive(),
  distName = "hamming",
  useLog = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusGapDiscr_+3A_x">x</code></td>
<td>
<p>A matrix object specifying category attributes in the columns and observations in the rows.</p>
</td></tr>
<tr><td><code id="clusGapDiscr_+3A_clusterfun">clusterFUN</code></td>
<td>
<p>Character string with one of the available clustering implementations.
Available options are: 'pam' (default) from &lsquo;cluster::pam', &rsquo;diana' from &lsquo;cluster::diana', &rsquo;fanny' from 'cluster::fanny',
'agnes-{average, single, complete, ward, weighted}' from 'cluster::fanny',
'hclust-{ward.D, ward.D2, single, complete, average, mcquitty, median, centroid}' from 'stats::hclust',
'kmodes' from 'klar::kmodes' ('iter.max = 10', 'weighted = FALSE' and 'fast= TRUE').
'kmodes-N' enables to run the 'kmodes' algorithm with a given number N of iterations where 'iter.max = N'.</p>
</td></tr>
<tr><td><code id="clusGapDiscr_+3A_k.max">K.max</code></td>
<td>
<p>Integer. Maximum number of clusters 'k' to consider</p>
</td></tr>
<tr><td><code id="clusGapDiscr_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. By default B = nrow(x).</p>
</td></tr>
<tr><td><code id="clusGapDiscr_+3A_value.range">value.range</code></td>
<td>
<p>String character vector or a list of character vector with the length matching the number of columns (nQ) of the array.
A vector with all categories to consider when bootstrapping the null distribution sample (KS: Known Support option).
By DEFAULT vals=NULL, meaning unique range of categories found in the data will be used when drawing the null (DS: Data Support option).
If a character vector of categories is provided, these values would be used for the null distribution drawing across the array.
If a list with category character vectors is provided, it has to have the same number of columns as the input array. The order of list element corresponds to the array's columns.</p>
</td></tr>
<tr><td><code id="clusGapDiscr_+3A_verbose">verbose</code></td>
<td>
<p>Integer or logical. Determines whether progress output should printed while running. By DEFAULT one bit is printed per bootstrap sample.</p>
</td></tr>
<tr><td><code id="clusGapDiscr_+3A_distname">distName</code></td>
<td>
<p>String. Name of categorical distance to apply.
Available distances: 'bhattacharyya', 'chisquare', 'cramerV', 'hamming' and 'hellinger'.</p>
</td></tr>
<tr><td><code id="clusGapDiscr_+3A_uselog">useLog</code></td>
<td>
<p>Logical. Use log function after estimating 'W.k'. Following the original formulation 'useLog=TRUE' by default.</p>
</td></tr>
<tr><td><code id="clusGapDiscr_+3A_...">...</code></td>
<td>
<p>optionally further arguments for 'FUNcluster()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with K.max rows and 4 columns, named &quot;logW&quot;, &quot;E.logW&quot;, &quot;gap&quot;, and &quot;SE.sim&quot;,
where gap = E.logW - logW, and SE.sim correspond to the standard error of 'gap'.
</p>

<hr>
<h2 id='clusGapDiscr0'>Discrete application of clusGap - core function.</h2><span id='topic+clusGapDiscr0'></span>

<h3>Description</h3>

<p>Based on the implementation of the function found in the 'cluster' R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusGapDiscr0(
  x,
  FUNcluster,
  K.max,
  B = nrow(x),
  value.range = "DS",
  verbose = interactive(),
  distName = "hamming",
  useLog = TRUE,
  Input2Alg = "distMatr",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusGapDiscr0_+3A_x">x</code></td>
<td>
<p>A matrix object specifying category attributes in the columns and observations in the rows.</p>
</td></tr>
<tr><td><code id="clusGapDiscr0_+3A_funcluster">FUNcluster</code></td>
<td>
<p>a function that accepts as first argument a matrix like 'x'; second argument specifies number of 'k' (k=&gt;2) clusters
This function should return a list with a component named 'cluster', a vector of length 'n=nrow(x)' of integers from '1:k' indicating observation cluster assignment.
Make sure 'FUNcluster' and 'Input2Alg' agree.</p>
</td></tr>
<tr><td><code id="clusGapDiscr0_+3A_k.max">K.max</code></td>
<td>
<p>Integer. Maximum number of clusters 'k' to consider</p>
</td></tr>
<tr><td><code id="clusGapDiscr0_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. By default B = nrow(x).</p>
</td></tr>
<tr><td><code id="clusGapDiscr0_+3A_value.range">value.range</code></td>
<td>
<p>String, character vector or a list of character vectors with the length matching the number of columns (nQ) of the array.
A vector with all categories to consider when bootstrapping the null distribution sample (KS: Known Support option).
By DEFAULT vals=NULL, meaning unique range of categories found in the data will be used when drawing the null (DS: Data Support option).
If a character vector of categories is provided, these values would be used for the null distribution drawing across the array.
If a list with category character vectors is provided, it has to have the same number of columns as the input array. The order of list element corresponds to the array's columns.</p>
</td></tr>
<tr><td><code id="clusGapDiscr0_+3A_verbose">verbose</code></td>
<td>
<p>Integer or logical. Determines whether progress output should printed while running. By DEFAULT one bit is printed per bootstrap sample.</p>
</td></tr>
<tr><td><code id="clusGapDiscr0_+3A_distname">distName</code></td>
<td>
<p>String. Name of categorical distance to apply.
Available distances: 'bhattacharyya', 'chisquare', 'cramerV', 'hamming' and 'hellinger'.</p>
</td></tr>
<tr><td><code id="clusGapDiscr0_+3A_uselog">useLog</code></td>
<td>
<p>Logical. Use log function after estimating 'W.k'. Following the original formulation 'useLog=TRUE' by default.</p>
</td></tr>
<tr><td><code id="clusGapDiscr0_+3A_input2alg">Input2Alg</code></td>
<td>
<p>Specifies the kind of input provided to the algorithm function in 'FUNcluster'.
For algorithms that only accept a distance matrix use ''distMatr'' option (default).
For algorithms that require the dataset and a prespecified distance function (e.g. &lsquo;stats::dist') use the '&rsquo;distFun'' option.
This case the distance function is defined internally and determined by parameter 'distName'.</p>
</td></tr>
<tr><td><code id="clusGapDiscr0_+3A_...">...</code></td>
<td>
<p>optionally further arguments for 'FUNcluster()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with K.max rows and 4 columns, named &quot;logW&quot;, &quot;E.logW&quot;, &quot;gap&quot;, and &quot;SE.sim&quot;,
where gap = E.logW - logW, and SE.sim correspond to the standard error of 'gap'.
</p>

<hr>
<h2 id='clusterFunSel'>Clustering generating function</h2><span id='topic+clusterFunSel'></span>

<h3>Description</h3>

<p>A function that generates formatted algorithmic functions that can be plugged
to enable run a wide variety of clustering algorithm for 'clusGapDiscr' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterFunSel(clustFun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterFunSel_+3A_clustfun">clustFun</code></td>
<td>
<p>A character string with the following possible options:
'pam' (default) from &lsquo;cluster::pam', &rsquo;diana' from &lsquo;cluster::diana', &rsquo;fanny' from 'cluster::fanny',
'agnes-{average, single, complete, ward, weighted}' from 'cluster::agnes',
'hclust-{ward.D, ward.D2, single, complete, average, mcquitty, median, centroid}' from 'base::hclust',
'kmodes' from 'klar::kmodes' ('iter.max = 10', 'weighted = FALSE' and 'fast= TRUE').
'kmodes-N' enables to run the 'kmodes' algorithm with a given number N of iterations where 'iter.max = N'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class kmodes as found in 'klaR' packages.
An additional component specifies the categorical distance function found in 'distFun'.
</p>

<hr>
<h2 id='concussion'>Concussion Data</h2><span id='topic+concussion'></span>

<h3>Description</h3>

<p>A data frame with 109 observations and 21 questions.
Severity rating recorded as categorical responses from c1 (none) to c7 (severe).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concussion
</code></pre>


<h3>Format</h3>

<p>## 'data.frame'
</p>

<dl>
<dt>Q1: Headache</dt><dd><p>Headache</p>
</dd>
<dt>Q2: Nausea</dt><dd><p>Nausea</p>
</dd>
<dt>Q3: Balance problems</dt><dd><p>Balance problems</p>
</dd>
<dt>Q4: Dizziness</dt><dd><p>Dizziness</p>
</dd>
<dt>Q5: Fatigue</dt><dd><p>Fatigue</p>
</dd>
<dt>Q6: Sleep more</dt><dd><p>Sleeping more than usual</p>
</dd>
<dt>Q7: Drowsiness</dt><dd><p>Drowsiness</p>
</dd>
<dt>Q8: Sensibility to light</dt><dd><p>Sensibility to light</p>
</dd>
<dt>Q9: Sensibility to noice</dt><dd><p>Sensibility to noice</p>
</dd>
<dt>Q10: Irritability</dt><dd><p>Irritability</p>
</dd>
<dt>Q11: Sadness</dt><dd><p>Sadness</p>
</dd>
<dt>Q12: Nervousness</dt><dd><p>Nervousness/Anxiousness</p>
</dd>
<dt>Q13: More emotional</dt><dd><p>Feeling more emotional</p>
</dd>
<dt>Q14: Feeling slowed down</dt><dd><p>Feeling slowed down</p>
</dd>
<dt>Q15: Feeling mentally foggy</dt><dd><p>Feeling mentally foggy</p>
</dd>
<dt>Q16: Difficulty concentrating</dt><dd><p>Difficulty concentrating</p>
</dd>
<dt>Q17: Difficulty remembering</dt><dd><p>Difficulty remembering</p>
</dd>
<dt>Q18: Visual problem</dt><dd><p>Visual problems</p>
</dd>
<dt>Q19: Confusion</dt><dd><p>Confusion</p>
</dd>
<dt>Q20: Feeling clumsy</dt><dd><p>Feeling clumsy</p>
</dd>
<dt>Q21: Answer slowlier</dt><dd><p>Answer slowlier</p>
</dd>
</dl>


<hr>
<h2 id='cramersVmod'>Cramer's V modified pairwise vector function based on the function found in lsr package</h2><span id='topic+cramersVmod'></span>

<h3>Description</h3>

<p>This is simple wrapper of the usual chisq.test function.
This is actually an adjusted version of the pi = sqrt(Chisq2/N)
guaranteeing that values are within 0 (no association) and 1 (association)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cramersVmod(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cramersVmod_+3A_x">x</code></td>
<td>
<p>vector of size n</p>
</td></tr>
<tr><td><code id="cramersVmod_+3A_y">y</code></td>
<td>
<p>vector of size n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical value
</p>

<hr>
<h2 id='CramerV'>Cramer's V distance</h2><span id='topic+CramerV'></span>

<h3>Description</h3>

<p>Cramer's V core function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CramerV(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CramerV_+3A_x">X</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance matrix
</p>

<hr>
<h2 id='dissbhattacharyya'>Bhattacharyya's distance (wrapper)</h2><span id='topic+dissbhattacharyya'></span>

<h3>Description</h3>

<p>Wrapper of 'BhattacharyyaDist'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissbhattacharyya(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dissbhattacharyya_+3A_x">X</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance R object
</p>

<hr>
<h2 id='disschisquare'>Chi-square distance (wrapper)</h2><span id='topic+disschisquare'></span>

<h3>Description</h3>

<p>Wrapper of 'ChisqDist'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disschisquare(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disschisquare_+3A_x">X</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance R object
</p>

<hr>
<h2 id='disscramerv'>Cramer's V distance (wrapper)</h2><span id='topic+disscramerv'></span>

<h3>Description</h3>

<p>Wrapper of 'CramerV'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disscramerv(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disscramerv_+3A_x">X</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance R object
</p>

<hr>
<h2 id='disshamming'>Hamming distance wrapper function</h2><span id='topic+disshamming'></span>

<h3>Description</h3>

<p>Function based on cultevo's package implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disshamming(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disshamming_+3A_x">X</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance matrix
</p>

<hr>
<h2 id='disshellinger'>Hellinger distance (wrapper)</h2><span id='topic+disshellinger'></span>

<h3>Description</h3>

<p>Wrapper of 'HellingerDist'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disshellinger(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disshellinger_+3A_x">X</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance R object
</p>

<hr>
<h2 id='distanceHeat'>Sample-to-sample heatmap</h2><span id='topic+distanceHeat'></span>

<h3>Description</h3>

<p>sample-to-sample heatmap clustering samples according to a given categorical distance
Exploratory tool that helps to visualize/cluster blocks of observations across
columns ordered according to given categorical distance. The final output is
a clustered distance matrix.
This plot is aimed to guide the 'DiscreteClusGap' user to give an idea which
type of categorical distance would accommodate better to the inputted data.
'sample2sampleHeat' is based on the 'pheatmap' function from the 'pheatmap'
R package. Thus, any parameter found in pheatmap can be specified to 'sample2sampleHeat'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceHeat(
  x,
  distName,
  clustering_method = "complete",
  border_color = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceHeat_+3A_x">x</code></td>
<td>
<p>matrix object or data.frame</p>
</td></tr>
<tr><td><code id="distanceHeat_+3A_distname">distName</code></td>
<td>
<p>Name of categorical distance to apply.</p>
</td></tr>
<tr><td><code id="distanceHeat_+3A_clustering_method">clustering_method</code></td>
<td>
<p>string; clustering method used by pheatmap</p>
</td></tr>
<tr><td><code id="distanceHeat_+3A_border_color">border_color</code></td>
<td>
<p>string; color cell borders. By default, border_color = NA, where no border colors are shown.</p>
</td></tr>
<tr><td><code id="distanceHeat_+3A_...">...</code></td>
<td>
<p>other valid arguments in pheatmap function
Available distances: 'bhattacharyya', 'chisquare', 'cramerV', 'hamming' and 'hellinger'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>clustered heatmap
</p>

<hr>
<h2 id='distancematrix'>Calculate categorical distance matrix for discrete data</h2><span id='topic+distancematrix'></span>

<h3>Description</h3>

<p>Function invoking discrete distance functions.
Available distances: 'bhattacharyya', 'chisquare', 'cramerV', 'hamming' and 'hellinger'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancematrix(X, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancematrix_+3A_x">X</code></td>
<td>
<p>Matrix where rows are the observations and columns are discrete features</p>
</td></tr>
<tr><td><code id="distancematrix_+3A_d">d</code></td>
<td>
<p>Name of distance. Distances available: bhattacharyya, chisquare, cramerV, hamming and hellinger</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R distance object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = rbind(matrix(paste0("a", rpois(7*5, 1)), nrow=5),
          matrix(paste0("a", rpois(7*5, 3)), nrow=5))
distancematrix(X = X, d = "hellinger")
</code></pre>

<hr>
<h2 id='findK'>Criteria to determine number of clusters k</h2><span id='topic+findK'></span>

<h3>Description</h3>

<p>Same function as found in 'cluster' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findK(cG_obj, meth = "Tibs2001SEmax")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findK_+3A_cg_obj">cG_obj</code></td>
<td>
<p>Output object obtained from 'clusGapDiscr'</p>
</td></tr>
<tr><td><code id="findK_+3A_meth">meth</code></td>
<td>
<p>Method to use to determine optimal k number of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value from 1 to K.max, contained in the input 'cG_obj' object.
</p>

<hr>
<h2 id='HellingerDist'>Hellinger distance</h2><span id='topic+HellingerDist'></span>

<h3>Description</h3>

<p>Hellinger distance core function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HellingerDist(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HellingerDist_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance matrix
</p>

<hr>
<h2 id='kmodesD'>Adapted k-modes algorithm</h2><span id='topic+kmodesD'></span>

<h3>Description</h3>

<p>K-modes function to accept any categorical distance based on
the function found in 'klaR:kmodes'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmodesD(data, modes, distFun, iter.max = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmodesD_+3A_data">data</code></td>
<td>
<p>A matrix or data frame of categorical data. Objects have to be in rows, variables in columns.</p>
</td></tr>
<tr><td><code id="kmodesD_+3A_modes">modes</code></td>
<td>
<p>The number of modes</p>
</td></tr>
<tr><td><code id="kmodesD_+3A_distfun">distFun</code></td>
<td>
<p>Pairwise categorical distance function. A function accepting two categorical vectors.</p>
</td></tr>
<tr><td><code id="kmodesD_+3A_iter.max">iter.max</code></td>
<td>
<p>The maximum number of iterations allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class kmodes as found in 'klaR' packages.
An additional component specifies the categorical distance function found in 'distFun'.
</p>

<hr>
<h2 id='likert.heat.plot2'>Summary Heatmap for categorical data</h2><span id='topic+likert.heat.plot2'></span>

<h3>Description</h3>

<p>Heatmap representation summarizing categorical/likert data.
Modified version of 'likert.heat.plot' from 'likert' package.
Does not allow different categorical ranges across questions.
The function outputs a ggplot object where additional layers can be added for customization purposes.
The output plot preserves the question order given by columns of 'x'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likert.heat.plot2(
  x,
  allLevels,
  low.color = "white",
  high.color = "blue",
  text.color = "black",
  text.size = 4,
  textLen = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likert.heat.plot2_+3A_x">x</code></td>
<td>
<p>matrix object or data.frame with categorical data. Columns are questions and rows are observations.</p>
</td></tr>
<tr><td><code id="likert.heat.plot2_+3A_alllevels">allLevels</code></td>
<td>
<p>vector with all categorical (ordered) levels.</p>
</td></tr>
<tr><td><code id="likert.heat.plot2_+3A_low.color">low.color</code></td>
<td>
<p>string; name of color assigned to the first level found in 'allLevels'.</p>
</td></tr>
<tr><td><code id="likert.heat.plot2_+3A_high.color">high.color</code></td>
<td>
<p>string; name of color assigned to the last level found in 'allLevels'.</p>
</td></tr>
<tr><td><code id="likert.heat.plot2_+3A_text.color">text.color</code></td>
<td>
<p>string; text color of numbers within cells.</p>
</td></tr>
<tr><td><code id="likert.heat.plot2_+3A_text.size">text.size</code></td>
<td>
<p>string; text size for numbers within cells.</p>
</td></tr>
<tr><td><code id="likert.heat.plot2_+3A_textlen">textLen</code></td>
<td>
<p>string; maximum length of text-length for question labels (column names)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object.
</p>

<hr>
<h2 id='mass'>mass data</h2><span id='topic+mass'></span>

<h3>Description</h3>

<p>Data extracted from the 'likert' R package.
Results from an administration of the Math Anxiety Scale Survey.
First Column records student gender either Female or Male.
All statement answers have 5 possible ordinal categorical items:
Strongly Disagree, Disagree, Neutral, Agree, Strongly Agree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass
</code></pre>


<h3>Format</h3>

<p>## 'data.frame'
</p>

<dl>
<dt>Gender</dt><dd><p>Gender</p>
</dd>
<dt>I find math interesting.</dt><dd><p>Math interesting</p>
</dd>
<dt>I get uptight during math tests.</dt><dd><p>Uptight with math tests</p>
</dd>
<dt>I think that I will use math in the future.</dt><dd><p>Use math in the future</p>
</dd>
<dt>Mind goes blank and I am unable to think clearly when doing my math test.</dt><dd><p>Mind goes blank in math tests</p>
</dd>
<dt>Math relates to my life.</dt><dd><p>Math relates to own life</p>
</dd>
<dt>I worry about my ability to solve math problems.</dt><dd><p>Worry about ability math problem solving</p>
</dd>
<dt>I get a sinking feeling when I try to do math problems.</dt><dd><p>Sinking feeling doing math problems</p>
</dd>
<dt>I find math challenging.</dt><dd><p>Math is challenging</p>
</dd>
<dt>Mathematics makes me feel nervous.</dt><dd><p>Nervousness with math</p>
</dd>
<dt>I would like to take more math classes.</dt><dd><p>Take more math classes</p>
</dd>
<dt>Mathematics makes me feel uneasy.</dt><dd><p>Uneasy feeling with math</p>
</dd>
<dt>Math is one of my favorite subjects.</dt><dd><p>Favorite subject is math</p>
</dd>
<dt>I enjoy learning with mathematics.</dt><dd><p>Enjoy learning math</p>
</dd>
<dt>Mathematics makes me feel confused.</dt><dd><p>Confused with math</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://rdrr.io/cran/likert/man/mass.html&gt;
</p>

<hr>
<h2 id='ResHeatmap'>Discrete Data Heatmap</h2><span id='topic+ResHeatmap'></span>

<h3>Description</h3>

<p>Heatmap assuming a given a distance function and a known number of clusters.
Function to display a categorical data matrix given a user defined number of
clusters 'nCl', a categorical distance 'distName' and a predefined clustering
method 'FUNcluster'.
The output displays a heatmap separating and color-labelling resulting
clusters vertically in the rows and allowing unsupervised clustering on
questions in the columns. Each cell is colored according to the categorical
values provided or found in the data.
The clustergram is based on the 'pheatmap' function from the pheatmap R package.
Thus, any parameter found in pheatmap can be specified to 'clusGapDiscrHeat'.
This function can be used to examine number of clusters before running
'clusGapDiscrHeat' but also after the number of clusters is determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResHeatmap(
  x,
  nCl,
  distName,
  catVals,
  clusterFUN,
  out = "heatmap",
  seed = NULL,
  clusterNames = NULL,
  prefObs = NULL,
  rowNames = rownames(x),
  filename = NULL,
  outDir = NULL,
  height = 10,
  width = 6
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResHeatmap_+3A_x">x</code></td>
<td>
<p>matrix object or data.frame</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_ncl">nCl</code></td>
<td>
<p>number of clusters to plot; if 'nCl' is a permutation vector of the first lN integers will rearrange clusters according to the original given ordering.</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_distname">distName</code></td>
<td>
<p>Name of categorical distance to apply.
Available distances: 'bhattacharyya', 'chisquare', 'cramerV', 'hamming' and 'hellinger'.</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_catvals">catVals</code></td>
<td>
<p>character string vector with (ordered) categorical values</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_clusterfun">clusterFUN</code></td>
<td>
<p>Character string with one of the available clustering implementations.
Available options are: 'pam' (default) from &lsquo;cluster::pam', &rsquo;diana' from &lsquo;cluster::diana', &rsquo;fanny' from 'cluster::fanny'.
'agnes-{average, single, complete, ward, weighted}' from 'cluster::agnes',
'hclust-{ward.D, ward.D2, single, complete, average, mcquitty, median, centroid}' from 'stats::hclust',
'kmodes' from 'klar::kmodes' ('weighted = FALSE' and 'fast= TRUE').</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_out">out</code></td>
<td>
<p>Specifies the desired output between &quot;heatmap&quot; (default; produce a heatmap), &quot;clusters&quot; (return a 'data.frame' with clustering assignments) or &quot;clustersReord&quot; (return a 'data.frame' with reorganized clusters)</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_seed">seed</code></td>
<td>
<p>Seed number.</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_clusternames">clusterNames</code></td>
<td>
<p>Either &lsquo;null' or &rsquo;renumber'. When &lsquo;nCl' is a numerical vector, the cluster ordering is rearranged. 'NULL' leaves cluster names as their original cluster assignment. &rsquo;renumber' respects the rearrangements but relabels the cluster numbers from top to bottom in ascending order.</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_prefobs">prefObs</code></td>
<td>
<p>character string vector of length 1 with a prefix for the observations, in case they come unlabelled or the user wants to anomymize sample IDs.</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_rownames">rowNames</code></td>
<td>
<p>character vector with names of rows according to 'x'. By default, 'rownames(x)' will be printed in the plot. 'rowNames=NULL' prevents from showing names. 'prefObs' option takes precedence if is different to 'NULL'.</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_filename">filename</code></td>
<td>
<p>character string with name of file output</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_outdir">outDir</code></td>
<td>
<p>character string with the directory path to save output file</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_height">height</code></td>
<td>
<p>numeric height of output plot in inches</p>
</td></tr>
<tr><td><code id="ResHeatmap_+3A_width">width</code></td>
<td>
<p>numeric width of output plot in inches</p>
</td></tr>
</table>


<h3>Value</h3>

<p>png file or ComplexHeatmap object
</p>

<hr>
<h2 id='SimData'>Simulate Data</h2><span id='topic+SimData'></span>

<h3>Description</h3>

<p>A function to simulate data based on a multinomial vector parameter vector or
a list of parameter vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimData(N, nQ, pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimData_+3A_n">N</code></td>
<td>
<p>Integer. Number of observations.</p>
</td></tr>
<tr><td><code id="SimData_+3A_nq">nQ</code></td>
<td>
<p>Integer. Number of questions.</p>
</td></tr>
<tr><td><code id="SimData_+3A_pi">pi</code></td>
<td>
<p>Numeric vector. Vector of probabilities adding up to 1; it is recommended that names of elements are character strings.
Alternatively, pi can be list of vectors as previously described with length equal to 'nQ'. Notice that the list elements need not have same vector names. The order of pi vectors in the list will be reflected in the resulting simulated matrix. This alternative ideally assumes that questions are independently distributed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N x nQ matrix with simulated categories distributed according to vector pi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Pix &lt;- setNames(c(0.1, 0.2, 0.3, 0.4, 0), paste0('a', 1:5))
X &lt;- SimData(N=10, nQ=5, Pix)
head(X)

Piy &lt;- setNames(c(0.3, 0.2, 0.4, 0, 0.1), paste0('a', 1:5))
Y &lt;- SimData(N=10, nQ=3, Piy)
head(Y)

PiZ &lt;- list(x1 = Pix, x2 = Pix, y1 = Piy, y2 = Piy)
Z &lt;- SimData(N=10, nQ=length(PiZ), PiZ)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
