<!DOCTYPE html><html lang="en"><head><title>Help for package fiery</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fiery}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fiery-package'><p>fiery: A Lightweight and Flexible Web Framework</p></a></li>
<li><a href='#fake_request'><p>Create a fake request to use in testing</p></a></li>
<li><a href='#Fire'><p>Generate a New App Object</p></a></li>
<li><a href='#loggers'><p>App Logging</p></a></li>
<li><a href='#random_port'><p>Select a random safe port</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Lightweight and Flexible Web Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A very flexible framework for building server side logic in
    R. The framework is unopinionated when it comes to how HTTP requests
    and WebSocket messages are handled and supports all levels of app
    complexity; from serving static content to full-blown dynamic
    web-apps. Fiery does not hold your hand as much as e.g. the shiny
    package does, but instead sets you free to create your web app the way
    you want.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fiery.data-imaginist.com">https://fiery.data-imaginist.com</a>,
<a href="https://github.com/thomasp85/fiery">https://github.com/thomasp85/fiery</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/fiery/issues">https://github.com/thomasp85/fiery/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, crayon, future, glue, httpuv, later, parallelly, R6,
reqres, rlang (&ge; 1.1.0), stats, stringi, utils, uuid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'loggers.R' 'aaa.R' 'HandlerStack.R' 'Fire.R' 'FutureStack.R'
'additional_type_checks.R' 'fake_request.R' 'fiery-package.R'
'import-standalone-obj-type.R'
'import-standalone-types-check.R' 'zzz.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 16:35:38 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 22:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='fiery-package'>fiery: A Lightweight and Flexible Web Framework</h2><span id='topic+fiery'></span><span id='topic+fiery-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A very flexible framework for building server side logic in R. The framework is unopinionated when it comes to how HTTP requests and WebSocket messages are handled and supports all levels of app complexity; from serving static content to full-blown dynamic web-apps. Fiery does not hold your hand as much as e.g. the shiny package does, but instead sets you free to create your web app the way you want.
</p>


<h3>Details</h3>

<p><code>fiery</code> is a lightweight and flexible framework for web servers build on top of
the <a href="httpuv.html#topic+httpuv-package">httpuv</a> package. The framework is largely
event-based, letting the developer attach handlers to life-cycle events as
well as defining and triggering their own events. This approach to
development is common in JavaScript, but might feel foreign to R developers.
Thankfully it is a rather simple concept that should be easy to gradually
begin to use to greater and greater effect.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://fiery.data-imaginist.com">https://fiery.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/fiery">https://github.com/thomasp85/fiery</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/fiery/issues">https://github.com/thomasp85/fiery/issues</a>
</p>
</li></ul>


<hr>
<h2 id='fake_request'>Create a fake request to use in testing</h2><span id='topic+fake_request'></span>

<h3>Description</h3>

<p>This function creates a new request for a specific resource defined by a
URL. It mimics the format of the requests provided through httpuv, meaning
that it can be used in place for the requests send to the <code>before-request</code>,
<code>request</code>, and <code>after-request</code> handlers. This is only provided so that
handlers can be tested without having to start up a server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fake_request(
  url,
  method = "get",
  appLocation = "",
  content = "",
  headers = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fake_request_+3A_url">url</code></td>
<td>
<p>A complete url for the resource the request should ask for</p>
</td></tr>
<tr><td><code id="fake_request_+3A_method">method</code></td>
<td>
<p>The request type (get, post, put, etc). Defaults to <code>"get"</code></p>
</td></tr>
<tr><td><code id="fake_request_+3A_applocation">appLocation</code></td>
<td>
<p>A string giving the first part of the url path that should
be stripped from the path</p>
</td></tr>
<tr><td><code id="fake_request_+3A_content">content</code></td>
<td>
<p>The content of the request, either a raw vector or a string</p>
</td></tr>
<tr><td><code id="fake_request_+3A_headers">headers</code></td>
<td>
<p>A list of name-value pairs that defines the request headers</p>
</td></tr>
<tr><td><code id="fake_request_+3A_...">...</code></td>
<td>
<p>Additional name-value pairs that should be added to the request</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Rook-compliant environment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- fake_request(
    'http://www.my-fake-website.com/path/to/a/query/?key=value&amp;key2=value2',
    content = 'Some important content'
)

# Get the main address of the URL
req[['SERVER_NAME']]

# Get the query string
req[['QUERY_STRING']]

# ... etc.

# Cleaning up connections
rm(req)
gc()

</code></pre>

<hr>
<h2 id='Fire'>Generate a New App Object</h2><span id='topic+Fire'></span>

<h3>Description</h3>

<p>The Fire generator creates a new <code>Fire</code>-object, which is the class containing
all the app logic. The class is based on the <a href="R6.html#topic+R6Class">R6</a> OO-system and
is thus reference-based with methods and data attached to each object, in
contrast to the more well known S3 and S4 systems. A <code>fiery</code> server is event
driven, which means that it is build up and manipulated by adding event
handlers and triggering events. To learn more about the <code>fiery</code> event model,
read the <a href="https://fiery.data-imaginist.com/articles/events.html">event vignette</a>.
<code>fiery</code> servers can be modified directly or by attaching plugins. As with
events, <a href="https://fiery.data-imaginist.com/articles/plugins.html">plugins has its own vignette</a>.
</p>


<h4>Initialization</h4>

<p>A new 'Fire'-object is initialized using the <code>new()</code> method on the generator:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>app &lt;- Fire$new(host = '127.0.0.1', port = 8080L)</code>
</td>
</tr>

</table>




<h4>Copying</h4>

<p>As <code>Fire</code> objects are using reference semantics new copies of an app cannot
be made simply be assigning it to a new variable. If a true copy of a <code>Fire</code>
object is desired, use the <code>clone()</code> method.
</p>



<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>host</code></dt><dd><p>A string giving a valid IPv4 address owned by the server, or <code>'0.0.0.0'</code> to listen on all addresses. The default is <code>'127.0.0.1'</code></p>
</dd>
<dt><code>port</code></dt><dd><p>An integer giving the port number the server should listen on (defaults to <code>8080L</code>)</p>
</dd>
<dt><code>refresh_rate</code></dt><dd><p>The interval in seconds between run cycles when running a blocking server (defaults to <code>0.001</code>)</p>
</dd>
<dt><code>refresh_rate_nb</code></dt><dd><p>The interval in seconds between run cycles when running a non-blocking server (defaults to <code>1</code>)</p>
</dd>
<dt><code>trigger_dir</code></dt><dd><p>A valid folder where trigger files can be put when running a blocking server (defaults to <code>NULL</code>). See the <a href="https://fiery.data-imaginist.com/articles/events.html"><em>The event cycle in fiery</em> vignette</a> for more information.</p>
</dd>
<dt><code>plugins</code></dt><dd><p>A named list of the already attached plugins. <strong>Read Only</strong> - can only be modified using the <code>attach()</code> method.</p>
</dd>
<dt><code>root</code></dt><dd><p>The location of the app. Setting this will remove the root value from requests (or decline them with <code>400</code> if the request does not match the root). E.g. the path of a request will be changed from <code style="white-space: pre;">&#8288;/demo/test&#8288;</code> to <code style="white-space: pre;">&#8288;/test&#8288;</code> if <code>root == '/demo'</code></p>
</dd>
<dt><code>access_log_format</code></dt><dd><p>A <a href="glue.html#topic+glue">glue</a> string defining how requests will be logged. For standard formats see <a href="#topic+common_log_format">common_log_format</a> and <a href="#topic+combined_log_format">combined_log_format</a>. Defaults to the <em>Common Log Format</em></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Fire-new"><code>Fire$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-format"><code>Fire$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-ignite"><code>Fire$ignite()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-start"><code>Fire$start()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-reignite"><code>Fire$reignite()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-resume"><code>Fire$resume()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-extinguish"><code>Fire$extinguish()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-stop"><code>Fire$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-on"><code>Fire$on()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-off"><code>Fire$off()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-trigger"><code>Fire$trigger()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-send"><code>Fire$send()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-close_ws_con"><code>Fire$close_ws_con()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-attach"><code>Fire$attach()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-has_plugin"><code>Fire$has_plugin()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-header"><code>Fire$header()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-set_data"><code>Fire$set_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-get_data"><code>Fire$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-remove_data"><code>Fire$remove_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-time"><code>Fire$time()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-remove_time"><code>Fire$remove_time()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-delay"><code>Fire$delay()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-remove_delay"><code>Fire$remove_delay()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-async"><code>Fire$async()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-remove_async"><code>Fire$remove_async()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-set_client_id_converter"><code>Fire$set_client_id_converter()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-set_logger"><code>Fire$set_logger()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-log"><code>Fire$log()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-is_running"><code>Fire$is_running()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-test_request"><code>Fire$test_request()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-test_header"><code>Fire$test_header()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-test_message"><code>Fire$test_message()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-test_websocket"><code>Fire$test_websocket()</code></a>
</p>
</li>
<li> <p><a href="#method-Fire-clone"><code>Fire$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Fire-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Fire</code> app
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$new(host = "127.0.0.1", port = 8080)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>host</code></dt><dd><p>A string overriding the default host</p>
</dd>
<dt><code>port</code></dt><dd><p>An port number overriding the default port</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Fire</code> object
</p>


<hr>
<a id="method-Fire-format"></a>



<h4>Method <code>format()</code></h4>

<p>Human readable description of the app
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A character vector
</p>


<hr>
<a id="method-Fire-ignite"></a>



<h4>Method <code>ignite()</code></h4>

<p>Begin running the server. Will trigger the <code>start</code> event
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$ignite(block = TRUE, showcase = FALSE, ..., silent = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>block</code></dt><dd><p>Should the console be blocked while running (alternative is to run in the background)</p>
</dd>
<dt><code>showcase</code></dt><dd><p>Should the default browser open up at the server address</p>
</dd>
<dt><code>...</code></dt><dd><p>Arguments passed on to the <code>start</code> handler</p>
</dd>
<dt><code>silent</code></dt><dd><p>Should startup messaging by silenced</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-start"></a>



<h4>Method <code>start()</code></h4>

<p>Synonymous method to <code>ignite()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$start(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>passed on to <code>ignite()</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-reignite"></a>



<h4>Method <code>reignite()</code></h4>

<p>Resume a session. This is equivalent to <code>ignite()</code> but will also trigger the <code>resume</code> event
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$reignite(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>passed on to <code>ignite()</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-resume"></a>



<h4>Method <code>resume()</code></h4>

<p>Synonymous method to <code>reignite()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$resume(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>passed on to <code>ignite()</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-extinguish"></a>



<h4>Method <code>extinguish()</code></h4>

<p>Stop the server. Will trigger the <code>end</code> event
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$extinguish()</pre></div>


<hr>
<a id="method-Fire-stop"></a>



<h4>Method <code>stop()</code></h4>

<p>Synonymous method to <code>extinguish()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$stop()</pre></div>


<hr>
<a id="method-Fire-on"></a>



<h4>Method <code>on()</code></h4>

<p>Add a handler to an event. See the <a href="https://fiery.data-imaginist.com/articles/events.html"><em>The event cycle in fiery</em> vignette</a> for more information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$on(event, handler, pos = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>event</code></dt><dd><p>The name of the event that should trigger the handler</p>
</dd>
<dt><code>handler</code></dt><dd><p>The handler function that should be triggered</p>
</dd>
<dt><code>pos</code></dt><dd><p>The position in the handler stack to place it at. <code>NULL</code> will place it at the end.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A unique string identifying the handler
</p>


<hr>
<a id="method-Fire-off"></a>



<h4>Method <code>off()</code></h4>

<p>Remove an event handler from the app.
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$off(handlerId)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>handlerId</code></dt><dd><p>The unique id identifying the handler</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-trigger"></a>



<h4>Method <code>trigger()</code></h4>

<p>Trigger an event in the app. This will cause any handler attached to the event to be called. See the <a href="https://fiery.data-imaginist.com/articles/events.html"><em>The event cycle in fiery</em> vignette</a> for more information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$trigger(event, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>event</code></dt><dd><p>The name of the event</p>
</dd>
<dt><code>...</code></dt><dd><p>Arguments passed on to the handlers</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A named list containing the return values of all handlers attached to the event
</p>


<hr>
<a id="method-Fire-send"></a>



<h4>Method <code>send()</code></h4>

<p>Send a Websocket message to a client. Will trigger the <code>send</code> event.
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$send(message, id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>message</code></dt><dd><p>The message to send</p>
</dd>
<dt><code>id</code></dt><dd><p>The id of the client to send to. If missing, the message will be send to all clients</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-close_ws_con"></a>



<h4>Method <code>close_ws_con()</code></h4>

<p>Close a Websocket connection. Will trigger the <code>websocket-closed</code> event
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$close_ws_con(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the client to close the websocket connection to</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-attach"></a>



<h4>Method <code>attach()</code></h4>

<p>Attach a plugin to the app. See the <a href="https://fiery.data-imaginist.com/articles/plugins.html"><em>Creating and using fiery plugins</em> vignette</a> for more information
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$attach(plugin, ..., force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plugin</code></dt><dd><p>The plugin to attach</p>
</dd>
<dt><code>...</code></dt><dd><p>Arguments to pass into the plugins <code>on_attach()</code> method</p>
</dd>
<dt><code>force</code></dt><dd><p>If the plugin has already been attached an error is thrown, unless <code>force = TRUE</code> which tells the app to reattach it</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-has_plugin"></a>



<h4>Method <code>has_plugin()</code></h4>

<p>Check if the app has a plugin attached
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$has_plugin(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the plugin</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A boolean indicating if the given plugin is already attached
</p>


<hr>
<a id="method-Fire-header"></a>



<h4>Method <code>header()</code></h4>

<p>Add a global http header that will be applied to all responses
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$header(name, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the header</p>
</dd>
<dt><code>value</code></dt><dd><p>The value of the header. Use <code>NULL</code> to remove the global header</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-set_data"></a>



<h4>Method <code>set_data()</code></h4>

<p>Add data to the global data store
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$set_data(name, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name identifying the data</p>
</dd>
<dt><code>value</code></dt><dd><p>The data to add</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-get_data"></a>



<h4>Method <code>get_data()</code></h4>

<p>Retrieve data from the global data store
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$get_data(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name identifying the data</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The data requested. Returns <code>NULL</code> if the store does not contain the requested data
</p>


<hr>
<a id="method-Fire-remove_data"></a>



<h4>Method <code>remove_data()</code></h4>

<p>Remove data from the global data store
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$remove_data(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name identifying the data to be removed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-time"></a>



<h4>Method <code>time()</code></h4>

<p>Add a timed evaluation that will be evaluated after the given number of seconds. See the <a href="https://fiery.data-imaginist.com/articles/delayed.html"><em>Delaying code execution in Fiery</em> vignette</a> for more information
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$time(expr, then, after, loop = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expr</code></dt><dd><p>The expression to evaluate when the time has passed</p>
</dd>
<dt><code>then</code></dt><dd><p>A handler to call once <code>expr</code> has been evaluated</p>
</dd>
<dt><code>after</code></dt><dd><p>The time in second to wait before evaluating <code>expr</code></p>
</dd>
<dt><code>loop</code></dt><dd><p>Should <code>expr</code> be called repeatedly with the interval given by <code>after</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A unique id identifying the handler
</p>


<hr>
<a id="method-Fire-remove_time"></a>



<h4>Method <code>remove_time()</code></h4>

<p>Remove a timed evaluation
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$remove_time(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The unique id identifying the handler</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-delay"></a>



<h4>Method <code>delay()</code></h4>

<p>Add a delayed evaluation to be evaluated immediately at the end of the loop cycle. See the <a href="https://fiery.data-imaginist.com/articles/delayed.html"><em>Delaying code execution in Fiery</em> vignette</a> for more information
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$delay(expr, then)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expr</code></dt><dd><p>The expression to evaluate at the end of the cycle</p>
</dd>
<dt><code>then</code></dt><dd><p>A handler to call once <code>expr</code> has been evaluated</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A unique id identifying the handler
</p>


<hr>
<a id="method-Fire-remove_delay"></a>



<h4>Method <code>remove_delay()</code></h4>

<p>Remove a delayed evaluation
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$remove_delay(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The unique id identifying the handler</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-async"></a>



<h4>Method <code>async()</code></h4>

<p>Add an asynchronous evaluation to be evaluated in another process without blocking the server. See the <a href="https://fiery.data-imaginist.com/articles/delayed.html"><em>Delaying code execution in Fiery</em> vignette</a> for more information
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$async(expr, then)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expr</code></dt><dd><p>The expression to evaluate at the end of the cycle</p>
</dd>
<dt><code>then</code></dt><dd><p>A handler to call once <code>expr</code> has been evaluated</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A unique id identifying the handler
</p>


<hr>
<a id="method-Fire-remove_async"></a>



<h4>Method <code>remove_async()</code></h4>

<p>Remove an async evaluation
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$remove_async(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The unique id identifying the handler</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-set_client_id_converter"></a>



<h4>Method <code>set_client_id_converter()</code></h4>

<p>Sets the function that converts an HTTP request into a specific client id
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$set_client_id_converter(converter)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>converter</code></dt><dd><p>A function with the argument <code>request</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-set_logger"></a>



<h4>Method <code>set_logger()</code></h4>

<p>Sets the logging function to use
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$set_logger(logger)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>logger</code></dt><dd><p>A function with the arguments <code>event</code>, <code>message</code>, <code>request</code>, and <code>...</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-log"></a>



<h4>Method <code>log()</code></h4>

<p>Log a message with the logger attached to the app. See <a href="#topic+loggers">loggers</a> for build in functionality
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$log(event, message, request = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>event</code></dt><dd><p>The event associated with the message</p>
</dd>
<dt><code>message</code></dt><dd><p>The message to log</p>
</dd>
<dt><code>request</code></dt><dd><p>The <code>Request</code> object associated with the message, if any.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments passed on to the logger.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-is_running"></a>



<h4>Method <code>is_running()</code></h4>

<p>Test if an app is running
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$is_running()</pre></div>


<hr>
<a id="method-Fire-test_request"></a>



<h4>Method <code>test_request()</code></h4>

<p>Send a request directly to the request logic of a non-running app. Only intended for testing the request logic
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$test_request(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>The request to send</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-test_header"></a>



<h4>Method <code>test_header()</code></h4>

<p>Send a request directly to the header logic of a non-running app. Only intended for testing the request logic
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$test_header(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>The request to send</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-test_message"></a>



<h4>Method <code>test_message()</code></h4>

<p>Send a message directly <strong>to</strong> the message logic of a non-running app. Only intended for testing the websocket logic
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$test_message(request, binary, message, withClose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>The request to use to establish the connection</p>
</dd>
<dt><code>binary</code></dt><dd><p>Is the message send in binary or character format</p>
</dd>
<dt><code>message</code></dt><dd><p>The message to send. If <code>binary = FALSE</code> a character vector, if <code>binary = TRUE</code> a raw vector</p>
</dd>
<dt><code>withClose</code></dt><dd><p>Should the websocket connection be closed at the end by the client</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-test_websocket"></a>



<h4>Method <code>test_websocket()</code></h4>

<p>Send a message directly <strong>from</strong> a non-running app. Only intended for testing the websocket logic
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$test_websocket(request, message, close = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>The request to use to establish the connection</p>
</dd>
<dt><code>message</code></dt><dd><p>The message to send from the app</p>
</dd>
<dt><code>close</code></dt><dd><p>Should the websocket connection be closed at the end by the server</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fire-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Fire$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create a New App
app &lt;- Fire$new(port = 4689)

# Setup the data every time it starts
app$on('start', function(server, ...) {
    server$set_data('visits', 0)
    server$set_data('cycles', 0)
})

# Count the number of cycles
app$on('cycle-start', function(server, ...) {
    server$set_data('cycles', server$get_data('cycles') + 1)
})

# Count the number of requests
app$on('before-request', function(server, ...) {
    server$set_data('visits', server$get_data('visits') + 1)
})

# Handle requests
app$on('request', function(server, ...) {
    list(
        status = 200L,
        headers = list('Content-Type' = 'text/html'),
        body = paste('This is indeed a test. You are number', server$get_data('visits'))
    )
})

# Show number of requests in the console
app$on('after-request', function(server, ...) {
    message(server$get_data('visits'))
    flush.console()
})

# Terminate the server after 300 cycles
app$on('cycle-end', function(server, ...) {
    if (server$get_data('cycles') &gt; 300) {
        message('Ending...')
        flush.console()
        server$extinguish()
    }
})

# Be polite
app$on('end', function(server) {
    message('Goodbye')
    flush.console()
})

## Not run: 
app$ignite(showcase = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='loggers'>App Logging</h2><span id='topic+loggers'></span><span id='topic+logging'></span><span id='topic+logger_null'></span><span id='topic+logger_console'></span><span id='topic+logger_file'></span><span id='topic+logger_switch'></span><span id='topic+common_log_format'></span><span id='topic+combined_log_format'></span>

<h3>Description</h3>

<p><code>fiery</code> has a build in logging mechanism that lets you capture event
information however you like. Every user-injested warnings and errors are
automatically captured by the logger along with most system errors as well.
<code>fiery</code> tries very hard not to break due to faulty app logic. This means that
any event handler error will be converted to an error log without <code>fiery</code>
stopping. In the case of request handlers a 500L response will be send back
if any error is encountered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger_null()

logger_console(format = "{time} - {event}: {message}")

logger_file(file, format = "{time} - {event}: {message}")

logger_switch(..., default = logger_null())

common_log_format

combined_log_format
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loggers_+3A_format">format</code></td>
<td>
<p>A <a href="glue.html#topic+glue">glue</a> string specifying the format of the log entry</p>
</td></tr>
<tr><td><code id="loggers_+3A_file">file</code></td>
<td>
<p>A file or connection to write to</p>
</td></tr>
<tr><td><code id="loggers_+3A_...">...</code></td>
<td>
<p>A named list of loggers to use for different events. The same
semantics as <a href="base.html#topic+switch">switch</a> is used so it is possible to let events
<em>fall through</em> e.g. <code>logger_switch(error =, warning = logger_file('errors.log'))</code>.</p>
</td></tr>
<tr><td><code id="loggers_+3A_default">default</code></td>
<td>
<p>A catch-all logger for use with events not defined in <code>...</code></p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>
<p>An object of class <code>character</code> of length 1.
</p>


<h3>Setting a logger</h3>

<p>By default, <code>fiery</code> uses <code>logger_null()</code> which forwards warning and error
messages to <code>stderr()</code> and ignores any other logging events. To change this
behavior, set a different logger using the <code>set_logger()</code> method:
</p>
<div class="sourceCode"><pre>app$set_logger(logger)
</pre></div>
<p>where <code>logger</code> is a function taking at least the following arguments: <code>event</code>,
<code>message</code>, <code>request</code>, <code>time</code>, and <code>...</code>.
</p>
<p><code>fiery</code> comes with some additional loggers, which either writes all logs to a
file or to the console. A new instance of the file logger can be created with
<code>logger_file(file)</code>:
</p>
<div class="sourceCode"><pre>app$set_logger(logger_file('fiery_log.log'))
</pre></div>
<p>A new instance of the console logger can be create with <code>logger_console()</code>:
</p>
<div class="sourceCode"><pre>app$set_logger(logger_console())
</pre></div>
<p>Both functions takes a <code>format</code> a argument that lets you customise how the
log is written. Furthermore the console logger will style the logs with
colour coding depending on the content if the console supports it.
</p>
<p>As a last possibility it is possible to use different loggers dependent on
the event by using the switch logger:
</p>
<div class="sourceCode"><pre>app$set_logger(logger_switch(warning =, 
                             error = logger_file('errors.log),
                             default = logger_file('info.log')))
</pre></div>


<h3>Automatic logs</h3>

<p><code>fiery</code> logs a number of different information by itself describing its
operations during run. The following events are send to the log:
</p>

<dl>
<dt><em>start</em></dt><dd><p>Will be send when the server starts up</p>
</dd>
<dt><em>resume</em></dt><dd><p>Will be send when the server is resumed</p>
</dd>
<dt><em>stop</em></dt><dd><p>Will be send when the server stops</p>
</dd>
<dt><em>request</em></dt><dd><p>Will be send when a request has been handled. The message
will contain information about how long time it took to handle the request
or if it was denied.</p>
</dd>
<dt><em>websocket</em></dt><dd><p>Will be send every time a WebSocket connection is
established or closed as well as when a message is received or send</p>
</dd>
<dt><em>message</em></dt><dd><p>Will be send every time a message is emitted by an event
handler or delayed execution handler</p>
</dd>
<dt><em>warning</em></dt><dd><p>Will be send everytime a warning is emitted by an event
handler or delayed execution handler</p>
</dd>
<dt><em>error</em></dt><dd><p>Will be send everytime an error is signaled by an event
handler or delayed execution handler. In addition some internal functions
will also emit error event when exceptions are encountered</p>
</dd>
</dl>

<p>By default only <em>message</em>, <em>warning</em> and <em>error</em> events will be logged by
sending them to the error stream as a <code><a href="base.html#topic+message">message()</a></code>.
</p>


<h3>Access Logs</h3>

<p>Of particular interest are logs that detail requests made to the server.
These are the <code>request</code> events detailed above. There are different standards
for how requests are logged. <code>fiery</code> uses the <em>Common Log Format</em> by default,
but this can be modified by setting the <code>access_log_format</code> field to a
<a href="glue.html#topic+glue">glue</a> expression that has access to the following variables:
</p>

<dl>
<dt><code>start_time</code></dt><dd><p>The time the request was recieved</p>
</dd>
<dt><code>end_time</code></dt><dd><p>The time the response was send back</p>
</dd>
<dt><code>request</code></dt><dd><p>The <code>Request</code> object</p>
</dd>
<dt><code>response</code></dt><dd><p>The <code>Response</code> object</p>
</dd>
<dt><code>id</code></dt><dd><p>The client id</p>
</dd>
</dl>

<p>To change the format:
</p>
<div class="sourceCode"><pre>app$access_log_format &lt;- combined_log_format
</pre></div>


<h3>Custom logs</h3>

<p>Apart from the standard logs described above it is also possible to send
messages to the log as you please, e.g. inside event handlers. This is done
through the <code>log()</code> method where you at the very least specify an event and a
message. In general it is better to send messages through <code>log()</code> rather than
with <code>warning()</code> and <code>stop()</code> even though the latters will eventually be
caught, as it gives you more control over the logging and what should happen
in the case of an exception.
</p>
<p>An example of using <code>log()</code> in a handler could be:
</p>
<div class="sourceCode"><pre>app$on('header', function(server, id, request) {
  server$log('info', paste0('request from ', id, ' received'), request)
})
</pre></div>
<p>Which would log the timepoint the headers of a request has been recieved.
</p>

<hr>
<h2 id='random_port'>Select a random safe port</h2><span id='topic+random_port'></span>

<h3>Description</h3>

<p>This is a small utility function to get random safe ports to run your
application on. It chooses a port within the range that cannot be registeret
to IANA and thus is safe to assume are not in use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_port()
</code></pre>


<h3>Value</h3>

<p>An integer in the range 49152-65535
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_port()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
