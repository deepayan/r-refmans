<!DOCTYPE html><html><head><title>Help for package PBSmapping</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PBSmapping}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PBSmapping'><p>PBS Mapping: Draw Maps and Implement Other GIS Procedures</p></a></li>
<li><a href='#addBubbles'>
<p>Add Bubbles to Maps</p></a></li>
<li><a href='#addCompass'>
<p>Add Compass Rose to Map</p></a></li>
<li><a href='#addLabels'><p>Add Labels to an Existing Plot</p></a></li>
<li><a href='#addLines'><p>Add a PolySet to an Existing Plot as Polylines</p></a></li>
<li><a href='#addPoints'><p>Add EventData/PolyData to an Existing Plot as Points</p></a></li>
<li><a href='#addPolys'><p>Add a PolySet to an Existing Plot as Polygons</p></a></li>
<li><a href='#addStipples'><p>Add Stipples to an Existing Plot</p></a></li>
<li><a href='#appendPolys'><p>Append a Two-Column Matrix to a PolySet</p></a></li>
<li><a href='#bcBathymetry'><p>Data: Bathymetry Spanning BC Coast</p></a></li>
<li><a href='#calcArea'><p>Calculate the Areas of Polygons</p></a></li>
<li><a href='#calcCentroid'><p>Calculate the Centroids of Polygons</p></a></li>
<li><a href='#calcConvexHull'><p>Calculate the Convex Hull for a Set of Points</p></a></li>
<li><a href='#calcGCdist'>
<p>Calculate Great-Circle Distance</p></a></li>
<li><a href='#calcLength'><p>Calculate the Length of Polylines</p></a></li>
<li><a href='#calcMidRange'><p>Calculate the Midpoint of the X/Y Ranges of Polygons</p></a></li>
<li><a href='#calcSummary'><p>Apply Functions to Polygons in a PolySet</p></a></li>
<li><a href='#calcVoronoi'><p>Calculate the Voronoi (Dirichlet) Tesselation for a Set of Points</p></a></li>
<li><a href='#clipLines'><p>Clip a PolySet as Polylines</p></a></li>
<li><a href='#clipPolys'><p>Clip a PolySet as Polygons</p></a></li>
<li><a href='#closePolys'><p>Close a PolySet</p></a></li>
<li><a href='#combineEvents'><p>Combine Measurements of Events</p></a></li>
<li><a href='#combinePolys'><p>Combine Several Polygons into a Single Polygon</p></a></li>
<li><a href='#convCP'><p>Convert Contour Lines into a PolySet</p></a></li>
<li><a href='#convDP'><p>Convert EventData/PolyData into a PolySet</p></a></li>
<li><a href='#convLP'><p>Convert Polylines into a Polygon</p></a></li>
<li><a href='#convUL'><p>Convert Coordinates between UTM and Lon/Lat</p></a></li>
<li><a href='#dividePolys'><p>Divide a Single Polygon into Several Polygons</p></a></li>
<li><a href='#dot-is.in'>
<p>Are Points in Polygons?</p></a></li>
<li><a href='#dot-PBSfigs'>
<p>Run PBSmapping Example Figures</p></a></li>
<li><a href='#dot-PBSmapEnv'><p>PBSmapping Environment</p></a></li>
<li><a href='#EventData'><p>EventData Objects</p></a></li>
<li><a href='#extractPolyData'><p>Extract PolyData from a PolySet</p></a></li>
<li><a href='#findCells'><p>Find Grid Cells that Contain Events</p></a></li>
<li><a href='#findPolys'><p>Find Polygons that Contain Events</p></a></li>
<li><a href='#fixBound'><p>Fix the Boundary Points of a PolySet</p></a></li>
<li><a href='#fixPOS'><p>Fix the POS Column of a PolySet</p></a></li>
<li><a href='#importEvents'><p>Import EventData from a Text File</p></a></li>
<li><a href='#importGSHHS'><p>Import Data from a GSHHS Database</p></a></li>
<li><a href='#importLocs'><p>Import LocationSet from Text File</p></a></li>
<li><a href='#importPolys'><p>Import PolySet from Text File</p></a></li>
<li><a href='#isConvex'><p>Determine Whether Polygons are Convex</p></a></li>
<li><a href='#isIntersecting'><p>Determine Whether Polygons are Self-Intersecting</p></a></li>
<li><a href='#joinPolys'><p>Join One or Two PolySets using a Logic Operation</p></a></li>
<li><a href='#locateEvents'><p>Locate Events on the Current Plot</p></a></li>
<li><a href='#locatePolys'><p>Locate Polygons on the Current Plot</p></a></li>
<li><a href='#LocationSet'><p>LocationSet Objects</p></a></li>
<li><a href='#makeGrid'><p>Make a Grid of Polygons</p></a></li>
<li><a href='#makeProps'><p>Make Polygon Properties</p></a></li>
<li><a href='#makeTopography'>
<p>Make Topography Data from Online Source</p></a></li>
<li><a href='#nepacLL'>
<p>Data: Shorelines of the NE Pacific Ocean and of the World</p></a></li>
<li><a href='#PBSprint'><p>Specify Whether to Print Summaries</p></a></li>
<li><a href='#placeHoles'>
<p>Place Holes Under Solids</p></a></li>
<li><a href='#plotLines'><p>Plot a PolySet as Polylines</p></a></li>
<li><a href='#plotMap'><p>Plot a PolySet as a Map</p></a></li>
<li><a href='#plotPoints'><p>Plot EventData/PolyData as Points</p></a></li>
<li><a href='#plotPolys'><p>Plot a PolySet as Polygons</p></a></li>
<li><a href='#PolyData'><p>PolyData Objects</p></a></li>
<li><a href='#PolySet'><p>PolySet Objects</p></a></li>
<li><a href='#print'><p>Print PBS Mapping Objects</p></a></li>
<li><a href='#pythagoras'><p>Data: Pythagoras' Theorem Diagram PolySet</p></a></li>
<li><a href='#refocusWorld'><p>Refocus the <code>worldLL</code>/<code>worldLLhigh</code> Data Sets</p></a></li>
<li><a href='#RGB2RYB'>
<p>Convert RGB to RYB and RYB to RGB</p></a></li>
<li><a href='#rotatePolys'>
<p>Rotate Polygons and Events</p></a></li>
<li><a href='#summary'><p>Summarize PBS Mapping Objects</p></a></li>
<li><a href='#surveyData'><p>Data: Tow Information from Pacific Ocean Perch Survey</p></a></li>
<li><a href='#thickenPolys'><p>Thicken a PolySet of Polygons</p></a></li>
<li><a href='#thinPolys'><p>Thin a PolySet of Polygons</p></a></li>
<li><a href='#towData'><p>Data: Tow Information from Longspine Thornyhead Survey</p></a></li>
<li><a href='#towTracks'><p>Data: Tow Track Polylines from Longspine Thornyhead Survey</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.73.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Mapping Fisheries Data and Spatial Analysis Tools</td>
</tr>
<tr>
<td>Author:</td>
<td>Jon T. Schnute [aut],
  Nicholas Boers [aut],
  Rowan Haigh [aut, cre],
  Alex Couture-Beil [ctb],
  Denis Chabot [ctb],
  Chris Grandin [ctb],
  Alan Murta [ctb],
  Angus Johnson [ctb],
  Paul Wessel [ctb],
  Franklin Antonio [ctb],
  Nicholas J. Lewin-Koh [ctb],
  Roger Bivand [ctb],
  Sean Anderson [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rowan Haigh &lt;rowan.haigh@dfo-mpo.gc.ca&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>2003-2023, Fisheries and Oceans Canada</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>foreign, deldir</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>This software has evolved from fisheries research conducted at the
   Pacific Biological Station (PBS) in 'Nanaimo', British Columbia, Canada. It
   extends the R language to include two-dimensional plotting features similar
   to those commonly available in a Geographic Information System (GIS).
   Embedded C code speeds algorithms from computational geometry, such as
   finding polygons that contain specified point events or converting between
   longitude-latitude and Universal Transverse Mercator (UTM) coordinates.
   Additionally, we include 'C++' code developed by Angus Johnson for the
   'Clipper' library, data for a global shoreline, and other data sets in the
   public domain. Under the user's R library directory '.libPaths()',
   specifically in './PBSmapping/doc', a complete user's guide is offered and
   should be consulted to use package functions effectively.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pbs-software/pbs-mapping">https://github.com/pbs-software/pbs-mapping</a>,
<a href="https://github.com/pbs-software/pbs-mapx">https://github.com/pbs-software/pbs-mapx</a>,
<a href="https://www.angusj.com/delphi/clipper.php">https://www.angusj.com/delphi/clipper.php</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-03 20:43:21 UTC; HaighR</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-04 03:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PBSmapping'>PBS Mapping: Draw Maps and Implement Other GIS Procedures</h2><span id='topic+PBSmapping'></span><span id='topic+PBSmapping-package'></span>

<h3>Description</h3>

<p>This software has evolved from fisheries research
conducted at the Pacific Biological Station (PBS) in Nanaimo,
British Columbia, Canada. It extends the R language to include
two-dimensional plotting features similar to those commonly
available in a Geographic Information System (GIS).  Embedded
C code speeds algorithms from computational geometry, such as
finding polygons that contain specified point events or
converting between longitude-latitude and Universal Transverse
Mercator (UTM) coordinates.  It includes data for a global
shoreline and other data sets in the public domain.
</p>
<p>For a complete user's guide, see the file <code>PBSmapping-UG.pdf</code> 
in the R directory <code>.../library/PBSmapping/doc</code>.
</p>
<p><code>PBSmapping</code> includes 10 demos that appear as figures in 
the User's Guide. To see them, run the function <code>.PBSfigs()</code>.
</p>
<p>More generally, a user can view all demos available from locally 
installed packages with the function <code>runDemos()</code> in our 
related (and recommended) package <code>PBSmodelling</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2008-09-03</code>
</p>

<hr>
<h2 id='addBubbles'>
Add Bubbles to Maps
</h2><span id='topic+addBubbles'></span>

<h3>Description</h3>

<p>Add bubbles proportional to some <code>EventData</code>'s <code>Z</code> column
(e.g., catch or effort) to an existing plot, where each unique
<code>EID</code> describes a bubble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addBubbles(events, type=c("perceptual","surface","volume"),
   z.max=NULL, min.size=0, max.size=0.8, symbol.zero="+",
   symbol.fg=rgb(0,0,0,0.60), symbol.bg=rgb(0,0,0,0.30),
   legend.pos="bottomleft", legend.breaks=NULL,
   show.actual=FALSE, legend.type=c("nested","horiz","vert"),
   legend.title="Abundance", legend.cex=.8, neg.col="RYB", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addBubbles_+3A_events">events</code></td>
<td>
<p><a href="#topic+EventData">EventData</a> to use (<em>required</em>).</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_type">type</code></td>
<td>
<p><code>character</code> &ndash; scaling option for bubbles where <code>"perceptual"</code>
emphasizes large z-values, <code>"volume"</code> emphasizes small z-values,
and <code>"surface"</code> lies in between.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_z.max">z.max</code></td>
<td>
<p><code>numeric</code> &ndash; maximum value for z (default = <code>max(events$Z)</code>);
determines the largest bubble; keeps the same legend for different maps.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_min.size">min.size</code></td>
<td>
<p><code>numeric</code> &ndash; minimum size (inches) for a bubble representing
<code>min(events$Z)</code>.  The legend may not actually include a bubble of
this size because the calculated legend.breaks does not include the <code>min(events$Z)</code>.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_max.size">max.size</code></td>
<td>
<p><code>numeric</code> &ndash; maximum size (inches) for a bubble representing
<code>z.max</code>.  A legend bubble may exceed this size when
<code>show.actual</code> is <code>FALSE</code> (on account of using <code>pretty(...)</code>).</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_symbol.zero">symbol.zero</code></td>
<td>
<p><code>character</code> &ndash; symbol to represent z-values equal to 0.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_symbol.fg">symbol.fg</code></td>
<td>
<p><code>character</code> &ndash; bubble outline (border) colour.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_symbol.bg">symbol.bg</code></td>
<td>
<p><code>character</code> &ndash; bubble interior (fill) colour.  If a vector, the
first element represents <code>min(legend.breaks)</code> and the last
element represents <code>max(legend.breaks)</code>; colours are interpolated
for values of <code>events$Z</code> between those boundaries.  For values
outside of those boundaries, interiors remain unfilled.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_legend.pos">legend.pos</code></td>
<td>
<p><code>character|numeric</code> &ndash; position for the legend.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_legend.breaks">legend.breaks</code></td>
<td>
<p><code>numeric</code> &ndash; break values for categorizing the z-values.
The automatic method should work if zeroes are present;
otherwise, you can specify your own break values for the legend.
If a single number, specifies the number of breaks; if a vector,
specifies the breaks.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_show.actual">show.actual</code></td>
<td>
<p><code>logical</code> &ndash; if <code>FALSE</code>, legend values are
obtained using <code>pretty(...)</code>, and consequently, the largest
bubble may be larger than <code>z.max</code>; if <code>TRUE</code>, the largest
bubble in the legend will correspond to <code>z.max</code>.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_legend.type">legend.type</code></td>
<td>
<p><code>character</code> &ndash; display format for legend.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_legend.title">legend.title</code></td>
<td>
<p><code>character</code> &ndash; title for legend.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_legend.cex">legend.cex</code></td>
<td>
<p><code>numeric</code> &ndash; size of legend text.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_neg.col">neg.col</code></td>
<td>
<p><code>character</code> &ndash; bubble colour for any potential negative values.</p>
</td></tr>
<tr><td><code id="addBubbles_+3A_...">...</code></td>
<td>
<p><code>dots</code> &ndash; additional arguments for <code>points</code> function that plots zero-value symbols.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modified from (and for the legend, strongly inspired by) Tanimura
et al. (2006) by Denis Chabot to work with <span class="pkg">PBSmapping</span>.
</p>
<p>Furthermore, Chabot's modifications make it possible to draw
several maps with bubbles that all have the same scale
(instead of each bubble plot having a scale that depends on
the maximum z-value for that plot).
This is done by making <code>z.max</code> equal to the largest z-value
from all maps that will be plotted.
</p>
<p>The user can also add a legend in one of four corners
(see <code><a href="graphics.html#topic+legend">legend</a></code>) or at a specific <code>c(X,Y)</code> position.
If <code>legend.pos</code> is <code>NULL</code>, no legend is drawn.
</p>


<h3>Author(s)</h3>

<p><a href="https://profils-profiles.science.gc.ca/en/profile/denis-chabot">Denis Chabot</a>, Research Scientist<br />
Maurice-Lamontagne Institute, Fisheries &amp; Oceans Canada (DFO), Mont-Joli QC<br />
</p>
<p>Maintainer: <a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Offsite, Vancouver BC<br />
Last modified <code>Rd: 2023-11-02</code>
</p>


<h3>References</h3>

<p>Tanimura, S., Kuroiwa, C., and Mizota, T. (2006)
Proportional symbol mapping in R.
<em>Journal of Statistical Software</em> <b>15</b>(5).
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+EventData">EventData</a></code>,
<code><a href="#topic+RGB2RYB">RGB2RYB</a></code>,
<code><a href="#topic+surveyData">surveyData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- common code for both examples below
  data(nepacLL,surveyData,envir=.PBSmapEnv)
  surveyData$Z &lt;- surveyData$catch

  #--- plot a version that only varies the size
  plotMap(nepacLL, xlim=c(-131.8,-127.2), ylim=c(50.5,52.7),
    col="gainsboro",plt=c(.08,.99,.08,.99), cex.axis=1.2, cex.lab=1.5)
  addBubbles(surveyData, symbol.bg=rgb(.9,.5,0,.6),
    legend.type="nested", symbol.zero="+", col="grey")

  #--- plot a version that uses different symbol colours
  plotMap(nepacLL, xlim=c(-131.8,-127.2), ylim=c(50.5,52.7),
  col="gainsboro",plt=c(.08,.99,.08,.99), cex.axis=1.2, cex.lab=1.5)
  subset &lt;- surveyData[surveyData$Z &lt;= 1000, ]
  addBubbles(subset, symbol.bg=c("red", "yellow", "green"),
    legend.type="horiz", legend.breaks=pretty(range(subset$Z), n=11),
    symbol.zero=FALSE, col="grey", min.size=0.1, max.size=0.4)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='addCompass'>
Add Compass Rose to Map
</h2><span id='topic+addCompass'></span>

<h3>Description</h3>

<p>Add a compass rose to an existing map, similar to those found on 
nautical charts showing both true north and magnetic north.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCompass(X, Y, rot="magN", useWest=TRUE, year,
   cex=1, col.compass=c("gainsboro","blue","yellow","black"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCompass_+3A_x">X</code></td>
<td>
<p><code>numeric</code> &ndash; longitude coordinate (degrees N) for centroid of compass rose.</p>
</td></tr>
<tr><td><code id="addCompass_+3A_y">Y</code></td>
<td>
<p><code>numeric</code> &ndash; latitude coordinate (degrees W) for centroid of compass rose.</p>
</td></tr>
<tr><td><code id="addCompass_+3A_rot">rot</code></td>
<td>
<p><code>numeric|character</code> &ndash; Rotation (degrees) counterclockwise from 0 degrees (true North, see details).</p>
</td></tr>
<tr><td><code id="addCompass_+3A_usewest">useWest</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, assumes longitude coordinates are centered on Greenwich extending westward to -180 and eastward to 180.</p>
</td></tr>
<tr><td><code id="addCompass_+3A_year">year</code></td>
<td>
<p><code>numeric</code> &ndash; specific year to use from IGRF-13 (see details).</p>
</td></tr>
<tr><td><code id="addCompass_+3A_cex">cex</code></td>
<td>
<p><code>numeric</code> &ndash; character expansion to use in the display.</p>
</td></tr>
<tr><td><code id="addCompass_+3A_col.compass">col.compass</code></td>
<td>
<p><code>character</code> &ndash; colours for compass rose components (in order):<br />
1=background compass, 2=rotated arms, 3=central button, 4=pch (border).</p>
</td></tr>
<tr><td><code id="addCompass_+3A_...">...</code></td>
<td>
<p><code>dots</code> &ndash; additional parameters to pass to the <code>text</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic idea comes from Jim Lemon (see References), but is modified here
to reflect a compass rose used on BC nautical charts.
</p>
<p>The default rotation (<code>"magN"</code>) is a calculation of the initial
bearing of a great-circle arc from the compass position to the north
geomagnetic rot using the function <code><a href="#topic+calcGCdist">calcGCdist</a></code>.
The default year is the current year, but the user can choose years from
1900 to 2025 for approximate rot locations using model output from NOAA's IGRF-13
(<a href="https://www.ngdc.noaa.gov/IAGA/vmod/igrf.html">International Geomagnetic Reference Field</a>).
</p>
<p>The user can also specify a fixed rotation (e.g. <code>rot=-30</code>) or no
rotation (either <code>rot=0</code> or <code>rot="trueN"</code>).
</p>


<h3>Value</h3>

<p>No value returned.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Regional Headquarters, Vancouver BC<br />
Last modified <code>Rd: 2022-07-05</code>
</p>


<h3>References</h3>

<p><a href="https://stat.ethz.ch/pipermail/r-sig-geo/2010-February/007564.html">
[R-sig-Geo] How to display a compass rose on a map</a>
</p>
<p><a href="https://wdc.kugi.kyoto-u.ac.jp/poles/polesexp.html">
Magnetic North, Geomagnetic and Magnetic Poles</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addBubbles">addBubbles</a></code>,
<code><a href="#topic+addLabels">addLabels</a></code>,
<code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+addStipples">addStipples</a></code>,
<code><a href="#topic+calcGCdist">calcGCdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  data(nepacLL,envir=.PBSmapEnv)
  par(mfrow=c(1,1),mar=c(3,4,0.5,0.5))
  plotMap(nepacLL, xlim=c(-134.5,-124.5), ylim=c(48,55), plt=NULL,
    col="lightyellow", cex.axis=1.2, cex.lab=1.5)
  addCompass(-132, 49.5, rot=-12, cex=1.5)
})
</code></pre>

<hr>
<h2 id='addLabels'>Add Labels to an Existing Plot</h2><span id='topic+addLabels'></span>

<h3>Description</h3>

<p>Add the <code>label</code> column of <code>data</code> to the existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLabels (data, xlim = NULL, ylim = NULL, polyProps = NULL,
           placement = "DATA", polys = NULL, rollup = 3,
           cex = NULL, col = NULL, font = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLabels_+3A_data">data</code></td>
<td>
<p><a href="#topic+EventData">EventData</a> or <a href="#topic+PolyData">PolyData</a> to add (<em>required</em>).</p>
</td></tr>
<tr><td><code id="addLabels_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_polyprops">polyProps</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> specifying which labels to plot and their
properties.  <code><a href="graphics.html#topic+par">par</a></code> parameters passed as direct arguments
supersede these data.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_placement">placement</code></td>
<td>
<p>one of <code>"DATA"</code>, <code>"CENTROID"</code>,
<code>"MEAN_RANGE"</code>, or <code>"MEAN_XY"</code>.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use for calculating label placement.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_rollup">rollup</code></td>
<td>
<p>level of detail at which to process <code>polys</code>, and it
should match that in <code>data</code>.  <code>1</code> = <code>PID</code>s only,
<code>2</code> = outer contours only, and <code>3</code> = no roll-up.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_cex">cex</code></td>
<td>
<p>vector describing character expansion factors (cycled by
<code>EID</code> or <code>PID</code>).</p>
</td></tr>
<tr><td><code id="addLabels_+3A_col">col</code></td>
<td>
<p>vector describing colours (cycled by <code>EID</code> or
<code>PID</code>).</p>
</td></tr>
<tr><td><code id="addLabels_+3A_font">font</code></td>
<td>
<p>vector describing fonts (cycled by <code>EID</code> or
<code>PID</code>).</p>
</td></tr>
<tr><td><code id="addLabels_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters for the
<code><a href="graphics.html#topic+text">text</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> is <a href="#topic+EventData">EventData</a>, it must minimally contain the columns
<code>EID</code>, <code>X</code>, <code>Y</code>, and <code>label</code>.  Since the
<code>EID</code> column does not match a column in <code>polys</code>, set
<code>placement = "DATA"</code>.  The function plots each <code>label</code> at
its corresponding <code>X</code>/<code>Y</code> coordinate.
</p>
<p>If <code>data</code> is <a href="#topic+PolyData">PolyData</a>, it must minimally contain the columns
<code>PID</code> and <code>label</code>.  If it also contains <code>X</code> and
<code>Y</code> columns, set <code>placement = "DATA"</code> to plot labels at
those coordinates.  Otherwise, set <code>placement</code> to one of
<code>"CENTROID"</code>, <code>"MEAN_RANGE"</code>, or <code>"MEAN_XY"</code>.  When
<code>placement != "DATA"</code>, supply a <a href="#topic+PolySet">PolySet</a> <code>polys</code>.  Using this
<a href="#topic+PolySet">PolySet</a>, the function calculates a centroid, mean range, or mean X/Y
coordinate for each polygon, and then links those <a href="#topic+PolyData">PolyData</a> with
<code>data</code> by <code>PID</code>/<code>SID</code> to determine label
coordinates.
</p>
<p>If <code>data</code> contains both <code>PID</code> and <code>EID</code> columns, the
function assumes it is <a href="#topic+PolyData">PolyData</a> and ignores the <code>EID</code>
column.
</p>
<p>For additional help on the arguments <code>cex</code>, <code>col</code>, and
<code>font</code>, please see <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+EventData">EventData</a> or <a href="#topic+PolyData">PolyData</a> with <code>X</code> and <code>Y</code> columns
that can subsequently reproduce the labels on the plot.  Modify this
data frame to tweak label positions.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+calcCentroid">calcCentroid</a></code>,
<code><a href="#topic+calcMidRange">calcMidRange</a></code>,
<code><a href="#topic+calcSummary">calcSummary</a></code>,
<a href="#topic+EventData">EventData</a>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<a href="#topic+PolyData">PolyData</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create sample PolyData to label Vancouver Island
  labelData &lt;- data.frame(PID=33, label="Vancouver Island");
  #--- load data
  if (!is.null(version$language) &amp;&amp; (version$language == "R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- plot the map
  plotMap(nepacLL,xlim=c(-129,-122.6),ylim=c(48,51.1),col="lemonchiffon")
  #--- add the labels
  addLabels(labelData,placement="CENTROID",polys=nepacLL,cex=1.2,col=2,font=2)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='addLines'>Add a PolySet to an Existing Plot as Polylines</h2><span id='topic+addLines'></span>

<h3>Description</h3>

<p>Add a <a href="#topic+PolySet">PolySet</a> to an existing plot, where each unique (<code>PID</code>,
<code>SID</code>) describes a polyline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLines (polys, xlim = NULL, ylim = NULL,
    polyProps = NULL, lty = NULL, col = NULL, arrows = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLines_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to add (<em>required</em>).</p>
</td></tr>
<tr><td><code id="addLines_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="addLines_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="addLines_+3A_polyprops">polyProps</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> specifying which polylines to plot and their
properties.  <code><a href="graphics.html#topic+par">par</a></code> parameters passed as direct arguments
supersede these data.</p>
</td></tr>
<tr><td><code id="addLines_+3A_lty">lty</code></td>
<td>
<p>vector of line types (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="addLines_+3A_col">col</code></td>
<td>
<p>vector of colours (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="addLines_+3A_arrows">arrows</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, add arrows using the
<a href="graphics.html#topic+arrows">arrows</a> function and consider the arguments <code>angle</code>,
<code>length</code>, and <code>code</code>.</p>
</td></tr>
<tr><td><code id="addLines_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters for the
<code><a href="graphics.html#topic+lines">lines</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plotting routine does not connect the last vertex of each discrete
polyline to the first vertex of that polyline. It clips <code>polys</code>
to <code>xlim</code> and <code>ylim</code> before plotting.
</p>
<p>For additional help on the arguments <code>lty</code> and <code>col</code>, please
see <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> consisting of the <code>PolyProp</code>s used to create the plot.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcLength">calcLength</a></code>,
<code><a href="#topic+clipLines">clipLines</a></code>,
<code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+convLP">convLP</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>,
<code><a href="#topic+plotLines">plotLines</a></code>,
<code><a href="#topic+thinPolys">thinPolys</a></code>,
<code><a href="#topic+thickenPolys">thickenPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create a PolySet to plot
  polys &lt;- data.frame(PID=rep(1,4),POS=1:4,X=c(0,1,1,0),Y=c(0,0,1,1))
  polys &lt;- as.PolySet(polys, projection=1)
  #--- plot the PolySet
  plotLines(polys, xlim=c(-.5,1.5), ylim=c(-.5,1.5), projection=1)
  #--- add the PolySet to the plot (in a different style)
  addLines(polys, lwd=5, col=3)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='addPoints'>Add EventData/PolyData to an Existing Plot as Points</h2><span id='topic+addPoints'></span>

<h3>Description</h3>

<p>Add <a href="#topic+EventData">EventData</a>/<a href="#topic+PolyData">PolyData</a> to an existing plot, where each
unique <code>EID</code> describes a point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPoints (data, xlim = NULL, ylim = NULL, polyProps = NULL,
           cex = NULL, col = NULL, pch = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPoints_+3A_data">data</code></td>
<td>
<p><a href="#topic+EventData">EventData</a> or <a href="#topic+PolyData">PolyData</a> to add (<em>required</em>).</p>
</td></tr>
<tr><td><code id="addPoints_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="addPoints_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="addPoints_+3A_polyprops">polyProps</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> specifying which points to plot and their
properties.  <code><a href="graphics.html#topic+par">par</a></code> parameters passed as direct arguments
supersede these data.</p>
</td></tr>
<tr><td><code id="addPoints_+3A_cex">cex</code></td>
<td>
<p>vector describing character expansion factors (cycled by
<code>EID</code> or <code>PID</code>).</p>
</td></tr>
<tr><td><code id="addPoints_+3A_col">col</code></td>
<td>
<p>vector describing colours (cycled by <code>EID</code> or
<code>PID</code>).</p>
</td></tr>
<tr><td><code id="addPoints_+3A_pch">pch</code></td>
<td>
<p>vector describing plotting characters (cycled by <code>EID</code>
or <code>PID</code>).</p>
</td></tr>
<tr><td><code id="addPoints_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters for the
<code><a href="graphics.html#topic+points">points</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function clips <code>data</code> to <code>xlim</code> and <code>ylim</code> before
plotting.  It only adds <a href="#topic+PolyData">PolyData</a> containing <code>X</code> and
<code>Y</code> columns.
</p>
<p>For additional help on the arguments <code>cex</code>, <code>col</code>, and
<code>pch</code>, please see <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> consisting of the <code>PolyProp</code>s used to create the plot.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineEvents">combineEvents</a></code>,
<code><a href="#topic+convDP">convDP</a></code>,
<code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+locateEvents">locateEvents</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,surveyData,envir=.PBSmapEnv)
  #--- plot a map
  plotMap(nepacLL, xlim=c(-136, -125), ylim=c(48, 57))
  #--- add events
  addPoints(surveyData, col=1:7)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='addPolys'>Add a PolySet to an Existing Plot as Polygons</h2><span id='topic+addPolys'></span>

<h3>Description</h3>

<p>Add a <a href="#topic+PolySet">PolySet</a> to an existing plot, where each unique (<code>PID</code>,
<code>SID</code>) describes a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPolys (polys, xlim = NULL, ylim = NULL, polyProps = NULL,
          border = NULL, lty = NULL, col = NULL, colHoles = NULL,
          density = NA, angle = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPolys_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to add (<em>required</em>).</p>
</td></tr>
<tr><td><code id="addPolys_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="addPolys_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="addPolys_+3A_polyprops">polyProps</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> specifying which polygons to plot and their
properties.  <code><a href="graphics.html#topic+par">par</a></code> parameters passed as direct arguments
supersede these data.</p>
</td></tr>
<tr><td><code id="addPolys_+3A_border">border</code></td>
<td>
<p>vector describing edge colours (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="addPolys_+3A_lty">lty</code></td>
<td>
<p>vector describing line types (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="addPolys_+3A_col">col</code></td>
<td>
<p>vector describing fill colours (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="addPolys_+3A_colholes">colHoles</code></td>
<td>
<p>vector describing hole colours (cycled by <code>PID</code>).
The default, <code>NULL</code>, should be used in most cases as it renders holes 
transparent. <code>colHoles</code> is designed solely to eliminate retrace lines 
when images are converted to PDF format. If <code>colHoles</code> is specified, 
underlying information (i.e., previously plotted shapes) will be obliterated.
If <code>NA</code> is specified, only outer polygons are drawn, consequently filling holes.</p>
</td></tr>
<tr><td><code id="addPolys_+3A_density">density</code></td>
<td>
<p>vector describing shading line densities (lines per
inch, cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="addPolys_+3A_angle">angle</code></td>
<td>
<p>vector describing shading line angles (degrees, cycled by
<code>PID</code>).</p>
</td></tr>
<tr><td><code id="addPolys_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters for the
<code><a href="graphics.html#topic+polygon">polygon</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plotting routine connects the last vertex of each discrete polygon
to the first vertex of that polygon.  It supports both
borders (<code>border</code>, <code>lty</code>) and fills (<code>col</code>,
<code>density</code>, <code>angle</code>). It clips <code>polys</code> to <code>xlim</code>
and <code>ylim</code> before plotting.
</p>
<p>For additional help on the arguments <code>border</code>, <code>lty</code>,
<code>col</code>, <code>density</code>, and <code>angle</code>, please see
<code><a href="graphics.html#topic+polygon">polygon</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> consisting of the <code>PolyProp</code>s used to create the plot.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addLabels">addLabels</a></code>,
<code><a href="#topic+addStipples">addStipples</a></code>,
<code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>,
<code><a href="#topic+plotLines">plotLines</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<code><a href="#topic+plotPolys">plotPolys</a></code>,
<code><a href="#topic+thinPolys">thinPolys</a></code>,
<code><a href="#topic+thickenPolys">thickenPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create a PolySet to plot
  polys &lt;- data.frame(PID=rep(1,4),POS=1:4,X=c(0,1,1,0),Y=c(0,0,1,1))
  polys &lt;- as.PolySet(polys, projection=1)
  #--- plot the PolySet
  plotPolys(polys,xlim=c(-.5,1.5),ylim=c(-.5,1.5),density=0,projection=1)
  #--- add the PolySet to the plot (in a different style)
  addPolys(polys,col="green",border="blue",lwd=3)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='addStipples'>Add Stipples to an Existing Plot</h2><span id='topic+addStipples'></span>

<h3>Description</h3>

<p>Add stipples to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addStipples (polys, xlim=NULL, ylim=NULL, polyProps=NULL,
   side=1, density=1, distance=4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addStipples_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> that provides the stipple boundaries
(<em>required</em>).</p>
</td></tr>
<tr><td><code id="addStipples_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="addStipples_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="addStipples_+3A_polyprops">polyProps</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> specifying which polygons to stipple
and their properties.  <code><a href="graphics.html#topic+par">par</a></code> parameters passed as direct
arguments supersede these data.</p>
</td></tr>
<tr><td><code id="addStipples_+3A_side">side</code></td>
<td>
<p>one of <code>-1</code>, <code>0</code>, or <code>1</code>, corresponding to
outside, both sides, or inside, respectively.</p>
</td></tr>
<tr><td><code id="addStipples_+3A_density">density</code></td>
<td>
<p>density of points, relative to the default.</p>
</td></tr>
<tr><td><code id="addStipples_+3A_distance">distance</code></td>
<td>
<p>distance to offset points, measured as a percentage of
the absolute difference in <code>xlim</code>.</p>
</td></tr>
<tr><td><code id="addStipples_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters for the
<code><a href="graphics.html#topic+points">points</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function locates stipples based on the <a href="#topic+PolySet">PolySet</a>
<code>polys</code> and does not stipple degenerate lines.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> consisting of the <code>PolyProp</code>s used to create the plot.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<code><a href="#topic+plotPolys">plotPolys</a></code>,
<code><a href="graphics.html#topic+points">points</a></code>,
<a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- plot a map
  plotMap(nepacLL,xlim=c(-128.66,-122.83),ylim=c(48.00,51.16))
  #--- add stippling
  addStipples(nepacLL,col="purple",pch=20,cex=0.25,distance=2)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='appendPolys'>Append a Two-Column Matrix to a PolySet</h2><span id='topic+appendPolys'></span>

<h3>Description</h3>

<p>Append a two-column matrix to a <a href="#topic+PolySet">PolySet</a>, assigning <code>PID</code> and
possibly <code>SID</code> values automatically or as specified in its
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendPolys (polys, mat, PID = NULL, SID = NULL, isHole = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendPolys_+3A_polys">polys</code></td>
<td>
<p>existing <a href="#topic+PolySet">PolySet</a>; if <code>NULL</code>, creates a new
<a href="#topic+PolySet">PolySet</a> (<em>required</em>).</p>
</td></tr>
<tr><td><code id="appendPolys_+3A_mat">mat</code></td>
<td>
<p>two-column matrix to append (<em>required</em>).</p>
</td></tr>
<tr><td><code id="appendPolys_+3A_pid">PID</code></td>
<td>
<p>new polygon's <code>PID</code>.</p>
</td></tr>
<tr><td><code id="appendPolys_+3A_sid">SID</code></td>
<td>
<p>new polygon's <code>SID</code>.</p>
</td></tr>
<tr><td><code id="appendPolys_+3A_ishole">isHole</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, <code>mat</code> represents a
hole.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>PID</code> argument is <code>NULL</code>, the appended polygon's
<code>PID</code> will be one greater than the maximum within <code>polys</code>
(if defined); otherwise, it will be 1.
</p>
<p>If <code>polys</code> contains an <code>SID</code> column and the <code>SID</code>
argument equals <code>NULL</code>, this function uses the next available
<code>SID</code> for the corresponding <code>PID</code>.
</p>
<p>If <code>polys</code> does not contain an <code>SID</code> column and the
caller passes an <code>SID</code> argument, all existing polygons will
receive an <code>SID</code> of 1.  The new polygon's <code>SID</code> will
match the <code>SID</code> argument.
</p>
<p>If <code>isHole = TRUE</code>, the polygon's <code>POS</code> values will
appropriately represent a hole (reverse order of POS).
</p>
<p>If (<code>PID</code>, <code>SID</code>) already exists in the <a href="#topic+PolySet">PolySet</a>, the
function will issue a warning and duplicate those identifiers.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> containing <code>mat</code> appended to <code>polys</code>.  The
function retains attributes from <code>polys</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+convLP">convLP</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>,
<code><a href="#topic+joinPolys">joinPolys</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPolys">plotPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- create two simple matrices
  a &lt;- matrix(data=c(0,0,1,0,1,1,0,1),ncol=2,byrow=TRUE);
  b &lt;- matrix(data=c(2,2,3,2,3,3,2,3), ncol=2,byrow=TRUE);
  #--- build a PolySet from them
  polys &lt;- appendPolys(NULL, a);
  polys &lt;- appendPolys(polys, b);
  #--- print the result
  print (polys);
})
</code></pre>

<hr>
<h2 id='bcBathymetry'>Data: Bathymetry Spanning BC Coast</h2><span id='topic+bcBathymetry'></span>

<h3>Description</h3>

<p>Bathymetry data spanning British Columbia's coast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bcBathymetry)</code></pre>


<h3>Format</h3>

<p>Three-element list: <code>x</code> = vector of horizontal grid line
locations, <code>y</code> = vector of vertical grid line locations, <code>z</code>
= (<code>x</code> by <code>y</code>) matrix containing water depths measured in
meters.  Positive values indicate distance below sea level and
negative values above it.
</p>
<p>The functions <code>'graphics::contour'</code> and <code>'grDevices::contourLines'</code> expect data in this format.
Function <code><a href="#topic+convCP">convCP</a></code> converts the output from <code>'grDevices::contourLines'</code> into a <a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Note</h3>

<p>In R, the data must be loaded using the <code>'utils::data'</code> function.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
</p>
<p>Maintainer: <a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Regional Headquarters, Vancouver BC<br />
Last modified <code>Rd: 2022-07-07</code>
</p>


<h3>Source</h3>

<p>Bathymetry data acquired from the Scripps Institution of Oceanography
at the University of San Diego.
</p>
<p>Using their online form, we requested bathymetry data for the complete
<code><a href="#topic+nepacLL">nepacLL</a></code> region.
At forty megabytes, the data were not suitable for distribution in our mapping package.
Therefore, we reduced the data to the range <code class="reqn">-140^\circ \le x \le -122^\circ</code>
and <code class="reqn">47^\circ \le y \le 61^\circ</code>.
</p>


<h3>References</h3>

<p>Smith, W.H.F. and Sandwell, D.T. (1997)
<a href="https://www.science.org/doi/10.1126/science.277.5334.1956">Global seafloor topography from satellite altimetry and ship depth soundings</a>.
<em>Science</em> <b>277</b>, 1957-1962. <br />
Website: <a href="https://topex.ucsd.edu/WWW_html/mar_topo.html">https://topex.ucsd.edu/WWW_html/mar_topo.html</a>
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">graphics</span>:<br />
<code><a href="graphics.html#topic+contour">contour</a></code><br />
In package <span class="pkg">grDevices</span>:<br />
<code><a href="grDevices.html#topic+contourLines">contourLines</a></code><br />
In package <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+convCP">convCP</a></code>,
<code><a href="#topic+nepacLL">nepacLL</a></code>,
<code><a href="#topic+nepacLLhigh">nepacLLhigh</a></code>
</p>

<hr>
<h2 id='calcArea'>Calculate the Areas of Polygons</h2><span id='topic+calcArea'></span>

<h3>Description</h3>

<p>Calculate the areas of polygons found in a <a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcArea (polys, rollup = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcArea_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
<tr><td><code id="calcArea_+3A_rollup">rollup</code></td>
<td>
<p>level of detail in the results; <code>1</code> = <code>PID</code>s
only, by summing all the polygons with the same <code>PID</code>, <code>2</code> =
outer contours only, by subtracting holes from their parent, and
<code>3</code> = no roll-up.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>rollup</code> equals <code>1</code>, the results contain an area for each
unique <code>PID</code> only.  When it equals <code>2</code>, they contain entries
for outer contours only.  Finally, setting it to <code>3</code> prevents
roll-up, and they contain areas for each unique (<code>PID</code>,
<code>SID</code>).
</p>
<p>Outer polygons have positive areas and inner polygons negative areas.
When polygons are rolled up, the routine sums the positive and
negative areas and consequently accounts for holes.
</p>
<p>If the <a href="#topic+PolySet">PolySet</a>'s <code>projection</code> attribute equals
<code>"LL"</code>, the function projects the <a href="#topic+PolySet">PolySet</a> in UTM first.
If the <a href="#topic+PolySet">PolySet</a>'s <code>zone</code> attribute exists, it uses it for
the conversion.  Otherwise, it computes the mean longitude and uses
that value to determine the zone.  The longitude range of zone
<code class="reqn">i</code> is <code class="reqn">-186 + 6 i^\circ &lt; x \le -180 + 6 i^\circ</code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with columns <code>PID</code>, <code>SID</code> (<em>may be
missing</em>), and <code>area</code>.  If the projection equals <code>"LL"</code> or
<code>"UTM"</code>, the units of area are square kilometres.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2022-09-06</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcCentroid">calcCentroid</a></code>,
<code><a href="#topic+calcLength">calcLength</a></code>,
<code><a href="#topic+calcMidRange">calcMidRange</a></code>,
<code><a href="#topic+calcSummary">calcSummary</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language == "R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- convert LL to UTM so calculation makes sense
  attr(nepacLL, "zone") &lt;- 9
  nepacUTM &lt;- convUL(nepacLL)
  #--- calculate and print the areas
  print(calcArea(nepacUTM))
})
</code></pre>

<hr>
<h2 id='calcCentroid'>Calculate the Centroids of Polygons</h2><span id='topic+calcCentroid'></span>

<h3>Description</h3>

<p>Calculate the centroids of polygons found in a <a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcCentroid (polys, rollup = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcCentroid_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
<tr><td><code id="calcCentroid_+3A_rollup">rollup</code></td>
<td>
<p>level of detail in the results; <code>1</code> = <code>PID</code>s
only, <code>2</code> = outer contours only, and <code>3</code> = no roll-up.  When
<code>rollup</code> equals <code>1</code> and <code>2</code>, the function appropriately
adjusts for polygons with holes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>rollup</code> equals <code>1</code>, the results contain a centroid for
each unique <code>PID</code> only.  When it equals <code>2</code>, they contain
entries for outer contours only.  Finally, setting it to <code>3</code>
prevents roll-up, and they contain a centroid for each unique
(<code>PID</code>, <code>SID</code>).
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with columns <code>PID</code>, <code>SID</code> (<em>may be missing</em>),
<code>X</code>, and <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcArea">calcArea</a></code>,
<code><a href="#topic+calcLength">calcLength</a></code>,
<code><a href="#topic+calcMidRange">calcMidRange</a></code>,
<code><a href="#topic+calcSummary">calcSummary</a></code>,
<code><a href="#topic+locateEvents">locateEvents</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- calculate and print the centroids for several polygons
  print(calcCentroid(nepacLL[is.element(nepacLL$PID,c(33,39,47)),]))
})
</code></pre>

<hr>
<h2 id='calcConvexHull'>Calculate the Convex Hull for a Set of Points</h2><span id='topic+calcConvexHull'></span>

<h3>Description</h3>

<p>Calculate the convex hull for a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcConvexHull (xydata, keepExtra=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcConvexHull_+3A_xydata">xydata</code></td>
<td>
<p>a data frame with columns <code>X</code> and <code>Y</code>
containing spatial coordinates.</p>
</td></tr>
<tr><td><code id="calcConvexHull_+3A_keepextra">keepExtra</code></td>
<td>
<p>logical: if <code>TRUE</code>, retain any additional columns
from the input data frame <code>xydata</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine uses the function <code>chull()</code> in the package grDevices.
By default, it ignores all columns other than <code>X</code> and <code>Y</code>;
however, the user can choose to retain additional columns in <code>xydata</code>
by specifying <code>keepExtra=TRUE</code>. 
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> with columns <code>PID</code>, <code>POS</code>, <code>X</code>, <code>Y</code>,
and additional columns in <code>xydata</code> if <code>keepExtra=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+calcArea">calcArea</a></code>,
<code><a href="#topic+calcCentroid">calcCentroid</a></code>,
<code><a href="#topic+calcMidRange">calcMidRange</a></code>,
<code><a href="#topic+calcSummary">calcSummary</a></code>,
<code><a href="#topic+locateEvents">locateEvents</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<code><a href="#topic+plotPolys">plotPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  data(surveyData,envir=.PBSmapEnv)
  #--- plot the convex hull, and then plot the points
  plotMap(calcConvexHull(surveyData),col="moccasin")
  addPoints(surveyData,col="blue",pch=17,cex=.6)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='calcGCdist'>
Calculate Great-Circle Distance
</h2><span id='topic+calcGCdist'></span>

<h3>Description</h3>

<p>Calculate the great-circle distance between geographic (LL)
coordinates. Also calculate the initial bearing of the 
great-circle arc (at its starting point).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcGCdist(lon1, lat1, lon2, lat2, R=6371.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcGCdist_+3A_lon1">lon1</code></td>
<td>
<p><code>numeric</code> &ndash; Longitude coordinate (degrees) of the start point.</p>
</td></tr>
<tr><td><code id="calcGCdist_+3A_lat1">lat1</code></td>
<td>
<p><code>numeric</code> &ndash; Latitude coordinate(degrees) of the start point.</p>
</td></tr>
<tr><td><code id="calcGCdist_+3A_lon2">lon2</code></td>
<td>
<p><code>numeric</code> &ndash; Longitude coordinate(degrees) of the end point.</p>
</td></tr>
<tr><td><code id="calcGCdist_+3A_lat2">lat2</code></td>
<td>
<p><code>numeric</code> &ndash; Latitude coordinate(degrees) of the end point.</p>
</td></tr>
<tr><td><code id="calcGCdist_+3A_r">R</code></td>
<td>
<p><code>numeric</code> &ndash; Mean radius (km) of the Earth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The great-circle distance is calculated between two points along a
spherical surface using the shortest distance and disregarding
topography.
<br /><br />
<b>Method 1: Haversine Formula</b>
</p>
<p style="text-align: center;"><code class="reqn">a = \sin^2((\phi_2 - \phi_1)/2) + \cos(\phi_1) \cos(\phi_2) \sin^2((\lambda_2 - \lambda_1)/2)</code>
</p>

<p style="text-align: center;"><code class="reqn">c = 2~\mathrm{atan2}(\sqrt{a}, \sqrt{1-a})</code>
</p>

<p style="text-align: center;"><code class="reqn">d = R c</code>
</p>

<p>where<br />
<code class="reqn">\phi</code> = latitude (in radians),<br />
<code class="reqn">\lambda</code> = longitude (in radians),<br />
<code class="reqn">R</code> = radius (km) of the Earth,<br />
<code class="reqn">a</code> = square of half the chord length between the points,<br />
<code class="reqn">c</code> = angular distance in radians,<br />
<code class="reqn">d</code> = great-circle distance (km) between two points.
<br /><br />
<b>Method 2: Spherical Law of Cosines</b>
</p>
<p style="text-align: center;"><code class="reqn">d = \mathrm{acos}(\sin(\phi_1)\sin(\phi_2) + \cos(\phi_1)\cos(\phi_2)\cos(\lambda_2 - \lambda_1)) R</code>
</p>

<p>The initial bearing (aka forward azimuth) for the start point can be calculated using:
</p>
<p style="text-align: center;"><code class="reqn">\theta = \mathrm{atan2}(\sin(\lambda_2-\lambda_1)\cos(\phi_2), \cos(\phi_1)\sin(\phi_2) - \sin(\phi_1)\cos(\phi_2)\cos(\lambda_2-\lambda_1))</code>
</p>



<h3>Value</h3>

<p>A list obect containing:<br />
<code>a</code> &ndash; Haversine <code class="reqn">a</code> = square of half the chord length between the points,<br />
<code>c</code> &ndash; Haversine <code class="reqn">c</code> = angular distance in radians,<br />
<code>d</code> &ndash; Haversine <code class="reqn">d</code> = great-circle distance (km) between two points,<br />
<code>d2</code> &ndash; Law of Cosines <code class="reqn">d</code> = great-circle distance (km) between two points,<br />
<code>theta</code> &ndash; Initial bearing <code class="reqn">\theta</code> (degrees) for the start point.
</p>


<h3>Note</h3>

<p>If one uses the north geomagnetic pole as an end point, 
<code class="reqn">\theta</code> crudely approximates the magnetic declination.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Offsite, Vancouver BC<br />
Last modified <code>Rd: 2023-11-03</code>
</p>


<h3>References</h3>

<p>Movable Type Scripts &ndash;
<a href="https://www.movable-type.co.uk/scripts/latlong.html">Calculate distance, bearing and more between Latitude/Longitude points</a>
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+addCompass">addCompass</a></code>,
<code><a href="#topic+calcArea">calcArea</a></code>,
<code><a href="#topic+calcCentroid">calcCentroid</a></code>,
<code><a href="#topic+calcLength">calcLength</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #-- Distance between southern BC waters and north geomagnetic pole
  print(calcGCdist(-126.5,48.6,-72.7,80.4))
})
</code></pre>

<hr>
<h2 id='calcLength'>Calculate the Length of Polylines</h2><span id='topic+calcLength'></span>

<h3>Description</h3>

<p>Calculate the length of polylines found in a <a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLength (polys, rollup = 3, close = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLength_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
<tr><td><code id="calcLength_+3A_rollup">rollup</code></td>
<td>
<p>level of detail in the results; <code>1</code> = <code>PID</code>s
only, summing the lengths of each <code>SID</code> within each <code>PID</code>,
and <code>3</code> = no roll-up. Note: rollup <code>2</code> has no meaning in
this function and, if specified, will be reset to <code>3</code>.</p>
</td></tr>
<tr><td><code id="calcLength_+3A_close">close</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, include the distance
between each polygon's last and first vertex, if necessary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>rollup</code> equals <code>1</code>, the results contain an entry for
each unique <code>PID</code> only.  Setting it to <code>3</code> prevents roll-up,
and they contain an entry for each unique (<code>PID</code>, <code>SID</code>).
</p>
<p>If the <code>projection</code> attribute equals <code>"LL"</code>, this routine uses
Great Circle distances to compute the surface length of each polyline.
In doing so, the algorithm simplifies Earth to a sphere.
</p>
<p>If the <code>projection</code> attribute equals <code>"UTM"</code> or <code>1</code>, this
routine uses Pythagoras' Theorem to calculate lengths.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with columns <code>PID</code>, <code>SID</code> (<em>may be missing</em>),
and <code>length</code>.  If <code>projection</code> equals <code>"UTM"</code> or
<code>"LL"</code>, lengths are in kilometres.  Otherwise, lengths are in the
same unit as the input <a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcArea">calcArea</a></code>,
<code><a href="#topic+calcCentroid">calcCentroid</a></code>,
<code><a href="#topic+calcMidRange">calcMidRange</a></code>,
<code><a href="#topic+calcSummary">calcSummary</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- calculate the perimeter of Vancouver Island
  print(calcLength(nepacLL[nepacLL$PID==33, ]))
})
</code></pre>

<hr>
<h2 id='calcMidRange'>Calculate the Midpoint of the X/Y Ranges of Polygons</h2><span id='topic+calcMidRange'></span>

<h3>Description</h3>

<p>Calculate the midpoint of the <code>X</code>/<code>Y</code> ranges of polygons
found in a <a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcMidRange (polys, rollup = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcMidRange_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
<tr><td><code id="calcMidRange_+3A_rollup">rollup</code></td>
<td>
<p>level of detail in the results; <code>1</code> = <code>PID</code>s
only, <code>2</code> = outer contours only, and <code>3</code> = no roll-up.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>rollup</code> equals <code>1</code>, the results contain a mean range for
each unique <code>PID</code> only.  When it equals <code>2</code>, they contain
entries for outer contours only.  Finally, setting it to <code>3</code>
prevents roll-up, and they contain a mean range for each unique
(<code>PID</code>, <code>SID</code>).
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with columns <code>PID</code>, <code>SID</code> (<em>may be missing</em>),
<code>X</code>, and <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcArea">calcArea</a></code>,
<code><a href="#topic+calcCentroid">calcCentroid</a></code>,
<code><a href="#topic+calcLength">calcLength</a></code>,
<code><a href="#topic+calcSummary">calcSummary</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- calculate and print the centroids for several polygons
  print(calcMidRange(nepacLL[is.element(nepacLL$PID,c(33,39,47)),]))
})
</code></pre>

<hr>
<h2 id='calcSummary'>Apply Functions to Polygons in a PolySet</h2><span id='topic+calcSummary'></span>

<h3>Description</h3>

<p>Apply functions to polygons in a <a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSummary (polys, rollup = 3, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSummary_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
<tr><td><code id="calcSummary_+3A_rollup">rollup</code></td>
<td>
<p>level of detail in the results; <code>1</code> = <code>PID</code>s
only, by removing the <code>SID</code> column, and then passing each
<code>PID</code> into <code>FUN</code>, <code>2</code> = outer contours only, by making
hole <code>SID</code>s equal to their parent's <code>SID</code>, and then passing
each (<code>PID</code>, <code>SID</code>) into <code>FUN</code>, and <code>3</code> = no
roll-up.</p>
</td></tr>
<tr><td><code id="calcSummary_+3A_fun">FUN</code></td>
<td>
<p>the function to apply; it must accept a vector and return a
vector or scalar.</p>
</td></tr>
<tr><td><code id="calcSummary_+3A_...">...</code></td>
<td>
<p>optional arguments for <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>rollup</code> equals <code>1</code>, the results contain an entry for
each unique <code>PID</code> only.  When it equals <code>2</code>, they contain
entries for outer contours only.  Finally, setting it to <code>3</code>
prevents roll-up, and they contain an entry for each unique
(<code>PID</code>, <code>SID</code>).
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with columns <code>PID</code>, <code>SID</code> (<em>may be missing</em>),
<code>X</code>, and <code>Y</code>.  If <code>FUN</code> returns a vector of length
greater than 1 (say <em>n</em>), names the columns <code>X1</code>, <code>X2</code>,
..., <code>X</code><em>n</em> and <code>Y1</code>, <code>Y2</code>, ..., <code>Y</code><em>n</em>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcArea">calcArea</a></code>,
<code><a href="#topic+calcCentroid">calcCentroid</a></code>,
<code><a href="#topic+calcConvexHull">calcConvexHull</a></code>,
<code><a href="#topic+calcLength">calcLength</a></code>,
<code><a href="#topic+calcMidRange">calcMidRange</a></code>,
<code><a href="#topic+combineEvents">combineEvents</a></code>,
<code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+locateEvents">locateEvents</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>,
<code><a href="#topic+makeGrid">makeGrid</a></code>,
<code><a href="#topic+makeProps">makeProps</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- calculate and print the centroids for several polygons
  print(calcSummary(nepacLL[is.element(nepacLL$PID,c(33,39,47)),],
    rollup=3, FUN=mean))
})
</code></pre>

<hr>
<h2 id='calcVoronoi'>Calculate the Voronoi (Dirichlet) Tesselation for a Set of Points</h2><span id='topic+calcVoronoi'></span>

<h3>Description</h3>

<p>Calculate the Voronoi (Dirichlet) tesselation for a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVoronoi (xydata, xlim = NULL, ylim = NULL, eps = 1e-09, frac = 0.0001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVoronoi_+3A_xydata">xydata</code></td>
<td>
<p>a data frame with columns <code>X</code> and <code>Y</code>
containing the points.</p>
</td></tr>
<tr><td><code id="calcVoronoi_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates; a bounding box for the
coordinates.</p>
</td></tr>
<tr><td><code id="calcVoronoi_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates; a bounding box for the
coordinates.</p>
</td></tr>
<tr><td><code id="calcVoronoi_+3A_eps">eps</code></td>
<td>
<p>the value of epsilon used in testing whether a quantity is
zero.</p>
</td></tr>
<tr><td><code id="calcVoronoi_+3A_frac">frac</code></td>
<td>
<p>used to detect duplicate input points, which meet the
condition <code class="reqn">\left | x1 - x2 \right | &lt; \mbox{frac} \times
    (\mbox{xmax} - \mbox{xmin}) \mbox{and} \left | y1 - y2 \right | &lt;
    \mbox{frac} \times (\mbox{ymax} - \mbox{ymin})</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine ignores all columns other than <code>X</code> and <code>Y</code>.
</p>
<p>If the user leaves <code>xlim</code> and <code>ylim</code> unspecified, the
function defaults to the range of the data with each extent expanded
by ten percent of the range.
</p>
<p>This function sets the attribute <code>projection</code> to <code>1</code> and the
attribute <code>zone</code> to <code>NULL</code> as it assumes this projection in
its calculations.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> with columns <code>PID</code>, <code>POS</code>, <code>X</code>, and <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+calcArea">calcArea</a></code>,
<code><a href="#topic+calcCentroid">calcCentroid</a></code>,
<code><a href="#topic+calcConvexHull">calcConvexHull</a></code>,
<code><a href="#topic+calcMidRange">calcMidRange</a></code>,
<code><a href="#topic+calcSummary">calcSummary</a></code>,
<code><a href="#topic+locateEvents">locateEvents</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<code><a href="#topic+plotPolys">plotPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create some EventData
  events &lt;- as.EventData(data.frame(
    EID=1:200, X=rnorm(200), Y=rnorm(200)), projection=1)
  #--- calculate the Voronoi tesselation
  polys &lt;- calcVoronoi(events)
  #--- create PolyData to color it based on area
  polyData &lt;- calcArea(polys)
  names(polyData)[is.element(names(polyData), "area")] &lt;- "Z"
  colSeq &lt;- seq(0.4, 0.95, length=4)
  polyData &lt;- makeProps(polyData,
    breaks=quantile(polyData$Z,c(0,.25,.5,.75,1)),
    propName="col", propVals=rgb(colSeq,colSeq,colSeq))
  #--- plot the tesselation
  plotMap(polys, polyProps=polyData)
  #--- plot the points
  addPoints(events, pch=19)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='clipLines'>Clip a PolySet as Polylines</h2><span id='topic+clipLines'></span>

<h3>Description</h3>

<p>Clip a <a href="#topic+PolySet">PolySet</a>, where each unique (<code>PID</code>, <code>SID</code>)
describes a polyline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipLines (polys, xlim, ylim, keepExtra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clipLines_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to clip.</p>
</td></tr>
<tr><td><code id="clipLines_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="clipLines_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="clipLines_+3A_keepextra">keepExtra</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, tries to
carry forward any non-standard columns into the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each discrete polyline, the function does not connect vertices 1
and N.  It recalculates the <code>POS</code> values for each vertex, saving
the old values in a column named <code>oldPOS</code>.  For new vertices, it
sets <code>oldPOS</code> to <code>NA</code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> containing the input data, with some points added or
removed.  A new column <code>oldPOS</code> records the original <code>POS</code>
value for each vertex.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create a triangle to clip
  polys &lt;- data.frame(PID=rep(1, 3), POS=1:3, X=c(0,1,0), Y=c(0,0.5,1))
  #--- clip the triangle in the X direction, and plot the results
  plotLines(clipLines(polys, xlim=c(0,.75), ylim=range(polys[, "Y"])))
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='clipPolys'>Clip a PolySet as Polygons</h2><span id='topic+clipPolys'></span>

<h3>Description</h3>

<p>Clip a <a href="#topic+PolySet">PolySet</a>, where each unique (<code>PID</code>, <code>SID</code>) describes
a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipPolys (polys, xlim, ylim, keepExtra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clipPolys_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to clip.</p>
</td></tr>
<tr><td><code id="clipPolys_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="clipPolys_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="clipPolys_+3A_keepextra">keepExtra</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, tries to
carry forward any non-standard columns into the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each discrete polygon, the function connects vertices 1 and N.  It
recalculates the <code>POS</code> values for each vertex, saving the old
values in a column named <code>oldPOS</code>.  For new vertices, it sets
<code>oldPOS</code> to <code>NA</code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> containing the input data, with some points added or
removed.  A new column <code>oldPOS</code> records the original <code>POS</code>
value for each vertex.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clipLines">clipLines</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create a triangle that will be clipped
  polys &lt;- data.frame(PID=rep(1, 3), POS=1:3, X=c(0,1,.5), Y=c(0,0,1))
  #--- clip the triangle in the X direction, and plot the results
  plotPolys(clipPolys(polys,xlim=c(0,.75),ylim=range(polys[,"Y"])),col=2)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='closePolys'>Close a PolySet</h2><span id='topic+closePolys'></span>

<h3>Description</h3>

<p>Close a <a href="#topic+PolySet">PolySet</a> of polylines to form polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closePolys (polys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closePolys_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to close.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, run <code>fixBound</code> before this function. The ranges of a
<a href="#topic+PolySet">PolySet</a>'s <code>X</code> and <code>Y</code> columns define the boundary.
For each discrete polygon, this function determines if the first and
last points lie on a boundary.  If both points lie on the same
boundary, it adds no points.  However, if they lie on different
boundaries, it may add one or two corners to the polygon.
</p>
<p>When the boundaries are adjacent, one corner will be added as
follows:
</p>

<ul>
<li><p> top boundary + left boundary implies add top-left corner;
</p>
</li>
<li><p> top boundary + right boundary implies add top-right corner;
</p>
</li>
<li><p> bottom boundary + left boundary implies add bottom-left
corner;
</p>
</li>
<li><p> bottom boundary + right boundary implies add bottom-right
corner.
</p>
</li></ul>

<p>When the boundaries are opposite, it first adds the corner closest to
a starting or ending polygon vertex.  This determines a side
(left-right or bottom-top) that connects the opposite boundaries.
Then, it adds the other corner of that side to close the polygon.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> identical to <code>polys</code>, except for possible
additional corner points.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixBound">fixBound</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- 4 corners
  polys &lt;- data.frame(
    PID = c(1, 1, 2, 2, 3, 3, 4, 4),
    POS = c(1, 2, 1, 2, 1, 2, 1, 2),
    X   = c(0, 1, 2, 3, 0, 1, 2, 3),
    Y   = c(1, 0, 0, 1, 2, 3, 3, 2))
  plotPolys(closePolys(polys), col=2)

  #--- 2 corners and 1 opposite
  polys &lt;- data.frame(
    PID = c(1, 1, 2, 2, 3, 3, 3),
    POS = c(1, 2, 1, 2, 1, 2, 3),
    X   = c(0, 1, 0, 1, 5, 6, 1.5),
    Y   = c(1, 0, 2, 3, 0, 1.5, 3))
  plotPolys(closePolys(polys), col=2)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='combineEvents'>Combine Measurements of Events</h2><span id='topic+combineEvents'></span>

<h3>Description</h3>

<p>Combine measurements associated with events that occur in the same
polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineEvents (events, locs, FUN, ..., bdryOK = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineEvents_+3A_events">events</code></td>
<td>
<p><a href="#topic+EventData">EventData</a> with at least four columns (<code>EID</code>,
<code>X</code>, <code>Y</code>, <code>Z</code>).</p>
</td></tr>
<tr><td><code id="combineEvents_+3A_locs">locs</code></td>
<td>
<p><a href="#topic+LocationSet">LocationSet</a> usually resulting from a call to
<code><a href="#topic+findPolys">findPolys</a></code>.</p>
</td></tr>
<tr><td><code id="combineEvents_+3A_fun">FUN</code></td>
<td>
<p>a function that produces a scalar from a vector
(e.g., <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="base.html#topic+sum">sum</a></code>).</p>
</td></tr>
<tr><td><code id="combineEvents_+3A_...">...</code></td>
<td>
<p>optional arguments for <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="combineEvents_+3A_bdryok">bdryOK</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, include boundary points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines measurements associated with events that occur
in the same polygon.  Each event (<code>EID</code>) has a corresponding
measurement <code>Z</code>.  The <code>locs</code> data frame (usually output from
<code><a href="#topic+findPolys">findPolys</a></code>) places events within polygons.  Thus, each
polygon (<code>PID</code>, <code>SID</code>) determines a set of events within it,
and a corresponding vector of measurements <code>Zv</code>.  The function
returns <code>FUN(Zv)</code>, a summary of measurements within each polygon.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with columns <code>PID</code>, <code>SID</code> (<em>if in</em>
<code>locs</code>), and <code>Z</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findCells">findCells</a></code>,
<code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+locateEvents">locateEvents</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>,
<code><a href="#topic+makeGrid">makeGrid</a></code>,
<code><a href="#topic+makeProps">makeProps</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- create an EventData data frame: let each event have Z = 1
  events &lt;- data.frame(EID=1:10, X=1:10, Y=1:10, Z=rep(1, 10))
  #--- example output from findPolys where 1 event occurred in the first
  #--- polygon, 3 in the second, and 6 in the third
  locs &lt;- data.frame(EID=1:10,PID=c(rep(1,1),rep(2,3),rep(3,6)),Bdry=rep(0,10))
  #--- sum the Z column of the events in each polygon, and print the result
  print(combineEvents(events=events, locs=locs, FUN=sum))
})
</code></pre>

<hr>
<h2 id='combinePolys'>Combine Several Polygons into a Single Polygon</h2><span id='topic+combinePolys'></span>

<h3>Description</h3>

<p>Combine several polygons into a single polygon by modifying the
<code>PID</code> and <code>SID</code> indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinePolys (polys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combinePolys_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> with one or more polygons, each with
possibly several components/holes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a <a href="#topic+PolySet">PolySet</a> containing one or more polygons
(<code>PID</code>s), each with one or more components or holes
(<code>SID</code>s).  The <code>SID</code> column need not exist in the input.
The function combines these polygons into a single polygon by simply
renumbering the <code>PID</code> and <code>SID</code> indices.  The resulting
<a href="#topic+PolySet">PolySet</a> contains a single <code>PID</code> (with the value 1) and uses
the <code>SID</code> value to differentiate between polygons, their
components, and holes.  
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a>, possibly with the addition of an <code>SID</code> column if
it did not already exist.  The function may also reorder columns such
that <code>PID</code>, <code>SID</code>, <code>POS</code>, <code>X</code> and <code>Y</code> appear
first, in that order.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2007-06-06</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dividePolys">dividePolys</a></code>
</p>

<hr>
<h2 id='convCP'>Convert Contour Lines into a PolySet</h2><span id='topic+convCP'></span>

<h3>Description</h3>

<p>Convert output from <code><a href="grDevices.html#topic+contourLines">contourLines</a></code> into a <a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convCP (data, projection = NULL, zone = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convCP_+3A_data">data</code></td>
<td>
<p>contour line data, often from the
<code><a href="grDevices.html#topic+contourLines">contourLines</a></code> function.</p>
</td></tr>
<tr><td><code id="convCP_+3A_projection">projection</code></td>
<td>
<p>optional <code>projection</code> attribute to add to
the PolySet.</p>
</td></tr>
<tr><td><code id="convCP_+3A_zone">zone</code></td>
<td>
<p>optional <code>zone</code> attribute to add to the PolySet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> contains a list as described below. The
<code><a href="grDevices.html#topic+contourLines">contourLines</a></code> function create a list suitable for the
<code>data</code> argument.
</p>
<p>A three-element list describes each contour.  The named elements in
this list include the scalar <code>level</code>, the vector <code>x</code>, and
the vector <code>y</code>.  Vectors <code>x</code> and <code>y</code> must have equal
lengths.  A higher-level list (<code>data</code>) contains one or more of
these contours lists.
</p>


<h3>Value</h3>

<p>A list with two named elements <a href="#topic+PolySet">PolySet</a> and <a href="#topic+PolyData">PolyData</a>.
The <a href="#topic+PolySet">PolySet</a> element contains a <a href="#topic+PolySet">PolySet</a> representation of the
contour lines.  The <a href="#topic+PolyData">PolyData</a> element links each contour line
(<code>PID</code>, <code>SID</code>) with a <code>level</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="grDevices.html#topic+contourLines">contourLines</a></code>,
<code><a href="#topic+convLP">convLP</a></code>,
<code><a href="#topic+makeTopography">makeTopography</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create sample data for the contourLines() function
  x &lt;- seq(-0.5, 0.8, length=50);  y &lt;- x
  z &lt;- outer(x, y, FUN = function(x,y) { sin(2*pi*(x^2+y^2))^2; } )
  data &lt;- contourLines(x, y, z, levels=c(0.2, 0.8))
  #--- pass that sample data into convCP()
  result &lt;- convCP(data)
  #--- plot the result
  plotLines(result$PolySet, projection=1)
  print(result$PolyData)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='convDP'>Convert EventData/PolyData into a PolySet</h2><span id='topic+convDP'></span>

<h3>Description</h3>

<p>Convert <a href="#topic+EventData">EventData</a>/<a href="#topic+PolyData">PolyData</a> into a <a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convDP (data, xColumns, yColumns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convDP_+3A_data">data</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> or <a href="#topic+EventData">EventData</a>.</p>
</td></tr>
<tr><td><code id="convDP_+3A_xcolumns">xColumns</code></td>
<td>
<p>vector of X-column names.</p>
</td></tr>
<tr><td><code id="convDP_+3A_ycolumns">yColumns</code></td>
<td>
<p>vector of Y-column names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function expects <code>data</code> to contain several X- and Y-columns.
For example, consider <code>data</code> with columns <code>x1</code>, <code>y1</code>,
<code>x2</code>, and <code>y2</code>.  Suppose <code>xColumns = c("x1", "x2")</code> and
<code>yColumns = c("y1", "y2")</code>.  The result will contain
<code>nrow(data)</code> polygons.  Each one will have two vertices,
<code>(x1, y1)</code> and <code>(x2, y2)</code> and <code>POS</code> values 1 and 2,
respectively.  If <code>data</code> includes an <code>SID</code> column, so will
the result.
</p>
<p>If <code>data</code> contains an <code>EID</code> and not a <code>PID</code> column,
the function uses the <code>EID</code>s as <code>PID</code>s.
</p>
<p>If <code>data</code> contains both <code>PID</code> and <code>EID</code> columns,
the function assumes it is <a href="#topic+PolyData">PolyData</a> and ignores the <code>EID</code>
column.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> with the same <code>PID</code>s as those given in <code>data</code>.  If
<code>data</code> has an <code>SID</code> column, the result will include it.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create sample PolyData
  polyData &lt;- data.frame(PID=c(1, 2, 3),
     x1=c(1, 3, 5), y1=c(1, 3, 2),
     x2=c(1, 4, 5), y2=c(2, 4, 1),
     x3=c(2, 4, 6), y3=c(2, 3, 1))
  #--- print PolyData
  print(polyData)
  #--- make a PolySet from PolyData
  polys &lt;- convDP(polyData,
    xColumns=c("x1", "x2", "x3"),
    yColumns=c("y1", "y2", "y3"))
  #--- print and plot the PolySet
  print(polys)
  plotLines(polys, xlim=c(0,7), ylim=c(0,5), col=2)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='convLP'>Convert Polylines into a Polygon</h2><span id='topic+convLP'></span>

<h3>Description</h3>

<p>Convert two polylines into a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convLP (polyA, polyB, reverse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convLP_+3A_polya">polyA</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> containing a polyline.</p>
</td></tr>
<tr><td><code id="convLP_+3A_polyb">polyB</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> containing a polyline.</p>
</td></tr>
<tr><td><code id="convLP_+3A_reverse">reverse</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, reverse <code>polyB</code>'s
vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting <a href="#topic+PolySet">PolySet</a> contains all the vertices from
<code>polyA</code> in their original order.  If <code>reverse = TRUE</code>, this
function appends the vertices from <code>polyB</code> in the reverse order
(<code>nrow(polyB):1</code>).  Otherwise, it appends them in their original
order.  The <code>PID</code> column equals the <code>PID</code> of <code>polyA</code>.
No <code>SID</code> column appears in the result.  The resulting polygon is
an exterior boundary.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> with a single <code>PID</code> that is the same as
<code>polyA</code>. The result contains all the vertices in <code>polyA</code> and
<code>polyB</code>. It has the same <code>projection</code> and <code>zone</code>
attributes as those in the input PolySets.  If an input PolySet's
attributes equal <code>NULL</code>, the function uses the other
PolySet's. If the PolySet attributes conflict, the result's attribute
equals <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addLines">addLines</a></code>,
<code><a href="#topic+appendPolys">appendPolys</a></code>,
<code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+convCP">convCP</a></code>,
<code><a href="#topic+joinPolys">joinPolys</a></code>,
<code><a href="#topic+plotLines">plotLines</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create two polylines
  polyline1 &lt;- data.frame(PID=rep(1,2),POS=1:2,X=c(1,4),Y=c(1,4))
  polyline2 &lt;- data.frame(PID=rep(1,2),POS=1:2,X=c(2,5),Y=c(1,4))
  #--- create two plots to demonstrate the effect of `reverse'
  par(mfrow=c(2, 1))
  plotPolys(convLP(polyline1, polyline2, reverse=TRUE), col=2)
  plotPolys(convLP(polyline1, polyline2, reverse=FALSE), col=3)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='convUL'>Convert Coordinates between UTM and Lon/Lat</h2><span id='topic+convUL'></span>

<h3>Description</h3>

<p>Convert coordinates between UTM and Lon/Lat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convUL (xydata, km=TRUE, southern=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convUL_+3A_xydata">xydata</code></td>
<td>
<p><code>numeric</code> &ndash; data frame with columns <code>X</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code id="convUL_+3A_km">km</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, UTM coordinates within
<code>xydata</code> are in kilometres; otherwise, metres.</p>
</td></tr>
<tr><td><code id="convUL_+3A_southern">southern</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, forces conversions from
UTM to longitude/latitude to produce coordinates within the
southern hemisphere.  For conversions from UTM, this argument defaults to
<code>FALSE</code>. For conversions from LL, the function determines 
<code>southern</code> from <code>xydata</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>xydata</code> must possess a <code>projection</code> attribute that
identifies the current projection.  If the data frame contains UTM
coordinates, it must also have a <code>zone</code> attribute equal to a
number between 1 and 60 (inclusive).  If it contains
geographic (longitude/latitude) coordinates and the <code>zone</code> attribute is
missing, the function computes the mean longitude and uses that value
to determine the zone.  The longitude range of zone <code class="reqn">i</code> is
<code class="reqn">-186 + 6 i^\circ &lt; x \le -180 + 6 i^\circ</code>.
</p>
<p>This function converts the <code>X</code> and <code>Y</code> columns of
<code>xydata</code> from <code>"LL"</code> to <code>"UTM"</code> or vice-versa.  If the
data span more than <b>one</b> zone to the right or left of the intended
central zone, the underlying algorithm may produce erroneous
results. This limitation means that the user should use 
the most central zone of the mapped region, or allow the function to determine
the central zone when converting from geographic to UTM coordinates.
After the conversion, this routine adjusts the data frame's attributes accordingly.
</p>


<h3>Value</h3>

<p>A data frame identical to <code>xydata</code>, except that the <code>X</code> and
<code>Y</code> columns contain the results of the conversion, and the
<code>projection</code> attribute matches the new projection.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Software Engineer, Jobber, Edmonton AB<br />
Maintainer: <a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Regional Headquarters, Vancouver BC<br />
Last modified <code>Rd: 2022-09-06</code>
</p>


<h3>References</h3>

<p>Ordnance Survey. (2020) 
<a href="https://www.ordnancesurvey.co.uk/documents/resources/guide-coordinate-systems-great-britain.pdf">A guide to coordinate systems in Great Britain</a>.
Copyright Ordnance Survey 2018 <b>(v3.6)</b>. Southampton, UK.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- load the data
  data(nepacLL,envir=.PBSmapEnv)
  #--- set the zone attribute
  #--- use a zone that is most central to the mapped region
  attr(nepacLL, "zone") &lt;- 6
  #--- convert and plot the result
  nepacUTM &lt;- convUL(nepacLL)
  plotMap(nepacUTM)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='dividePolys'>Divide a Single Polygon into Several Polygons</h2><span id='topic+dividePolys'></span>

<h3>Description</h3>

<p>Divide a single polygon (with several outer-contour components) into
several polygons, a polygon for each outer contour, by modifying the
<code>PID</code> and <code>SID</code> indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dividePolys (polys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dividePolys_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> with one or more polygons, each with
possibly several components/holes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the input <a href="#topic+PolySet">PolySet</a>, this function renumbers the <code>PID</code>
and <code>SID</code> indices so that each outer contour has a unique PID and
is followed by all of its holes, identifying them with <code>SID</code>s
greater than one.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a>, possibly with the addition of an <code>SID</code> column if
it did not already exist.  The function may also reorder columns such
that <code>PID</code>, <code>SID</code>, <code>POS</code>, <code>X</code> and <code>Y</code> appear
first, in that order.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2007-06-06</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combinePolys">combinePolys</a></code>.
</p>

<hr>
<h2 id='dot-is.in'>
Are Points in Polygons?
</h2><span id='topic+.is.in'></span>

<h3>Description</h3>

<p>Determines which points (EventData) are located inside a polygon (PolySet).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is.in(events, polys, use.names=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dot-is.in_+3A_events">events</code></td>
<td>
<p><code>numeric</code> &ndash; data frame of event data (points), 
with X and Y coordinates; not necessarily a PBSmapping <code>EventData</code> object</p>
</td></tr>
<tr><td><code id="dot-is.in_+3A_polys">polys</code></td>
<td>
<p><code>numeric</code> &ndash; a PBSmapping PolySet (polygon)</p>
</td></tr>
<tr><td><code id="dot-is.in_+3A_use.names">use.names</code></td>
<td>
<p><code>logical</code> &ndash; <em>currently not used</em></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taps into the PBSmapping C code for <code>'findPolys'</code>.
</p>


<h3>Value</h3>

<p>Reports events inside the polygon, outside the polygon, and whether
all events are inside, outside, or on the boundary of the polygon.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Offsite, Vancouver BC<br />
Last modified <code>Rd: 2023-10-30</code>
</p>


<h3>See Also</h3>

<p>In <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+as.EventData">as.EventData</a></code>,
<code><a href="#topic+is.PolySet">is.PolySet</a></code>,
<code><a href="#topic+findPolys">findPolys</a></code>
</p>

<hr>
<h2 id='dot-PBSfigs'>
Run PBSmapping Example Figures
</h2><span id='topic+.PBSfigs'></span><span id='topic+.PBSfig01'></span><span id='topic+.PBSfig02'></span><span id='topic+.PBSfig03'></span><span id='topic+.PBSfig04'></span><span id='topic+.PBSfig05'></span><span id='topic+.PBSfig06'></span><span id='topic+.PBSfig07'></span><span id='topic+.PBSfig08'></span><span id='topic+.PBSfig09'></span><span id='topic+.PBSfig10'></span>

<h3>Description</h3>

<p>Run built-in example figures for PBSmapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.PBSfigs(nfigs=1:10, wait=TRUE)
.PBSfig01()
.PBSfig02()
.PBSfig03()
.PBSfig04()
.PBSfig05()
.PBSfig06()
.PBSfig07()
.PBSfig08()
.PBSfig09()
.PBSfig10()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dot-PBSfigs_+3A_nfigs">nfigs</code></td>
<td>
<p><code>numeric</code> &ndash; figure number(s) to run</p>
</td></tr>
<tr><td><code id="dot-PBSfigs_+3A_wait">wait</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, figure pauses until user hits
&lt;return&gt; for the next figure to display.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The wrapper function <code>'.PBSfigs'</code> displays pre-defined figures
from 1 to 10, depending on the numbers that the user specifies.
User can also call each figure directly, e.g., <code>'.PBSfig05()'</code>.
</p>


<h3>Value</h3>

<p>NULL</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Software Engineer, Jobber, Edmonton AB<br />
Maintainer: <a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Offsite, Vancouver BC<br />
Last modified <code>Rd: 2023-10-30</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.PBSfigs(nfigs=1:3, wait=FALSE)
</code></pre>

<hr>
<h2 id='dot-PBSmapEnv'>PBSmapping Environment</h2><span id='topic+.PBSmapEnv'></span>

<h3>Description</h3>

<p>An environment set aside for PBSmapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.PBSmapEnv</code></pre>


<h3>Format</h3>

<p>A new environment with a <code>.GlobalEnv</code> parent.
</p>


<h3>Details</h3>

<p>The environment is created in <code>'zzz.r'</code> and can be
used by <code>PBSmodelling</code> functions <code>'lisp'</code>, <code>'tget'</code>, 
<code>'tput'</code>, <code>'tprint'</code>, and <code>'tcall'</code>, if this package has be loaded.
</p>
<p>Currently, <code>'.PBSmapEnv'</code> is only used in <code>'.validateData'</code>
(in the namespace), and by a set of <code>print</code> functions specific to PBSmapping.
</p>


<h3>Source</h3>

<p>Generated by a call to the base function <code>new.env()</code>.
</p>


<h3>See Also</h3>

<p>In <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+print.EventData">print.EventData</a></code>,
<code><a href="#topic+print.LocationSet">print.LocationSet</a></code>,
<code><a href="#topic+print.PolyData">print.PolyData</a></code>,
<code><a href="#topic+print.PolySet">print.PolySet</a></code>,
<code><a href="#topic+print.summary.PBS">print.summary.PBS</a></code><br />
In <span class="pkg">PBSmodelling</span>:<br />
<code>lisp</code>,
<code>tget</code>,
<code>packList</code>
</p>

<hr>
<h2 id='EventData'>EventData Objects</h2><span id='topic+EventData'></span><span id='topic+as.EventData'></span><span id='topic+is.EventData'></span>

<h3>Description</h3>

<p>An EventData object comprises a data frame with at least three fields named
<code>EID</code>, <code>X</code>, and <code>Y</code>; each row specifies an event that occurs
at a specific point.
</p>
<p><span class="pkg">PBSmapping</span> functions that expect EventData will accept properly
formatted data frames in their place (see 'Details').
</p>
<p><code>as.EventData</code> attempts to coerce a data frame to an object with
class EventData.
</p>
<p><code>is.EventData</code> returns <code>TRUE</code> if its argument is of class
EventData.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.EventData(x, projection = NULL, zone = NULL)
is.EventData(x, fullValidation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EventData_+3A_x">x</code></td>
<td>
<p>data frame to be coerced or tested.</p>
</td></tr>
<tr><td><code id="EventData_+3A_projection">projection</code></td>
<td>
<p>optional <code>projection</code> attribute to add to
EventData, possibly overwriting an existing attribute.</p>
</td></tr>
<tr><td><code id="EventData_+3A_zone">zone</code></td>
<td>
<p>optional <code>zone</code> attribute to add to EventData,
possibly overwriting an existing attribute.</p>
</td></tr>
<tr><td><code id="EventData_+3A_fullvalidation">fullValidation</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, fully test
<code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conceptually, an EventData object describes events (EID) that take place at
specific points (X,Y) in two-dimensional space. Additional fields can specify
measurements associated with these events. In a fishery context, EventData
could describe fishing events associated with trawl tows, based on the fields:
</p>

<ul>
<li> <p><code>EID</code> - fishing event (tow) identification number;
</p>
</li>
<li> <p><code>X</code>, <code>Y</code> - fishing location;
</p>
</li>
<li> <p><code>Duration</code> - length of time for the tow;
</p>
</li>
<li> <p><code>Depth</code> - average depth of the tow;
</p>
</li>
<li> <p><code>Catch</code> - biomass captured.
</p>
</li></ul>

<p>Like <a href="#topic+PolyData">PolyData</a>, EventData can have attributes <code>projection</code>
and <code>zone</code>, which may be absent. Inserting the string
<code>"EventData"</code> as the class attribute's first element alters the
behaviour of some functions, including <code><a href="base.html#topic+print">print</a></code> (if
<code><a href="#topic+PBSprint">PBSprint</a></code> is <code>TRUE</code>) and <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Value</h3>

<p>The <code>as.EventData</code> method returns an object with classes
<code>"EventData"</code> and <code>"data.frame"</code>, in that order.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2015-04-23</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+PolySet">PolySet</a>,
<a href="#topic+PolyData">PolyData</a>, 
<a href="#topic+LocationSet">LocationSet</a>
</p>

<hr>
<h2 id='extractPolyData'>Extract PolyData from a PolySet</h2><span id='topic+extractPolyData'></span>

<h3>Description</h3>

<p>Extract <a href="#topic+PolyData">PolyData</a> from a <a href="#topic+PolySet">PolySet</a>.  Columns for the
<a href="#topic+PolyData">PolyData</a> include those other than <code>PID</code>, <code>SID</code>,
<code>POS</code>, <code>oldPOS</code>, <code>X</code>, and <code>Y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractPolyData (polys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractPolyData_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies the <a href="#topic+PolySet">PolySet</a>'s extra columns and
determines if those columns contain unique values for each
(<code>PID</code>, <code>SID</code>).  Where they do, the (<code>PID</code>, <code>SID</code>)
will appear in the <a href="#topic+PolyData">PolyData</a> output with that unique value.
Where they do not, the extra column will contain <code>NA</code>s for that
(<code>PID</code>, <code>SID</code>).
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with columns <code>PID</code>, <code>SID</code>, and any extra
columns.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeProps">makeProps</a></code>,
<a href="#topic+PolyData">PolyData</a>,
<a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- create a PolySet with an extra column
  polys &lt;- data.frame(PID = c(rep(1, 10), rep(2, 10)),
    POS = c(1:10, 1:10),
    X = c(rep(1, 10), rep(1, 10)),
    Y = c(rep(1, 10), rep(1, 10)),
    colour = (c(rep("green", 10), rep("red", 10))))
  #--- extract the PolyData
  print(extractPolyData(polys))
})
</code></pre>

<hr>
<h2 id='findCells'>Find Grid Cells that Contain Events</h2><span id='topic+findCells'></span>

<h3>Description</h3>

<p>Find the grid cells in a <a href="#topic+PolySet">PolySet</a> that contain events specified in
<a href="#topic+EventData">EventData</a>.  Similar to <code><a href="#topic+findPolys">findPolys</a></code>, except this
function requires a <a href="#topic+PolySet">PolySet</a> resulting from
<code><a href="#topic+makeGrid">makeGrid</a></code>.  This restriction allows this function to
calculate the result with greater efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCells (events, polys, includeBdry=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findCells_+3A_events">events</code></td>
<td>
<p><a href="#topic+EventData">EventData</a> to use.</p>
</td></tr>
<tr><td><code id="findCells_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
<tr><td><code id="findCells_+3A_includebdry">includeBdry</code></td>
<td>
<p>numeric: determines how points on boundaries are handled: <br />
if <code>NULL</code> then report all points on polygon boundaries (default behaviour); <br />
if <code>0</code> then exclude all points on polygon boundaries; <br />
if <code>1</code> then report only the first (lowest PID/SID) polygon boundary; <br />
if <code>2,...,n</code> then report the last (highest PID/SID) polygon boundary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting data frame, a <a href="#topic+LocationSet">LocationSet</a>, contains the columns
<code>EID</code>, <code>PID</code>, <code>SID</code> (<em>if in</em> <code>polys</code>), and
<code>Bdry</code>, where an event (<code>EID</code>) occurs in a polygon
(<code>PID</code>, <code>SID</code>). The Boolean (0,1) variable <code>Bdry</code> indicates
whether an event lies on a polygon's edge.  Note that if an event lies
properly outside of all the polygons, then a record with (<code>EID</code>,
<code>PID</code>, <code>SID</code>) does not occur in the output.  It may happen,
however, that an event occurs in multiple polygons (i.e., on two or
more boundaries).  Thus, the same <code>EID</code> can occur more than once
in the output.
</p>
<p>If an event happens to lie at the boundary intersection of four (or two) grid cells 
then one <code>EID</code> will be associated with four (or two) grid cells. A user
can choose to manipulate this result by setting the argument <code>includeBdry</code>
to a numeric value that constrains the association of a boundary event to 
0 or 1 grid cell (see argument description above).
</p>


<h3>Value</h3>

<p><a href="#topic+LocationSet">LocationSet</a> that links events with polygons.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2014-12-15</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+makeGrid">makeGrid</a></code>,
<code><a href="#topic+combineEvents">combineEvents</a></code>,
<code><a href="#topic+locateEvents">locateEvents</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>,
<a href="#topic+LocationSet">LocationSet</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create some EventData: points in a diagonal line
  events &lt;- data.frame(EID=1:11, X=seq(0, 2, length=11),
     Y=seq(0, 2, length=11))
  events &lt;- as.EventData(events, projection=1);
  #--- create a PolySet (a grid)
  polys &lt;- makeGrid (x=seq(0, 2, by=0.50), y=seq(0, 2, by=0.50), projection=1)
  #--- show a picture
  plotPolys(polys, xlim=range(polys$X)+c(-0.1, 0.1),
    ylim=range(polys$Y)+c(-0.1, 0.1), projection=1)
  addPoints(events, col=2)
  #--- run findCells and print the results
  fc &lt;- findCells(events, polys)
  fc &lt;- fc[order(fc$EID, fc$PID, fc$SID), ]
  fc$label &lt;- paste(fc$PID, fc$SID, sep=", ")
  print (fc)
  #--- add labels to the graph
  addLabels(as.PolyData(fc[!duplicated(paste(fc$PID,fc$SID)), ],
    projection=1), placement="CENTROID", 
    polys=as.PolySet(polys, projection=1), col=4)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='findPolys'>Find Polygons that Contain Events</h2><span id='topic+findPolys'></span>

<h3>Description</h3>

<p>Find the polygons in a <a href="#topic+PolySet">PolySet</a> that contain events specified in
<a href="#topic+EventData">EventData</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPolys (events, polys, maxRows = 1e+05, includeBdry=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPolys_+3A_events">events</code></td>
<td>
<p><a href="#topic+EventData">EventData</a> to use.</p>
</td></tr>
<tr><td><code id="findPolys_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
<tr><td><code id="findPolys_+3A_maxrows">maxRows</code></td>
<td>
<p>estimated maximum number of rows in the output <a href="#topic+LocationSet">LocationSet</a>.</p>
</td></tr>
<tr><td><code id="findPolys_+3A_includebdry">includeBdry</code></td>
<td>
<p>numeric: determines how points on boundaries are handled: <br />
if <code>NULL</code> then report all points on polygon boundaries (default behaviour); <br />
if <code>0</code> then exclude all points on polygon boundaries; <br />
if <code>1</code> then report only the first (lowest PID/SID) polygon boundary; <br />
if <code>2,...,n</code> then report the last (highest PID/SID) polygon boundary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting data frame, a <a href="#topic+LocationSet">LocationSet</a>, contains the columns
<code>EID</code>, <code>PID</code>, <code>SID</code> (<em>if in</em> <code>polys</code>), and
<code>Bdry</code>, where an event (<code>EID</code>) occurs in a polygon
(<code>PID</code>, <code>SID</code>) and <code>SID</code> does not correspond to an
inner boundary.  The Boolean variable <code>Bdry</code> indicates whether an
event lies on a polygon's edge.  Note that if an event lies properly
outside of all the polygons, then a record with (<code>EID</code>,
<code>PID</code>, <code>SID</code>) does not occur in the output.  It may happen,
however, that an event occurs in multiple polygons.  Thus, the same
<code>EID</code> can occur more than once in the output.
</p>
<p>If an event happens to lie at the boundary intersection of two or more polygons
then one <code>EID</code> will be associated with two or more polygons. A user
can choose to manipulate this result by setting the argument <code>includeBdry</code>
to a numeric value that constrains the association of a boundary event to
0 or 1 polygon (see argument description above).
</p>


<h3>Value</h3>

<p><a href="#topic+LocationSet">LocationSet</a> that links events with polygons.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2014-12-15</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineEvents">combineEvents</a></code>,
<code><a href="#topic+findCells">findCells</a></code>,
<code><a href="#topic+locateEvents">locateEvents</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>,
<a href="#topic+LocationSet">LocationSet</a>,
<code><a href="#topic+makeGrid">makeGrid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create some EventData: a column of points at X = 0.5
  events &lt;- data.frame(EID=1:10, X=.5, Y=seq(0, 2, length=10))
  events &lt;- as.EventData(events, projection=1)
  #--- create a PolySet: two squares with the second above the first
  polys &lt;- data.frame(PID=c(rep(1, 4), rep(2, 4)), POS=c(1:4, 1:4),
    X=c(0, 1, 1, 0, 0, 1, 1, 0),
    Y=c(0, 0, 1, 1, 1, 1, 2, 2))
  polys &lt;- as.PolySet(polys, projection=1)
  #--- show a picture
  plotPolys(polys, xlim=range(polys$X)+c(-0.1, 0.1),
    ylim=range(polys$Y)+c(-0.1, 0.1), projection=1);
  addPoints(events, col=2);
  #--- run findPolys and print the results
  print(findPolys(events, polys))
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='fixBound'>Fix the Boundary Points of a PolySet</h2><span id='topic+fixBound'></span>

<h3>Description</h3>

<p>The ranges of a <a href="#topic+PolySet">PolySet</a>'s <code>X</code> and <code>Y</code> columns define
its boundary.  This function fixes a <a href="#topic+PolySet">PolySet</a>'s vertices by
moving vertices near a boundary to the actual boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixBound (polys, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixBound_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to fix.</p>
</td></tr>
<tr><td><code id="fixBound_+3A_tol">tol</code></td>
<td>
<p>vector (length 1 or 2) specifying a percentage of
the ranges to use in defining <em>near</em> to a boundary. If
<code>tol</code> has two elements, the first specifies the tolerance for
the x-axis and the second the y-axis.  If it has only one element,
the function uses the same tolerance for both axes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When moving vertices to a boundary, the function moves them strictly
horizontally or vertically, as appropriate.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> identical to the input, except for possible changes in
the <code>X</code> and <code>Y</code> columns.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>,
<code><a href="#topic+isConvex">isConvex</a></code>,
<code><a href="#topic+isIntersecting">isIntersecting</a></code>,
<a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- set up a long horizontal and long vertical line to extend the plot's
  #--- limits, and then try fixing the bounds of a line in the top-left
  #--- corner and a line in the bottom-right corner
  polys &lt;- data.frame(PID=c(1, 1, 2, 2,  3, 3, 4, 4),
    POS=c(1, 2, 1, 2,  1, 2, 1, 2),
    X = c(0, 10, 5, 5, 0.1, 4.9, 5.1, 9.9),
    Y = c(5, 5, 0, 10, 5.1, 9.9, 0.1, 4.9))
  polys &lt;- fixBound(polys, tol=0.0100001)
  plotLines(polys)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='fixPOS'>Fix the POS Column of a PolySet</h2><span id='topic+fixPOS'></span>

<h3>Description</h3>

<p>Fix the <code>POS</code> column of a <a href="#topic+PolySet">PolySet</a> by recalculating it
using sequential integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixPOS (polys, exteriorCCW = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixPOS_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to fix.</p>
</td></tr>
<tr><td><code id="fixPOS_+3A_exteriorccw">exteriorCCW</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, orders exterior
polygon vertices in a counter-clockwise direction.  If <code>FALSE</code>,
orders them in a clockwise direction.  If <code>NA</code>, maintains their
original order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function recalculates the <code>POS</code> values of each (<code>PID</code>,
<code>SID</code>) as either 1 to N or N to 1, depending on the order of
<code>POS</code> (ascending or descending) in the input data.  <code>POS</code>
values in the input must be properly ordered (ascending or
descending), but they may contain fractional values.  For example,
<code>POS = 2.5</code> might correspond to a point manually added between
<code>POS = 2</code> and <code>POS = 3</code>.  If <code>exteriorCCW = NA</code>, all
other columns remain unchanged.  Otherwise, it orders the <code>X</code> and
<code>Y</code> columns according to <code>exteriorCCW</code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> with the same columns as the input, except for possible
changes to the <code>POS</code>, <code>X</code>, and <code>Y</code> columns.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>,
<code><a href="#topic+isConvex">isConvex</a></code>,
<code><a href="#topic+isIntersecting">isIntersecting</a></code>,
<a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- create a PolySet with broken POS numbering
  polys &lt;- data.frame(PID = c(rep(1, 10), rep(2, 10)),
    POS = c(seq(2, 10, length = 10), seq(10, 2, length = 10)),
    X = c(rep(1, 10), rep(1, 10)),
    Y = c(rep(1, 10), rep(1, 10)))
  #--- fix the POS numbering
  polys &lt;- fixPOS(polys)
  #--- print the results
  print(polys)
})
</code></pre>

<hr>
<h2 id='importEvents'>Import EventData from a Text File</h2><span id='topic+importEvents'></span>

<h3>Description</h3>

<p>Import a text file and convert into <code>EventData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importEvents(EventData, projection=NULL, zone=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importEvents_+3A_eventdata">EventData</code></td>
<td>
<p><code>character</code> &ndash; filename of <code>EventData</code> text file.</p>
</td></tr>
<tr><td><code id="importEvents_+3A_projection">projection</code></td>
<td>
<p><code>character</code> &ndash; optional projection attribute to add to <code>EventData</code>.</p>
</td></tr>
<tr><td><code id="importEvents_+3A_zone">zone</code></td>
<td>
<p><code>numeric</code> &ndash; optional zone attribute to add to <code>EventData</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An imported <code>EventData</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2023-10-30</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+importPolys">importPolys</a></code>, <code><a href="#topic+importLocs">importLocs</a></code>, <code><a href="#topic+importGSHHS">importGSHHS</a></code>
</p>

<hr>
<h2 id='importGSHHS'>Import Data from a GSHHS Database</h2><span id='topic+importGSHHS'></span>

<h3>Description</h3>

<p>Import data from a GSHHS database and convert data into a <code>PolySet</code>
with a <code>PolyData</code> attribute. 
The database was originally called &lsquo;Global Self-consistent, Hierarchical, High-resolution Shoreline&rsquo;
(GSHHS, Wessel and Smith 1996), but &lsquo;Shoreline&rsquo; was subsequently expanded to include more &lsquo;Geography&rsquo; (GSHHG).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importGSHHS(gshhsDB, xlim, ylim, maxLevel=4, n=0, useWest=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importGSHHS_+3A_gshhsdb">gshhsDB</code></td>
<td>
<p><code>character</code> &ndash; path name to binary GSHHS database. If unspecified,
looks for <code>gshhs_f.b</code> in the root of the <span class="pkg">PBSmapping</span> library
directory.</p>
</td></tr>
<tr><td><code id="importGSHHS_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> &ndash; range of X-coordinates (for clipping).
The range should be between 0 and 360, starting at the Greenwich meridian and wrapping eastward around the globe.</p>
</td></tr>
<tr><td><code id="importGSHHS_+3A_ylim">ylim</code></td>
<td>
<p><code>numeric</code> &ndash; range of Y-coordinates (for clipping).</p>
</td></tr>
<tr><td><code id="importGSHHS_+3A_maxlevel">maxLevel</code></td>
<td>
<p><code>numeric</code> &ndash; maximum level of polygons to import:
1 (land), 2 (lakes on land), 3 (islands in lakes), or 4 (ponds on
islands); ignored when importing lines.</p>
</td></tr>
<tr><td><code id="importGSHHS_+3A_n">n</code></td>
<td>
<p><code>numeric</code> &ndash; minimum number of vertices that must exist in a line/polygon
in order for it to be imported.</p>
</td></tr>
<tr><td><code id="importGSHHS_+3A_usewest">useWest</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, convert the X-coordinates (longitude)
to <code class="reqn">^\circ</code>W (western hemisphere -180 to 0, i.e., west of the Greenwich meridian).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine requires a binary GSHHG (Global Self-consistent, Hierarchical,
High-resolution Geography) database file. 
The <a href="http://www.soest.hawaii.edu/pwessel/gshhg/">GSHHG database</a> has been released
in the public domain.
At the time of writing, the most recent binary database was the archive
file called <code>gshhg-bin-2.3.7.zip</code>.
</p>
<p>The archive contains multiple binary files that contain geographical
coordinates for shorelines (<code>gshhs</code>), rivers (<code>wdb_rivers</code>), and
borders (<code>wdb_borders</code>).
The latter two come from <a href="https://meta.wikimedia.org/wiki/Geographical_data#CIA_World_DataBank_II_and_derivates">World DataBank II</a> (WDBII).
The five resolutions available are:
full (<code>f</code>), high (<code>h</code>), intermediate (<code>i</code>), low (<code>l</code>), and coarse (<code>c</code>).
</p>
<p>This routine returns a <code>PolySet</code> object with an associated
<code>PolyData</code> attribute. The attribute contains four fields: (a) <code>PID</code>,
(b) <code>SID</code>, (c) <code>Level</code>, and (d) <code>Source</code>.
Each record corresponds to a line/polygon in the <code>PolySet</code>.  The
<code>Level</code> indicates the line's/polygon's level (1=land, 2=lake,
3=island, 4=pond). The <code>Source</code> identifies the data source
(1=WVS, 0=CIA (WDBII)).
</p>


<h3>Value</h3>

<p>A <code>PolySet</code> with a <code>PolyData</code> attribute.
</p>


<h3>Note</h3>

<p>The function calls a C routine, also called <code>importGSHHS</code>, which returns
a set of map coordinates that is not always predictably laid out. 
This issue stems from how the world is divided at the Greenwich meridian and
at the International Date Line. 
The unpredictability occurs when user-specified X-limits span either of the 
longitudinal meridians &ndash; (0<code class="reqn">^\circ</code>, 360<code class="reqn">^\circ</code>) or 
(-180<code class="reqn">^\circ</code>, 180<code class="reqn">^\circ</code>).
</p>
<p>This version of the R function attempts to stitch together the overlapping 
edges of <code>gshhs</code> that run from -20<code class="reqn">^\circ</code> to 
360<code class="reqn">^\circ</code> (see example map 5 below). 
At present, no attempt has been made to deal with the overlap 
at the International Date Line where Russia overlaps the Aleutian Islands of
Alaska. To some extent, the C-code can deal with this, but not in all cases.
</p>
<p>Therefore, the user will likely experience some limitations when using 
<code>importGSHHS</code>.
The solution is to import the whole dataset with this function using
<code>xlim=c(0,360)</code>, and then apply the function <code>refocusWorld</code>
with user-desired X-limits. 
The Y-limits are generally not problematic unless the user wants to focus on
either pole.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB
</p>
<p>Maintainer: <a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Offsite, Vancouver BC<br />
Last modified <code>Rd: 2023-10-30</code>
</p>


<h3>References</h3>

<p>Wessel, P., and Smith, W.H.F. (1996)
<a href="http://www.soest.hawaii.edu/pwessel/gshhg/Wessel+Smith_1996_JGR.pdf">A Global Self-consistent, Hierarchical, High-resolution Shoreline Database</a>.
<em>J. Geophys. Res.</em> <b>101</b> 8741-8743.
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+importEvents">importEvents</a></code>,
<code><a href="#topic+importLocs">importLocs</a></code>, 
<code><a href="#topic+importPolys">importPolys</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
useWest=FALSE
useVers=c("2.2.0","2.2.3","2.3.0","2.3.4") # GSHHG versions
mapswitch = 5
for (i in c("land","rivers","borders"))
  if (exists(i)) eval(parse(text=paste0("rm(",i,")")))
switch( mapswitch,
 # 1. Canada------------------------------------------------
      {vN=4; useWest=T; xlim=c(-150,-50)+360;ylim=c(40,75)},
 # 2. NW Canada &amp; America-----------------------------------
      {vN=4; useWest=T;xlim=c(-136,-100)+360;ylim=c(40,75)},
 # 3. Black Sea (user Ivailo)-------------------------------
      {vN=4; xlim=c(27.5, 34.3); ylim=c(40.9, 46.7)},
 # 4. W Europe, NW Africa (user Uli)------------------------
      {vN=4; xlim=c(-20,10); ylim=c(20,50)},
 # 5. W Europe + Iceland------------------------------------
      {vN=4; xlim=c(-25, 20); ylim=c(40, 68)},
 # 6. New Zealand-------------------------------------------
      {vN=4; xlim=c(163, 182); ylim=c(-48,-34)},
 # 7. Australia---------------------------------------------
      {vN=4; xlim=c(112,155); ylim=c(-44,-10)},
 # 8. Japan-------------------------------------------------
      {vN=4; xlim=c(127,148); ylim=c(30,47)},
 # 9. Central America---------------------------------------
      {vN=4; useWest=T; xlim=c(-95,-60)+360;ylim=c(-10,25)},
 #10. North Pacific-----------------------------------------
      {vN=4; useWest=T; xlim=c(150,220); ylim=c(45,80)},
 #11. Pacific Ocean-----------------------------------------
      {vN=4; xlim=c(112,240); ylim=c(-48,80)},
 #12. North Atlantic (world coordinates)--------------------
      {vN=4; xlim=c(285,360); ylim=c(40,68)},
 #13. North Atlantic (western hemisphere coordinates)-------
      {vN=4; xlim=c(-75,0); ylim=c(40,68)},
 #14. Atlantic Ocean----------------------------------------
      {vN=4; xlim=c(285,380); ylim=c(-50,68)},
 #15. Northern hemisphere-----------------------------------
      {vN=4; xlim=c(-180,180); ylim=c(0,85)},
 #16. Asia--------------------------------------------------
      {vN=4; xlim=c(0,180); ylim=c(0,80)},
 #17. North America-----------------------------------------
      {vN=4; xlim=c(-180,0); ylim=c(0,80)},
 #18. International date line-------------------------------
      {vN=4; xlim=c(45,315); ylim=c(0,80)},
 #19. Indian Ocean------------------------------------------
      {vN=4; xlim=c(20,130); ylim=c(-40,40)},
 #20. Moose County ("400 miles north of everywhere")--------
      {vN=4; xlim=c(272.5,280.5); ylim=c(43,47.5)}
)
db=paste0("gshhg-bin-",useVers[vN])        # database version folder
gshhg   = paste0("C:/Ruser/GSHHG/",db,"/") # directory with binary files
land    = importGSHHS(paste0(gshhg,"gshhs_i.b"),
          xlim=xlim,ylim=ylim,maxLevel=4,useWest=useWest)
rivers  = importGSHHS(paste0(gshhg,"wdb_rivers_i.b"),
          xlim=xlim,ylim=ylim,useWest=useWest)
borders = importGSHHS(paste0(gshhg,"wdb_borders_i.b"),
          xlim=xlim,ylim=ylim,useWest=useWest,maxLevel=1)
if(exists("land")){
  plotMap(land,xlim=xlim-ifelse(useWest,360,0),ylim=ylim,
    col="lemonchiffon",bg="aliceblue")
  if(!is.null(rivers)) addLines(rivers,col="blue")
  if(!is.null(borders)) addLines(borders,col="red",lwd=2)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='importLocs'>Import LocationSet from Text File</h2><span id='topic+importLocs'></span>

<h3>Description</h3>

<p>Import a text file and convert it into a LocationSet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importLocs(LocationSet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importLocs_+3A_locationset">LocationSet</code></td>
<td>
<p><code>character</code> &ndash; file name of LocationSet text file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An imported LocationSet.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2023-10-30</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+importPolys">importPolys</a></code>, <code><a href="#topic+importEvents">importEvents</a></code>, <code><a href="#topic+importGSHHS">importGSHHS</a></code>
</p>

<hr>
<h2 id='importPolys'>Import PolySet from Text File</h2><span id='topic+importPolys'></span>

<h3>Description</h3>

<p>Import a text file and convert it into a PolySet with optional PolyData attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importPolys(PolySet, PolyData=NULL, projection=NULL, zone=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importPolys_+3A_polyset">PolySet</code></td>
<td>
<p><code>character</code> &ndash; file name of PolySet text file.</p>
</td></tr>
<tr><td><code id="importPolys_+3A_polydata">PolyData</code></td>
<td>
<p><code>character</code> &ndash; optional file name of PolyData text file.</p>
</td></tr>
<tr><td><code id="importPolys_+3A_projection">projection</code></td>
<td>
<p><code>character</code> &ndash; optional projection attribute to add to EventData.</p>
</td></tr>
<tr><td><code id="importPolys_+3A_zone">zone</code></td>
<td>
<p><code>numeric</code> &ndash; optional zone attribute to add to EventData.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An imported PolySet with optional PolyData attribute.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2023-10-30</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+importEvents">importEvents</a></code>, <code><a href="#topic+importLocs">importLocs</a></code>, <code><a href="#topic+importGSHHS">importGSHHS</a></code>
</p>

<hr>
<h2 id='isConvex'>Determine Whether Polygons are Convex</h2><span id='topic+isConvex'></span>

<h3>Description</h3>

<p>Determine whether polygons found in a <a href="#topic+PolySet">PolySet</a> are convex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isConvex (polys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isConvex_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convex polygons do not self-intersect.  In a convex polygon, only the
first and last vertices may share the same coordinates (i.e., the
polygons are optionally closed).
</p>
<p>The function does not give special consideration to holes.  It returns
a value for each unique (<code>PID</code>, <code>SID</code>), regardless of
whether a contour represents a hole.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with columns <code>PID</code>, <code>SID</code> (<em>may be missing</em>),
and <code>convex</code>.  Column <code>convex</code> contains Boolean values.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isIntersecting">isIntersecting</a></code>,
<a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- calculate then print the polygons that are convex
  p &lt;- isConvex(nepacLL);
  #--- nepacLL actually contains no convex polygons
  print(p[p$convex,])
})
</code></pre>

<hr>
<h2 id='isIntersecting'>Determine Whether Polygons are Self-Intersecting</h2><span id='topic+isIntersecting'></span>

<h3>Description</h3>

<p>Determine whether polygons found in a <a href="#topic+PolySet">PolySet</a> are
self-intersecting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isIntersecting (polys, numericResult = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isIntersecting_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to use.</p>
</td></tr>
<tr><td><code id="isIntersecting_+3A_numericresult">numericResult</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, returns the number
of intersections.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>numericResult = TRUE</code>, this function counts intersections
as the algorithm processes them.  It counts certain types (i.e., those
involving vertices and those where an edge retraces over an edge) more
than once.
</p>
<p>The function does not give special consideration to holes.  It returns
a value for each unique (<code>PID</code>, <code>SID</code>), regardless of
whether a contour represents a hole.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with columns <code>PID</code>, <code>SID</code> (<em>may be missing</em>),
and <code>intersecting</code>.  If <code>numericResult</code> is <code>TRUE</code>,
<code>intersecting</code> contains the number of intersections.  Otherwise,
it contains a Boolean value.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isConvex">isConvex</a></code>,
<a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
  data(nepacLL,envir=.PBSmapEnv)
  #--- calculate then print the polygons that are self-intersecting
  p &lt;- isIntersecting(nepacLL, numericResult = FALSE)
  print(p[p$intersecting,])
})
</code></pre>

<hr>
<h2 id='joinPolys'>Join One or Two PolySets using a Logic Operation</h2><span id='topic+joinPolys'></span>

<h3>Description</h3>

<p>Join one or two PolySets using a logic operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinPolys(polysA, polysB=NULL, operation="INT")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinPolys_+3A_polysa">polysA</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to join.</p>
</td></tr>
<tr><td><code id="joinPolys_+3A_polysb">polysB</code></td>
<td>
<p>optional second <a href="#topic+PolySet">PolySet</a> with which to join.</p>
</td></tr>
<tr><td><code id="joinPolys_+3A_operation">operation</code></td>
<td>
<p>one of <code>"DIFF"</code>, <code>"INT"</code>, <code>"UNION"</code>,
or <code>"XOR"</code>, representing difference, intersection, union, and
exclusive-or, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function interfaces with the <a href="https://www.angusj.com/delphi/clipper.php">Clipper library</a>,
specifically version 6.2.1 released 2014-10-31, developed by Angus Johnson.
Prior to 2013-03-23, <code>'joinPolys'</code> used the General Polygon Clipper library
by Alan Murta at the University of Manchester.
We keep this historic reference to GPC because <code>'joinPolys'</code> remains faithful
to Murta's definition of a generic polygon, which we describe below.
</p>
<p>Murta (2004) defines a <em>generic polygon</em> (or <em>polygon set</em>)
as zero or more disjoint boundaries of arbitrary configuration.  He
relates a <em>boundary</em> to a contour, where each may be convex,
concave or self-intersecting. In a PolySet, the polygons associated
with each unique <code>PID</code> loosely correspond to a generic polygon,
as they can represent both inner and outer boundaries.  Our use of the
term <em>generic polygon</em> includes the restrictions imposed by a
PolySet.  For example, the polygons for a given <code>PID</code> cannot
be arranged arbitrarily.
</p>
<p>If <code>'polysB'</code> is <code>NULL</code>, this function sequentially applies
the logic <code>'operation'</code> between the generic polygons in <code>'polysA'</code>.
For example, suppose <code>'polysA'</code> contains three generic polygons (A, B, C).
The function outputs the PolySet containing ((A <em>op</em> B) <em>op</em> C).
</p>
<p>If <code>'polysB'</code> is not <code>NULL</code>, this function applies the logic <code>'operation'</code>
between each generic polygon in <code>'polysA'</code> and each one in <code>'polysB'</code>.
For example, suppose <code>'polysA'</code> contains two generic polygons <code>(A, B)</code>
and <code>'polysB'</code> contains two generic polygons <code>(C, D)</code>.
The function's output is the concatenation of
A <em>op</em> C, B <em>op</em> C, A <em>op</em> D, B <em>op</em> D, with <code>PID</code>s 1 to 4, respectively.
Generally there are <em>n</em> times <em>m</em> comparisons, where <em>n</em> = number of polygons
in <code>'polysA'</code> and <em>m</em> = number of polygons in <code>'polysB'</code>.
If <code>'polysB'</code> contains only one generic polygon, the function
maintains the <code>PID</code>s from <code>'polysA'</code>.
It also maintains them when <code>'polysA'</code> contains only one generic polygon and
the <code>'operation'</code> is <code>"DIFF"</code> (difference).
Otherwise, if <code>'polysA'</code> contains only one generic polygon, it maintains
the <code>PID</code>s from <code>'polysB'</code>.
</p>


<h3>Value</h3>

<p>If <code>'polysB'</code> is <code>NULL</code>, the resulting PolySet contains
a single generic polygon (one <code>PID</code>), possibly with several
components (<code>SID</code>s).
The function recalculates the <code>PID</code> and <code>SID</code> columns.
</p>
<p>If <code>'polysB'</code> is not <code>NULL</code>, the resulting PolySet contains one or more
generic polygons (<code>PID</code>s), each with possibly several components (<code>SID</code>s).
The function recalculates the <code>SID</code> column, and depending on the input,
it may recalculate the <code>PID</code> column.
</p>


<h3>Author(s)</h3>

<p>C code: <a href="https://www.angusj.com/delphi/clipper.php">Angus Johnson</a>, Computer Programmer
</p>
<p>Implementation: <a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB
</p>
<p>Maintainer: <a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Offsite, Vancouver BC<br />
Last modified <code>Rd: 2023-10-30</code>
</p>


<h3>References</h3>

<p>Murta, A. (2004) <em>A General Polygon Clipping Library</em>. Accessed: Jul 29, 2004.
</p>
<p>Johnson, A. (2014) <em>Clipper</em> &ndash; an open source freeware library for clipping and offsetting lines and polygons. Accessed: Oct 31, 2014.
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+appendPolys">appendPolys</a></code>,
<code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<code><a href="#topic+thickenPolys">thickenPolys</a></code>,
<code><a href="#topic+thinPolys">thinPolys</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)

  ### Example 1. Cut a triangle out of Vancouver Island
  par(mfrow=c(1,1))
  #--- create a triangle to use in clipping
  polysB &lt;- data.frame(PID=rep(1, 3), POS=1:3,
    X=c(-127.5, -124.5, -125.6), Y = c(49.2, 50.3, 48.6))
  #--- intersect nepacLL with the single polygon, and plot the result
  plotMap(joinPolys(nepacLL, polysB), col="cyan")
  #--- add nepacLL in a different line type to emphasize the intersection
  addPolys(nepacLL, border="purple", lty=3, density=0)
  box()

  ### Example 2. Cut Texada and Lasqueti Islands out of Boxes
  xlim = list(box1=c(-124.8,-124),box2=c(-124,-123.9))
  ylim = list(box1=c(49.4,49.85), box2=c(49.85,49.9))
  Xlim = extendrange(xlim); Ylim=extendrange(ylim)
  polyA = as.PolySet(data.frame(
    PID = rep(1:2,each=4), POS = rep(1:4,2),
    X = as.vector(sapply(xlim,function(x){x[c(1,1,2,2)]})),
    Y = as.vector(sapply(ylim,function(x){x[c(1,2,2,1)]}))
    ), projection="LL")
  data(nepacLLhigh,envir=.PBSmapEnv)
  polyB = nepacLLhigh[is.element(nepacLLhigh$PID,c(736,1912)),]
  polyC = joinPolys(polyA, polyB, "DIFF")
  par(mfrow=c(2,2),cex=1,mgp=c(2,0.5,0))
  plotMap(polyA,col="lightblue",xlim=Xlim,ylim=Ylim)
  addPolys(polyB,col="gold");
  text(mean(Xlim)-0.05,Ylim-0.04,"Boxes (A,B)  and  Isles (C,D)")
  labs = calcCentroid(polyA)
  labs[1,c("X","Y")] = labs[2,c("X","Y")]+c(-0.1,-0.05)
  text(labs[,"X"],labs[,"Y"],c("A","B"),font=2)
  plotMap(polyC[is.element(polyC$PID,1),],col="pink",xlim=Xlim,ylim=Ylim)
  text(mean(Xlim)-0.05,Ylim-0.04,"Box A  \"DIFF\"  Isle C")
  plotMap(polyC[is.element(polyC$PID,3),],col="green",xlim=Xlim,ylim=Ylim)
  text(mean(Xlim)-0.05,Ylim-0.04,"Box A  \"DIFF\"  Isle D")
  plotMap(polyC[is.element(polyC$PID,c(1,3)),],col="cyan",xlim=Xlim,ylim=Ylim)
  text(mean(Xlim)-0.05,Ylim-0.04,"Box A  \"DIFF\"  Isles (C,D)")
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='locateEvents'>Locate Events on the Current Plot</h2><span id='topic+locateEvents'></span>

<h3>Description</h3>

<p>Locate events on the current plot (using the <code><a href="graphics.html#topic+locator">locator</a></code>
function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locateEvents (EID, n = 512, type = "p", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locateEvents_+3A_eid">EID</code></td>
<td>
<p>vector of event IDs (<em>optional</em>).</p>
</td></tr>
<tr><td><code id="locateEvents_+3A_n">n</code></td>
<td>
<p>maximum number of events to locate.</p>
</td></tr>
<tr><td><code id="locateEvents_+3A_type">type</code></td>
<td>
<p>one of <code>"n"</code>, <code>"p"</code>, <code>"l"</code>, or
<code>"o"</code>. If <code>"p"</code> or <code>"o"</code>, then the points are
plotted; if <code>"l"</code> or <code>"o"</code>, then the points are joined by
lines.</p>
</td></tr>
<tr><td><code id="locateEvents_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters for the
<code><a href="graphics.html#topic+locator">locator</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows its user to define events with mouse clicks on
the current plot via the <code><a href="graphics.html#topic+locator">locator</a></code> function.  The
arguments <code>n</code> and <code>type</code> are the usual parameters of the
<code><a href="graphics.html#topic+locator">locator</a></code> function.  If <code>EID</code> is not missing, then
<code>n = length(EID)</code>.
</p>
<p>On exit from <code><a href="graphics.html#topic+locator">locator</a></code>, suppose the user defined <em>m</em>
events.  If <code>EID</code> was missing, then the output data frame will
contain <em>m</em> events. However, if <code>EID</code> exists, then the
output data frame will contain <code>length(EID)</code> events, and both
<code>X</code> and <code>Y</code> will be <code>NA</code> for events
<code>EID[(</code><em>m</em><code>+1):n]</code>.  The <code><a href="stats.html#topic+na.omit">na.omit</a></code> function
can remove rows with <code>NA</code>s.
</p>


<h3>Value</h3>

<p><a href="#topic+EventData">EventData</a> with columns <code>EID</code>, <code>X</code>, and <code>Y</code>, and
<code>projection</code> attribute equal to the map's projection.  The
function does not set the <code>zone</code> attribute.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2007-06-06</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+combineEvents">combineEvents</a></code>,
<code><a href="#topic+convDP">convDP</a></code>,
<a href="#topic+EventData">EventData</a>,
<code><a href="#topic+findCells">findCells</a></code>,
<code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- define five events on the current plot, numbering them 10 to 14
## Not run: events &lt;- locateEvents(EID = 10:14)
</code></pre>

<hr>
<h2 id='locatePolys'>Locate Polygons on the Current Plot</h2><span id='topic+locatePolys'></span>

<h3>Description</h3>

<p>Locate polygons on the current plot (using the <code><a href="graphics.html#topic+locator">locator</a></code>
function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locatePolys (pdata, n = 512, type = "o", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locatePolys_+3A_pdata">pdata</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> (<em>optional</em>) with
columns <code>PID</code> and <code>SID</code> (<em>optional</em>), with two more
optional columns <code>n</code> and <code>type</code>.</p>
</td></tr>
<tr><td><code id="locatePolys_+3A_n">n</code></td>
<td>
<p>maximum number of points to locate.</p>
</td></tr>
<tr><td><code id="locatePolys_+3A_type">type</code></td>
<td>
<p>one of <code>"n"</code>, <code>"p"</code>, <code>"l"</code>, or
<code>"o"</code>. If <code>"p"</code> or <code>"o"</code>, then the points are
plotted; if <code>"l"</code>  or <code>"o"</code>, then the points are joined by
lines.</p>
</td></tr>
<tr><td><code id="locatePolys_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters for the
<code><a href="graphics.html#topic+locator">locator</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows its user to define polygons with mouse clicks on
the current plot via the <code><a href="graphics.html#topic+locator">locator</a></code> function.  The
arguments <code>n</code> and <code>type</code> are the usual parameters for the
<code><a href="graphics.html#topic+locator">locator</a></code> function, but the user can specify them for each
individual (<code>PID</code>, <code>SID</code>) in a <code>pdata</code> object.
</p>
<p>If a <code>pdata</code> object exists, the function ignores columns other
than <code>PID</code>, <code>SID</code>, <code>n</code>, and <code>type</code>.  If <code>pdata</code>
includes <code>n</code>, then an outer boundary has <code>n &gt; 0</code> and an
inner boundary has <code>n &lt; 0</code>.
</p>
<p>On exit from <code><a href="graphics.html#topic+locator">locator</a></code>, suppose the user defined <em>m</em>
vertices for a given polygon. For that polygon, the <code>X</code> and
<code>Y</code> columns will contain <code>NA</code>s where <code>POS =
  (</code><em>m</em><code>+1):n</code> for outer-boundaries and <code>POS =
  (|n|-</code><em>m</em><code>):1</code> for inner-boundaries.  The
<code><a href="stats.html#topic+na.omit">na.omit</a></code> function can remove rows with <code>NA</code>s.
</p>
<p>If a <code>pdata</code> object does not exist, the output contains only one
polygon with a <code>PID</code> equal to 1.  One inner-boundary polygon
(<code>POS</code> goes from <code>n</code> to <code>1</code>) can be generated by
supplying a negative <code>n</code>.
</p>
<p>If <code>type = "o"</code> or <code>type = "l"</code>, the function draws a line
connecting the last and first vertices.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> with <code>projection</code> attribute equal to the map's
projection.  The function does not set the <code>zone</code> attribute.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2007-06-06</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+appendPolys">appendPolys</a></code>,
<code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+findCells">findCells</a></code>,
<code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>,
<code><a href="#topic+joinPolys">joinPolys</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPolys">plotPolys</a></code>,
<code><a href="#topic+thickenPolys">thickenPolys</a></code>,
<code><a href="#topic+thinPolys">thinPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- define one polygon with up to 5 vertices on the current plot
## Not run: polys &lt;- locatePolys(n = 5)
</code></pre>

<hr>
<h2 id='LocationSet'>LocationSet Objects</h2><span id='topic+LocationSet'></span><span id='topic+as.LocationSet'></span><span id='topic+is.LocationSet'></span>

<h3>Description</h3>

<p>A LocationSet comprises a data frame that summarises which EventData points
(<code>EID</code>) lie in which PolySet polygons (<code>PID</code>) or 
(<code>PID</code>, <code>SID</code>).
Events not located in target polygons are not reported. If an event lies on a
polygon boundary, an additional LocationSet field called <code>Bdry</code> is set
to <code>TRUE</code>. One event can also occur in multiple polygons.
</p>
<p><span class="pkg">PBSmapping</span> functions that expect LocationSet's will accept properly
formatted data frames in their place (see 'Details').
</p>
<p><code>as.LocationSet</code> attempts to coerce a data frame to an object with
class LocationSet.
</p>
<p><code>is.LocationSet</code> returns <code>TRUE</code> if its argument is of class
LocationSet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.LocationSet(x)
is.LocationSet(x, fullValidation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocationSet_+3A_x">x</code></td>
<td>
<p>data frame to be coerced or tested.</p>
</td></tr>
<tr><td><code id="LocationSet_+3A_fullvalidation">fullValidation</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, fully test
<code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <a href="#topic+PolySet">PolySet</a> can define regional boundaries for drawing a map, and
<a href="#topic+EventData">EventData</a> can give event points on the map. Which events occur in
which regions? Our function <code><a href="#topic+findPolys">findPolys</a></code> resolves this
problem. The output lies in a LocationSet, a data frame with three or
four columns (<code>EID</code>, <code>PID</code>, <code>SID</code>, <code>Bdry</code>), where
<code>SID</code> may be missing. One row in a LocationSet means that the event
<code>EID</code> occurs in the polygon (<code>PID</code>, <code>SID</code>). The boundary
(<code>Bdry</code>) field specifies whether (<code>Bdry=T</code>) or not
(<code>Bdry=F</code>) the event lies on the polygon boundary. If <code>SID</code>
refers to an inner polygon boundary, then <code>EID</code> occurs in
(<code>PID</code>, <code>SID</code>) only if <code>Bdry=T</code>. An event may occur in
multiple polygons. Thus, the same <code>EID</code> can occur in multiple
records. If an <code>EID</code> does not fall in any (<code>PID</code>, <code>SID</code>),
or if it falls within a hole, it does not occur in the output
LocationSet. Inserting the string <code>"LocationSet"</code> as the first
element of a LocationSet's <code>class</code> attribute alters the behaviour
of some functions, including <code><a href="base.html#topic+print">print</a></code> (if
<code><a href="#topic+PBSprint">PBSprint</a></code> is <code>TRUE</code>) and <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Value</h3>

<p>The <code>as.LocationSet</code> method returns an object with classes
<code>"LocationSet"</code> and <code>"data.frame"</code>, in that order.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2015-04-23</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+PolySet">PolySet</a>,
<a href="#topic+PolyData">PolyData</a>,
<a href="#topic+EventData">EventData</a>
</p>

<hr>
<h2 id='makeGrid'>Make a Grid of Polygons</h2><span id='topic+makeGrid'></span>

<h3>Description</h3>

<p>Make a grid of polygons, using <code>PID</code>s and <code>SID</code>s according
to the input arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGrid(x, y, byrow=TRUE, addSID=TRUE, 
   projection=NULL, zone = NULL, type="rectangle")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeGrid_+3A_x">x</code></td>
<td>
<p><code>numeric</code> &ndash; vector of X-coordinates (of length <code class="reqn">m</code>).</p>
</td></tr>
<tr><td><code id="makeGrid_+3A_y">y</code></td>
<td>
<p><code>numeric</code> &ndash; vector of Y-coordinates (of length <code class="reqn">n</code>).</p>
</td></tr>
<tr><td><code id="makeGrid_+3A_byrow">byrow</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code> <em>and</em> <code>type='rectangle'</code>, increment <code>PID</code> along X (column-wise);<br />
&ndash; if <code>TRUE</code> <em>and</em> <code>type='hexagon'</code>, create flat-topped hexagons contiguous by column and increment <code>PID</code> by column;<br />
&ndash; if <code>FALSE</code> <em>and</em> <code>type='hexagon'</code>, create pointy-topped hexagons contiguous by row and increment <code>PID</code> by row.</p>
</td></tr>
<tr><td><code id="makeGrid_+3A_addsid">addSID</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, include an <code>SID</code> field in
the resulting <a href="#topic+PolySet">PolySet</a>, incremented by the alternative dimension used by <code>PID</code>.</p>
</td></tr>
<tr><td><code id="makeGrid_+3A_projection">projection</code></td>
<td>
<p><code>character</code> &ndash; optional <code>projection</code> attribute to add to
the PolySet.</p>
</td></tr>
<tr><td><code id="makeGrid_+3A_zone">zone</code></td>
<td>
<p><code>numeric</code> &ndash; optional <code>zone</code> attribute to add to the PolySet.</p>
</td></tr>
<tr><td><code id="makeGrid_+3A_type">type</code></td>
<td>
<p><code>character</code> &ndash; type of regular tesselation; choices: <code>"rectangle"</code> or <code>"hexagon"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes a grid of polygons, labeling them according to
<code>byrow</code> and <code>addSID</code>.
</p>
<p>For rectangular tesselations (grid cells), the variables <code class="reqn">i</code> and <code class="reqn">j</code>
indicate column and row numbers, respectively, where the lower-left cell
of the grid is (1, 1):
</p>

<ul>
<li> <p><code>byrow</code> <code class="reqn">=</code> <code>TRUE</code> and <code>addSID</code> <code class="reqn">=</code>
<code>FALSE</code> implies <code>PID</code> <code class="reqn">= i + (j - 1) \times (m -
        1)</code>
</p>
</li>
<li> <p><code>byrow</code> <code class="reqn">=</code> <code>FALSE</code> and <code>addSID</code> <code class="reqn">=</code>
<code>FALSE</code> implies <code>PID</code> <code class="reqn">= j + (i - 1) \times (n -
        1)</code>
</p>
</li>
<li> <p><code>byrow</code> <code class="reqn">=</code> <code>TRUE</code> and <code>addSID</code> <code class="reqn">=</code>
<code>TRUE</code> implies <code>PID</code> <code class="reqn">= i</code>, <code>SID</code> <code class="reqn">= j</code>
</p>
</li>
<li> <p><code>byrow</code> <code class="reqn">=</code> <code>FALSE</code> and <code>addSID</code> <code class="reqn">=</code>
<code>TRUE</code> implies <code>PID</code> <code class="reqn">= j</code>, <code>SID</code> <code class="reqn">= i</code>
</p>
</li></ul>

<p>For hexagonal tesselations (grid cells), <code class="reqn">i</code> indicates columns for flat-topped
hexagons and rows for pointy-topped hexagons. The reverse is true for <code class="reqn">j</code>.
Stemming from their six-sided nature, hexagons will adjoin along a long-edge by row when
their orientation is such that one vertex is higher than all the others.
Hexagons will adjoin along a long-edge by column when their orientation shows two
uppermost vertices.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> with columns <code>PID</code>, <code>SID</code>
(<em>if</em> <code>addSID=TRUE</code>), <code>POS</code>, <code>X</code>, and <code>Y</code>.<br />
The PolySet is a set of rectangular grid cells when <code>type='rectangle'</code>, with
vertices:<br />
<code class="reqn">(x_{i}, y_{j}), (x_{i+1}, y_{j}), (x_{i+1}, y_{j+1}), (x_{i},
    y_{j+1})</code>.<br />
The PolySet is a set of hexagonal grid cells when <code>type='hexagon'</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB
</p>
<p><a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Institute of Ocean Sciences (IOS), Sidney BC<br />
Last modified <code>Rd: 2019-01-04</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+combineEvents">combineEvents</a></code>,
<code><a href="#topic+findCells">findCells</a></code>,
<code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+thickenPolys">thickenPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  ##--- make a 10 x 10 grid
  polyGrid &lt;- makeGrid(x=0:10, y=0:10)
  ##--- plot the grid
  plotPolys(polyGrid, density=0, projection=1)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='makeProps'>Make Polygon Properties</h2><span id='topic+makeProps'></span>

<h3>Description</h3>

<p>Append a column for a polygon property (e.g., <code>border</code> or
<code>lty</code>) to <a href="#topic+PolyData">PolyData</a> based on measurements in the
<a href="#topic+PolyData">PolyData</a>'s <code>Z</code> column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeProps(pdata,breaks,propName="col",propVals=1:(length(breaks)-1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeProps_+3A_pdata">pdata</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> with a <code>Z</code> column.</p>
</td></tr>
<tr><td><code id="makeProps_+3A_breaks">breaks</code></td>
<td>
<p>either a vector of cut points or a scalar denoting the
number of intervals that <code>Z</code> is to be cut into.</p>
</td></tr>
<tr><td><code id="makeProps_+3A_propname">propName</code></td>
<td>
<p>name of the new column to append to <code>pdata</code>.</p>
</td></tr>
<tr><td><code id="makeProps_+3A_propvals">propVals</code></td>
<td>
<p>vector of values to associate with <code>Z</code> breaks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function acts like the <code><a href="base.html#topic+cut">cut</a></code> function to produce
<a href="#topic+PolyData">PolyData</a> suitable for the <code>polyProps</code> plotting argument
(see <code><a href="#topic+addLabels">addLabels</a></code>, <code><a href="#topic+addLines">addLines</a></code>,
<code><a href="#topic+addPoints">addPoints</a></code>, <code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+addStipples">addStipples</a></code>, <code><a href="#topic+plotLines">plotLines</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,<code><a href="#topic+plotPoints">plotPoints</a></code>, and
<code><a href="#topic+plotPolys">plotPolys</a></code>).  The <code>Z</code> column of <code>pdata</code> is
equivalent to the data vector <code>x</code> of the <code><a href="base.html#topic+cut">cut</a></code>
function.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> with the same columns as <code>pdata</code> plus an
additional column <code>propName</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addLabels">addLabels</a></code>,
<code><a href="#topic+addLines">addLines</a></code>,
<code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+addStipples">addStipples</a></code>,
<code><a href="#topic+plotLines">plotLines</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<code><a href="#topic+plotPolys">plotPolys</a></code>,
<a href="#topic+PolyData">PolyData</a>,
<a href="#topic+PolySet">PolySet</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- create a PolyData object
  pd &lt;- data.frame(PID=1:10, Z=1:10)

  #--- using 3 intervals, create a column named `col' and populate it with
  #--- the supplied values
  makeProps(pdata=pd, breaks=3, propName="col", propVals=c(1:3))
})
</code></pre>

<hr>
<h2 id='makeTopography'>
Make Topography Data from Online Source
</h2><span id='topic+makeTopography'></span>

<h3>Description</h3>

<p>Make topography data suitable for the <code>'graphics::contour'</code> and
<code>'grDevices::contourLines'</code> functions using freely available global
seafloor topography data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTopography (dat, digits=2, func=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTopography_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code> &ndash; data with three optionally-named columns: <code>x</code>,
<code>y</code>, and <code>z</code>.  The columns must appear in that order.</p>
</td></tr>
<tr><td><code id="makeTopography_+3A_digits">digits</code></td>
<td>
<p><code>numeric</code> &ndash; integer indicating the precision to be used by the function
<code>round</code> on <code>(x,y)</code> values.</p>
</td></tr>
<tr><td><code id="makeTopography_+3A_func">func</code></td>
<td>
<p><code>function</code> &ndash; to summarize <code>z</code> if <code>(x,y)</code> points are duplicated. 
Defaults to <code>mean()</code> if no function is specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suitable data can be obtained through the <a href="https://topex.ucsd.edu/cgi-bin/get_data.cgi">Topex acquisition form</a>.
The function <code>'utils::read.table'</code> will import dowloaded ASCII files into R,
creating objects suitable for the argument <code>'dat'</code> in <code>'makeTopography'</code>.
</p>
<p>When creating data for regions with longitude values spanning
-180<code class="reqn">^\circ</code> to 0<code class="reqn">^\circ</code>, consider
subtracting 360 from the result's longitude coordinates (<code>x</code>).
</p>
<p>When creating bathymetry data, consider negating the result's
elevations (<code>z</code>) to give depths positive values.
</p>
<p>Combinations of <code>(x,y)</code> do not need to be complete (<code>z[x,y]=NA</code>) or 
unique (<code>z[x,y] = func(z[x,y])</code>).
</p>


<h3>Value</h3>

<p>List with elements <code>x</code>, <code>y</code>, and <code>z</code>. Elements <code>x</code> and
<code>y</code> are vectors, while <code>z</code> is a matrix with rownames <code>x</code>
and colnames <code>y</code>.
The functions <code>'graphics::contour'</code> and <code>'grDevices::contourLines'</code>
expect data conforming to this list format.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
</p>
<p>Maintainer: <a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Institute of Ocean Sciences (IOS), Sidney BC<br />
Last modified <code>Rd: 2021-01-11</code>
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">graphics</span>:<br />
<code><a href="graphics.html#topic+contour">contour</a></code><br />
In package <span class="pkg">grDevices</span>:<br />
<code><a href="grDevices.html#topic+contourLines">contourLines</a></code><br />
In package <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+convCP">convCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- Example 1: Sample data frame and conversion.
  file &lt;- data.frame(X=c(1,1,2,2),Y=c(3,4,3,4),Z=c(5,6,7,8))
  print(makeTopography(file))

  #--- Example 2: Aleutian Islands bathymetry
  isob &lt;- c(100,500,1000,2500,5000)
  icol &lt;- rgb(0,0,seq(255,100,len=length(isob)),max=255)
  afile &lt;- paste(system.file(package="PBSmapping"),
    "/Extra/aleutian.txt",sep="")
  aleutian &lt;- read.table(afile, header=FALSE, col.names=c("x","y","z"))
  aleutian$x &lt;- aleutian$x - 360
  aleutian$z &lt;- -aleutian$z
  alBathy &lt;- makeTopography(aleutian)
  alCL &lt;- contourLines(alBathy,levels=isob)
  alCP &lt;- convCP(alCL)
  alPoly &lt;- alCP$PolySet
  attr(alPoly,"projection") &lt;- "LL"
  plotMap(alPoly, type="n", cex.axis=1.2, cex.lab=1.5)
  addLines(alPoly,col=icol)
  data(nepacLL,envir=.PBSmapEnv)
  addPolys(nepacLL,col="gold")
  legend(x="topleft",bty="n",col=icol,lwd=2,legend=as.character(isob))
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='nepacLL'>
Data: Shorelines of the NE Pacific Ocean and of the World
</h2><span id='topic+nepacLL'></span><span id='topic+nepacLLhigh'></span><span id='topic+worldLL'></span><span id='topic+worldLLhigh'></span>

<h3>Description</h3>

<p><a href="#topic+PolySet">PolySet</a> of polygons for the shorelines of the northeast Pacific Ocean
and of the world, both in normal and high resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(nepacLL)
  data(nepacLLhigh)
  data(worldLL)
  data(worldLLhigh)
</code></pre>


<h3>Format</h3>

<p>Data frame consisting of 4 columns: <code>PID</code> = primary polygon ID,
<code>POS</code> = position of each vertex within a given polygon, <code>X</code>
= longitude coordinate, and <code>Y</code> = latitude coordinate.   Attributes:
<code>projection = "LL"</code>.
</p>


<h3>Note</h3>

<p>In R, the data must be loaded using the <code><a href="utils.html#topic+data">data</a></code> function.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2023-10-30</code>
</p>


<h3>Source</h3>

<p>Polygon data from the GSHHG (Global Self-consistent, Hierarchical,
High-resolution Geography) Database. <br />
Download the native binary files of shoreline polygons, rivers, and borders
contained in the latest zip archive (version 2.3.4 ) at 
<a href="http://www.soest.hawaii.edu/pwessel/gshhg/">http://www.soest.hawaii.edu/pwessel/gshhg/</a>.
</p>
<pre>
nepacLL &lt;- importGSHHS("gshhs_h.b", xlim=c(-190,-110), ylim=c(34,72), 
           level=1, n=15, xoff=-360)

nepacLLhigh &lt;- importGSHHS("gshhs_f.b", xlim=c(-190,-110),
               ylim=c(34,72), level=1, n=0, xoff=-360)
nepacLLhigh &lt;- thinPolys(nepacLLhigh, tol=0.1, filter=3)

worldLL &lt;- importGSHHS("gshhs_l.b", xlim=c(-20,360), ylim=c(-90,90), 
           level=1, n=15, xoff=0)
worldLL &lt;- PBSmapping:::.fixGSHHSWorld(worldLL)

worldLLhigh &lt;- importGSHHS("gshhs_i.b", xlim=c(-20,360),
               ylim=c(-90,90), level=1, n=15, xoff=0)
worldLLhigh &lt;- PBSmapping:::.fixGSHHSWorld(worldLLhigh)
</pre>


<h3>References</h3>

<p>Wessel, P. and Smith, W.H.F. (1996) A global, self-consistent,
hierarchical, high-resolution shoreline database. <em>Journal of
Geophysical Research</em> <b>101</b>, 8741&ndash;8743. <br />
<a href="http://www.soest.hawaii.edu/pwessel/gshhg/Wessel+Smith_1996_JGR.pdf">http://www.soest.hawaii.edu/pwessel/gshhg/Wessel+Smith_1996_JGR.pdf</a>
</p>


<h3>See Also</h3>

<p>Data:<br />
<code><a href="#topic+bcBathymetry">bcBathymetry</a></code>,
<code><a href="#topic+surveyData">surveyData</a></code>,
<code><a href="#topic+towData">towData</a></code>
</p>
<p>Functions:<br />
<code><a href="#topic+importGSHHS">importGSHHS</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPolys">plotPolys</a></code>,
<code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+refocusWorld">refocusWorld</a></code>,
<code><a href="#topic+thickenPolys">thickenPolys</a></code>,
<code><a href="#topic+thinPolys">thinPolys</a></code>
</p>

<hr>
<h2 id='PBSprint'>Specify Whether to Print Summaries</h2><span id='topic+PBSprint'></span>

<h3>Description</h3>

<p>Specify whether PBS Mapping should print object summaries or not. If
not, data objects are displayed as normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PBSprint
</code></pre>


<h3>Details</h3>

<p>If <code>PBSprint = TRUE</code>, the mapping software will print summaries
rather than the data frames for EventData, LocationSet, PolyData, and
PolySet objects.  If <code>PBSprint = FALSE</code>, it will print the data
frames.
</p>
<p>This variable's default value is <code>FALSE</code>.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>, depending on the user's preference.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2007-06-06</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>.
</p>

<hr>
<h2 id='placeHoles'>
Place Holes Under Solids
</h2><span id='topic+placeHoles'></span>

<h3>Description</h3>

<p>Place secondary polygons identified as holes (inner contours)
under primary polygons identified as solids (outer contours)
if the vertices of the holes lie completely within the vertices of the solids. 
This operation is performed for each primary polygon until all holes
have been assigned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>placeHoles(polyset, minVerts=3, 
   orient=FALSE, show.progress=FALSE, unique.pid=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="placeHoles_+3A_polyset">polyset</code></td>
<td>
<p>a valid <span class="pkg">PBSmapping</span> PolySet.</p>
</td></tr>
<tr><td><code id="placeHoles_+3A_minverts">minVerts</code></td>
<td>
<p><code>numeric</code> &ndash; minimum number of vertices required for a polygon 
representing a hole to be retained (does not affect solids).</p>
</td></tr>
<tr><td><code id="placeHoles_+3A_orient">orient</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, use each polygon's rotation 
to determine its nature: clockwise = solid (outer contour), counter-clockwise =
hole (inner contour).</p>
</td></tr>
<tr><td><code id="placeHoles_+3A_show.progress">show.progress</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, display on the 
command console the progress of placing holes under solids.</p>
</td></tr>
<tr><td><code id="placeHoles_+3A_unique.pid">unique.pid</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, ignore the input PIDs
and redefine them from 1 to the number of solids; this inherently destroys
the previous organisation that a creator may have intended for the PolySet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm identifies outer contours (solids) and inner contours (holes)
using either the default PBSmapping method (solids = increasing <code>"POS"</code>,
holes = decreasing <code>"POS"</code>) or the rotational direction of the polygons
(solids = clockwise, holes = counter-clockwise).
</p>
<p>It then systematically starts matching holes with solids based on their vertices 
being completely within the boundaries of the solid.
If a hole happens to match a current solid completley (all vertices on the boundary),
then the hole is not matched to this solid because it is a hole in another solid
that creates space for the current solid.
</p>
<p>To facilitate computation, the algorithm assumes that once a 
hole is located in a solid, it will not occur in any other solid.
This means that for each successive solid, the number of 
candidate holes will either decrease or stay the same.
</p>
<p>This function makes use of the PBSmapping hidden function <code>".is.in"</code>
which uses the C code <code>"findPolys"</code>. The latter only returns events found
in a polygon (or on the boundary) but <code>.is.in</code> evaluates all events and 
returns a list containing:<br />
<code>"e.in"</code> &ndash; events within the polygon,<br />
<code>"e.out"</code> &ndash; events outside the polygon,<br />
<code>"all.in"</code> &ndash; logical value of whether all events are in the polygon,<br />
<code>"all.out"</code> &ndash; logical value of whether all events are outside the polygon,<br />
<code>"all.bdry"</code> &ndash; logical value of whether all events occur on the boundary of the polygon
</p>


<h3>Value</h3>

<p>Returns the input PolySet where holes have been arranged 
beneath appropriate solids for each <code>PID</code> (original or redefined).
</p>


<h3>Author(s)</h3>

<p><a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Offsite, Vancouver BC<br />
Last modified <code>Rd: 2023-10-30</code>
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+findPolys">findPolys</a></code>, 
<code><a href="#topic+is.PolySet">is.PolySet</a></code>,
<code><a href="#topic+dot-is.in">dot-is.in</a></code>
</p>

<hr>
<h2 id='plotLines'>Plot a PolySet as Polylines</h2><span id='topic+plotLines'></span>

<h3>Description</h3>

<p>Plot a <a href="#topic+PolySet">PolySet</a> as polylines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLines (polys, xlim = NULL, ylim = NULL, projection = FALSE,
           plt = c(0.11, 0.98, 0.12, 0.88), polyProps = NULL,
           lty = NULL, col = NULL, bg = 0, axes = TRUE,
           tckLab = TRUE, tck = 0.014, tckMinor = 0.5 * tck, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLines_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to plot (<em>required</em>).</p>
</td></tr>
<tr><td><code id="plotLines_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_projection">projection</code></td>
<td>
<p>desired projection when <a href="#topic+PolySet">PolySet</a> lacks a
<code>projection</code> attribute; one of <code>"LL"</code>, <code>"UTM"</code>,
or a numeric value.  If Boolean, specifies whether to check
<code>polys</code> for a <code>projection</code> attribute.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_plt">plt</code></td>
<td>
<p>four element numeric vector <code>(x1, x2, y1, y2)</code> giving
the coordinates of the plot region measured as a fraction of the
figure region. Set to <code>NULL</code> if <code>mai</code> in <code>par</code> is
desired.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_polyprops">polyProps</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> specifying which polylines to plot and their
properties.  <code><a href="graphics.html#topic+par">par</a></code> parameters passed as direct arguments
supersede these data.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_lty">lty</code></td>
<td>
<p>vector describing line types (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotLines_+3A_col">col</code></td>
<td>
<p>vector describing colours (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotLines_+3A_bg">bg</code></td>
<td>
<p>background colour of the plot.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_axes">axes</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, plot axes.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_tcklab">tckLab</code></td>
<td>
<p>Boolean vector (length 1 or 2); if <code>TRUE</code>, 
label the major tick marks.  If given a two-element
vector, the first element describes the tick marks on the
x-axis and the second element describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_tck">tck</code></td>
<td>
<p>numeric vector (length 1 or 2) describing the length
of tick marks as a fraction of the smallest dimension. If
<code>tckLab = TRUE</code>, these tick marks will be automatically
labelled.  If given a two-element vector, the first element
describes the tick marks on the x-axis and the second element
describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_tckminor">tckMinor</code></td>
<td>
<p>numeric vector (length 1 or 2) describing the length
of tick marks as a fraction of the smallest dimension.  These tick
marks can not be automatically labelled.  If given a two-element vector,
the first element describes the tick marks on the x-axis and
the second element describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotLines_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters, or the arguments
<code>main</code>, <code>sub</code>, <code>xlab</code>, or <code>ylab</code> for the
<code><a href="graphics.html#topic+title">title</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a <a href="#topic+PolySet">PolySet</a>, where each unique (<code>PID</code>,
<code>SID</code>) describes a polyline.  It does not connect each polyline's
last vertex to its first.  Unlike <code><a href="#topic+plotMap">plotMap</a></code>, the function
ignores the aspect ratio.  It clips <code>polys</code> to <code>xlim</code> and
<code>ylim</code> before plotting.
</p>
<p>The function creates a blank plot when <code>polys</code> equals
<code>NULL</code>.  In this case, the user must supply both <code>xlim</code> and
<code>ylim</code> arguments.  Alternatively, it accepts the argument
<code>type = "n"</code> as part of ..., which is equivalent to specifying
<code>polys = NULL</code>, but requires a <a href="#topic+PolySet">PolySet</a>.  In both cases,
the function's behaviour changes slightly.  To resemble the
<code><a href="base.html#topic+plot">plot</a></code> function, it plots the border, labels, and other
parts according to <code><a href="graphics.html#topic+par">par</a></code> parameters such as <code>col</code>.
</p>
<p>For additional help on the arguments <code>lty</code> and <code>col</code>, please
see <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> consisting of the <code>PolyProp</code>s used to create the plot.
</p>


<h3>Note</h3>

<p>To satisfy the aspect ratio, this plotting routine resizes the plot
region.  Consequently, <code><a href="graphics.html#topic+par">par</a></code> parameters such as
<code>plt</code>, <code>mai</code>, and <code>mar</code> will change.  When the function
terminates, these changes persist to allow for additions to the plot.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addLines">addLines</a></code>, <code><a href="#topic+calcLength">calcLength</a></code>, <code><a href="#topic+clipLines">clipLines</a></code>,
<code><a href="#topic+closePolys">closePolys</a></code>, <code><a href="#topic+convLP">convLP</a></code>, <code><a href="#topic+fixBound">fixBound</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>,
</p>
<p><code><a href="#topic+locatePolys">locatePolys</a></code>, <code><a href="#topic+thinPolys">thinPolys</a></code>, <code><a href="#topic+thickenPolys">thickenPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create a PolySet to plot
  polys &lt;- data.frame(PID=rep(1,4),POS=1:4,X=c(0,1,1,0),Y=c(0,0,1,1))
  #--- plot the PolySet
  plotLines(polys, xlim=c(-.5,1.5), ylim=c(-.5,1.5))
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='plotMap'>Plot a PolySet as a Map</h2><span id='topic+plotMap'></span>

<h3>Description</h3>

<p>Plot a <a href="#topic+PolySet">PolySet</a> as a map, using the correct aspect ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMap (polys, xlim = NULL, ylim = NULL, projection = TRUE,
         plt = c(0.11, 0.98, 0.12, 0.88), polyProps = NULL,
         border = NULL, lty = NULL, col = NULL, colHoles = NULL,
         density = NA, angle = NULL, bg = 0, axes = TRUE,
         tckLab = TRUE, tck = 0.014, tckMinor = 0.5 * tck, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMap_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to plot (<em>required</em>).</p>
</td></tr>
<tr><td><code id="plotMap_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_projection">projection</code></td>
<td>
<p>desired projection when <a href="#topic+PolySet">PolySet</a> lacks a
<code>projection</code> attribute; one of <code>"LL"</code>, <code>"UTM"</code>,
or a numeric value.  If Boolean, specifies whether to check
<code>polys</code> for a <code>projection</code> attribute.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_plt">plt</code></td>
<td>
<p>four element numeric vector <code>(x1, x2, y1, y2)</code> giving
the coordinates of the plot region measured as a fraction of the
figure region. Set to <code>NULL</code> if <code>mai</code> in <code>par</code> is
desired.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_polyprops">polyProps</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> specifying which polygons to plot and their
properties.  <code><a href="graphics.html#topic+par">par</a></code> parameters passed as direct arguments
supersede these data.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_border">border</code></td>
<td>
<p>vector describing edge colours (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotMap_+3A_lty">lty</code></td>
<td>
<p>vector describing line types (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotMap_+3A_col">col</code></td>
<td>
<p>vector describing fill colours (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotMap_+3A_colholes">colHoles</code></td>
<td>
<p>vector describing hole colours (cycled by <code>PID</code>).
The default, <code>NULL</code>, should be used in most cases as it renders
holes transparent. <code>colHoles</code> is designed solely to eliminate
retrace lines when images are converted to PDF format. If
<code>colHoles</code> is specified, underlying information (i.e., previously
plotted shapes) will be obliterated.  If <code>NA</code> is specified, only
outer polygons are drawn, consequently filling holes.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_density">density</code></td>
<td>
<p>vector describing shading line densities (lines per
inch, cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotMap_+3A_angle">angle</code></td>
<td>
<p>vector describing shading line angles (degrees, cycled by
<code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotMap_+3A_bg">bg</code></td>
<td>
<p>background colour of the plot.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_axes">axes</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, plot axes.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_tcklab">tckLab</code></td>
<td>
<p>Boolean vector (length 1 or 2); if <code>TRUE</code>,
label the major tick marks.  If given a two-element
vector, the first element describes the tick marks on the
x-axis and the second element describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_tck">tck</code></td>
<td>
<p>numeric vector (length 1 or 2) describing the length
of tick marks as a fraction of the smallest dimension. If
<code>tckLab = TRUE</code>, these tick marks will be automatically
labelled.  If given a two-element vector, the first element
describes the tick marks on the x-axis and the second element
describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_tckminor">tckMinor</code></td>
<td>
<p>numeric vector (length 1 or 2) describing the length
of tick marks as a fraction of the smallest dimension.  These tick
marks can not be automatically labelled.  If given a two-element vector,
the first element describes the tick marks on the x-axis and
the second element describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters, or the arguments
<code>main</code>, <code>sub</code>, <code>xlab</code>, or <code>ylab</code> for the
<code><a href="graphics.html#topic+title">title</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a <a href="#topic+PolySet">PolySet</a>, where each unique (<code>PID</code>,
<code>SID</code>) describes a polygon.  It connects each polygon's last
vertex to its first.  The function supports both borders
(<code>border</code>, <code>lty</code>) and fills (<code>col</code>, <code>density</code>,
<code>angle</code>).  When supplied with the appropriate arguments, it can
draw only borders or only fills .  Unlike <code><a href="#topic+plotLines">plotLines</a></code> and
<code><a href="#topic+plotPolys">plotPolys</a></code>, it uses the aspect ratio supplied in the
<code>projection</code> attribute of <code>polys</code>.  If this attribute is
missing, it attempts to use its <code>projection</code> argument.  In the
absence of both, it uses a default aspect ratio of 1:1.  It clips
<code>polys</code> to <code>xlim</code> and <code>ylim</code> before plotting.
</p>
<p>The function creates a blank plot when <code>polys</code> equals
<code>NULL</code>.  In this case, the user must supply both <code>xlim</code> and
<code>ylim</code> arguments.  Alternatively, it accepts the argument
<code>type = "n"</code> as part of ..., which is equivalent to specifying
<code>polys = NULL</code>, but requires a <a href="#topic+PolySet">PolySet</a>.  In both cases,
the function's behaviour changes slightly.  To resemble the
<code><a href="graphics.html#topic+plot">plot</a></code> function, it plots the border, labels, and other
parts according to <code><a href="graphics.html#topic+par">par</a></code> parameters such as <code>col</code>.
</p>
<p>For additional help on the arguments <code>border</code>, <code>lty</code>,
<code>col</code>, <code>density</code>, and <code>angle</code>, please see
<code><a href="graphics.html#topic+polygon">polygon</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> consisting of the <code>PolyProp</code>s used to create the plot.
</p>


<h3>Note</h3>

<p>To satisfy the aspect ratio, this plotting routine resizes the plot
region.  Consequently, <code><a href="graphics.html#topic+par">par</a></code> parameters such as
<code>plt</code>, <code>mai</code>, and <code>mar</code> will change.  When the function
terminates, these changes persist to allow for additions to the plot.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addLabels">addLabels</a></code>,
<code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+addStipples">addStipples</a></code>,
<code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>,
<code><a href="#topic+plotLines">plotLines</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<code><a href="#topic+thinPolys">thinPolys</a></code>,
<code><a href="#topic+thickenPolys">thickenPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create a PolySet to plot
  polys &lt;- data.frame(PID=rep(1,4),POS=1:4,X=c(0,1,1,0),Y=c(0,0,1,1))
  #--- plot the PolySet
  plotMap(polys,xlim=c(-.5,1.5),ylim=c(-.5,1.5),density=0,projection=1)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='plotPoints'>Plot EventData/PolyData as Points</h2><span id='topic+plotPoints'></span>

<h3>Description</h3>

<p>Plot <a href="#topic+EventData">EventData</a>/<a href="#topic+PolyData">PolyData</a>, where each unique <code>EID</code> or
(<code>PID</code>, <code>SID</code>) describes a point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPoints (data, xlim = NULL, ylim = NULL, projection = FALSE,
            plt = c(0.11, 0.98, 0.12, 0.88), polyProps = NULL,
            cex = NULL, col = NULL, pch = NULL, axes = TRUE,
            tckLab = TRUE, tck = 0.014, tckMinor = 0.5 * tck, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPoints_+3A_data">data</code></td>
<td>
<p><a href="#topic+EventData">EventData</a> or <a href="#topic+PolyData">PolyData</a> to plot (<em>required</em>).</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_projection">projection</code></td>
<td>
<p>desired projection when <a href="#topic+PolySet">PolySet</a> lacks a
<code>projection</code> attribute; one of <code>"LL"</code>, <code>"UTM"</code>,
or a numeric value.  If Boolean, specifies whether to check
<code>polys</code> for a <code>projection</code> attribute.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_plt">plt</code></td>
<td>
<p>four element numeric vector <code>(x1, x2, y1, y2)</code> giving
the coordinates of the plot region measured as a fraction of the
figure region. Set to <code>NULL</code> if <code>mai</code> in <code>par</code> is
desired.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_polyprops">polyProps</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> specifying which points to plot and their
properties.  <code><a href="graphics.html#topic+par">par</a></code> parameters passed as direct arguments
supersede these data.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_cex">cex</code></td>
<td>
<p>vector describing character expansion factors (cycled by
<code>EID</code> or <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_col">col</code></td>
<td>
<p>vector describing colours (cycled by <code>EID</code> or
<code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_pch">pch</code></td>
<td>
<p>vector describing plotting characters (cycled by <code>EID</code>
or <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_axes">axes</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, plot axes.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_tcklab">tckLab</code></td>
<td>
<p>Boolean vector (length 1 or 2); if <code>TRUE</code>,
label the major tick marks.  If given a two-element
vector, the first element describes the tick marks on the
x-axis and the second element describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_tck">tck</code></td>
<td>
<p>numeric vector (length 1 or 2) describing the length
of tick marks as a fraction of the smallest dimension. If
<code>tckLab = TRUE</code>, these tick marks will be automatically
labelled.  If given a two-element vector, the first element
describes the tick marks on the x-axis and the second element
describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_tckminor">tckMinor</code></td>
<td>
<p>numeric vector (length 1 or 2) describing the length
of tick marks as a fraction of the smallest dimension.  These tick
marks can not be automatically labelled.  If given a two-element vector,
the first element describes the tick marks on the x-axis and
the second element describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters, or the arguments
<code>main</code>, <code>sub</code>, <code>xlab</code>, or <code>ylab</code> for the
<code><a href="graphics.html#topic+title">title</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function clips <code>data</code> to <code>xlim</code> and <code>ylim</code> before
plotting.  It only adds <a href="#topic+PolyData">PolyData</a> containing <code>X</code> and
<code>Y</code> columns.
</p>
<p>The function creates a blank plot when <code>polys</code> equals
<code>NULL</code>.  In this case, the user must supply both <code>xlim</code> and
<code>ylim</code> arguments.  Alternatively, it accepts the argument
<code>type = "n"</code> as part of ..., which is equivalent to specifying
<code>polys = NULL</code>, but requires a <a href="#topic+PolySet">PolySet</a>.  In both cases,
the function's behaviour changes slightly.  To resemble the
<code><a href="base.html#topic+plot">plot</a></code> function, it plots the border, labels, and other
parts according to <code><a href="graphics.html#topic+par">par</a></code> parameters such as <code>col</code>.
</p>
<p>For additional help on the arguments <code>cex</code>, <code>col</code>, and
<code>pch</code>, please see <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> consisting of the <code>PolyProp</code>s used to create the plot.
</p>


<h3>Note</h3>

<p>To satisfy the aspect ratio, this plotting routine resizes the plot
region.  Consequently, <code><a href="graphics.html#topic+par">par</a></code> parameters such as
<code>plt</code>, <code>mai</code>, and <code>mar</code> will change.  When the function
terminates, these changes persist to allow for additions to the plot.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+combineEvents">combineEvents</a></code>,
<code><a href="#topic+convDP">convDP</a></code>,
<code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+locateEvents">locateEvents</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,surveyData,envir=.PBSmapEnv)
  #--- plot a map
  plotMap(nepacLL, xlim=c(-136, -125), ylim=c(48, 57))
  #--- add events
  addPoints(surveyData, col=1:7)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='plotPolys'>Plot a PolySet as Polygons</h2><span id='topic+plotPolys'></span>

<h3>Description</h3>

<p>Plot a <a href="#topic+PolySet">PolySet</a> as polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPolys (polys, xlim = NULL, ylim = NULL, projection = FALSE,
           plt = c(0.11, 0.98, 0.12, 0.88), polyProps = NULL,
           border = NULL, lty = NULL, col = NULL, colHoles = NULL,
           density = NA, angle = NULL, bg = 0, axes = TRUE,
           tckLab = TRUE, tck = 0.014, tckMinor = 0.5 * tck, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPolys_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to plot (<em>required</em>).</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_xlim">xlim</code></td>
<td>
<p>range of X-coordinates.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_ylim">ylim</code></td>
<td>
<p>range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_projection">projection</code></td>
<td>
<p>desired projection when <a href="#topic+PolySet">PolySet</a> lacks a
<code>projection</code> attribute; one of <code>"LL"</code>, <code>"UTM"</code>,
or a numeric value.  If Boolean, specifies whether to check
<code>polys</code> for a <code>projection</code> attribute.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_plt">plt</code></td>
<td>
<p>four element numeric vector <code>(x1, x2, y1, y2)</code> giving
the coordinates of the plot region measured as a fraction of the
figure region. Set to <code>NULL</code> if <code>mai</code> in <code>par</code> is
desired.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_polyprops">polyProps</code></td>
<td>
<p><a href="#topic+PolyData">PolyData</a> specifying which polygons to
plot and their properties.  <code><a href="graphics.html#topic+par">par</a></code> parameters passed as
direct arguments supersede these data.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_border">border</code></td>
<td>
<p>vector describing edge colours (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_lty">lty</code></td>
<td>
<p>vector describing line types (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_col">col</code></td>
<td>
<p>vector describing fill colours (cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_colholes">colHoles</code></td>
<td>
<p>vector describing hole colours (cycled by <code>PID</code>).
The default, <code>NULL</code>, should be used in most cases as it renders holes 
transparent. <code>colHoles</code> is designed solely to eliminate retrace lines 
when images are converted to PDF format. If <code>colHoles</code> is specified, 
underlying information (i.e., previously plotted shapes) will be obliterated.
If <code>NA</code> is specified, only outer polygons are drawn, consequently filling holes.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_density">density</code></td>
<td>
<p>vector describing shading line densities (lines per
inch, cycled by <code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_angle">angle</code></td>
<td>
<p>vector describing shading line angles (degrees, cycled by
<code>PID</code>).</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_bg">bg</code></td>
<td>
<p>background colour of the plot.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_axes">axes</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, plot axes.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_tcklab">tckLab</code></td>
<td>
<p>Boolean vector (length 1 or 2); if <code>TRUE</code>,
label the major tick marks.  If given a two-element
vector, the first element describes the tick marks on the
x-axis and the second element describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_tck">tck</code></td>
<td>
<p>numeric vector (length 1 or 2) describing the length
of tick marks as a fraction of the smallest dimension. If
<code>tckLab = TRUE</code>, these tick marks will be automatically
labelled.  If given a two-element vector, the first element
describes the tick marks on the x-axis and the second element
describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_tckminor">tckMinor</code></td>
<td>
<p>numeric vector (length 1 or 2) describing the length
of tick marks as a fraction of the smallest dimension.  These tick
marks can not be automatically labelled.  If given a two-element
vector, the first element describes the tick marks on the x-axis and
the second element describes those on the y-axis.</p>
</td></tr>
<tr><td><code id="plotPolys_+3A_...">...</code></td>
<td>
<p>additional <code><a href="graphics.html#topic+par">par</a></code> parameters, or the arguments
<code>main</code>, <code>sub</code>, <code>xlab</code>, or <code>ylab</code> for the
<code><a href="graphics.html#topic+title">title</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a <a href="#topic+PolySet">PolySet</a>, where each unique (<code>PID</code>,
<code>SID</code>) describes a polygon.  It connects each polygon's last
vertex to its first.  The function supports both borders
(<code>border</code>, <code>lty</code>) and fills (<code>col</code>, <code>density</code>,
<code>angle</code>).  When supplied with the appropriate arguments, it can
draw only borders or only fills.  Unlike <code><a href="#topic+plotMap">plotMap</a></code>, it
ignores the aspect ratio.  It clips <code>polys</code> to <code>xlim</code> and
<code>ylim</code> before plotting.
</p>
<p>This function creates a blank plot when <code>polys</code> equals
<code>NULL</code>.  In this case, the user must supply both <code>xlim</code> and
<code>ylim</code> arguments.  Alternatively, it accepts the argument
<code>type = "n"</code> as part of ..., which is equivalent to specifying
<code>polys = NULL</code>, but requires a <a href="#topic+PolySet">PolySet</a>.  In both cases,
the function's behaviour changes slightly.  To resemble the
<code><a href="base.html#topic+plot">plot</a></code> function, it plots the border, labels, and other
parts according to <code><a href="graphics.html#topic+par">par</a></code> parameters such as <code>col</code>.
</p>
<p>For additional help on the arguments <code>border</code>, <code>lty</code>,
<code>col</code>, <code>density</code>, and <code>angle</code>, please see
<code><a href="graphics.html#topic+polygon">polygon</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolyData">PolyData</a> consisting of the <code>PolyProp</code>s used to create the plot.
</p>


<h3>Note</h3>

<p>To satisfy the aspect ratio, this plotting routine resizes the plot
region.  Consequently, <code><a href="graphics.html#topic+par">par</a></code> parameters such as
<code>plt</code>, <code>mai</code>, and <code>mar</code> will change.  When the function
terminates, these changes persist to allow for additions to the plot.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addLabels">addLabels</a></code>,
<code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+addStipples">addStipples</a></code>,
<code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+closePolys">closePolys</a></code>,
<code><a href="#topic+fixBound">fixBound</a></code>,
<code><a href="#topic+fixPOS">fixPOS</a></code>,
<code><a href="#topic+locatePolys">locatePolys</a></code>,
<code><a href="#topic+plotLines">plotLines</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<code><a href="#topic+thinPolys">thinPolys</a></code>,
<code><a href="#topic+thickenPolys">thickenPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- create a PolySet to plot
  polys &lt;- data.frame(PID=rep(1,4),POS=1:4,X=c(0,1,1,0),Y=c(0,0,1,1))
  #--- plot the PolySet
  plotPolys(polys, xlim=c(-.5,1.5), ylim=c(-.5,1.5), density=0)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='PolyData'>PolyData Objects</h2><span id='topic+PolyData'></span><span id='topic+as.PolyData'></span><span id='topic+is.PolyData'></span>

<h3>Description</h3>

<p>A PolyData object comprises a data frame that summarises information
for each polyline/polygon in a PolySet; each PolyData record is defined by
a unique <code>PID</code> or (<code>PID</code>, <code>SID</code> combination).
</p>
<p><span class="pkg">PBSmapping</span> functions that expect PolyData will accept properly
formatted data frames in their place (see 'Details').
</p>
<p><code>as.PolyData</code> attempts to coerce a data frame to an object with
class PolyData.
</p>
<p><code>is.PolyData</code> returns <code>TRUE</code> if its argument is of class
PolyData.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.PolyData(x, projection = NULL, zone = NULL)
is.PolyData(x, fullValidation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PolyData_+3A_x">x</code></td>
<td>
<p>data frame to be coerced or tested.</p>
</td></tr>
<tr><td><code id="PolyData_+3A_projection">projection</code></td>
<td>
<p>optional <code>projection</code> attribute to add to
PolyData, possibly overwriting an existing attribute.</p>
</td></tr>
<tr><td><code id="PolyData_+3A_zone">zone</code></td>
<td>
<p>optional <code>zone</code> attribute to add to PolyData,
possibly overwriting an existing attribute.</p>
</td></tr>
<tr><td><code id="PolyData_+3A_fullvalidation">fullValidation</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, fully test
<code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We define PolyData as a data frame with a first column named <code>PID</code>
and (optionally) a second column named <code>SID</code>. Unlike a
<a href="#topic+PolySet">PolySet</a>, where each contour has many records corresponding
to the vertices, a PolyData object must have only one record for each
<code>PID</code> or each (<code>PID</code>, <code>SID</code>) combination. Conceptually,
this object associates data with contours, where the data correspond to
additional fields in the data frame. The R language conveniently
allows data frames to contain fields of various atomic modes
(<code>"logical"</code>, <code>"numeric"</code>, <code>"complex"</code>,
<code>"character"</code>, and <code>"null"</code>). For example, PolyData with the
fields (<code>PID</code>, <code>PName</code>) might assign character names to a set
of primary polygons. Additionally, if fields <code>X</code> and <code>Y</code> exist
(perhaps representing locations for placing labels), consider adding
attributes <code>zone</code> and <code>projection</code>. Inserting the string
<code>"PolyData"</code> as the class attribute's first element alters the
behaviour of some functions, including <code><a href="base.html#topic+print">print</a></code> (if
<code><a href="#topic+PBSprint">PBSprint</a></code> is <code>TRUE</code>) and <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>Our software particularly uses PolyData to set various plotting
characteristics. Consistent with graphical parameters used by the R/S
functions <code><a href="graphics.html#topic+lines">lines</a></code> and <code><a href="graphics.html#topic+polygon">polygon</a></code>, column names
can specify graphical properties:
</p>

<ul>
<li> <p><code>lty</code> - line type in drawing the border and/or shading
lines;
</p>
</li>
<li> <p><code>col</code> - line or fill colour;
</p>
</li>
<li> <p><code>border</code> - border colour;
</p>
</li>
<li> <p><code>density</code> - density of shading lines;
</p>
</li>
<li> <p><code>angle</code> - angle of shading lines.
</p>
</li></ul>

<p>When drawing polylines (as opposed to closed polygons), only <code>lty</code>
and <code>col</code> have meaning.
</p>


<h3>Value</h3>

<p>The <code>as.PolyData</code> method returns an object with classes
<code>"PolyData"</code> and <code>"data.frame"</code>, in that order.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2015-04-23</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+PolySet">PolySet</a>,
<a href="#topic+EventData">EventData</a>,
<a href="#topic+LocationSet">LocationSet</a>
</p>

<hr>
<h2 id='PolySet'>PolySet Objects</h2><span id='topic+PolySet'></span><span id='topic+as.PolySet'></span><span id='topic+is.PolySet'></span>

<h3>Description</h3>

<p>A PolySet object comprises a data frame that defines a collection of
polygonal contours (i.e., line segments joined at vertices). These contours
can be open-ended (polylines) or closed (polygons).
</p>
<p><span class="pkg">PBSmapping</span> functions that expect PolySet's will accept properly
formatted data frames in their place (see 'Details').
</p>
<p><code>as.PolySet</code> attempts to coerce a data frame to an object with
class PolySet.
</p>
<p><code>is.PolySet</code> returns <code>TRUE</code> if its argument is of class
PolySet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.PolySet(x, projection = NULL, zone = NULL)
is.PolySet(x, fullValidation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PolySet_+3A_x">x</code></td>
<td>
<p>data frame to be coerced or tested.</p>
</td></tr>
<tr><td><code id="PolySet_+3A_projection">projection</code></td>
<td>
<p>optional <code>projection</code> attribute to add to
the PolySet, possibly overwriting an existing attribute.</p>
</td></tr>
<tr><td><code id="PolySet_+3A_zone">zone</code></td>
<td>
<p>optional <code>zone</code> attribute to add to the PolySet,
possibly overwriting an existing attribute.</p>
</td></tr>
<tr><td><code id="PolySet_+3A_fullvalidation">fullValidation</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, fully test
<code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In our software, a PolySet data frame defines a collection of polygonal
contours (i.e., line segments joined at vertices), based on four or five
numerical fields:
</p>

<ul>
<li> <p><code>PID</code> - the primary identification number for a contour;
</p>
</li>
<li> <p><code>SID</code> - optional, the secondary identification number for a
contour;
</p>
</li>
<li> <p><code>POS</code> - the position number associated with a vertex;
</p>
</li>
<li> <p><code>X</code> - the horizontal coordinate at a vertex;
</p>
</li>
<li> <p><code>Y</code> - the vertical coordinate at a vertex.
</p>
</li></ul>

<p>The simplest PolySet lacks an <code>SID</code> column, and each <code>PID</code>
corresponds to a different contour. By analogy with a child's
&ldquo;follow the dots&rdquo; game, the <code>POS</code> field enumerates the
vertices to be connected by straight lines. Coordinates (<code>X</code>,
<code>Y</code>) specify the location of each vertex. Thus, in familiar
mathematical notation, a contour consists of <code class="reqn">n</code> points 
(<code class="reqn">x_{i}, y_{i}</code>) with <code class="reqn">i = 1, ..., n</code>, where <code class="reqn">i</code> corresponds to the
<code>POS</code> index. A PolySet has two potential interpretations. The first
associates a line segment with each successive pair of points from 1 to
<code class="reqn">n</code>, giving a <em>polyline</em> (in GIS terminology) composed of the
sequential segments. The second includes a final line segment joining
points <code class="reqn">n</code> and 1, thus giving a <em>polygon</em>.
</p>
<p>The secondary ID field allows us to define regions as composites of
polygons. From this point of view, each primary ID identifies a
collection of polygons distinguished by secondary IDs. For example, a
single management area (<code>PID</code>) might consist of two fishing areas,
each defined by a unique <code>SID</code>. A secondary polygon can also
correspond to an inner boundary, like the hole in a doughnut. We adopt
the convention that <code>POS</code> goes from 1 to <code class="reqn">n</code> along an outer
boundary, but from <code class="reqn">n</code> to 1 along an inner boundary, regardless of
rotational direction. This contrasts with other GIS software, such as
ArcView (ESRI 1996), in which outer and inner boundaries correspond to
clockwise and counter-clockwise directions, respectively.
</p>
<p>The SID field in a PolySet with secondary IDs must have integer values
that appear in ascending order for a given <code>PID</code>. Furthermore,
inner boundaries must follow the outer boundary that encloses them. The
<code>POS</code> field for each contour (<code>PID</code>, <code>SID</code>) must
similarly appear as integers in strictly increasing or decreasing order,
for outer and inner boundaries respectively. If the <code>POS</code> field
erroneously contains floating-point numbers, <code><a href="#topic+fixPOS">fixPOS</a></code> can
renumber them as sequential integers, thus simplifying the insertion of
a new point, such as point 3.5 between points 3 and 4.
</p>
<p>A PolySet can have a <code>projection</code> attribute, which may be missing,
that specifies a map projection. In the current version of PBS Mapping,
projection can have character values <code>"LL"</code> or <code>"UTM"</code>,
referring to &ldquo;Longitude-Latitude&rdquo; and &ldquo;Universal
Transverse Mercator&rdquo;. We explain these projections more completely
below. If projection is numeric, it specifies the aspect ratio <code class="reqn">r</code>,
the number of <code class="reqn">x</code> units per <code class="reqn">y</code> unit. Thus, <code class="reqn">r</code> units of
<code class="reqn">x</code> on the graph occupy the same distance as one unit of
<code class="reqn">y</code>. Another optional attribute <code>zone</code> specifies the UTM zone
(if <code>projection="UTM"</code>) or the preferred zone for conversion from
Longitude-Latitude (if <code>projection="LL"</code>).
</p>
<p>A data frame's class attribute by default contains the string
<code>"data.frame"</code>. Inserting the string <code>"PolySet"</code> as the class
vector's first element alters the behaviour of some functions. For
example, the <code><a href="base.html#topic+summary">summary</a></code> function will print details specific
to a PolySet. Also, when <code><a href="#topic+PBSprint">PBSprint</a></code> is <code>TRUE</code>, the
print function will display a PolySet's summary rather than the contents
of the data frame.
</p>


<h3>Value</h3>

<p>The <code>as.PolySet</code> method returns an object with classes
<code>"PolySet"</code> and <code>"data.frame"</code>, in that order.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2022-09-06</code>
</p>


<h3>References</h3>

<p>Environmental Systems Research Institute (ESRI). (1996) <em>ArcView GIS:
The Geographic Information System for Everyone</em>. ESRI Press, Redlands,
California. 340 pp.
</p>


<h3>See Also</h3>

<p><a href="#topic+PolyData">PolyData</a>,
<a href="#topic+EventData">EventData</a>,
<a href="#topic+LocationSet">LocationSet</a>
</p>

<hr>
<h2 id='print'>Print PBS Mapping Objects</h2><span id='topic+print.EventData'></span><span id='topic+print.LocationSet'></span><span id='topic+print.PolyData'></span><span id='topic+print.PolySet'></span><span id='topic+print.summary.PBS'></span>

<h3>Description</h3>

<p>This function displays information about a PBS Mapping object.
</p>
<p>Functions <code>'summary.EventData'</code>, <code>'summary.LocationSet'</code>,
<code>'summary.PolyData'</code>, and <code>'summary.PolySet'</code>
produce an object with class <code>'summary.PBS'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EventData'
print(x, ...)
## S3 method for class 'LocationSet'
print(x, ...)
## S3 method for class 'PolyData'
print(x, ...)
## S3 method for class 'PolySet'
print(x, ...)
## S3 method for class 'summary.PBS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p><code>object</code> &ndash; a PBS Mapping object of appropriate <code>class</code>.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p><code>dots</code> &ndash; additional arguments to <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2019-03-14</code>
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br />
Data structures:
<a href="#topic+EventData">EventData</a>,
<a href="#topic+LocationSet">LocationSet</a>,
<a href="#topic+PolyData">PolyData</a>,
<a href="#topic+PolySet">PolySet</a><br />
Functions:
<code><a href="#topic+PBSprint">PBSprint</a></code>,
<code><a href="#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- change to summary printing style
  PBSprint &lt;- TRUE
  #--- print the PolySet
  print(nepacLL)
})
</code></pre>

<hr>
<h2 id='pythagoras'>Data: Pythagoras' Theorem Diagram PolySet</h2><span id='topic+pythagoras'></span>

<h3>Description</h3>

<p><a href="#topic+PolySet">PolySet</a> of shapes to prove Pythagoras' Theorem:
<code class="reqn">a^2 + b^2 = c^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pythagoras)</code></pre>


<h3>Format</h3>

<p>4 column data frame: <code>PID</code> = primary polygon ID,
<code>POS</code> = position of each vertex within a given polyline, <code>X</code>
= X-coordinate, and <code>Y</code> = Y-coordinate. Attributes:
<code>projection = 1</code>.
</p>


<h3>Note</h3>

<p>In R, the data must be loaded using the <code><a href="utils.html#topic+data">data</a></code> function.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2022-09-06</code>
</p>


<h3>Source</h3>

<p>An artificial construct to illustrate the proof of Pythagoras' Theorem
using trigonometry.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPolys">addPolys</a></code>,
<code><a href="#topic+plotPolys">plotPolys</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<a href="#topic+PolySet">PolySet</a>.
</p>

<hr>
<h2 id='refocusWorld'>Refocus the <code>worldLL</code>/<code>worldLLhigh</code> Data Sets</h2><span id='topic+refocusWorld'></span>

<h3>Description</h3>

<p>Refocus the <code>worldLL</code>/<code>worldLLhigh</code> data sets, e.g., refocus
them so that Eastern Canada appears to the west of Western Europe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refocusWorld (polys, xlim=NULL, ylim=NULL, clip.AN=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refocusWorld_+3A_polys">polys</code></td>
<td>
<p><code>PolySet</code> &ndash; object with one or more polygons; typically
<code>worldLL</code> or <code>worldLLhigh</code> (<em>required</em>).</p>
</td></tr>
<tr><td><code id="refocusWorld_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> &ndash; range of X-coordinates.</p>
</td></tr>
<tr><td><code id="refocusWorld_+3A_ylim">ylim</code></td>
<td>
<p><code>numeric</code> &ndash; range of Y-coordinates.</p>
</td></tr>
<tr><td><code id="refocusWorld_+3A_clip.an">clip.AN</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, clip expanded Antarctica to 
<code>'xlim'</code> of refocused polygons other than Antarctica and to user-defined/default <code>'ylim'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a <a href="#topic+PolySet">PolySet</a> containing one or more polygons
with X-coordinates that collectively span approximately 360 degrees.
The function effectively joins the <a href="#topic+PolySet">PolySet</a> into a cylinder and
then splits it at an arbitrary longitude according to the
user-specified limits.  Modifications in the resulting <a href="#topic+PolySet">PolySet</a>
are restricted to shifting X-coordinates by +/- multiples of 360
degrees, and instead of clipping polygons, the return value simply
omits out-of-range polygons.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a>, likely a subset of the input <a href="#topic+PolySet">PolySet</a>, which
retains the same <code>PID</code>/<code>SID</code> values.
</p>


<h3>Note</h3>

<p>The Antarctic polygon is treated as a special case in that it is expanded longitudinally
by duplicating it to the West and East of the base polygon. The expanded Antarctica is 
then clipped to the limits of the plot, or not if <code>'clip.NA=FALSE'</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
</p>
<p><a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Institute of Ocean Sciences (IOS), Sidney BC<br />
Last modified <code>Rd: 2018-10-26</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joinPolys">joinPolys</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- load appropriate data
  data(worldLL,envir=.PBSmapEnv)
  #--- set limits
  xlim &lt;- c(-100,25)
  ylim &lt;- c(0,90)
  #--- refocus and plot the world
  polys &lt;- refocusWorld(worldLL, xlim, ylim)
  plotMap(polys, xlim, ylim)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='RGB2RYB'>
Convert RGB to RYB and RYB to RGB
</h2><span id='topic+RGB2RYB'></span><span id='topic+RYB2RGB'></span>

<h3>Description</h3>

<p>Convert RGB (red-green-blue) colours to RYB (red-yellow-blue) colours, and vice versa.
Algorithm based on Sugita and Takahashi (2015, 2017)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGB2RYB(RGBmat)
RYB2RGB(RYBmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RGB2RYB_+3A_rgbmat">RGBmat</code></td>
<td>
<p><code>numeric</code> &ndash; matrix of red-green-blue primary colors by column, where rows are individual records of the three primary (RGB) colours. User can specify RGB in terms of 0-1 or 0-255; however, the algorith converts the latter to 0-1.</p>
</td></tr>
<tr><td><code id="RGB2RYB_+3A_rybmat">RYBmat</code></td>
<td>
<p><code>numeric</code> &ndash; matrix of red-yellow-blue primary colors by column, where rows are individual records of the three primary (RYB) colours. User can specify RYB in terms of 0-1 or 0-255; however, the algorith converts the latter to 0-1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RYB colour wheel is more commonly used by artists, and provides a more intuitive system when blending colours &ndash; red and yellow makes orange, yellow and blue makes green, blue and red makes purple. On the RYB colour wheel, red lies opposite green, but on the RGB colour wheel, red lies opposite cyan.
</p>


<h3>Value</h3>

<p>Matrix of RGB or RYB primary colour intensities, where rows are records and columns are primary colours.
</p>


<h3>Note</h3>

<p>Opposite colours calculated in RYB space (1-RYB) are not always what one expects.
For example the colour <code>"purple"</code>, RGB {160, 32, 240}, might better be specified
as RGB {126, 0, 255} before converting to RYB and inverting.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Regional Headquarters, Vancouver BC<br />
Last modified <code>Rd: 2022-07-06</code>
</p>


<h3>References</h3>

<p>Sugita, J. and Takahashi, T. (2017)
<a href="https://www.jstage.jst.go.jp/article/tievciieej/5/2/5_110/_article/-char/ja">Computational RYB Color Model and its Applications</a>.
IIEEJ Transactions on Image Electronics and Visual Computing 5(2): 110-122.
</p>
<p>Sugita, J. and Takahashi, T. (2015)
<a href="http://nishitalab.org/user/UEI/publication/Sugita_IWAIT2015.pdf">RYB Color Compositing</a>.
International Workshop on Applications in Information Technology, October 8-10, 2015.
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br />
<code><a href="#topic+addBubbles">addBubbles</a></code>
</p>
<p>In package <span class="pkg">grDevices</span>:<br />
<code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>,
<code><a href="grDevices.html#topic+rgb">rgb</a></code>,
<code><a href="grDevices.html#topic+rgb2hsv">rgb2hsv</a></code>
</p>

<hr>
<h2 id='rotatePolys'>
Rotate Polygons and Events
</h2><span id='topic+rotatePolys'></span><span id='topic+rotateEvents'></span>

<h3>Description</h3>

<p>Rotate a PolySet (or an EventData set) clockwise by a specified angle around a fixed point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotatePolys(polys, angle=40, centroid=c(500,5700),
   proj.out, zone, xlim=c(-135,-121.5), ylim=c(47,56),
   plot=FALSE, keep.extra=FALSE, ...)

rotateEvents(data, angle=40, centroid=c(500,5700),
   proj.out, zone, plot=FALSE, keep.extra=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotatePolys_+3A_polys">polys</code></td>
<td>
<p><code>PolySet</code> &ndash; data frame with fields <code>'PID'</code>, <code>'SID'</code>, <code>'POS'</code>, <code>'X'</code>, <code>'Y'</code>,
and attribute <code>'projection'</code> set to either <code>"LL"</code> or <code>"UTM"</code>.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_data">data</code></td>
<td>
<p><code>EventData</code> &ndash; data frame with fields <code>'EID'</code>, <code>'POS'</code>, <code>'X'</code>, <code>'Y'</code>,
and attribute <code>'projection'</code> set to either <code>"LL"</code> or <code>"UTM"</code>.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_angle">angle</code></td>
<td>
<p><code>numeric</code> &ndash; angle between 0 and 360 degrees for map rotation in a clockwise direction.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_centroid">centroid</code></td>
<td>
<p><code>numeric</code> &ndash; fixed UTM point, specified in km, around which the map will be rotated.
Rotation is performed in UTM space regardless of the input and output projections.
If user specifies <code>'NULL'</code> or <code>'NA'</code>, the centroid of the map will be used.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_proj.out">proj.out</code></td>
<td>
<p><code>character</code> &ndash; desired output projection, where choices are <code>'LL'</code> or <code>'UTM'</code>.
If <code>'proj.out'</code> is not specified, the output projection will be the same as the projection of the input object.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_zone">zone</code></td>
<td>
<p><code>numeric</code> &ndash; UTM zone used for rotation; if not supplied, the zone is set to 9.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> &ndash; two-element vector specifying the limits of X using units (degrees or km) that match the input projection.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_ylim">ylim</code></td>
<td>
<p><code>numeric</code> &ndash; two-element vector specifying the limits of Y using units (degrees or km) that match the input projection.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_plot">plot</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, plot the results of the rotation.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_keep.extra">keep.extra</code></td>
<td>
<p><code>logical</code> &ndash; if <code>TRUE</code>, keep the coordinates of initial and intermediate steps in the rotation process
in addition to the final rotated coordinates of the desired projection.</p>
</td></tr>
<tr><td><code id="rotatePolys_+3A_...">...</code></td>
<td>
<p><code>dots</code> &ndash; additional arguments for <code>'plotMap'</code> (in <code>'rotatePolys'</code>) or <code>'plotPoints'</code> (in <code>'rotateEvents'</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Map rotation returns coordinates that are no longer meaningful with respect to the original coordinate system.
When displaying rotated maps, the user might wish to turn off axis labels using <code>xaxt="n"</code> and <code>yaxt="n"</code>.
</p>


<h3>Value</h3>

<p>Rotated PolySet or EventData set where <code>'X'</code> and <code>'Y'</code> are the rotated coordinates in the projection specified by <code>'proj.out'</code>.
The returned object has an attribute list object named <code>'rotation'</code> that contains:
</p>

<ul>
<li> <p><code>angle</code> &ndash; angle of clockwise rotation in degrees
</p>
</li>
<li> <p><code>radian</code> &ndash; angle of rotation in radians: <code>pi * (-angle)/180</code>
</p>
</li>
<li> <p><code>centroid</code> &ndash; fixed point in UTM coordinates (km) around which map is rotated in UTM projection
</p>
</li>
<li> <p><code>R</code> &ndash; <a href="https://academo.org/demos/rotation-about-point/">rotation matrix</a> (2-dimensional)
</p>
</li>
<li> <p><code>xylim</code> &ndash; list object to keep track of <code>'xlim'</code>, <code>'ylim'</code> and a bounding box <code>'xybox'</code>.
</p>
</li>
<li> <p><code>projection</code> &ndash; projection of the rotated PolySet or EventData set
</p>
</li>
<li> <p><code>zone</code> &ndash; zone of the rotated PolySet or EventData set
</p>
</li></ul>

<p>When <code>keep.extra=TRUE</code>, the returned object will contain additional fields calculated by the rotational algorithm:
</p>

<ul>
<li> <p><code>(X0,Y0)</code> &ndash; original coordinates of the input PolySet | EventData set
</p>
</li>
<li> <p><code>(uX0,uY0)</code> &ndash; original coordinates converted to UTM (only if original projection is <code>'LL'</code>)
</p>
</li>
<li> <p><code>(aX,aY)</code> &ndash; UTM coordinates adjusted by subtracting the UTM centroid
</p>
</li>
<li> <p><code>(tX,tY)</code> &ndash; adjusted UTM coordinates transformed by multiplying the rotational matrix
</p>
</li>
<li> <p><code>(rX,rY)</code> &ndash; rotated UTM coordinates re-centered by adding the UTM centroid
</p>
</li></ul>

<p>Note:<br />
If <code>proj.out="UTM"</code>, the coordinates <code>c(rX, rY)</code> are used as the final rotated coordinates.
If <code>proj.out="LL"</code>, the coordinates <code>c(rX, rY)</code> are transformed back into projection <code>'LL'</code> as the final rotated coordinates.
</p>
<p>Additionally, <code>'xylim'</code> in the <code>'rotation'</code> list attribute contains intermediary bounding box objects.
For instance, if the input PolySet | EventData object has projection <code>'LL'</code>, the <code>'xylim'</code> object contains:
</p>

<ul>
<li> <p><code>LL</code> &ndash; original <code>(X,Y)</code> limits (<code>'xlim'</code>, <code>'ylim'</code>, <code>'xybox'</code>)
</p>
</li>
<li> <p><code>UTM</code> &ndash; original <code>(X,Y)</code> limits transformed to UTM coordinates
</p>
</li>
<li> <p><code>rot</code> &ndash; rotated UTM <code>(X,Y)</code> limits
</p>
</li>
<li> <p><code>out</code> &ndash; final projection <code>(X,Y)</code> limits
</p>
</li></ul>



<h3>Note</h3>

<p>The map rotation algorithm is not heavily tested at this time.
Report any issues to the package maintainer.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head &ndash; Offshore Rockfish<br />
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br />
<em>locus opus</em>: Institute of Ocean Sciences (IOS), Sidney BC<br />
Last modified <code>Rd: 2019-03-14</code>
</p>


<h3>References</h3>

<p><a href="https://academo.org/demos/rotation-about-point/">Academo &ndash; 2D Rotation about a point</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Rotation_matrix">Wikipedia &ndash; Rotation matrix</a>
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br />
<code>as.PolySet</code> in <a href="#topic+PolySet">PolySet</a>,
<code><a href="#topic+clipPolys">clipPolys</a></code>,
<code><a href="#topic+nepacLL">nepacLL</a></code>,
<code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>,
<code><a href="#topic+refocusWorld">refocusWorld</a></code>,
<code><a href="#topic+surveyData">surveyData</a></code>
</p>

<hr>
<h2 id='summary'>Summarize PBS Mapping Objects</h2><span id='topic+summary.EventData'></span><span id='topic+summary.LocationSet'></span><span id='topic+summary.PolyData'></span><span id='topic+summary.PolySet'></span>

<h3>Description</h3>

<p><code>summary</code> method for PBS Mapping classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EventData'
summary(object, ...)
## S3 method for class 'LocationSet'
summary(object, ...)
## S3 method for class 'PolyData'
summary(object, ...)
## S3 method for class 'PolySet'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p><code>object</code> &ndash; a PBSmapping object: EventData, LocationSet,
PolyData, or PolySet.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p><code>dots</code> &ndash; further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After creating a list of summary statistics, this function assigns the
class <code>'summary.PBS'</code> to the output in order to accomplish
formatted printing via <code>print.summary.PBS</code>.
</p>


<h3>Value</h3>

<p>A list of summary statistics.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2019-03-14</code>
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br />
<a href="#topic+EventData">EventData</a>,
<a href="#topic+LocationSet">LocationSet</a>,
<a href="#topic+PolyData">PolyData</a>,
<a href="#topic+PolySet">PolySet</a>,
<code><a href="#topic+PBSprint">PBSprint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(surveyData,envir=.PBSmapEnv)
  print(summary(surveyData))
})
</code></pre>

<hr>
<h2 id='surveyData'>Data: Tow Information from Pacific Ocean Perch Survey</h2><span id='topic+surveyData'></span>

<h3>Description</h3>

<p><a href="#topic+EventData">EventData</a> of Pacific ocean perch (POP) tow information (1966-89).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(surveyData)</code></pre>


<h3>Format</h3>

<p>Data frame consisting of 9 columns: <code>PID</code> = primary polygon ID,
<code>POS</code> = position of each vertex within a given polygon, <code>X</code>
= longitude coordinate, <code>Y</code> = latitude coordinate,  <code>trip</code>
= trip ID, <code>tow</code> = tow number in trip, <code>catch</code> = catch of
POP (kg), <code>effort</code> = tow effort (minutes), <code>depth</code> = fishing
depth (m), and <code>year</code> = year of survey trip. Attributes:
<code>projection = "LL"</code>, <code>zone = 9</code>.
</p>


<h3>Note</h3>

<p>In R, the data must be loaded using the <code><a href="utils.html#topic+data">data</a></code> function.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2008-09-03</code>
</p>


<h3>Source</h3>

<p>The GFBio database, maintained at the Pacific Biological Station
(Fisheries and Oceans Canada, Nanaimo, BC V9T 6N7), archives catches
and related biological data from commercial groundfish fishing trips
and research/assessment cruises off the west coast of British Columbia
(BC).
</p>
<p>The POP (<em>Sebastes alutus</em>) survey data were extracted from
GFBio. The data extraction covers bottom trawl surveys that focus
primarily on POP biomass estimation: 1966-89 for the central BC coast
and 1970-85 for the west coast of Vancouver Island. Additionally, a
1989 cruise along the entire BC coast concentrated on the collection
of biological samples. Schnute et al. (2001) provide a more
comprehensive history of POP surveys including the subset of data
presented here.
</p>


<h3>References</h3>

<p>Schnute, J.T., Haigh, R., Krishka, B.A. and Starr, P. (2001) Pacific
ocean perch assessment for the west coast of Canada in 2001. <em>Canadian
Science Advisory Secretariat, Research Document</em> <b>2001/138</b>, 90 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPoints">addPoints</a></code>,
<code><a href="#topic+combineEvents">combineEvents</a></code>,
<a href="#topic+EventData">EventData</a>,
<code><a href="#topic+findPolys">findPolys</a></code>,
<code><a href="#topic+makeGrid">makeGrid</a></code>,
<code><a href="#topic+plotPoints">plotPoints</a></code>.
</p>

<hr>
<h2 id='thickenPolys'>Thicken a PolySet of Polygons</h2><span id='topic+thickenPolys'></span>

<h3>Description</h3>

<p>Thicken a <a href="#topic+PolySet">PolySet</a>, where each unique (<code>PID</code>, <code>SID</code>)
describes a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thickenPolys (polys, tol = 1, filter = 3, keepOrig = TRUE,
              close = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thickenPolys_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to thicken.</p>
</td></tr>
<tr><td><code id="thickenPolys_+3A_tol">tol</code></td>
<td>
<p>tolerance (in kilometres when <code>proj</code> is
<code>"LL"</code> and <code>"UTM"</code>; otherwise, same units as
<code>polys</code>).</p>
</td></tr>
<tr><td><code id="thickenPolys_+3A_filter">filter</code></td>
<td>
<p>minimum number of vertices per result polygon.</p>
</td></tr>
<tr><td><code id="thickenPolys_+3A_keeporig">keepOrig</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, keep the original
points in the <a href="#topic+PolySet">PolySet</a>.</p>
</td></tr>
<tr><td><code id="thickenPolys_+3A_close">close</code></td>
<td>
<p>Boolean value; if <code>TRUE</code>, create intermediate vertices
between each polygon's last and first vertex, if necessary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function thickens each polygon within <code>polys</code> according to
the input arguments.
</p>
<p>If <code>keepOrig = TRUE</code>, all of the original vertices appear in the
result.  It calculates the distance between two sequential original
vertices, and if that distance exceeds <code>tol</code>, it adds a
sufficient number of vertices spaced evenly between the two original
vertices so that the distance between vertices no longer exceeds
<code>tol</code>.  If <code>close = TRUE</code>, it adds intermediate vertices
between the last and first vertices when necessary.
</p>
<p>If <code>keepOrig = FALSE</code>, only the first vertex of each polygon is
guaranteed to appear in the results.  From this first vertex, the
algorithm walks the polygon summing the distance between vertices.
When this cumulative distance exceeds <code>tol</code>, it adds a vertex on
the line segment under inspection.  After doing so, it resets the
distance sum, and walks the polygon from this new vertex.  If
<code>close = TRUE</code>, it will walk the line segment from the last
vertex to the first.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> containing the thickened data.  The function
recalculates the <code>POS</code> values for each polygon.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thinPolys">thinPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- plot Vancouver Island
  plotMap(nepacLL[nepacLL$PID == 33, ])
  #--- calculate a thickened version using a 30 kilometres tolerance,
  #--- without keeping the original points
  p &lt;- thickenPolys(nepacLL[nepacLL$PID == 33, ], tol = 30, keepOrig = FALSE)
  #--- convert the PolySet to EventData by dropping the PID column and
  #--- renaming POS to EID
  p &lt;- p[-1]; names(p)[1] &lt;- "EID"
  #--- convert the now invalid PolySet into a data frame, and then into
  #--- EventData
  p &lt;- as.EventData(as.data.frame(p), projection="LL")
  #--- plot the results
  addPoints(p, col=2, pch=19)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='thinPolys'>Thin a PolySet of Polygons</h2><span id='topic+thinPolys'></span>

<h3>Description</h3>

<p>Thin a <a href="#topic+PolySet">PolySet</a>, where each unique (<code>PID</code>, <code>SID</code>)
describes a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinPolys (polys, tol = 1, filter = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinPolys_+3A_polys">polys</code></td>
<td>
<p><a href="#topic+PolySet">PolySet</a> to thin.</p>
</td></tr>
<tr><td><code id="thinPolys_+3A_tol">tol</code></td>
<td>
<p>tolerance (in kilometres when <code>proj</code> is
<code>"LL"</code> and <code>"UTM"</code>; otherwise, same units as
<code>polys</code>).</p>
</td></tr>
<tr><td><code id="thinPolys_+3A_filter">filter</code></td>
<td>
<p>minimum number of vertices per result polygon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function executes the Douglas-Peuker line simplification
algorithm on each polygon within <code>polys</code>.
</p>


<h3>Value</h3>

<p><a href="#topic+PolySet">PolySet</a> containing the thinned data.  The function recalculates
the <code>POS</code> values for each polygon.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2013-04-10</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thickenPolys">thickenPolys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)
  #--- plot a thinned version of Vancouver Island (3 km tolerance)
  plotMap(thinPolys(nepacLL[nepacLL$PID == 33, ], tol = 3))
  #--- add the original Vancouver Island in a different line type to
  #--- emphasize the difference
  addPolys(nepacLL[nepacLL$PID == 33, ], border=2, lty=8, density=0)
  par(oldpar)
})
</code></pre>

<hr>
<h2 id='towData'>Data: Tow Information from Longspine Thornyhead Survey</h2><span id='topic+towData'></span>

<h3>Description</h3>

<p><a href="#topic+PolyData">PolyData</a> of tow information for a longspine thornyhead survey (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(towData)</code></pre>


<h3>Format</h3>

<p>Data frame consisting of 8 columns: <code>PID</code> = primary polygon ID,
<code>POS</code> = position of each vertex within a given polygon, <code>X</code>
= longitude coordinate, <code>Y</code> = latitude coordinate, <code>depth</code>
= fishing depth (m), <code>effort</code> = tow effort (minutes), <code>distance</code>
= tow track distance (km), <code>catch</code> = catch of longspine
thornyhead (kg), and <code>year</code> = year of survey. Attributes:
<code>projection = "LL"</code>, <code>zone = 9</code>.
</p>


<h3>Note</h3>

<p>In R, the data must be loaded using the <code><a href="utils.html#topic+data">data</a></code> function.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2008-09-03</code>
</p>


<h3>Source</h3>

<p>The GFBio database, maintained at the Pacific Biological Station
(Fisheries and Oceans Canada, Nanaimo, BC V9T 6N7), archives catches
and related biological data from commercial groundfish fishing trips
and research/assessment cruises off the west coast of British Columbia
(BC).  The longspine thornyhead (<em>Sebastolobus altivelis</em>) survey data
were extracted from GFBio. Information on the first 45 tows from the
2001 survey (Starr et al. 2002) are included here. Effort is time
(minutes) from winch lock-up to winch release.
</p>


<h3>References</h3>

<p>Starr, P.J., Krishka, B.A. and Choromanski, E.M. (2002) Trawl survey
for thornyhead biomass estimation off the west coast of Vancouver
Island, September 15 - October 2, 2001. <em>Canadian Technical Report of
Fisheries and Aquatic Sciences</em> <b>2421</b>, 60 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeProps">makeProps</a></code>,
<a href="#topic+PolyData">PolyData</a>,
<code><a href="#topic+towTracks">towTracks</a></code>.
</p>

<hr>
<h2 id='towTracks'>Data: Tow Track Polylines from Longspine Thornyhead Survey</h2><span id='topic+towTracks'></span>

<h3>Description</h3>

<p><a href="#topic+PolySet">PolySet</a> of geo-referenced polyline tow track data from a
longspine thornyhead survey (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(towTracks)</code></pre>


<h3>Format</h3>

<p>Data frame consisting of 4 columns: <code>PID</code> = primary polygon ID,
<code>POS</code> = position of each vertex within a given polyline, <code>X</code>
= longitude coordinate, and <code>Y</code> = latitude
coordinate. Attributes: <code>projection = "LL"</code>, <code>zone = 9</code>.
</p>


<h3>Note</h3>

<p>In R, the data must be loaded using the <code><a href="utils.html#topic+data">data</a></code> function.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br />
Jobber, Edmonton AB<br />
Last modified <code>Rd: 2008-09-03</code>
</p>


<h3>Source</h3>

<p>The longspine thornyhead (<em>Sebastolobus altivelis</em>) tow
track spatial coordinates are available at the Pacific Biological
Station (Fisheries and Oceans Canada, Nanaimo, BC V9T 6N7). The
geo-referenced coordinates of the first 45 tows from the 2001 survey (Starr
et al. 2002) are included here. Coordinates are recorded once per
minute between winch lock-up and winch release.
</p>


<h3>References</h3>

<p>Starr, P.J., Krishka, B.A. and Choromanski, E.M. (2002) Trawl survey
for thornyhead biomass estimation off the west coast of Vancouver
Island, September 15 - October 2, 2001. <em>Canadian Technical Report of
Fisheries and Aquatic Sciences</em> <b>2421</b>, 60 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addLines">addLines</a></code>,
<code><a href="#topic+calcLength">calcLength</a></code>,
<code><a href="#topic+clipLines">clipLines</a></code>,
<code><a href="#topic+plotLines">plotLines</a></code>,
<a href="#topic+PolySet">PolySet</a>,
<code><a href="#topic+towData">towData</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
