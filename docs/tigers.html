<!DOCTYPE html><html><head><title>Help for package tigers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tigers}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tigers-package'><p>Integration of Geography, Environment, and Remote Sensing</p></a></li>
<li><a href='#area'><p>Area of Polygon</p></a></li>
<li><a href='#barycoords'><p>Computes Barycentric Coordinates</p></a></li>
<li><a href='#chullPolygon'><p>Convex Hull of Polygon</p></a></li>
<li><a href='#convexPolygonOverlap'><p>Overlap of Two Convex Polygons</p></a></li>
<li><a href='#distance_to_line'><p>Distance to Line</p></a></li>
<li><a href='#geod'><p>Geodesic Distances</p></a></li>
<li><a href='#geoTrans'><p>Manipulate Geographical Coordinates</p></a></li>
<li><a href='#great_circle_line'><p>Great Circle Line</p></a></li>
<li><a href='#HausdorffDistance'><p>Hausdorff Distance</p></a></li>
<li><a href='#haveOverlap'><p>Compare Two Polygons</p></a></li>
<li><a href='#is.insidePolygon'><p>Test If a Point Is Inside a Polygon</p></a></li>
<li><a href='#polygon2mask'><p>Convert Polygon to a Raster Mask</p></a></li>
<li><a href='#polygonOverlap'><p>Decomposition and Overlap of Polygons</p></a></li>
<li><a href='#random_point_in_triangle'><p>Random Points in Triangle</p></a></li>
<li><a href='#redundantVertices'><p>Redundant Vertices in a Polygon</p></a></li>
<li><a href='#RMA'><p>Reduced Major Axis</p></a></li>
<li><a href='#triangulate'><p>Triangulate a Polygon</p></a></li>
<li><a href='#trilinear2Cartesian'><p>Trilinear Coordinates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-31</td>
</tr>
<tr>
<td>Title:</td>
<td>Integration of Geography, Environment, and Remote Sensing</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Handling and manipulation polygons, coordinates, and other geographical objects. The tools include: polygon areas, barycentric and trilinear coordinates (Hormann and Floater, 2006, &lt;<a href="https://doi.org/10.1145%2F1183287.1183295">doi:10.1145/1183287.1183295</a>&gt;), convex hull for polygons (Graham and Yao, 1983, &lt;<a href="https://doi.org/10.1016%2F0196-6774%2883%2990013-5">doi:10.1016/0196-6774(83)90013-5</a>&gt;), polygon triangulation (Toussaint, 1991, &lt;<a href="https://doi.org/10.1007%2FBF01905693">doi:10.1007/BF01905693</a>&gt;), great circle and geodesic distances, Hausdorff distance, and reduced major axis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/emmanuelparadis/tigers">https://github.com/emmanuelparadis/tigers</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/emmanuelparadis/tigers/issues">https://github.com/emmanuelparadis/tigers/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 13:03:01 UTC; paradis</td>
</tr>
<tr>
<td>Author:</td>
<td>Emmanuel Paradis <a href="https://orcid.org/0000-0003-3092-2199"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emmanuel Paradis &lt;Emmanuel.Paradis@ird.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tigers-package'>Integration of Geography, Environment, and Remote Sensing</h2><span id='topic+tigers-package'></span><span id='topic+tigers'></span>

<h3>Description</h3>

<p><span class="pkg">tigers</span> provides functions for manipulating polygons,
coordinates, ...
</p>
<p>All the tools programmed in <span class="pkg">tigers</span> are &ldquo;class-free&rdquo;: they work
on numeric vectors or matrices (even data frames) that store
coordinates. So the functions in the present package can easily be
interfaced with other packages such as <span class="pkg">terra</span>, <span class="pkg">sf</span>, or
<span class="pkg">sp</span>.
</p>
<p>The majority of the computations done by <span class="pkg">tigers</span> are performed by
efficient C code which could be interfaced with other languages (e.g.,
Python).
</p>
<p>The complete list of functions can be displayed with
<code>library(help = tigers)</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis
</p>
<p>Maintainer: Emmanuel Paradis &lt;Emmanuel.Paradis@ird.fr&gt;
</p>

<hr>
<h2 id='area'>Area of Polygon</h2><span id='topic+area'></span>

<h3>Description</h3>

<p>This function computes the area of a polygon with Euclidean coordinates
(e.g., UTM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_+3A_x">x</code>, <code id="area_+3A_y">y</code></td>
<td>
<p>the coordinates of the points given in the usual way in
<span class="rlang"><b>R</b></span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The unit of the area are the squared unit of input coordinates by
default.
</p>


<h3>Value</h3>

<p>a single numeric value giving the area of the polygon.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+geod">geod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>XY &lt;- rbind(c(0, 0),
            c(1, 0),
            c(.25, .25),
            c(.5, .5),
            c(1.2, .8),
            c(1, .78),
            c(0, 1))
area(XY)
</code></pre>

<hr>
<h2 id='barycoords'>Computes Barycentric Coordinates</h2><span id='topic+barycoords'></span>

<h3>Description</h3>

<p>The barycentric coordinates of a point inside a polygon are weighted
coordinates of the vertices of this polygon. The algorithm implemented
in this function works for any concave or convex polygon (Hormann and
Floater, 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barycoords(XY, point)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barycoords_+3A_xy">XY</code></td>
<td>
<p>A two-column matrix giving the coordinates of a polygon.</p>
</td></tr>
<tr><td><code id="barycoords_+3A_point">point</code></td>
<td>
<p>a vector with two values giving the coordinates of a point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the polygon is a triangle, the <code><a href="#topic+trilinear2Cartesian">trilinear2Cartesian</a></code>
can be used instead.
</p>
<p>The polygon must be open (see <code><a href="#topic+is.open">is.open</a></code>), and can be
either in clockwise or in counterclockwise order (see
<code><a href="#topic+is.clockwise">is.clockwise</a></code>).
</p>
<p>For the moment, the function is not vectorized with respect to
<code>point</code>, so it must be called for each point separately (see
examples). This is likely to change in the future.
</p>


<h3>Value</h3>

<p>a numeric vector giving the barycentric coordinates of the point
(second argument). The length of the returned vector is equal to the
number of vertices in the polygon (first argument).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Hormann, K. and Floater, M. S. (2006) Mean value coordinates for
arbitrary planar polygons. <em>ACM Transactions on Graphics</em>
<b>25</b>, 1424&ndash;1441. &lt;doi:10.1145/1183287.1183295&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trilinear2Cartesian">trilinear2Cartesian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a square:
xy &lt;- cbind(c(0, 1, 1, 0), c(0, 0, 1, 1))

## a small function to get the coordinates directly:
f &lt;- function(Pxy) barycoords(xy, Pxy)
## the CMYK scale:
F &lt;- col2rgb(c("cyan", "magenta", "yellow", "black"))

n &lt;- 1e5L
## random points in the square
Pxys &lt;- matrix(runif(2 * n), n, 2)
system.time(res &lt;- t(apply(Pxys, 1, f))) # &lt; 1 sec
colnames(res) &lt;- as.character(1:4)

## all rows should (approximately) sum to one:
all.equal(rowSums(res), rep(1, n), tol = 1e-15)

## transform the barycentric coordinates into colours:
COLS &lt;- t(F %*% t(res)) / 255
rgbCOLS &lt;- apply(COLS, 1, function(x) do.call(rgb, as.list(x)))
## add transparency:
rgbCOLS &lt;- paste0(rgbCOLS, "33")
## plot the results:
plot(0:1, 0:1, "n", asp = 1, ann = FALSE, axes = FALSE)
points(Pxys, pch = ".", col = rgbCOLS, cex = 20)
## the visual effect is nicer with n &lt;- 1e6L above and cex = 7
## in the last command


## the example below follows the same logic than the previous one

## an 8-vertex polygon:
xy &lt;- cbind(c(0, 0.5, 1, 3, 1, 0.5, 0, -2),
            c(0, -2, 0, 0.5, 1, 3, 1, 0.5))

## random points in the square and in the 4 triangles:
Pxys &lt;- rbind(matrix(runif(2 * n), n, 2),
              rpit(n, xy[1:3, ]),
	      rpit(n, xy[3:5, ]),
	      rpit(n, xy[5:7, ]),
	      rpit(n, xy[c(7:8, 1), ]))

system.time(res &lt;- t(apply(Pxys, 1, f))) # &lt; 5 sec

colnames(res) &lt;- as.character(1:8)
F &lt;- col2rgb(c("black", "red", "orange", "green",
               "yellow", "blue", "purple", "white"))
## F &lt;- col2rgb(rainbow(8)) # alternative
COLS &lt;- t(F %*% t(res)) / 255.001
rgbCOLS &lt;- apply(COLS, 1, function(x) do.call(rgb, as.list(x)))
rgbCOLS &lt;- paste0(rgbCOLS, "33") # add transparency
plot(xy, , "n", asp = 1, ann = FALSE, axes = FALSE)
points(Pxys, pch = ".", col = rgbCOLS, cex = 5)

</code></pre>

<hr>
<h2 id='chullPolygon'>Convex Hull of Polygon</h2><span id='topic+chullPolygon'></span>

<h3>Description</h3>

<p>Finds the convex hull of a polygon.
</p>
<p>Note that the function <code>chull</code> (see link below) finds the convex
hull of a set of points and is about twice slower than the present one
when applied to a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chullPolygon(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chullPolygon_+3A_x">x</code>, <code id="chullPolygon_+3A_y">y</code></td>
<td>
<p>the coordinates of the points given in the usual way in <span class="rlang"><b>R</b></span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal implementation requires the polygon to be open and in
clockwise order (a crash will happen otherwise). Clockwise order is
checked and possibly handled before calling the C code.
</p>


<h3>Value</h3>

<p>a vector of integers which give the indices of the vertices of the
input polygon defining the convex hull.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Graham, R. L. and Yao, F. F. (1983) Finding the convex hull of a
simple polygon. <em>Journal of Algorithms</em>, <b>4</b>, 324&ndash;331.
&lt;doi:10.1016/0196-6774(83)90013-5&gt;
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+chull">chull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY &lt;- rbind(c(0, 0),
            c(1, 0),
            c(.25, .25),
            c(.5, .5),
            c(1.2, .8),
            c(1, .78),
            c(0, 1))
(i &lt;- chullPolygon(XY))
plot(XY, type = "n", asp = 1)
polygon(XY, lwd = 5, border = "lightgrey")
text(XY, labels = 1:nrow(XY), cex = 2/1.5)
polygon(XY[i, ], border = "blue", lty = 2, lwd = 3)
</code></pre>

<hr>
<h2 id='convexPolygonOverlap'>Overlap of Two Convex Polygons</h2><span id='topic+convexPolygonOverlap'></span>

<h3>Description</h3>

<p>Find the intersection of two convex polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convexPolygonOverlap(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convexPolygonOverlap_+3A_a">A</code>, <code id="convexPolygonOverlap_+3A_b">B</code></td>
<td>
<p>two two-column matrices giving the coordinates of two
polygons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intersection of two overlapping convex polygons is a single convex
polygon.
</p>
<p>The two input polygons must be in clockwise order.
</p>


<h3>Value</h3>

<p>a two-column numeric matrix giving the coordinates of the overlap
between the two input polygons.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.clockwise">is.clockwise</a></code>, <code><a href="#topic+polygonOverlap">polygonOverlap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(3800), ncol = 2)
A &lt;- X[chull(X), ]
Y &lt;- matrix(rnorm(3800), ncol = 2)
B &lt;- Y[chull(Y), ]

plot(rbind(A, B), type = "n", asp = 1)
polygon(A)
COLS &lt;- c("blue", "red")
text(A, labels = 1:nrow(A), font = 2, cex = 1.5, col = COLS[1])
polygon(B)
text(B, labels = 1:nrow(B), font = 2, cex = 1.5, col = COLS[2])
legend("topleft", , c("A", "B"), text.font = 2, text.col = COLS)
O &lt;- convexPolygonOverlap(A, B)
polygon(O, border = NA, col = rgb(1, 1, 0, 0.5))
</code></pre>

<hr>
<h2 id='distance_to_line'>Distance to Line</h2><span id='topic+distance_to_line'></span><span id='topic+dtl'></span><span id='topic+distance_to_arc'></span><span id='topic+dta'></span>

<h3>Description</h3>

<p>These functions calculate the shortest distances from a set of points
to a line (in Euclidean coordinates) or an arc (in angular coordinates).
</p>
<p><code>dtl</code> and <code>dta</code> are aliases to <code>distance_to_line</code> and
<code>distance_to_arc</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_to_line(x, y = NULL, x0, y0, x1, y1,
                 alpha = NULL, beta = NULL)
dtl(x, y = NULL, x0, y0, x1, y1, alpha = NULL, beta = NULL)
distance_to_arc(x, y = NULL, x0, y0, x1, y1, prec = 0.001)
dta(x, y = NULL, x0, y0, x1, y1, prec = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_to_line_+3A_x">x</code>, <code id="distance_to_line_+3A_y">y</code></td>
<td>
<p>the coordinates of the points given in the usual way in <span class="rlang"><b>R</b></span>.</p>
</td></tr>
<tr><td><code id="distance_to_line_+3A_x0">x0</code>, <code id="distance_to_line_+3A_y0">y0</code>, <code id="distance_to_line_+3A_x1">x1</code>, <code id="distance_to_line_+3A_y1">y1</code></td>
<td>
<p>the coordinates of two points defining the line
similar to <code><a href="graphics.html#topic+segments">segments</a></code>. These are ignored if
<code>alpha</code> and <code>beta</code> are given.</p>
</td></tr>
<tr><td><code id="distance_to_line_+3A_alpha">alpha</code>, <code id="distance_to_line_+3A_beta">beta</code></td>
<td>
<p>alternatively to the previous arguments, the
parameters of the line (<code>beta</code> is the slope).</p>
</td></tr>
<tr><td><code id="distance_to_line_+3A_prec">prec</code></td>
<td>
<p>the precision of the estimated distances (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>distance_to_line</code> uses Euclidean geometry (see references). The
coordinates can be in any units.
</p>
<p><code>distance_to_arc</code> uses distances along arcs on the (Earth)
sphere. The coordinates must be in decimal degrees. The calculations
are done by iterations using intervals of decreasing lengths along the
arc. The iterations are stopped when the required precision is reached
(see argument <code>prec</code>).
</p>


<h3>Value</h3>

<p>a numeric vector giving the distances; <code>distance_to_line</code> returns
them in the same unit than the input data; <code>distance_to_arc</code>
returns them in kilometres (km).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line">https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+great_circle_line">great_circle_line</a></code>, <code><a href="#topic+geoTrans">geoTrans</a></code>,
<code><a href="#topic+geod">geod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## distance from the topleft corner of the unity square to the diagonal:
(d &lt;- dtl(matrix(c(1, 0), , 2), NULL, 0, 0, 1, 1))
all.equal(d, sqrt(2)/2)

## see also ?great_circle_line
x &lt;- y &lt;- 0:10/10
dta(x, y, 0, 0, 1, 1)
</code></pre>

<hr>
<h2 id='geod'>Geodesic Distances</h2><span id='topic+geod'></span>

<h3>Description</h3>

<p>This function calculates geodesic (or great-circle) distances
between pairs of points with their longitudes and latitudes given in
(decimal) degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geod(lon, lat = NULL, R = 6371)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geod_+3A_lon">lon</code></td>
<td>
<p>either a vector of numeric values with the longitudes in
degrees, or, if <code>lat = NULL</code>, a matrix giving the longitudes
(first column) and the latitudes (second column).</p>
</td></tr>
<tr><td><code id="geod_+3A_lat">lat</code></td>
<td>
<p>a vector with the latitudes.</p>
</td></tr>
<tr><td><code id="geod_+3A_r">R</code></td>
<td>
<p>the mean radius of the Earth (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value of <code>R</code> is the mean radius of the Earth which is
slightly smaller than the radius at the equator (6378.1 km).
</p>


<h3>Value</h3>

<p>a numeric symmetric matrix with the distances between pairs of points
in kilometres.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Great-circle_distance">https://en.wikipedia.org/wiki/Great-circle_distance</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Earth">https://en.wikipedia.org/wiki/Earth</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Haversine_formula">https://en.wikipedia.org/wiki/Haversine_formula</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoTrans">geoTrans</a></code>, <code><a href="stats.html#topic+as.dist">as.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## the distance between 0N 0E and 0N 180E...
geod(c(0, 180), c(0, 0)) # ~ 20015.09 km
## ... the same using the radius of the Earth at the equator:
geod(c(0, 180), c(0, 0), 6378.1) # ~ 20037.39 km
## The same comparison for two points 5 degrees apart:
geod(c(0, 5), c(0, 0)) # ~ 555.9746 km
geod(c(0, 5), c(0, 0), 6378.1) # ~ 556.5942 km
</code></pre>

<hr>
<h2 id='geoTrans'>Manipulate Geographical Coordinates</h2><span id='topic+geoTrans'></span><span id='topic+geoTrans2'></span>

<h3>Description</h3>

<p><code>geoTrans</code> transforms geographical coordinates in degrees,
minutes and seconds input as characters (or a factor) into numerical
values in degrees. <code>geoTrans2</code> does the reverse operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoTrans(x, degsym = NULL, minsym = "'", secsym = "\"")
geoTrans2(lon, lat = NULL, degsym = NULL, minsym = "'",
          secsym = "\"", dropzero = FALSE, digits = 3,
          latex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geoTrans_+3A_x">x</code></td>
<td>
<p>a vector of character strings storing geographical
coordinates; this can be a factor with the levels correctly set.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_degsym">degsym</code>, <code id="geoTrans_+3A_minsym">minsym</code>, <code id="geoTrans_+3A_secsym">secsym</code></td>
<td>
<p>a single character giving the symbol
used for degrees, minutes and seconds, respectively.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_lon">lon</code></td>
<td>
<p>either a vector of numeric values with the longitudes in
degrees, or, if <code>lat = NULL</code>, a matrix (or a data frame) giving
the longitudes in the first column and the latitudes in the second
column.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_lat">lat</code></td>
<td>
<p>a vector with the latitudes.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_dropzero">dropzero</code></td>
<td>
<p>a logical value: if <code>TRUE</code>, the number of
arc-seconds is dropped if it is zero; similarly for the number of
arc-minutes if the number of arc-seconds is also zero.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_digits">digits</code></td>
<td>
<p>an integer used for rounding the number of arc-seconds.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_latex">latex</code></td>
<td>
<p>a logical value: if <code>TRUE</code>, the returned character
is formatted with LaTeX code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geoTrans</code> should be robust to any pattern of spacing around the
values and the symbols (see examples). If the letter S, W, or O is
found is the coordinate, the returned value is negative. Note that
longitude and latitude should not be mixed in the same character
strings.
</p>
<p><code>geoTrans2</code> can be used with <code><a href="base.html#topic+cat">cat</a></code> (see
examples).
</p>
<p>The default for <code>degsym</code> (<code>NULL</code>) is because the degree
symbol (°) is coded differently in different character encodings.
By default, the function will use the appropriate character depending
on the system and encoding used.
</p>


<h3>Value</h3>

<p><code>geoTrans</code> returns a numeric vector with the coordinates in
degrees (eventually as decimal values). <code>geoTrans2</code> returns a
character vector.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+geod">geod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>coord &lt;- c("N 43°27'30\"", "N43°27'30\"", "43°27'30\"N",
           "43° 27' 30\" N", "43 ° 27 ' 30 \" N",
           "43°27'30\"", "43°27.5'")
cat(coord, sep = "\n")
geoTrans(coord)
geoTrans("43 D 27.5'", degsym = "D")
geoTrans("43° 27' 30\" S")

XL &lt;- c(100.6417, 102.9500)
YL &lt;- c(11.55833, 14.51667)
cat(geoTrans2(XL, YL, dropzero = TRUE), sep = "\n")
cat(geoTrans2(XL, YL, latex = TRUE), sep = "\\\n")
</code></pre>

<hr>
<h2 id='great_circle_line'>Great Circle Line</h2><span id='topic+great_circle_line'></span><span id='topic+gcl'></span>

<h3>Description</h3>

<p>This function calculates the coordinates of the line on the surface of
a sphere between two points. All coordinates are in decimal degrees.
</p>
<p><code>gcl</code> is simply an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>great_circle_line(x0, y0, x1, y1, linear = FALSE, npoints = 100)
gcl(x0, y0, x1, y1, linear = FALSE, npoints = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="great_circle_line_+3A_x0">x0</code>, <code id="great_circle_line_+3A_y0">y0</code>, <code id="great_circle_line_+3A_x1">x1</code>, <code id="great_circle_line_+3A_y1">y1</code></td>
<td>
<p>the coordinates of the two points similar to
<code><a href="graphics.html#topic+segments">segments</a></code>.</p>
</td></tr>
<tr><td><code id="great_circle_line_+3A_linear">linear</code></td>
<td>
<p>a logical value.</p>
</td></tr>
<tr><td><code id="great_circle_line_+3A_npoints">npoints</code></td>
<td>
<p>an integer giving the number of points where the
coordinates are calculated (should be at least two).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interval between <code>x0</code> and <code>x1</code> is split into regular
segments, then the latitudes are computed, by default, using a
great circle formula (Chamberlain and Duquette, 2007).
</p>
<p>If <code>linear = TRUE</code>, the coordinates are treated as linear (i.e.,
Euclidean).
</p>


<h3>Value</h3>

<p>a numeric matrix with two columns and colnames 'x' and 'y'.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Chamberlain, R. G. and Duquette, W. H. (2007) Some algorithms for
polygons on a sphere. JPL Open Repository. &lt;doi:2014/41271&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geod">geod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- 3; Y1 &lt;- 49 # Paris
X2 &lt;- 101; Y2 &lt;- 13 # Bangkok
## if (require(maps))  map() else
plot(c(-180, 180), c(-90, 90), "n")
text(X1, Y1, "Paris")
text(X2, Y2, "Bangkok")
lines(gcl(X1, Y1, X2, Y2), col = "blue", lwd = 2)
lines(gcl(X1, Y1, X2, Y2, linear = TRUE), col = "red", lwd = 2)

## assess the error implied by using linear interpolation for the
## diagonal of a 1 degree by 1 degree square near the equator:
xya &lt;- gcl(0, 0, 1, 1)
xyb &lt;- gcl(0, 0, 1, 1, TRUE)
## the error in degrees:
error &lt;- xya[, "y"] - xyb[, "y"]
plot(xya[, "x"], error * 3600, "o",
     xlab = "Longitude (degrees)", ylab = "Error (arc-seconds)")

## max (vertical) distance between these 2 curves:
geod(c(0.5, 0.5), c(0.5, 0.5 + max(error))) # ~6.5 m
## NOTE: the actual shortest (orthogonal) distance
## between these two curves is ~4.6 m
## (assuming the vertical distance helps to define a rectangular
## triangle, we have: 0.5 * sqrt(6.5^2 * 2)) ~ 4.6)

## NOTE2: dividing the coordinates by 10 results in dividing
## these deviations by 1000
</code></pre>

<hr>
<h2 id='HausdorffDistance'>Hausdorff Distance</h2><span id='topic+HausdorffDistance'></span>

<h3>Description</h3>

<p>Computes the Hausdorff distance between two polygons. The distances
can be directed (i.e., asymmetric) or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  HausdorffDistance(A, B, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HausdorffDistance_+3A_a">A</code>, <code id="HausdorffDistance_+3A_b">B</code></td>
<td>
<p>two two-column matrices giving the coordinates of two
polygons.</p>
</td></tr>
<tr><td><code id="HausdorffDistance_+3A_directed">directed</code></td>
<td>
<p>a logical value. By default, the undirected distance
is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>directed = TRUE</code>, the order of the two polygons is important.
</p>


<h3>Value</h3>

<p>a single numeric value.</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- cbind(c(0, 1, 1, 0), c(0, 0, 1, 1))
B &lt;- A
B[, 1] &lt;- B[, 1] + 2
B[c(1, 4), 1] &lt;- 1.15

plot(rbind(A, B), type = "n", asp = 1)
COLS &lt;- c("blue", "red")
polygon(A, border = COLS[1], lwd = 3)
polygon(B, border = COLS[2], lwd = 3)
text(mean(A[, 1]), mean(A[, 2]), "A", font = 2, col = COLS[1])
text(mean(B[, 1]), mean(B[, 2]), "B", font = 2, col = COLS[2])

(H &lt;- HausdorffDistance(A, B))
(HAB &lt;- HausdorffDistance(A, B, TRUE))
(HBA &lt;- HausdorffDistance(B, A, TRUE))
arrows(0, 0.75, 1.15, 0.75, length = 0.1, code = 3)
text(0.5, 0.85, paste("H(A-&gt;B)", "=", HAB))
arrows(1, 0.15, 3, 0.15, length = 0.1, code = 3)
text(2, 0.25, paste("H(B-&gt;A)", "=", HBA))
text(1.5, -0.5, paste("H = max(H(A-&gt;B), H(B-&gt;A))", "=", H))
</code></pre>

<hr>
<h2 id='haveOverlap'>Compare Two Polygons</h2><span id='topic+haveOverlap'></span><span id='topic+samePolygons'></span>

<h3>Description</h3>

<p>These functions compare two polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haveOverlap(A, B)
samePolygons(A, B, digits = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haveOverlap_+3A_a">A</code>, <code id="haveOverlap_+3A_b">B</code></td>
<td>
<p>Two two-column matrices giving the coordinates of two
polygons.</p>
</td></tr>
<tr><td><code id="haveOverlap_+3A_digits">digits</code></td>
<td>
<p>the number of digits considered when comparing the
coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single logical value</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+redundantVertices">redundantVertices</a></code></p>

<hr>
<h2 id='is.insidePolygon'>Test If a Point Is Inside a Polygon</h2><span id='topic+is.insidePolygon'></span>

<h3>Description</h3>

<p>This function tests if a point is inside a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.insidePolygon(XY, points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.insidePolygon_+3A_xy">XY</code></td>
<td>
<p>A two-column matrix giving the coordinates of a polygon.</p>
</td></tr>
<tr><td><code id="is.insidePolygon_+3A_points">points</code></td>
<td>
<p>a vector with two values giving the coordinates of a
point, or a matrix with two columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is based on &ldquo;ray-tracing&rdquo;: a segment is traced between
<code>points</code> and an arbitrary point far from the polygon. If this
segment intersects an odd number of edges of the polygon, then
<code>points</code> is inside the polygon.
</p>
<p>The polygon must be open and can be in either clockwise or
counterclockwise order. If the polygon is closed, it is modified
internally without warning (the original polygon is not modified).
</p>


<h3>Value</h3>

<p>a logical vector indicating whether each point is inside the polygon
defined by <code>XY</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.open">is.open</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>XY &lt;- rbind(c(0, 0), c(0, 1), c(1, 1), c(1, 0))
stopifnot(is.insidePolygon(XY, c(0.5, 0.5)))
stopifnot(!is.insidePolygon(XY, c(1.5, 1.5)))
</code></pre>

<hr>
<h2 id='polygon2mask'>Convert Polygon to a Raster Mask</h2><span id='topic+polygon2mask'></span><span id='topic+polygon2raster'></span>

<h3>Description</h3>

<p>Takes a polygon and returns a matrix with a mask that can be input
into a raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon2mask(XY, extent = NULL, k = 360,
             value = 1L, backgrd = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygon2mask_+3A_xy">XY</code></td>
<td>
<p>A two-column matrix giving the coordinates of a polygon.</p>
</td></tr>
<tr><td><code id="polygon2mask_+3A_extent">extent</code></td>
<td>
<p>a vector with four numeric values giving the extent of
the raster. By default, values are determined to minimally cover the
polygon.</p>
</td></tr>
<tr><td><code id="polygon2mask_+3A_k">k</code></td>
<td>
<p>an integer value giving the number of pixels per unit (i.e.,
the inverse of the resolution of the raster). The resolution is the
same in both directions.</p>
</td></tr>
<tr><td><code id="polygon2mask_+3A_value">value</code></td>
<td>
<p>the value given to the pixels inside the polygon
(converted to integer).</p>
</td></tr>
<tr><td><code id="polygon2mask_+3A_backgrd">backgrd</code></td>
<td>
<p>idem for the pixels outside the polygon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mask is returned as a matrix which is filled rowwise (in agreement
with the convention used in rasters) and can be input into functions
in <span class="pkg">terra</span> (e.g., <code>rast()</code>).
</p>
<p><code>polygon2mask</code> does basically the same operation than
<code>terra::rasterize()</code> but is faster and can produce a vector for
masking raster data.
</p>
<p>The output matrix is actually row-filled (unlike most matrices in R
which are column-filled). It should be transposed before passed to
<code>terra::rast()</code>, or its <code>dim</code> attribute can be ignored if
used as a mask to a rasted (which is also usually row-filled).
</p>


<h3>Value</h3>

<p>a matrix stored as integers; the dimensions of this matrix give the
size of the raster.
</p>


<h3>Note</h3>

<p>The code is still in development.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Nievergelt, J. and Preparata, F. P. (1982) Plane-sweep algorithms for
intersecting geometric figures. <em>Communications of the ACM</em>,
<b>25</b>, 739&ndash;747. &lt;doi:10.1145/358656.358681&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## from ?chullPolygon:
XY &lt;- rbind(c(0, 0),
            c(1, 0),
            c(.25, .25),
            c(.5, .5),
            c(1.2, .8),
            c(1, .78),
            c(0, 1))

layout(matrix(1:9, 3, 3, TRUE))
k &lt;- 2
for (i in 1:9) {
    msk &lt;- polygon2mask(XY, k = k)
    d &lt;- dim(msk)
    image(1:d[1], 1:d[2], msk)
    dm &lt;- paste(d, collapse = "x")
    title(paste("k =", k, ", dim =", dm))
    k &lt;- k * 2
}

layout(1)
</code></pre>

<hr>
<h2 id='polygonOverlap'>Decomposition and Overlap of Polygons</h2><span id='topic+polygonOverlap'></span><span id='topic+decomposePolygon'></span>

<h3>Description</h3>

<p><code>decomposePolygon</code> decomposes a polygon into convex subpolygons.
</p>
<p><code>polygonOverlap</code> finds the intersection of two polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposePolygon(x, y = NULL, method = 1, quiet = FALSE)
polygonOverlap(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygonOverlap_+3A_x">x</code>, <code id="polygonOverlap_+3A_y">y</code></td>
<td>
<p>the coordinates of the points given in the usual way in
<span class="rlang"><b>R</b></span>.</p>
</td></tr>
<tr><td><code id="polygonOverlap_+3A_method">method</code></td>
<td>
<p>the method used for triangulation (see
<code><a href="#topic+triangulate">triangulate</a></code>).</p>
</td></tr>
<tr><td><code id="polygonOverlap_+3A_quiet">quiet</code></td>
<td>
<p>if the polygon is convex, a warning message is issued
unless this option is switched to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="polygonOverlap_+3A_a">A</code>, <code id="polygonOverlap_+3A_b">B</code></td>
<td>
<p>two two-column matrices giving the coordinates of two
polygons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions require the polygons to be in counterclockwise order
(which is checked and arranged internally if needed).
</p>
<p>The method in <code>decomposePolygon</code> is from Hertel and Mehlhorn
(1983).
</p>
<p>The method in <code>polygonOverlap</code> is based on first decomposing the
two polygons into convex subpolygons, then computing their
intersections with <code><a href="#topic+convexPolygonOverlap">convexPolygonOverlap</a></code>. The results is
a list of polygons. A different algorithm is sketched in Chamberlain
and Duquette (2007).
</p>


<h3>Value</h3>

<p><code>decomposePolygon</code> returns a two-column matrix with integers
where each row gives the indices of two vertices of the input polygon
defining a diagonal; the set of these diagonals define convex
subpolygons.
</p>
<p><code>polygonOverlap</code> returns a list of polygons each defined by a
two-column numeric matrix giving the coordinates of the vertices.
</p>


<h3>Note</h3>

<p>These two functions are still in development.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Chamberlain, R. G. and Duquette, W. H. (2007) Some algorithms for
polygons on a sphere. JPL Open Repository. &lt;doi:2014/41271&gt;
</p>
<p>Hertel, S. and Mehlhorn, K. (1983) Fast triangulation of simple
polygons. In: <em>Foundations of Computation Theory.</em> Ed. Karpinski,
M. Springer, Berlin, pp. 207&ndash;218. &lt;doi:10.1007/3-540-12689-9_105&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convexPolygonOverlap">convexPolygonOverlap</a></code>, <code><a href="#topic+is.clockwise">is.clockwise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## same polygon than in ?triangulate
XY &lt;- rbind(c(0, 0), c(1, 0), c(.25, .25), c(.5, .5),
            c(1.2, .8), c(1, .78), c(0, 1))
decomposePolygon(XY) # similar to the output of triangulate()
## "lift up" one vertex:
XYb &lt;- XY
XYb[6, 2] &lt;- 1.2
decomposePolygon(XYb) # one diagonal less

## A is concave, B is convex:
A &lt;- rbind(c(0, 1.5), c(2, 1), c(0.5, 1.5), c(2, 2))
B &lt;- rbind(c(1, 0), c(3, 0), c(3, 3), c(1, 3))
AB &lt;- polygonOverlap(A, B)
plot(rbind(A, B), , "n", asp = 1)
polygon(A)
polygon(B)
lapply(AB, polygon, col = "gold")
</code></pre>

<hr>
<h2 id='random_point_in_triangle'>Random Points in Triangle</h2><span id='topic+random_point_in_triangle'></span><span id='topic+rpit'></span>

<h3>Description</h3>

<p>Generates random points inside a triangle using Osada et al.'s (2002,
Sect. 4.2) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  random_point_in_triangle(n, X, rfun1 = runif, rfun2 = runif)
  rpit(n, X, rfun1 = runif, rfun2 = runif)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_point_in_triangle_+3A_n">n</code></td>
<td>
<p>an integer giving the number of points to generate.</p>
</td></tr>
<tr><td><code id="random_point_in_triangle_+3A_x">X</code></td>
<td>
<p>a numeric matrix with 3 rows and 2 columns giving the
coordinates of the triangle.</p>
</td></tr>
<tr><td><code id="random_point_in_triangle_+3A_rfun1">rfun1</code></td>
<td>
<p>a function generating random values in [0,1]. By default,
the values are generated under a uniform distribution.</p>
</td></tr>
<tr><td><code id="random_point_in_triangle_+3A_rfun2">rfun2</code></td>
<td>
<p>same as the previous argument (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the points are uniformly distributed in the triangle.
The <code><a href="stats.html#topic+Beta">Beta</a></code> function offers an interesting
alternative to  generate points concentrated in a specific part of the
triangle (see examples).
</p>


<h3>Value</h3>

<p>A numeric matrix with <code>n</code> rows and two columns giving the
coordinates of the points.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Osada, R., Funkhouser, T., Chazelle, B., and Dobkin, D. (2002) Shape
distributions. <em>ACM Transactions on Graphics</em>, <b>21</b>,
807&ndash;832. &lt;doi:10.1145/571647.571648&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a random triangle in [0,1]^2:
P &lt;- matrix(runif(6), 3, 2)

## n points uniformly distributed in the triangle P:
n &lt;- 10000
x &lt;- rpit(n, P)

layout(matrix(1:2, 1))

plot(P, type = "n", asp = 1)
polygon(P, col = "yellow", border = NA)
points(x, pch = ".", col = "blue")

## using Beta distributions:
foo &lt;- function(n) rbeta(n, 1, 10)
bar &lt;- function(n) rbeta(n, 1, 1)
y &lt;- rpit(n, P, foo, bar)

plot(P, type = "n", asp = 1)
polygon(P, col = "yellow", border = NA)
points(y, pch = ".", col = "blue")

layout(1)
</code></pre>

<hr>
<h2 id='redundantVertices'>Redundant Vertices in a Polygon</h2><span id='topic+redundantVertices'></span><span id='topic+is.clockwise'></span><span id='topic+is.convex'></span><span id='topic+is.open'></span><span id='topic+revPolygon'></span>

<h3>Description</h3>

<p>Tests and optionally correct for redundant vertices in a polygon.
</p>
<p>The other functions test some features of a polygon.
</p>
<p><code>revPolygon</code> reverses the order of the vertices (i.e., swiching
between clockwise and counterclockwise orders).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redundantVertices(x, tol = 1e-8, check.only = FALSE)
is.clockwise(x)
is.convex(x)
is.open(x)
revPolygon(x, copy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redundantVertices_+3A_x">x</code></td>
<td>
<p>a two-column matrix.</p>
</td></tr>
<tr><td><code id="redundantVertices_+3A_tol">tol</code></td>
<td>
<p>the tolerance to consider two vertices identical.</p>
</td></tr>
<tr><td><code id="redundantVertices_+3A_check.only">check.only</code></td>
<td>
<p>a logical value.</p>
</td></tr>
<tr><td><code id="redundantVertices_+3A_copy">copy</code></td>
<td>
<p>by default, a new polygon is created; if <code>FALSE</code>, the
vertex order is reversed within the same object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>check.only</code> is <code>TRUE</code>, the first function prints the
diagnostics and nothing is returned. Otherwise, the possibly corrected
matrix is returned.
</p>


<h3>Value</h3>

<p><code>redundantVertices</code> returns a two-column numeric matrix, or
nothing if <code>check.only = TRUE</code> (the diagnostics are printed in
the console).
</p>
<p><code>is.clockwise</code>, <code>is.convex</code>, and <code>is.open</code> return a
single logical value.
</p>
<p><code>revPolygon</code> returns by default a two-column numeric matrix, or
nothing if <code>copy = FALSE</code> (the first argument is modified).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>The method for <code>is.clockwise</code> is from:
</p>
<p><a href="https://en.wikipedia.org/wiki/Curve_orientation">https://en.wikipedia.org/wiki/Curve_orientation</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haveOverlap">haveOverlap</a></code></p>

<hr>
<h2 id='RMA'>Reduced Major Axis</h2><span id='topic+RMA'></span>

<h3>Description</h3>

<p>Computes the coefficients of the reduced major axis (RMA) of a set of
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RMA(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMA_+3A_x">x</code>, <code id="RMA_+3A_y">y</code></td>
<td>
<p>the coordinates of the points given in the usual way in <span class="rlang"><b>R</b></span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RMA is found by solving a polynomial equation of degree two, so
there are actually two solutions which are both returned. It is
usually straightforward to find the appropriate solution.
</p>


<h3>Value</h3>

<p>a matrix with two rows and two columns named alpha and beta for the
intercepts and slopes, respectively.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p><a href="https://mathworld.wolfram.com/LeastSquaresFittingPerpendicularOffsets.html">https://mathworld.wolfram.com/LeastSquaresFittingPerpendicularOffsets.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:1000
y &lt;- x + rnorm(1000, 5)
RMA(x, y) # same than RMA(cbind(x, y))
</code></pre>

<hr>
<h2 id='triangulate'>Triangulate a Polygon</h2><span id='topic+triangulate'></span>

<h3>Description</h3>

<p>Performs the decomposition of a polygon into triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate(x, y = NULL, method = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangulate_+3A_x">x</code>, <code id="triangulate_+3A_y">y</code></td>
<td>
<p>the coordinates of the points given in the usual way in
<span class="rlang"><b>R</b></span>.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_method">method</code></td>
<td>
<p>an integer between 1 and 4 specifying the triangulation
method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following methods are available:
</p>

<ul>
<li><p> 1: the triangles are created in successive order from the
first appropriate angle (i.e., an ear) encountered in the polygon.
</p>
</li>
<li><p> 2: the triangles are created to favour thin triangles.
</p>
</li>
<li><p> 3: the triangles are created to favour fat triangles.
</p>
</li>
<li><p> 4: the triangles are created to favour regular-looking
triangles based on their determinant.
</p>
</li></ul>

<p>These methods have different requirements: method 1 needs the polygon
to be closed, whereas the other methods need it to be open; method 2
needs the polygon to be in counterclockwise order, and method 3 needs
it to be in clockwise order (the other methods are not sensitive to
this order). These requirements are checked before performing the
triangulation and the polygon is changed internally (without warning
since the original polygon is not modified) if necessary.
</p>


<h3>Value</h3>

<p>a three-column matrix giving the indices of the vertices in each
triangle (i.e., each row a is a triangle).
</p>


<h3>Note</h3>

<p>The internal codes need to be checked and tested again.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Toussaint, G. (1991) Efficient triangulation of simple
polygons. <em>Visual Computer</em>, <b>7</b>, 280&ndash;295.
&lt;doi:10.1007/BF01905693&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY &lt;- rbind(c(0, 0),
            c(1, 0),
            c(.25, .25),
            c(.5, .5),
            c(1.2, .8),
            c(1, .78),
            c(0, 1))
(tri &lt;- triangulate(XY))
plot(XY, type = "n", asp = 1)
for (i in 1:nrow(tri))
    polygon(XY[tri[i, ], ], border = "white", col = "green", lwd = 2)
polygon(XY, lwd = 4, border = "lightgrey")
text(XY, labels = 1:nrow(XY), cex = 1.2)
</code></pre>

<hr>
<h2 id='trilinear2Cartesian'>Trilinear Coordinates</h2><span id='topic+trilinear2Cartesian'></span><span id='topic+Cartesian2trilinear'></span>

<h3>Description</h3>

<p><code>trilinear2Cartesian</code> calculates the coordinates of a point
inside a triangle given three values interpreted as proportions.
</p>
<p><code>Cartesian2trilinear</code> does the reverse operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trilinear2Cartesian(p, X)
Cartesian2trilinear(xy, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trilinear2Cartesian_+3A_p">p</code></td>
<td>
<p>a vector with three numeric values (see details).</p>
</td></tr>
<tr><td><code id="trilinear2Cartesian_+3A_x">X</code></td>
<td>
<p>a numeric matrix with 3 rows and 2 columns giving the
coordinates of the triangle.</p>
</td></tr>
<tr><td><code id="trilinear2Cartesian_+3A_xy">xy</code></td>
<td>
<p>a vector with two numeric values (Cartesian coordinates).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values in <code>p</code> do not need to sum to one since they are scaled
internally.
</p>
<p>The triangle defined by <code>X</code> can be of any type. The coordinates
returned by <code>trilinear2Cartesian</code> is always inside the triangle.
</p>
<p><code>Cartesian2trilinear</code> does not check if <code>xy</code> is inside the
triangle.
</p>


<h3>Value</h3>

<p><code>trilinear2Cartesian</code> returns a numeric matrix with a single row
and two columns giving the coordinates of the point.
</p>
<p><code>Cartesian2trilinear</code> returns a numeric matrix with a single row
and three columns.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Trilinear_coordinates">https://en.wikipedia.org/wiki/Trilinear_coordinates</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## rectangular triangle (counterclockwise):
X &lt;- rbind(c(0, 0), c(0, 1), c(1, 0))
plot(X, , "n", asp = 1)
polygon(X)

h &lt;- sqrt(2) # hypothenuse length

points(trilinear2Cartesian(c(1, 1, 1), X)) # incenter
points(trilinear2Cartesian(c(1, h, h), X), pch = 2) # centroid
points(trilinear2Cartesian(c(h, 1, 1), X), pch = 3) # symmedian point
## the 3 midpoints:
points(trilinear2Cartesian(c(0, h, h), X), pch = 7)
points(trilinear2Cartesian(c(1, 0, h), X), pch = 7)
points(trilinear2Cartesian(c(1, h, 0), X), pch = 7)

legend("topright", ,
       c("incenter", "centroid", "symmedian point", "midpoints"),
       pch = c(1:3, 7))

f &lt;- c(0.1, 0.3, 0.6)
o &lt;- trilinear2Cartesian(f, X)
p &lt;- Cartesian2trilinear(o, X)
p - f # &lt; 1e-15
stopifnot(all.equal(as.vector(p), f))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
