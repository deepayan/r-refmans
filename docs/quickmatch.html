<!DOCTYPE html><html><head><title>Help for package quickmatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quickmatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#covariate_averages'><p>Covariate averages in matched sample</p></a></li>
<li><a href='#covariate_balance'><p>Covariate balance in matched sample</p></a></li>
<li><a href='#is.qm_matching'><p>Check qm_matching object</p></a></li>
<li><a href='#lm_match'><p>Regression-based matching estimator of treatment effects</p></a></li>
<li><a href='#matching_weights'><p>Unit weights implied by matching</p></a></li>
<li><a href='#qm_matching'><p>Constructor for qm_matching objects</p></a></li>
<li><a href='#quickmatch'><p>Derive generalized full matchings</p></a></li>
<li><a href='#quickmatch-package'><p>quickmatch: Quick Generalized Full Matching</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quick Generalized Full Matching</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-29</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Provides functions for constructing near-optimal generalized full matching.
    Generalized full matching is an extension of the original full matching method
    to situations with more intricate study designs. The package is made with
    large data sets in mind and derives matches more than an order of magnitude
    quicker than other methods.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), distances</td>
</tr>
<tr>
<td>Imports:</td>
<td>sandwich, scclust (&ge; 0.2.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fsavje/quickmatch">https://github.com/fsavje/quickmatch</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fsavje/quickmatch/issues">https://github.com/fsavje/quickmatch/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 20:02:29 UTC; fredriksavje</td>
</tr>
<tr>
<td>Author:</td>
<td>Fredrik Savje [aut, cre],
  Jasjeet Sekhon [aut],
  Michael Higgins [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fredrik Savje &lt;fredrik.savje@yale.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='covariate_averages'>Covariate averages in matched sample</h2><span id='topic+covariate_averages'></span>

<h3>Description</h3>

<p><code>covariate_averages</code> derives covariate averages for treatment groups in
matched samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariate_averages(treatments, covariates, matching = NULL, target = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariate_averages_+3A_treatments">treatments</code></td>
<td>
<p>factor specifying the units' treatment assignments.</p>
</td></tr>
<tr><td><code id="covariate_averages_+3A_covariates">covariates</code></td>
<td>
<p>vector, matrix or data frame with covariates to calculate averages for.</p>
</td></tr>
<tr><td><code id="covariate_averages_+3A_matching">matching</code></td>
<td>
<p><code><a href="#topic+qm_matching">qm_matching</a></code> or <code><a href="scclust.html#topic+scclust">scclust</a></code> object with
the matched groups. If <code>NULL</code>, averages are derived for the unmatched
sample.</p>
</td></tr>
<tr><td><code id="covariate_averages_+3A_target">target</code></td>
<td>
<p>units to target the averages for. If <code>NULL</code>, the averages will
be the raw average over all units in the sample (i.e., ATE). A non-null
value specifies a subset of units to derive averages for (e.g.,
ATT or ATC). If <code>target</code> is a logical vector with the same length as
the sample size, units indicated with <code>TRUE</code> will be targeted. If
<code>target</code> is an integer vector, the units with indices in <code>target</code>
are targeted. If <code>target</code> is a character vector, it should contain
treatment labels, and the corresponding units (as given by
<code>treatments</code>) will be targeted. If <code>matching</code> is <code>NULL</code>,
<code>target</code> is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>covariate_averages</code> calculates covariate averages by first deriving
the average for each covariate for each treatment conditions in each matched
group. It then aggregates the group averages by a weighted average, where the
<code>target</code> parameter decides the weights. If a matched group contains many
units not targeted (e.g., control units when ATT is of interest), those units
will contribute less to the covariate average for the corresponding treatment
condition than units in matched groups with many targeted units. This means that
the covariate average is calculated in the same way as the potential outcomes
are estimated. In fact, <code>covariate_averages</code> can be used as an estimator
for potential outcomes by calling it with the outcome variable as a covariate.
</p>
<p>When the average treatment effect (ATE) is of interest (i.e., <code>target == NULL</code>),
the matched groups will be weighted by their sizes. When <code>target</code> indicates
that some subset of units is of interest, the number of such units in each matched
group will decide its weight. For example, if we are interested in the average
treatment effect of the treated (ATT), the weight of a group will be proportional
to the number of treated units in that group.
</p>
<p>In practice, the function first derives the unit-level weights implied by the
matching. In detail, let <code class="reqn">S(g)</code> be the number of units indicated by
<code>target</code> in group <code class="reqn">g</code>. Let <code class="reqn">T</code> be the total number of units
indicated by <code>target</code> in the sample. Let <code class="reqn">A(t, g)</code> be the number of
units assigned to treatment <code class="reqn">t</code> in group <code class="reqn">g</code>. The weight for a unit
in group <code class="reqn">g</code> that is assigned to treatment <code class="reqn">t</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{S(g)}{T \times A(t, g)}.</code>
</p>

<p>See <code><a href="#topic+matching_weights">matching_weights</a></code> for more details.
</p>
<p><code>covariate_averages</code> focuses on means, but higher moments and interactions
can be investigated by adding corresponding columns to the covariate matrix
(see examples below).
</p>


<h3>Value</h3>

<p>Returns a matrix with the average of each covariate for each treatment
group. The rows in the matrix correspond to the covariates in order and
the columns correspond to the treatment groups. For example, a possible
output with three treatment groups (&quot;C&quot;, &quot;T1&quot; and &quot;T2&quot;) and four
covariates is:
</p>

<table>
<tr>
 <td style="text-align: right;">
     C </td><td style="text-align: right;"> T1 </td><td style="text-align: right;"> T2</td>
</tr>
<tr>
 <td style="text-align: right;">
     3.0 </td><td style="text-align: right;"> 3.3 </td><td style="text-align: right;"> 3.5</td>
</tr>
<tr>
 <td style="text-align: right;">
     -0.3 </td><td style="text-align: right;"> 0.0 </td><td style="text-align: right;"> -0.2</td>
</tr>
<tr>
 <td style="text-align: right;">
     0.1 </td><td style="text-align: right;"> 0.2 </td><td style="text-align: right;"> 0.0</td>
</tr>
<tr>
 <td style="text-align: right;">
     5.0 </td><td style="text-align: right;"> 5.1 </td><td style="text-align: right;"> 4.9</td>
</tr>
<tr>
 <td style="text-align: right;">
   </td>
</tr>

</table>

<p>which indicates that the average of the first covariate in the matched
sample is 3.0 for units assigned to condition &quot;C&quot;, and that the average
of the third covariate is 0.2 for units assigned to condition &quot;T1&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct example data
my_data &lt;- data.frame(y = rnorm(100),
                      x1 = runif(100),
                      x2 = runif(100),
                      treatment = factor(sample(rep(c("T1", "T2", "C"), c(25, 25, 50)))))

# Make distances
my_distances &lt;- distances(my_data, dist_variables = c("x1", "x2"))

# Treatment group averages in unmatched sample
covariate_averages(my_data$treatment, my_data[c("x1", "x2")])

# Make matching
my_matching &lt;- quickmatch(my_distances, my_data$treatment)

# Treatment group averages in matched sample
covariate_averages(my_data$treatment, my_data[c("x1", "x2")], my_matching)

# Averages in matched sample for ATT
covariate_averages(my_data$treatment,
                   my_data[c("x1", "x2")],
                   my_matching,
                   target = c("T1", "T2"))

# Second-order moments and interactions
mod_covs &lt;- data.frame(x1 = my_data$x1,
                       x2 = my_data$x2,
                       x1sq = my_data$x1^2,
                       x2sq = my_data$x2^2,
                       x1x2 = my_data$x1 * my_data$x2)
covariate_averages(my_data$treatment, mod_covs, my_matching)

</code></pre>

<hr>
<h2 id='covariate_balance'>Covariate balance in matched sample</h2><span id='topic+covariate_balance'></span>

<h3>Description</h3>

<p><code>covariate_balance</code> derives measures of covariate balance between
treatment groups in matched samples. The function calculates normalized mean
differences between all pairs of treatment conditions for each covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariate_balance(
  treatments,
  covariates,
  matching = NULL,
  target = NULL,
  normalize = TRUE,
  all_differences = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariate_balance_+3A_treatments">treatments</code></td>
<td>
<p>factor specifying the units' treatment assignments.</p>
</td></tr>
<tr><td><code id="covariate_balance_+3A_covariates">covariates</code></td>
<td>
<p>vector, matrix or data frame with covariates to derive balance for.</p>
</td></tr>
<tr><td><code id="covariate_balance_+3A_matching">matching</code></td>
<td>
<p><code><a href="#topic+qm_matching">qm_matching</a></code> or <code><a href="scclust.html#topic+scclust">scclust</a></code> object with
the matched groups. If <code>NULL</code>, balance is derived for the unmatched
sample.</p>
</td></tr>
<tr><td><code id="covariate_balance_+3A_target">target</code></td>
<td>
<p>units to target the balance measures for. If <code>NULL</code>, the measures will
be the raw average over all units in the sample (i.e., ATE). A non-null
value specifies a subset of units to derive balance measures for (e.g.,
ATT or ATC). If <code>target</code> is a logical vector with the same length as
the sample size, units indicated with <code>TRUE</code> will be targeted. If
<code>target</code> is an integer vector, the units with indices in <code>target</code>
are targeted. If <code>target</code> is a character vector, it should contain
treatment labels, and the corresponding units (as given by
<code>treatments</code>) will be targeted. If <code>matching</code> is <code>NULL</code>,
<code>target</code> is ignored.</p>
</td></tr>
<tr><td><code id="covariate_balance_+3A_normalize">normalize</code></td>
<td>
<p>logical scalar indicating whether differences should be normalized by the
sample standard deviation of the corresponding covariates.</p>
</td></tr>
<tr><td><code id="covariate_balance_+3A_all_differences">all_differences</code></td>
<td>
<p>logical scalar indicating whether full matrices of differences should be
reported. If <code>FALSE</code>, only the maximum difference for each covariate
is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>covariate_balance</code> calculates covariate balance by first deriving the
(normalized) mean difference between all treatment conditions for each
covariate in each matched group. It then aggregates the differences by a
weighted average, where the <code>target</code> parameter decides the weights.
When the average treatment effect (ATE) is of interest (i.e.,
<code>target == NULL</code>), the matched groups will be weighted by their sizes.
When <code>target</code> indicates that some subset of units is of interest, the
number of such units in each matched group will decide its weight. For
example, if we are interested in the average treatment effect of the treated
(ATT), the weight of a group will be proportional to the number of treated
units in that group. The reweighting of the groups captures that we are
prepared to accept greater imbalances in groups with few units of interest.
</p>
<p>By default, the differences are normalized by the sample standard deviation
of the corresponding covariate (see the <code>normalize</code> parameter). In more
detail, the sample variance of the covariate is derived separately for each
treatment group. The square root of the mean of these variances is then used
for the normalization. The matching is ignored when deriving the normalization
factor so that balance can be compared across different matchings or with
the unmatched sample.
</p>
<p><code>covariate_balance</code> focuses on mean differences, but higher moments and
interactions can be investigated by adding corresponding columns to the
covariate matrix (see examples below).
</p>


<h3>Value</h3>

<p>Returns the mean difference between treatment groups in the matched sample
for each covariate.
</p>
<p>When <code>all_differences = TRUE</code>, the function returns a matrix for each
covariate with the mean difference for each possible pair of treatment
conditions. Rows in the matrices indicate minuends in the differences and
columns indicate subtrahends. For example, when differences are normalized,
the matrix:
</p>

<table>
<tr>
 <td style="text-align: right;">
     </td><td style="text-align: right;"> a </td><td style="text-align: right;"> b </td><td style="text-align: right;"> c</td>
</tr>
<tr>
 <td style="text-align: right;">
     a </td><td style="text-align: right;"> 0.0 </td><td style="text-align: right;"> 0.3 </td><td style="text-align: right;"> 0.5</td>
</tr>
<tr>
 <td style="text-align: right;">
     b </td><td style="text-align: right;"> -0.3 </td><td style="text-align: right;"> 0.0 </td><td style="text-align: right;"> 0.2</td>
</tr>
<tr>
 <td style="text-align: right;">
     c </td><td style="text-align: right;"> -0.5 </td><td style="text-align: right;"> -0.2 </td><td style="text-align: right;"> 0.0</td>
</tr>
<tr>
 <td style="text-align: right;">
   </td>
</tr>

</table>

<p>reports that the mean difference for the corresponding covariate between
treatments &quot;a&quot; and &quot;b&quot; is 30% of a sample standard deviation of the covariate.
The maximum difference (in absolute value) is also reported in a separate vector.
For example, the maximum difference for the covariate in the example above is 0.5.
</p>
<p>When <code>all_differences = FALSE</code>, only the maximum differences are
reported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct example data
my_data &lt;- data.frame(y = rnorm(100),
                      x1 = runif(100),
                      x2 = runif(100),
                      treatment = factor(sample(rep(c("T1", "T2", "C"), c(25, 25, 50)))))

# Make distances
my_distances &lt;- distances(my_data, dist_variables = c("x1", "x2"))

# Balance in unmatched sample (maximum for each covariate)
covariate_balance(my_data$treatment, my_data[c("x1", "x2")])

# Make matching
my_matching &lt;- quickmatch(my_distances, my_data$treatment)

# Balance in matched sample (maximum for each covariate)
covariate_balance(my_data$treatment, my_data[c("x1", "x2")], my_matching)

# Balance in matched sample for ATT
covariate_balance(my_data$treatment,
                  my_data[c("x1", "x2")],
                  my_matching,
                  target = c("T1", "T2"))

# Balance on second-order moments and interactions
balance_cov &lt;- data.frame(x1 = my_data$x1,
                          x2 = my_data$x2,
                          x1sq = my_data$x1^2,
                          x2sq = my_data$x2^2,
                          x1x2 = my_data$x1 * my_data$x2)
covariate_balance(my_data$treatment, balance_cov, my_matching)

# Report all differences (not only maximum for each covariate)
covariate_balance(my_data$treatment,
                  my_data[c("x1", "x2")],
                  my_matching,
                  all_differences = TRUE)

</code></pre>

<hr>
<h2 id='is.qm_matching'>Check qm_matching object</h2><span id='topic+is.qm_matching'></span>

<h3>Description</h3>

<p><code>is.qm_matching</code> checks whether the provided object is a valid instance
of the <code><a href="#topic+qm_matching">qm_matching</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.qm_matching(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.qm_matching_+3A_x">x</code></td>
<td>
<p>object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.qm_matching</code> does not check whether the matching itself is sensible
or whether it satisfies some set of constraints. See
<code><a href="scclust.html#topic+check_clustering">check_clustering</a></code> for that functionality.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> is a valid <code><a href="#topic+qm_matching">qm_matching</a></code>
object, otherwise <code>FALSE</code>.
</p>

<hr>
<h2 id='lm_match'>Regression-based matching estimator of treatment effects</h2><span id='topic+lm_match'></span>

<h3>Description</h3>

<p><code>lm_match</code> estimates treatment effects in matched samples. The function
expects the user to provide the outcomes, treatment indicators, and a matching
object. It returns point estimates of the average treatment effects and variance
estimates. It is possible to estimate treatment effects for subsets of the
observations, such as estimates of the average treatment effect for the treated
(ATT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_match(outcomes, treatments, matching, covariates = NULL, target = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_match_+3A_outcomes">outcomes</code></td>
<td>
<p>numeric vector with observed outcomes.</p>
</td></tr>
<tr><td><code id="lm_match_+3A_treatments">treatments</code></td>
<td>
<p>factor specifying the units' treatment assignments.</p>
</td></tr>
<tr><td><code id="lm_match_+3A_matching">matching</code></td>
<td>
<p><code><a href="#topic+qm_matching">qm_matching</a></code> or <code><a href="scclust.html#topic+scclust">scclust</a></code> object with
the matched groups.</p>
</td></tr>
<tr><td><code id="lm_match_+3A_covariates">covariates</code></td>
<td>
<p>vector, matrix or data frame with covariates to include in the estimation.
If <code>NULL</code>, no covariates are included.</p>
</td></tr>
<tr><td><code id="lm_match_+3A_target">target</code></td>
<td>
<p>units to target the estimation for. If <code>NULL</code>, the effect is estimated
for all units in the sample (i.e., ATE). A non-null value specifies a
subset of units for which the effect should be estimated (e.g., ATT or
ATC). If <code>target</code> is a logical vector with the same length as the
sample size, units indicated with <code>TRUE</code> will be targeted. If
<code>target</code> is an integer vector, the units with indices in <code>target</code>
are targeted. If <code>target</code> is a character vector, it should contain
treatment labels, and the effect for the corresponding units (as given by
<code>treatments</code>) will be estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lm_match</code> estimates treatment effects using weighted regression. The
function first derives the unit-level weights implied by the matching. In
detail, let <code class="reqn">S(g)</code> be the number of units indicated by <code>target</code> in
group <code class="reqn">g</code>. Let <code class="reqn">T</code> be the total number of units indicated by
<code>target</code> in the sample. Let <code class="reqn">A(t, g)</code> be the number of units assigned
to treatment <code class="reqn">t</code> in group <code class="reqn">g</code>. The weight for a unit in group <code class="reqn">g</code>
that is assigned to treatment <code class="reqn">t</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{S(g)}{T \times A(t, g)}.</code>
</p>

<p>See <code><a href="#topic+matching_weights">matching_weights</a></code> for more details.
</p>
<p>The function uses the derived weights in a weighted least squares regression
(using the <code><a href="stats.html#topic+lm">lm</a></code> function) with indicator variables for the
treatment conditions. Optionally, covariates can be added to the regression
(e.g., a common recommendation is to include the covariates used to construct
the matching). Standard errors are estimated with the heteroskedasticity-robust
&quot;HC1&quot; estimator in the <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code> function. Units not
assigned to matched groups and units assigned weights of zero are excluded
from the estimation.
</p>


<h3>Value</h3>

<p>A list with two numeric matrices with all estimated treatment effects and
their estimated variances is returned. The first matrix (<code>effects</code>)
contains estimated treatment effects. Rows in this matrix indicate minuends
in the treatment effect contrast and columns indicate subtrahends. For
example, in the matrix:
</p>

<table>
<tr>
 <td style="text-align: right;">
     </td><td style="text-align: right;"> a </td><td style="text-align: right;"> b </td><td style="text-align: right;"> c</td>
</tr>
<tr>
 <td style="text-align: right;">
     a </td><td style="text-align: right;"> 0.0 </td><td style="text-align: right;"> 4.5 </td><td style="text-align: right;"> 5.5</td>
</tr>
<tr>
 <td style="text-align: right;">
     b </td><td style="text-align: right;"> -4.5 </td><td style="text-align: right;"> 0.0 </td><td style="text-align: right;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: right;">
     c </td><td style="text-align: right;"> -5.5 </td><td style="text-align: right;"> -1.0 </td><td style="text-align: right;"> 0.0</td>
</tr>
<tr>
 <td style="text-align: right;">
   </td>
</tr>

</table>

<p>the estimated treatment effect between conditions <code class="reqn">a</code> and <code class="reqn">b</code> is
<code class="reqn">4.5</code>, and the estimated treatment effect between conditions <code class="reqn">c</code>
and <code class="reqn">b</code> is <code class="reqn">-1.0</code>. In symbols, <code class="reqn">E[Y(a) - Y(b) | S] = 4.5</code> and
<code class="reqn">E[Y(c) - Y(b) | S] = -1.0</code> where <code class="reqn">S</code> is the condition set
indicated by the <code>target</code> parameter.
</p>
<p>The second matrix (<code>effect_variances</code>) contains estimates of
variances of the corresponding effect estimators.
</p>


<h3>References</h3>

<p>Stuart, Elizabeth A. (2010),
&lsquo;Matching Methods for Causal Inference: A Review and a Look Forward&rsquo;.
Statistical Science, 25(1), 1–21. https://doi.org/10.1214/09-STS313
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct example data
my_data &lt;- data.frame(y = rnorm(100),
                      x1 = runif(100),
                      x2 = runif(100),
                      treatment = factor(sample(rep(c("T1", "T2", "C"), c(25, 25, 50)))))

# Make distances
my_distances &lt;- distances(my_data, dist_variables = c("x1", "x2"))

# Make matching
my_matching &lt;- quickmatch(my_distances, my_data$treatment)

# ATE without covariates
lm_match(my_data$y,
         my_data$treatment,
         my_matching)

# ATE with covariates
lm_match(my_data$y,
         my_data$treatment,
         my_matching,
         my_data[c("x1", "x2")])

# ATT for T1
lm_match(my_data$y,
         my_data$treatment,
         my_matching,
         my_data[c("x1", "x2")],
         target = "T1")

</code></pre>

<hr>
<h2 id='matching_weights'>Unit weights implied by matching</h2><span id='topic+matching_weights'></span>

<h3>Description</h3>

<p><code>matching_weights</code> derives the weights implied by a matching for units
assigned to matched groups. If the matching is exact, reweighting the units
with this function will produce a sample where all treatment groups are
identical on the matching covariates. If the matching is approximate but of
good quality, the reweighted treatment groups will be close to identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matching_weights(treatments, matching, target = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matching_weights_+3A_treatments">treatments</code></td>
<td>
<p>factor specifying the units' treatment assignments.</p>
</td></tr>
<tr><td><code id="matching_weights_+3A_matching">matching</code></td>
<td>
<p><code><a href="#topic+qm_matching">qm_matching</a></code> or <code><a href="scclust.html#topic+scclust">scclust</a></code> object with
the matched groups.</p>
</td></tr>
<tr><td><code id="matching_weights_+3A_target">target</code></td>
<td>
<p>units to target the weights for. If <code>NULL</code>, the weights will target
all units, so that the reweighted treatment groups are as similar as
possible to the complete sample (i.e., corresponding to ATE). A non-null
value specifies a subset of units that the weights should be targeted for
(e.g., ATT or ATC). If <code>target</code> is a logical vector with the same
length as the sample size, units indicated with <code>TRUE</code> will be
targeted. If <code>target</code> is an integer vector, the units with indices
in <code>target</code> are targeted. If <code>target</code> is a character vector, it
should contain treatment labels, and the weights target the corresponding
units (as given by <code>treatments</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">S(g)</code> be the number of units indicated by <code>target</code> in group
<code class="reqn">g</code> (or the total number of units in the group if <code>target</code> is
<code>NULL</code>). Let <code class="reqn">T</code> be the total number of units indicated by
<code>target</code> in the sample (or the sample size if <code>target</code> is <code>NULL</code>).
Let <code class="reqn">A(t, g)</code> be the number of units assigned to treatment <code class="reqn">t</code> in
group <code class="reqn">g</code>. The weight for a unit in group <code class="reqn">g</code> that is assigned to
treatment <code class="reqn">t</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{S(g)}{T \times A(t, g)}.</code>
</p>

<p>Consider, for example, a matched group with one treated unit and two control
units when we are interested in the average effect of the treated (ATT) and
we have 50 treated units in total (<code class="reqn">T=50</code>). For all three units in the
group, we have <code class="reqn">S(g)=1</code>. For the treated unit we have <code class="reqn">A(t, g)=1</code>,
so its weight becomes <code class="reqn">1/50</code>. The two control units have <code class="reqn">A(t, g)=2</code>,
so their weights are both <code class="reqn">1/100</code>.
</p>
<p>These weights are such that the difference between the weighted averages of
the outcomes in two treatment conditions is the same as the average
within-group difference-in-means between the two conditions.
</p>
<p>If a matched group <code class="reqn">g</code> with <code class="reqn">S(g) &gt; 0</code> lacks some treatment condition
<code class="reqn">t</code>, no weights exist for the units assigned to <code class="reqn">t</code> (in other groups)
so to replicate group <code class="reqn">g</code>; the matching does not contain enough
information to impute the missing treatment in group <code class="reqn">g</code>. Subsequently,
all units assigned to <code class="reqn">t</code> will be given the weight <code>NA</code>. There is
two ways to solve this problem. First, one can change the target estimand by
setting <code class="reqn">S(g) = 0</code> for all groups that are missing units assigned to
<code class="reqn">t</code>. This is done with the <code>target</code> parameter. Second, one can change
the matching so that all groups contain at least one unit assigned to <code class="reqn">t</code>
(e.g., by merging groups).
</p>
<p>Units not assigned to matched groups are given zero weights.
</p>


<h3>Value</h3>

<p>Returns a numeric vector with the weights of the units in the matching.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct example data
my_data &lt;- data.frame(y = rnorm(100),
                      x1 = runif(100),
                      x2 = runif(100),
                      treatment = factor(sample(rep(c("T1", "T2", "C"), c(25, 25, 50)))))

# Make distances
my_distances &lt;- distances(my_data, dist_variables = c("x1", "x2"))

# Make matching
my_matching &lt;- quickmatch(my_distances, my_data$treatment)

# Weights for ATE
weights_ate &lt;- matching_weights(my_data$treatment, my_matching)

# Weights for ATT for T1
weights_att &lt;- matching_weights(my_data$treatment, my_matching, target = "T1")

# Estimate treatment effects with WLS estimator (see `lm_match`)
effects &lt;- lm(y ~ treatment + x1 + x2, data = my_data, weights = weights_att)

</code></pre>

<hr>
<h2 id='qm_matching'>Constructor for qm_matching objects</h2><span id='topic+qm_matching'></span>

<h3>Description</h3>

<p>The <code>qm_matching</code> function constructs a <code>qm_matching</code> object from
existing matched group labels. The function does not derive matchings from
sets of data points; see <code><a href="#topic+quickmatch">quickmatch</a></code> for that functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qm_matching(group_labels, unassigned_labels = NULL, ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qm_matching_+3A_group_labels">group_labels</code></td>
<td>
<p>a vector containing each unit's group label.</p>
</td></tr>
<tr><td><code id="qm_matching_+3A_unassigned_labels">unassigned_labels</code></td>
<td>
<p>labels that denote unassigned units. If <code>NULL</code>, <code>NA</code> values in
<code>group_labels</code> are used to denote unassigned points.</p>
</td></tr>
<tr><td><code id="qm_matching_+3A_ids">ids</code></td>
<td>
<p>IDs of the units. Should be a vector of the same length as
<code>group_labels</code> or <code>NULL</code>. If <code>NULL</code>, the IDs are set to
<code>1:length(group_labels)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qm_matching</code> objects are based on integer vectors, and it indexes
matched groups starting with zero. The <code>qm_matching</code> class inherits
from the <code><a href="scclust.html#topic+scclust">scclust</a></code> class.
</p>


<h3>Value</h3>

<p>Returns a <code>qm_matching</code> object with the matching described by the
provided labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 10 units in 3 matched groups
matches1 &lt;- qm_matching(c("A", "A", "B", "C", "B",
                          "C", "C", "A", "B", "B"))

# 8 units in 3 matched groups, 2 units unassigned
matches2 &lt;- qm_matching(c(1, 1, 2, 3, 2,
                          NA, 3, 1, NA, 2))

# Custom labels indicating unassiged units
matches3 &lt;- qm_matching(c("A", "A", "B", "C", "NONE",
                          "C", "C", "NONE", "B", "B"),
                        unassigned_labels = "NONE")

# Two different labels indicating unassiged units
matches4 &lt;- qm_matching(c("A", "A", "B", "C", "NONE",
                          "C", "C", "0", "B", "B"),
                        unassigned_labels = c("NONE", "0"))

# Custom unit IDs
matches5 &lt;- qm_matching(c("A", "A", "B", "C", "B",
                          "C", "C", "A", "B", "B"),
                        ids = letters[1:10])

</code></pre>

<hr>
<h2 id='quickmatch'>Derive generalized full matchings</h2><span id='topic+quickmatch'></span>

<h3>Description</h3>

<p><code>quickmatch</code> constructs near-optimal generalized full matchings. The
function expects the user to provide distances measuring the similarity of
units and a set of matching constraints. It then constructs a matching
so that units assigned to the same group are as similar as possible while
satisfying the matching constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickmatch(
  distances,
  treatments,
  treatment_constraints = NULL,
  size_constraint = NULL,
  target = NULL,
  caliper = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickmatch_+3A_distances">distances</code></td>
<td>
<p><code><a href="distances.html#topic+distances">distances</a></code> object or a numeric vector, matrix
or data frame. The parameter describes the similarity of the units to be
matched. It can either be preprocessed distance information using a
<code><a href="distances.html#topic+distances">distances</a></code> object, or raw covariate data. When
called with covariate data, Euclidean distances are calculated unless
otherwise specified.</p>
</td></tr>
<tr><td><code id="quickmatch_+3A_treatments">treatments</code></td>
<td>
<p>factor specifying the units' treatment assignments.</p>
</td></tr>
<tr><td><code id="quickmatch_+3A_treatment_constraints">treatment_constraints</code></td>
<td>
<p>named integer vector with the treatment constraints. If <code>NULL</code>, the
function ensures that each matched group contains one unit from each
treatment condition.</p>
</td></tr>
<tr><td><code id="quickmatch_+3A_size_constraint">size_constraint</code></td>
<td>
<p>integer with the required total number of units in each group. Must be
greater or equal to the sum of <code>treatment_constraints</code>. If NULL, no
constraints other than the treatment constraints are imposed.</p>
</td></tr>
<tr><td><code id="quickmatch_+3A_target">target</code></td>
<td>
<p>units to target the matching for. All units indicated by <code>target</code> are
ensured to be assigned to a matched group (disregarding eventual
<code>caliper</code> setting). Units not indicated by <code>target</code> could be
left unassigned if they are not necessary to satisfy the matching
constraints. If <code>NULL</code>, <code>quickmatch</code> targets the complete sample
and ensures that all units are assigned to a group. If <code>target</code> is a
logical vector with the same length as the sample size, units indicated
with <code>TRUE</code> will be targeted. If <code>target</code> is an integer vector,
the units with indices in <code>target</code> are targeted. Indices starts at 1
and <code>target</code> must be sorted. If <code>target</code> is a character vector,
it should contain treatment labels, and the corresponding units (as given
by <code>treatments</code>) will be targeted.</p>
</td></tr>
<tr><td><code id="quickmatch_+3A_caliper">caliper</code></td>
<td>
<p>restrict the maximum within-group distance.</p>
</td></tr>
<tr><td><code id="quickmatch_+3A_...">...</code></td>
<td>
<p>additional parameters to be sent either to the <code><a href="distances.html#topic+distances">distances</a></code>
function when the <code>distances</code> parameter contains covariate data, or
to the underlying <code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>treatment_constraints</code> parameter should be a named vector with
treatment-specific constraints. For example, in a sample with treatment
conditions &quot;A&quot;, &quot;B&quot; and &quot;C&quot;, the vector <code>c("A" = 1, "B" = 2, "C" = 0)</code>
specifies that each matched group should contain at least one unit with
treatment &quot;A&quot;, at least two units with treatment &quot;B&quot; and any number of units
with treatment &quot;C&quot;. Treatments not specified in the vector defaults to zero.
For example, the vector <code>c("A" = 1, "B" = 2)</code> is identical to the
previous one. When <code>treatment_constraints</code> is <code>NULL</code>, the function
requires at least one unit for each treatment in each group. In our current
example, <code>NULL</code> would be shorthand for <code>c("A" = 1, "B" = 1, "C" = 1)</code>.
</p>
<p>The <code>size_constraint</code> parameter can be used to constrain the matched
groups to contain at least a certain number of units in total (independently
of treatment assignment). For example, if <code>treatment_constraints =
c("A" = 1, "B" = 2)</code> and <code>total_size_constraint = 4</code>, each matched
group will contain at least one unit assigned to &quot;A&quot;, at least two units
assigned to &quot;B&quot; and at least four units in total, where the fourth unit can
be from any treatment condition.
</p>
<p>The <code>target</code> parameter can be used to control which units are included
in the matching. When <code>target</code> is <code>NULL</code> (the default), all units
will be assigned to a matched group. When not <code>NULL</code>, the parameter
indicates that some units must be assigned to matched group and that the
remaining units can safely be ignored. This can be useful, for example,
when one is interested in estimating treatment effects only for a certain
type of units (e.g., the average treatment effect for the treated, ATT). It
is particularly useful when units of interested are not represented in the
whole covariate space (i.e., an one-sided overlap problem). Without the
<code>target</code> parameter, the function would in such cases try to assign every
unit to a group, including units in sparse regions that we are not interested
in. This could lead to unnecessarily large and diverse matched groups. By
specifying that some units are of interest only insofar as they help us satisfy
the matching constraints (i.e., setting the <code>target</code> parameter to the
appropriate value), we can avoid such situations.
</p>
<p>Consider, as an example, a study with two treatment conditions, &quot;A&quot; and &quot;B&quot;.
Units assigned to &quot;B&quot; are more numerous and tend to have more extreme
covariate values. We are, however, only interested in estimating the
treatment effect for units assigned to &quot;A&quot;. By specifying <code>target = "A"</code>,
the function ensures that all &quot;A&quot; units are assigned to matched groups. Some
units assigned to treatment &quot;B&quot; &ndash; in particular the units with extreme
covariate values &ndash; will be left unassigned. However, as those units are not
of interest, they can safely be ignored, and we avoid groups of poor quality.
</p>
<p>Even if some of the units that can be ignored are not needed to satisfy the
matching constraints, it is rarely beneficial to discard them blindly; they can
occasionally provide useful information. The default behavior when <code>target</code>
is non-NULL is to assign as many of the ignorable units as possible given that
the within-group distances do not increase too much
(using <code>secondary_unassigned_method = "estimated_radius"</code>). This behavior
might, however, reduce covariate balance in some instances. If called with
<code>secondary_unassigned_method = "ignore"</code>, units not specified in
<code>target</code> will be discarded unless they are absolutely needed to satisfying
the matching constraints. This tends to reduce bias since the within-group
distances are minimized, but it could increase variance since we ignore
potentially useful information in the sample. An intermediate alternative
is to specify an aggressive caliper for the ignorable units, which is done
with the <code>secondary_radius</code> parameter. (These parameters are part of the
<code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> function that <code>quickmatch</code> calls.
The <code>target</code> parameter corresponds to the <code>primary_data_points</code>
parameter in that function.)
</p>
<p>The <code>caliper</code> parameter constrains the maximum distance between units
assigned to the same matched group. This is implemented by restricting the
edge weight in the graph used to construct the matched groups (see
<code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> for details). As a result, the caliper
will affect all groups in the matching and, in general, make it harder for
the function to find good matches even for groups where the caliper is not
binding. In particular, a too tight <code>caliper</code> can lead to discarded
units that otherwise would be assigned to a group satisfying both the
matching constraints and the caliper. For this reason, it is recommended
to set the <code>caliper</code> value quite high and only use it to avoid particularly
poor matches. It strongly recommended to use the <code>caliper</code> parameter only
when <code>primary_unassigned_method = "closest_seed"</code> in the underlying
<code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> function (which is the default
behavior).
</p>
<p><code>quickmatch</code> calls <code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> with
<code>seed_method = "inwards_updating"</code>. The <code>seed_method</code> parameter
governs how the seeds are selected in the nearest neighborhood graph that
is used to construct the matched groups (see <code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code>
for details). The <code>"inwards_updating"</code> option generally works well
and is safe with most datasets. Using <code>seed_method = "exclusion_updating"</code>
often leads to better performance (in the sense of matched groups with more
similar units), but it may increase run time. Discrete data (or more generally
when units tend to be at equal distance to many other units) will lead to
particularly poor run time with this option. If the data set has at least one
continuous covariate, <code>"exclusion_updating"</code> is typically reasonably
quick. A third option is <code>seed_method = "lexical"</code>, which decreases the
run time relative to <code>"inwards_updating"</code> (sometimes considerably) at
the cost of performance. <code>quickmatch</code> passes parameters on to
<code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code>, so to change <code>seed_method</code>, call
<code>quickmatch</code> with the parameter specified as usual:
<code>quickmatch(..., seed_method = "exclusion_updating")</code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+qm_matching">qm_matching</a></code> object with the matched groups.
</p>


<h3>References</h3>

<p>Sävje, Fredrik, Michael J. Higgins and Jasjeet S. Sekhon (2017),
&lsquo;Generalized Full Matching&rsquo;, arXiv 1703.03882.
<a href="https://arxiv.org/abs/1703.03882">https://arxiv.org/abs/1703.03882</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> for the underlying function used
to construct the matched groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct example data
my_data &lt;- data.frame(y = rnorm(100),
                      x1 = runif(100),
                      x2 = runif(100),
                      treatment = factor(sample(rep(c("T1", "T2", "C"), c(25, 25, 50)))))

# Make distances
my_distances &lt;- distances(my_data, dist_variables = c("x1", "x2"))

# Make matching with one unit from "T1", "T2" and "C" in each matched group
quickmatch(my_distances, my_data$treatment)

# Require at least two "C" in each group
quickmatch(my_distances,
           my_data$treatment,
           treatment_constraints = c("T1" = 1, "T2" = 1, "C" = 2))

# Require groups with at least six units in total
quickmatch(my_distances,
           my_data$treatment,
           treatment_constraints = c("T1" = 1, "T2" = 1, "C" = 2),
           size_constraint = 6)

# Focus the matching to units assigned to "T1" and "T2" (i.e., all
# units assigned to "T1" or T2 will be assigned to a matched group).
# Units assigned to treatment "C" will be assigned to groups so to
# ensure that each group contains at least one unit of each treatment
# condition. Remaining "C" units could be left unassigned.
quickmatch(my_distances,
           my_data$treatment,
           target = c("T1", "T2"))

# Impose caliper
quickmatch(my_distances,
           my_data$treatment,
           caliper = 0.25)

# Call `quickmatch` directly with covariate data (ie., not pre-calculating distances)
quickmatch(my_data[c("x1", "x2")], my_data$treatment)

# Call `quickmatch` directly with covariate data using Mahalanobis distances
quickmatch(my_data[c("x1", "x2")],
           my_data$treatment,
           normalize = "mahalanobize")

</code></pre>

<hr>
<h2 id='quickmatch-package'>quickmatch: Quick Generalized Full Matching</h2><span id='topic+quickmatch-package'></span>

<h3>Description</h3>

<p>Provides functions for constructing near-optimal generalized full matchings.
Generalized full matching is an extension of the original full matching method
to situations with more intricate study designs. The package is made with
large data sets in mind and derives matchings more than an order of magnitude
quicker than other methods.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+quickmatch">quickmatch</a></code> for the main matching function.
</p>
<p>See the package's website for more information:
<a href="https://github.com/fsavje/quickmatch">https://github.com/fsavje/quickmatch</a>.
</p>
<p>Bug reports and suggestions are greatly appreciated. They are best reported
here: <a href="https://github.com/fsavje/quickmatch/issues">https://github.com/fsavje/quickmatch/issues</a>.
</p>


<h3>References</h3>

<p>Sävje, Fredrik and Michael J. Higgins and Jasjeet S. Sekhon (2017),
&lsquo;Generalized Full Matching&rsquo;, arXiv 1703.03882.
<a href="https://arxiv.org/abs/1703.03882">https://arxiv.org/abs/1703.03882</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
