<!DOCTYPE html><html><head><title>Help for package extremeStat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {extremeStat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#extremeStat-package'><p>extremeStat: Extreme Value Statistics and Quantile Estimation</p></a></li>
<li><a href='#annMax'><p>annual discharge maxima (streamflow)</p></a></li>
<li><a href='#distLexBoot'><p>Bootstrapping uncertainty intervals for return periods</p></a></li>
<li><a href='#distLextreme'><p>Extreme value stats</p></a></li>
<li><a href='#distLfit'><p>Fit distributions via L-moments</p></a></li>
<li><a href='#distLquantile'><p>distribution quantiles</p></a></li>
<li><a href='#distLweights'><p>Compute distribution weights from GOF</p></a></li>
<li><a href='#extremeStat'><p>Extreme value statistics on a linear scale</p></a></li>
<li><a href='#plotLexBoot'><p>Bootstrapping uncertainty intervals for return periods</p></a></li>
<li><a href='#plotLextreme'><p>Plot extreme value statistics</p></a></li>
<li><a href='#plotLfit'><p>Plot distributions fitted with L-moments</p></a></li>
<li><a href='#plotLquantile'><p>Plot quantiles of distributions fitted with L-moments</p></a></li>
<li><a href='#plotLweights'><p>Distribution rank comparison</p></a></li>
<li><a href='#printL'><p>print dlf objects</p></a></li>
<li><a href='#q_gpd'><p>GPD quantile of sample</p></a></li>
<li><a href='#q_weighted'><p>Compute weighted averages of quantile estimates</p></a></li>
<li><a href='#quantGPD'><p>Fast GPD quantile estimate</p></a></li>
<li><a href='#weightp'><p>distribution weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extreme Value Statistics and Quantile Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-12</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lmomco (&ge; 2.2.5), berryFunctions (&ge; 1.15.6), pbapply,
RColorBrewer, grDevices, graphics, methods, stats, utils, evir,
ismev, fExtremes, extRemes, evd, Renext</td>
</tr>
<tr>
<td>Author:</td>
<td>Berry Boessenkool</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Berry Boessenkool &lt;berry-b@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit, plot and compare several (extreme value) distribution functions. 
    Compute (truncated) distribution quantile estimates and plot return periods on a linear scale.
   	On the fitting method, see Asquith (2011): Distributional Analysis with L-moment Statistics [...]  ISBN 1463508417.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/brry/extremeStat">https://github.com/brry/extremeStat</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/brry/extremeStat">https://github.com/brry/extremeStat</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-12 13:17:59 UTC; berry</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 13:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='extremeStat-package'>extremeStat: Extreme Value Statistics and Quantile Estimation</h2><span id='topic+extremeStat-package'></span>

<h3>Description</h3>

<p>Fit, plot and compare several (extreme value) distribution functions. Compute (truncated) distribution quantile estimates and plot return periods on a linear scale. On the fitting method, see Asquith (2011): Distributional Analysis with L-moment Statistics [...] ISBN 1463508417.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/brry/extremeStat">https://github.com/brry/extremeStat</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/brry/extremeStat">https://github.com/brry/extremeStat</a>
</p>
</li></ul>


<hr>
<h2 id='annMax'>annual discharge maxima (streamflow)</h2><span id='topic+annMax'></span>

<h3>Description</h3>

<p>Annual discharge maxima of a stream in Austria called Griesler or Fuschler
Ache, at the measurement station (gauge) near St. Lorenz, catchment area ca
100 km^2. Extracted from the time series 1976-2010 with a resolution of 15
Minutes.
</p>


<h3>Format</h3>

<p>num [1:35] 61.5 77 37 69.3 75.6 74.9 43.7 50.8 55.6 84.1 ...
</p>


<h3>Source</h3>

<p>Hydrographische Dienste Oberoesterreich und Salzburg, analyzed by
package author (<a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(annMax)
str(annMax)
str(annMax)
plot(1976:2010, annMax, type="l", las=1, main="annMax dataset from Austria")
# Moving Average with different window widths:
berryFunctions::movAvLines(annMax, x=1976:2010, lwd=3, alpha=0.7)

</code></pre>

<hr>
<h2 id='distLexBoot'>Bootstrapping uncertainty intervals for return periods</h2><span id='topic+distLexBoot'></span>

<h3>Description</h3>

<p>Calculates and plots bootstrap uncertainty intervals for <code><a href="#topic+plotLextreme">plotLextreme</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distLexBoot(
  dlf,
  nbest = 3,
  selection = NULL,
  n = 100,
  prop = 0.8,
  conf.lev = 0.95,
  replace = FALSE,
  RPs = NULL,
  log = TRUE,
  progbars = TRUE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distLexBoot_+3A_dlf">dlf</code></td>
<td>
<p><code>dlf</code> object, as returned by <code><a href="#topic+distLextreme">distLextreme</a></code></p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_nbest">nbest</code></td>
<td>
<p>Number of best fitted distribution functions in dlf for which
bootstrapping is to be done. Overridden by <code>selection</code>. DEFAULT: 3</p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_selection">selection</code></td>
<td>
<p>Character vector with distribution function names to be used.
Suggested to keep this low. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_n">n</code></td>
<td>
<p>Number of subsamples to be processed
(computing time increases extraordinarily). DEFAULT: 100</p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_prop">prop</code></td>
<td>
<p>Proportion of sample to be used in each run. DEFAULT: 0.8</p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_conf.lev">conf.lev</code></td>
<td>
<p>Confidence level (Proportion of subsamples within 'confidence interval').
Quantiles extracted from this value are passed to
<code><a href="berryFunctions.html#topic+quantileMean">quantileMean</a></code>. DEFAULT: 0.95</p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_replace">replace</code></td>
<td>
<p>Logical: replace in each <code><a href="base.html#topic+sample">sample</a></code>? DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_rps">RPs</code></td>
<td>
<p>Return Period vector, by default calculated internally based on
value of <code>log</code>. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_log">log</code></td>
<td>
<p>RPs suitable for plot on a logarithmic axis? DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_progbars">progbars</code></td>
<td>
<p>Show progress bar for Monte Carlo simulation? DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="distLexBoot_+3A_quiet">quiet</code></td>
<td>
<p>Logical: suppress messages? See <code><a href="#topic+distLquantile">distLquantile</a></code>.
DEFAULT: FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Has not been thoroughly tested yet. Bootstrapping defaults can probably be improved.
</p>


<h3>Value</h3>

<p>invisible dlf object, see <code><a href="#topic+printL">printL</a></code>.
Additional elements are: exBootCL (confidence level),
exBootRPs (x values for plot)
exBootSim (all simulation results) and exBootCI (aggregated into CI band).
The last two are each a list with a matrix (return levels)
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Sept 2015 + Dec 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotLexBoot">plotLexBoot</a></code>, <code><a href="#topic+distLextreme">distLextreme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(annMax)
dlf &lt;- distLextreme(annMax, selection=c("gum","gev","wak","nor"))
dlfB &lt;- distLexBoot(dlf, nbest=4, conf.lev=0.5, n=10) # n low for quick example tests
plotLexBoot(dlfB)
plotLexBoot(dlfB, selection=c("nor","gev"))
plotLexBoot(dlfB, selection=c("gum","gev","wak","nor"), order=FALSE)

</code></pre>

<hr>
<h2 id='distLextreme'>Extreme value stats</h2><span id='topic+distLextreme'></span>

<h3>Description</h3>

<p>Extreme value statistics for flood risk estimation.
Input: vector with annual discharge maxima (or all observations for POT approach).
Output: discharge estimates for given return periods,
parameters of several distributions (fit based on L-moments),
quality of fits, plot with linear/logarithmic axis.
(plotting positions by Weibull and Gringorton).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distLextreme(
  dat = NULL,
  dlf = NULL,
  RPs = c(2, 5, 10, 20, 50),
  npy = 1,
  truncate = 0,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distLextreme_+3A_dat">dat</code></td>
<td>
<p>Vector with <em>either</em> (for Block Maxima Approach)
extreme values like annual discharge maxima <em>or</em>
(for Peak Over Threshold approach) all values in time-series.
Ignored if dlf is given. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="distLextreme_+3A_dlf">dlf</code></td>
<td>
<p>List as returned by <code><a href="#topic+distLfit">distLfit</a></code>. See also
<code><a href="#topic+distLquantile">distLquantile</a></code>. Overrides dat! DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="distLextreme_+3A_rps">RPs</code></td>
<td>
<p>Return Periods (in years) for which discharge is estimated.
DEFAULT: c(2,5,10,20,50)</p>
</td></tr>
<tr><td><code id="distLextreme_+3A_npy">npy</code></td>
<td>
<p>Number of observations per year. Leave <code>npy=1</code> if you
use annual block maxima (and leave truncate at 0).
If you use a POT approach (see <a href="../doc/extremeStat">vignette</a>
and examples below) e.g. on daily data, use npy=365.24.
DEFAULT: 1</p>
</td></tr>
<tr><td><code id="distLextreme_+3A_truncate">truncate</code></td>
<td>
<p>Truncated proportion to determine POT threshold,
see <code><a href="#topic+distLquantile">distLquantile</a></code>. DEFAULT: 0</p>
</td></tr>
<tr><td><code id="distLextreme_+3A_quiet">quiet</code></td>
<td>
<p>Suppress notes and progbars? DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="distLextreme_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+distLquantile">distLquantile</a></code> like truncate, selection,
time, progbars</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+plotLextreme">plotLextreme</a></code> adds weibull and gringorton plotting positions
to the distribution lines, which are estimated from the L-moments of the data itself.<br />
I personally believe that if you have, say, 35 values in <code>dat</code>,
the highest return period should be around 36 years (Weibull) and not 60 (Gringorton).<br />
The plotting positions don't affect the distribution parameter estimation,
so this dispute is not really important.
But if you care, go ahead and google &quot;weibull vs gringorton plotting positions&quot;.
</p>
<p>Plotting positions are not used for fitting distributions, but for plotting only.
The ranks of ascendingly sorted extreme values are used to
compute the probability of non-exceedance Pn:<br />
<code>Pn_w &lt;-  Rank      /(n+1)       # Weibull</code><br />
<code>Pn_g &lt;- (Rank-0.44)/(n+0.12)    # Gringorton (taken from lmom:::evplot.default)</code><br />
Finally: RP = Return period = recurrence interval = 1/P_exceedance = 1/(1-P_nonexc.), thus:<br />
<code>RPweibull = 1/(1-Pn_w)</code> and analogous for gringorton.<br />
</p>


<h3>Value</h3>

<p>invisible dlf object, see <code><a href="#topic+printL">printL</a></code>.
The added element is <code>returnlev</code>, a data.frame with the return level (discharge)
for all given RPs and for each distribution.
Note that this differs from <code><a href="#topic+distLquantile">distLquantile</a></code> (matrix output, not data.frame)
</p>


<h3>Note</h3>

<p>This function replaces <code>berryFunctions::extremeStatLmom</code>
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, 2012 (first draft) - 2014 &amp; 2015 (main updates)
</p>


<h3>References</h3>

<p><a href="https://RclickHandbuch.wordpress.com">https://RclickHandbuch.wordpress.com</a> Chapter 15 (German)<br />
Christoph Mudersbach: Untersuchungen zur Ermittlung von hydrologischen
Bemessungsgroessen mit Verfahren der instationaeren Extremwertstatistik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distLfit">distLfit</a></code>. <code><a href="#topic+distLexBoot">distLexBoot</a></code> for confidence
interval from Bootstrapping.
<code><a href="extRemes.html#topic+fevd">fevd</a></code> in the package <code>extRemes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic examples
# BM vs POT
# Plotting options
# weighted mean based on Goodness of fit (GOF)
# Effect of data proportion used to estimate GOF
# compare extremeStat with other packages

library(lmomco)
library(berryFunctions)

data(annMax) # annual streamflow maxima in river in Austria

# Basic examples ---------------------------------------------------------------
dlf &lt;- distLextreme(annMax)
plotLextreme(dlf, log=TRUE)
plotLextreme(dlf, log="xy")
plotLextreme(dlf)

# Object structure:
str(dlf, max.lev=2)
printL(dlf)

# discharge levels for default return periods:
dlf$returnlev

# Estimate discharge that could occur every 80 years (at least empirically):
Q80 &lt;- distLextreme(dlf=dlf, RPs=80)$returnlev
round(sort(Q80[1:17,1]),1)
# 99 to 143 m^3/s can make a relevant difference in engineering!
# That's why the rows weighted by GOF are helpful. Weights are given as in
plotLweights(dlf) # See also section weighted mean below
# For confidence intervals see ?distLexBoot

# Return period of a given discharge value, say 120 m^3/s:
round0(sort(1/(1-sapply(dlf$parameter, plmomco, x=120) )  ),1)
# exponential:                 every 29 years
# gev (general extreme value dist):  59,
# Weibull:                     every 73 years only


# BM vs POT --------------------------------------------------------------------
# Return levels by Block Maxima approach vs Peak Over Threshold approach:
# BM distribution theoretically converges to GEV, POT to GPD

data(rain, package="ismev")
days &lt;- seq(as.Date("1914-01-01"), as.Date("1961-12-30"), by="days")
BM &lt;- tapply(rain, format(days,"%Y"), max)  ;  rm(days)
dlfBM &lt;- plotLextreme(distLextreme(BM, emp=FALSE), ylim=lim0(100), log=TRUE, nbest=10)
plotLexBoot(distLexBoot(dlfBM, quiet=TRUE), ylim=lim0(100))
plotLextreme(dlfBM, log=TRUE, ylim=lim0(100))

dlfPOT99 &lt;- distLextreme(rain, npy=365.24, trunc=0.99, emp=FALSE)
dlfPOT99 &lt;- plotLextreme(dlfPOT99, ylim=lim0(100), log=TRUE, nbest=10, main="POT 99")
printL(dlfPOT99)

# using only nonzero values (normally yields better fits, but not here)
rainnz &lt;- rain[rain&gt;0]
dlfPOT99nz &lt;- distLextreme(rainnz, npy=length(rainnz)/48, trunc=0.99, emp=FALSE)
dlfPOT99nz &lt;- plotLextreme(dlfPOT99nz, ylim=lim0(100), log=TRUE, nbest=10,
                           main=paste("POT 99 x&gt;0, npy =", round(dlfPOT99nz$npy,2)))

## Not run:  ## Excluded from CRAN R CMD check because of computing time

dlfPOT99boot &lt;- distLexBoot(dlfPOT99, prop=0.4)
printL(dlfPOT99boot)
plotLexBoot(dlfPOT99boot)


dlfPOT90 &lt;- distLextreme(rain, npy=365.24, trunc=0.90, emp=FALSE)
dlfPOT90 &lt;- plotLextreme(dlfPOT90, ylim=lim0(100), log=TRUE, nbest=10, main="POT 90")

dlfPOT50 &lt;- distLextreme(rain, npy=365.24, trunc=0.50, emp=FALSE)
dlfPOT50 &lt;- plotLextreme(dlfPOT50, ylim=lim0(100), log=TRUE, nbest=10, main="POT 50")

## End(Not run)

ig99 &lt;- ismev::gpd.fit(rain, dlfPOT99$threshold)
ismev::gpd.diag(ig99); title(main=paste(99, ig99$threshold))
## Not run: 
ig90 &lt;- ismev::gpd.fit(rain, dlfPOT90$threshold)
ismev::gpd.diag(ig90); title(main=paste(90, ig90$threshold))
ig50 &lt;- ismev::gpd.fit(rain, dlfPOT50$threshold)
ismev::gpd.diag(ig50); title(main=paste(50, ig50$threshold))

## End(Not run)


# Plotting options -------------------------------------------------------------
plotLextreme(dlf=dlf)
# Line colors / select distributions to be plotted:
plotLextreme(dlf, nbest=17, distcols=heat.colors(17), lty=1:5) # lty is recycled
plotLextreme(dlf, selection=c("gev", "gam", "gum"), distcols=4:6, PPcol=3, lty=3:2)
plotLextreme(dlf, selection=c("gpa","glo","wei","exp"), pch=c(NA,NA,6,8),
                 order=TRUE, cex=c(1,0.6, 1,1), log=TRUE, PPpch=c(16,NA), n_pch=20)
# use n_pch to say how many points are drawn per line (important for linear axis)

plotLextreme(dlf, legarg=list(cex=0.5, x="bottom", box.col="red", col=3))
# col in legarg list is (correctly) ignored
## Not run: 
## Excluded from package R CMD check because it's time consuming

plotLextreme(dlf, PPpch=c(1,NA)) # only Weibull plotting positions
# add different dataset to existing plot:
distLextreme(Nile/15, add=TRUE, PPpch=NA, distcols=1, selection="wak", legend=FALSE)

# Logarithmic axis
plotLextreme(distLextreme(Nile), log=TRUE, nbest=8)



# weighted mean based on Goodness of fit (GOF) ---------------------------------
# Add discharge weighted average estimate continuously:
plotLextreme(dlf, nbest=17, legend=FALSE)
abline(h=115.6, v=50)
RP &lt;- seq(1, 70, len=100)
DischargeEstimate &lt;- distLextreme(dlf=dlf, RPs=RP, plot=FALSE)$returnlev
lines(RP, DischargeEstimate["weighted2",], lwd=3, col="orange")

# Or, on log scale:
plotLextreme(dlf, nbest=17, legend=FALSE, log=TRUE)
abline(h=115.9, v=50)
RP &lt;- unique(round(logSpaced(min=1, max=70, n=200, plot=FALSE),2))
DischargeEstimate &lt;- distLextreme(dlf=dlf, RPs=RP)$returnlev
lines(RP, DischargeEstimate["weighted2",], lwd=5)


# Minima -----------------------------------------------------------------------

browseURL("https://nrfa.ceh.ac.uk/data/station/meanflow/39072")
qfile &lt;- system.file("extdata/discharge39072.csv", package="berryFunctions")
Q &lt;- read.table(qfile, skip=19, header=TRUE, sep=",", fill=TRUE)[,1:2]
rm(qfile)
colnames(Q) &lt;- c("date","discharge")
Q$date &lt;- as.Date(Q$date)
plot(Q, type="l")
Qmax &lt;- tapply(Q$discharge, format(Q$date,"%Y"), max)
plotLextreme(distLextreme(Qmax, quiet=TRUE))
Qmin &lt;- tapply(Q$discharge, format(Q$date,"%Y"), min)
dlf &lt;- distLextreme(-Qmin, quiet=TRUE, RPs=c(2,5,10,20,50,100,200,500))
plotLextreme(dlf, ylim=c(0,-31), yaxs="i", yaxt="n", ylab="Q annual minimum", nbest=14)
axis(2, -(0:3*10), 0:3*10, las=1)
-dlf$returnlev[c(1:14,21), ]
# Some distribution functions are an obvious bad choice for this, so I use
# weighted 3: Values weighted by GOF of dist only for the best half.
# For the Thames in Windsor, we will likely always have &gt; 9 m^3/s streamflow


# compare extremeStat with other packages: ---------------------------------------
library(extRemes)
plot(fevd(annMax))
par(mfrow=c(1,1))
return.level(fevd(annMax, type="GEV")) # "GP", "PP", "Gumbel", "Exponential"
distLextreme(dlf=dlf, RPs=c(2,20,100))$returnlev["gev",]
# differences are small, but noticeable...
# if you have time for a more thorough control, please pass me the results!


# yet another dataset for testing purposes:
Dresden_AnnualMax &lt;- c(403, 468, 497, 539, 542, 634, 662, 765, 834, 847, 851, 873,
885, 983, 996, 1020, 1028, 1090, 1096, 1110, 1173, 1180, 1180,
1220, 1270, 1285, 1329, 1360, 1360, 1387, 1401, 1410, 1410, 1456,
1556, 1580, 1610, 1630, 1680, 1734, 1740, 1748, 1780, 1800, 1820,
1896, 1962, 2000, 2010, 2238, 2270, 2860, 4500)
plotLextreme(distLextreme(Dresden_AnnualMax))

## End(Not run) # end dontrun

</code></pre>

<hr>
<h2 id='distLfit'>Fit distributions via L-moments</h2><span id='topic+distLfit'></span>

<h3>Description</h3>

<p>Fit several distributions via L-moments with <code>lmomco::<a href="lmomco.html#topic+lmom2par">lmom2par</a></code>
and compute goodness of fit measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distLfit(
  dat,
  datname = deparse(substitute(dat)),
  selection = NULL,
  speed = TRUE,
  ks = FALSE,
  truncate = 0,
  threshold = berryFunctions::quantileMean(dat, truncate),
  progbars = length(dat) &gt; 200,
  time = TRUE,
  quiet = FALSE,
  ssquiet = quiet,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distLfit_+3A_dat">dat</code></td>
<td>
<p>Vector with values</p>
</td></tr>
<tr><td><code id="distLfit_+3A_datname">datname</code></td>
<td>
<p>Character string for main, xlab etc.
DEFAULT: <code>deparse(substitute(dat))</code></p>
</td></tr>
<tr><td><code id="distLfit_+3A_selection">selection</code></td>
<td>
<p>Selection of distributions. Character vector with types
as in <code><a href="lmomco.html#topic+lmom2par">lmom2par</a></code>. Overrides speed. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="distLfit_+3A_speed">speed</code></td>
<td>
<p>If TRUE, several distributions are omitted, for the reasons
shown in <code>lmomco::<a href="lmomco.html#topic+dist.list">dist.list</a>()</code>. DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="distLfit_+3A_ks">ks</code></td>
<td>
<p>Include ks.test results and CDF R^2 in <code>dlf$gof</code>?
Computing is much faster when FALSE. DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="distLfit_+3A_truncate">truncate</code></td>
<td>
<p>Number between 0 and 1. POT Censored <code><a href="#topic+distLquantile">distLquantile</a></code>:
fit to highest values only (truncate lower proportion of x).
Probabilities are adjusted accordingly. DEFAULT: 0</p>
</td></tr>
<tr><td><code id="distLfit_+3A_threshold">threshold</code></td>
<td>
<p>POT cutoff value. If you want correct percentiles,
set this only via truncate, see Details of <code><a href="#topic+q_gpd">q_gpd</a></code>.
DEFAULT: <code><a href="berryFunctions.html#topic+quantileMean">quantileMean</a>(x, truncate)</code></p>
</td></tr>
<tr><td><code id="distLfit_+3A_progbars">progbars</code></td>
<td>
<p>Show progress bars for each loop? DEFAULT: TRUE if n &gt; 200</p>
</td></tr>
<tr><td><code id="distLfit_+3A_time">time</code></td>
<td>
<p><code><a href="base.html#topic+message">message</a></code> execution time? DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="distLfit_+3A_quiet">quiet</code></td>
<td>
<p>Suppress notes? DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="distLfit_+3A_ssquiet">ssquiet</code></td>
<td>
<p>Suppress sample size notes? DEFAULT: quiet</p>
</td></tr>
<tr><td><code id="distLfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+distLweights">distLweights</a></code>
like weightc, order=FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible dlf object, see <code><a href="#topic+printL">printL</a></code>.
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Sept 2014, July 2015, Dec 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotLfit">plotLfit</a></code>, <code><a href="#topic+distLweights">distLweights</a></code>, <code><a href="#topic+plotLweights">plotLweights</a></code>,
<code>extRemes::<a href="extRemes.html#topic+fevd">fevd</a></code>, <code>MASS::<a href="MASS.html#topic+fitdistr">fitdistr</a></code>.<br />
More complex estimates of quality of fits:
Fard, M.N.P. and Holmquist, B. (2013, Chilean Journal of Statistics):
Powerful goodness-of-fit tests for the extreme value distribution.
https://chjs.mat.utfsm.cl/volumes/04/01/Fard_Holmquist(2013).pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(annMax)
# basic usage on real data (annual discharge maxima in Austria)
dlf &lt;- distLfit(annMax)
str(dlf, max.lev=2)
printL(dlf)
plotLfit(dlf)

# arguments that can be passed to plotting function:
plotLfit(dlf, lty=2, col=3, nbest=17, legargs=list(lwd=3), main="booh!")
set.seed(42)
dlf_b &lt;- distLfit(rbeta(100, 5, 2))
plotLfit(dlf_b, nbest=10, legargs=c(x="left"))
plotLfit(dlf_b, selection=c("gpa", "glo", "gev", "wak"))
plotLfit(dlf_b, selection=c("gpa", "glo", "gev", "wak"), order=TRUE)
plotLfit(dlf_b, distcols=c("orange",3:6), lty=1:3) # lty is recycled
plotLfit(dlf_b, cdf=TRUE)
plotLfit(dlf_b, cdf=TRUE, histargs=list(do.points=FALSE), sel="nor")


# logarithmic axes:
set.seed(1)
y &lt;- 10^rnorm(300, mean=2, sd=0.3) # if you use 1e4, distLfit will be much slower
hist(y, breaks=20)
berryFunctions::logHist(y, col=8)
dlf &lt;- distLfit(log10(y))
plotLfit(dlf, breaks=50)
plotLfit(dlf, breaks=50, log=TRUE)


# Goodness of fit: how well do the distributions fit the original data?
# measured by RMSE of cumulated distribution function and ?ecdf
# RMSE: root of average of ( errors squared )  ,   errors = line distances
dlf &lt;- distLfit(annMax, ks=TRUE)
plotLfit(dlf, cdf=TRUE, sel=c("wak", "revgum"))
x &lt;- sort(annMax)
segments(x0=x, y0=lmomco::plmomco(x, dlf$parameter$revgum), y1=ecdf(annMax)(x), col=2)
segments(x0=x, y0=lmomco::plmomco(x, dlf$parameter$wak), y1=ecdf(annMax)(x), col=4, lwd=2)
# weights by three different weighting schemes, see distLweights:
plotLweights(dlf)
plotLfit(distLfit(annMax              ), cdf=TRUE, nbest=17)$gof
plotLfit(distLfit(annMax, truncate=0.7), cdf=TRUE, nbest=17)$gof
pairs(dlf$gof[,-(2:5)]) # measures of goodness of fit are correlated quite well here.
dlf$gof

# Kolmogorov-Smirnov Tests for normal distribution return slightly different values:
library(lmomco)
ks.test(annMax, "pnorm", mean(annMax), sd(annMax) )$p.value
ks.test(annMax, "cdfnor", parnor(lmoms(annMax)))$p.value


# Fit all available distributions (30):
## Not run: # this takes a while...
d_all &lt;- distLfit(annMax, speed=FALSE, progbars=TRUE) # 20 sec
printL(d_all)
plotLfit(d_all, nbest=30, distcols=grey(1:22/29), xlim=c(20,140))
plotLfit(d_all, nbest=30, ylim=c(0,0.04), xlim=c(20,140))
plotLweights(d_all)
d_all$gof

## End(Not run)

</code></pre>

<hr>
<h2 id='distLquantile'>distribution quantiles</h2><span id='topic+distLquantile'></span>

<h3>Description</h3>

<p>Parametric quantiles of distributions fitted to a sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distLquantile(
  x = NULL,
  probs = c(0.8, 0.9, 0.99),
  truncate = 0,
  threshold = quantileMean(dlf$dat_full[is.finite(dlf$dat_full)], truncate),
  sanerange = NA,
  sanevals = NA,
  selection = NULL,
  order = TRUE,
  dlf = NULL,
  datname = deparse(substitute(x)),
  list = FALSE,
  empirical = TRUE,
  qemp.type = 8,
  weighted = empirical,
  gpd = empirical,
  speed = TRUE,
  quiet = FALSE,
  ssquiet = quiet,
  ttquiet = quiet,
  gpquiet = missing(quiet) | quiet,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distLquantile_+3A_x">x</code></td>
<td>
<p>Sample for which parametric quantiles are to be calculated.
If it is NULL (the default), <code>dat</code> from <code>dlf</code> is used.
DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities with values in [0,1]. DEFAULT: c(0.8,0.9,0.99)</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_truncate">truncate</code></td>
<td>
<p>Number between 0 and 1 (proportion of sample discarded).
Censored quantile: fit to highest values only (truncate lower proportion of x).
Probabilities are adjusted accordingly. DEFAULT: 0</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_threshold">threshold</code></td>
<td>
<p>POT cutoff value. If you want correct percentiles,
set this only via truncate, see Details of <code><a href="#topic+q_gpd">q_gpd</a></code>.
DEFAULT: <code><a href="berryFunctions.html#topic+quantileMean">quantileMean</a>(x, truncate)</code></p>
</td></tr>
<tr><td><code id="distLquantile_+3A_sanerange">sanerange</code></td>
<td>
<p>Range outside of which results should be changed to <code>sanevals</code>.
This can capture numerical errors in small samples
(notably GPD_MLE_extRemes). If NA, this is ignored.
Attention: the RMSE column is also checked and changed.
DEFAULT: NA</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_sanevals">sanevals</code></td>
<td>
<p>Values to be used below [1] and above [2] <code>sanerange</code>.
DEFAULT: NA</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_selection">selection</code></td>
<td>
<p>Distribution type, eg. &quot;gev&quot; or &quot;wak&quot;, see
<code>lmomco::<a href="lmomco.html#topic+dist.list">dist.list</a></code>.
Can be a vector. If NULL (the default), all types present in
dlf$distnames are used. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_order">order</code></td>
<td>
<p>Logical: sort by RMSE, even if selection is given?
See <code><a href="#topic+distLweights">distLweights</a></code>. DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_dlf">dlf</code></td>
<td>
<p>dlf object described in <code><a href="#topic+extremeStat">extremeStat</a></code>. Use this to save
computing time for large datasets where you already have dlf.
DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_datname">datname</code></td>
<td>
<p>Character string: data name, important if list=TRUE.
DEFAULT: deparse(substitute(x))</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_list">list</code></td>
<td>
<p>Return full <code>dlf</code>list with output attached as element <code>quant</code>?
If FALSE (the default), just the matrix with quantile estimates
is returned. DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_empirical">empirical</code></td>
<td>
<p>Add rows &quot;empirical&quot; and &quot;quantileMean&quot; in the output matrix?
Uses <code><a href="stats.html#topic+quantile">quantile</a></code> with <code>qemp.type</code> (ignoring truncation)
and <code><a href="berryFunctions.html#topic+quantileMean">quantileMean</a></code>. DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_qemp.type">qemp.type</code></td>
<td>
<p>Method passed to <code><a href="stats.html#topic+quantile">quantile</a></code> for row &quot;empirical&quot;.
Only used if <code>empirical=TRUE</code>.
DEFAULT: 8 (NOT the <code>stats::quantile</code> default)</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_weighted">weighted</code></td>
<td>
<p>Include weighted averages across distribution functions to the output?
DEFAULT: empirical, so additional options can all be excluded with emp=F.</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_gpd">gpd</code></td>
<td>
<p>Include GPD quantile estimation via <code><a href="#topic+q_gpd">q_gpd</a></code>?
Note that the 'GPD_LMO_lmomco' result differs slightly from 'gpa',
especially if truncate=0. This comes from using
x&gt;threshold (all 'GPD_*' distributions) or
x&gt;=threshold ('gpa' and all other distributions in extremeStat).
DEFAULT: empirical</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_speed">speed</code></td>
<td>
<p>Compute <code><a href="#topic+q_gpd">q_gpd</a></code> only for fast methods?
Currently, only the Bayesian method is excluded. DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_quiet">quiet</code></td>
<td>
<p>Suppress notes? If it is actually set to FALSE (not missing),
gpquiet is set to FALSE to print all the warnings including stacks.
DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_ssquiet">ssquiet</code></td>
<td>
<p>Suppress sample size notes? DEFAULT: quiet</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_ttquiet">ttquiet</code></td>
<td>
<p>Suppress truncation!=threshold note? DEFAULT: quiet</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_gpquiet">gpquiet</code></td>
<td>
<p>Suppress warnings in <code><a href="#topic+q_gpd">q_gpd</a></code>?
DEFAULT: TRUE if quiet is not specified, else quiet</p>
</td></tr>
<tr><td><code id="distLquantile_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+distLfit">distLfit</a></code>
and <code><a href="#topic+distLweights">distLweights</a></code> like weightc, ks=TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Very high quantiles (99% and higher) need large sample sizes for
<code><a href="stats.html#topic+quantile">quantile</a></code> to yield a robust estimate. Theoretically, at least
1/(1-probs) values must be present, e.g. 10'000 for Q99.99%. With smaller
sample sizes (eg n=35), they underestimate the actual (but unknown)
quantile. Parametric quantiles need only small sample sizes. They don't have
a systematical underestimation bias, but have higher variability.
</p>


<h3>Value</h3>

<p>if list=FALSE (default): invisible matrix with distribution quantile values .
if list=TRUE: invisible dlf object, see <code><a href="#topic+printL">printL</a></code>
</p>


<h3>Note</h3>

<p>NAs are always removed from x in <code><a href="#topic+distLfit">distLfit</a></code>
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, March + July 2015, Feb 2016
</p>


<h3>References</h3>

<p>On GPD: <a href="https://stats.stackexchange.com/questions/69438">https://stats.stackexchange.com/questions/69438</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+q_gpd">q_gpd</a></code>, <code><a href="#topic+distLfit">distLfit</a></code>, require(&quot;truncdist&quot;)
Xian Zhou, Liuquan Sun and Haobo Ren (2000): Quantile estimation for
left truncated and right censored data, Statistica Sinica 10
<a href="https://www3.stat.sinica.edu.tw/statistica/oldpdf/A10n411.pdf">https://www3.stat.sinica.edu.tw/statistica/oldpdf/A10n411.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(annMax) # Annual Discharge Maxima (streamflow)

distLquantile(annMax, emp=FALSE)[,] # several distribution functions in lmomco

## Not run: 
## Taken out from CRAN package check because it's slow
distLquantile(annMax, truncate=0.8, probs=0.95)[,] # POT (annMax already block maxima)
dlf &lt;- distLquantile(annMax, probs=0.95, list=TRUE)
plotLquantile(dlf, linargs=list(lwd=3), nbest=5, breaks=10)
dlf$quant
# Parametric 95% quantile estimates range from 92 to 111!
# But the best fitting distributions all lie aroud 103.

# compare General Pareto Fitting methods
# Theoretically, the tails of distributions converge to GPD (General Pareto)
# q_gpd compares several R packages for fitting and quantile estimation:
dlq &lt;- distLquantile(annMax, weighted=FALSE, quiet=TRUE, probs=0.97, list=TRUE)
dlq$quant
plotLquantile(dlq) # per default best fitting distribution functions
plotLquantile(dlq, row=c("wak","GPD*"), nbest=14)
#pdf("dummy.pdf", width=9)
plotLquantile(dlq, row="GPD*", nbest=13, xlim=c(102,110),
          linargs=list(lwd=3), heights=seq(0.02, 0.005, len=14))
#dev.off()


# Sanity checks: important for very small samples:
x1 &lt;- c(2.6, 2.5, 2.9, 3, 5, 2.7, 2.7, 5.7, 2.8, 3.1, 3.6, 2.6, 5.8, 5.6, 5.7, 5.3)
q1 &lt;- distLquantile(x1, sanerange=c(0,500), sanevals=c(NA,500))
x2 &lt;- c(6.1, 2.4, 4.1, 2.4, 6, 6.3, 2.9, 6.8, 3.5)
q2 &lt;- distLquantile(x2, sanerange=c(0,500), sanevals=c(NA,500), quiet=FALSE)
x3 &lt;- c(4.4, 3, 1.8, 7.3, 2.1, 2.1, 1.8, 1.8)
q3 &lt;- distLquantile(x3, sanerange=c(0,500), sanevals=c(NA,500))

# weighted distribution quantiles are calculated by different weighting schemes:
plotLweights(dlf)

# If speed is important and parameters are already available, pass them via dlf:
distLquantile(dlf=dlf, probs=0:5/5, selection=c("wak","gev","kap"))
distLquantile(dlf=dlf, truncate=0.3, list=TRUE)$truncate

# censored (truncated, trimmed) quantile, Peak Over Treshold (POT) method:
qwak &lt;- distLquantile(annMax, sel="wak", prob=0.95, emp=FALSE, list=TRUE)
plotLquantile(qwak, ylim=c(0,0.06) ); qwak$quant
qwak2 &lt;-distLquantile(annMax, sel="wak", prob=0.95, emp=FALSE, list=TRUE, truncate=0.6)
plotLquantile(qwak2, add=TRUE, distcols="blue")


# Simulation of truncation effect
library(lmomco)
#set.seed(42)
rnum &lt;- rlmomco(n=1e3, para=dlf$parameter$gev)
myprobs &lt;- c(0.9, 0.95, 0.99, 0.999)
mytrunc &lt;- seq(0, 0.9, length.out=20)
trunceffect &lt;- sapply(mytrunc, function(mt) distLquantile(rnum, selection="gev",
                             probs=myprobs, truncate=mt, quiet=TRUE,
                             pempirical=FALSE)["gev",])
# If more values are truncated, the function runs faster

op &lt;- par(mfrow=c(2,1), mar=c(2,4.5,2,0.5), cex.main=1)
dlf1 &lt;- distLquantile(rnum, sel="gev", probs=myprobs, emp=FALSE, list=TRUE)
dlf2 &lt;- distLquantile(rnum, sel="gev", probs=myprobs, emp=FALSE, list=TRUE, truncate=0.3)
plotLquantile(dlf1, ylab="", xlab="")
plotLquantile(dlf2, add=TRUE, distcols=4)
legend("right", c("fitted GEV", "fitted with truncate=0.3"), lty=1, col=c(2,4), bg="white")
par(mar=c(3,4.5,3,0.5))
plot(mytrunc, trunceffect[1,], ylim=range(trunceffect), las=1, type="l",
     main=c("High quantiles of 1000 random numbers from gev distribution",
           "Estimation based on proportion of lower values truncated"),
     xlab="", ylab="parametric quantile")
title(xlab="Proportion censored", mgp=c(1.8,1,0))
for(i in 2:4) lines(mytrunc, trunceffect[i,])
library("berryFunctions")
textField(rep(0.5,4), trunceffect[,11], paste0("Q",myprobs*100,"%") )
par(op)

trunc &lt;- seq(0,0.1,len=200)
dd &lt;- pbsapply(trunc, function(t) distLquantile(annMax,
          selection="gpa", weight=FALSE, truncate=t, prob=0.99, quiet=T)[c(1,3),])
 plot(trunc, dd[1,], type="o", las=1)
lines(trunc, dd[2,], type="o", col=2)


set.seed(3); rnum &lt;- rlmomco(n=1e3, para=dlf$parameter$gpa)
qd99 &lt;- evir::quant(rnum, p=0.99, start=15, end=1000, ci=0.5, models=30)
axis(3, at=seq(-1000,0, length=6), labels=0:5/5, pos=par("usr")[3])
title(xlab="Proportion truncated", line=-3)
mytrunc &lt;- seq(0, 0.9, length.out=30)
trunceffect &lt;- sapply(mytrunc, function(mt) distLquantile(rnum, selection="gpa",
                      probs=0.99, truncate=mt, plot=FALSE, quiet=TRUE,
                      empirical=FALSE, gpd=TRUE))
lines(-1000*(1-mytrunc), trunceffect[1,], col=4)
lines(-1000*(1-mytrunc), trunceffect[2,], col=3) # interesting...
for(i in 3:13) lines(-1000*(1-mytrunc), trunceffect[i,], col=3) # interesting...

# If you want the estimates only for one single truncation, use
q_gpd(rnum, probs=myprobs, truncate=0.5)


## End(Not run) # end dontrun

</code></pre>

<hr>
<h2 id='distLweights'>Compute distribution weights from GOF</h2><span id='topic+distLweights'></span>

<h3>Description</h3>

<p>Determine distribution function weights from RMSE for weighted averages.
The weights are inverse to RMSE: weight1 for all dists,
weight2 places zero weight on the worst fitting function,
weight3 on the worst half of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distLweights(
  RMSE,
  order = TRUE,
  onlydn = TRUE,
  weightc = NA,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distLweights_+3A_rmse">RMSE</code></td>
<td>
<p>Numeric: Named vector with goodness of fit values (RMSE).
Can also be a data.frame, in which case the column rmse or RMSE is used.</p>
</td></tr>
<tr><td><code id="distLweights_+3A_order">order</code></td>
<td>
<p>Logical: should result be ordered by RMSE? If order=FALSE,
the order of appearance in RMSE is kept (alphabetic or selection
in <code><a href="#topic+distLfit">distLfit</a></code>). DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="distLweights_+3A_onlydn">onlydn</code></td>
<td>
<p>Logical: weight only distributions from <code>lmomco::<a href="lmomco.html#topic+dist.list">dist.list</a></code>?
DEFAULT: TRUE (all other RMSEs are set to 0)</p>
</td></tr>
<tr><td><code id="distLweights_+3A_weightc">weightc</code></td>
<td>
<p>Optional: a named vector with custom weights for each distribution.
Are internally normalized to sum=1 after removing nonfitted dists.
Names match the parameter names from <code>RMSE</code>.
DEFAULT: NA</p>
</td></tr>
<tr><td><code id="distLweights_+3A_quiet">quiet</code></td>
<td>
<p>Logical: Suppress messages. DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="distLweights_+3A_...">...</code></td>
<td>
<p>Ignored arguments (so a set of arguments can be passed to
distLfit and distLquantile and arguments used only in the latter
will not throw errors)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Dec 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distLfit">distLfit</a></code>, <code><a href="#topic+distLquantile">distLquantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># weights from RMSE vector:
RMSE &lt;- c(gum=0.20, wak=0.17, gam=0.21, gev=0.15)
distLweights(RMSE)
distLweights(RMSE, order=FALSE)

# weights from RMSE in data.frame:
df &lt;- data.frame("99.9%"=2:5, RMSE=sample(3:6))
rownames(df) &lt;- letters[1:4]
df ;  distLweights(df, onlydn=FALSE)

# custom weights:
set.seed(42); x &lt;- data.frame(A=1:5, RMSE=runif(5)) ; x
distLweights(x) # two warnings
distLweights(x, weightc=c("1"=3, "3"=5), onlydn=FALSE)
distLweights(x, weightc=c("1"=3, "3"=5), order=FALSE, onlydn=FALSE)

# real life example:
data(annMax)
cw &lt;- c("gpa"=7, "gev"=3, "wak"=6, "wei"=4, "kap"=3.5, "gum"=3, "ray"=2.1,
        "ln3"=2, "pe3"=2.5, "gno"=4, "gam"=5)
dlf &lt;- distLfit(annMax, weightc=cw, quiet=TRUE, order=FALSE)
plotLweights(dlf)


# GOF judgement by RMSE, not R2 --------
# Both RMSE and R2 are computed with ECDF and TCDF
# R2 may be very good (see below), but fit needs to be close to 1:1 line,
# which is better measured by RMSE

dlf &lt;- distLfit(annMax, ks=TRUE)
op &lt;- par(mfrow=c(1,2), mar=c(3,4,0.5,0.5), mgp=c(1.9,0.7,0))
yy &lt;- nrow(dlf$gof):1 # depends on length of lmomco::dist.list()
plot(dlf$gof$RMSE, yy, yaxt="n", ylab="", type="o"); axis(2, yy, rownames(dlf$gof), las=1)
plot(dlf$gof$R2,   yy, yaxt="n", ylab="", type="o"); axis(2, yy, rownames(dlf$gof), las=1)
par(op)
sel &lt;- c("wak","lap","nor","revgum")
plotLfit(dlf, selection=sel, cdf=TRUE)
dlf$gof[sel,-(2:7)]

x &lt;- sort(annMax, decreasing=TRUE)
ECDF &lt;- ecdf(x)(x)
TCDF &lt;- sapply(sel, function(d) lmomco::plmomco(x,dlf$parameter[[d]]))

plot(TCDF[,"lap"],    ECDF, col="cyan", asp=1, las=1)
points(TCDF[,"nor"],    ECDF, col="green")
#points(TCDF[,"wak"],    ECDF, col="blue")
#points(TCDF[,"revgum"], ECDF, col="red")
abline(a=0, b=1, lwd=3, lty=3)
legend("bottomright", c("lap good RMSE bad R2", "nor bad RMSE good R2"),
       col=c("cyan","green"), lwd=2)
berryFunctions::linReg(TCDF[,"lap"], ECDF, add=TRUE, digits=3, col="cyan", pos1="topleft")
berryFunctions::linReg(TCDF[,"nor"], ECDF, add=TRUE, digits=3, col="green", pos1="left")


# more distinct example (but with fake data)
set.seed(42); x &lt;- runif(30)
y1 &lt;-     x+rnorm(30,sd=0.09)
y2 &lt;- 1.5*x+rnorm(30,sd=0.01)-0.3
plot(x,x, asp=1, las=1, main="High cor (R2) does not necessarily mean good fit!")
berryFunctions::linReg(x, y2, add=TRUE, digits=4, pos1="topleft")
points(x,y2, col="red", pch=3)
points(x,y1, col="blue")
berryFunctions::linReg(x, y1, add=TRUE, digits=4, col="blue", pos1="left")
abline(a=0, b=1, lwd=3, lty=3)

</code></pre>

<hr>
<h2 id='extremeStat'>Extreme value statistics on a linear scale</h2><span id='topic+extremeStat'></span>

<h3>Description</h3>

<p>Fit (via L moments), plot (on a linear scale) and compare (by goodness of fit)
several (extreme value) distributions.
Compute high quantiles even in small samples and estimate extrema at given return periods.<br />
Open the <a href="https://cran.r-project.org/package=extremeStat/vignettes/extremeStat.html">Vignette</a>
for an introduction to the package: <code>vignette("extremeStat")</code><br />
This package heavily relies on and thankfully acknowledges the package <code>lmomco</code> by WH Asquith.
</p>


<h3>Package overview</h3>

<p>The main functions in the extremeStat package are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+distLweights">distLweights</a></code> </td><td style="text-align: left;"> -&gt; <code><a href="#topic+plotLweights">plotLweights</a></code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+distLfit">distLfit</a></code>     </td><td style="text-align: left;"> -&gt; <code><a href="#topic+plotLfit">plotLfit</a></code>     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+q_gpd">q_gpd</a></code> + <code><a href="#topic+q_weighted">q_weighted</a></code> -&gt; <code><a href="#topic+distLquantile">distLquantile</a></code> </td><td style="text-align: left;"> -&gt; <code><a href="#topic+plotLquantile">plotLquantile</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+distLextreme">distLextreme</a></code> </td><td style="text-align: left;"> -&gt; <code><a href="#topic+plotLextreme">plotLextreme</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+distLexBoot">distLexBoot</a></code>  </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>They create and modify a list object printed by (and documented in) <code><a href="#topic+printL">printL</a></code>.
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, 2014-2016
</p>


<h3>See Also</h3>

<p>If you are looking for more detailed (uncertainty) analysis, eg confidence intervals,
check out the package <code>extRemes</code>, especially the function <code><a href="extRemes.html#topic+fevd">fevd</a></code>.
<a href="https://cran.r-project.org/package=extRemes">https://cran.r-project.org/package=extRemes</a><br />
Intro slides: <a href="https://sites.lsa.umich.edu/eva2015/wp-content/uploads/sites/44/2015/06/Intro2EVT.pdf">https://sites.lsa.umich.edu/eva2015/wp-content/uploads/sites/44/2015/06/Intro2EVT.pdf</a><br />
Parameter fitting and distribution functions: <a href="https://cran.r-project.org/package=lmomco">https://cran.r-project.org/package=lmomco</a><br />
Distributions: <a href="https://web.archive.org/web/20110807225801/https://www.rmetrics.org/files/Meielisalp2009/Presentations/Scott.pdf">https://web.archive.org/web/20110807225801/https://www.rmetrics.org/files/Meielisalp2009/Presentations/Scott.pdf</a>
and: <a href="https://cran.r-project.org/view=Distributions">https://cran.r-project.org/view=Distributions</a> <br />
R in Hydrology: <a href="https://abouthydrology.blogspot.de/2012/08/r-resources-for-hydrologists.html">https://abouthydrology.blogspot.de/2012/08/r-resources-for-hydrologists.html</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(annMax) # annual discharge maxima from a stream in Austria
plot(annMax, type="l")
dle &lt;- distLextreme(annMax)
dle$returnlev

</code></pre>

<hr>
<h2 id='plotLexBoot'>Bootstrapping uncertainty intervals for return periods</h2><span id='topic+plotLexBoot'></span>

<h3>Description</h3>

<p>plot bootstrap uncertainty intervals for <code><a href="#topic+plotLextreme">plotLextreme</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLexBoot(dlf, selection = NULL, add = FALSE, log = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLexBoot_+3A_dlf">dlf</code></td>
<td>
<p><code>dlf</code> object, as returned by <code><a href="#topic+distLexBoot">distLexBoot</a></code></p>
</td></tr>
<tr><td><code id="plotLexBoot_+3A_selection">selection</code></td>
<td>
<p>Character vector with distribution function names to be used.
Suggested to keep this low. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="plotLexBoot_+3A_add">add</code></td>
<td>
<p>Add to existing plot? DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="plotLexBoot_+3A_log">log</code></td>
<td>
<p>Plot on a logarithmic axis. DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="plotLexBoot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+plotLextreme">plotLextreme</a></code>.
If add=TRUE, they are instead passed to
<code>berryFunctions::<a href="berryFunctions.html#topic+ciBand">ciBand</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible dlf object, see <code><a href="#topic+printL">printL</a></code>
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Dec 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distLexBoot">distLexBoot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see distLexBoot

</code></pre>

<hr>
<h2 id='plotLextreme'>Plot extreme value statistics</h2><span id='topic+plotLextreme'></span>

<h3>Description</h3>

<p>Plots distributions fitted by L-moments and adds plotting positions by Weibull and Gringorton.
This is an auxiliary graphing function to <code><a href="#topic+distLextreme">distLextreme</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLextreme(
  dlf,
  selection = NULL,
  order = FALSE,
  add = FALSE,
  nbest = 5,
  log = "",
  xlim = NULL,
  ylim = NULL,
  las = 1,
  main = dlf$datname,
  xlab = "Return Period RP  [a]",
  ylab = "Discharge HQ  [m\U00B3/s]",
  PPcol = "black",
  PPpch = c(16, 3),
  PPcex = 1,
  distcols = berryFunctions::rainbow2(nbest),
  lty = 1,
  lwd = 1,
  pch = NA,
  cex = 1,
  n_pch = 15,
  legend = TRUE,
  rmse = 4,
  legargs = NULL,
  quiet = FALSE,
  logargs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLextreme_+3A_dlf">dlf</code></td>
<td>
<p>List as returned by <code><a href="#topic+distLextreme">distLextreme</a></code> or <code><a href="#topic+distLexBoot">distLexBoot</a></code></p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_selection">selection</code></td>
<td>
<p>Selection of distributions. Character vector with type as in
<code><a href="lmomco.html#topic+lmom2par">lmom2par</a></code>. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_order">order</code></td>
<td>
<p>If selection is given, should legend and colors be ordered
by gof anyways? DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_add">add</code></td>
<td>
<p>If TRUE, plot is not called before adding lines. This lets you
add lines to an existing plot. DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_nbest">nbest</code></td>
<td>
<p>Number of distributions plotted, in order of goodness of fit.
Overwritten internally if selection is given. DEFAULT: 5</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_log">log</code></td>
<td>
<p>Charstring (&quot;x&quot;, &quot;y&quot;, &quot;xy&quot;) for logarithmic axes. See <code>logargs</code>. DEFAULT: &quot;&quot;</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_xlim">xlim</code></td>
<td>
<p>X-axis limits. DEFAULT: xlim of plotting positions</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_ylim">ylim</code></td>
<td>
<p>Y-lim. DEFAULT: from min to extended max</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_las">las</code></td>
<td>
<p>LabelAxisStyle to orient labels, see <code><a href="graphics.html#topic+par">par</a></code>. DEFAULT: 1</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_main">main</code></td>
<td>
<p>Title of plot. DEFAULT: dlf$datname</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_xlab">xlab</code></td>
<td>
<p>X axis label. DEFAULT: &quot;Return Period RP  [a]&quot;</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label. Please note that the ubuntu pdf viewer might be
unable to display unicode superscript. DEFAULT: &quot;Discharge HQ  [m3/s]&quot;</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_ppcol">PPcol</code></td>
<td>
<p>Plotting Position point colors, vector of length two for
Weibull and Gringorton, recycled. PP are not used for
fitting distributions, but for plotting only. DEFAULT: &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_pppch">PPpch</code></td>
<td>
<p>point characters for plotting positions after Weibull and
Gringorton, respectively. NA to suppress in plot and legend. DEFAULT: c(16,3)</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_ppcex">PPcex</code></td>
<td>
<p>Character EXpansion of plotting points. DEFAULT: 1</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_distcols">distcols</code></td>
<td>
<p>Color for each distribution added with <code><a href="graphics.html#topic+lines">lines</a></code>.
Recycled, if necessary. DEFAULT: <code><a href="berryFunctions.html#topic+rainbow2">rainbow2</a></code></p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_lty">lty</code></td>
<td>
<p>Line TYpe for plotted distributions. Is recycled to from a
vector of length nbest, i.e. a value for each dist. DEFAULT: 1</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_lwd">lwd</code></td>
<td>
<p>Line WiDth of distribution lines. Recycled vector of length nbest.
DEFAULT: 1</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_pch">pch</code></td>
<td>
<p>Point CHaracter of points added at regular intervals.
This makes lines more distinguishable from each other.
NA to suppress. Recycled vector of length nbest. DEFAULT: NA</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_cex">cex</code></td>
<td>
<p>if pch != NA, size of points. Recycled vector of length nbest.
DEFAULT: 1</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_n_pch">n_pch</code></td>
<td>
<p>Number of points spread evenly along the line.
Recycled vector of length nbest. DEFAULT: 15</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_legend">legend</code></td>
<td>
<p>Logical. Add a legend? DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_rmse">rmse</code></td>
<td>
<p>Integer. If rmse &gt; 0, RMSE values are added to legend.
They are rounded to <code>rmse</code> digits. DEFAULT: 4</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_legargs">legargs</code></td>
<td>
<p>list of arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code> except for
legend, col, pch, lwd, lty. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_quiet">quiet</code></td>
<td>
<p>Suppress notes? DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_logargs">logargs</code></td>
<td>
<p>list of arguments passed to <code>berryFunctions::<a href="berryFunctions.html#topic+logAxis">logAxis</a></code>.</p>
</td></tr>
<tr><td><code id="plotLextreme_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code> like yaxt=&quot;n&quot;, ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible dlf object, see <code><a href="#topic+printL">printL</a></code>
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, March 2015, updated heavily Aug 2015
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distLextreme">distLextreme</a></code>, <code><a href="#topic+plotLfit">plotLfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#see
?distLextreme

</code></pre>

<hr>
<h2 id='plotLfit'>Plot distributions fitted with L-moments</h2><span id='topic+plotLfit'></span>

<h3>Description</h3>

<p>Plot histogram and distribution densities <em>or</em> ecdf with cumulated probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLfit(
  dlf,
  nbest = 5,
  selection = NULL,
  order = TRUE,
  rmse = 4,
  cdf = FALSE,
  log = FALSE,
  supportends = TRUE,
  breaks = 20,
  xlim = extendrange(dlf$dat, f = 0.15),
  ylim = NULL,
  col = "grey",
  main = paste(if (cdf) "Cumulated", "density distributions of", dlf$datname),
  xlab = dlf$datname,
  ylab = if (cdf) "(Empirical) Cumulated Density (CDF)" else
    "Probability Density Function (PDF)",
  las = 1,
  distcols = berryFunctions::rainbow2(nbest),
  lty = 1,
  add = FALSE,
  logargs = NULL,
  legend = TRUE,
  legargs = NULL,
  histargs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLfit_+3A_dlf">dlf</code></td>
<td>
<p>List as returned by <code><a href="#topic+distLfit">distLfit</a></code>, containing the
elements <code>dat, parameter, gof, datname</code></p>
</td></tr>
<tr><td><code id="plotLfit_+3A_nbest">nbest</code></td>
<td>
<p>Number of distributions plotted, in order of goodness of fit.
DEFAULT: 5</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_selection">selection</code></td>
<td>
<p>Names of distributions in <code>dlf$parameter</code> that will be drawn.
Overrides nbest. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_order">order</code></td>
<td>
<p>Logical: order legend and colors by RMSE, even if dlf$gof is
unordered or selection is given? DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_rmse">rmse</code></td>
<td>
<p>Integers. If rmse != 0, RMSE values are added to legend.
They are rounded to <code>rmse</code> digits. DEFAULT: 4</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_cdf">cdf</code></td>
<td>
<p>If TRUE, plot cumulated DF instead of probability density.
DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_log">log</code></td>
<td>
<p>If TRUE, logAxis is called. Only makes sense if dlf$dat is
already logarithmic and ranges eg. from -2 to 3. DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_supportends">supportends</code></td>
<td>
<p>If TRUE, dots are placed at the support bounds. DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_breaks">breaks</code></td>
<td>
<p><code><a href="graphics.html#topic+hist">hist</a></code> breaks. DEFAULT: 20</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_xlim">xlim</code>, <code id="plotLfit_+3A_ylim">ylim</code></td>
<td>
<p><code><a href="graphics.html#topic+hist">hist</a></code> or <code><a href="stats.html#topic+ecdf">ecdf</a></code> axis limits.</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_col">col</code></td>
<td>
<p><code><a href="graphics.html#topic+hist">hist</a></code> bar color or <code><a href="stats.html#topic+ecdf">ecdf</a></code> point color.
DEFAULT: &quot;grey&quot;</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_main">main</code>, <code id="plotLfit_+3A_xlab">xlab</code>, <code id="plotLfit_+3A_ylab">ylab</code></td>
<td>
<p><code><a href="graphics.html#topic+hist">hist</a></code> or <code><a href="stats.html#topic+ecdf">ecdf</a></code> main, xlab, ylab.
DEFAULT: abstractions from <code>dlf$datname</code></p>
</td></tr>
<tr><td><code id="plotLfit_+3A_las">las</code></td>
<td>
<p>Label Axis Style for orientation of numbers along axes. DEFAULT: 1</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_distcols">distcols</code></td>
<td>
<p>Color for each distribution added with <code><a href="graphics.html#topic+lines">lines</a></code>.
DEFAULT: <code><a href="berryFunctions.html#topic+rainbow2">rainbow2</a></code></p>
</td></tr>
<tr><td><code id="plotLfit_+3A_lty">lty</code></td>
<td>
<p>Line TYpe for plotted distributions.
Recycled vector of length nbest. DEFAULT: 1</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_add">add</code></td>
<td>
<p>If TRUE, hist/ecdf is not called before adding lines.
This lets you add lines highly customized one by one.
DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_logargs">logargs</code></td>
<td>
<p>List of arguments passed to <code><a href="berryFunctions.html#topic+logAxis">logAxis</a></code> if
<code>log=TRUE</code>. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_legend">legend</code></td>
<td>
<p>Should <code><a href="graphics.html#topic+legend">legend</a></code> be called? DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_legargs">legargs</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code> except for
legend and col. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_histargs">histargs</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+hist">hist</a></code> or <code><a href="stats.html#topic+ecdf">ecdf</a></code>
except for x, freq. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="plotLfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+lines">lines</a></code>, like type, pch, ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this plots density instead of CDF, because the distributions are
easier to discern and tail behavior is easier to judge visually.
</p>


<h3>Value</h3>

<p>invisible dlf object, see <code><a href="#topic+printL">printL</a></code>
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Sept 2014
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distLfit">distLfit</a></code>, <code><a href="#topic+plotLquantile">plotLquantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # See distLfit

</code></pre>

<hr>
<h2 id='plotLquantile'>Plot quantiles of distributions fitted with L-moments</h2><span id='topic+plotLquantile'></span>

<h3>Description</h3>

<p>Plot quantiles of distributions fitted with L-moments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLquantile(
  dlf,
  nbest = 5,
  selection = NULL,
  order = FALSE,
  rows = NULL,
  heights = stats::quantile(par("usr")[3:4], 0.2),
  distcols = dlfplot$distcols,
  linargs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLquantile_+3A_dlf">dlf</code></td>
<td>
<p>List as returned by <code><a href="#topic+distLquantile">distLquantile</a></code>, containing the
elements <code>dat, parameter, gof, datname, quant</code></p>
</td></tr>
<tr><td><code id="plotLquantile_+3A_nbest">nbest</code>, <code id="plotLquantile_+3A_selection">selection</code>, <code id="plotLquantile_+3A_order">order</code></td>
<td>
<p>Distributions to be plotted, see <code><a href="#topic+plotLfit">plotLfit</a></code></p>
</td></tr>
<tr><td><code id="plotLquantile_+3A_rows">rows</code></td>
<td>
<p>Rowname(s) of <code>dlf$quant</code> that should be drawn instead of
the selection / nbest highest ranking distribution functions.
'GPD*' will select all the gpd fits. heights and distcols must then
accordingly have at least 13 elements (or will be recycled).
DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="plotLquantile_+3A_heights">heights</code></td>
<td>
<p>Coordinates of quantile line ends, recycled if necessary.
DEFAULT: 20% of plot height.</p>
</td></tr>
<tr><td><code id="plotLquantile_+3A_distcols">distcols</code></td>
<td>
<p>Color for each distribution added with <code><a href="graphics.html#topic+lines">lines</a></code>.
DEFAULT: dlfplot$distcols</p>
</td></tr>
<tr><td><code id="plotLquantile_+3A_linargs">linargs</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+lines">lines</a></code>. DEFAULT: NULL</p>
</td></tr>
<tr><td><code id="plotLquantile_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+plotLfit">plotLfit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible dlf object, see <code><a href="#topic+printL">printL</a></code>
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Dec 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distLquantile">distLquantile</a></code>, <code><a href="#topic+plotLfit">plotLfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See distLquantile

</code></pre>

<hr>
<h2 id='plotLweights'>Distribution rank comparison</h2><span id='topic+plotLweights'></span>

<h3>Description</h3>

<p>Plot rank comparison of fitted distributions calculated by <code><a href="#topic+distLfit">distLfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLweights(
  dlf,
  type = "o",
  col = RColorBrewer::brewer.pal(5, "Set2"),
  pch = c(1:4, NA),
  lty = 1,
  lwd = 1,
  legargs = NULL,
  main = "Distribution function GOF and weights",
  xlab = "Weight / RMSE",
  ylab = "",
  xlim = range(gof[, grep("weight", colnames(gof))], na.rm = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLweights_+3A_dlf">dlf</code></td>
<td>
<p>List as returned by <code><a href="#topic+distLfit">distLfit</a></code>, containing the element <code>gof</code></p>
</td></tr>
<tr><td><code id="plotLweights_+3A_type">type</code>, <code id="plotLweights_+3A_col">col</code>, <code id="plotLweights_+3A_pch">pch</code>, <code id="plotLweights_+3A_lty">lty</code>, <code id="plotLweights_+3A_lwd">lwd</code></td>
<td>
<p>Vectors with 5 values for line customization. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plotLweights_+3A_legargs">legargs</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code>, like cex, bg, etc.</p>
</td></tr>
<tr><td><code id="plotLweights_+3A_main">main</code>, <code id="plotLweights_+3A_xlab">xlab</code>, <code id="plotLweights_+3A_ylab">ylab</code></td>
<td>
<p>plot title and axis labels</p>
</td></tr>
<tr><td><code id="plotLweights_+3A_xlim">xlim</code></td>
<td>
<p>Range of x axis. DEFAULT: range(gof$weight*)</p>
</td></tr>
<tr><td><code id="plotLweights_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Sept 2014
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distLweights">distLweights</a></code>, <code><a href="#topic+distLfit">distLfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see distLweights and distLfit

</code></pre>

<hr>
<h2 id='printL'>print dlf objects</h2><span id='topic+printL'></span>

<h3>Description</h3>

<p>print list objects created in this package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printL(dlf, digits = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printL_+3A_dlf">dlf</code></td>
<td>
<p>List as explained in section Details</p>
</td></tr>
<tr><td><code id="printL_+3A_digits">digits</code></td>
<td>
<p>number of digits <code><a href="base.html#topic+round">round</a></code>ed to. DEFAULT: 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The common object to share between functions (see overview in <code><a href="#topic+extremeStat">extremeStat</a></code>)
is a list with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>dat</code>          </td><td style="text-align: left;"> numeric vector with (extreme) values,
                         with all NAs and values below threshold removed</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>dat_full</code>     </td><td style="text-align: left;"> original input data complete with NAs</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>datname</code>      </td><td style="text-align: left;"> character string for main, xlab etc </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>parameter</code>    </td><td style="text-align: left;"> list (usually of length 17 if <code>speed=TRUE</code> in
                         <code><a href="#topic+distLfit">distLfit</a></code>)
                         with parameters of each distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>gof</code>          </td><td style="text-align: left;"> dataframe with 'Goodness of Fit' measures, sorted by
                         RMSE of theoretical and empirical cumulated density</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>distnames</code>    </td><td style="text-align: left;"> character vector with selected distribution names</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>distfailed</code>   </td><td style="text-align: left;"> Names of nonfitted distributions or ""</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>distcols</code>     </td><td style="text-align: left;"> colors for distnames (for plotting). If not given manually,
                         determined by <code>berryFunctions::<a href="berryFunctions.html#topic+rainbow2">rainbow2</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>distselector</code> </td><td style="text-align: left;"> character string with function name creating
                         the selection</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>truncate, threshold</code> </td><td style="text-align: left;"> Truncation percentage and threshold value,
                         relevant for <code><a href="#topic+distLquantile">distLquantile</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>optionally, it can also contain:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>returnlev, npy </code>  </td><td style="text-align: left;"> dataframe with values of distributions for given
                         return periods (<code>RPs</code>), number of observations per year/block.
                         These elements are only added in <code><a href="#topic+distLextreme">distLextreme</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>RPweibull, RPgringorton</code> </td><td style="text-align: left;"> Return periods according to plotting positions,
                         added in <code><a href="#topic+plotLextreme">plotLextreme</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>quant</code>        </td><td style="text-align: left;"> Quantile estimates from <code><a href="#topic+distLquantile">distLquantile</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>exBootRPs, qexBootSim, exBootCI, exBootCL</code> </td><td style="text-align: left;"> objects from <code><a href="#topic+distLexBoot">distLexBoot</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>none, prints via <code><a href="base.html#topic+message">message</a></code>.
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Sept 2014, March + July 2015, Dec 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extremeStat">extremeStat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see
?distLextreme

</code></pre>

<hr>
<h2 id='q_gpd'>GPD quantile of sample</h2><span id='topic+q_gpd'></span>

<h3>Description</h3>

<p>Compute quantile of General Pareto Distribution fitted to sample by peak over threshold (POT) method
using threshold from truncation proportion,
comparing several R packages doing this
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_gpd(
  x,
  probs = c(0.8, 0.9, 0.99),
  truncate = 0,
  threshold = berryFunctions::quantileMean(x, truncate),
  package = "extRemes",
  method = NULL,
  list = FALSE,
  undertruncNA = TRUE,
  quiet = FALSE,
  ttquiet = quiet,
  efquiet = quiet,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q_gpd_+3A_x">x</code></td>
<td>
<p>Vector with numeric values. NAs are silently ignored.</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_probs">probs</code></td>
<td>
<p>Probabilities of truncated (Peak over threshold) quantile.
DEFAULT: c(0.8,0.9,0.99)</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_truncate">truncate</code></td>
<td>
<p>Truncation percentage (proportion of sample discarded). DEFAULT: 0</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_threshold">threshold</code></td>
<td>
<p>POT cutoff value. If you want correct percentiles, set this
only via truncate, see Details.
DEFAULT: <code><a href="berryFunctions.html#topic+quantileMean">quantileMean</a>(x, truncate)</code></p>
</td></tr>
<tr><td><code id="q_gpd_+3A_package">package</code></td>
<td>
<p>Character string naming package to be used. One of
c(&quot;lmomco&quot;,&quot;evir&quot;,&quot;evd&quot;,&quot;extRemes&quot;,&quot;fExtremes&quot;,&quot;ismev&quot;).
DEFAULT: &quot;extRemes&quot;</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_method">method</code></td>
<td>
<p><code>method</code> passed to the fitting function, if applicable.
Defaults are internally specified (See Details), depending on
<code>package</code>, if left to the DEFAULT: NULL.</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_list">list</code></td>
<td>
<p>Return result from the fitting function with the quantiles
added to the list as element <code>quant</code> and some information
in elements starting with <code>q_gpd_</code>. DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_undertruncna">undertruncNA</code></td>
<td>
<p>Return NAs for probs below truncate? Highly recommended
to leave this at the DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_quiet">quiet</code></td>
<td>
<p>Should messages from this function be suppressed? DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_ttquiet">ttquiet</code></td>
<td>
<p>Should truncation!=threshold messages from this function be
suppressed? DEFAULT: quiet</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_efquiet">efquiet</code></td>
<td>
<p>Should warnings in function calls to the external packages be
suppressed via <code><a href="base.html#topic+options">options</a>(warn=-1)</code>?
The usual type of warning is: NAs produced in log(...). DEFAULT: quiet</p>
</td></tr>
<tr><td><code id="q_gpd_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the fitting function listed in section Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the value of &quot;package&quot;, this fits the GPD using <br />
<code>lmomco::<a href="lmomco.html#topic+pargpa">pargpa</a></code><br />
<code>evir::<a href="evir.html#topic+gpd">gpd</a></code><br />
<code>evd::<a href="evd.html#topic+fpot">fpot</a></code><br />
<code>extRemes::<a href="extRemes.html#topic+fevd">fevd</a></code><br />
<code>fExtremes::<a href="fExtremes.html#topic+gpdFit">gpdFit</a></code><br />
<code>ismev::<a href="ismev.html#topic+gpd.fit">gpd.fit</a></code><br />
<code>Renext::<a href="Renext.html#topic+Renouv">Renouv</a></code> or <code>Renext::<a href="Renext.html#topic+fGPD">fGPD</a></code><br /><br />
</p>
<p>The <b><code>method</code></b> defaults (and other possibilities) are <br />
lmomco: none, only L-moments <br />
evir: &quot;pwm&quot; (probability-weighted moments), or &quot;ml&quot; (maximum likelihood) <br />
evd: none, only Maximum-likelihood fitting implemented <br />
extRemes: &quot;MLE&quot;, or &quot;GMLE&quot;, &quot;Bayesian&quot;, &quot;Lmoments&quot; <br />
fExtremes: &quot;pwm&quot;, or &quot;mle&quot;<br />
ismev: none, only Maximum-likelihood fitting implemented <br />
Renext: &quot;r&quot; for <code><a href="Renext.html#topic+Renouv">Renouv</a></code> (since distname.y = &quot;gpd&quot;, evd::fpot is used),
or 'f' for <code><a href="Renext.html#topic+fGPD">fGPD</a></code> (with minimum POTs added)<br /><br />
</p>
<p>The Quantiles are always given with <code>probs</code> in regard to the full (uncensored) sample.
If e.g. truncate is 0.90, the distribution function is fitted to the top 10% of the sample.
The 95th percentile of the full sample is equivalent to the 50% quantile of
the subsample actually used for fitting.
For computation, the probabilities are internally updated with <code>p2=(p-t)/(1-t)</code>
but labeled with the original <code>p</code>.
If you truncate 90% of the sample, you cannot compute the 70th percentile anymore,
thus <code>undertruncNA</code> should be left to TRUE. <br />
If not exported by the packages, the quantile functions are extracted from their source code (Nov 2016).
</p>


<h3>Value</h3>

<p>Named vector of quantile estimates for each value of <code>probs</code>,<br />
or if(list): list with element <code>q_gpd_quant</code> and info-elements added.
q_gpd_n_geq is number of values greater than or equal to q_gpd_threshold.
gt is only greater than.
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Feb 2016
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/q/27524131">https://stackoverflow.com/q/27524131</a>,
<a href="https://stats.stackexchange.com/q/129438">https://stats.stackexchange.com/q/129438</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distLquantile">distLquantile</a></code> which compares results for all packages<br />
Other related packages (not implemented):<br />
<a href="https://cran.r-project.org/package=gPdtest">https://cran.r-project.org/package=gPdtest</a><br />
<a href="https://cran.r-project.org/package=actuar">https://cran.r-project.org/package=actuar</a><br />
<a href="https://cran.r-project.org/package=fitdistrplus">https://cran.r-project.org/package=fitdistrplus</a><br />
<a href="https://cran.r-project.org/package=lmom">https://cran.r-project.org/package=lmom</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(annMax)
q_gpd(annMax)
q_gpd(annMax, truncate=0.6)
q_gpd(annMax, truncate=0.85)
q_gpd(annMax, truncate=0.91)

q_gpd(annMax, package="evir")
q_gpd(annMax, package="evir", method="ml")
q_gpd(annMax, package="evd")
q_gpd(annMax, package="extRemes")
q_gpd(annMax, package="extRemes", method="GMLE")
#q_gpd(annMax, package="extRemes", method="Bayesian") # computes a while
q_gpd(annMax, package="extRemes", method="Lmoments")
q_gpd(annMax, package="extRemes", method="nonsense") # NAs
q_gpd(annMax, package="fExtremes")                   # log warnings
q_gpd(annMax, package="fExtremes", efquiet=TRUE)    # silenced warnings
q_gpd(annMax, package="fExtremes", method= "mle")
q_gpd(annMax, package="ismev")
q_gpd(annMax, package="Renext")
q_gpd(annMax, package="Renext", method="f")
berryFunctions::is.error(q_gpd(annMax, package="nonsense"), force=TRUE)

# compare all at once with
d &lt;- distLquantile(annMax); d
# d &lt;- distLquantile(annMax, speed=FALSE); d # for Bayesian also

q_gpd(annMax, truncate=0.85, package="evd")          # Note about quantiles
q_gpd(annMax, truncate=0.85, package="evir")
q_gpd(annMax, truncate=0.85, package="evir", quiet=TRUE) # No note
q_gpd(annMax, truncate=0.85, package="evir", undertruncNA=FALSE)

q_gpd(annMax, truncate=0.85, package="evir", list=TRUE)
str(  q_gpd(annMax, truncate=0.85, probs=0.6, package="evir", list=TRUE) )# NAs
str(  q_gpd(annMax, package="evir",      list=TRUE)   )
str(  q_gpd(annMax, package="evd",       list=TRUE)   )
str(  q_gpd(annMax, package="extRemes",  list=TRUE)   )
str(  q_gpd(annMax, package="fExtremes", list=TRUE)   )
str(  q_gpd(annMax, package="ismev",     list=TRUE)   )
str(  q_gpd(annMax, package="Renext",    list=TRUE)   )

q_gpd(annMax, package="evir", truncate=0.9, method="ml") # NAs (MLE fails often)

trunc &lt;- seq(0,0.9,len=500)
library("pbapply")
quant &lt;- pbsapply(trunc, function(tr) q_gpd(annMax, pack="evir", method = "pwm",
                                            truncate=tr, quiet=TRUE))
quant &lt;- pbsapply(trunc, function(tr) q_gpd(annMax, pack="lmomco", truncate=tr, quiet=TRUE))
plot(trunc, quant["99%",], type="l", ylim=c(80,130), las=1)
lines(trunc, quant["90%",])
lines(trunc, quant["80%",])
plot(trunc, quant["RMSE",], type="l", las=1)

## Not run: 
## Not run in checks because simulation takes too long

trunc &lt;- seq(0,0.9,len=200)
dlfs &lt;- pblapply(trunc, function(tr) distLfit(annMax, truncate=tr, quiet=TRUE, order=FALSE))
rmses &lt;- sapply(dlfs, function(x) x$gof$RMSE)
plot(trunc, trunc, type="n", ylim=range(rmses,na.rm=TRUE), las=1, ylab="rmse")
cols &lt;- rainbow2(17)[rank(rmses[,1])]
for(i in 1:17) lines(trunc, rmses[i,], col=cols[i])

dlfs2 &lt;- lapply(0:8/10, function(tr) distLfit(annMax, truncate=tr, quiet=TRUE))
pdf("dummy.pdf")
dummy &lt;- sapply(dlfs2, function(x)
{plotLfit(x, cdf=TRUE, main=x$truncate, ylim=0:1, xlim=c(20,135), nbest=1)
title(sub=round(x$gof$RMSE[1],4))
})
dev.off()

# truncation effect
mytruncs &lt;- seq(0, 0.9, len=150)
oo &lt;- options(show.error.messages=FALSE, warn=-1)
myquants &lt;- sapply(mytruncs, function(t) q_gpd(annMax, truncate=t, quiet=TRUE))
options(oo)
plot(1, type="n", ylim=range(myquants, na.rm=TRUE), xlim=c(0,0.9), las=1,
     xlab="truncated proportion", ylab="estimated quantiles")
abline(h=quantileMean(annMax, probs=c(0.8,0.9,0.99)))
for(i in 1:3) lines(mytruncs, myquants[i,], col=i)
text(0.3, c(87,97,116), rownames(myquants), col=1:3)


# Underestimation in small samples
# create known population:
dat &lt;- extRemes::revd(1e5, scale=50, shape=-0.02, threshold=30, type="GP")
op &lt;- par(mfrow=c(1,2), mar=c(2,2,1,1))
hist(dat, breaks=50, col="tan")
berryFunctions::logHist(dat, breaks=50, col="tan")
par(op)

# function to estimate empirical and GPD quantiles from subsamples
samsizeeffect &lt;- function(n, nrep=30, probs=0.999, trunc=0.5, Q=c(0.4,0.5,0.6))
{
res &lt;- replicate(nrep, {
subsample &lt;- sample(dat, n)
qGPD &lt;- q_gpd(subsample, probs=probs, truncate=trunc)
qEMP &lt;- berryFunctions::quantileMean(subsample, probs=probs, truncate=trunc)
c(qGPD=qGPD, qEMP=qEMP)})
apply(res, MARGIN=1, berryFunctions::quantileMean, probs=Q)
}

# Run and plot simulations
samplesize &lt;- c(seq(20, 150, 10), seq(200,800, 100))
results &lt;- pbapply::pblapply(samplesize, samsizeeffect)
res &lt;- function(row, col) sapply(results, function(x) x[row,col])
berryFunctions::ciBand(yu=res(3,1),yl=res(1,1),ym=res(2,1),x=samplesize,
  main="99.9% Quantile underestimation", xlab="subsample size", ylim=c(200,400), colm=4)
berryFunctions::ciBand(yu=res(3,2),yl=res(1,2),ym=res(2,2),x=samplesize, add=TRUE)
abline(h=berryFunctions::quantileMean(dat, probs=0.999))
text(300, 360, "empirical quantile of full sample")
text(300, 340, "GPD parametric estimate", col=4)
text(300, 300, "empirical quantile estimate", col="green3")


## End(Not run) # end of dontrun

</code></pre>

<hr>
<h2 id='q_weighted'>Compute weighted averages of quantile estimates</h2><span id='topic+q_weighted'></span>

<h3>Description</h3>

<p>Compute weighted averages of quantile estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_weighted(quant, weights = distLweights(quant, ...), onlyc = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q_weighted_+3A_quant">quant</code></td>
<td>
<p>Data.frame as in <code><a href="#topic+distLquantile">distLquantile</a></code> output.</p>
</td></tr>
<tr><td><code id="q_weighted_+3A_weights">weights</code></td>
<td>
<p>Data.frame as in <code><a href="#topic+distLweights">distLweights</a></code> output.</p>
</td></tr>
<tr><td><code id="q_weighted_+3A_onlyc">onlyc</code></td>
<td>
<p>Logical: only return custom weighted quantile estimates as
a vector? Useful to add those to existing results. See examples.
DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="q_weighted_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+distLweights">distLweights</a></code> like
weightc, onlydn=FALSE. order will be ignored, as
q_weighted only adds/changes the rows weighted*.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with rows &quot;weighted*&quot; added.
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Dec 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distLquantile">distLquantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(A=1:5, RMSE=runif(5))
distLweights(x, onlydn=FALSE)

q_weighted(x,  onlydn=FALSE)
q_weighted(x,  distLweights(x, weightc=c("1"=3, "3"=5), order=FALSE, onlydn=FALSE)  )

## Not run:  # time consuming
x &lt;- rexp(190)
d &lt;- distLquantile(x)
d2 &lt;- q_weighted(d)
stopifnot(all(d==d2, na.rm=TRUE))

# fast option for adding custom weighted estimates:
cw &lt;- runif(17)
names(cw) &lt;- c("exp", "gam", "gev", "glo", "gno", "gpa", "gum", "kap", "lap",
               "ln3", "nor", "pe3", "ray", "revgum", "rice", "wak", "wei")
dw &lt;- distLweights(d, weightc=cw)
qw1 &lt;- q_weighted(d, weightc=cw); qw1
qw2 &lt;- q_weighted(d, weights=dw); qw2
stopifnot(all(qw1==qw2, na.rm=TRUE))
q_weighted(d, weights=dw, onlyc=TRUE)
q_weighted(d, weights=data.frame(weightc=cw), onlyc=TRUE)

system.time(pbreplicate(5000, q_weighted(d, weightc=cw)))             # 8.5 secs
system.time(pbreplicate(5000, q_weighted(d, weights=dw, onlyc=TRUE))) # 0.8 secs

## End(Not run)

</code></pre>

<hr>
<h2 id='quantGPD'>Fast GPD quantile estimate</h2><span id='topic+quantGPD'></span>

<h3>Description</h3>

<p>Fast GPD quantile estimate through L-moments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantGPD(
  x,
  probs = c(0.8, 0.9, 0.99),
  truncate = 0,
  threshold = berryFunctions::quantileMean(x, truncate),
  addn = TRUE,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantGPD_+3A_x">x</code></td>
<td>
<p>Vector with numeric values. NAs are silently ignored.</p>
</td></tr>
<tr><td><code id="quantGPD_+3A_probs">probs</code></td>
<td>
<p>Probabilities. DEFAULT: c(0.8,0.9,0.99)</p>
</td></tr>
<tr><td><code id="quantGPD_+3A_truncate">truncate</code>, <code id="quantGPD_+3A_threshold">threshold</code></td>
<td>
<p>Truncation proportion or threshold. DEFAULT: 0, computed
See <code><a href="#topic+q_gpd">q_gpd</a></code>.</p>
</td></tr>
<tr><td><code id="quantGPD_+3A_addn">addn</code></td>
<td>
<p>Logical: add element with sample size (after truncation). DEFAULT: TRUE</p>
</td></tr>
<tr><td><code id="quantGPD_+3A_quiet">quiet</code></td>
<td>
<p>Should messages from this function be suppressed? DEFAULT: FALSE</p>
</td></tr>
<tr><td><code id="quantGPD_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>lmomco::<a href="lmomco.html#topic+pargpa">pargpa</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with quantiles
</p>


<h3>Author(s)</h3>

<p>Berry Boessenkool, <a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>, Jun 2017
</p>


<h3>See Also</h3>

<p><code><a href="#topic+q_gpd">q_gpd</a></code> for a comparison across R packages and methods, <code><a href="#topic+distLquantile">distLquantile</a></code> to compare distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(annMax)
quantile(annMax, 0.99)
quantGPD(annMax, 0.99)

## Not run:  # Excluded from CRAN checks to reduce checking time
data(rain, package="ismev") ;  rain &lt;- rain[rain&gt;0]
hist(rain, breaks=50, col=7)
tr &lt;- seq(0,0.999, len=50)
qu &lt;- pbapply::pbsapply(tr, quantGPD, x=rain, probs=c(0.9,0.99,0.999) ) # 30 s
plot(tr, qu[3,], ylim=range(rain), las=1, type="l")
lines(tr, qu[2,], col=2); lines(tr, qu[1,], col=4)

tr &lt;- seq(0.88,0.999, len=50)
qu &lt;- pbapply::pbsapply(tr, quantGPD, x=rain, probs=c(0.9,0.99,0.999) ) # 5 s
plot(tr, qu[3,], ylim=range(rain), las=1, type="l")
lines(tr, qu[2,], col=2); lines(tr, qu[1,], col=4);
tail(qu["n",])

library(microbenchmark)
data(rain, package="ismev"); rain &lt;- rain[rain&gt;0]
mb &lt;- microbenchmark(quantGPD(rain[1:200], truncate=0.8, probs=0.99, addn=F),
distLquantile(rain[1:200], sel="gpa", emp=F, truncate=0.8, quiet=T, probs=0.99)[1,1]
)
boxplot(mb)
# since computing the lmoments takes most of the computational time,
# there's not much to optimize in large samples like n=2000


## End(Not run)

</code></pre>

<hr>
<h2 id='weightp'>distribution weights</h2><span id='topic+weightp'></span>

<h3>Description</h3>

<p>Weights for weighted average as in the submission of revisions for the paper
<a href="https://nhess.copernicus.org/articles/17/1623/2017/nhess-17-1623-2017-discussion.html">https://nhess.copernicus.org/articles/17/1623/2017/nhess-17-1623-2017-discussion.html</a>
</p>


<h3>Format</h3>

<p>named num [1:17]
</p>


<h3>Source</h3>

<p>See paper revisions (not yet online at moment of extremeStat update) (<a href="mailto:berry-b@gmx.de">berry-b@gmx.de</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(weightp)
data.frame(weightp)
barplot(weightp, horiz=TRUE, las=1)
stopifnot(   all.equal(sum(weightp), 1)   )

data(annMax) ; data(weightp)
dlf &lt;- distLfit(annMax, weightc=weightp)
dlf$gof
quant &lt;- distLquantile(annMax, weightc=weightp)
quant

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
