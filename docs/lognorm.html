<!DOCTYPE html><html lang="en"><head><title>Help for package lognorm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lognorm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lognorm-package'><p>lognorm: Functions for the Lognormal Distribution</p></a></li>
<li><a href='#.trimNA'><p>remove NA values at the start and end</p></a></li>
<li><a href='#computeEffectiveAutoCorr'><p>Estimate vector of effective components of the autocorrelation</p></a></li>
<li><a href='#computeEffectiveNumObs'><p>Compute the effective number of observations taking into account autocorrelation</p></a></li>
<li><a href='#estimateDiffLognormal'><p>Inference on the difference of two lognormals</p></a></li>
<li><a href='#estimateParmsLognormFromSample'><p>Estimate lognormal distribution parameters from a sample</p></a></li>
<li><a href='#estimateSumLognormalSample'><p>Estimate the parameters of the lognormal approximation to the sum</p></a></li>
<li><a href='#getCorrMatFromAcf'><p>Construct the full correlation matrix from autocorrelation components.</p></a></li>
<li><a href='#getLognormMoments'><p>Compute summary statistics of a log-normal distribution</p></a></li>
<li><a href='#getParmsLognormForMedianAndUpper'><p>Calculate mu and sigma of lognormal from summary statistics.</p></a></li>
<li><a href='#scaleLogToOrig'><p>Scale standard deviation between log and original scale.</p></a></li>
<li><a href='#seCor'><p>Compute the standard error accounting for empirical autocorrelations</p></a></li>
<li><a href='#setMatrixOffDiagonals'><p>set off-diagonal values of a matrix</p></a></li>
<li><a href='#varCor'><p>Compute the unbiased variance accounting for empirical autocorrelations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Functions for the Lognormal Distribution</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.10</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Wutzler</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Wutzler &lt;twutz@bgc-jena.mpg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The lognormal distribution  
  (Limpert et al. (2001) &lt;<a href="https://doi.org/10.1641/0006-3568(2001)051%5B0341:lndats%5D2.0.co;2">doi:10.1641/0006-3568(2001)051%5B0341:lndats%5D2.0.co;2</a>&gt;)
  can characterize uncertainty that is bounded by zero.
  This package provides estimation of distribution parameters, computation of
  moments and other basic statistics, and an approximation of the distribution
  of the sum of several correlated lognormally distributed variables 
  (Lo 2013 &lt;<a href="https://doi.org/10.12988%2Fams.2013.39511">doi:10.12988/ams.2013.39511</a>&gt;) and the approximation of the 
  difference of two correlated lognormally distributed variables
  (Lo 2012 &lt;<a href="https://doi.org/10.1155%2F2012%2F838397">doi:10.1155/2012/838397</a>&gt;).</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>markdown, rmarkdown, testthat, knitr, dplyr, ggplot2,
mvtnorm, purrr, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bgctw/lognorm">https://github.com/bgctw/lognorm</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-21 17:28:10 UTC; twutz</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-21 17:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='lognorm-package'>lognorm: Functions for the Lognormal Distribution</h2><span id='topic+lognorm'></span><span id='topic+lognorm-package'></span>

<h3>Description</h3>

<p>The lognormal distribution  
(Limpert et al. (2001) &lt;doi:10.1641/0006-3568(2001)051
can characterize uncertainty that is bounded by zero.
This package provides estimation of distribution parameters, computation of
moments and other basic statistics, and an approximation of the distribution
of the sum of several correlated lognormally distributed variables 
(Lo 2013 &lt;doi:10.12988/ams.2013.39511&gt;) and the approximation of the 
difference of two correlated lognormally distributed variables
(Lo 2012 &lt;doi:10.1155/2012/838397&gt;).
</p>


<h3>Details</h3>

<p>Essential functions are 
</p>

<ul>
<li><p> Compute summary statistics: 
<code><a href="#topic+getLognormMoments">getLognormMoments</a></code>
</p>
</li>
<li><p> computing distribution parameters from summary statistics: 
<code><a href="#topic+getParmsLognormForModeAndUpper">getParmsLognormForModeAndUpper</a></code>
</p>
</li>
<li><p> estimate distribution parameters from summary sample: 
<code><a href="#topic+estimateParmsLognormFromSample">estimateParmsLognormFromSample</a></code>
</p>
</li>
<li><p> Approximate the sum of correlated lognormals: 
<code><a href="#topic+estimateSumLognormalSample">estimateSumLognormalSample</a></code>
</p>
</li>
<li><p> Approximate the difference of two correlated lognormals: 
<code><a href="#topic+estimateDiffLognormal">estimateDiffLognormal</a></code>
</p>
</li></ul>

<p>Utilities for correlated data. These functions maybe moved to
a separate package in future.
</p>

<ul>
<li><p> Estimate summary statistics of autocorrelated data
</p>

<ul>
<li><p> standard error of the mean: <code><a href="#topic+seCor">seCor</a></code> 
</p>
</li>
<li><p> effective number of observations <code><a href="#topic+computeEffectiveNumObs">computeEffectiveNumObs</a></code> 
</p>
</li>
<li><p> variance: <code><a href="#topic+varCor">varCor</a></code> 
</p>
</li></ul>

</li>
<li><p> Return the vector of effective components of the autocorrelation: 
<code><a href="#topic+computeEffectiveAutoCorr">computeEffectiveAutoCorr</a></code> 
</p>
</li></ul>

<p>Otherwise refer to the vignettes
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bgctw/lognorm">https://github.com/bgctw/lognorm</a>
</p>
</li></ul>


<hr>
<h2 id='.trimNA'>remove NA values at the start and end</h2><span id='topic+.trimNA'></span>

<h3>Description</h3>

<p>remove NA values at the start and end
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.trimNA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".trimNA_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subset of x with leading and trailing NAs removed
</p>

<hr>
<h2 id='computeEffectiveAutoCorr'>Estimate vector of effective components of the autocorrelation</h2><span id='topic+computeEffectiveAutoCorr'></span>

<h3>Description</h3>

<p>Estimate vector of effective components of the autocorrelation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeEffectiveAutoCorr(res, type = "correlation")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeEffectiveAutoCorr_+3A_res">res</code></td>
<td>
<p>numeric of autocorrelated numbers, usually observation - 
model residuals</p>
</td></tr>
<tr><td><code id="computeEffectiveAutoCorr_+3A_type">type</code></td>
<td>
<p>type of residuals (see <code><a href="stats.html#topic+acf">acf</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns all components before first negative autocorrelation
</p>


<h3>Value</h3>

<p>numeric vector: strongest components of the autocorrelation function
</p>


<h3>References</h3>

<p><code>Zieba 2011 Standard Deviation of the Mean of Autocorrelated
 Observations Estimated with the Use of the Autocorrelation Function Estimated
 From the Data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate autocorrelated time series
res &lt;- stats::filter(rnorm(1000), filter = rep(1,5), circular = TRUE)
res[100:120] &lt;- NA
(effAcf &lt;- computeEffectiveAutoCorr(res))
</code></pre>

<hr>
<h2 id='computeEffectiveNumObs'>Compute the effective number of observations taking into account autocorrelation</h2><span id='topic+computeEffectiveNumObs'></span>

<h3>Description</h3>

<p>Compute the effective number of observations taking into account autocorrelation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeEffectiveNumObs(
  res,
  effAcf = computeEffectiveAutoCorr(res),
  na.rm = FALSE,
  exact.na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeEffectiveNumObs_+3A_res">res</code></td>
<td>
<p>numeric of autocorrelated numbers, usually observation -
model residuals</p>
</td></tr>
<tr><td><code id="computeEffectiveNumObs_+3A_effacf">effAcf</code></td>
<td>
<p>autocorrelation coefficients.
The first entry is fixed at 1 for zero distance.</p>
</td></tr>
<tr><td><code id="computeEffectiveNumObs_+3A_na.rm">na.rm</code></td>
<td>
<p>if not set to TRUE will return NA in there are missings
in the series</p>
</td></tr>
<tr><td><code id="computeEffectiveNumObs_+3A_exact.na">exact.na</code></td>
<td>
<p>if set to FALSE then do not count and correct for missing
in the sum of autocorrelation terms. This is faster, but results are
increasingly biased high with increasing number of missings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes records of all times present. 
DO NOT REMOVE OR FILTER NA records before. 
The length of the time series is used.
</p>
<p>Handling of NA values: The formula from Zieba 2011 is extended
to subtract the number of missing pairs in the count of correlation terms.
If 'exact.na=false' the original formula is used (after trimming edge-NAs).
</p>


<h3>Value</h3>

<p>integer scalar: effective number of observations
</p>


<h3>References</h3>

<p><code>Zieba &amp; Ramza (2011) 
Standard Deviation of the Mean of Autocorrelated 
Observations Estimated with the Use of the Autocorrelation Function 
Estimated From the Data. 
Metrology and Measurement Systems, 
Walter de Gruyter GmbH, 18 10.2478/v10178-011-0052-x</code>
</p>
<p><code>Bayley &amp; Hammersley (1946) 
The "effective" number of independent observations in an autocorrelated 
time series. 
Supplement to the Journal of the Royal Statistical Society, JSTOR,8,184-197</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate autocorrelated time series
res &lt;- stats::filter(rnorm(1000), filter = rep(1,5), circular = TRUE)
res[100:120] &lt;- NA
# plot the series of autocorrelated random variables
plot(res)
# plot their empirical autocorrelation function
acf(res, na.action = na.pass)
#effAcf &lt;- computeEffectiveAutoCorr(res)
# the effective number of parameters is less than number of 1000 samples
(nEff &lt;- computeEffectiveNumObs(res, na.rm = TRUE))
</code></pre>

<hr>
<h2 id='estimateDiffLognormal'>Inference on the difference of two lognormals</h2><span id='topic+estimateDiffLognormal'></span><span id='topic+pDiffLognormalSample'></span>

<h3>Description</h3>

<p>The distribution of y = a - b + s, where a and b are two lognormal random
variables and s is a constant to be estimated, can be approximated
by a lognormal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateDiffLognormal(mu_a, mu_b, sigma_a, sigma_b, corr = 0)

pDiffLognormalSample(
  mu_a,
  mu_b,
  sigma_a,
  sigma_b,
  corr = 0,
  q = 0,
  nSample = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateDiffLognormal_+3A_mu_a">mu_a</code></td>
<td>
<p>center parameter of the first term</p>
</td></tr>
<tr><td><code id="estimateDiffLognormal_+3A_mu_b">mu_b</code></td>
<td>
<p>center parameter of the second term</p>
</td></tr>
<tr><td><code id="estimateDiffLognormal_+3A_sigma_a">sigma_a</code></td>
<td>
<p>scale parameter of the first term</p>
</td></tr>
<tr><td><code id="estimateDiffLognormal_+3A_sigma_b">sigma_b</code></td>
<td>
<p>scale parameter of the second term</p>
</td></tr>
<tr><td><code id="estimateDiffLognormal_+3A_corr">corr</code></td>
<td>
<p>correlation between the two random variables</p>
</td></tr>
<tr><td><code id="estimateDiffLognormal_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="estimateDiffLognormal_+3A_nsample">nSample</code></td>
<td>
<p>number of samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimateDiffLognormal: numeric vector with components mu, sigma, and shift, the components
of the shifted lognormal distribution.
</p>
<p>pDiffLognormalSample: vector of probabilities
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>estimateDiffLognormal</code>: Estimate the shifted-lognormal approximation to difference of two lognormals
</p>
</li>
<li> <p><code>pDiffLognormalSample</code>: Distribution function for the difference of two lognormals based on sampling.
Default provides the probability that the difference is significantly larger 
than zero.
</p>
</li></ul>

<hr>
<h2 id='estimateParmsLognormFromSample'>Estimate lognormal distribution parameters from a sample</h2><span id='topic+estimateParmsLognormFromSample'></span><span id='topic+estimateStdErrParms'></span>

<h3>Description</h3>

<p>Estimate lognormal distribution parameters from a sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateParmsLognormFromSample(x, na.rm = FALSE)

estimateStdErrParms(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateParmsLognormFromSample_+3A_x">x</code></td>
<td>
<p>numeric vector of sampled values</p>
</td></tr>
<tr><td><code id="estimateParmsLognormFromSample_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether 
NA values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected value of a can be determined with
higher accuracy the larger the sample. Here, the uncorrelated
assumption is applied at the log scale and distribution parameters
are returned with the same expected value as the sample, but with
uncertainty (sigma) decreased by sqrt(nfin - 1). 
</p>
<p>Since with low relative error, the lognormal becomes very close
to the normal distribution, the distribution of the mean can be
well approximated by a normal with sd(mean(x)) ~ sd(x)/sqrt(n-1).
</p>


<h3>Value</h3>

<p>numeric vector with components <code>mu</code> and <code>sigma</code>,
i.e., the center parameter (mean at log scale, log(median)) and 
the scale parameter (standard deviation at log scale)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>estimateParmsLognormFromSample</code>: Estimate lognormal distribution parameters from a sample
</p>
</li>
<li> <p><code>estimateStdErrParms</code>: Estimate parameters of the lognormal distribution of the mean from an uncorrelated sample
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>.mu &lt;- log(1)
.sigma &lt;- log(2)
n = 200
x &lt;- exp(rnorm(n, mean = .mu, sd = .sigma))
exp(pL &lt;- estimateParmsLognormFromSample(x)) # median and multiplicative stddev
c(mean(x), meanx &lt;- getLognormMoments(pL["mu"],pL["sigma"])[,"mean"])
c(sd(x), sdx &lt;- sqrt(getLognormMoments(pL["mu"],pL["sigma"])[,"var"]))

# stddev decreases (each sample about 0.9) to about 0.07
# for the mean with n replicated samples
se &lt;- estimateStdErrParms(x)
sqrt(getLognormMoments(se["mu"],se["sigma"])[,"var"])
sd(x)/sqrt(n-1) # well approximated by normal
# expected value stays the same
c(meanx, getLognormMoments(se["mu"],se["sigma"])[,"mean"])
</code></pre>

<hr>
<h2 id='estimateSumLognormalSample'>Estimate the parameters of the lognormal approximation to the sum</h2><span id='topic+estimateSumLognormalSample'></span><span id='topic+estimateSumLognormalSampleExpScale'></span><span id='topic+estimateSumLognormal'></span>

<h3>Description</h3>

<p>Estimate the parameters of the lognormal approximation to the sum
</p>
<p>Estimate the parameters of the lognormal approximation to the sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateSumLognormalSample(
  mu,
  sigma,
  resLog,
  effAcf = computeEffectiveAutoCorr(resLog),
  isGapFilled = logical(0),
  na.rm = TRUE
)

estimateSumLognormalSampleExpScale(mean, sigmaOrig, ...)

estimateSumLognormal(
  mu,
  sigma,
  effAcf = c(),
  corr = Diagonal(length(mu)),
  corrLength = if (inherits(corr, "ddiMatrix")) 0 else nTerm,
  sigmaSum = numeric(0),
  isStopOnNoTerm = FALSE,
  na.rm = isStopOnNoTerm
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateSumLognormalSample_+3A_mu">mu</code></td>
<td>
<p>numeric vector of center parameters of terms at log scale</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector of scale parameter of terms at log scale</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_reslog">resLog</code></td>
<td>
<p>time series of model-residuals at log scale 
to estimate correlation</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_effacf">effAcf</code></td>
<td>
<p>numeric vector of effective autocorrelation
This overrides arguments <code>corr</code> and <code>corrLength</code></p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_isgapfilled">isGapFilled</code></td>
<td>
<p>logical vector whether entry is gap-filled 
rather than an original measurement, see details</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_na.rm">na.rm</code></td>
<td>
<p>neglect terms with NA values in mu or sigma</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_mean">mean</code></td>
<td>
<p>numeric vector of expected values</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_sigmaorig">sigmaOrig</code></td>
<td>
<p>numeric vector of standard deviation at original scale</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>estimateSumLognormalSample</code></p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_corr">corr</code></td>
<td>
<p>numeric matrix of correlations between the random variables</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_corrlength">corrLength</code></td>
<td>
<p>integer 
scalar: set correlation length to smaller values
to speed up computation by neglecting correlations among terms
further apart.
Set to zero to omit correlations.</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_sigmasum">sigmaSum</code></td>
<td>
<p>numeric scalar: possibility to specify
a precomputed scale parameter instead of computing it.</p>
</td></tr>
<tr><td><code id="estimateSumLognormalSample_+3A_isstoponnoterm">isStopOnNoTerm</code></td>
<td>
<p>if no finite estimate is provided then by
default NA is returned for the sum.
Set this to TRUE to issue an error instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are no gap-filled values, i.e. <code>all(!isGapFilled)</code> or
<code>!length(isGapFilled)</code> (the default), distribution parameters
are estimated using all the samples. Otherwise, the scale parameter
(uncertainty) is first estimated using only the non-gapfilled records.
</p>
<p>Also use isGapFilled == TRUE for records, where sigma cannot be trusted. 
When setting sigma to missing, this is also affecting the expected value.
</p>
<p>If there are only gap-filled records, 
assume uncertainty to be 
(before v0.1.5: the largest uncertainty of given gap-filled records.)
the mean of the given multiplicative standard deviation
</p>


<h3>Value</h3>

<p>numeric vector with components <code>mu</code>, <code>sigma</code>, 
and <code>nEff</code>,
i.e. the parameters of the lognormal distribution at log scale
and the number of effective observations.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>estimateSumLognormalSample</code>: In addition to <code>estimateSumLognormal</code> take care of missing values
and estimate correlation terms.
</p>
</li>
<li> <p><code>estimateSumLognormalSampleExpScale</code>: Before calling <code>estimateSumLognormalSample</code> estimate
lognormal parameters from value and its uncertainty given
on original scale.
</p>
</li>
<li> <p><code>estimateSumLognormal</code>: Estimate the parameters of the lognormal approximation to the sum
</p>
</li></ul>


<h3>References</h3>

<p><code>Lo C (2013) WKB approximation for the sum of two 
correlated lognormal random variables.
Applied Mathematical Sciences, Hikari, Ltd., 7 , 6355-6367 
10.12988/ams.2013.39511</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # distribution of the sum of two lognormally distributed random variables
  mu1 = log(110)
  mu2 = log(100)
  sigma1 = log(1.2)
  sigma2 = log(1.6)
  (coefSum &lt;- estimateSumLognormal( 
  c(mu1,mu2), c(sigma1,sigma2) ))
  # repeat with correlation
  (coefSumCor &lt;- estimateSumLognormal( 
  c(mu1,mu2), c(sigma1,sigma2), effAcf = c(1,0.9) ))
  # expected value is equal, but variance with correlated variables is larger
  getLognormMoments(coefSum["mu"],coefSum["sigma"])
  getLognormMoments(coefSumCor["mu"],coefSumCor["sigma"])
</code></pre>

<hr>
<h2 id='getCorrMatFromAcf'>Construct the full correlation matrix from autocorrelation components.</h2><span id='topic+getCorrMatFromAcf'></span>

<h3>Description</h3>

<p>Construct the full correlation matrix from autocorrelation components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCorrMatFromAcf(nRow, effAcf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCorrMatFromAcf_+3A_nrow">nRow</code></td>
<td>
<p>number of rows in correlation matrix</p>
</td></tr>
<tr><td><code id="getCorrMatFromAcf_+3A_effacf">effAcf</code></td>
<td>
<p>numeric vector of effective autocorrelation components
. The first entry, which is defined as 1, is not used.</p>
</td></tr>
</table>

<hr>
<h2 id='getLognormMoments'>Compute summary statistics of a log-normal distribution</h2><span id='topic+getLognormMoments'></span><span id='topic+getLognormMedian'></span><span id='topic+getLognormMode'></span>

<h3>Description</h3>

<p>Compute summary statistics of a log-normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLognormMoments(mu, sigma, m = exp(mu + sigma2/2) - shift, shift = 0)

getLognormMedian(mu, sigma, shift = 0)

getLognormMode(mu, sigma, shift = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLognormMoments_+3A_mu">mu</code></td>
<td>
<p>numeric vector: location parameter</p>
</td></tr>
<tr><td><code id="getLognormMoments_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector: scale parameter</p>
</td></tr>
<tr><td><code id="getLognormMoments_+3A_m">m</code></td>
<td>
<p>mean at original scale, may override default based on mu</p>
</td></tr>
<tr><td><code id="getLognormMoments_+3A_shift">shift</code></td>
<td>
<p>shift for the shifted lognormal distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>getLognormMoments</code> a numeric matrix with columns
<code>mean</code> (expected value at original scale)
, <code>var</code> (variance at original scale)
, and <code>cv</code> (coefficient of variation: sqrt(var)/mean).
For the other functions a numeric vector of the required summary.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getLognormMoments</code>: get the expected value, variance, and coefficient of variation
</p>
</li>
<li> <p><code>getLognormMedian</code>: get the median
</p>
</li>
<li> <p><code>getLognormMode</code>: get the mode
</p>
</li></ul>


<h3>References</h3>

<p><code>Limpert E, Stahel W &amp; Abbt M (2001)
Log-normal Distributions across the Sciences: Keys and Clues.
Oxford University Press (OUP) 51, 341,
10.1641/0006-3568(2001)051[0341:lndats]2.0.co;2</code>
</p>


<h3>See Also</h3>

<p>scaleLogToOrig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # start by estimating lognormal parameters from moments
  .mean &lt;- 1
  .var &lt;- c(1.3,2)^2
  parms &lt;- getParmsLognormForMoments(.mean, .var)
  #
  # computed moments must equal previous ones
  (ans &lt;- getLognormMoments(parms[,"mu"], parms[,"sigma"]))
  cbind(.var, ans[,"var"])
  #
  getLognormMedian(mu = log(1), sigma = log(2))
  getLognormMode(mu = log(1), sigma = c(log(1.2),log(2)))

</code></pre>

<hr>
<h2 id='getParmsLognormForMedianAndUpper'>Calculate mu and sigma of lognormal from summary statistics.</h2><span id='topic+getParmsLognormForMedianAndUpper'></span><span id='topic+getParmsLognormForMeanAndUpper'></span><span id='topic+getParmsLognormForLowerAndUpper'></span><span id='topic+getParmsLognormForLowerAndUpperLog'></span><span id='topic+getParmsLognormForModeAndUpper'></span><span id='topic+getParmsLognormForMoments'></span><span id='topic+getParmsLognormForExpval'></span>

<h3>Description</h3>

<p>Calculate mu and sigma of lognormal from summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParmsLognormForMedianAndUpper(median, upper, sigmaFac = qnorm(0.99))

getParmsLognormForMeanAndUpper(mean, upper, sigmaFac = qnorm(0.99))

getParmsLognormForLowerAndUpper(lower, upper, sigmaFac = qnorm(0.99))

getParmsLognormForLowerAndUpperLog(lowerLog, upperLog, sigmaFac = qnorm(0.99))

getParmsLognormForModeAndUpper(mle, upper, sigmaFac = qnorm(0.99))

getParmsLognormForMoments(mean, var, sigmaOrig = sqrt(var))

getParmsLognormForExpval(mean, sigmaStar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_median">median</code></td>
<td>
<p>geometric mu (median at the original exponential scale)</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_upper">upper</code></td>
<td>
<p>numeric vector: value at the upper quantile,
i.e. practical maximum</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_sigmafac">sigmaFac</code></td>
<td>
<p>sigmaFac=2 is 95% sigmaFac=2.6 is 99% interval.</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_mean">mean</code></td>
<td>
<p>expected value at original scale</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_lower">lower</code></td>
<td>
<p>value at the lower quantile, i.e. practical minimum</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_lowerlog">lowerLog</code></td>
<td>
<p>value at the lower quantile, i.e. practical minimum at log scale</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_upperlog">upperLog</code></td>
<td>
<p>value at the upper quantile, i.e. practical maximum at log scale</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_mle">mle</code></td>
<td>
<p>numeric vector: mode at the original scale</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_var">var</code></td>
<td>
<p>variance at original scale</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_sigmaorig">sigmaOrig</code></td>
<td>
<p>standard deviation at original scale</p>
</td></tr>
<tr><td><code id="getParmsLognormForMedianAndUpper_+3A_sigmastar">sigmaStar</code></td>
<td>
<p>multiplicative standard deviation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>getParmsLognormForMeanAndUpper</code>
there are two valid solutions, and the one with lower sigma
, i.e. the not so strongly skewed solution is returned.
</p>


<h3>Value</h3>

<p>numeric matrix with columns 'mu' and 'sigma', the parameter of the
lognormal distribution. Rows correspond to rows of inputs.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getParmsLognormForMedianAndUpper</code>: Calculates mu and sigma of lognormal from median and upper quantile.
</p>
</li>
<li> <p><code>getParmsLognormForMeanAndUpper</code>: Calculates mu and sigma of lognormal from mean and upper quantile.
</p>
</li>
<li> <p><code>getParmsLognormForLowerAndUpper</code>: Calculates mu and sigma of lognormal from lower and upper quantile.
</p>
</li>
<li> <p><code>getParmsLognormForLowerAndUpperLog</code>: Calculates mu and sigma of lognormal from lower and upper quantile at log scale.
</p>
</li>
<li> <p><code>getParmsLognormForModeAndUpper</code>: Calculates mu and sigma of lognormal from mode and upper quantile.
</p>
</li>
<li> <p><code>getParmsLognormForMoments</code>: Calculate mu and sigma from moments (mean anc variance)
</p>
</li>
<li> <p><code>getParmsLognormForExpval</code>: Calculate mu and sigma from expected value and geometric standard deviation
</p>
</li></ul>


<h3>References</h3>

<p><code>Limpert E, Stahel W &amp; Abbt M (2001)
Log-normal Distributions across the Sciences: Keys and Clues.
Oxford University Press (OUP) 51, 341,
10.1641/0006-3568(2001)051[0341:lndats]2.0.co;2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example 1: a distribution with mode 1 and upper bound 5
(thetaEst &lt;- getParmsLognormForModeAndUpper(1,5))
mle &lt;- exp(thetaEst[1] - thetaEst[2]^2)
all.equal(mle, 1, check.attributes = FALSE)

# plot the distributions
xGrid = seq(0,8, length.out = 81)[-1]
dxEst &lt;- dlnorm(xGrid, meanlog = thetaEst[1], sdlog = thetaEst[2])
plot( dxEst~xGrid, type = "l",xlab = "x",ylab = "density")
abline(v = c(1,5),col = "gray")

# example 2: true parameters, which should be rediscovered
theta0 &lt;- c(mu = 1, sigma = 0.4)
mle &lt;- exp(theta0[1] - theta0[2]^2)
perc &lt;- 0.975		# some upper percentile, proxy for an upper bound
upper &lt;- qlnorm(perc, meanlog = theta0[1], sdlog = theta0[2])
(thetaEst &lt;- getParmsLognormForModeAndUpper(
  mle,upper = upper,sigmaFac = qnorm(perc)) )

#plot the true and the rediscovered distributions
xGrid = seq(0,10, length.out = 81)[-1]
dx &lt;- dlnorm(xGrid, meanlog = theta0[1], sdlog = theta0[2])
dxEst &lt;- dlnorm(xGrid, meanlog = thetaEst[1], sdlog = thetaEst[2])
plot( dx~xGrid, type = "l")
#plot( dx~xGrid, type = "n")
#overplots the original, coincide
lines( dxEst ~ xGrid, col = "red", lty = "dashed")

# example 3: explore varying the uncertainty (the upper quantile)
x &lt;- seq(0.01,1.2,by = 0.01)
mle = 0.2
dx &lt;- sapply(mle*2:8,function(q99){
  theta = getParmsLognormForModeAndUpper(mle,q99,qnorm(0.99))
  #dx &lt;- dDistr(x,theta[,"mu"],theta[,"sigma"],trans = "lognorm")
  dx &lt;- dlnorm(x,theta[,"mu"],theta[,"sigma"])
})
  matplot(x,dx,type = "l")
# Calculate mu and sigma from expected value and geometric standard deviation
.mean &lt;- 1
.sigmaStar &lt;- c(1.3,2)
(parms &lt;- getParmsLognormForExpval(.mean, .sigmaStar))
# multiplicative standard deviation must equal the specified value
cbind(exp(parms[,"sigma"]), .sigmaStar)

</code></pre>

<hr>
<h2 id='scaleLogToOrig'>Scale standard deviation between log and original scale.</h2><span id='topic+scaleLogToOrig'></span><span id='topic+scaleOrigToLog'></span>

<h3>Description</h3>

<p>When comparing values at log scale that have different sd at original scale, 
better compare log(mean) instead of mu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleLogToOrig(logmean, sigma)

scaleOrigToLog(mean, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaleLogToOrig_+3A_logmean">logmean</code></td>
<td>
<p>log of the expected value</p>
</td></tr>
<tr><td><code id="scaleLogToOrig_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation at log scale</p>
</td></tr>
<tr><td><code id="scaleLogToOrig_+3A_mean">mean</code></td>
<td>
<p>expected value at original scale</p>
</td></tr>
<tr><td><code id="scaleLogToOrig_+3A_sd">sd</code></td>
<td>
<p>standard deviation at original scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix with columns <code>mean</code>, and <code>sd</code> at original scale
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>scaleLogToOrig</code>: get logmean and sigma at log scale
</p>
</li>
<li> <p><code>scaleOrigToLog</code>: get mean and sd at original scale
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>  xLog &lt;- data.frame(logmean = c(0.8, 0.8), sigma = c(0.2, 0.3))
  xOrig &lt;- as.data.frame(scaleLogToOrig(xLog$logmean, xLog$sigma))
  xLog2 &lt;- as.data.frame(scaleOrigToLog(xOrig$mean, xOrig$sd))
  all.equal(xLog, xLog2)
  xLog3 &lt;- as.data.frame(getParmsLognormForMoments(xOrig$mean, xOrig$sd^2))
  all.equal(xLog$sigma, xLog3$sigma) # but mu  &lt; logmean 
</code></pre>

<hr>
<h2 id='seCor'>Compute the standard error accounting for empirical autocorrelations</h2><span id='topic+seCor'></span>

<h3>Description</h3>

<p>Compute the standard error accounting for empirical autocorrelations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seCor(
  x,
  effCor = if (missing(effCov)) computeEffectiveAutoCorr(x) else effCov/var(x, na.rm =
    TRUE),
  na.rm = FALSE,
  effCov,
  nEff = computeEffectiveNumObs(x, effCor, na.rm = na.rm)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seCor_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="seCor_+3A_effcor">effCor</code></td>
<td>
<p>numeric vector of effective correlation components
first entry at zero lag equals one. See <code><a href="#topic+computeEffectiveAutoCorr">computeEffectiveAutoCorr</a></code></p>
</td></tr>
<tr><td><code id="seCor_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="seCor_+3A_effcov">effCov</code></td>
<td>
<p>alternative to specifying effCor: numeric vector of 
effective covariance components
first entry is the variance. See <code><a href="#topic+computeEffectiveAutoCorr">computeEffectiveAutoCorr</a></code></p>
</td></tr>
<tr><td><code id="seCor_+3A_neff">nEff</code></td>
<td>
<p>possibility to specify precomputed number of effective 
observations for speedup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default uses empirical autocorrelation
estimates from the supplied data up to first negative component.
For short series of <code>x</code> it is strongly recommended to to
provide <code>effCov</code> that was estimated on a longer time series.
</p>


<h3>Value</h3>

<p>numeric scalar of standard error of the mean of x
</p>

<hr>
<h2 id='setMatrixOffDiagonals'>set off-diagonal values of a matrix</h2><span id='topic+setMatrixOffDiagonals'></span>

<h3>Description</h3>

<p>set off-diagonal values of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMatrixOffDiagonals(x, diag = 1:length(value), value, isSymmetric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setMatrixOffDiagonals_+3A_x">x</code></td>
<td>
<p>numeric square matrix</p>
</td></tr>
<tr><td><code id="setMatrixOffDiagonals_+3A_diag">diag</code></td>
<td>
<p>integer vector specifying the diagonals
0 is the center +1 the first row to upper and -2 the second row to lower</p>
</td></tr>
<tr><td><code id="setMatrixOffDiagonals_+3A_value">value</code></td>
<td>
<p>numeric vector of values to fill in</p>
</td></tr>
<tr><td><code id="setMatrixOffDiagonals_+3A_issymmetric">isSymmetric</code></td>
<td>
<p>set to TRUE to to only
specify the upper diagonal element but also
set the lower in the mirrored diagonal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with modified diagonal elements
</p>

<hr>
<h2 id='varCor'>Compute the unbiased variance accounting for empirical autocorrelations</h2><span id='topic+varCor'></span>

<h3>Description</h3>

<p>Compute the unbiased variance accounting for empirical autocorrelations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varCor(
  x,
  effCor = computeEffectiveAutoCorr(x),
  na.rm = FALSE,
  nEff = computeEffectiveNumObs(x, effAcf = effCor)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varCor_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="varCor_+3A_effcor">effCor</code></td>
<td>
<p>numeric vector of effective correlation components
first entry at zero lag equals one. See <code><a href="#topic+computeEffectiveAutoCorr">computeEffectiveAutoCorr</a></code>
The effective correlation is passed to <code><a href="#topic+computeEffectiveNumObs">computeEffectiveNumObs</a></code>.</p>
</td></tr>
<tr><td><code id="varCor_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="varCor_+3A_neff">nEff</code></td>
<td>
<p>possibility to specify precomputed number of effective 
observations for speedup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default uses empirical autocorrelation
estimates from the supplied data up to first negative component.
For short series of <code>x</code> it is strongly recommended to to
provide <code>effCov</code> that was estimated on a longer time series.
</p>


<h3>Value</h3>

<p>numeric scalar of unbiased variation of x
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
