<!DOCTYPE html><html><head><title>Help for package DALSM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DALSM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#centeredBasis.gen'><p>Generation of a recentered cubic B-spline basis matrix in additive models</p></a></li>
<li><a href='#DALSM'><p>Fit a double additive location-scale model (DALSM) with a flexible error distribution</p></a></li>
<li><a href='#DALSM_additive'><p>Extraction of the estimated additive terms in a <code>DALSM.object</code></p></a></li>
<li><a href='#DALSM_IncomeData'><p>Income data</p></a></li>
<li><a href='#DALSM.object'><p>Object resulting from the fit of a double additive location-scale model (DALSM).</p></a></li>
<li><a href='#Dens1d'><p>Object creation for density estimation from right- or interval-censored data</p></a></li>
<li><a href='#Dens1d.object'><p>Object created by <code>Dens1d</code> to prepare for density estimation from censored data using <code>densityLPS</code></p></a></li>
<li><a href='#densityLPS'><p>Constrained density estimation from censored data with given mean and variance using Laplace P-splines</p></a></li>
<li><a href='#densLPS.object'><p>Object generated by function <code>densityLPS</code></p></a></li>
<li><a href='#DesignFormula'><p>Internal function extracting design matrices from formulas in the DALSM function and computing penalty related matrices</p></a></li>
<li><a href='#logDet.fun'><p>Log-determinant of a positive-definite matrix</p></a></li>
<li><a href='#Pcal.fun'><p>Generation of the penalty matrix for an additive model based on P-splines</p></a></li>
<li><a href='#plot.DALSM'><p>Plot visual information on a <code>DALSM.object</code></p></a></li>
<li><a href='#plot.densLPS'><p>Plot the density estimate in a <code>densLPS.object</code></p></a></li>
<li><a href='#plotRegion'><p>Plot a credible region for a curve together with its point estimates</p></a></li>
<li><a href='#predict.DALSM'><p>Prediction based on a DALSM model</p></a></li>
<li><a href='#print.DALSM'><p>Print summary information on a <code>DALSM.object</code></p></a></li>
<li><a href='#print.densLPS'><p>Print a summary of the information in a <code>densLPS.object</code></p></a></li>
<li><a href='#qknots'><p>Specification of knots in a cubic P-spline model</p></a></li>
<li><a href='#s'><p>Specification of smooth terms in formulas in the DALSM function.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Double Additive Location-Scale Model (DALSM)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philippe Lambert &lt;p.lambert@uliege.be&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/plambertULiege/DALSM/issues">https://github.com/plambertULiege/DALSM/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fit of a double additive location-scale model with a nonparametric error distribution from possibly right- or interval censored data. The additive terms in the location and dispersion submodels, as well as the unknown error distribution in the location-scale model, are estimated using Laplace P-splines. For more details, see Lambert (2021) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2021.107250">doi:10.1016/j.csda.2021.107250</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/plambertULiege/DALSM&amp;gt;">https://github.com/plambertULiege/DALSM&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>cubicBsplines, MASS, plyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-02 13:33:39 UTC; plambert</td>
</tr>
<tr>
<td>Author:</td>
<td>Philippe Lambert <a href="https://orcid.org/0000-0002-3670-3328"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-02 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='centeredBasis.gen'>Generation of a recentered cubic B-spline basis matrix in additive models</h2><span id='topic+centeredBasis.gen'></span>

<h3>Description</h3>

<p>Generation of a cubic B-spline basis matrix with recentered columns
to handle the identifiability constraint in additive models. See Wood (CRC Press 2017, pp. 175-176) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centeredBasis.gen(x, knots, cm = NULL, pen.order = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centeredBasis.gen_+3A_x">x</code></td>
<td>
<p>vector of values where to compute the &quot;recentered&quot; B-spline basis.</p>
</td></tr>
<tr><td><code id="centeredBasis.gen_+3A_knots">knots</code></td>
<td>
<p>vector of knots (that should cover the values in &lt;x&gt;).</p>
</td></tr>
<tr><td><code id="centeredBasis.gen_+3A_cm">cm</code></td>
<td>
<p>(Optional) values subtracted from each column of the original B-spline matrix.</p>
</td></tr>
<tr><td><code id="centeredBasis.gen_+3A_pen.order">pen.order</code></td>
<td>
<p>penalty order for the B-spline parameters (Default: 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing
</p>

<ul>
<li><p><code>B</code> : <code style="white-space: pre;">&#8288; &#8288;</code>centered cubic B-spline matrix (with columns recentered to have mean 0 over equi-spaced x values on the range of the knots).
</p>
</li>
<li><p><code>Dd</code> : <code style="white-space: pre;">&#8288; &#8288;</code>difference matrix (of order &lt;pen.order&gt;) for the associated centered B-spline matrix.
</p>
</li>
<li><p><code>Pd</code> : <code style="white-space: pre;">&#8288; &#8288;</code>penalty matrix (of order &lt;pen.order&gt;) for the associated centered B-spline matrix.
</p>
</li>
<li><p><code>K</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of centered B-splines in the basis.
</p>
</li>
<li><p><code>cm</code> : <code style="white-space: pre;">&#8288; &#8288;</code>values subtracted from each column of the original B-spline matrix. By default, this is a vector containing the mean of each column in the original B-spline matrix.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = seq(0,1,by=.01)
knots = seq(0,1,length=5)
obj = centeredBasis.gen(x,knots)
matplot(x,obj$B,type="l",ylab="Centered B-splines")
colMeans(obj$B)
</code></pre>

<hr>
<h2 id='DALSM'>Fit a double additive location-scale model (DALSM) with a flexible error distribution</h2><span id='topic+DALSM'></span>

<h3>Description</h3>

<p>Fit a location-scale regression model with a flexible error distribution and
additive terms in location (=mean) and dispersion (= log(sd)) using Laplace P-splines
from potentially right- and interval-censored response data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DALSM(y, formula1,formula2, data,
       K1=10, K2=10, pen.order1=2, pen.order2=2,
       b.tau=1e-4, lambda1.min=1, lambda2.min=1,
       phi.0=NULL,psi1.0=NULL,psi2.0=NULL,lambda1.0=NULL,lambda2.0=NULL,
       REML=FALSE, diag.only=TRUE, Normality=FALSE, sandwich=TRUE,
       K.error=20, rmin=NULL,rmax=NULL,
       ci.level=.95, iterlim=50,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DALSM_+3A_y">y</code></td>
<td>
<p>n-vector of responses or (nx2)-matrix/data.frame when interval-censoring (with the 2 elements giving the interval bounds) or right-censoring (when the element in the 2nd column equals Inf).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_formula1">formula1</code></td>
<td>
<p>model formula for location (i.e. for the conditional mean).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_formula2">formula2</code></td>
<td>
<p>model formula for dispersion (i.e. for the log of the conditional standard deviation).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_data">data</code></td>
<td>
<p>data frame containing the model covariates.</p>
</td></tr>
<tr><td><code id="DALSM_+3A_k1">K1</code></td>
<td>
<p>(optional) number of B-splines to describe a given additive term in the location submodel (default: 10).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_k2">K2</code></td>
<td>
<p>(optional) number of B-splines to describe a given additive term in the dispersion submodel (default: 10).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_pen.order1">pen.order1</code></td>
<td>
<p>(optional) penalty order for the additive terms in the location submodel (default: 2).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_pen.order2">pen.order2</code></td>
<td>
<p>(optional) penalty order for the additive terms in the dispersion submodel (default: 2).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_b.tau">b.tau</code></td>
<td>
<p>(optional) prior on penalty parameter <code class="reqn">\tau</code> is Gamma(1,b.tau=1e-4) (for additive terms) (default: 1e-4).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_lambda1.min">lambda1.min</code></td>
<td>
<p>(optional) minimal value for the penalty parameters in the additive model for location (default: 1.0).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_lambda2.min">lambda2.min</code></td>
<td>
<p>(optional) minimal value for penalty parameters in the additive model for log-dispersion (default: 1.0).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_phi.0">phi.0</code></td>
<td>
<p>(optional) initial values for the spline parameters in the log-hazard of the standardized error distribution.</p>
</td></tr>
<tr><td><code id="DALSM_+3A_psi1.0">psi1.0</code></td>
<td>
<p>(optional) initial values for the location submodel parameters.</p>
</td></tr>
<tr><td><code id="DALSM_+3A_psi2.0">psi2.0</code></td>
<td>
<p>(optional) initial values for the dispersion submodel parameters.</p>
</td></tr>
<tr><td><code id="DALSM_+3A_lambda1.0">lambda1.0</code></td>
<td>
<p>(optional) initial value for the J1 penalty parameters of the additive terms in the location submodel.</p>
</td></tr>
<tr><td><code id="DALSM_+3A_lambda2.0">lambda2.0</code></td>
<td>
<p>(optional) initial value for the J2 penalty parameters of the additive terms in the dispersion submodel.</p>
</td></tr>
<tr><td><code id="DALSM_+3A_reml">REML</code></td>
<td>
<p>(optional) logical indicating if a REML correction is desired to estimate the dispersion parameters (default: FALSE).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_diag.only">diag.only</code></td>
<td>
<p>(optional) logical indicating if only the diagonal of the Hessian needs to be corrected during REML (default: TRUE).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_normality">Normality</code></td>
<td>
<p>(optional) logical indicating if Normality is assumed for the error term (default: FALSE).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_sandwich">sandwich</code></td>
<td>
<p>(optional) logical indicating if sandwich variance estimators are needed for the regression parameters for a NP error distribution (when Normality=FALSE) ; it is forced to be TRUE when Normality=TRUE.</p>
</td></tr>
<tr><td><code id="DALSM_+3A_k.error">K.error</code></td>
<td>
<p>(optional) number of B-splines to approximate the log of the error hazard on (rmin,rmax) (default: 20).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_rmin">rmin</code></td>
<td>
<p>(optional) minimum value for the support of the standardized error distribution (default: min(y)-sd(y)).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_rmax">rmax</code></td>
<td>
<p>(optional) maximum value for the support of the standardized error distribution (default: max(y)+sd(y)).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_ci.level">ci.level</code></td>
<td>
<p>(optional) nominal level for the reported credible intervals (default: .95).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_iterlim">iterlim</code></td>
<td>
<p>(optional) maximum number of iterations (after which the algorithm is interrupted with a non-convergence diagnostic) (default: 50).</p>
</td></tr>
<tr><td><code id="DALSM_+3A_verbose">verbose</code></td>
<td>
<p>(optional) logical indicating whether estimation step details should be displayed (default: FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>DASLM</code> containing several components from the fit,
see <code><a href="#topic+DALSM.object">DALSM.object</a></code> for details. A summary can be printed using <code><a href="#topic+print.DALSM">print.DALSM</a></code>
or plotted using <code><a href="#topic+plot.DALSM">plot.DALSM</a></code>.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DALSM.object">DALSM.object</a></code>, <code><a href="#topic+print.DALSM">print.DALSM</a></code>, <code><a href="#topic+plot.DALSM">plot.DALSM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
            formula1 = ~twoincomes+s(age)+s(eduyrs),
            formula2 = ~twoincomes+s(age)+s(eduyrs),
            data = DALSM_IncomeData)
print(fit)
plot(fit)

</code></pre>

<hr>
<h2 id='DALSM_additive'>Extraction of the estimated additive terms in a <code><a href="#topic+DALSM.object">DALSM.object</a></code></h2><span id='topic+DALSM_additive'></span>

<h3>Description</h3>

<p>Extract the estimated additive terms with their standard errors from a <code><a href="#topic+DALSM.object">DALSM.object</a></code> resulting from the fit of a <code><a href="#topic+DALSM">DALSM</a></code> model.
In addition to the estimated functions in the location and dispersion submodels, their values on a regular grid covering the observed covariate values
are reported together with credible intervals. The mean effective coverage of these pointwise credible intervals
for the additive terms with respect to given (optional) reference functions (such as the ones for the 'true' additive terms used
to generate data in a simulation study) can also be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DALSM_additive(obj.DALSM, ngrid=101,
       true.loc=NULL, true.disp=NULL, ci.level=NULL,
       verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DALSM_additive_+3A_obj.dalsm">obj.DALSM</code></td>
<td>
<p>a <code><a href="#topic+DALSM.object">DALSM.object</a></code></p>
</td></tr>
<tr><td><code id="DALSM_additive_+3A_ngrid">ngrid</code></td>
<td>
<p>(optional) grid size of covariate values where the additive terms are calculated (default: 101).</p>
</td></tr>
<tr><td><code id="DALSM_additive_+3A_true.loc">true.loc</code></td>
<td>
<p>(optional) list of functions containing the 'true' additive terms in the location sub-model.</p>
</td></tr>
<tr><td><code id="DALSM_additive_+3A_true.disp">true.disp</code></td>
<td>
<p>(optional) list of functions containing the 'true' additive terms in the dispersion sub-model.</p>
</td></tr>
<tr><td><code id="DALSM_additive_+3A_ci.level">ci.level</code></td>
<td>
<p>(optional) level of credible intervals.</p>
</td></tr>
<tr><td><code id="DALSM_additive_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether the computed corverages should be printed out (default: TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an invisible list containing:
</p>

<ul>
<li><p><code>J1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of additive terms in the location sub-model.
</p>
</li>
<li><p><code>labels.loc</code> : <code style="white-space: pre;">&#8288; &#8288;</code>labels of the additive terms in the location sub-model.
</p>
</li>
<li><p><code>f.loc.grid</code> : <code style="white-space: pre;">&#8288; &#8288;</code>list of length <code>J1</code> with, for each additive term, a list of length 3 with elements 'x': a vector of <code>ngrid</code> values for the covariate ; 'y.mat': a matrix with 3 columns (est,low,up) giving the additive term and its pointwise credible region ; se: the standard error of the additive term on the x-grid.
</p>
</li>
<li><p><code>f.loc</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a list of length <code>J1</code> with, for each additive term &lt;x&gt;, a list with f.loc$x: a function computing the additive term f.loc(x) for a given covariate value 'x' ; attributes(f.loc$x): support, label, range.
</p>
</li>
<li><p><code>se.loc</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a list of length <code>J1</code> with, for each additive term &lt;x&gt;, a list with se.loc$x: a function computing the s.e. of f(x) for a given covariate value 'x' ; attributes(se.loc$x): support, label, range.
</p>
</li>
<li><p><code>coverage.loc</code> : <code style="white-space: pre;">&#8288; &#8288;</code>if <code>true.loc</code> is provided: a vector of length <code>J1</code> giving the average effective coverage of pointwise credible intervals for each of the additive terms in the location sub-model.
</p>
</li>
<li><p><code>J2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of additive terms in the dispersion sub-model.
</p>
</li>
<li><p><code>labels.disp</code> : <code style="white-space: pre;">&#8288; &#8288;</code>labels of the additive terms in the dispersion sub-model.
</p>
</li>
<li><p><code>f.disp.grid</code> : <code style="white-space: pre;">&#8288; &#8288;</code>list of length <code>J2</code> with, for each additive term, a list of length 3 with elements 'x': a vector of <code>ngrid</code> values for the covariate ; 'y.mat': a matrix with 3 columns (est,low,up) giving the additive term and its pointwise credible region ; se: the standard error of the additive term on the x-grid.
</p>
</li>
<li><p><code>f.disp</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a list of length <code>J2</code> with, for each additive term &lt;x&gt;, a list with f.disp$x: a function computing the additive term f.disp(x) for a given covariate value 'x' ; attributes(f.disp$x): support, label, range.
</p>
</li>
<li><p><code>se.disp</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a list of length <code>J2</code> with, for each additive term &lt;x&gt;, a list with se.disp$x: a function computing the s.e. of f(x) for a given covariate value 'x' ; attributes(se.disp$x): support, label, range.
</p>
</li>
<li><p><code>coverage.disp</code> : <code style="white-space: pre;">&#8288; &#8288;</code>if &lt;true.disp&gt; is provided: a vector of length <code>J2</code> giving the average effective coverage of pointwise credible intervals for each of the additive terms in the dispersion sub-model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DALSM.object">DALSM.object</a></code>, <code><a href="#topic+DALSM">DALSM</a></code>, <code><a href="#topic+print.DALSM">print.DALSM</a></code>, <code><a href="#topic+plot.DALSM">plot.DALSM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
            formula1 = ~twoincomes+s(age)+s(eduyrs),
            formula2 = ~twoincomes+s(age)+s(eduyrs),
            data = DALSM_IncomeData)
obj = DALSM_additive(fit)
str(obj)

## Visualize the estimated additive terms for Age
## ... in the location submodel
with(obj$f.loc.grid$age, matplot(x,y.mat,
                                 xlab="Age",ylab="f.loc(Age)",
                                 type="l",col=1,lty=c(1,2,2)))
## ... and in the dispersion submodel
with(obj$f.disp.grid$age, matplot(x,y.mat,
                                 xlab="Age",ylab="f.disp(Age)",
                                 type="l",col=1,lty=c(1,2,2)))
## Also report their values for selected age values
obj$f.loc$age(c(30,40,50)) ; obj$f.disp$age(c(30,40,50))
## ... together with their standard errors
obj$se.loc$age(c(30,40,50)) ; obj$se.disp$age(c(30,40,50))
</code></pre>

<hr>
<h2 id='DALSM_IncomeData'>Income data</h2><span id='topic+DALSM_IncomeData'></span>

<h3>Description</h3>

<p>Income (in euros) available per person in 756 Belgian households (ESS 2016 ; Lambert 2021, Section 4)
for respondents aged 25-55 when the main source of income
comes from wages or salaries. The data were extracted from the European Social Survey (2016)
and reworked to quantify the resources available at the individual level
in the selected Belgian households.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DALSM_IncomeData)
</code></pre>


<h3>Format</h3>

<p>A data frame with 756 rows and 5 columns:
</p>

<ul>
<li><p><code>inc.low</code> : <code style="white-space: pre;">&#8288; &#8288;</code>lower bound for the individual income data.
</p>
</li>
<li><p><code>inc.up</code> : <code style="white-space: pre;">&#8288; &#8288;</code>upper bound for the individual income data (<code>Inf</code> if right-censored).
</p>
</li>
<li><p><code>twoincomes</code> : <code style="white-space: pre;">&#8288; &#8288;</code><code>0</code>: one-income household ; <code>1</code>: two-income household.
</p>
</li>
<li><p><code>age</code> : <code style="white-space: pre;">&#8288; &#8288;</code>age of the respondent.
</p>
</li>
<li><p><code>eduyrs</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of years of education completed.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>
<p>European Social Survey Round 8 Data (2016)
Data file edition 2.1. NSD - Norwegian Centre for Research Data, Norway.
</p>

<hr>
<h2 id='DALSM.object'>Object resulting from the fit of a double additive location-scale model (DALSM).</h2><span id='topic+DALSM.object'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+DALSM">DALSM</a></code> function: this is a list
with various components related to the fit of a double additive location-scale model using Laplace P-splines.
</p>


<h3>Value</h3>

<p>A <code>DALSM</code> object has the following elements:
</p>
<p>Essential part:
</p>

<ul>
<li><p><code>converged</code> : <code style="white-space: pre;">&#8288; &#8288;</code>logical convergence indicator.
</p>
</li>
<li><p><code>derr</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated standardized error distribution returned as a <a href="#topic+densLPS.object">densLPS.object</a>.
</p>
</li>
<li><p><code>psi1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated regression parameters for location (fixed effects, B-spline coefs for the J1 additive terms).
</p>
</li>
<li><p><code>psi2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated regression parameters for dispersion (fixed effects, B-spline coefs for the J2 additive terms).
</p>
</li>
<li><p><code>fixed.loc</code> : <code style="white-space: pre;">&#8288; &#8288;</code>matrix with the estimated fixed effects (est,se,ci.low,ci.up) in the location sub-model.
</p>
</li>
<li><p><code>fixed.disp</code> : <code style="white-space: pre;">&#8288; &#8288;</code>matrix with the estimated fixed effects (est,se,ci.low,ci.up) in the dispersion sub-model.
</p>
</li>
<li><p><code>mu</code> : <code style="white-space: pre;">&#8288; &#8288;</code>n-vector with the fitted conditional mean.
</p>
</li>
<li><p><code>sd</code> : <code style="white-space: pre;">&#8288; &#8288;</code>n-vector with the fitted conditional standard deviation.
</p>
</li></ul>

<p>Additional elements:
</p>

<ul>
<li><p><code>data</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the original data frame used when calling the <code><a href="#topic+DALSM">DALSM</a></code> function.
</p>
</li>
<li><p><code>phi</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated B-spline coefs for the log-hazard of the error distribution.
</p>
</li>
<li><p><code>K.error</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of B-splines used to approximate the log of the error hazard.
</p>
</li>
<li><p><code>rmin, rmax</code> : <code style="white-space: pre;">&#8288; &#8288;</code>minimum and maximum values for the support of the standardized error distribution.
</p>
</li>
<li><p><code>knots.error</code> : <code style="white-space: pre;">&#8288; &#8288;</code>equidistant knots on (rmin,rmax) used to specify the B-spline basis for the log of the error hazard.
</p>
</li>
<li><p><code>bread.psi1, Sand.psi1, Cov.psi1</code>: <code style="white-space: pre;">&#8288; &#8288;</code>estimated Variance-Covariance matrix for <code class="reqn">\psi_1</code>.
</p>
</li>
<li><p><code>U.psi1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>gradient for <code class="reqn">\psi_1</code>.
</p>
</li>
<li><p><code>bread.psi2, Sand.psi2, Cov.psi2</code>: <code style="white-space: pre;">&#8288; &#8288;</code>estimated Variance-Covariance matrix for <code class="reqn">\psi_2</code>.
</p>
</li>
<li><p><code>U.psi2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>gradient for <code class="reqn">\psi_2</code>.
</p>
</li>
<li><p><code>U.psi</code> : <code style="white-space: pre;">&#8288; &#8288;</code>gradient for <code class="reqn">\psi=(\psi_1,\psi_2)</code>.
</p>
</li>
<li><p><code>Cov.psi</code> : <code style="white-space: pre;">&#8288; &#8288;</code>variance-covariance for <code class="reqn">\psi=(\psi_1,\psi_2)</code>.
</p>
</li>
<li><p><code>regr1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>object generated by <code><a href="#topic+DesignFormula">DesignFormula</a></code> for the specified submodel for location.
</p>
</li>
<li><p><code>regr2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>object generated by <code><a href="#topic+DesignFormula">DesignFormula</a></code> for the specified submodel for dispersion.
</p>
</li>
<li><p><code>res</code> : <code style="white-space: pre;">&#8288; &#8288;</code>n-vector or nx2 matrix (if IC data) with the standardized residuals for the fitted model.
</p>
</li>
<li><p><code>expctd.res</code> : <code style="white-space: pre;">&#8288; &#8288;</code>n-vector with observed standardized residual for a non RC unit, or their expected value if right-censored.
</p>
</li>
<li><p><code>REML</code> : <code style="white-space: pre;">&#8288; &#8288;</code>logical indicating whether REML estimation was performed.
</p>
</li>
<li><p><code>n</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the sample size.
</p>
</li>
<li><p><code>n.uncensored</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of non-censored response data.
</p>
</li>
<li><p><code>event</code> : <code style="white-space: pre;">&#8288; &#8288;</code>n-vector of event indicators (1: non right-censored ; 0: right censoring).
</p>
</li>
<li><p><code>is.IC</code> : <code style="white-space: pre;">&#8288; &#8288;</code>n-vector with interval censoring indicators.
</p>
</li>
<li><p><code>n.IC</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of interval-censored response data.
</p>
</li>
<li><p><code>n.RC</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of right-censored response data.
</p>
</li>
<li><p><code>perc.obs</code> : <code style="white-space: pre;">&#8288; &#8288;</code>percentage of exactly observed response data.
</p>
</li>
<li><p><code>perc.IC</code> : <code style="white-space: pre;">&#8288; &#8288;</code>percentage of interval-censored response data.
</p>
</li>
<li><p><code>perc.RC</code> : <code style="white-space: pre;">&#8288; &#8288;</code>percentage of right-censored response data.
</p>
</li>
<li><p><code>cred.int</code> : <code style="white-space: pre;">&#8288; &#8288;</code>nominal level for the reported credible intervals.
</p>
</li>
<li><p><code>alpha</code> : <code style="white-space: pre;">&#8288; &#8288;</code>user-specified <code class="reqn">\alpha</code> with Bayesian <code class="reqn">(1-\alpha)</code> credible intervals reported.
</p>
</li>
<li><p><code>sandwich</code> : <code style="white-space: pre;">&#8288; &#8288;</code>logical indicating if variance-covariance and standard errors computed using sandwich estimator in the NP case.
</p>
</li>
<li><p><code>diag.only</code> : <code style="white-space: pre;">&#8288; &#8288;</code>logical indicating if the correction to the Hessian under REML only concerns diagonal elements.
</p>
</li>
<li><p><code>iter</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of iterations.
</p>
</li>
<li><p><code>elapsed.time</code> : <code style="white-space: pre;">&#8288; &#8288;</code>time required by the model fitting procedure.
</p>
</li></ul>

<p>If there are additive terms in the location submodel:
</p>

<ul>
<li><p><code>K1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of B-splines used to describe an additive term in the location submodel.
</p>
</li>
<li><p><code>xi1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>matrix with the selected log penalty parameters for the J1 additive terms in the location submodel (point estimate, se, ci.low, ci.up.
</p>
</li>
<li><p><code>U.xi1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>gradient for the log of the penalty parameters for the J1 additive terms in the location submodel.
</p>
</li>
<li><p><code>U.lambda1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>gradient for the penalty parameters for the J1 additive terms in the location submodel.
</p>
</li>
<li><p><code>Cov.xi1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated Variance-Covariance matrix for the parameters involved in the J1 additive terms in the location submodel.
</p>
</li>
<li><p><code>lambda1.min</code> : <code style="white-space: pre;">&#8288; &#8288;</code>minimal value for the penalty parameters in the additive submodel for location.
</p>
</li>
<li><p><code>lambda1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>matrix with the selected penalty parameters for the J1 additive terms in the location submodel (point estimate, se, ci.low, ci.up).
</p>
</li>
<li><p><code>ED1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>matrix with the effective dimensions for each of the J1 additive terms in the location submodel (point estimate,ci.low,ci.up).
</p>
</li></ul>

<p>If there are additive terms in the dispersion submodel:
</p>

<ul>
<li><p><code>K2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of B-splines used to describe an additive term in the dispersion submodel.
</p>
</li>
<li><p><code>xi2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>matrix with the selected log penalty parameters for the J2 additive terms in the dispersion submodel (point estimate, se, ci.low, ci.up).
</p>
</li>
<li><p><code>U.xi2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>gradient for the log of the penalty parameters for the J2 additive terms in the dispersion submodel.
</p>
</li>
<li><p><code>U.lambda2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>gradient for the penalty parameters for the J2 additive terms in the dispersion submodel.
</p>
</li>
<li><p><code>Cov.xi2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated Variance-Covariance matrix for the parameters involved in the J2 additive terms in the dispersion submodel.
</p>
</li>
<li><p><code>lambda2.min</code> : <code style="white-space: pre;">&#8288; &#8288;</code>minimal value for the penalty parameters in the additive submodel for dispersion.
</p>
</li>
<li><p><code>lambda2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>matrix with the selected penalty parameters for the J2 additive terms in the dispersion submodel (point estimate, se, ci.low, ci.up).
</p>
</li>
<li><p><code>ED2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>matrix with the effective dimensions for each of the J2 additive terms in the dispersion submodel (point estimate,ci.low,ci.up).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DALSM">DALSM</a></code>, <code><a href="#topic+print.DALSM">print.DALSM</a></code>, <code><a href="#topic+plot.DALSM">plot.DALSM</a></code>, <code><a href="#topic+densityLPS">densityLPS</a></code>, <code><a href="#topic+densLPS.object">densLPS.object</a></code>
</p>

<hr>
<h2 id='Dens1d'>Object creation for density estimation from right- or interval-censored data</h2><span id='topic+Dens1d'></span>

<h3>Description</h3>

<p>Object creation for density estimation from right- or interval-censored data using function <a href="#topic+densityLPS">densityLPS</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dens1d(y, event=NULL, ymin=NULL, ymax=NULL,
       K=25, equid.knots=TRUE, pen.order=2, nbins=501)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dens1d_+3A_y">y</code></td>
<td>
<p>a n-vector (if no interval-censored data) or a nx2 matrix (left and right limits of the interval for IC data ; right limit set to Inf for right-censored data).</p>
</td></tr>
<tr><td><code id="Dens1d_+3A_event">event</code></td>
<td>
<p>a n-vector of observation indicators (0: right-censored ; 1: exactly observed or interval-censored).</p>
</td></tr>
<tr><td><code id="Dens1d_+3A_ymin">ymin</code></td>
<td>
<p>left limit of the variable support.</p>
</td></tr>
<tr><td><code id="Dens1d_+3A_ymax">ymax</code></td>
<td>
<p>right limit of the variable support.</p>
</td></tr>
<tr><td><code id="Dens1d_+3A_k">K</code></td>
<td>
<p>number of B-splines in the basis to approximate the log-hazard.</p>
</td></tr>
<tr><td><code id="Dens1d_+3A_equid.knots">equid.knots</code></td>
<td>
<p>logical indicating if equidistants knots are desired.</p>
</td></tr>
<tr><td><code id="Dens1d_+3A_pen.order">pen.order</code></td>
<td>
<p>penalty order when equidistant knots (otherwise: penalty matrix computed to penalize the second derivative).</p>
</td></tr>
<tr><td><code id="Dens1d_+3A_nbins">nbins</code></td>
<td>
<p>number of small bins used for quadrature and approximations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Dens1d.object">Dens1d.object</a>, i.e. a list with summary measures and precomputed components required for density estimation using <code><a href="#topic+densityLPS">densityLPS</a></code>.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dens1d.object">Dens1d.object</a></code>, <code><a href="#topic+densityLPS">densityLPS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
head(resp,n=20)
temp = Dens1d(y=resp,ymin=0) ## Create Dens1d object from positive censored data
obj = densityLPS(temp) ## Density estimation from IC &amp; RC data
plot(obj) ## Visualize the estimated density

</code></pre>

<hr>
<h2 id='Dens1d.object'>Object created by <code>Dens1d</code> to prepare for density estimation from censored data using <code>densityLPS</code></h2><span id='topic+Dens1d.object'></span>

<h3>Description</h3>

<p>An object returned by function <code><a href="#topic+Dens1d">Dens1d</a></code> to prepare for density estimation with given mean and variance from censored data using function <code><a href="#topic+densityLPS">densityLPS</a></code>.
</p>


<h3>Value</h3>

<p>A <code>Dens1d.object</code> is a list with the following elements:
</p>

<ul>
<li><p><code>n</code> : <code style="white-space: pre;">&#8288; &#8288;</code>total sample size.
</p>
</li>
<li><p><code>y</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a n-vector if no interval-censored data, a nx2 matrix otherwise (for interval-censored data: left and right limits of the interval ; for right-censored data: the right limit is set to Inf).
</p>
</li>
<li><p><code>event</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a n-vector of observation indicators (0: right-censored ; 1: exactly observed or interval-censored).
</p>
</li>
<li><p><code>ymin</code> : <code style="white-space: pre;">&#8288; &#8288;</code>left limit of the variable support.
</p>
</li>
<li><p><code>ymax</code> : <code style="white-space: pre;">&#8288; &#8288;</code>right limit of the variable support.
</p>
</li>
<li><p><code>is.uncensored</code> : <code style="white-space: pre;">&#8288; &#8288;</code>boolean n-vector indicating if the corresponding &lt;y&gt; value is not right- or interval-censored.
</p>
</li>
<li><p><code>n.uncensored</code> : <code style="white-space: pre;">&#8288; &#8288;</code>total number of uncensored data.
</p>
</li>
<li><p><code>is.IC</code> : <code style="white-space: pre;">&#8288; &#8288;</code>boolean n-vector indicating if the corresponding <code>y</code> value is interval-censored.
</p>
</li>
<li><p><code>n.IC</code> : <code style="white-space: pre;">&#8288; &#8288;</code>total number of interval-censored data.
</p>
</li>
<li><p><code>is.RC</code> : <code style="white-space: pre;">&#8288; &#8288;</code>n-vector of booleans indicating if the corresponding <code>y</code> value is right-censored.
</p>
</li>
<li><p><code>n.RC</code> : <code style="white-space: pre;">&#8288; &#8288;</code>total number of right-censored data.
</p>
</li>
<li><p><code>ylow, yup</code> : <code style="white-space: pre;">&#8288; &#8288;</code>n-vector with the lower and upper limits of the interval data (when interval-censored). When <code>y</code> is exactly observed or right-censored, the two values are identical.
</p>
</li>
<li><p><code>ymid</code> : <code style="white-space: pre;">&#8288; &#8288;</code>n-vector containing the mean of <code>y.low</code> and <code>y.up</code>.
</p>
</li>
<li><p><code>K</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of B-splines in the basis used to model the log-hazard.
</p>
</li>
<li><p><code>knots</code> : <code style="white-space: pre;">&#8288; &#8288;</code>vector of knots for the B-spline basis.
</p>
</li>
<li><p><code>pen.order</code> : <code style="white-space: pre;">&#8288; &#8288;</code>penalty order.
</p>
</li>
<li><p><code>Pd</code> : <code style="white-space: pre;">&#8288; &#8288;</code>penalty matrix in the P-spline model.
</p>
</li>
<li><p><code>nbins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of small bins used to partition the variable support.
</p>
</li>
<li><p><code>bins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>small bins of equal width used to partition the variable support (cf. binning).
</p>
</li>
<li><p><code>ugrid</code> : <code style="white-space: pre;">&#8288; &#8288;</code>midpoints of the small bins.
</p>
</li>
<li><p><code>dbins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>width of a small bin.
</p>
</li>
<li><p><code>Bbins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>((nbins +1) x K)-matrix containing the B-spline basis evaluated at the bin limits.
</p>
</li>
<li><p><code>C</code> : <code style="white-space: pre;">&#8288; &#8288;</code>(n x nbins) matrix of event or censoring indicators <code class="reqn">C_{ij}</code> for unit 'i' and bin 'j'. For a unit with IC data, the bins with an non-empty intersection with the interval are indicated. When the unit is associated to a precise event time or censoring time in bin 'j', then <code class="reqn">C_{ij}=1</code> and 0 for other bins.
</p>
</li>
<li><p><code>Bgrid</code> : <code style="white-space: pre;">&#8288; &#8288;</code>(nbins x K)-matrix containing the B-spline basis evaluated at the bin midpoints.
</p>
</li>
<li><p><code>fgrid</code> : <code style="white-space: pre;">&#8288; &#8288;</code>nbins-vector with the estimated density values at the bin midpoints.
</p>
</li>
<li><p><code>rgrid</code> : <code style="white-space: pre;">&#8288; &#8288;</code>nbins-vector with the number of units 'still at risk' of an &quot;event&quot; in a given bin.
</p>
</li>
<li><p><code>BsB, ev</code> : <code style="white-space: pre;">&#8288; &#8288;</code>technical quantities used in the estimation procedure, see the code in Dens1d.R for more details.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dens1d">Dens1d</a></code>, <code><a href="#topic+densityLPS">densityLPS</a></code>, <code><a href="#topic+densLPS.object">densLPS.object</a></code>
</p>

<hr>
<h2 id='densityLPS'>Constrained density estimation from censored data with given mean and variance using Laplace P-splines</h2><span id='topic+densityLPS'></span>

<h3>Description</h3>

<p>P-spline estimation of the density (pdf), cumulative distribution (cdf),
hazard and cumulative hazard functions from interval- or right-censored data under possible marginal
mean and/or variance constraints. The penalty parameter <code class="reqn">\tau</code> tuning the smoothness of
the log-hazard can be selected using the Laplace P-splines (LPS) method maximizing an approximation to the marginal posterior
of <code class="reqn">\tau</code> (also named the 'evidence')  or using Schall's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityLPS(obj.data,
       is.density=TRUE, Mean0=NULL, Var0=NULL,
       fixed.penalty=FALSE, method=c("LPS","Schall"),
       fixed.phi=FALSE,phi.ref=NULL, phi0=NULL,tau0=exp(5),tau.min=.1,
       verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityLPS_+3A_obj.data">obj.data</code></td>
<td>
<p>a list created from potentially right- or interval-censored data using <code><a href="#topic+Dens1d">Dens1d</a></code>. It includes summary statistics, the assumed density support, the knots for the B-spline basis, etc.</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_is.density">is.density</code></td>
<td>
<p>(optional) logical indicating whether the estimated density should integrate to 1.0 over the range of the knots in obj.data$knots (default: TRUE).</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_mean0">Mean0</code></td>
<td>
<p>(optional) constrained value for the mean of the fitted density (defaut: NULL).</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_var0">Var0</code></td>
<td>
<p>(optional) constrained value for the variance of the fitted density (defaut: NULL).</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_fixed.penalty">fixed.penalty</code></td>
<td>
<p>(optional) logical indicating whether the penalty parameter should be selected from the data (<code>fixed.penalty</code>=FALSE) or fixed (<code>fixed.penalty</code>=TRUE) at its initial value <code class="reqn">\tau_0</code>.</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_method">method</code></td>
<td>
<p>method used for the selection of the penalty parameter: &quot;LPS&quot; (by maximizing the marginal posterior for <code class="reqn">\tau</code>, cf. &quot;Laplace P-splines&quot;) or &quot;Schall&quot; (Schall's method).</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_fixed.phi">fixed.phi</code></td>
<td>
<p>(optional) logical indicating whether the spline parameters are fixed (<code>fixed.phi</code>=TRUE) or estimated from the data (default: <code>fixed.phi</code>=FALSE).</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_phi.ref">phi.ref</code></td>
<td>
<p>(optional) reference value for the spline parameters with respect to which deviations are penalized (default: zero vector).</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_phi0">phi0</code></td>
<td>
<p>starting value for the spline parameters (default: spline parameters corresponding to a Student density with 5 DF).</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_tau0">tau0</code></td>
<td>
<p>(optional) initial value for the penalty parameter <code class="reqn">\tau</code> (default: exp(5)).</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_tau.min">tau.min</code></td>
<td>
<p>(optional) minimal value for the penalty parameter <code class="reqn">\tau</code> (default: .1).</p>
</td></tr>
<tr><td><code id="densityLPS_+3A_verbose">verbose</code></td>
<td>
<p>(optional) logical indicating whether estimation step details should be displayed (default: FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+densLPS.object">densLPS.object</a></code> containing the density estimation results.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densLPS.object">densLPS.object</a></code>, <code><a href="#topic+print.densLPS">print.densLPS</a></code>, <code><a href="#topic+plot.densLPS">plot.densLPS</a></code>, <code><a href="#topic+Dens1d.object">Dens1d.object</a></code>, <code><a href="#topic+Dens1d">Dens1d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DALSM)

## Example 1: estimation of the error density in a DALSM model
require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
            formula1 = ~twoincomes+s(age)+s(eduyrs),
            formula2 = ~twoincomes+s(age)+s(eduyrs),
            data = DALSM_IncomeData)
plot(fit$derr)  ## Plot the estimated error density
print(fit$derr) ## ... and provide summary statistics for it

## Example 2: density estimation from censored income data
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
head(resp,n=20)
temp = Dens1d(y=resp,ymin=0) ## Create Dens1d object from positive censored data
obj = densityLPS(temp) ## Density estimation from IC &amp; RC data
print(obj) ## Summary information on the estimated density
plot(obj,hist=TRUE) ## Visualize the estimated density
legend("topright",col=c("black","grey"),lwd=c(2,20),
       legend=c("Fitted density","Pseudo-data"),bty="n")

## Example 3: density estimation from simulated RC and IC data
## Data generation
set.seed(123)
n = 500 ## Sample size
x = rgamma(n,10,2) ## Exact (unobserved) data
width = runif(n,1,3) ## Width of the IC data (mean width = 2)
w = runif(n) ## Positioning of the exact data within the interval
xmat = cbind(pmax(0,x-w*width),x+(1-w)*width) ## Generated IC data
t.cens = rexp(n,1/15) ## Right-censoring values
idx.RC = (1:n)[t.cens&lt;x] ## Id's of the right-censored units
xmat[idx.RC,] = cbind(t.cens[idx.RC],Inf) ## Data for RC units: (t.cens,Inf)
head(xmat,15)
## Density estimation with mean and variance constraints
obj.data = Dens1d(xmat,ymin=0) ## Prepare the data for estimation
obj = densityLPS(obj.data,Mean0=10/2,Var0=10/4) ## Density estimation
print(obj)
plot(obj) ## Plot the estimated density
curve(dgamma(x,10,2), ## ... and compare it to the true density (in red)
      add=TRUE,col="red",lwd=2,lty=2)
legend("topright",col=c("black","red"),lwd=c(2,2),lty=c(1,2),
       legend=c("Estimated density","True density"),bty="n")
## Same story for the cdf
with(obj, curve(pdist(x),ymin,ymax,lwd=2,xlab="",ylab="F(x)"))
curve(pgamma(x,10,2),add=TRUE,col="red",lwd=2,lty=2)
legend("right",col=c("black","red"),lwd=c(2,2),lty=c(1,2),
       legend=c("Estimated cdf","True cdf"),bty="n")

</code></pre>

<hr>
<h2 id='densLPS.object'>Object generated by function <code>densityLPS</code></h2><span id='topic+densLPS.object'></span>

<h3>Description</h3>

<p>An object returned by function <code><a href="#topic+densityLPS">densityLPS</a></code>: this is a list
with various components related to the estimation of a density with given mean and variance from potentially right- or interval-censored data using Laplace P-splines.
</p>


<h3>Value</h3>

<p>An object returned by <code><a href="#topic+densityLPS">densityLPS</a></code> has the following elements:
Essential part:
</p>

<ul>
<li><p><code>converged</code> : <code style="white-space: pre;">&#8288; &#8288;</code>logical convergence indicator.
</p>
</li>
<li><p><code>ddist</code> : <code style="white-space: pre;">&#8288; &#8288;</code>fitted density function.
</p>
</li>
<li><p><code>Hdist</code> : <code style="white-space: pre;">&#8288; &#8288;</code>fitted cumulative hazard function.
</p>
</li>
<li><p><code>hdist</code> : <code style="white-space: pre;">&#8288; &#8288;</code>fitted hazard function.
</p>
</li>
<li><p><code>pdist</code> : <code style="white-space: pre;">&#8288; &#8288;</code>fitted cumulative distribution function.
</p>
</li>
<li><p><code>ymin, ymax</code> : <code style="white-space: pre;">&#8288; &#8288;</code>assumed values for the support of the distribution.
</p>
</li>
<li><p><code>phi</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated B-spline coefficients for the log-hazard of the error distribution.
</p>
</li>
<li><p><code>U.phi</code> : <code style="white-space: pre;">&#8288; &#8288;</code>score of the Lagrangian G(<code class="reqn">\phi|\omega</code>).
</p>
</li>
<li><p><code>tau</code>, <code>ltau</code> : <code style="white-space: pre;">&#8288; &#8288;</code>selected penalty parameter and its logarithm.
</p>
</li>
<li><p><code>est</code> : <code style="white-space: pre;">&#8288; &#8288;</code>vector containing the estimated/selected (<code class="reqn">\phi,\log\tau</code>) parameters.
</p>
</li>
<li><p><code>fixed.phi</code> : <code style="white-space: pre;">&#8288; &#8288;</code>logical indicating whether the spline parameters were given fixed values or estimated from the data.
</p>
</li>
<li><p><code>phi.ref</code> : <code style="white-space: pre;">&#8288; &#8288;</code>reference values for the spline parameters with respect to which <code class="reqn">\phi</code> is compared during penalization.
</p>
</li>
<li><p><code>BWB</code> : <code style="white-space: pre;">&#8288; &#8288;</code>Hessian for <code class="reqn">\phi</code> without the penalty contribution.
</p>
</li>
<li><p><code>Prec</code> : <code style="white-space: pre;">&#8288; &#8288;</code>Hessian or posterior precision matrix for <code class="reqn">\phi</code>.
</p>
</li>
<li><p><code>Fisher</code> : <code style="white-space: pre;">&#8288; &#8288;</code>Fisher information for <code class="reqn">\phi</code>.
</p>
</li>
<li><p><code>bins, ugrid, du</code> : <code style="white-space: pre;">&#8288; &#8288;</code>bins (of width 'du') and with midpoints 'ugrid' partitioning the support of the density.
</p>
</li>
<li><p><code>h.grid, H.grid, dens.grid</code> : <code style="white-space: pre;">&#8288; &#8288;</code>hazard, cumulative hazard and density values at the grid midpoints 'ugrid'.
</p>
</li>
<li><p><code>h.bins, H.bins, dens.bins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>hazard, cumulative hazard and density values at the bin limits 'bins'.
</p>
</li>
<li><p><code>expected</code> : <code style="white-space: pre;">&#8288; &#8288;</code>expected number of observations within each bin.
</p>
</li>
<li><p><code>Finfty</code> : <code style="white-space: pre;">&#8288; &#8288;</code>integrated density value over the considered support.
</p>
</li>
<li><p><code>Mean0, Var0</code> : <code style="white-space: pre;">&#8288; &#8288;</code>when specified, constrained mean and variance values during estimation.
</p>
</li>
<li><p><code>mean.dist, var.dist</code> : <code style="white-space: pre;">&#8288; &#8288;</code>mean and variance of the fitted density.
</p>
</li>
<li><p><code>method</code> : <code style="white-space: pre;">&#8288; &#8288;</code>method used for penaly selection: &quot;evidence&quot; (by maximizing the marginal posterior for <code class="reqn">\tau</code>) or &quot;Schall&quot; (Schall's method).
</p>
</li>
<li><p><code>ed</code> : <code style="white-space: pre;">&#8288; &#8288;</code>effective number of (spline) parameters.
</p>
</li>
<li><p><code>iterations</code> : <code style="white-space: pre;">&#8288; &#8288;</code>total number of iterations necessary for convergence.
</p>
</li>
<li><p><code>elapsed.time</code> : <code style="white-space: pre;">&#8288; &#8288;</code>time required for convergence.
</p>
</li></ul>

<p>Additional elements:
the content of the <a href="#topic+Dens1d.object">Dens1d.object</a> used when <a href="#topic+densityLPS">densityLPS</a> was called.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityLPS">densityLPS</a></code>, <code><a href="#topic+DALSM">DALSM</a></code>
</p>

<hr>
<h2 id='DesignFormula'>Internal function extracting design matrices from formulas in the DALSM function and computing penalty related matrices</h2><span id='topic+DesignFormula'></span>

<h3>Description</h3>

<p>Internal function extracting design matrices from formulas in the DALSM function and computing penalty related matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DesignFormula(formula, data, K = 10, pen.order = 2, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DesignFormula_+3A_formula">formula</code></td>
<td>
<p>a formula describing the fixed effects and the additive terms in a regression model.</p>
</td></tr>
<tr><td><code id="DesignFormula_+3A_data">data</code></td>
<td>
<p>a dataframe containing the data.</p>
</td></tr>
<tr><td><code id="DesignFormula_+3A_k">K</code></td>
<td>
<p>number of B-splines to describe an additive term.</p>
</td></tr>
<tr><td><code id="DesignFormula_+3A_pen.order">pen.order</code></td>
<td>
<p>desired penalty order for the spline parameters in the additive terms.</p>
</td></tr>
<tr><td><code id="DesignFormula_+3A_n">n</code></td>
<td>
<p>number of units (Default: number of rows in the design matrix constructed from the formula and the data frame).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with
</p>

<ul>
<li><p><code>Z</code> : <code style="white-space: pre;">&#8288; &#8288;</code>(n x nfixed) design matrix with fixed effects (including a first column of 1).
</p>
</li>
<li><p><code>X</code> : <code style="white-space: pre;">&#8288; &#8288;</code>(n x J) design matrix with the covariates involved in the additive terms.
</p>
</li>
<li><p><code>nfixed</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of fixed effect regression parameters.
</p>
</li>
<li><p><code>J</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of additive terms.
</p>
</li>
<li><p><code>K</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of B-splines in a basis used to estimate an additive term.
</p>
</li>
<li><p><code>Bx</code> : <code style="white-space: pre;">&#8288; &#8288;</code>list with J objects (one per additive term) including (B,Dd,Pd,K,cm).
</p>
</li>
<li><p><code>Pd.x, Dd.x</code> : <code style="white-space: pre;">&#8288; &#8288;</code>penalty and difference penalty matrices applied on the spline parameters of an additive term.
</p>
</li>
<li><p><code>knots.x</code> : <code style="white-space: pre;">&#8288; &#8288;</code>list of length J with the knots associated to each of the J additive terms.
</p>
</li>
<li><p><code>Bcal</code> : <code style="white-space: pre;">&#8288; &#8288;</code>column-stacked matrix with the J centered B-spline bases.
</p>
</li>
<li><p><code>Xcal</code> : <code style="white-space: pre;">&#8288; &#8288;</code>Z column-stacked with the J centered B-spline bases to yield the full design matrix (with column labels).
</p>
</li>
<li><p><code>pen.order</code> : <code style="white-space: pre;">&#8288; &#8288;</code>penalty order for the spline parameters in the additive terms.
</p>
</li>
<li><p><code>additive.lab</code> : <code style="white-space: pre;">&#8288; &#8288;</code>labels for the columns in &lt;Bcal&gt; associated to the additive terms.
</p>
</li>
<li><p><code>lambda.lab</code> : <code style="white-space: pre;">&#8288; &#8288;</code>labels for the penalty parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>

<hr>
<h2 id='logDet.fun'>Log-determinant of a positive-definite matrix</h2><span id='topic+logDet.fun'></span>

<h3>Description</h3>

<p>Log-determinant of a positive-definite matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logDet.fun(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logDet.fun_+3A_x">x</code></td>
<td>
<p>positive definite matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log of det(x).
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(1:4,ncol=2)
logDet.fun(A)

</code></pre>

<hr>
<h2 id='Pcal.fun'>Generation of the penalty matrix for an additive model based on P-splines</h2><span id='topic+Pcal.fun'></span>

<h3>Description</h3>

<p>Compute the penalty matrix associated to a vector containing fixed (non-penalized) parameters and equal-size sub-vectors of penalized B-spline parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pcal.fun(nfixed, lambda, Pd.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pcal.fun_+3A_nfixed">nfixed</code></td>
<td>
<p>the number of fixed (i.e. non-penalized) parameters.</p>
</td></tr>
<tr><td><code id="Pcal.fun_+3A_lambda">lambda</code></td>
<td>
<p>a vector of <code>p</code> penalty parameters where each component is associated to a sub-vector of spline parameters of length <code>J</code>.</p>
</td></tr>
<tr><td><code id="Pcal.fun_+3A_pd.x">Pd.x</code></td>
<td>
<p>a penalty matrix of size <code>J</code> associated to a given sub-vector of spline parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A block diagonal penalty matrix of size <code>(nfixed+pJ)</code> given by Blockdiag(diag(0,<code>nfixed</code>), diag(<code>lambda</code>).kron.<code>Pd.x</code>).
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D = diff(diag(5),diff=2) ## Difference penalty matrix of order 2 for 5 P-spline parameters
P = t(D) %*% D ## Penalty matrix of order 2 for 5 B-spline parameters
lambda = c(100,10) ## Penalty parameters for 2 additive terms with 5 B-spline parameters each
Pcal.fun(3,lambda,P) ## Global penalty matrix for 3 additional non-penalized parameters
</code></pre>

<hr>
<h2 id='plot.DALSM'>Plot visual information on a <code>DALSM.object</code></h2><span id='topic+plot.DALSM'></span>

<h3>Description</h3>

<p>Visualize the estimated additive terms and error density corresponding to a Double Additive Location-Scale Model (DALSM) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DALSM'
plot(x,
       mfrow.loc=NULL, mfrow.disp=NULL,
       nx=101, equal.ylims=TRUE, true.loc=NULL,true.disp=NULL, ci.level=NULL,
       error.lim = NULL, add.residuals=FALSE, true.derr=NULL, new.dev=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DALSM_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+DALSM.object">DALSM.object</a></code>.</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_mfrow.loc">mfrow.loc</code></td>
<td>
<p>(optional) window layout to plot the additive terms for location.</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_mfrow.disp">mfrow.disp</code></td>
<td>
<p>(optional) window layout to plot the additive terms for dispersion.</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_nx">nx</code></td>
<td>
<p>(optional) number of points to make the plots for the fitted additive terms (default: 101).</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_equal.ylims">equal.ylims</code></td>
<td>
<p>logical indicating if the same y-limits must be used when plotting the fitted additive terms (default: TRUE).</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_true.loc">true.loc</code></td>
<td>
<p>(optional) list of functions to be superposed to the corresponding estimated additive terms in the location submodel (default: NULL).</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_true.disp">true.disp</code></td>
<td>
<p>(optional) list of functions to be superposed to the corresponding estimated additive terms in the dispersion submodel (default: NULL).</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_ci.level">ci.level</code></td>
<td>
<p>(optional) nominal level for the plotted pointwise credible intervals (default: x$ci.level).</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_error.lim">error.lim</code></td>
<td>
<p>(optional) plotting interval for the estimated standardized error density in the DALSM model (default: support of the fitted standardized error density).</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_add.residuals">add.residuals</code></td>
<td>
<p>logical requesting to add the (possibly censored) standardized residuals to the plot of the fitted standardized error density (default: FALSE).</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_true.derr">true.derr</code></td>
<td>
<p>(optional) density function to superpose to the estimated standardized error density when plotting (default: NULL).</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_new.dev">new.dev</code></td>
<td>
<p>(optional) logical indicating whether a new plotting device must be opened for each graph (default: TRUE).</p>
</td></tr>
<tr><td><code id="plot.DALSM_+3A_...">...</code></td>
<td>
<p>additional generic plotting arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the fitted additive terms and the estimated standardized error density contained in the <code><a href="#topic+DALSM.object">DALSM.object</a></code> <code>x</code>.
</p>


<h3>Value</h3>

<p>In addition to the plots, an invisible list containing the following is returned:
</p>

<ul>
<li><p><code>J1</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of additive terms in the location sub-model.
</p>
</li>
<li><p><code>x.loc</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a <code>nx</code> by <code>J1</code> matrix containing a regular grid of <code>nx</code> covariate values where the corresponding additive term in location is evaluated.
</p>
</li>
<li><p><code>f.loc</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a <code>nx</code> by <code>J1</code> matrix containing the <code>J1</code> fitted location additive terms evaluated at <code>x.loc</code>.
</p>
</li>
<li><p><code>se.loc</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a <code>nx</code> by <code>J1</code> matrix containing the the pointwise standard errors of the fitted location additive terms evaluated at <code>x.loc</code>.
</p>
</li>
<li><p><code>J2</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of additive terms in the dispersion sub-model.
</p>
</li>
<li><p><code>x.disp</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a <code>nx</code> by <code>J2</code> matrix containing a regular grid of <code>nx</code> covariate values where the corresponding additive term in dispersion is evaluated.
</p>
</li>
<li><p><code>f.disp</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a <code>nx</code> by <code>J2</code> matrix containing the <code>J2</code> fitted dispersion additive terms evaluated at <code>x.disp</code>.
</p>
</li>
<li><p><code>se.disp</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a <code>nx</code> by <code>J2</code> matrix containing the pointwise standard errors of the fitted dispersion additive terms evaluated at <code>x.disp</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DALSM">DALSM</a></code>, <code><a href="#topic+DALSM.object">DALSM.object</a></code>, <code><a href="#topic+print.DALSM">print.DALSM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
            formula1 = ~twoincomes+s(age)+s(eduyrs),
            formula2 = ~twoincomes+s(age)+s(eduyrs),
            data = DALSM_IncomeData)
plot(fit)

</code></pre>

<hr>
<h2 id='plot.densLPS'>Plot the density estimate in a <code>densLPS.object</code></h2><span id='topic+plot.densLPS'></span>

<h3>Description</h3>

<p>Plot the density estimate obtained by <code>densityLPS</code> from censored data with given mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'densLPS'
plot(x,
       xlim=range(fit$bins),breaks=NULL,hist=FALSE,histRC=FALSE,
       xlab="",ylab="Density",main="",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.densLPS_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+densLPS.object">densLPS.object</a></code>.</p>
</td></tr>
<tr><td><code id="plot.densLPS_+3A_xlim">xlim</code></td>
<td>
<p>interval of values where the density should be plotted.</p>
</td></tr>
<tr><td><code id="plot.densLPS_+3A_breaks">breaks</code></td>
<td>
<p>(Optional) breaks for the histogram of the observed residuals.</p>
</td></tr>
<tr><td><code id="plot.densLPS_+3A_hist">hist</code></td>
<td>
<p>Logical (Default: FALSE) indicating whether the histogram of the (pseudo-) data should be plotted with the estimated density.</p>
</td></tr>
<tr><td><code id="plot.densLPS_+3A_histrc">histRC</code></td>
<td>
<p>Logical (Default: FALSE) indicating whether the histogram of the right-censored residuals should be highlighted.</p>
</td></tr>
<tr><td><code id="plot.densLPS_+3A_xlab">xlab</code></td>
<td>
<p>Optional label for the x-axis (Defaut: empty).</p>
</td></tr>
<tr><td><code id="plot.densLPS_+3A_ylab">ylab</code></td>
<td>
<p>Optional label for the y-axis (Default: &quot;Density&quot;).</p>
</td></tr>
<tr><td><code id="plot.densLPS_+3A_main">main</code></td>
<td>
<p>Plot main title (Default: &quot;&quot;).</p>
</td></tr>
<tr><td><code id="plot.densLPS_+3A_...">...</code></td>
<td>
<p>Optional additional plot parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returned value (just plots).
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densLPS.object">densLPS.object</a></code>, <code><a href="#topic+print.densLPS">print.densLPS</a></code>, <code><a href="#topic+densityLPS">densityLPS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DALSM)

## Example 1: density estimation from simulated IC data
n = 500 ## Sample size
x = 3 + rgamma(n,10,2) ## Exact generated data
width = runif(n,1,3) ## Width of the IC data (mean width = 2)
w = runif(n) ## Positioning of the exact data within the interval
xmat = cbind(x-w*width,x+(1-w)*width) ## Generated IC data
head(xmat)
obj.data = Dens1d(xmat,ymin=0) ## Prepare the data for estimation
## Density estimation with fixed mean and variance
obj = densityLPS(obj.data,Mean0=3+10/2,Var0=10/4)
plot(obj, hist=TRUE) ## Histogram of the pseudo-data with the density estimate
curve(dgamma(x-3,10,2), ## ... compared to the true density (in red)
      add=TRUE,col="red",lwd=2,lty=2)
legend("topright",col=c("black","red","grey"),lwd=c(2,2,10),lty=c(1,2,1),
       legend=c("Fitted density","True density","Pseudo-data"),bty="n")
print(obj) ## ... with summary statistics

## Example 2: estimation of the error density in a DALSM model
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
            formula1 = ~twoincomes+s(age)+s(eduyrs),
            formula2 = ~twoincomes+s(age)+s(eduyrs),
            data = DALSM_IncomeData)
plot(fit$derr, hist=TRUE)  ## Plot the estimated error density
legend("topright",col=c("black","grey"),lwd=c(2,10),lty=c(1,1),
       legend=c("Estimated error density","Pseudo-residuals"),bty="n")
print(fit$derr) ## ... and provide summary statistics for it
</code></pre>

<hr>
<h2 id='plotRegion'>Plot a credible region for a curve together with its point estimates</h2><span id='topic+plotRegion'></span>

<h3>Description</h3>

<p>Plot a credible region (in grey) for a curve together with its point estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRegion(x,mat,
       add=FALSE, xlim=range(x), ylim=range(mat),
       lwd=2, xlab="", ylab="", main="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRegion_+3A_x">x</code></td>
<td>
<p>vector of values where the curve is evaluated.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_mat">mat</code></td>
<td>
<p>cbind(f.hat,f.low,f.up) is a matrix containing the point estimates &lt;f.hat&gt; and the liming values &lt;f.low&gt; and &lt;f.up&gt; for the credible region.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_add">add</code></td>
<td>
<p>Logical indicating if the plot must be added to the active plot (Default: FALSE).</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_xlim">xlim</code></td>
<td>
<p>range of &lt;x&gt; values for which the plot should be provided.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_ylim">ylim</code></td>
<td>
<p>range of curve values that should be considered for the plot.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_lwd">lwd</code></td>
<td>
<p>line width for the plot (Default: 2).</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_xlab">xlab</code></td>
<td>
<p>x-label.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_ylab">ylab</code></td>
<td>
<p>y-label.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_...">...</code></td>
<td>
<p>optional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returned value (just a plot)
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DALSM">DALSM</a></code>, <code><a href="#topic+DALSM.object">DALSM.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
            formula1 = ~twoincomes+s(age)+s(eduyrs),
            formula2 = ~twoincomes+s(age)+s(eduyrs),
            data = DALSM_IncomeData)
obj = DALSM_additive(fit)
## par(mfrow=c(1,2),mar=c(4,5,1,1))
with(obj$f.loc.grid$age, plotRegion(x, y.mat,
     xlab="age", ylab=expression('f'[1]^{~mu}*(age))))
with(obj$f.disp.grid$age, plotRegion(x, y.mat,
     xlab="age", ylab=expression('f'[1]^{~sigma}*(age))))
</code></pre>

<hr>
<h2 id='predict.DALSM'>Prediction based on a DALSM model</h2><span id='topic+predict.DALSM'></span>

<h3>Description</h3>

<p>Estimated conditional mean and standard deviation of the response based on a DALSM object
for given covariate values in a data frame 'newdata'. Conditional quantiles can also
be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DALSM'
predict(object, newdata, probs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.DALSM_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+DALSM.object">DALSM.object</a></code>.</p>
</td></tr>
<tr><td><code id="predict.DALSM_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables with which to predict. If omitted, the covariate values in the original data frame used to fit the DALSM model are considered.</p>
</td></tr>
<tr><td><code id="predict.DALSM_+3A_probs">probs</code></td>
<td>
<p>probability levels of the requested conditional quantiles.</p>
</td></tr>
<tr><td><code id="predict.DALSM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>

<ul>
<li><p><code>mu</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated conditional mean.
</p>
</li>
<li><p><code>sd</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated conditional standard deviation.
</p>
</li>
<li><p><code>quant</code> : <code style="white-space: pre;">&#8288; &#8288;</code>estimated quantiles (at probability level <code>probs</code>) of the fitted conditional response in the DALSM model.
</p>
</li>
<li><p><code>qerr</code> : <code style="white-space: pre;">&#8288; &#8288;</code>quantiles (at probability level <code>probs</code>) of the fitted error distribution in the DALSM model.
</p>
</li>
<li><p><code>probs</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a reminder of the requested probability levels for the fitted quantiles.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DALSM.object">DALSM.object</a></code>, <code><a href="#topic+print.DALSM">print.DALSM</a></code>, <code><a href="#topic+plot.DALSM">plot.DALSM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
            formula1 = ~twoincomes+s(age)+s(eduyrs),
            formula2 = ~twoincomes+s(age)+s(eduyrs),
            data = DALSM_IncomeData)
data2 = data.frame(age=c(40,60),eduyrs=c(18,12))
predict(fit, data = DALSM_IncomeData, newdata=data2, probs=c(.2,.5,.8))
</code></pre>

<hr>
<h2 id='print.DALSM'>Print summary information on a <code>DALSM.object</code></h2><span id='topic+print.DALSM'></span>

<h3>Description</h3>

<p>Print summary information on a <code>DALSM.object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DALSM'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.DALSM_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+DALSM.object">DALSM.object</a></code>.</p>
</td></tr>
<tr><td><code id="print.DALSM_+3A_...">...</code></td>
<td>
<p>additional generic printing arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides summary measures on the estimation of the regression parameters and additive terms
in the location and dispersion submodels corresponding to a <code><a href="#topic+DALSM.object">DALSM.object</a></code> generated by <code><a href="#topic+DALSM">DALSM</a></code>.
</p>


<h3>Value</h3>

<p>No returned value (just printed summary).
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.DALSM">plot.DALSM</a></code>, <code><a href="#topic+DALSM.object">DALSM.object</a></code>, <code><a href="#topic+DALSM">DALSM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
            formula1 = ~twoincomes+s(age)+s(eduyrs),
            formula2 = ~twoincomes+s(age)+s(eduyrs),
            data = DALSM_IncomeData)
print(fit)

</code></pre>

<hr>
<h2 id='print.densLPS'>Print a summary of the information in a <code>densLPS.object</code></h2><span id='topic+print.densLPS'></span>

<h3>Description</h3>

<p>Print summary information on the density estimate obtained by <code>densityLPS</code> from censored data with given mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'densLPS'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.densLPS_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+densLPS.object">densLPS.object</a></code>.</p>
</td></tr>
<tr><td><code id="print.densLPS_+3A_...">...</code></td>
<td>
<p>Optional additional print parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returned value (just printed summary).
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021). Fast Bayesian inference using Laplace approximations
in nonparametric double additive location-scale models with right- and
interval-censored data.
<em>Computational Statistics and Data Analysis</em>, 161: 107250.
&lt;doi:10.1016/j.csda.2021.107250&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densLPS.object">densLPS.object</a></code>, <code><a href="#topic+plot.densLPS">plot.densLPS</a></code>, <code><a href="#topic+densityLPS">densityLPS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DALSM)
data(DALSM_IncomeData)
resp = DALSM_IncomeData[,1:2]
fit = DALSM(y=resp,
            formula1 = ~twoincomes+s(age)+s(eduyrs),
            formula2 = ~twoincomes+s(age)+s(eduyrs),
            data = DALSM_IncomeData)
plot(fit$derr)  ## Plot the estimated error density
print(fit$derr) ## ... and provide some descriptive elements on it

</code></pre>

<hr>
<h2 id='qknots'>Specification of knots in a cubic P-spline model</h2><span id='topic+qknots'></span>

<h3>Description</h3>

<p>Specification of knots for a cubic B-spline basis with <code>K</code> elements in
a P-spline model. The knots should support the data contained in vector <code>x</code>
and are by default assumed equidistant. Alternatively, they can be based
on the data quantiles. The penalty matrix of the selected penalty order
(3 by default) is also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qknots(x, xmin = NULL, xmax = NULL, equid.knots = TRUE, pen.order = 3, K = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qknots_+3A_x">x</code></td>
<td>
<p>data that the knots should upport.</p>
</td></tr>
<tr><td><code id="qknots_+3A_xmin">xmin</code></td>
<td>
<p>desired minimum value for the knots.</p>
</td></tr>
<tr><td><code id="qknots_+3A_xmax">xmax</code></td>
<td>
<p>desired maximum value for the knots.</p>
</td></tr>
<tr><td><code id="qknots_+3A_equid.knots">equid.knots</code></td>
<td>
<p>logical indicating if equidistant knots are desired (Default: TRUE). If FALSE, the quantile of <code>x</code> are used to select the knots.</p>
</td></tr>
<tr><td><code id="qknots_+3A_pen.order">pen.order</code></td>
<td>
<p>penalty order if <code>equid.knots</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="qknots_+3A_k">K</code></td>
<td>
<p>number of B-splines in the basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p><code>xmin</code> : <code style="white-space: pre;">&#8288; &#8288;</code>specified minimum value for the knots, except if <code class="reqn">\min(x) &lt; xmin</code>, in which case the default value <code class="reqn">\min(x)-sd(x)</code> is returned.
</p>
</li>
<li><p><code>xmin</code> : <code style="white-space: pre;">&#8288; &#8288;</code>specified maximum value for the knots, except if <code class="reqn">xmax &lt; \max(x)</code>, in which case the default value <code class="reqn">\max(x)+sd(x)</code> is returned.
</p>
</li>
<li><p><code>K</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of B-splines.
</p>
</li>
<li><p><code>knots</code> : <code style="white-space: pre;">&#8288; &#8288;</code>equidistant knots on (xmin,xmax) if <code>equidistant.knots</code> is TRUE, based on quantiles of <code>x</code> otherwise.
</p>
</li>
<li><p><code>Pd</code> : <code style="white-space: pre;">&#8288; &#8288;</code><code class="reqn">K\times K</code> penalty matrix of order <code>pen.order</code>.
</p>
</li>
<li><p><code>pen.order</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a reminder of the requested penalty order (Default: 3).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x = runif(500)
obj = qknots(x,xmin=0,xmax=1,K=13)
print(obj)
</code></pre>

<hr>
<h2 id='s'>Specification of smooth terms in formulas in the DALSM function.</h2><span id='topic+s'></span>

<h3>Description</h3>

<p>Specification of smooth terms in formulas in the DALSM function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_+3A_x">x</code></td>
<td>
<p>Name of the variable for which an additive term is requested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The submitted variable for which an additive term is required
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
