<!DOCTYPE html><html><head><title>Help for package tripack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tripack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.constraint'>
<p>Add a constraint to an triangulaion object</p></a></li>
<li><a href='#cells'><p> extract info about voronoi cells</p></a></li>
<li><a href='#circles'><p> plot circles</p></a></li>
<li><a href='#circtest'><p> circtest / sample data</p></a></li>
<li><a href='#circum'>
<p>Determine the circumcircle of a triangle</p></a></li>
<li><a href='#circumcircle'>
<p>Determine the circumcircle of a set of points</p></a></li>
<li><a href='#convex.hull'><p>Return the convex hull of a triangulation object</p></a></li>
<li><a href='#identify.tri'><p>Identify points in a triangulation plot</p></a></li>
<li><a href='#in.convex.hull'><p>Determines if points are in the convex hull of a triangulation object</p></a></li>
<li><a href='#left'>
<p>Determines whether given points are left of a directed edge.</p></a></li>
<li><a href='#neighbours'><p>List of neighbours from a triangulation object</p></a></li>
<li><a href='#on.convex.hull'><p>Determines if points are on the convex hull of a triangulation object</p></a></li>
<li><a href='#outer.convhull'><p>Version of outer which operates only in a convex hull</p></a></li>
<li><a href='#plot.tri'><p>Plot a triangulation object</p></a></li>
<li><a href='#plot.voronoi'><p>Plot a voronoi object</p></a></li>
<li><a href='#plot.voronoi.polygons'><p>plots an voronoi.polygons object</p></a></li>
<li><a href='#print.summary.tri'><p>Print a summary of a triangulation object</p></a></li>
<li><a href='#print.summary.voronoi'><p>Print a summary of a voronoi object</p></a></li>
<li><a href='#print.tri'><p>Print a triangulation object</p></a></li>
<li><a href='#print.voronoi'><p>Print a voronoi object</p></a></li>
<li><a href='#summary.tri'><p>Return a summary of a triangulation object</p></a></li>
<li><a href='#summary.voronoi'><p>Return a summary of a voronoi object</p></a></li>
<li><a href='#tri'><p>A triangulation object</p></a></li>
<li><a href='#tri.dellens'><p>Compute the Delaunay segment lengths</p></a></li>
<li><a href='#tri.find'><p>Locate a point in a triangulation</p></a></li>
<li><a href='#tri.mesh'>
<p>Create a delaunay triangulation</p></a></li>
<li><a href='#triangles'><p>Extract a list of triangles from a triangulation object</p></a></li>
<li><a href='#tripack-internal'><p>Internal functions</p></a></li>
<li><a href='#tritest'><p> tritest / sample data</p></a></li>
<li><a href='#voronoi'><p>Voronoi object</p></a></li>
<li><a href='#voronoi.area'><p>Calculate area of Voronoi polygons</p></a></li>
<li><a href='#voronoi.findrejectsites'><p>Find the Voronoi sites at the border of the region (to be rejected).</p></a></li>
<li><a href='#voronoi.mosaic'><p>Create a Voronoi mosaic</p></a></li>
<li><a href='#voronoi.polygons'><p> extract polygons from a voronoi mosaic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3-9.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Triangulation of Irregularly Spaced Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Fortran code by R. J. Renka.
        R functions by Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;.
        With contributions from Stephen Eglen &lt;stephen@anc.ed.ac.uk&gt;,
        Sergei Zuyev &lt;sergei@stams.strath.ac.uk&gt; and
	Denis White &lt;white.denis@epamail.epa.gov&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A constrained two-dimensional Delaunay triangulation package
  providing both triangulation and generation of voronoi mosaics of 
  irregular spaced data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.acm.org/publications/policies/software-copyright-notice">ACM</a> | file LICENSE</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-06</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-30 08:51:35 UTC; ripley</td>
</tr>
<tr>
<td>License_restricts_use:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-30 09:50:58 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.3.0; x86_64-pc-linux-gnu; 2022-06-22 12:17:42 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='add.constraint'>
Add a constraint to an triangulaion object
</h2><span id='topic+add.constraint'></span>

<h3>Description</h3>

<p>This subroutine provides for creation of a constrained
Delaunay triangulation which, in some sense, covers an
arbitrary connected region R rather than the convex hull
of the nodes.  This is achieved simply by forcing the
presence of certain adjacencies (triangulation arcs) corresponding
to constraint curves.  The union of triangles
coincides with the convex hull of the nodes, but triangles
in R can be distinguished from those outside of R.  The
only modification required to generalize the definition of
the Delaunay triangulation is replacement of property 5
(refer to <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> by the following:
</p>
<p>5')  If a node is contained in the interior of the circumcircle
of a triangle, then every interior point
of the triangle is separated from the node by a
constraint arc.
</p>
<p>In order to be explicit, we make the following definitions.
A constraint region is the open interior of a
simple closed positively oriented polygonal curve defined
by an ordered sequence of three or more distinct nodes
(constraint nodes) P(1),P(2),...,P(K), such that P(I) is
adjacent to P(I+1) for I = 1,...,K with P(K+1) = P(1).
Thus, the constraint region is on the left (and may have
nonfinite area) as the sequence of constraint nodes is
traversed in the specified order.  The constraint regions
must not contain nodes and must not overlap.  The region
R is the convex hull of the nodes with constraint regions
excluded.
</p>
<p>Note that the terms boundary node and boundary arc are
reserved for nodes and arcs on the boundary of the convex
hull of the nodes.
</p>
<p>The algorithm is as follows:  given a triangulation
which includes one or more sets of constraint nodes, the
corresponding adjacencies (constraint arcs) are forced to
be present (Fortran subroutine EDGE).  Any additional new arcs
required are chosen to be locally optimal (satisfy the
modified circumcircle property).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.constraint(tri.obj,cstx,csty,reverse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.constraint_+3A_tri.obj">tri.obj</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
<tr><td><code id="add.constraint_+3A_cstx">cstx</code></td>
<td>
<p>vector containing x coordinates of the constraint curve.</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_csty">csty</code></td>
<td>
<p>vector containing y coordinates of the constraint curve.</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_reverse">reverse</code></td>
<td>
<p>if <code>TRUE</code> the orientation of the constraint curve
is reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An new object of class <code>"tri"</code>.</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>, <code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>, <code><a href="igraph.html#topic+triangles">triangles</a></code>, <code><a href="igraph.html#topic+convex.hull">convex.hull</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># we will use the simple test data from TRIPACK:
data(tritest)
tritest.tr&lt;-tri.mesh(tritest)
opar&lt;-par(mfrow=c(2,2))
plot(tritest.tr)
# include all points in a big triangle:
tritest.tr&lt;-add.constraint(tritest.tr,c(-0.1,2,-0.1),
                                      c(-3,0.5,3),reverse=TRUE)
# insert a small cube:
tritest.tr &lt;- add.constraint(tritest.tr, c(0.4, 0.4,0.6, 0.6), 
                                         c(0.6, 0.4,0.4, 0.6), 
                                         reverse = FALSE)
par(opar)
</code></pre>

<hr>
<h2 id='cells'> extract info about voronoi cells </h2><span id='topic+cells'></span>

<h3>Description</h3>

<p>This function returns some info about the cells of a voronoi mosaic,
including the coordinates of the vertices and the cell area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cells(voronoi.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cells_+3A_voronoi.obj">voronoi.obj</code></td>
<td>
<p> object of class <code>voronoi</code>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the neighbourhood relations between the
underlying triangulation and translates it into the neighbourhood
relations between the voronoi cells.
</p>


<h3>Value</h3>

<p>retruns a list of lists, one entry for each voronoi cell which contains
</p>
<table>
<tr><td><code>cell</code></td>
<td>
<p>cell index</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>cell 'center'</p>
</td></tr>
<tr><td><code>neighbours</code></td>
<td>
<p>neighbour cell indices</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>2 times <code>nnb</code> matrix with vertice coordinates</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>cell area</p>
</td></tr>
</table>


<h3>Note</h3>

<p> outer cells have <code>area=NA</code>, currently also <code>nodes=NA</code>
which is not really useful &ndash; to be done later </p>


<h3>Author(s)</h3>

<p> A. Gebhardt </p>


<h3>See Also</h3>

  <p><code><a href="interp.html#topic+voronoi.mosaic">voronoi.mosaic</a></code>,  <code><a href="interp.html#topic+voronoi.area">voronoi.area</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tritest)
tritest.vm &lt;- voronoi.mosaic(tritest$x,tritest$y)
tritest.cells &lt;- cells(tritest.vm)
# higlight cell 12:
plot(tritest.vm)
polygon(t(tritest.cells[[12]]$nodes),col="green")
# put cell area into cell center:
text(tritest.cells[[12]]$center[1],
     tritest.cells[[12]]$center[2],
     tritest.cells[[12]]$area)
</code></pre>

<hr>
<h2 id='circles'> plot circles </h2><span id='topic+circles'></span>

<h3>Description</h3>

<p>This function plots circles at given locations with given radii.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circles(x, y, r, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circles_+3A_x">x</code></td>
<td>
<p> vector of x coordinates </p>
</td></tr>
<tr><td><code id="circles_+3A_y">y</code></td>
<td>
<p> vector of y coordinates </p>
</td></tr>
<tr><td><code id="circles_+3A_r">r</code></td>
<td>
<p> vactor of radii </p>
</td></tr>
<tr><td><code id="circles_+3A_...">...</code></td>
<td>
<p> additional graphic parameters will be passed through </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function needs a previous plot where it adds the circles.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>See Also</h3>

  <p><code><a href="graphics.html#topic+lines">lines</a></code>,
<code><a href="graphics.html#topic+points">points</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rnorm(10)
y&lt;-rnorm(10)
r&lt;-runif(10,0,0.5)
plot(x,y, xlim=c(-3,3), ylim=c(-3,3), pch="+")
circles(x,y,r)
</code></pre>

<hr>
<h2 id='circtest'> circtest / sample data </h2><span id='topic+circtest'></span><span id='topic+circtest2'></span>

<h3>Description</h3>

<p>Sample data for the <code>link{circumcircle}</code> function.
</p>
<p><code>circtest2</code> are points sampled from a circle with some jitter
added, i.e. they represent the most complicated case for the
<code>link{circumcircle}</code> function.
</p>

<hr>
<h2 id='circum'>
Determine the circumcircle of a triangle
</h2><span id='topic+circum'></span>

<h3>Description</h3>

<p>This function returns the circumcircle of a triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circum(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circum_+3A_x">x</code></td>
<td>
<p>Vector of three elements, giving the x coordinatres of the
triangle nodes.
</p>
</td></tr>
<tr><td><code id="circum_+3A_y">y</code></td>
<td>
<p>Vector of three elements, giving the y coordinatres of the
triangle nodes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an interface to the Fortran function CIRCUM found in TRIPACK.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p> 'x' coordinate of center</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> 'y' coordinate of center</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p> circumcircle radius </p>
</td></tr>
<tr><td><code>signed.area</code></td>
<td>
<p> signed area of riangle (positive iff nodes are
numbered counter clock wise) </p>
</td></tr>
<tr><td><code>aspect.ratio</code></td>
<td>
<p> ratio &quot;radius of inscribed circle&quot;/&quot;radius of
circumcircle&quot;, varies between 0 and 0.5
</p>
<p>0 means collinear points, 0.5 equilateral trangle.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is mainly intended to be used by <code><a href="interp.html#topic+circumcircle">circumcircle</a></code>.
</p>


<h3>Author(s)</h3>

<p>Fortran code: R. J. Renka, R code: A. Gebhardt
</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+circumcircle">circumcircle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circum(c(0,1,0),c(0,0,1))
</code></pre>

<hr>
<h2 id='circumcircle'>
Determine the circumcircle of a set of points
</h2><span id='topic+circumcircle'></span>

<h3>Description</h3>

<p>This function returns the (smallest) circumcircle of a set of n points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circumcircle(x, y = NULL, num.touch=2, plot = FALSE, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circumcircle_+3A_x">x</code></td>
<td>
<p>vector containing x coordinates of the data. If <code>y</code> is missing
<code>x</code> should contain two elements <code>$x</code> and <code>$y</code>.
</p>
</td></tr>
<tr><td><code id="circumcircle_+3A_y">y</code></td>
<td>
<p>vector containing y coordinates of the data.
</p>
</td></tr>
<tr><td><code id="circumcircle_+3A_num.touch">num.touch</code></td>
<td>

<p>How often should the resulting circle touch the convex hull of the
given points?
</p>
<p>default: 2
</p>
<p>possible values: 2 or 3
</p>
<p>Note: The circumcircle of a triangle is usually defined to touch
at 3 points, this function searches by default the minimum circle,
which may be only touching at 2 points. Set parameter
<code>num.touch</code> accordingly if you dont want the default behaviour!
</p>
</td></tr>
<tr><td><code id="circumcircle_+3A_plot">plot</code></td>
<td>
<p>Logical, produce a simple plot of the result.
</p>
<p>default: <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="circumcircle_+3A_debug">debug</code></td>
<td>
<p>Logical, more plots, only needed for debugging.
</p>
<p>default: <code>FALSE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a (naive implemented) algorithm which determines the smallest
circumcircle of n points:
</p>
<p>First step: Take the convex hull.
</p>
<p>Second step: Determine two points on the convex hull with maximum
distance for the diameter of the set.
</p>
<p>Third step: Check if the circumcircle of these two points already
contains all other points (of the convex hull and hence all other points).
</p>
<p>If not or if 3 or more touching points are desired
(<code>num.touch=3</code>), 
search a point with minimum enclosing circumcircle among the
remaining points of the convex hull.
</p>
<p>If such a point cannot be found (e.g. for <code>data(circtest2)</code>),
search the remaining triangle combinations of points from the convex
hull until an enclosing circle with minimum radius is found.
</p>
<p>The last search uses an upper and lower bound for the desired miniumum
radius:
</p>
<p>Any enclosing rectangle and its circumcircle gives an upper bound (the
axis-parallel rectangle is used).
</p>
<p>Half the diameter of the set from step 1 is a lower bound.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>'x' coordinate of circumcircle center</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>'y' coordinate of circumcircle center</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>radius of circumcircle</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+convex.hull">convex.hull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(circtest)
 # smallest circle:
 circumcircle(circtest,num.touch=2,plot=TRUE)

 # smallest circle with maximum touching points (3):
 circumcircle(circtest,num.touch=3,plot=TRUE)

 # some stress test for this function,
 data(circtest2)
 # circtest2 was generated by:
 # 100 random points almost one a circle:
 # alpha &lt;- runif(100,0,2*pi)
 # x &lt;- cos(alpha)
 # y &lt;- sin(alpha)
 # circtest2&lt;-list(x=cos(alpha)+runif(100,0,0.1),
 #                 y=sin(alpha)+runif(100,0,0.1))
 #  
 circumcircle(circtest2,plot=TRUE)

</code></pre>

<hr>
<h2 id='convex.hull'>Return the convex hull of a triangulation object</h2><span id='topic+convex.hull'></span>

<h3>Description</h3>

<p>Given a triangulation <code>tri.obj</code> of <code class="reqn">n</code> points in the plane, this
subroutine returns two vectors containing the coordinates
of the nodes on the boundary of the convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convex.hull(tri.obj, plot.it=FALSE, add=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convex.hull_+3A_tri.obj">tri.obj</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
<tr><td><code id="convex.hull_+3A_plot.it">plot.it</code></td>
<td>
<p>logical, if <code>TRUE</code> the convex hull of
<code>tri.obj</code> will be plotted.</p>
</td></tr>
<tr><td><code id="convex.hull_+3A_add">add</code></td>
<td>
<p>logical. if <code>TRUE</code> (and <code>plot.it=TRUE</code>), add to
a current plot.</p>
</td></tr>
<tr><td><code id="convex.hull_+3A_...">...</code></td>
<td>
<p>additional plot arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>x coordinates of boundary nodes.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y coordinates of boundary nodes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>, <code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>, <code><a href="igraph.html#topic+triangles">triangles</a></code>, <code><a href="tripack.html#topic+add.constraint">add.constraint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rather simple example from TRIPACK:
data(tritest)
tr&lt;-tri.mesh(tritest$x,tritest$y)
convex.hull(tr,plot.it=TRUE)
# random points:
rand.tr&lt;-tri.mesh(runif(10),runif(10))
plot(rand.tr)
rand.ch&lt;-convex.hull(rand.tr, plot.it=TRUE, add=TRUE, col="red")
# use a part of the quakes data set:
data(quakes)
quakes.part&lt;-quakes[(quakes[,1]&lt;=-17 &amp; quakes[,1]&gt;=-19.0 &amp;
                     quakes[,2]&lt;=182.0 &amp; quakes[,2]&gt;=180.0),]
quakes.tri&lt;-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
plot(quakes.tri)
convex.hull(quakes.tri, plot.it=TRUE, add=TRUE, col="red")
</code></pre>

<hr>
<h2 id='identify.tri'>Identify points in a triangulation plot</h2><span id='topic+identify.tri'></span>

<h3>Description</h3>

<p>Identify points in a plot of <code>"x"</code> with its
coordinates. The plot of <code>"x"</code> must be generated with <code>plot.tri</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tri'
identify(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.tri_+3A_x">x</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
<tr><td><code id="identify.tri_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>identify</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector containing the indexes of the identified points.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>, <code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tritest)
tritest.tr&lt;-tri.mesh(tritest$x,tritest$y)
plot(tritest.tr)
identify.tri(tritest.tr)
</code></pre>

<hr>
<h2 id='in.convex.hull'>Determines if points are in the convex hull of a triangulation object</h2><span id='topic+in.convex.hull'></span>

<h3>Description</h3>

<p>Given a triangulation <code>tri.obj</code> of <code class="reqn">n</code> points in the plane, this
subroutine returns a logical vector indicating if the points
<code class="reqn">(x_i,y_i)</code>
are contained within the convex hull of <code>tri.obj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.convex.hull(tri.obj, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.convex.hull_+3A_tri.obj">tri.obj</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
<tr><td><code id="in.convex.hull_+3A_x">x</code></td>
<td>
<p>vector of x-coordinates of points to locate</p>
</td></tr>
<tr><td><code id="in.convex.hull_+3A_y">y</code></td>
<td>
<p>vector of y-coordinates of points to locate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>,
<code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>, <code><a href="igraph.html#topic+triangles">triangles</a></code>,
<code><a href="tripack.html#topic+add.constraint">add.constraint</a></code>, <code><a href="igraph.html#topic+convex.hull">convex.hull</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example from TRIPACK:
data(tritest)
tr&lt;-tri.mesh(tritest$x,tritest$y)
in.convex.hull(tr,0.5,0.5)
in.convex.hull(tr,c(0.5,-1,1),c(0.5,1,1))
# use a part of the quakes data set:
data(quakes)
quakes.part&lt;-quakes[(quakes[,1]&lt;=-10.78 &amp; quakes[,1]&gt;=-19.4 &amp;
                     quakes[,2]&lt;=182.29 &amp; quakes[,2]&gt;=165.77),]
q.tri&lt;-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
in.convex.hull(q.tri,quakes$lon[990:1000],quakes$lat[990:1000])
</code></pre>

<hr>
<h2 id='left'>
Determines whether given points are left of a directed edge.
</h2><span id='topic+left'></span><span id='topic+is.left.of'></span>

<h3>Description</h3>

<p>This function returns a logical vector indicating which elements of
the given points P0 are left of the directed edge P1-&gt;P2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left(x0, y0, x1, y1, x2, y2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="left_+3A_x0">x0</code></td>
<td>

<p>Numeric vector, 'x' coordinates of points P0 to check
</p>
</td></tr>
<tr><td><code id="left_+3A_y0">y0</code></td>
<td>

<p>Numeric vector, 'y' coordinates of points P0 to check, same length as 'x'.
</p>
</td></tr>
<tr><td><code id="left_+3A_x1">x1</code></td>
<td>

<p>'x' coordinate of point P1
</p>
</td></tr>
<tr><td><code id="left_+3A_y1">y1</code></td>
<td>

<p>'y' coordinate of point P1
</p>
</td></tr>
<tr><td><code id="left_+3A_x2">x2</code></td>
<td>

<p>'x' coordinate of point P2
</p>
</td></tr>
<tr><td><code id="left_+3A_y2">y2</code></td>
<td>

<p>'y' coordinate of point P2
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector.
</p>


<h3>Note</h3>

<p>This is an interface to the Fortran function VLEFT, wich is modeled
after TRIPACKs LEFT function but accepts more than one point P0.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+in.convex.hull">in.convex.hull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
left(c(0,0,1,1),c(0,1,0,1),0,0,1,1)
   
</code></pre>

<hr>
<h2 id='neighbours'>List of neighbours from a triangulation object</h2><span id='topic+neighbours'></span>

<h3>Description</h3>

<p>Extract a list of neighbours from a triangulation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbours(tri.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbours_+3A_tri.obj">tri.obj</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nested list of neighbours per point
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>, <code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>, <code><a href="igraph.html#topic+triangles">triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tritest)
tritest.tr&lt;-tri.mesh(tritest$x,tritest$y)
tritest.nb&lt;-neighbours(tritest.tr)
</code></pre>

<hr>
<h2 id='on.convex.hull'>Determines if points are on the convex hull of a triangulation object</h2><span id='topic+on.convex.hull'></span>

<h3>Description</h3>

<p>Given a triangulation <code>tri.obj</code> of <code class="reqn">n</code> points in the plane, this
subroutine returns a logical vector indicating if the points
<code class="reqn">(x_i,y_i)</code>
lay on the convex hull of <code>tri.obj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>on.convex.hull(tri.obj, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="on.convex.hull_+3A_tri.obj">tri.obj</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
<tr><td><code id="on.convex.hull_+3A_x">x</code></td>
<td>
<p>vector of x-coordinates of points to locate</p>
</td></tr>
<tr><td><code id="on.convex.hull_+3A_y">y</code></td>
<td>
<p>vector of y-coordinates of points to locate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>,
<code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>, <code><a href="igraph.html#topic+triangles">triangles</a></code>,
<code><a href="tripack.html#topic+add.constraint">add.constraint</a></code>, <code><a href="igraph.html#topic+convex.hull">convex.hull</a></code>, <code><a href="interp.html#topic+in.convex.hull">in.convex.hull</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example from TRIPACK:
data(tritest)
tr&lt;-tri.mesh(tritest$x,tritest$y)
on.convex.hull(tr,0.5,0.5)
on.convex.hull(tr,c(0.5,-1,1),c(0.5,1,1))
# use a part of the quakes data set:
data(quakes)
quakes.part&lt;-quakes[(quakes[,1]&lt;=-10.78 &amp; quakes[,1]&gt;=-19.4 &amp;
                     quakes[,2]&lt;=182.29 &amp; quakes[,2]&gt;=165.77),]
q.tri&lt;-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
on.convex.hull(q.tri,quakes.part$lon[1:20],quakes.part$lat[1:20])
</code></pre>

<hr>
<h2 id='outer.convhull'>Version of outer which operates only in a convex hull</h2><span id='topic+outer.convhull'></span>

<h3>Description</h3>

<p>This version of <code>outer</code> evaluates <code>FUN</code>
only on that part of the grid <code class="reqn">cx x cy</code> that is enclosed within
the convex hull of the points (<code>px</code>,<code>py</code>).
</p>
<p>This can be useful for spatial estimation if no extrapolation is wanted. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outer.convhull(cx,cy,px,py,FUN,duplicate="remove",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outer.convhull_+3A_cx">cx</code></td>
<td>
<p>x cordinates of grid</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_cy">cy</code></td>
<td>
<p>y cordinates of grid</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_px">px</code></td>
<td>
<p>vector of x coordinates of points</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_py">py</code></td>
<td>
<p>vector of y coordinates of points</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_fun">FUN</code></td>
<td>
<p>function to be evaluated over the grid</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_duplicate">duplicate</code></td>
<td>
<p>indicates what to do with duplicate
<code class="reqn">(px_i,py_i)</code> points, default <code>"remove"</code>.</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with values of <code>FUN</code> (<code>NA</code>s if outside the
convex hull).
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+in.convex.hull">in.convex.hull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-runif(20)
y&lt;-runif(20)
z&lt;-runif(20)
z.lm&lt;-lm(z~x+y)
f.pred&lt;-function(x,y)
  {predict(z.lm,data.frame(x=as.vector(x),y=as.vector(y)))}
xg&lt;-seq(0,1,0.05)
yg&lt;-seq(0,1,0.05)
image(xg,yg,outer.convhull(xg,yg,x,y,f.pred))
points(x,y)
</code></pre>

<hr>
<h2 id='plot.tri'>Plot a triangulation object</h2><span id='topic+plot.tri'></span>

<h3>Description</h3>

<p>plots the triangulation <code>"x"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tri'
plot(x, add=FALSE,xlim=range(x$x),ylim=range(x$y), 
  do.points=TRUE, do.labels = FALSE, isometric=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tri_+3A_x">x</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
<tr><td><code id="plot.tri_+3A_add">add</code></td>
<td>
<p>logical, if <code>TRUE</code>, add to a current plot.</p>
</td></tr>
<tr><td><code id="plot.tri_+3A_do.points">do.points</code></td>
<td>
<p>logical, indicates if points should be plotted.</p>
</td></tr>
<tr><td><code id="plot.tri_+3A_do.labels">do.labels</code></td>
<td>
<p>logical, indicates if points should be labelled</p>
</td></tr>
<tr><td><code id="plot.tri_+3A_xlim">xlim</code>, <code id="plot.tri_+3A_ylim">ylim</code></td>
<td>
<p>x/y ranges for plot</p>
</td></tr>
<tr><td><code id="plot.tri_+3A_isometric">isometric</code></td>
<td>
<p>generate an isometric plot (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot.tri_+3A_...">...</code></td>
<td>
<p>additional plot parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8. 
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, 
<code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># random points
plot(tri.mesh(rpois(100,lambda=20),rpois(100,lambda=20),duplicate="remove"))
# use a part of the quakes data set:
data(quakes)
quakes.part&lt;-quakes[(quakes[,1]&lt;=-10.78 &amp; quakes[,1]&gt;=-19.4 &amp;
                     quakes[,2]&lt;=182.29 &amp; quakes[,2]&gt;=165.77),]
quakes.tri&lt;-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
plot(quakes.tri)
# use the whole quakes data set 
# (will not work with standard memory settings, hence commented out)
#plot(tri.mesh(quakes$lon, quakes$lat, duplicate="remove"), do.points=F) 
</code></pre>

<hr>
<h2 id='plot.voronoi'>Plot a voronoi object</h2><span id='topic+plot.voronoi'></span>

<h3>Description</h3>

<p>Plots the mosaic <code>"x"</code>.
</p>
<p>Dashed lines are used for outer tiles of the mosaic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi'
plot(x,add=FALSE,
                           xlim=c(min(x$tri$x)-
                             0.1*diff(range(x$tri$x)),
                             max(x$tri$x)+
                             0.1*diff(range(x$tri$x))),
                           ylim=c(min(x$tri$y)-
                             0.1*diff(range(x$tri$y)),
                             max(x$tri$y)+
                             0.1*diff(range(x$tri$y))),
                           all=FALSE,
                           do.points=TRUE,
                           main="Voronoi mosaic",
                           sub=deparse(substitute(x)),
                           isometric=FALSE,
                           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.voronoi_+3A_x">x</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_add">add</code></td>
<td>
<p>logical, if <code>TRUE</code>, add to a current plot.</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_xlim">xlim</code></td>
<td>
<p>x plot ranges, by default modified to hide dummy 
points outside of the plot</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_ylim">ylim</code></td>
<td>
<p>y plot ranges, by default modified to hide dummy 
points outside of the plot</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_all">all</code></td>
<td>
<p>show all (including dummy points in the plot</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_do.points">do.points</code></td>
<td>
<p>logical, indicates if points should be plotted.</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_sub">sub</code></td>
<td>
<p>plot subtitle</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_isometric">isometric</code></td>
<td>
<p>generate an isometric plot (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_...">...</code></td>
<td>
<p>additional plot parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8. 
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+voronoi">voronoi</a></code>, <code><a href="interp.html#topic+print.voronoi">print.voronoi</a></code>, 
<code><a href="interp.html#topic+summary.voronoi">summary.voronoi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot a random mosaic
plot(voronoi.mosaic(runif(100),runif(100),duplicate="remove"))
# use isometric=TRUE and all=TRUE to see the complete mosaic
# including extreme outlier points:
plot(voronoi.mosaic(runif(100),runif(100),duplicate="remove"),
     all=TRUE, isometric=TRUE)
# use a part of the quakes data set:
data(quakes)
quakes.part&lt;-quakes[(quakes[,1]&lt;=-17 &amp; quakes[,1]&gt;=-19.0 &amp;
                     quakes[,2]&lt;=182.0 &amp; quakes[,2]&gt;=180.0),]
quakes.vm&lt;-voronoi.mosaic(quakes.part$lon, quakes.part$lat,
                          duplicate="remove")
plot(quakes.vm, isometric=TRUE)
# use the whole quakes data set 
# (will not work with standard memory settings, hence commented out here)
#plot(voronoi.mosaic(quakes$lon, quakes$lat, duplicate="remove"), isometric=TRUE)
</code></pre>

<hr>
<h2 id='plot.voronoi.polygons'>plots an voronoi.polygons object</h2><span id='topic+plot.voronoi.polygons'></span>

<h3>Description</h3>

<p>plots an <code>voronoi.polygons</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi.polygons'
plot(x, which, color=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.voronoi.polygons_+3A_x">x</code></td>
<td>
<p> object of class <code>voronoi.polygons</code>  </p>
</td></tr>
<tr><td><code id="plot.voronoi.polygons_+3A_which">which</code></td>
<td>
<p> index vector selecting which polygons to plot </p>
</td></tr>
<tr><td><code id="plot.voronoi.polygons_+3A_color">color</code></td>
<td>
<p> logical, determines if plot should be colored, default: <code>TRUE</code> </p>
</td></tr>
<tr><td><code id="plot.voronoi.polygons_+3A_...">...</code></td>
<td>
<p> additional plot arguments </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> A. Gebhardt</p>


<h3>See Also</h3>

 <p><code><a href="interp.html#topic+voronoi.polygons">voronoi.polygons</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	     or do  help(data=index)  for the standard data sets.
data(tritest)
tritest.vm &lt;- voronoi.mosaic(tritest$x,tritest$y)
tritest.vp &lt;- voronoi.polygons(tritest.vm)
plot(tritest.vp)
plot(tritest.vp,which=c(1,3,5))
</code></pre>

<hr>
<h2 id='print.summary.tri'>Print a summary of a triangulation object</h2><span id='topic+print.summary.tri'></span>

<h3>Description</h3>

<p>Prints some information about <code>tri.obj</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.tri'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.tri_+3A_x">x</code></td>
<td>
<p>object of class <code>"summary.tri"</code>,
generated by <code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.tri_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>,<code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>,
<code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>,
<code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>. 
</p>

<hr>
<h2 id='print.summary.voronoi'>Print a summary of a voronoi object</h2><span id='topic+print.summary.voronoi'></span>

<h3>Description</h3>

<p>Prints some information about <code>x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.voronoi'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.voronoi_+3A_x">x</code></td>
<td>
<p>object of class <code>"summary.voronoi"</code>,
generated by <code><a href="interp.html#topic+summary.voronoi">summary.voronoi</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.voronoi_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+voronoi">voronoi</a></code>,<code><a href="interp.html#topic+voronoi.mosaic">voronoi.mosaic</a></code>,
<code><a href="interp.html#topic+print.voronoi">print.voronoi</a></code>, <code><a href="interp.html#topic+plot.voronoi">plot.voronoi</a></code>,
<code><a href="interp.html#topic+summary.voronoi">summary.voronoi</a></code>. 
</p>

<hr>
<h2 id='print.tri'>Print a triangulation object</h2><span id='topic+print.tri'></span>

<h3>Description</h3>

<p>prints a adjacency list of <code>"x"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tri'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tri_+3A_x">x</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
<tr><td><code id="print.tri_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>,
<code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>,
<code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>
</p>

<hr>
<h2 id='print.voronoi'>Print a voronoi object</h2><span id='topic+print.voronoi'></span>

<h3>Description</h3>

<p>prints a summary of <code>"x"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.voronoi_+3A_x">x</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
<tr><td><code id="print.voronoi_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+voronoi">voronoi</a></code>,
<code><a href="interp.html#topic+plot.voronoi">plot.voronoi</a></code>,
<code><a href="interp.html#topic+summary.voronoi">summary.voronoi</a></code>
</p>

<hr>
<h2 id='summary.tri'>Return a summary of a triangulation object</h2><span id='topic+summary.tri'></span>

<h3>Description</h3>

<p>Returns some information (number of nodes, triangles, arcs, boundary
nodes and constraints) about <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tri'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tri_+3A_object">object</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
<tr><td><code id="summary.tri_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>summary</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objekt of class <code>"summary.tri"</code>, to be printed by
<code><a href="tripack.html#topic+print.summary.tri">print.summary.tri</a></code>.
</p>
<p>It contains the number of nodes (<code>n</code>), of arcs (<code>na</code>), of
boundary nodes (<code>nb</code>), of triangles (<code>nt</code>) and constraints
(<code>nc</code>).   
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>,
<code><a href="tripack.html#topic+print.summary.tri">print.summary.tri</a></code>.
</p>

<hr>
<h2 id='summary.voronoi'>Return a summary of a voronoi object</h2><span id='topic+summary.voronoi'></span>

<h3>Description</h3>

<p>Returns some information about <code>object</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.voronoi_+3A_object">object</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
<tr><td><code id="summary.voronoi_+3A_...">...</code></td>
<td>
<p>additional parameters for <code>summary</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"summary.voronoi"</code>.
</p>
<p>It contains the number of nodes (<code>nn</code>) and dummy nodes (<code>nd</code>).
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+voronoi">voronoi</a></code>,<code><a href="interp.html#topic+voronoi.mosaic">voronoi.mosaic</a></code>,
<code><a href="interp.html#topic+print.voronoi">print.voronoi</a></code>, <code><a href="interp.html#topic+plot.voronoi">plot.voronoi</a></code>,
<code><a href="interp.html#topic+print.summary.voronoi">print.summary.voronoi</a></code>. 
</p>

<hr>
<h2 id='tri'>A triangulation object</h2><span id='topic+tri'></span>

<h3>Description</h3>

<p>R object that represents the triangulation of a set of 2D points, 
generated by <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> or <code><a href="tripack.html#topic+add.constraint">add.constraint</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri_+3A_n">n</code></td>
<td>
<p>Number of nodes</p>
</td></tr>
<tr><td><code id="tri_+3A_x">x</code></td>
<td>
<p>x coordinates of the triangulation nodes</p>
</td></tr>
<tr><td><code id="tri_+3A_y">y</code></td>
<td>
<p>y coordinates of the triangulation nodes</p>
</td></tr>
<tr><td><code id="tri_+3A_tlist">tlist</code></td>
<td>
<p>Set of nodal indexes which, along with <code>tlptr</code>,
<code>tlend</code>, and <code>tlnew</code>, define the triangulation as a
set of <code class="reqn">n</code> adjacency lists &ndash; counterclockwise-ordered sequences of
neighboring nodes such that the first and last neighbors of a
boundary node are boundary nodes (the first neighbor of an interior
node is arbitrary). In order to distinguish between
interior and boundary nodes, the last neighbor of each boundary node
is represented by the negative of its index.</p>
</td></tr>
<tr><td><code id="tri_+3A_tlptr">tlptr</code></td>
<td>
<p>Set of pointers in one-to-one
correspondence with the elements of <code>tlist</code>.
<code>tlist[tlptr[i]]</code> indexes the node which follows
<code>tlist[i]</code> in cyclical counterclockwise order
(the first neighbor follows the last neighbor).</p>
</td></tr>
<tr><td><code id="tri_+3A_tlend">tlend</code></td>
<td>
<p>Set of pointers to adjacency lists. <code>tlend[k]</code>
points to the last neighbor of node <code class="reqn">k</code> for
<code class="reqn">k = 1,...,n</code>.  Thus, <code>tlist[tlend[k]]</code>&lt;0 if and
only if <code class="reqn">k</code> is a boundary node.</p>
</td></tr>
<tr><td><code id="tri_+3A_tlnew">tlnew</code></td>
<td>
<p> Pointer to the first empty location in <code>tlist</code>
and <code>tlptr</code> (list length plus one).</p>
</td></tr>
<tr><td><code id="tri_+3A_nc">nc</code></td>
<td>
<p>number of constraints</p>
</td></tr>
<tr><td><code id="tri_+3A_lc">lc</code></td>
<td>
<p>starting indices of constraints in <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="tri_+3A_call">call</code></td>
<td>
<p>call, which generated this object</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The elements <code>tlist</code>, <code>tlptr</code>, <code>tlend</code> and <code>tlnew</code>
are mainly intended for internal use in the appropriate Fortran
routines. 
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>, <code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>
</p>

<hr>
<h2 id='tri.dellens'>Compute the Delaunay segment lengths</h2><span id='topic+tri.dellens'></span>

<h3>Description</h3>

<p>Return a vector of Delaunay segment lengths for the voronoi object.
The Delaunay triangles connected to sites contained in  <code>exceptions</code>
vector are ignored (unless <code>inverse</code> is TRUE, when only those
Delaunay triangles are accepted).
</p>
<p>The <code>exceptions</code> vector is provided so that sites at the border
of a region can be removed, as these tend to bias the distribution of
Delaunay segment lengths.  <code>exceptions</code> can be created by
<code><a href="interp.html#topic+voronoi.findrejectsites">voronoi.findrejectsites</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.dellens(voronoi.obj, exceptions = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri.dellens_+3A_voronoi.obj">voronoi.obj</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
<tr><td><code id="tri.dellens_+3A_exceptions">exceptions</code></td>
<td>
<p>a numerical vector</p>
</td></tr>
<tr><td><code id="tri.dellens_+3A_inverse">inverse</code></td>
<td>
<p>Logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of Delaunay segment lengths.
</p>


<h3>Author(s)</h3>

<p>S. J. Eglen</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+voronoi.findrejectsites">voronoi.findrejectsites</a></code>, <code><a href="interp.html#topic+voronoi.mosaic">voronoi.mosaic</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tritest)
tritest.vm &lt;- voronoi.mosaic(tritest$x,tritest$y)

tritest.vm.rejects &lt;- voronoi.findrejectsites(tritest.vm, 0,1, 0, 1)
trilens.all &lt;- tri.dellens(tritest.vm)
trilens.acc &lt;- tri.dellens(tritest.vm, tritest.vm.rejects)
trilens.rej &lt;- tri.dellens(tritest.vm, tritest.vm.rejects, inverse=TRUE)

par(mfrow=c(3,1))
dotchart(trilens.all, main="all Delaunay segment lengths")
dotchart(trilens.acc, main="excluding border sites")
dotchart(trilens.rej, main="only border sites")
</code></pre>

<hr>
<h2 id='tri.find'>Locate a point in a triangulation</h2><span id='topic+tri.find'></span>

<h3>Description</h3>

<p>This subroutine locates a point P=(<code>x</code>,<code>y</code>) relative to a triangulation
created by <code>tri.mesh</code>.  If P is
contained in a triangle, the three vertex indexes are
returned.  Otherwise, the indexes of the rightmost and
leftmost visible boundary nodes are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.find(tri.obj,x,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri.find_+3A_tri.obj">tri.obj</code></td>
<td>
<p>an triangulation object</p>
</td></tr>
<tr><td><code id="tri.find_+3A_x">x</code></td>
<td>
<p>x-coordinate of the point</p>
</td></tr>
<tr><td><code id="tri.find_+3A_y">y</code></td>
<td>
<p>y-coordinate of the point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>i1</code>,<code>i2</code>,<code>i3</code> containing
nodal indexes, in counterclockwise order,
of the vertices of a triangle containing
P=(<code>x</code>,<code>y</code>), or, if P is not contained in the convex
hull of the nodes, <code>i1</code> indexes the
rightmost visible boundary node, <code>i2</code> indexes
the leftmost visible boundary node,
and <code>i3</code> = 0.  Rightmost and leftmost are
defined from the perspective of P, and a
pair of points are visible from each
other if and only if the line segment
joining them intersects no triangulation
arc.  If P and all of the nodes lie on a
common line, then <code>i1</code>=<code>i2</code>=<code>i3</code> = 0 on
output.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>,
<code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>, <code><a href="igraph.html#topic+triangles">triangles</a></code>, 
<code><a href="igraph.html#topic+convex.hull">convex.hull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tritest)
tritest.tr&lt;-tri.mesh(tritest$x,tritest$y)
plot(tritest.tr)
pnt&lt;-list(x=0.3,y=0.4)
triangle.with.pnt&lt;-tri.find(tritest.tr,pnt$x,pnt$y)
attach(triangle.with.pnt)
lines(tritest$x[c(i1,i2,i3,i1)],tritest$y[c(i1,i2,i3,i1)],col="red")
points(pnt$x,pnt$y)
</code></pre>

<hr>
<h2 id='tri.mesh'>
Create a delaunay triangulation
</h2><span id='topic+tri.mesh'></span>

<h3>Description</h3>

<p>This subroutine creates a Delaunay triangulation of a
set of N arbitrarily distributed points in the plane referred to as
nodes.
The Delaunay triangulation is defined
as a set of triangles with the following five properties:
</p>
<p>1)  The triangle vertices are nodes.
</p>
<p>2)  No triangle contains a node other than its vertices.
</p>
<p>3)  The interiors of the triangles are pairwise disjoint.
</p>
<p>4)  The union of triangles is the convex hull of the set
of nodes (the smallest convex set which contains
the nodes).
</p>
<p>5)  The interior of the circumcircle of each triangle
contains no node.
</p>
<p>The first four properties define a triangulation, and the
last property results in a triangulation which is as close
as possible to equiangular in a certain sense and which is
uniquely defined unless four or more nodes lie on a common
circle.  This property makes the triangulation well-suited
for solving closest point problems and for triangle-based
interpolation.
</p>
<p>The triangulation can be generalized to a constrained
Delaunay triangulation by a call to <code>add.constraint</code>.
This allows for user-specified boundaries defining a nonconvex
and/or multiply connected region.
</p>
<p>The operation count for constructing the triangulation
is close to O(N) if the nodes are presorted on X or Y components.
Also, since the algorithm proceeds by adding
nodes incrementally, the triangulation may be updated with
the addition (or deletion) of a node very efficiently.
The adjacency information representing the triangulation
is stored as a linked list requiring approximately 13N
storage locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.mesh(x, y = NULL, duplicate = "error",
         jitter = 10^-12, jitter.iter = 6, jitter.random = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri.mesh_+3A_x">x</code></td>
<td>
<p>vector containing x coordinates of the data. If <code>y</code> is missing
<code>x</code> should contain two elements <code>$x</code> and <code>$y</code>.
</p>
</td></tr>
<tr><td><code id="tri.mesh_+3A_y">y</code></td>
<td>
<p>vector containing y coordinates of the data.
</p>
</td></tr>
<tr><td><code id="tri.mesh_+3A_duplicate">duplicate</code></td>
<td>
<p>flag indicating how to handle duplicate elements.
Possible values are: <code>"error"</code> &ndash; default, <code>"strip"</code> &ndash; remove all duplicate points, <code>"remove"</code> &ndash; leave one point of duplicate points.
</p>
</td></tr>
<tr><td><code id="tri.mesh_+3A_jitter">jitter</code></td>
<td>
<p>Jitter of amount of <code>diff(range(XX))*jitter</code> (XX=x
or y) will be added to coordinates if collinear points are
detected. Afterwards interpolation will be tried once again.
</p>
<p>Note that the jitter is not generated randomly unless
<code>jitter.random</code> is set to <code>TRUE</code>. This ensures
reproducable results. <code><a href="akima.html#topic+interp">interp</a></code> of package
<code>akima</code> uses the same jitter mechanism. That means you can
plot the triangulation on top of the interpolation and see the
same triangulation as used for interpolation, see examples for
<code><a href="akima.html#topic+interp">interp</a></code>.
</p>
</td></tr>
<tr><td><code id="tri.mesh_+3A_jitter.iter">jitter.iter</code></td>
<td>
<p>number of iterations to retry with jitter, amount
will be increased in each iteration by <code>iter^1.5</code></p>
</td></tr>
<tr><td><code id="tri.mesh_+3A_jitter.random">jitter.random</code></td>
<td>
<p>logical, see <code>jitter</code>, defaults to
<code>FALSE</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tri"</code>
</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>,
<code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>, <code><a href="igraph.html#topic+triangles">triangles</a></code>,
<code><a href="igraph.html#topic+convex.hull">convex.hull</a></code>, <code><a href="interp.html#topic+neighbours">neighbours</a></code>,
<code><a href="tripack.html#topic+add.constraint">add.constraint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tritest)
tritest.tr&lt;-tri.mesh(tritest$x,tritest$y)
tritest.tr
</code></pre>

<hr>
<h2 id='triangles'>Extract a list of triangles from a triangulation object</h2><span id='topic+triangles'></span>

<h3>Description</h3>

<p>This function extracts a triangulation data structure
from an triangulation object created by <code>tri.mesh</code>.
</p>
<p>The vertices in the returned matrix (let's denote it  with
<code>retval</code>) are ordered
counterclockwise with the first vertex taken
to be the one with smallest index.  Thus,
<code>retval[i,"node2"]</code> and <code>retval[i,"node3"]</code> are larger
than
<code>retval[i,"node3"]</code> and index adjacent neighbors of
node <code>retval[i,"node1"]</code>. The columns <code>trx</code> and
<code>arcx</code>, x=1,2,3 index the triangle and arc,
respectively, which are opposite (not shared
by) node <code>nodex</code>, with <code>trix</code>= 0 if
<code>arcx</code> indexes a boundary arc.  Vertex
indexes range from 1 to N, triangle indexes
from 0 to NT, and, if included, arc indexes
from 1 to NA = NT+N-1.  The triangles are 
ordered on first (smallest) vertex indexes,
except that the sets of constraint triangles
(triangles contained in the closure of a constraint
region) follow the non-constraint
triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangles(tri.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangles_+3A_tri.obj">tri.obj</code></td>
<td>
<p>object of class <code>"tri"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns <code>node1</code>,<code>node2</code>,<code>node3</code>,
representing the vertex nodal indexes,
<code>tr1</code>,<code>tr2</code>,<code>tr3</code>, representing neighboring triangle
indexes and <code>arc1</code>,<code>arc2</code>,<code>arc3</code> reresenting arc indexes.
</p>
<p>Each row represents one triangle. 
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri">tri</a></code>, <code><a href="tripack.html#topic+print.tri">print.tri</a></code>, <code><a href="tripack.html#topic+plot.tri">plot.tri</a></code>, <code><a href="tripack.html#topic+summary.tri">summary.tri</a></code>, <code><a href="igraph.html#topic+triangles">triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use a slighlty modified version of data(tritest)
data(tritest2)
tritest2.tr&lt;-tri.mesh(tritest2$x,tritest2$y)
triangles(tritest2.tr)
</code></pre>

<hr>
<h2 id='tripack-internal'>Internal functions</h2><span id='topic+voronoi.polyarea'></span><span id='topic+tri.vordist'></span><span id='topic+voronoi.findvertices'></span><span id='topic+tri.swap'></span><span id='topic+tri.swap.lowlevel'></span>

<h3>Description</h3>

<p>Internal tripack functions
</p>


<h3>Details</h3>

<p>These functions are not intended to be called by the user.
</p>

<hr>
<h2 id='tritest'> tritest / sample data </h2><span id='topic+tritest'></span><span id='topic+tritest2'></span>

<h3>Description</h3>

<p>A very simply set set of points to test the tripack functions, taken
from the FORTRAN original. <code>tritest2</code> is a slight modification by 
adding <code>runif(,-0.1,0.1)</code> random numbers to the coordinates.
</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>

<hr>
<h2 id='voronoi'>Voronoi object</h2><span id='topic+voronoi'></span>

<h3>Description</h3>

<p>An <code>voronoi</code> object is created with <code><a href="interp.html#topic+voronoi.mosaic">voronoi.mosaic</a>
</code></p>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoi_+3A_x">x</code>, <code id="voronoi_+3A_y">y</code></td>
<td>
<p>x and y coordinates of nodes of the voronoi mosaic. Each node is a
circumcircle center of some triangle from the Delaunay triangulation.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_node">node</code></td>
<td>
<p>logical vector, indicating real nodes of the voronoi
mosaic. These nodes are the centers of circumcircles of triangles with 
positive area of the delaunay triangulation.
</p>
<p>If <code>node[i]</code>=<code>FALSE</code>, (<code>c[i]</code>,<code>x[i]</code>) belongs to a 
triangle with area 0.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_n1">n1</code>, <code id="voronoi_+3A_n2">n2</code>, <code id="voronoi_+3A_n3">n3</code></td>
<td>
<p>indices of neighbour nodes. Negative indices indicate
dummy points as neighbours.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_tri">tri</code></td>
<td>
<p>triangulation object, see <code><a href="tripack.html#topic+tri">tri</a></code>.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_area">area</code></td>
<td>
<p>area of triangle i. <code>area[i]</code>=-1 indicates a removed
triangle with area 0 at the border of the triangulation.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_ratio">ratio</code></td>
<td>
<p>aspect ratio (inscribed radius/circumradius) of triangle
i.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_radius">radius</code></td>
<td>
<p>circumradius of triangle i.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_dummy.x">dummy.x</code>, <code id="voronoi_+3A_dummy.y">dummy.y</code></td>
<td>
<p>x and y coordinates of dummy points. They are
used for plotting of unbounded tiles.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+voronoi.mosaic">voronoi.mosaic</a></code>,<code><a href="interp.html#topic+plot.voronoi">plot.voronoi</a></code>
</p>

<hr>
<h2 id='voronoi.area'>Calculate area of Voronoi polygons</h2><span id='topic+voronoi.area'></span>

<h3>Description</h3>

<p>Computes the area of each Voronoi polygon.
For some sites at the edge of the region, the Voronoi polygon is not
bounded, and so the area of those sites cannot be calculated, and hence
will be NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.area(voronoi.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoi.area_+3A_voronoi.obj">voronoi.obj</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of polygon areas.</p>


<h3>Author(s)</h3>

<p>S. J. Eglen</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+voronoi">voronoi</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tritest)
tritest.vm &lt;- voronoi.mosaic(tritest$x,tritest$y)
tritest.vm.areas &lt;- voronoi.area(tritest.vm)
plot(tritest.vm)
text(tritest$x, tritest$y, tritest.vm.areas)
</code></pre>

<hr>
<h2 id='voronoi.findrejectsites'>Find the Voronoi sites at the border of the region (to be rejected).</h2><span id='topic+voronoi.findrejectsites'></span>

<h3>Description</h3>

<p>Find the sites in the Voronoi tesselation that lie at the
edge of the region.  A site is at the edge if any of the vertices of
its Voronoi polygon lie outside the rectangle with corners (xmin,ymin)
and (xmax,ymax).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.findrejectsites(voronoi.obj, xmin, xmax, ymin, ymax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoi.findrejectsites_+3A_voronoi.obj">voronoi.obj</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
<tr><td><code id="voronoi.findrejectsites_+3A_xmin">xmin</code></td>
<td>
<p>minimum x-coordinate of sites in the region</p>
</td></tr>
<tr><td><code id="voronoi.findrejectsites_+3A_xmax">xmax</code></td>
<td>
<p>maximum x-coordinate of sites in the region</p>
</td></tr>
<tr><td><code id="voronoi.findrejectsites_+3A_ymin">ymin</code></td>
<td>
<p>minimum y-coordinate of sites in the region</p>
</td></tr>
<tr><td><code id="voronoi.findrejectsites_+3A_ymax">ymax</code></td>
<td>
<p>maximum y-coordinate of sites in the region</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as the number of sites.  If
the site is a reject, the corresponding element of the vector is set
to TRUE.</p>


<h3>Author(s)</h3>

<p>S. J. Eglen</p>


<h3>See Also</h3>

<p><code><a href="tripack.html#topic+tri.dellens">tri.dellens</a></code>
</p>

<hr>
<h2 id='voronoi.mosaic'>Create a Voronoi mosaic</h2><span id='topic+voronoi.mosaic'></span>

<h3>Description</h3>

<p>This function creates a Voronoi mosaic.
</p>
<p>It creates first a Delaunay triangulation, determines the circumcircle 
centers of its triangles, and connects these points according to the
neighbourhood relations between the triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.mosaic(x,y=NULL,duplicate="error")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoi.mosaic_+3A_x">x</code></td>
<td>
<p>vector containing x coordinates of the data. If <code>y</code> is
missing    <code>x</code> should contain two elements <code>$x</code> and <code>$y</code>.
</p>
</td></tr>
<tr><td><code id="voronoi.mosaic_+3A_y">y</code></td>
<td>
<p>vector containing y coordinates of the data.
</p>
</td></tr>
<tr><td><code id="voronoi.mosaic_+3A_duplicate">duplicate</code></td>
<td>
<p>flag indicating how to handle duplicate elements.
Possible values are: <code>"error"</code> &ndash; default, <code>"strip"</code> &ndash;
remove all duplicate points, <code>"remove"</code> &ndash; leave one point of
duplicate points. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="interp.html#topic+voronoi">voronoi</a></code>.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>See Also</h3>

  <p><code><a href="interp.html#topic+voronoi">voronoi</a></code>,<code><a href="interp.html#topic+voronoi.mosaic">voronoi.mosaic</a></code>,      <code><a href="interp.html#topic+print.voronoi">print.voronoi</a></code>, <code><a href="interp.html#topic+plot.voronoi">plot.voronoi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example from TRIPACK:
data(tritest)
tritest.vm&lt;-voronoi.mosaic(tritest$x,tritest$y)
tritest.vm
# use a part of the quakes data set:
data(quakes)
quakes.part&lt;-quakes[(quakes[,1]&lt;=-17 &amp; quakes[,1]&gt;=-19.0 &amp;
                     quakes[,2]&lt;=182.0 &amp; quakes[,2]&gt;=180.0),]
quakes.vm&lt;-voronoi.mosaic(quakes.part$lon, quakes.part$lat, duplicate="remove")
quakes.vm
</code></pre>

<hr>
<h2 id='voronoi.polygons'> extract polygons from a voronoi mosaic </h2><span id='topic+voronoi.polygons'></span>

<h3>Description</h3>

<p>This functions extracts polygons from a <code>voronoi.mosaic</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.polygons(voronoi.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoi.polygons_+3A_voronoi.obj">voronoi.obj</code></td>
<td>
<p> object of class <code>voronoi.mosaic</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>voronoi.polygons</code> with unamed list
elements for each polygon. These list
elements are matrices with columns <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p> Denis White </p>


<h3>See Also</h3>

 <p><code><a href="interp.html#topic+plot.voronoi.polygons">plot.voronoi.polygons</a></code>,<code><a href="interp.html#topic+voronoi.mosaic">voronoi.mosaic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	     or do  help(data=index)  for the standard data sets.

data(tritest)
tritest.vm &lt;- voronoi.mosaic(tritest$x,tritest$y)
tritest.vp &lt;- voronoi.polygons(tritest.vm)
tritest.vp
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
