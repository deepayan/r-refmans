<!DOCTYPE html><html><head><title>Help for package model4you</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {model4you}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.add_modelinfo'><p>Add model information to a personalised-model-ctree</p></a></li>
<li><a href='#.modelfit'><p>Fit function when model object is given</p></a></li>
<li><a href='#.prepare_args'><p>Prepare input for ctree/cforest from input of pmtree/pmforest</p></a></li>
<li><a href='#binomial_glm_plot'><p>Plot for a given logistic regression model (glm with binomial family)</p>
with one binary covariate.</a></li>
<li><a href='#coeftable.survreg'><p>Table of coefficients for survreg model</p></a></li>
<li><a href='#coxph_plot'><p>Survival plot for a given coxph model</p>
with one binary covariate.</a></li>
<li><a href='#lm_plot'><p>Density plot for a given lm model</p>
with one binary covariate.</a></li>
<li><a href='#logLik.pmtree'><p>Extract log-Likelihood</p></a></li>
<li><a href='#node_pmterminal'><p>Panel-Generator for Visualization of pmtrees</p></a></li>
<li><a href='#objfun'><p>Objective function</p></a></li>
<li><a href='#objfun.pmodel_identity'><p>Objective function of personalised models</p></a></li>
<li><a href='#objfun.pmtree'><p>Objective function of a given pmtree</p></a></li>
<li><a href='#one_factor'><p>Check if model has only one factor covariate.</p></a></li>
<li><a href='#pmforest'><p>Compute model-based forest from model.</p></a></li>
<li><a href='#pmodel'><p>Personalised model</p></a></li>
<li><a href='#pmtest'><p>Test if personalised models improve upon</p>
base model.</a></li>
<li><a href='#pmtree'><p>Compute model-based tree from model.</p></a></li>
<li><a href='#predict.pmtree'><p>pmtree predictions</p></a></li>
<li><a href='#print.pmtree'><p>Methods for pmtree</p></a></li>
<li><a href='#rss'><p>Residual sum of squares</p></a></li>
<li><a href='#survreg_plot'><p>Survival plot for a given survreg model</p>
with one binary covariate.</a></li>
<li><a href='#varimp.pmforest'><p>Variable Importance for pmforest</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Stratified and Personalised Models Based on Model-Based Trees
and Forests</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-12-23</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-7</td>
</tr>
<tr>
<td>Description:</td>
<td>Model-based trees for subgroup analyses in clinical trials and
  model-based forests for the estimation and prediction of personalised
  treatment effects (personalised models). Currently partitioning of linear
  models, lm(), generalised linear models, glm(), and Weibull models,
  survreg(), is supported.  Advanced plotting functionality is supported for
  the trees and a test for parameter heterogeneity is provided for the
  personalised models. For details on model-based trees for subgroup analyses
  see Seibold, Zeileis and Hothorn (2016) &lt;<a href="https://doi.org/10.1515%2Fijb-2015-0032">doi:10.1515/ijb-2015-0032</a>&gt;; for
  details on model-based forests for estimation of individual treatment effects
  see Seibold, Zeileis and Hothorn (2017) &lt;<a href="https://doi.org/10.1177%2F0962280217693034">doi:10.1177/0962280217693034</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), partykit (&ge; 1.2-6), grid</td>
</tr>
<tr>
<td>Imports:</td>
<td>sandwich, stats, methods, ggplot2, Formula, gridExtra,
survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, TH.data, psychotools, strucchange, plyr, knitr,
ggbeeswarm, MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-23 08:13:18 UTC; heidiseibold</td>
</tr>
<tr>
<td>Author:</td>
<td>Heidi Seibold [aut, cre],
  Achim Zeileis [aut],
  Torsten Hothorn [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Heidi Seibold &lt;heidi@seibold.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-20 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.add_modelinfo'>Add model information to a personalised-model-ctree</h2><span id='topic+.add_modelinfo'></span>

<h3>Description</h3>

<p>For internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.add_modelinfo(x, nodeids, data, model, coeffun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".add_modelinfo_+3A_x">x</code></td>
<td>
<p>constparty object.</p>
</td></tr>
<tr><td><code id=".add_modelinfo_+3A_nodeids">nodeids</code></td>
<td>
<p>node ids, usually the terminal ids.</p>
</td></tr>
<tr><td><code id=".add_modelinfo_+3A_data">data</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id=".add_modelinfo_+3A_model">model</code></td>
<td>
<p>model.</p>
</td></tr>
<tr><td><code id=".add_modelinfo_+3A_coeffun">coeffun</code></td>
<td>
<p>function that takes the model object and returns the coefficients.
Useful when coef() does not return all coefficients (e.g. survreg).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tree with added info. Class still to be added.
</p>

<hr>
<h2 id='.modelfit'>Fit function when model object is given</h2><span id='topic+.modelfit'></span>

<h3>Description</h3>

<p>Use update function to refit model and extract info such as coef, logLik and
estfun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.modelfit(model, data, coeffun = coef, weights, control, parm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".modelfit_+3A_model">model</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id=".modelfit_+3A_data">data</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id=".modelfit_+3A_coeffun">coeffun</code></td>
<td>
<p>function that takes the model object and returns the coefficients.
Useful when coef() does not return all coefficients (e.g. survreg).</p>
</td></tr>
<tr><td><code id=".modelfit_+3A_weights">weights</code></td>
<td>
<p>weights.</p>
</td></tr>
<tr><td><code id=".modelfit_+3A_control">control</code></td>
<td>
<p>control options from <code>ctree_control</code>.</p>
</td></tr>
<tr><td><code id=".modelfit_+3A_parm">parm</code></td>
<td>
<p>which parameters should be used for instability test?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function returning a list of
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
 <p><code>coef</code>. </p>
</td></tr>
<tr><td><code>objfun</code></td>
<td>
 <p><code>logLik</code>. </p>
</td></tr>
<tr><td><code>object</code></td>
<td>
<p> the model object. </p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p> Did the model converge? </p>
</td></tr>
<tr><td><code>estfun</code></td>
<td>
 <p><code>estfun</code>. </p>
</td></tr>
</table>

<hr>
<h2 id='.prepare_args'>Prepare input for ctree/cforest from input of pmtree/pmforest</h2><span id='topic+.prepare_args'></span>

<h3>Description</h3>

<p>Prepare input for ctree/cforest from input of pmtree/pmforest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prepare_args(model, data, zformula, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".prepare_args_+3A_model">model</code></td>
<td>
<p>model.</p>
</td></tr>
<tr><td><code id=".prepare_args_+3A_data">data</code></td>
<td>
<p>an optional data frame.</p>
</td></tr>
<tr><td><code id=".prepare_args_+3A_zformula">zformula</code></td>
<td>
<p>ormula describing which variable should be used for partitioning.</p>
</td></tr>
<tr><td><code id=".prepare_args_+3A_control">control</code></td>
<td>
<p>ontrol parameters, see <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code id=".prepare_args_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>args to be passed to ctree/cforest.
</p>

<hr>
<h2 id='binomial_glm_plot'>Plot for a given logistic regression model (glm with binomial family)
with one binary covariate.</h2><span id='topic+binomial_glm_plot'></span>

<h3>Description</h3>

<p>Can be used on its own but is also useable as plotfun in
<code><a href="#topic+node_pmterminal">node_pmterminal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial_glm_plot(
  mod,
  data = NULL,
  plot_data = FALSE,
  theme = theme_classic(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomial_glm_plot_+3A_mod">mod</code></td>
<td>
<p>A model of class glm with binomial family.</p>
</td></tr>
<tr><td><code id="binomial_glm_plot_+3A_data">data</code></td>
<td>
<p>optional data frame. If NULL the data stored in mod is used.</p>
</td></tr>
<tr><td><code id="binomial_glm_plot_+3A_plot_data">plot_data</code></td>
<td>
<p>should the data in form of a mosaic type plot be plotted?</p>
</td></tr>
<tr><td><code id="binomial_glm_plot_+3A_theme">theme</code></td>
<td>
<p>A ggplot2 theme.</p>
</td></tr>
<tr><td><code id="binomial_glm_plot_+3A_...">...</code></td>
<td>
<p>ignored at the moment.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2017)

# number of observations
n &lt;- 1000

# balanced binary treatment
# trt &lt;- factor(rep(c("C", "A"), each = n/2),
#               levels = c("C", "A"))

# unbalanced binary treatment
trt &lt;- factor(c(rep("C", n/4), rep("A", 3*n/4)),
              levels = c("C", "A"))

# some continuous variables
x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)

# linear predictor
lp &lt;- -0.5 + 0.5*I(trt == "A") + 1*I(trt == "A")*I(x1 &gt; 0)

# compute probability with inverse logit function
invlogit &lt;- function(x) 1/(1 + exp(-x))
pr &lt;- invlogit(lp)

# bernoulli response variable
y &lt;- rbinom(n, 1, pr)
dat &lt;- data.frame(y, trt, x1, x2)

# logistic regression model
mod &lt;- glm(y ~ trt, data = dat, family = "binomial")
binomial_glm_plot(mod, plot_data = TRUE)

# logistic regression model tree
ltr &lt;- pmtree(mod)
plot(ltr, terminal_panel = node_pmterminal(ltr,
                                           plotfun = binomial_glm_plot,
                                           confint = TRUE,
                                           plot_data = TRUE))

</code></pre>

<hr>
<h2 id='coeftable.survreg'>Table of coefficients for survreg model</h2><span id='topic+coeftable.survreg'></span>

<h3>Description</h3>

<p>This function is mostly useful for plotting a pmtree.
The generic plotting does not show the estimate and confidence interval
of the scale parameter. This one does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeftable.survreg(model, confint = TRUE, digits = 2, intree = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeftable.survreg_+3A_model">model</code></td>
<td>
<p>model of class <code><a href="survival.html#topic+survreg">survreg</a></code></p>
</td></tr>
<tr><td><code id="coeftable.survreg_+3A_confint">confint</code></td>
<td>
<p>should a confidence interval be computed? Default: TRUE</p>
</td></tr>
<tr><td><code id="coeftable.survreg_+3A_digits">digits</code></td>
<td>
<p>integer, used for formating numbers. Default: 2</p>
</td></tr>
<tr><td><code id="coeftable.survreg_+3A_intree">intree</code></td>
<td>
<p>is the table plotted within a tree? Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("survival") &amp; require("TH.data")) {
  ## Load data
  data(GBSG2, package = "TH.data")

  ## Weibull model
  bmod &lt;- survreg(Surv(time, cens) ~ horTh, data = GBSG2, model = TRUE)

  ## Coefficient table
  grid.newpage()
  coeftable.survreg(bmod)

  ## partitioned model
  tr &lt;- pmtree(bmod)

  ## plot
  plot(tr, terminal_panel = node_pmterminal(tr, plotfun = survreg_plot,
    confint = TRUE, coeftable = coeftable.survreg))
}

</code></pre>

<hr>
<h2 id='coxph_plot'>Survival plot for a given coxph model
with one binary covariate.</h2><span id='topic+coxph_plot'></span>

<h3>Description</h3>

<p>Can be used on its own but is also useable as plotfun in
<code><a href="#topic+node_pmterminal">node_pmterminal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxph_plot(mod, data = NULL, theme = theme_classic(), yrange = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxph_plot_+3A_mod">mod</code></td>
<td>
<p>A model of class coxph.</p>
</td></tr>
<tr><td><code id="coxph_plot_+3A_data">data</code></td>
<td>
<p>optional data frame. If NULL the data stored in mod is used.</p>
</td></tr>
<tr><td><code id="coxph_plot_+3A_theme">theme</code></td>
<td>
<p>A ggplot2 theme.</p>
</td></tr>
<tr><td><code id="coxph_plot_+3A_yrange">yrange</code></td>
<td>
<p>Range of the y variable to be used for plotting.
If NULL it will be 0 to max(y).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("survival")) {
  coxph_plot(coxph(Surv(futime, fustat) ~ factor(rx), ovarian))
}

</code></pre>

<hr>
<h2 id='lm_plot'>Density plot for a given lm model
with one binary covariate.</h2><span id='topic+lm_plot'></span>

<h3>Description</h3>

<p>Can be used on its own but is also useable as plotfun in
<code><a href="#topic+node_pmterminal">node_pmterminal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_plot(
  mod,
  data = NULL,
  densest = FALSE,
  theme = theme_classic(),
  yrange = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_plot_+3A_mod">mod</code></td>
<td>
<p>A model of class lm.</p>
</td></tr>
<tr><td><code id="lm_plot_+3A_data">data</code></td>
<td>
<p>optional data frame. If NULL the data stored in mod is used.</p>
</td></tr>
<tr><td><code id="lm_plot_+3A_densest">densest</code></td>
<td>
<p>should additional to the model density kernel density estimates
(see <code><a href="ggplot2.html#topic+geom_density">geom_density</a></code>) be computed?</p>
</td></tr>
<tr><td><code id="lm_plot_+3A_theme">theme</code></td>
<td>
<p>A ggplot2 theme.</p>
</td></tr>
<tr><td><code id="lm_plot_+3A_yrange">yrange</code></td>
<td>
<p>Range of the y variable to be used for plotting.
If NULL the range in the data will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of an offset, the value of the offset variable will be set to
the median of the values in the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example taken from ?lm
ctl &lt;- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt &lt;- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group &lt;- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight &lt;- c(ctl, trt)
data &lt;- data.frame(weight, group)
lm.D9 &lt;- lm(weight ~ group, data = data)
lm_plot(lm.D9)

## example taken from ?glm (modified version)
data(anorexia, package = "MASS")
anorexia$treatment &lt;- factor(anorexia$Treat != "Cont")
anorex.1 &lt;- glm(Postwt ~ treatment + offset(Prewt),
                family = gaussian, data = anorexia)
lm_plot(anorex.1)

</code></pre>

<hr>
<h2 id='logLik.pmtree'>Extract log-Likelihood</h2><span id='topic+logLik.pmtree'></span>

<h3>Description</h3>

<p>Extract sum of log-Likelihood contributions of all terminal nodes. By default the degrees
of freedom from the models are used but optionally degrees of freedom for splits
can be incorporated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmtree'
logLik(object, dfsplit = 0, newdata = NULL, weights = NULL, perm = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.pmtree_+3A_object">object</code></td>
<td>
<p>pmtree object.</p>
</td></tr>
<tr><td><code id="logLik.pmtree_+3A_dfsplit">dfsplit</code></td>
<td>
<p>degrees of freedom per selected split.</p>
</td></tr>
<tr><td><code id="logLik.pmtree_+3A_newdata">newdata</code></td>
<td>
<p>an optional new data frame for which to compute the sum of 
objective functions.</p>
</td></tr>
<tr><td><code id="logLik.pmtree_+3A_weights">weights</code></td>
<td>
<p>weights.</p>
</td></tr>
<tr><td><code id="logLik.pmtree_+3A_perm">perm</code></td>
<td>
<p>the number of permutations performed (see <code><a href="partykit.html#topic+varimp">varimp</a></code>).</p>
</td></tr>
<tr><td><code id="logLik.pmtree_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+objfun.pmtree">objfun.pmtree</a></code> for the sum of contributions to the
objective function (not the same when partitioning linear models <code><a href="stats.html#topic+lm">lm</a></code>)
</p>

<hr>
<h2 id='node_pmterminal'>Panel-Generator for Visualization of pmtrees</h2><span id='topic+node_pmterminal'></span>

<h3>Description</h3>

<p>The plot method for party and constparty objects are rather flexible and can
be extended by panel functions. The pre-defined panel-generating function of
class grapcon_generator for pmtrees is documented here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_pmterminal(
  obj,
  coeftable = TRUE,
  digits = 2,
  confint = TRUE,
  plotfun,
  nid = function(node) paste0(nam[id_node(node)], ", n = ", node$info$nobs),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_pmterminal_+3A_obj">obj</code></td>
<td>
<p>an object of class party.</p>
</td></tr>
<tr><td><code id="node_pmterminal_+3A_coeftable">coeftable</code></td>
<td>
<p>logical or function. If logical: should a table with
coefficients be added to the plot (TRUE/FALSE)? If function: A function
comparable to <code><a href="#topic+coeftable.survreg">coeftable.survreg</a></code>.</p>
</td></tr>
<tr><td><code id="node_pmterminal_+3A_digits">digits</code></td>
<td>
<p>integer, used for formating numbers.</p>
</td></tr>
<tr><td><code id="node_pmterminal_+3A_confint">confint</code></td>
<td>
<p>Should a confidence interval be computed.</p>
</td></tr>
<tr><td><code id="node_pmterminal_+3A_plotfun">plotfun</code></td>
<td>
<p>Plotting function to be used. Needs to be of format
<code>function(mod, data)</code> where <code>mod</code> is the model object.
See examples for more details.</p>
</td></tr>
<tr><td><code id="node_pmterminal_+3A_nid">nid</code></td>
<td>
<p>function to retrieve info on what is plottet as node ids.</p>
</td></tr>
<tr><td><code id="node_pmterminal_+3A_...">...</code></td>
<td>
<p>arguments passed on to plotfun.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("survival")) {
## compute survreg model
mod_surv &lt;- survreg(Surv(futime, fustat) ~ factor(rx), ovarian,
  dist = 'weibull')
survreg_plot(mod_surv)

## partition model and plot
tr_surv &lt;- pmtree(mod_surv)
plot(tr_surv, terminal_panel = node_pmterminal(tr_surv, plotfun = survreg_plot,
                                               confint = TRUE))
}

if(require("survival") &amp; require("TH.data")) {
  ## Load data
  data(GBSG2, package = "TH.data")

  ## Weibull model
  bmod &lt;- survreg(Surv(time, cens) ~ horTh, data = GBSG2, model = TRUE)

  ## Coefficient table
  grid.newpage()
  coeftable.survreg(bmod)

  ## partitioned model
  tr &lt;- pmtree(bmod)

  ## plot with specific coeftable
  plot(tr, terminal_panel = node_pmterminal(tr, plotfun = survreg_plot,
    confint = TRUE, coeftable = coeftable.survreg))
}

</code></pre>

<hr>
<h2 id='objfun'>Objective function</h2><span id='topic+objfun'></span><span id='topic+objfun.survreg'></span><span id='topic+objfun.lm'></span><span id='topic+objfun.glm'></span>

<h3>Description</h3>

<p>Get the contributions of an objective function. For <code><a href="stats.html#topic+glm">glm</a></code>
these are the (weighted) log-likelihood contributions, for <code><a href="stats.html#topic+lm">lm</a></code> the
negative (weighted) squared error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objfun(x, ...)

## S3 method for class 'survreg'
objfun(x, newdata = NULL, weights = NULL, ...)

## S3 method for class 'lm'
objfun(x, newdata = NULL, weights = NULL, ...)

## S3 method for class 'glm'
objfun(x, newdata = NULL, weights = NULL, log = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objfun_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="objfun_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code>objfun</code> methods.</p>
</td></tr>
<tr><td><code id="objfun_+3A_newdata">newdata</code></td>
<td>
<p>optional. New data frame. Can be useful for model evaluation / benchmarking.</p>
</td></tr>
<tr><td><code id="objfun_+3A_weights">weights</code></td>
<td>
<p>optional. Prior weights. See <code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="objfun_+3A_log">log</code></td>
<td>
<p>should the log-Likelihood contributions or the Likelhood contributions be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of objective function contributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example taken from ?stats::glm
## Dobson (1990) Page 93: Randomized Controlled Trial :
counts &lt;- c(18,17,15,20,10,20,25,13,12) 
outcome &lt;- gl(3,1,9)
treatment &lt;- gl(3,3)
print(d.AD &lt;- data.frame(treatment, outcome, counts))
glm.D93 &lt;- glm(counts ~ outcome + treatment, family = poisson())
logLik_contributions &lt;- objfun(glm.D93)
sum(logLik_contributions)
logLik(glm.D93)

if(require("survival")) {
  x &lt;- survreg(Surv(futime, fustat) ~ rx, ovarian, dist = "weibull")
  newdata &lt;- ovarian[3:5, ]

  sum(objfun(x))
  x$loglik

  objfun(x, newdata = newdata)
}

</code></pre>

<hr>
<h2 id='objfun.pmodel_identity'>Objective function of personalised models</h2><span id='topic+objfun.pmodel_identity'></span><span id='topic+logLik.pmodel_identity'></span>

<h3>Description</h3>

<p>Get the contributions of an objective function (e.g. likelihood contributions)
and the sum thereof (e.g. log-Likelihood).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmodel_identity'
objfun(x, ...)

## S3 method for class 'pmodel_identity'
logLik(object, add_df = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objfun.pmodel_identity_+3A_x">x</code>, <code id="objfun.pmodel_identity_+3A_object">object</code></td>
<td>
<p>object of class pmodel_identity (obtained by <code>pmodel(..., fun = identity)</code>).</p>
</td></tr>
<tr><td><code id="objfun.pmodel_identity_+3A_...">...</code></td>
<td>
<p>additional parameters passed on to <code><a href="#topic+objfun">objfun</a></code>.</p>
</td></tr>
<tr><td><code id="objfun.pmodel_identity_+3A_add_df">add_df</code></td>
<td>
<p>it is not very clear what the degrees of freedom are in personalised models.
With this argument you can add/substract degrees of freedom at your convenience. Default
is <code>0</code> which means adding up the degrees of freedom of all individual models.
</p>
<p>For examples see <code><a href="#topic+pmodel">pmodel</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='objfun.pmtree'>Objective function of a given pmtree</h2><span id='topic+objfun.pmtree'></span>

<h3>Description</h3>

<p>Returns the contributions to the objective function or the 
sum thereof (if <code>sum = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmtree'
objfun(x, newdata = NULL, weights = NULL, perm = NULL, sum = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objfun.pmtree_+3A_x">x</code></td>
<td>
<p>pmtree object.</p>
</td></tr>
<tr><td><code id="objfun.pmtree_+3A_newdata">newdata</code></td>
<td>
<p>an optional new data frame for which to compute the sum of 
objective functions.</p>
</td></tr>
<tr><td><code id="objfun.pmtree_+3A_weights">weights</code></td>
<td>
<p>weights.</p>
</td></tr>
<tr><td><code id="objfun.pmtree_+3A_perm">perm</code></td>
<td>
<p>the number of permutations performed (see <code><a href="partykit.html#topic+varimp">varimp</a></code>).</p>
</td></tr>
<tr><td><code id="objfun.pmtree_+3A_sum">sum</code></td>
<td>
<p>should the sum of objective functions be computed.</p>
</td></tr>
<tr><td><code id="objfun.pmtree_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="partykit.html#topic+predict.party">predict.party</a></code>.
</p>
<p>Note that <code>objfun.pmtree(x, sum = TRUE)</code> is much faster than
<code>sum(objfun.pmtree(x))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>objective function or the sum thereof
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
set.seed(2)
n &lt;- 1000
trt &lt;- factor(rep(1:2, each = n/2))
age &lt;- sample(40:60, size = n, replace = TRUE)
eff &lt;- -1 + I(trt == 2) + 1 * I(trt == 2) * I(age &gt; 50)
expit &lt;- function(x) 1/(1 + exp(-x))
success &lt;- rbinom(n = n, size = 1, prob = expit(eff))
dat &lt;- data.frame(success, trt, age)

## compute base model
bmod1 &lt;- glm(success ~ trt, data = dat, family = binomial)

## copmute tree
(tr1 &lt;- pmtree(bmod1, data = dat))

## compute log-Likelihood
logLik(tr1)
objfun(tr1, newdata = dat, sum = TRUE)
objfun(tr1, sum = TRUE)

## log-Likelihood contributions of first 
## 5 observations
nd &lt;- dat[1:5, ]
objfun(tr1, newdata = nd)
</code></pre>

<hr>
<h2 id='one_factor'>Check if model has only one factor covariate.</h2><span id='topic+one_factor'></span>

<h3>Description</h3>

<p>See https://stackoverflow.com/questions/50504386/check-that-model-has-only-one-factor-covariate/50514499#50514499
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_factor(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_factor_+3A_object">object</code></td>
<td>
<p>model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if model has a single factor covariate, FALSE otherwise.
</p>

<hr>
<h2 id='pmforest'>Compute model-based forest from model.</h2><span id='topic+pmforest'></span><span id='topic+gettree.pmforest'></span>

<h3>Description</h3>

<p>Input a parametric model and get a forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmforest(
  model,
  data = NULL,
  zformula = ~.,
  ntree = 500L,
  perturb = list(replace = FALSE, fraction = 0.632),
  mtry = NULL,
  applyfun = NULL,
  cores = NULL,
  control = ctree_control(teststat = "quad", testtype = "Univ", mincriterion = 0,
    saveinfo = FALSE, lookahead = TRUE, ...),
  trace = FALSE,
  ...
)

## S3 method for class 'pmforest'
gettree(object, tree = 1L, saveinfo = TRUE, coeffun = coef, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmforest_+3A_model">model</code></td>
<td>
<p>a model object. The model can be a parametric model with a single binary covariate.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_data">data</code></td>
<td>
<p>data. If <code>NULL</code> the data from the model object are used.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_zformula">zformula</code></td>
<td>
<p>formula describing which variable should be used for partitioning.
Default is to use all variables in data that are not in the model (i.e. <code>~ .</code>).</p>
</td></tr>
<tr><td><code id="pmforest_+3A_ntree">ntree</code></td>
<td>
<p>number of trees.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_perturb">perturb</code></td>
<td>
<p>a list with arguments replace and fraction determining which type of
resampling with <code>replace = TRUE</code> referring to the n-out-of-n bootstrap and
<code>replace = FALSE</code> to sample splitting. fraction is the number of observations
to draw without replacement.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_mtry">mtry</code></td>
<td>
<p>number of input variables randomly sampled as candidates at each
node (Default <code>NULL</code> corresponds to <code>ceiling(sqrt(nvar))</code>).
Bagging, as special case of a random forest without random input variable
sampling, can be performed by setting mtry either equal to Inf or
equal to the number of input variables.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_applyfun">applyfun</code></td>
<td>
<p>see <code><a href="partykit.html#topic+cforest">cforest</a></code>.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_cores">cores</code></td>
<td>
<p>see <code><a href="partykit.html#topic+cforest">cforest</a></code>.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_control">control</code></td>
<td>
<p>control parameters, see <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_trace">trace</code></td>
<td>
<p>a logical indicating if a progress bar shall be printed while
the forest grows.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_...">...</code></td>
<td>
<p>additional parameters passed on to model fit such as weights.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_object">object</code></td>
<td>
<p>an object returned by pmforest.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_tree">tree</code></td>
<td>
<p>an integer, the number of the tree to extract from the forest.</p>
</td></tr>
<tr><td><code id="pmforest_+3A_saveinfo">saveinfo</code></td>
<td>
<p>logical. Should the model info be stored in terminal nodes?</p>
</td></tr>
<tr><td><code id="pmforest_+3A_coeffun">coeffun</code></td>
<td>
<p>function that takes the model object and returns the coefficients.
Useful when coef() does not return all coefficients (e.g. survreg).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cforest object
</p>


<h3>See Also</h3>

<p><code><a href="partykit.html#topic+gettree">gettree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("model4you")

if(require("mvtnorm") &amp; require("survival")) {
  
  ## function to simulate the data
  sim_data &lt;- function(n = 500, p = 10, beta = 3, sd = 1){
    
    ## treatment
    lev &lt;- c("C", "A")
    a &lt;- rep(factor(lev, labels = lev, levels = lev), length = n)
    
    ## correlated z variables
    sigma &lt;- diag(p) 
    sigma[sigma == 0] &lt;- 0.2
    ztemp &lt;- rmvnorm(n, sigma = sigma)
    z &lt;- (pnorm(ztemp) * 2 * pi) - pi  
    colnames(z) &lt;- paste0("z", 1:ncol(z))
    z1 &lt;- z[,1]
    
    ## outcome
    y &lt;- 7 + 0.2 * (a %in% "A") + beta * cos(z1) * (a %in% "A") + rnorm(n, 0, sd)
    
    data.frame(y = y, a = a, z)
  }
  
  ## simulate data
  set.seed(123)
  beta &lt;- 3
  ntrain &lt;- 500
  ntest &lt;- 50
  simdata &lt;- simdata_s &lt;- sim_data(p = 5, beta = beta, n = ntrain)
  tsimdata &lt;- tsimdata_s &lt;- sim_data(p = 5, beta = beta, n = ntest)
  simdata_s$cens &lt;- rep(1, ntrain)
  tsimdata_s$cens &lt;- rep(1, ntest)
  
  ## base model
  basemodel_lm &lt;- lm(y ~ a, data = simdata)
  
  ## forest
  frst_lm &lt;- pmforest(basemodel_lm, ntree = 20, 
                      perturb = list(replace = FALSE, fraction = 0.632),
                      control = ctree_control(mincriterion = 0))
  
  ## personalised models
  # (1) return the model objects
  pmodels_lm &lt;- pmodel(x = frst_lm, newdata = tsimdata, fun = identity)
  class(pmodels_lm)
  # (2) return coefficients only (default)
  coefs_lm &lt;- pmodel(x = frst_lm, newdata = tsimdata)
  
  # compare predictive objective functions of personalised models versus
  # base model
  sum(objfun(pmodels_lm)) # -RSS personalised models
  sum(objfun(basemodel_lm, newdata = tsimdata)) # -RSS base model
  
  
  if(require("ggplot2")) {
    ## dependence plot
    dp_lm &lt;- cbind(coefs_lm, tsimdata)
    ggplot(tsimdata) +
      stat_function(fun = function(z1) 0.2 + beta * cos(z1), 
                    aes(color = "true treatment\neffect")) +
      geom_point(data = dp_lm, 
                 aes(y = aA, x = z1, color = "estimates lm"), 
                 alpha = 0.5)  +
      ylab("treatment effect") + 
      xlab("patient characteristic z1")
  }
}

</code></pre>

<hr>
<h2 id='pmodel'>Personalised model</h2><span id='topic+pmodel'></span>

<h3>Description</h3>

<p>Compute personalised models from cforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmodel(
  x = NULL,
  model = NULL,
  newdata = NULL,
  OOB = TRUE,
  fun = coef,
  return_attr = c("modelcall", "data", "similarity")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmodel_+3A_x">x</code></td>
<td>
<p>cforest object or matrix of weights.</p>
</td></tr>
<tr><td><code id="pmodel_+3A_model">model</code></td>
<td>
<p>model object. If NULL the model in <code>x$info$model</code> is used.</p>
</td></tr>
<tr><td><code id="pmodel_+3A_newdata">newdata</code></td>
<td>
<p>new data. If NULL cforest learning data is used. Ignored if <code>x</code> is a matrix.</p>
</td></tr>
<tr><td><code id="pmodel_+3A_oob">OOB</code></td>
<td>
<p>In case of using the learning data, should patient similarities be
computed out of bag?</p>
</td></tr>
<tr><td><code id="pmodel_+3A_fun">fun</code></td>
<td>
<p>function to apply on the personalised model before returning. The
default <code>coef</code> returns a matrix of personalised coefficients. For returning
the model objects use <code>identity</code>.</p>
</td></tr>
<tr><td><code id="pmodel_+3A_return_attr">return_attr</code></td>
<td>
<p>which attributes to add to the object returned. If it contains
<code>"modelcall"</code> the call of the base model is returned, if it contains 
<code>"data"</code> the data, and if it contains <code>"similarity"</code> the matrix of 
similarity weights is added.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>depends on fun.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("model4you")

if(require("mvtnorm") &amp; require("survival")) {
  
  ## function to simulate the data
  sim_data &lt;- function(n = 500, p = 10, beta = 3, sd = 1){
    
    ## treatment
    lev &lt;- c("C", "A")
    a &lt;- rep(factor(lev, labels = lev, levels = lev), length = n)
    
    ## correlated z variables
    sigma &lt;- diag(p) 
    sigma[sigma == 0] &lt;- 0.2
    ztemp &lt;- rmvnorm(n, sigma = sigma)
    z &lt;- (pnorm(ztemp) * 2 * pi) - pi  
    colnames(z) &lt;- paste0("z", 1:ncol(z))
    z1 &lt;- z[,1]
    
    ## outcome
    y &lt;- 7 + 0.2 * (a %in% "A") + beta * cos(z1) * (a %in% "A") + rnorm(n, 0, sd)
    
    data.frame(y = y, a = a, z)
  }
  
  ## simulate data
  set.seed(123)
  beta &lt;- 3
  ntrain &lt;- 500
  ntest &lt;- 50
  simdata &lt;- simdata_s &lt;- sim_data(p = 5, beta = beta, n = ntrain)
  tsimdata &lt;- tsimdata_s &lt;- sim_data(p = 5, beta = beta, n = ntest)
  simdata_s$cens &lt;- rep(1, ntrain)
  tsimdata_s$cens &lt;- rep(1, ntest)
  
  ## base model
  basemodel_lm &lt;- lm(y ~ a, data = simdata)
  
  ## forest
  frst_lm &lt;- pmforest(basemodel_lm, ntree = 20, 
                      perturb = list(replace = FALSE, fraction = 0.632),
                      control = ctree_control(mincriterion = 0))
  
  ## personalised models
  # (1) return the model objects
  pmodels_lm &lt;- pmodel(x = frst_lm, newdata = tsimdata, fun = identity)
  class(pmodels_lm)
  # (2) return coefficients only (default)
  coefs_lm &lt;- pmodel(x = frst_lm, newdata = tsimdata)
  
  # compare predictive objective functions of personalised models versus
  # base model
  sum(objfun(pmodels_lm)) # -RSS personalised models
  sum(objfun(basemodel_lm, newdata = tsimdata)) # -RSS base model
  
  
  if(require("ggplot2")) {
    ## dependence plot
    dp_lm &lt;- cbind(coefs_lm, tsimdata)
    ggplot(tsimdata) +
      stat_function(fun = function(z1) 0.2 + beta * cos(z1), 
                    aes(color = "true treatment\neffect")) +
      geom_point(data = dp_lm, 
                 aes(y = aA, x = z1, color = "estimates lm"), 
                 alpha = 0.5)  +
      ylab("treatment effect") + 
      xlab("patient characteristic z1")
  }
}

</code></pre>

<hr>
<h2 id='pmtest'>Test if personalised models improve upon 
base model.</h2><span id='topic+pmtest'></span><span id='topic+plot.heterogeneity_test'></span>

<h3>Description</h3>

<p>This is a rudimentary test if there is 
heterogeneity in the model parameters.
The null-hypothesis is: the base model is the correct model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmtest(forest, pmodels = NULL, data = NULL, B = 100)

## S3 method for class 'heterogeneity_test'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmtest_+3A_forest">forest</code></td>
<td>
<p>pmforest object.</p>
</td></tr>
<tr><td><code id="pmtest_+3A_pmodels">pmodels</code></td>
<td>
<p>pmodel_identity object (pmodel(..., fun = identity)).</p>
</td></tr>
<tr><td><code id="pmtest_+3A_data">data</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id="pmtest_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="pmtest_+3A_x">x</code></td>
<td>
<p>object of class heterogeneity_test.</p>
</td></tr>
<tr><td><code id="pmtest_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list where the first element is the p-value und the 
second element is a data.frame with all neccessary infos to
compute the p-value.
</p>
<p>The test statistic is the difference in objective function between
the base model and the personalised models.
To compute the distribution under the Null we draw parametric bootstrap 
samples from the base model. For each bootstrap sample we again compute
the difference in objective function between the base model and the 
personalised models. If the difference in the original data is greater
than the difference in the bootstrap samples, we reject the null-hypothesis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
n &lt;- 160
trt &lt;- factor(rep(0:1, each = n/2))
y &lt;- 4 + (trt == 1) + rnorm(n)
z &lt;- matrix(rnorm(n * 2), ncol = 2)

dat &lt;- data.frame(y, trt, z)

mod &lt;- lm(y ~ trt, data = dat)

## Note that ntree should usually be higher
frst &lt;- pmforest(mod, ntree = 20) 
pmods &lt;- pmodel(frst, fun = identity)

## Note that B should be at least 100
## The low B is just for demonstration 
## purposes.
tst &lt;- pmtest(forest = frst, 
              pmodels = pmods, 
              B = 10) 
tst$pvalue
tst
plot(tst)

## End(Not run)

</code></pre>

<hr>
<h2 id='pmtree'>Compute model-based tree from model.</h2><span id='topic+pmtree'></span>

<h3>Description</h3>

<p>Input a parametric model and get a model-based tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmtree(
  model,
  data = NULL,
  zformula = ~.,
  control = ctree_control(),
  coeffun = coef,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmtree_+3A_model">model</code></td>
<td>
<p>a model object. The model can be a parametric model with a binary covariate.</p>
</td></tr>
<tr><td><code id="pmtree_+3A_data">data</code></td>
<td>
<p>data. If NULL (default) the data from the model object are used.</p>
</td></tr>
<tr><td><code id="pmtree_+3A_zformula">zformula</code></td>
<td>
<p>formula describing which variable should be used for partitioning.
Default is to use all variables in data that are not in the model (i.e. <code>~ .</code>).</p>
</td></tr>
<tr><td><code id="pmtree_+3A_control">control</code></td>
<td>
<p>control parameters, see <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code id="pmtree_+3A_coeffun">coeffun</code></td>
<td>
<p>function that takes the model object and returns the coefficients.
Useful when <code>coef()</code> does not return all coefficients (e.g. <code>survreg</code>).</p>
</td></tr>
<tr><td><code id="pmtree_+3A_...">...</code></td>
<td>
<p>additional parameters passed on to model fit such as weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes the number of participant in each treatment group needs to 
be of a certain size. This can be accomplished by setting <code>control$converged</code>.
See example below.
</p>


<h3>Value</h3>

<p>ctree object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("TH.data") &amp; require("survival")) {
  ## base model
  bmod &lt;- survreg(Surv(time, cens) ~ horTh, data = GBSG2, model = TRUE)
  survreg_plot(bmod)
  
  ## partitioned model
  tr &lt;- pmtree(bmod)
  plot(tr, terminal_panel = node_pmterminal(tr, plotfun = survreg_plot, 
                                            confint = TRUE))
  summary(tr)
  summary(tr, node = 1:2)
  
  logLik(bmod)
  logLik(tr)
  
  
  ## Sometimes the number of participant in each treatment group needs to 
  ## be of a certain size. This can be accomplished using converged
  
  ## Each treatment group should have more than 33 observations
  ctrl &lt;- ctree_control(lookahead = TRUE)
  ctrl$converged &lt;- function(mod, data, subset) {
      all(table(data$horTh[subset]) &gt; 33)
  }
  
  tr2 &lt;- pmtree(bmod, control = ctrl)
  plot(tr2, terminal_panel = node_pmterminal(tr, plotfun = survreg_plot,
      confint = TRUE))
  
  summary(tr2[[5]]$data$horTh)
}


if(require("psychotools")) {
  data("MathExam14W", package = "psychotools")
  
  ## scale points achieved to [0, 100] percent
  MathExam14W$tests &lt;- 100 * MathExam14W$tests/26
  MathExam14W$pcorrect &lt;- 100 * MathExam14W$nsolved/13
  
  ## select variables to be used
  MathExam &lt;- MathExam14W[ , c("pcorrect", "group", "tests", "study",
                               "attempt", "semester", "gender")]
  
  ## compute base model
  bmod_math &lt;- lm(pcorrect ~ group, data = MathExam)
  lm_plot(bmod_math, densest = TRUE)
  
  ## compute tree
  (tr_math &lt;- pmtree(bmod_math, control = ctree_control(maxdepth = 2)))
  plot(tr_math, terminal_panel = node_pmterminal(tr_math, plotfun = lm_plot, 
                                                 confint = FALSE))
  plot(tr_math, terminal_panel = node_pmterminal(tr_math, plotfun = lm_plot, 
                                                 densest = TRUE,
                                                 confint = TRUE))
  
  ## predict
  newdat &lt;- MathExam[1:5, ]
  
  # terminal nodes
  (nodes &lt;- predict(tr_math, type = "node", newdata = newdat))
  
  # response
  (pr &lt;- predict(tr_math, type = "pass", newdata = newdat))
  
  # response including confidence intervals, see ?predict.lm
  (pr1 &lt;- predict(tr_math, type = "pass", newdata = newdat,
                  predict_args = list(interval = "confidence")))
}
</code></pre>

<hr>
<h2 id='predict.pmtree'>pmtree predictions</h2><span id='topic+predict.pmtree'></span>

<h3>Description</h3>

<p>Compute predictions from pmtree object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmtree'
predict(
  object,
  newdata = NULL,
  type = "node",
  predict_args = list(),
  perm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.pmtree_+3A_object">object</code></td>
<td>
<p>pmtree object.</p>
</td></tr>
<tr><td><code id="predict.pmtree_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables with
which to predict, if omitted, <code>object$data</code> is used.</p>
</td></tr>
<tr><td><code id="predict.pmtree_+3A_type">type</code></td>
<td>
<p>character denoting the type of predicted value. The terminal node 
is returned for <code>"node"</code>. If <code>type = "pass"</code> the model 
predict method is used and arguments can be passed to it via <code>predict_args</code>.
If <code>type = "coef"</code> the the model coefficients are returned.</p>
</td></tr>
<tr><td><code id="predict.pmtree_+3A_predict_args">predict_args</code></td>
<td>
<p>If <code>type = "pass"</code> arguments can be passed on to the
model predict function.</p>
</td></tr>
<tr><td><code id="predict.pmtree_+3A_perm">perm</code></td>
<td>
<p>an optional character vector of variable names (or integer vector 
of variable location in <code>newdata</code>). Splits of nodes 
with a primary split in any of these variables will be permuted (after dealing 
with surrogates). Note that surrogate split in the perm variables will no be 
permuted.</p>
</td></tr>
<tr><td><code id="predict.pmtree_+3A_...">...</code></td>
<td>
<p>passed on to predict.party (e.g. <code>perm</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if(require("psychotools")) {
  data("MathExam14W", package = "psychotools")
  
  ## scale points achieved to [0, 100] percent
  MathExam14W$tests &lt;- 100 * MathExam14W$tests/26
  MathExam14W$pcorrect &lt;- 100 * MathExam14W$nsolved/13
  
  ## select variables to be used
  MathExam &lt;- MathExam14W[ , c("pcorrect", "group", "tests", "study",
                               "attempt", "semester", "gender")]
  
  ## compute base model
  bmod_math &lt;- lm(pcorrect ~ group, data = MathExam)
  lm_plot(bmod_math, densest = TRUE)
  
  ## compute tree
  (tr_math &lt;- pmtree(bmod_math, control = ctree_control(maxdepth = 2)))
  plot(tr_math, terminal_panel = node_pmterminal(tr_math, plotfun = lm_plot, 
                                                 confint = FALSE))
  plot(tr_math, terminal_panel = node_pmterminal(tr_math, plotfun = lm_plot, 
                                                 densest = TRUE,
                                                 confint = TRUE))
  
  ## predict
  newdat &lt;- MathExam[1:5, ]
  
  # terminal nodes
  (nodes &lt;- predict(tr_math, type = "node", newdata = newdat))
  
  # response
  (pr &lt;- predict(tr_math, type = "pass", newdata = newdat))
  
  # response including confidence intervals, see ?predict.lm
  (pr1 &lt;- predict(tr_math, type = "pass", newdata = newdat,
                  predict_args = list(interval = "confidence")))
}
</code></pre>

<hr>
<h2 id='print.pmtree'>Methods for pmtree</h2><span id='topic+print.pmtree'></span><span id='topic+summary.pmtree'></span><span id='topic+print.summary.pmtree'></span><span id='topic+coef.pmtree'></span>

<h3>Description</h3>

<p>Print and summary methods for pmtree objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmtree'
print(
  x,
  node = NULL,
  FUN = NULL,
  digits = getOption("digits") - 4L,
  footer = TRUE,
  ...
)

## S3 method for class 'pmtree'
summary(object, node = NULL, ...)

## S3 method for class 'summary.pmtree'
print(x, digits = 4, ...)

## S3 method for class 'pmtree'
coef(object, node = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pmtree_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="print.pmtree_+3A_node">node</code></td>
<td>
<p>node number, if any.</p>
</td></tr>
<tr><td><code id="print.pmtree_+3A_fun">FUN</code></td>
<td>
<p>formatinfo function.</p>
</td></tr>
<tr><td><code id="print.pmtree_+3A_digits">digits</code></td>
<td>
<p>number of digits.</p>
</td></tr>
<tr><td><code id="print.pmtree_+3A_footer">footer</code></td>
<td>
<p>should footer be included?</p>
</td></tr>
<tr><td><code id="print.pmtree_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="partykit.html#topic+print.party">print.party</a></code>.</p>
</td></tr>
<tr><td><code id="print.pmtree_+3A_object">object</code></td>
<td>
<p>object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>print
</p>

<hr>
<h2 id='rss'>Residual sum of squares</h2><span id='topic+rss'></span><span id='topic+rss.default'></span>

<h3>Description</h3>

<p>Returns the sum of the squared residuals for a given object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rss(object, ...)

## Default S3 method:
rss(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rss_+3A_object">object</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="rss_+3A_...">...</code></td>
<td>
<p>passed on to specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sum of the squared residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from ?lm
ctl &lt;- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt &lt;- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group &lt;- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight &lt;- c(ctl, trt)
lm.D9 &lt;- lm(weight ~ group)
rss(lm.D9)
</code></pre>

<hr>
<h2 id='survreg_plot'>Survival plot for a given survreg model
with one binary covariate.</h2><span id='topic+survreg_plot'></span>

<h3>Description</h3>

<p>Can be used on its own but is also useable as plotfun in
<code><a href="#topic+node_pmterminal">node_pmterminal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survreg_plot(mod, data = NULL, theme = theme_classic(), yrange = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survreg_plot_+3A_mod">mod</code></td>
<td>
<p>A model of class survreg.</p>
</td></tr>
<tr><td><code id="survreg_plot_+3A_data">data</code></td>
<td>
<p>optional data frame. If NULL the data stored in mod is used.</p>
</td></tr>
<tr><td><code id="survreg_plot_+3A_theme">theme</code></td>
<td>
<p>A ggplot2 theme.</p>
</td></tr>
<tr><td><code id="survreg_plot_+3A_yrange">yrange</code></td>
<td>
<p>Range of the y variable to be used for plotting.
If NULL it will be 0 to max(y).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("survival")) {
  survreg_plot(survreg(Surv(futime, fustat) ~ factor(rx), ovarian))
}

</code></pre>

<hr>
<h2 id='varimp.pmforest'>Variable Importance for pmforest</h2><span id='topic+varimp.pmforest'></span>

<h3>Description</h3>

<p>See <code><a href="partykit.html#topic+varimp.cforest">varimp.cforest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmforest'
varimp(
  object,
  nperm = 1L,
  OOB = TRUE,
  risk = function(x, ...) -objfun(x, sum = TRUE, ...),
  conditional = FALSE,
  threshold = 0.2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varimp.pmforest_+3A_object">object</code></td>
<td>
<p>DESCRIPTION.</p>
</td></tr>
<tr><td><code id="varimp.pmforest_+3A_nperm">nperm</code></td>
<td>
<p>the number of permutations performed.</p>
</td></tr>
<tr><td><code id="varimp.pmforest_+3A_oob">OOB</code></td>
<td>
<p>a logical determining whether the importance is computed from the 
out-of-bag sample or the learning sample (not suggested).</p>
</td></tr>
<tr><td><code id="varimp.pmforest_+3A_risk">risk</code></td>
<td>
<p>the risk to be evaluated. By default the objective function 
(e.g. log-Likelihood) is used.</p>
</td></tr>
<tr><td><code id="varimp.pmforest_+3A_conditional">conditional</code></td>
<td>
<p>a logical determining whether unconditional or conditional 
computation of the importance is performed.</p>
</td></tr>
<tr><td><code id="varimp.pmforest_+3A_threshold">threshold</code></td>
<td>
<p>the value of the test statistic or 1 - p-value of the 
association between the variable of interest and a covariate that must be 
exceeded inorder to include the covariate in the conditioning scheme for the 
variable of interest (only relevant if conditional = TRUE).</p>
</td></tr>
<tr><td><code id="varimp.pmforest_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+objfun">objfun</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 'mean decrease in accuracy' importance scores.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
