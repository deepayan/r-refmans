<!DOCTYPE html><html lang="en"><head><title>Help for package imputeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {imputeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#imputeR-package'><p>imputeR-package description</p></a></li>
<li><a href='#CubistR'><p>Cubist method for imputation</p></a></li>
<li><a href='#Detect'><p>Detect variable type in a data matrix</p></a></li>
<li><a href='#gbmC'><p>boosting tree for imputation</p></a></li>
<li><a href='#glmboostR'><p>Boosting for regression</p></a></li>
<li><a href='#guess'><p>Impute by (educated) guessing</p></a></li>
<li><a href='#impute'><p>General Imputation Framework in R</p></a></li>
<li><a href='#lassoC'><p>logistic regression with lasso for imputation</p></a></li>
<li><a href='#lassoR'><p>LASSO for regression</p></a></li>
<li><a href='#major'><p>Majority imputation for a vector</p></a></li>
<li><a href='#mixError'><p>Calculate mixed error when the imputed matrix is mixed type</p></a></li>
<li><a href='#mixGuess'><p>Naive imputation for mixed type data</p></a></li>
<li><a href='#mr'><p>calculate miss-classification error</p></a></li>
<li><a href='#orderbox'><p>Ordered boxplot for a data matrix</p></a></li>
<li><a href='#parkinson'><p>Parkinsons Data Set</p></a></li>
<li><a href='#pcrR'><p>Principle component regression for imputation</p></a></li>
<li><a href='#plotIm'><p>Plot function for imputation</p></a></li>
<li><a href='#plsR'><p>Partial Least Square regression for imputation</p></a></li>
<li><a href='#ridgeC'><p>Ridge regression with lasso for imputation</p></a></li>
<li><a href='#ridgeR'><p>Ridge shrinkage for regression</p></a></li>
<li><a href='#Rmse'><p>calculate the RMSE or NRMSE</p></a></li>
<li><a href='#rpartC'><p>classification tree for imputation</p></a></li>
<li><a href='#SimEval'><p>Evaluate imputation performance by simulation</p></a></li>
<li><a href='#SimIm'><p>Introduce some missing values into a data matrix</p></a></li>
<li><a href='#spect'><p>SPECT Heart Data Set</p></a></li>
<li><a href='#stepBackC'><p>Best subset for classification (backward)</p></a></li>
<li><a href='#stepBackR'><p>Best subset (backward direction) for regression</p></a></li>
<li><a href='#stepBothC'><p>Best subset for classification (both direction)</p></a></li>
<li><a href='#stepBothR'><p>Best subset for regression (both direction)</p></a></li>
<li><a href='#stepForC'><p>Best subset for classification (forward direction)</p></a></li>
<li><a href='#stepForR'><p>Best subset (forward direction) for regression</p></a></li>
<li><a href='#tic'><p>Insurance Company Benchmark (COIL 2000) Data Set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A General Multivariate Imputation Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Steffen Moritz <a href="https://orcid.org/0000-0002-0085-1804"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Lingbing Feng [aut],
  Gen Nowak [ctb],
  Alan. H. Welsh [ctb],
  Terry. J. O'Neill [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steffen Moritz &lt;steffen.moritz10@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multivariate Expectation-Maximization (EM) based imputation framework that offers several different algorithms. These include regularisation methods like Lasso and Ridge regression, tree-based models and dimensionality reduction methods like PCA and PLS.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SteffenMoritz/imputeR/issues">https://github.com/SteffenMoritz/imputeR/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/SteffenMoritz/imputeR">http://github.com/SteffenMoritz/imputeR</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, reshape2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, caret, glmnet, pls, Cubist, ridge, gbm, mboost,
rpart, earth</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-20 21:49:42 UTC; Steve</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-20 22:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='imputeR-package'>imputeR-package description</h2><span id='topic+imputeR-package'></span>

<h3>Description</h3>

<p>The imputeR package offers a General Multivariate Imputation Framework
</p>


<h3>Details</h3>

<p>The imputeR package is a Multivariate Expectation-Maximization (EM) based imputation framework that offers several
different algorithms. These include regularisation methods like Lasso and Ridge regression, tree-based models and dimensionality
reduction methods like PCA and PLS.
</p>


<h3>Author(s)</h3>

<p>Steffen Moritz, Lingbing Feng, Gen Nowak, Alan. H. Welsh, Terry. J. O'Neill
</p>

<hr>
<h2 id='CubistR'>Cubist method for imputation</h2><span id='topic+CubistR'></span>

<h3>Description</h3>

<p>Quinlan's Cubist model for imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CubistR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CubistR_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="CubistR_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
and the optimal value for the &quot;neighbors&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="Cubist.html#topic+cubist">cubist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
missdata &lt;- SimIm(parkinson, 0.1)

impdata &lt;- impute(missdata, lmFun = "CubistR")

</code></pre>

<hr>
<h2 id='Detect'>Detect variable type in a data matrix</h2><span id='topic+Detect'></span>

<h3>Description</h3>

<p>This function detects the type of the variables in a data matrix. Types 
can be continuous only, categorical only or mixed type. The rule for
defining a variable as a categorical variable is when: (1) it is a character
vector, (2) it contains no more than n = 5 unique values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Detect(x, n = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Detect_+3A_x">x</code></td>
<td>
<p>is the data matrix that need to be detected.</p>
</td></tr>
<tr><td><code id="Detect_+3A_n">n</code></td>
<td>
<p>is a number, indicating how many levels, if outnumbered, can be seen
as an numeric variable, rather than a categorical variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the variable type for every column, can either be &quot;numeric&quot; or
&quot;character&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
Detect(parkinson)
data(spect)
Detect(spect)
data(tic)
table(Detect(tic))
</code></pre>

<hr>
<h2 id='gbmC'>boosting tree for imputation</h2><span id='topic+gbmC'></span>

<h3>Description</h3>

<p>boosting tree for imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbmC(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbmC_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="gbmC_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
and the best.iter for gbm model.
</p>


<h3>See Also</h3>

<p><code><a href="gbm.html#topic+gbm">gbm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spect)
missdata &lt;- SimIm(spect, 0.1)

impdata &lt;- impute(spect, cFun = "gbmC")

</code></pre>

<hr>
<h2 id='glmboostR'>Boosting for regression</h2><span id='topic+glmboostR'></span>

<h3>Description</h3>

<p>boosting variable selection for continuous data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmboostR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmboostR_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="glmboostR_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
missdata &lt;- SimIm(parkinson, 0.1)

impdata &lt;- impute(missdata, lmFun = "glmboostR")

</code></pre>

<hr>
<h2 id='guess'>Impute by (educated) guessing</h2><span id='topic+guess'></span>

<h3>Description</h3>

<p>This function use some primitive methods, including mean imputation, 
median imputation, random guess, or majority imputation (only for categorical
variables), to impute a missing data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess(x, type = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guess_+3A_x">x</code></td>
<td>
<p>a matrix or data frame</p>
</td></tr>
<tr><td><code id="guess_+3A_type">type</code></td>
<td>
<p>is the guessing type, including &quot;mean&quot; for mean imputation, 
&quot;median&quot; for median imputation, &quot;random&quot; for random guess, and &quot;majority&quot; for
majority imputation for categorical variables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
# introduce some random missing values
missdata &lt;- SimIm(parkinson, 0.1)
# impute by mean imputation
impdata &lt;- guess(missdata)
# caculate the NRMSE
Rmse(impdata, missdata, parkinson, norm = TRUE)
# by random guessing, the NRMSE should be much bigger
impdata2 &lt;- guess(missdata, "random")
Rmse(impdata2, missdata, parkinson, norm = TRUE)
</code></pre>

<hr>
<h2 id='impute'>General Imputation Framework in R</h2><span id='topic+impute'></span>

<h3>Description</h3>

<p>Impute missing values under the general framework in R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute(missdata, lmFun = NULL, cFun = NULL, ini = NULL,
  maxiter = 100, verbose = TRUE, conv = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute_+3A_missdata">missdata</code></td>
<td>
<p>data matrix with missing values encoded as NA.</p>
</td></tr>
<tr><td><code id="impute_+3A_lmfun">lmFun</code></td>
<td>
<p>the variable selection method for continuous data.</p>
</td></tr>
<tr><td><code id="impute_+3A_cfun">cFun</code></td>
<td>
<p>the variable selection method for categorical data.</p>
</td></tr>
<tr><td><code id="impute_+3A_ini">ini</code></td>
<td>
<p>the method for initilisation. It is a length one character if
missdata contains only one type of variables only. For continous only data, 
ini can be &quot;mean&quot; (mean imputation), &quot;median&quot; (median imputation) or &quot;random&quot;
(random guess), the default is &quot;mean&quot;. For categorical data, it can be 
either &quot;majority&quot; or &quot;random&quot;, the default is &quot;majority&quot;. If missdata is 
mixed of continuous and categorical data, then ini has to be a vector of two
characters, with the first element indicating the method for continous 
variables and the other element for categorical variables, and the default
is c(&quot;mean&quot;, &quot;majority&quot;.)</p>
</td></tr>
<tr><td><code id="impute_+3A_maxiter">maxiter</code></td>
<td>
<p>is the maximum number of interations</p>
</td></tr>
<tr><td><code id="impute_+3A_verbose">verbose</code></td>
<td>
<p>is logical, if TRUE then detailed information will
be printed in the console while running.</p>
</td></tr>
<tr><td><code id="impute_+3A_conv">conv</code></td>
<td>
<p>logical, if TRUE, the convergence details will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can impute several kinds of data, including continuous-only
data, categorical-only data and mixed-type data. Many methods can be used, including
regularisation method like LASSO and ridge regression, tree-based model and dimensionality
reduction method like PCA and PLS.
</p>


<h3>Value</h3>

<p>if conv = FALSE, it returns a completed data matrix with no
missing values; if TRUE, it rrturns a list of components including:
</p>
<table role = "presentation">
<tr><td><code>imp</code></td>
<td>
<p>the imputed data matrix with no missing values</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>the convergence status during the imputation</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+SimIm">SimIm</a></code> for missing value simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
# introduce 10% random missing values into the parkinson data
missdata &lt;- SimIm(parkinson, 0.1)
# impute the missing values by LASSO

impdata &lt;- impute(missdata, lmFun = "lassoR")
# calculate the normalised RMSE for the imputation
Rmse(impdata$imp, missdata, parkinson, norm = TRUE)

</code></pre>

<hr>
<h2 id='lassoC'>logistic regression with lasso for imputation</h2><span id='topic+lassoC'></span>

<h3>Description</h3>

<p>logistic regression with lasso for imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lassoC(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lassoC_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="lassoC_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>See Also</h3>

<p><code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code> and <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spect)
missdata &lt;- SimIm(spect, 0.1)

impdata &lt;- impute(spect, cFun = "lassoC")

</code></pre>

<hr>
<h2 id='lassoR'>LASSO for regression</h2><span id='topic+lassoR'></span>

<h3>Description</h3>

<p>LASSO variable selection for continuous data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lassoR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lassoR_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="lassoR_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
missdata &lt;- SimIm(parkinson, 0.1)

impdata &lt;- impute(missdata, lmFun = "lassoR")

</code></pre>

<hr>
<h2 id='major'>Majority imputation for a vector</h2><span id='topic+major'></span>

<h3>Description</h3>

<p>This function is internally used by <code><a href="#topic+guess">guess</a></code>, it 
may be useless in reality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>major(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="major_+3A_x">x</code></td>
<td>
<p>a character (or numeric categorical) vector with missing values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same length of vector with missing values being imputed by the majority class
in this vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(rep(0, 10), rep(1, 15), rep(2, 5))
a[sample(seq_along(a), 5)] &lt;- NA
a
b &lt;- major(a)
b
</code></pre>

<hr>
<h2 id='mixError'>Calculate mixed error when the imputed matrix is mixed type</h2><span id='topic+mixError'></span>

<h3>Description</h3>

<p>Calculate mixed error when the imputed matrix is mixed type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixError(imp, mis, true, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixError_+3A_imp">imp</code></td>
<td>
<p>the imputed matrix</p>
</td></tr>
<tr><td><code id="mixError_+3A_mis">mis</code></td>
<td>
<p>the original matrix with missing values</p>
</td></tr>
<tr><td><code id="mixError_+3A_true">true</code></td>
<td>
<p>the true matrix</p>
</td></tr>
<tr><td><code id="mixError_+3A_norm">norm</code></td>
<td>
<p>logical, if TRUE, the nomailised RMSE will return for continous 
variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of two values indicating the mixed error the the imputation,
the first one if either RMSE or NRMSE, the second one is MCE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tic)
Detect(tic)
missdata &lt;- SimIm(tic, 0.3)

library(earth)
impdata &lt;- impute(tic, lmFun = "earth", cFun = "rpartC")
mixError(impdata$imp, missdata, tic)

</code></pre>

<hr>
<h2 id='mixGuess'>Naive imputation for mixed type data</h2><span id='topic+mixGuess'></span>

<h3>Description</h3>

<p>Naive imputation for mixed type data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixGuess(missdata, method = c("mean", "majority"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixGuess_+3A_missdata">missdata</code></td>
<td>
<p>a data matrix with missing values</p>
</td></tr>
<tr><td><code id="mixGuess_+3A_method">method</code></td>
<td>
<p>a character vector of length 2 indicating which two methods to use
respectively for continuous variables and categorical variables. There are three options
for continous variables: &quot;mean&quot;, &quot;median&quot; and &quot;random&quot;, and two options for categorical
varaibles: &quot;majority&quot; and &quot;random&quot;. The default method is &quot;mean&quot; for the continous part
and &quot;majority&quot; for the categorical part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same size data matrix with no missing value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tic)
missdata &lt;- SimIm(tic, 0.1)
sum(is.na(missdata))
impdata &lt;- mixGuess(missdata)
sum(is.na(impdata))
</code></pre>

<hr>
<h2 id='mr'>calculate miss-classification error</h2><span id='topic+mr'></span>

<h3>Description</h3>

<p>This function calculates the misclassfication error given the imputed data, 
the missing data and the true data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mr(imp, mis, true)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mr_+3A_imp">imp</code></td>
<td>
<p>the imputaed data matrix</p>
</td></tr>
<tr><td><code id="mr_+3A_mis">mis</code></td>
<td>
<p>the missing data matrix</p>
</td></tr>
<tr><td><code id="mr_+3A_true">true</code></td>
<td>
<p>the ture data matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The missclassification error
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spect)
Detect(spect)
missdata &lt;- SimIm(spect, 0.1)

sum(is.na(missdata))
# impute using rpart
impdata &lt;- impute(missdata, cFun = "rpartC")
# calculate the misclassification error
mr(impdata$imp, missdata, spect)

</code></pre>

<hr>
<h2 id='orderbox'>Ordered boxplot for a data matrix</h2><span id='topic+orderbox'></span>

<h3>Description</h3>

<p>Ordered boxplot for a data matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderbox(x, names = c("method", "MCE"), order.by = mean,
  decreasing = TRUE, notch = TRUE, col = "bisque", mar = c(7, 4.1,
  4.1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderbox_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="orderbox_+3A_names">names</code></td>
<td>
<p>a length two character vector, default is c(&quot;method, &quot;MCE&quot;)</p>
</td></tr>
<tr><td><code id="orderbox_+3A_order.by">order.by</code></td>
<td>
<p>which statistics to order by, default is mean</p>
</td></tr>
<tr><td><code id="orderbox_+3A_decreasing">decreasing</code></td>
<td>
<p>default is TRUE, the boxplot will be arranged in a decreasing order</p>
</td></tr>
<tr><td><code id="orderbox_+3A_notch">notch</code></td>
<td>
<p>logical, default is TRUE</p>
</td></tr>
<tr><td><code id="orderbox_+3A_col">col</code></td>
<td>
<p>color for the boxplots, default is &quot;bisque&quot;.</p>
</td></tr>
<tr><td><code id="orderbox_+3A_mar">mar</code></td>
<td>
<p>the margin for the plot, adjust it to your need.</p>
</td></tr>
<tr><td><code id="orderbox_+3A_...">...</code></td>
<td>
<p>some other arguments that can be passed to the boxplot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boxplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)

orderbox(parkinson)

</code></pre>

<hr>
<h2 id='parkinson'>Parkinsons Data Set</h2><span id='topic+parkinson'></span>

<h3>Description</h3>

<p>This dataset contains a range of biomedical voice measurements from 31 people, 23 with 
Parkinson's disease. Each row corresponds to one of 195 individuals and each column a
measurement variable. This data was originally obtaind from the UCI Machine Learning Repository.
For detailed information about the columns, see the reference and the source below. 
In the study of simulation, this dataset can be treated as continuous-only data
</p>


<h3>Format</h3>

<p>A data frame with 195 rows and 22 variables</p>


<h3>Details</h3>


<ul>
<li><p> MDVP:Fo(Hz). Average vocal fundamental frequency  
</p>
</li>
<li><p> MDVP:Fhi(Hz). Maximum vocal fundamental frequency 
</p>
</li>
<li><p> MDVP:Flo(Hz). Minimum vocal fundamental frequency 
</p>
</li>
<li><p> ...
</p>
</li></ul>



<h3>Source</h3>

<p><a href="http://archive.ics.uci.edu/ml/datasets/Parkinsons">http://archive.ics.uci.edu/ml/datasets/Parkinsons</a>
</p>


<h3>References</h3>

<p>Little MA, McSharry PE, Roberts SJ, Costello DAE, Moroz IM, 2007 
Exploiting Nonlinear Recurrence and Fractal Scaling Properties for Voice Disorder Detection,
<em>BioMedical Engineering OnLine</em>
</p>

<hr>
<h2 id='pcrR'>Principle component regression for imputation</h2><span id='topic+pcrR'></span>

<h3>Description</h3>

<p>Principle component regression method for imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcrR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcrR_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="pcrR_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>See Also</h3>

<p><code><a href="pls.html#topic+pcr">pcr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
missdata &lt;- SimIm(parkinson, 0.1)

impdata &lt;- impute(missdata, lmFun = "pcrR")

</code></pre>

<hr>
<h2 id='plotIm'>Plot function for imputation</h2><span id='topic+plotIm'></span>

<h3>Description</h3>

<p>this is a plot function for assessing imputation performance given the imputed data
and the original true data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotIm(imp, mis, true, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotIm_+3A_imp">imp</code></td>
<td>
<p>the imputed data matrix</p>
</td></tr>
<tr><td><code id="plotIm_+3A_mis">mis</code></td>
<td>
<p>the missing data matrix</p>
</td></tr>
<tr><td><code id="plotIm_+3A_true">true</code></td>
<td>
<p>the true data matrix</p>
</td></tr>
<tr><td><code id="plotIm_+3A_...">...</code></td>
<td>
<p>other arguments that can be passed to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot object that show the imputation performance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
# introduce 10% random missing values into the parkinson data
missdata &lt;- SimIm(parkinson, 0.1)

# impute the missing values by LASSO
impdata &lt;- impute(missdata, lmFun = "lassoR")

# calculate the normalised RMSE for the imputation
Rmse(impdata$imp, missdata, parkinson, norm = T)

# Plot imputation performance
plotIm(impdata$imp, missdata, parkinson)

</code></pre>

<hr>
<h2 id='plsR'>Partial Least Square regression for imputation</h2><span id='topic+plsR'></span>

<h3>Description</h3>

<p>Principle component regression method for imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plsR_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="plsR_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>See Also</h3>

<p><code><a href="pls.html#topic+plsr">plsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
missdata &lt;- SimIm(parkinson, 0.1)

impdata &lt;- impute(missdata, lmFun = "plsR")

</code></pre>

<hr>
<h2 id='ridgeC'>Ridge regression with lasso for imputation</h2><span id='topic+ridgeC'></span>

<h3>Description</h3>

<p>Ridge regression with lasso for imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridgeC(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ridgeC_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="ridgeC_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>See Also</h3>

<p><code><a href="ridge.html#topic+logisticRidge">logisticRidge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spect)
missdata &lt;- SimIm(spect, 0.1)

impdata &lt;- impute(spect, cFun = "ridgeC")

</code></pre>

<hr>
<h2 id='ridgeR'>Ridge shrinkage for regression</h2><span id='topic+ridgeR'></span>

<h3>Description</h3>

<p>Ridge shrinkage variable selection for continuous data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridgeR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ridgeR_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="ridgeR_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
missdata &lt;- SimIm(parkinson, 0.1)

impdata &lt;- impute(missdata, lmFun = "ridgeR")

</code></pre>

<hr>
<h2 id='Rmse'>calculate the RMSE or NRMSE</h2><span id='topic+Rmse'></span>

<h3>Description</h3>

<p>This function calculate imputation error given the imputed data, the missing
data and the true data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmse(imp, mis, true, norm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rmse_+3A_imp">imp</code></td>
<td>
<p>the imputaed data matrix</p>
</td></tr>
<tr><td><code id="Rmse_+3A_mis">mis</code></td>
<td>
<p>the missing data matrix</p>
</td></tr>
<tr><td><code id="Rmse_+3A_true">true</code></td>
<td>
<p>the true data matrix</p>
</td></tr>
<tr><td><code id="Rmse_+3A_norm">norm</code></td>
<td>
<p>logical, if TRUE then the normalized RMSE will be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the RMSE or NRMSE
</p>


<h3>See Also</h3>

<p><code><a href="#topic+impute">impute</a></code> for the main imputation function, 
<code><a href="#topic+mr">mr</a></code> for the misclassification error metric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
# introduce 10% random missing values into the parkinson data
missdata &lt;- SimIm(parkinson, 0.1)

# impute the missing values by LASSO
impdata &lt;- impute(missdata, lmFun = "lassoR")

# calculate the normalised RMSE for the imputation
Rmse(impdata$imp, missdata, parkinson, norm = TRUE)

</code></pre>

<hr>
<h2 id='rpartC'>classification tree for imputation</h2><span id='topic+rpartC'></span>

<h3>Description</h3>

<p>classification tree for imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpartC(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpartC_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="rpartC_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>See Also</h3>

<p><code><a href="rpart.html#topic+rpart">rpart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spect)
missdata &lt;- SimIm(spect, 0.1)

impdata &lt;- impute(spect, cFun = "rpartC")

</code></pre>

<hr>
<h2 id='SimEval'>Evaluate imputation performance by simulation</h2><span id='topic+SimEval'></span>

<h3>Description</h3>

<p>Evaluate imputation performance by simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimEval(data, task = NULL, p = 0.1, n.sim = 100, ini = "mean",
  method = NULL, guess = FALSE, guess.method = NULL, other = NULL,
  verbose = TRUE, seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimEval_+3A_data">data</code></td>
<td>
<p>is the complete data matrix that will be used for simulation</p>
</td></tr>
<tr><td><code id="SimEval_+3A_task">task</code></td>
<td>
<p>task type, either be 1 for regression, 2 for classification or 3 for
mixed type</p>
</td></tr>
<tr><td><code id="SimEval_+3A_p">p</code></td>
<td>
<p>is the percentage of missing values that will be introduction into
data, it has to be a value between 0 and 1</p>
</td></tr>
<tr><td><code id="SimEval_+3A_n.sim">n.sim</code></td>
<td>
<p>the number of simulations, default is 100 times</p>
</td></tr>
<tr><td><code id="SimEval_+3A_ini">ini</code></td>
<td>
<p>is the initialization setting for some relevant imputation methods
, the default setting is &quot;mean&quot;, while &quot;median&quot; and &quot;random&quot; can also be 
used. See also <code><a href="#topic+guess">guess</a></code></p>
</td></tr>
<tr><td><code id="SimEval_+3A_method">method</code></td>
<td>
<p>the imputaion method based on variable selection for simulation
some other imputation method can be passed to the 'other' argument</p>
</td></tr>
<tr><td><code id="SimEval_+3A_guess">guess</code></td>
<td>
<p>logical value, if is TRUE, then <code><a href="#topic+guess">guess</a></code> will be used
as the imputation method for simulation</p>
</td></tr>
<tr><td><code id="SimEval_+3A_guess.method">guess.method</code></td>
<td>
<p>guess type for the guess function. It cannot be NULL if guess is TRUE</p>
</td></tr>
<tr><td><code id="SimEval_+3A_other">other</code></td>
<td>
<p>some other imputation method that is based on variable selection
can be used. The requirement for this 'other' method is strict: it receives
a data matrix including missing values and returns a complete data matrix.</p>
</td></tr>
<tr><td><code id="SimEval_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE, additional output information will be provided 
during iterations, i.e., the method that is using, the iteration number,
the convegence difference as compared to the precious iteration. The 
progression bar will show up irrespective of this option and it can not be
got rid of.</p>
</td></tr>
<tr><td><code id="SimEval_+3A_seed">seed</code></td>
<td>
<p>set the seed for simulation so simulations using different imputation
methods are comparable. The default value is set to 1234, which is not supposed to 
mean anything. But if 1234 is used, then the seed for simulating the first
missing data matrix is 1234, then it sums by one for every subsequent
simulationg data matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of componentes including
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the method used for imputation</p>
</td></tr>  
<tr><td><code>task</code></td>
<td>
<p>the name of the task</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>computational time</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>the imputation error</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>the number of iterations to converge</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
# WARNING: simulation may take considerable time.

SimEval(parkinson, method = "lassoR")

</code></pre>

<hr>
<h2 id='SimIm'>Introduce some missing values into a data matrix</h2><span id='topic+SimIm'></span>

<h3>Description</h3>

<p>This function randomly introduce some amount of missing values into a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimIm(data, p = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimIm_+3A_data">data</code></td>
<td>
<p>a data matrix to simulate</p>
</td></tr>
<tr><td><code id="SimIm_+3A_p">p</code></td>
<td>
<p>the percentage of missing values introduced into the data matrix
it should be a value between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same size matrix with simulated missing values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create data without missing values as example
simdata &lt;- matrix(rnorm(100), 10, 10)

# Now let's introduce some missing values into the dataset
missingdata &lt;- SimIm(simdata, p = 0.15)

# count the number of missing values afterwards
sum(is.na(missingdata))

#------------------

# There is no missing values in the original parkinson data
data(parkinson)

# Let's introduce some missing values into the dataset
missdata &lt;- SimIm(parkinson, 0.1)

# count the number of missing values afterwards
sum(is.na(missdata))
</code></pre>

<hr>
<h2 id='spect'>SPECT Heart Data Set</h2><span id='topic+spect'></span>

<h3>Description</h3>

<p>The dataset describes diagnosing of cardiac Single Proton Emission Computed Tomography (SPECT) images
Each of the patients is classified into two categories: normal and abnormal. 
The database of 267 SPECT image sets (patients) was processed to extract features 
that summarize the original SPECT images. As a result, 44 continuous feature pattern
was created for each patient. The pattern was further processed to obtain 22 binary feature patterns. 
The CLIP3 algorithm was used to generate classification rules from these patterns. 
The CLIP3 algorithm generated rules that were 84.0
SPECT is a good data set for testing ML algorithms; it has 267 instances that are descibed by 23 binary attributes.
In the imputation study, it can be treated as a categorical-only data. For detailed information, please refer to
the Source and the Reference
</p>


<h3>Format</h3>

<p>A data frame with 266 rows and 23 variables</p>


<h3>Details</h3>


<ul>
<li><p> X1. OVERALL_DIAGNOSIS: 0,1 (class attribute, binary) 
</p>
</li>
<li><p> X0. F1: 0,1 (the partial diagnosis 1, binary) 
</p>
</li>
<li><p> ...
</p>
</li></ul>



<h3>Source</h3>

<p><a href="http://archive.ics.uci.edu/ml/datasets/SPECT+Heart">http://archive.ics.uci.edu/ml/datasets/SPECT+Heart</a>
</p>


<h3>References</h3>

<p>Kurgan, L.A., Cios, K.J., Tadeusiewicz, R., Ogiela, M. &amp; Goodenday, L.S. 2001
Knowledge Discovery Approach to Automated Cardiac SPECT Diagnosis 
<em>Artificial Intelligence in Medicine</em>, vol. 23:2, pp 149-169
</p>

<hr>
<h2 id='stepBackC'>Best subset for classification (backward)</h2><span id='topic+stepBackC'></span>

<h3>Description</h3>

<p>Best subset variable selection from both forward and backward
direction for categorical data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepBackC(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepBackC_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="stepBackC_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+step">step</a></code>, <code><a href="#topic+stepBackR">stepBackR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spect)
missdata &lt;- SimIm(spect, 0.1)

impdata &lt;- impute(spect, cFun = "stepBackC")

</code></pre>

<hr>
<h2 id='stepBackR'>Best subset (backward direction) for regression</h2><span id='topic+stepBackR'></span>

<h3>Description</h3>

<p>Best subset variable selection (backward direction) for continuous data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepBackR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepBackR_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="stepBackR_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
missdata &lt;- SimIm(parkinson, 0.1)

impdata &lt;- impute(missdata, lmFun = "stepBackR")

</code></pre>

<hr>
<h2 id='stepBothC'>Best subset for classification (both direction)</h2><span id='topic+stepBothC'></span>

<h3>Description</h3>

<p>Best subset variable selection from both forward and backward
direction for categorical data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepBothC(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepBothC_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="stepBothC_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+step">step</a></code>, <code><a href="#topic+stepBothR">stepBothR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spect)
missdata &lt;- SimIm(spect, 0.1)

impdata &lt;- impute(spect, cFun = "stepBothC")

</code></pre>

<hr>
<h2 id='stepBothR'>Best subset for regression (both direction)</h2><span id='topic+stepBothR'></span>

<h3>Description</h3>

<p>Best subset variable selection from both forward and backward
direction for continuous data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepBothR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepBothR_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="stepBothR_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
missdata &lt;- SimIm(parkinson, 0.1)

impdata &lt;- impute(missdata, lmFun = "stepBothR")

</code></pre>

<hr>
<h2 id='stepForC'>Best subset for classification (forward direction)</h2><span id='topic+stepForC'></span>

<h3>Description</h3>

<p>Best subset variable selection from both forward and backward
direction for categorical data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepForC(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepForC_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="stepForC_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+step">step</a></code>, <code><a href="#topic+stepForR">stepForR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spect)
missdata &lt;- SimIm(spect, 0.1)

impdata &lt;- impute(spect, cFun = "stepForC")

</code></pre>

<hr>
<h2 id='stepForR'>Best subset (forward direction) for regression</h2><span id='topic+stepForR'></span>

<h3>Description</h3>

<p>Best subset variable selection (forward direction) for continuous data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepForR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepForR_+3A_x">x</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="stepForR_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model object that can be used by the <code><a href="#topic+impute">impute</a></code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(parkinson)
missdata &lt;- SimIm(parkinson, 0.1)

impdata &lt;- impute(missdata, lmFun = "stepForR")

</code></pre>

<hr>
<h2 id='tic'>Insurance Company Benchmark (COIL 2000) Data Set</h2><span id='topic+tic'></span>

<h3>Description</h3>

<p>This data set used in the CoIL 2000 Challenge contains information on customers of an insurance company. 
The data consists of 86 variables and includes product usage data and socio-demographic data. Detailed
information, please refer to the Source. For imputation study, this dataset can be treated as a mixed-type
data.
</p>


<h3>Format</h3>

<p>A data frame with 266 rows and 23 variables</p>


<h3>Details</h3>


<ul>
<li><p> V1. a numeric variable
</p>
</li>
<li><p> V2. a categorical variable
</p>
</li>
<li><p> ...
</p>
</li></ul>



<h3>Source</h3>

<p><a href="http://archive.ics.uci.edu/ml/datasets/Insurance+Company+Benchmark+(COIL+2000)">http://archive.ics.uci.edu/ml/datasets/Insurance+Company+Benchmark+(COIL+2000)</a>
</p>


<h3>References</h3>

<p>P. van der Putten and M. van Someren (eds). CoIL Challenge 2000: 
The Insurance Company Case. Published by Sentient Machine Research, Amsterdam. 
Also a Leiden Institute of Advanced Computer Science Technical Report 2000-09. June 22, 2000.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
