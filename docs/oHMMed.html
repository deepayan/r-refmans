<!DOCTYPE html><html><head><title>Help for package oHMMed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {oHMMed}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#oHMMed-package'><p>oHMMed: HMMs with Ordered Hidden States and Emission Densities</p></a></li>
<li><a href='#coef.hmm_mcmc_normal'><p>Extract Model Estimates</p></a></li>
<li><a href='#conf_mat'><p>Calculate and Visualise a Confusion Matrix</p></a></li>
<li><a href='#convert_to_ggmcmc'><p>Converts MCMC Samples into <code>ggmcmc</code> Format</p></a></li>
<li><a href='#eigen_system'><p>Calculate Eigenvalues and Eigenvectors</p></a></li>
<li><a href='#example_hmm_mcmc_gamma_poisson'><p>Example of a Simulated Gamma-Poisson Model</p></a></li>
<li><a href='#example_hmm_mcmc_normal'><p>Example of a Simulated Normal Model</p></a></li>
<li><a href='#generate_random_T'><p>Generate a Random Transition Matrix</p></a></li>
<li><a href='#get_pi'><p>Get the Prior Probability of States</p></a></li>
<li><a href='#hmm_mcmc_gamma_poisson'><p>MCMC Sampler sampler for the Hidden Markov with Gamma-Poisson emission densities</p></a></li>
<li><a href='#hmm_mcmc_normal'><p>MCMC Sampler for the Hidden Markov Model with Normal emission densities</p></a></li>
<li><a href='#hmm_simulate_gamma_poisson_data'><p>Simulate data distributed according to oHMMed with gamma-poisson emission densities</p></a></li>
<li><a href='#hmm_simulate_normal_data'><p>Simulate data distributed according to oHMMed with normal emission densities</p></a></li>
<li><a href='#kullback_leibler_cont_appr'><p>Calculate a Continuous Approximation of the Kullback-Leibler Divergence</p></a></li>
<li><a href='#kullback_leibler_disc'><p>Calculate a Kullback-Leibler Divergence for a Discrete Distribution</p></a></li>
<li><a href='#plot.hmm_mcmc_gamma_poisson'><p>Plot Diagnostics for <code>hmm_mcmc_gamma_poisson</code> Objects</p></a></li>
<li><a href='#plot.hmm_mcmc_normal'><p>Plot Diagnostics for <code>hmm_mcmc_normal</code> Objects</p></a></li>
<li><a href='#posterior_prob_gamma_poisson'><p>Forward-Backward Algorithm to Calculate the Posterior Probabilities of Hidden States in Poisson-Gamma Model</p></a></li>
<li><a href='#posterior_prob_normal'><p>Forward-Backward Algorithm to Calculate the Posterior Probabilities of Hidden States in Normal Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>HMMs with Ordered Hidden States and Emission Densities</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Inference using a class of Hidden Markov models
    (HMMs) called 'oHMMed'(ordered HMM with emission densities 
    &lt;<a href="https://doi.org/10.1101%2F2023.06.26.546495">doi:10.1101/2023.06.26.546495</a>&gt;): The 'oHMMed' algorithms identify 
    the number of comparably homogeneous regions within observed sequences
    with autocorrelation patterns. These are modelled as discrete hidden
    states; the observed data points are then realisations of continuous
    probability distributions with state-specific means that enable
    ordering of these distributions. The observed sequence is labelled
    according to the hidden states, permitting only neighbouring states
    that are also neighbours within the ordering of their associated
    distributions. The parameters that characterise these state-specific
    distributions are then inferred. Relevant for application to genomic
    sequences, time series, or any other sequence data with serial
    autocorrelation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LynetteCaitlin/oHMMed">https://github.com/LynetteCaitlin/oHMMed</a>,
<a href="https://lynettecaitlin.github.io/oHMMed/">https://lynettecaitlin.github.io/oHMMed/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LynetteCaitlin/oHMMed/issues">https://github.com/LynetteCaitlin/oHMMed/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cvms, ggmcmc, ggplot2, gridExtra, mistr, scales, stats, vcd</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-18 21:13:31 UTC; michal</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Majka <a href="https://orcid.org/0000-0002-7524-8014"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Lynette Caitlin Mikula
    <a href="https://orcid.org/0000-0002-0252-4014"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Claus Vogl <a href="https://orcid.org/0000-0002-3996-7863"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Majka &lt;michalmajka@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-19 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='oHMMed-package'>oHMMed: HMMs with Ordered Hidden States and Emission Densities</h2><span id='topic+oHMMed-package'></span>

<h3>Description</h3>

<p>Inference using a class of Hidden Markov models (HMMs) called 'oHMMed'(ordered HMM with emission densities <a href="https://doi.org/10.1101/2023.06.26.546495">doi:10.1101/2023.06.26.546495</a>): The 'oHMMed' algorithms identify the number of comparably homogeneous regions within observed sequences with autocorrelation patterns. These are modelled as discrete hidden states; the observed data points are then realisations of continuous probability distributions with state-specific means that enable ordering of these distributions. The observed sequence is labelled according to the hidden states, permitting only neighbouring states that are also neighbours within the ordering of their associated distributions. The parameters that characterise these state-specific distributions are then inferred. Relevant for application to genomic sequences, time series, or any other sequence data with serial autocorrelation.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michal Majka <a href="mailto:michalmajka@hotmail.com">michalmajka@hotmail.com</a> (<a href="https://orcid.org/0000-0002-7524-8014">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Lynette Caitlin Mikula <a href="mailto:lynettecaitlin@gmail.com">lynettecaitlin@gmail.com</a> (<a href="https://orcid.org/0000-0002-0252-4014">ORCID</a>)
</p>
</li>
<li><p> Claus Vogl <a href="mailto:claus.vogl@vetmeduni.ac.at">claus.vogl@vetmeduni.ac.at</a> (<a href="https://orcid.org/0000-0002-3996-7863">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>

<p>Inference of Genomic Landscapes using Ordered Hidden Markov Models with Emission Densities (oHMMed)
Claus Vogl, Mariia Karapetiants, Burçin Yildirim, Hrönn Kjartansdottir, Carolin Kosiol, Juraj Bergman, Michal Majka, Lynette Caitlin Mikula,
bioRxiv 2023.06.26.546495; <a href="https://doi.org/10.1101/2023.06.26.546495">doi:10.1101/2023.06.26.546495</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/LynetteCaitlin/oHMMed">https://github.com/LynetteCaitlin/oHMMed</a>
</p>
</li>
<li> <p><a href="https://lynettecaitlin.github.io/oHMMed/">https://lynettecaitlin.github.io/oHMMed/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/LynetteCaitlin/oHMMed/issues">https://github.com/LynetteCaitlin/oHMMed/issues</a>
</p>
</li></ul>


<hr>
<h2 id='coef.hmm_mcmc_normal'>Extract Model Estimates</h2><span id='topic+coef.hmm_mcmc_normal'></span><span id='topic+coef.hmm_mcmc_gamma_poisson'></span>

<h3>Description</h3>

<p><code>coef</code> is a generic function which extracts model estimates from <code>mcmc_hmm_*</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm_mcmc_normal'
coef(object, ...)

## S3 method for class 'hmm_mcmc_gamma_poisson'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.hmm_mcmc_normal_+3A_object">object</code></td>
<td>
<p>an object of class inheriting from &quot;<code>mcmc_hmm_*</code>&quot;</p>
</td></tr>
<tr><td><code id="coef.hmm_mcmc_normal_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates extracted from MCMC HMM objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coef(example_hmm_mcmc_normal)
coef(example_hmm_mcmc_gamma_poisson)
</code></pre>

<hr>
<h2 id='conf_mat'>Calculate and Visualise a Confusion Matrix</h2><span id='topic+conf_mat'></span>

<h3>Description</h3>

<p>A diagnostic function that tests the reliability of estimation
procedures given the inferred transition rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conf_mat(N, res, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conf_mat_+3A_n">N</code></td>
<td>
<p>(numeric) number of simulations</p>
</td></tr>
<tr><td><code id="conf_mat_+3A_res">res</code></td>
<td>
<p>(mcmc_hmm_*) simulated MCMC HMM model</p>
</td></tr>
<tr><td><code id="conf_mat_+3A_plot">plot</code></td>
<td>
<p>(logical) plot confusion matrix. By default <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>First the data is simulated given the inferred model parameters and transition
rates. Then posterior probabilities are calculated and states are inferred.
Finally, the inferred states and simulated states are compared via
<code><a href="cvms.html#topic+confusion_matrix">confusion_matrix</a></code> function.
</p>


<h3>Value</h3>

<p><code><a href="cvms.html#topic+confusion_matrix">confusion_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  res &lt;- conf_mat(100, example_hmm_mcmc_normal, plot = TRUE) 
}
</code></pre>

<hr>
<h2 id='convert_to_ggmcmc'>Converts MCMC Samples into <code>ggmcmc</code> Format</h2><span id='topic+convert_to_ggmcmc'></span>

<h3>Description</h3>

<p>This helper function converts MCMC samples into <code>ggmcmc</code> format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_ggmcmc(
  x,
  pattern = c("mean", "sigma", "beta", "alpha", "pois_means", "T"),
  include_warmup = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_ggmcmc_+3A_x">x</code></td>
<td>
<p>(mcmc_hmm_*) MCMC HMM object</p>
</td></tr>
<tr><td><code id="convert_to_ggmcmc_+3A_pattern">pattern</code></td>
<td>
<p>(character) pattern(s) with model parameters to be included in the output</p>
</td></tr>
<tr><td><code id="convert_to_ggmcmc_+3A_include_warmup">include_warmup</code></td>
<td>
<p>(logical) include warmup samples. By default <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, for a given model, all parameters are converted into ggmcmc format.
</p>
<p>The parameter <code>pattern</code> can be used to extract specific parameters.
For instance <code>pattern="mean"</code> extracts all mean parameters from 
a hmm_mcmc_normal model.
</p>
<p>If a specific parameter is of interest it can be matched by an exact name:
<code>pattern=c("mean[1]", "T[1,1]")</code>.
</p>


<h3>Value</h3>

<p>data.frame compatible with functions from the <code>ggmcmc</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert all parameters (Normal model)
convert_normal_all &lt;- convert_to_ggmcmc(example_hmm_mcmc_normal)
unique(convert_normal_all$Parameter)
head(convert_normal_all)
tail(convert_normal_all)

# Convert only means (Normal model)
convert_normal_means &lt;- convert_to_ggmcmc(example_hmm_mcmc_normal, 
                                          pattern = "mean")
unique(convert_normal_means$Parameter)

# Convert selected parameter (Normal model)
pattern_normal &lt;- c("mean[1]", "sigma[1]", "T[1,1]")
convert_normal_param &lt;- convert_to_ggmcmc(example_hmm_mcmc_normal, 
                                          pattern = pattern_normal)
unique(convert_normal_param$Parameter)

# Convert all parameters (Poisson-Gamma model)
convert_pois_gamma_all &lt;- convert_to_ggmcmc(example_hmm_mcmc_gamma_poisson)
unique(convert_pois_gamma_all$Parameter)
</code></pre>

<hr>
<h2 id='eigen_system'>Calculate Eigenvalues and Eigenvectors</h2><span id='topic+eigen_system'></span>

<h3>Description</h3>

<p>This helper function returns the eigenvalues in lambda and the left and right eigenvectors in forwards and backwards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_system(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen_system_+3A_mat">mat</code></td>
<td>
<p>(matrix) a square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements:
</p>

<ul>
<li> <p><code>lambda</code>: eigenvalues
</p>
</li>
<li> <p><code>forwards</code>: left eigenvector
</p>
</li>
<li> <p><code>backwards</code>: right eigenvector
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mat_T0 &lt;- rbind(c(1-0.01,0.01,0),
               c(0.01,1-0.02,0.01),
               c(0,0.01,1-0.01))
eigen_system(mat_T0)
</code></pre>

<hr>
<h2 id='example_hmm_mcmc_gamma_poisson'>Example of a Simulated Gamma-Poisson Model</h2><span id='topic+example_hmm_mcmc_gamma_poisson'></span>

<h3>Description</h3>

<p>Example of a Simulated Gamma-Poisson Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_hmm_mcmc_gamma_poisson
</code></pre>


<h3>Format</h3>

<p>hmm_mcmc_gamma_poisson object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data stored in the object
hist(example_hmm_mcmc_gamma_poisson$data, 
     breaks = 50, xlab = "", main = "")

# Priors used in simulation
example_hmm_mcmc_gamma_poisson$priors

# Model
example_hmm_mcmc_gamma_poisson

summary(example_hmm_mcmc_gamma_poisson)
</code></pre>

<hr>
<h2 id='example_hmm_mcmc_normal'>Example of a Simulated Normal Model</h2><span id='topic+example_hmm_mcmc_normal'></span>

<h3>Description</h3>

<p>Example of a Simulated Normal Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_hmm_mcmc_normal
</code></pre>


<h3>Format</h3>

<p>hmm_mcmc_normal object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data stored in the object
plot(density(example_hmm_mcmc_normal$data), main = "")

# Priors used in simulation
example_hmm_mcmc_normal$priors

# Model
example_hmm_mcmc_normal

summary(example_hmm_mcmc_normal)
</code></pre>

<hr>
<h2 id='generate_random_T'>Generate a Random Transition Matrix</h2><span id='topic+generate_random_T'></span>

<h3>Description</h3>

<p>This helper function generates a transition matrix at random for testing purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_T(n = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_T_+3A_n">n</code></td>
<td>
<p>(integer) dimension of a transition matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uniform random numbers <code class="reqn">[0,1]</code> are used to fill the matrix. Rows are then
normalized.
</p>


<h3>Value</h3>

<p>random <code>n x n</code> transition matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat_T &lt;- generate_random_T(3)
mat_T

rowSums(mat_T)
</code></pre>

<hr>
<h2 id='get_pi'>Get the Prior Probability of States</h2><span id='topic+get_pi'></span>

<h3>Description</h3>

<p>Calculate the prior probability of states that correspond to the stationary
distribution of the transition matrix T
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pi(mat_T = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pi_+3A_mat_t">mat_T</code></td>
<td>
<p>(matrix) transition matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the prior probability of states corresponds
to the stationary distribution of the transition matrix <code class="reqn">T</code>,
denoted with <code class="reqn">\pi</code> and its entries with <code class="reqn">\pi_i=Pr(\theta_{l-1}=i)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T_mat &lt;- rbind(c(1-0.01,0.01,0),
               c(0.01,1-0.02,0.01),
               c(0,0.01,1-0.01))
T_mat
get_pi(T_mat)
</code></pre>

<hr>
<h2 id='hmm_mcmc_gamma_poisson'>MCMC Sampler sampler for the Hidden Markov with Gamma-Poisson emission densities</h2><span id='topic+hmm_mcmc_gamma_poisson'></span>

<h3>Description</h3>

<p>MCMC Sampler sampler for the Hidden Markov with Gamma-Poisson emission densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_mcmc_gamma_poisson(
  data,
  prior_T,
  prior_betas,
  prior_alpha = 1,
  iter = 5000,
  warmup = floor(iter/1.5),
  thin = 1,
  seed = sample.int(.Machine$integer.max, 1),
  init_T = NULL,
  init_betas = NULL,
  init_alpha = NULL,
  print_params = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_data">data</code></td>
<td>
<p>(numeric) data</p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_prior_t">prior_T</code></td>
<td>
<p>(matrix) prior transition matrix</p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_prior_betas">prior_betas</code></td>
<td>
<p>(numeric) prior beta parameters</p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_prior_alpha">prior_alpha</code></td>
<td>
<p>(numeric) a single prior alpha parameter. By default, <code>prior_alpha=1</code></p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_iter">iter</code></td>
<td>
<p>(integer) number of MCMC iterations</p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_warmup">warmup</code></td>
<td>
<p>(integer) number of warmup iterations</p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_thin">thin</code></td>
<td>
<p>(integer) thinning parameter. By default, <code>1</code></p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_seed">seed</code></td>
<td>
<p>(integer) seed parameter</p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_init_t">init_T</code></td>
<td>
<p>(matrix) <code>optional parameter</code>; initial transition matrix</p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_init_betas">init_betas</code></td>
<td>
<p>(numeric) <code>optional parameter</code>; initial beta parameters</p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_init_alpha">init_alpha</code></td>
<td>
<p>(numeric) <code>optional parameter</code>; initial alpha parameter</p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_print_params">print_params</code></td>
<td>
<p>(logical) <code>optional parameter</code>; print estimated parameters every iteration. By default, <code>TRUE</code></p>
</td></tr>
<tr><td><code id="hmm_mcmc_gamma_poisson_+3A_verbose">verbose</code></td>
<td>
<p>(logical) <code>optional parameter</code>; print additional messages. By default, <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see supplementary material at <a href="https://doi.org/10.1101/2023.06.26.546495">doi:10.1101/2023.06.26.546495</a> for more details on the algorithm.
</p>
<p>For usage recommendations please see <a href="https://github.com/LynetteCaitlin/oHMMed/blob/main/UsageRecommendations.pdf">https://github.com/LynetteCaitlin/oHMMed/blob/main/UsageRecommendations.pdf</a>.
</p>


<h3>Value</h3>

<p>List with following elements:
</p>

<ul>
<li> <p><code>data</code>: data used for simulation
</p>
</li>
<li> <p><code>samples</code>: list with samples
</p>
</li>
<li> <p><code>estimates</code>: list with various estimates
</p>
</li>
<li> <p><code>idx</code>: indices with iterations after the warmup period
</p>
</li>
<li> <p><code>priors</code>: prior parameters
</p>
</li>
<li> <p><code>inits</code>: initial parameters
</p>
</li>
<li> <p><code>last_iter</code>: list with samples from the last MCMC iteration
</p>
</li>
<li> <p><code>info</code>: list with various meta information about the object
</p>
</li></ul>



<h3>References</h3>

<p>Inference of Genomic Landscapes using Ordered Hidden Markov Models with Emission Densities (oHMMed)
Claus Vogl, Mariia Karapetiants, Burçin Yıldırım, Hrönn Kjartansdóttir, Carolin Kosiol, Juraj Bergman, Michal Majka, Lynette Caitlin Mikula,
bioRxiv 2023.06.26.546495; <a href="https://doi.org/10.1101/2023.06.26.546495">doi:10.1101/2023.06.26.546495</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Poisson-Gamma data
N &lt;- 2^10
true_T &lt;- rbind(c(0.95, 0.05, 0),
                c(0.025, 0.95, 0.025),
                c(0.0, 0.05, 0.95))

true_betas &lt;- c(2, 1, 0.1)
true_alpha &lt;- 1

simdata_full &lt;- hmm_simulate_gamma_poisson_data(L = N,
                                                mat_T = true_T,
                                                betas = true_betas,
                                                alpha = true_alpha)
simdata &lt;- simdata_full$data
hist(simdata, breaks = 40, probability = TRUE,  
     main = "Distribution of the simulated Poisson-Gamma data")
lines(density(simdata), col = "red")

# Set numbers of states to be inferred
n_states_inferred &lt;- 3

# Set priors
prior_T &lt;- generate_random_T(n_states_inferred)
prior_betas &lt;- c(1, 0.5, 0.1)
prior_alpha &lt;- 3

# Simmulation settings
iter &lt;- 50
warmup &lt;- floor(iter / 5) # 20 percent
thin &lt;- 1
seed &lt;- sample.int(10000, 1)
print_params &lt;- FALSE # if TRUE then parameters are printed in each iteration
verbose &lt;- FALSE # if TRUE then the state of the simulation is printed

# Run MCMC sampler
res &lt;- hmm_mcmc_gamma_poisson(data = simdata,
                              prior_T = prior_T,
                              prior_betas = prior_betas,
                              prior_alpha = prior_alpha,
                              iter = iter,
                              warmup = warmup,  
                              thin = thin,
                              seed = seed,
                              print_params = print_params,
                              verbose = verbose)
res

summary(res)# summary output can be also assigned to a variable

coef(res) # extract model estimates

# plot(res) # MCMC diagnostics
</code></pre>

<hr>
<h2 id='hmm_mcmc_normal'>MCMC Sampler for the Hidden Markov Model with Normal emission densities</h2><span id='topic+hmm_mcmc_normal'></span>

<h3>Description</h3>

<p>MCMC Sampler for the Hidden Markov Model with Normal emission densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_mcmc_normal(
  data,
  prior_T,
  prior_means,
  prior_sd,
  iter = 600,
  warmup = floor(iter/5),
  thin = 1,
  seed = sample.int(.Machine$integer.max, 1),
  init_T = NULL,
  init_means = NULL,
  init_sd = NULL,
  print_params = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_mcmc_normal_+3A_data">data</code></td>
<td>
<p>(numeric) normal data</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_prior_t">prior_T</code></td>
<td>
<p>(matrix) prior transition matrix</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_prior_means">prior_means</code></td>
<td>
<p>(numeric) prior means</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_prior_sd">prior_sd</code></td>
<td>
<p>(numeric) a single prior standard deviation</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_iter">iter</code></td>
<td>
<p>(integer) number of MCMC iterations</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_warmup">warmup</code></td>
<td>
<p>(integer) number of warmup iterations</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_thin">thin</code></td>
<td>
<p>(integer) thinning parameter. By default, <code>1</code></p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_seed">seed</code></td>
<td>
<p>(integer) <code>optional parameter</code>; seed parameter</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_init_t">init_T</code></td>
<td>
<p>(matrix) <code>optional parameter</code>; initial transition matrix</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_init_means">init_means</code></td>
<td>
<p>(numeric) <code>optional parameter</code>; initial means</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_init_sd">init_sd</code></td>
<td>
<p>(numeric) <code>optional parameter</code>; initial standard deviation</p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_print_params">print_params</code></td>
<td>
<p>(logical) <code>optional parameter</code>; print parameters every iteration. By default, <code>TRUE</code></p>
</td></tr>
<tr><td><code id="hmm_mcmc_normal_+3A_verbose">verbose</code></td>
<td>
<p>(logical) <code>optional parameter</code>; print additional messages. By default, <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see supplementary material at <a href="https://doi.org/10.1101/2023.06.26.546495">doi:10.1101/2023.06.26.546495</a> for more details on the algorithm.
</p>
<p>For usage recommendations please see <a href="https://github.com/LynetteCaitlin/oHMMed/blob/main/UsageRecommendations.pdf">https://github.com/LynetteCaitlin/oHMMed/blob/main/UsageRecommendations.pdf</a>.
</p>


<h3>Value</h3>

<p>List with following elements:
</p>

<ul>
<li> <p><code>data</code>: data used for simulation
</p>
</li>
<li> <p><code>samples</code>: list with samples
</p>
</li>
<li> <p><code>estimates</code>: list with various estimates
</p>
</li>
<li> <p><code>idx</code>: indices with iterations after the warmup period
</p>
</li>
<li> <p><code>priors</code>: prior parameters
</p>
</li>
<li> <p><code>inits</code>: initial parameters
</p>
</li>
<li> <p><code>last_iter</code>: list with samples from the last MCMC iteration
</p>
</li>
<li> <p><code>info</code>: list with various meta information about the object
</p>
</li></ul>



<h3>References</h3>

<p>Inference of Genomic Landscapes using Ordered Hidden Markov Models with Emission Densities (oHMMed)
Claus Vogl, Mariia Karapetiants, Burçin Yıldırım, Hrönn Kjartansdóttir, Carolin Kosiol, Juraj Bergman, Michal Majka, Lynette Caitlin Mikula,
bioRxiv 2023.06.26.546495; <a href="https://doi.org/10.1101/2023.06.26.546495">doi:10.1101/2023.06.26.546495</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate normal data
N &lt;- 2^10
true_T &lt;- rbind(c(0.95, 0.05, 0),
                c(0.025, 0.95, 0.025),
                c(0.0, 0.05, 0.95))

true_means &lt;- c(-5, 0, 5)
true_sd &lt;- 1.5

simdata_full &lt;- hmm_simulate_normal_data(L = N, 
                                         mat_T = true_T, 
                                         means = true_means,
                                         sigma = true_sd)
simdata &lt;- simdata_full$data
hist(simdata, 
     breaks = 40, 
     probability = TRUE,  
     main = "Distribution of the simulated normal data")
lines(density(simdata), col = "red")

# Set numbers of states to be inferred
n_states_inferred &lt;- 3

# Set priors
prior_T &lt;- generate_random_T(n_states_inferred)
prior_means &lt;- c(-18, -1, 12)
prior_sd &lt;- 3

# Simmulation settings
iter &lt;- 50
warmup &lt;- floor(iter / 5) # 20 percent
thin &lt;- 1
seed &lt;- sample.int(10000, 1)
print_params &lt;- FALSE # if TRUE then parameters are printed in each iteration
verbose &lt;- FALSE # if TRUE then the state of the simulation is printed

# Run MCMC sampler
res &lt;- hmm_mcmc_normal(data = simdata,
                       prior_T = prior_T,
                       prior_means = prior_means,
                       prior_sd = prior_sd,
                       iter = iter,
                       warmup = warmup,
                       seed = seed,
                       print_params = print_params,
                       verbose = verbose)
res

summary(res) # summary output can be also assigned to a variable

coef(res) # extract model estimates

# plot(res) # MCMC diagnostics
</code></pre>

<hr>
<h2 id='hmm_simulate_gamma_poisson_data'>Simulate data distributed according to oHMMed with gamma-poisson emission densities</h2><span id='topic+hmm_simulate_gamma_poisson_data'></span>

<h3>Description</h3>

<p>Simulate data distributed according to oHMMed with gamma-poisson emission densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_simulate_gamma_poisson_data(L, mat_T, betas, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_simulate_gamma_poisson_data_+3A_l">L</code></td>
<td>
<p>(integer) number of simulations</p>
</td></tr>
<tr><td><code id="hmm_simulate_gamma_poisson_data_+3A_mat_t">mat_T</code></td>
<td>
<p>(matrix) a square matrix with the initial state</p>
</td></tr>
<tr><td><code id="hmm_simulate_gamma_poisson_data_+3A_betas">betas</code></td>
<td>
<p>(numeric) <code>rate</code> parameter in <code><a href="stats.html#topic+rgamma">rgamma</a></code> for emission probabilities</p>
</td></tr>
<tr><td><code id="hmm_simulate_gamma_poisson_data_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) <code>shape</code> parameter in <code><a href="stats.html#topic+rgamma">rgamma</a></code> for emission probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>

<ul>
<li> <p><code>data</code>: numeric vector with data
</p>
</li>
<li> <p><code>states</code>: an integer vector with &quot;true&quot; hidden states used to generate the data vector
</p>
</li>
<li> <p><code>pi</code>: numeric vector with prior probability of states
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mat_T &lt;- rbind(c(1-0.01, 0.01, 0),
               c(0.01, 1-0.02, 0.01),
               c(0, 0.01, 1-0.01))
L &lt;- 2^7
betas &lt;- c(0.1, 0.3, 0.5)
alpha &lt;- 1

sim_data &lt;- hmm_simulate_gamma_poisson_data(L = L,
                                            mat_T = mat_T,
                                            betas = betas,
                                            alpha = alpha)
hist(sim_data$data, 
     breaks = 40,
     main = "Histogram of Simulated Gamma-Poisson Data", 
     xlab = "")
sim_data
</code></pre>

<hr>
<h2 id='hmm_simulate_normal_data'>Simulate data distributed according to oHMMed with normal emission densities</h2><span id='topic+hmm_simulate_normal_data'></span>

<h3>Description</h3>

<p>Simulate data distributed according to oHMMed with normal emission densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_simulate_normal_data(L, mat_T, means, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_simulate_normal_data_+3A_l">L</code></td>
<td>
<p>(integer) number of simulations</p>
</td></tr>
<tr><td><code id="hmm_simulate_normal_data_+3A_mat_t">mat_T</code></td>
<td>
<p>(matrix) a square matrix with the initial state</p>
</td></tr>
<tr><td><code id="hmm_simulate_normal_data_+3A_means">means</code></td>
<td>
<p>(numeric) <code>mean</code> parameter in <code><a href="stats.html#topic+rnorm">rnorm</a></code> for emission probabilities</p>
</td></tr>
<tr><td><code id="hmm_simulate_normal_data_+3A_sigma">sigma</code></td>
<td>
<p>(numeric) <code>sd</code> parameter in <code><a href="stats.html#topic+rnorm">rnorm</a></code> for emission probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>

<ul>
<li> <p><code>data</code>: numeric vector with data
</p>
</li>
<li> <p><code>states</code>: an integer vector with &quot;true&quot; hidden states used to generate the data vector
</p>
</li>
<li> <p><code>pi</code>: numeric vector with prior probability of states
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mat_T0 &lt;- rbind(c(1-0.01, 0.01, 0),
                c(0.01, 1-0.02, 0.01),
                c(0, 0.01, 1-0.01))
L &lt;- 2^7
means0 &lt;- c(-1,0,1)
sigma0 &lt;- 1

sim_data &lt;- hmm_simulate_normal_data(L = L, 
                                     mat_T = mat_T0, 
                                     means = means0, 
                                     sigma = sigma0)
                                     
plot(density(sim_data$data), main = "Density of Simulated Normal Data")
sim_data
</code></pre>

<hr>
<h2 id='kullback_leibler_cont_appr'>Calculate a Continuous Approximation of the Kullback-Leibler Divergence</h2><span id='topic+kullback_leibler_cont_appr'></span>

<h3>Description</h3>

<p>Calculate a Continuous Approximation of the Kullback-Leibler Divergence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kullback_leibler_cont_appr(p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kullback_leibler_cont_appr_+3A_p">p</code></td>
<td>
<p>(numeric) probabilities</p>
</td></tr>
<tr><td><code id="kullback_leibler_cont_appr_+3A_q">q</code></td>
<td>
<p>(numeric) probabilities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The continuous approximation of the Kullback-Leibler divergence
is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">
  \frac{1}{n}\sum_{i=1}^n\big[\log(p_i) p_i - \log(q_i) p_i \big]
</code>
</p>



<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate n normally distributed variates
n &lt;- 1000
dist1 &lt;- rnorm(n)
dist2 &lt;- rnorm(n, mean = 0, sd = 2)
dist3 &lt;- rnorm(n, mean = 2, sd = 2)

# Estimate probability density functions
pdf1 &lt;- density(dist1)
pdf2 &lt;- density(dist2)
pdf3 &lt;- density(dist3)

# Visualise PDFs
plot(pdf1, main = "PDFs", col = "red", xlim = range(dist3))
lines(pdf2, col = "blue")
lines(pdf3, col = "green")

# PDF 1 vs PDF 2
kullback_leibler_cont_appr(pdf1$y, pdf2$y)

# PDF 1 vs PDF 3
kullback_leibler_cont_appr(pdf1$y, pdf3$y)

# PDF 2 vs PDF 2
kullback_leibler_cont_appr(pdf2$y, pdf3$y)
</code></pre>

<hr>
<h2 id='kullback_leibler_disc'>Calculate a Kullback-Leibler Divergence for a Discrete Distribution</h2><span id='topic+kullback_leibler_disc'></span>

<h3>Description</h3>

<p>Calculate a Kullback-Leibler Divergence for a Discrete Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kullback_leibler_disc(p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kullback_leibler_disc_+3A_p">p</code></td>
<td>
<p>(numeric) probabilities</p>
</td></tr>
<tr><td><code id="kullback_leibler_disc_+3A_q">q</code></td>
<td>
<p>(numeric) probabilities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kullback-Leibler divergence for a discrete distribution
is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n p_i \log\Big(\frac{p_i}{q_i}\Big)</code>
</p>



<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate n Poisson distributed variates
n &lt;- 1000
dist1 &lt;- rpois(n, lambda = 1)
dist2 &lt;- rpois(n, lambda = 5)
dist3 &lt;- rpois(n, lambda = 20)

# Generate common factor levels
x_max &lt;- max(c(dist1, dist2, dist3))
all_levels &lt;- 0:x_max

# Estimate probability mass functions 
pmf_dist1 &lt;- table(factor(dist1, levels = all_levels)) / n
pmf_dist2 &lt;- table(factor(dist2, levels = all_levels)) / n
pmf_dist3 &lt;- table(factor(dist3, levels = all_levels)) / n

# Visualise PMFs
barplot(pmf_dist1, col = "green", xlim = c(0, x_max))
barplot(pmf_dist2, col = "red", add = TRUE)
barplot(pmf_dist3, col = "blue", add = TRUE)

# Calculate distances
kullback_leibler_disc(pmf_dist1, pmf_dist2)
kullback_leibler_disc(pmf_dist1, pmf_dist3)
kullback_leibler_disc(pmf_dist2, pmf_dist3)
</code></pre>

<hr>
<h2 id='plot.hmm_mcmc_gamma_poisson'>Plot Diagnostics for <code>hmm_mcmc_gamma_poisson</code> Objects</h2><span id='topic+plot.hmm_mcmc_gamma_poisson'></span>

<h3>Description</h3>

<p>This function creates a variety of diagnostic plots that can be useful when 
conducting Markov Chain Monte Carlo (MCMC) simulation of a gamma-poisson hidden Markov model (HMM). 
These plots will help to assess convergence, fit, and performance of the MCMC simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm_mcmc_gamma_poisson'
plot(
  x,
  simulation = FALSE,
  true_betas = NULL,
  true_alpha = NULL,
  true_mat_T = NULL,
  true_states = NULL,
  show_titles = TRUE,
  log_statesplot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hmm_mcmc_gamma_poisson_+3A_x">x</code></td>
<td>
<p>(hmm_mcmc_gamma_poisson) HMM MCMC gamma-poisson object</p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_gamma_poisson_+3A_simulation">simulation</code></td>
<td>
<p>(logical); default is <code>simulation=FALSE</code>, so the input data was empirical. If the input data was simulated, it must be set <code>simulation=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_gamma_poisson_+3A_true_betas">true_betas</code></td>
<td>
<p>(numeric) true betas. To be used if <code>simulation=TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_gamma_poisson_+3A_true_alpha">true_alpha</code></td>
<td>
<p>(numeric) true alpha. To be used if <code>simulation=TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_gamma_poisson_+3A_true_mat_t">true_mat_T</code></td>
<td>
<p>(matrix) <code>optional parameter</code>; true transition matrix. To be used if <code>simulation=TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_gamma_poisson_+3A_true_states">true_states</code></td>
<td>
<p>(integer) <code>optional parameter</code>; true states. To be used if <code>simulation=TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_gamma_poisson_+3A_show_titles">show_titles</code></td>
<td>
<p>(logical) if <code>TRUE</code> then titles are shown for all graphs. By default, <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_gamma_poisson_+3A_log_statesplot">log_statesplot</code></td>
<td>
<p>(logical) if <code>TRUE</code> then log-statesplots are shown. By default, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_gamma_poisson_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Several diagnostic plots that can be used to evaluate the MCMC simulation
of the gamma-poisson HMM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(example_hmm_mcmc_gamma_poisson)

</code></pre>

<hr>
<h2 id='plot.hmm_mcmc_normal'>Plot Diagnostics for <code>hmm_mcmc_normal</code> Objects</h2><span id='topic+plot.hmm_mcmc_normal'></span>

<h3>Description</h3>

<p>This function creates a variety of diagnostic plots that can be useful when 
conducting Markov Chain Monte Carlo (MCMC) simulation of a normal hidden Markov model (HMM). 
These plots will help to assess convergence, fit, and performance of the MCMC simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm_mcmc_normal'
plot(
  x,
  simulation = FALSE,
  true_means = NULL,
  true_sd = NULL,
  true_mat_T = NULL,
  true_states = NULL,
  show_titles = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hmm_mcmc_normal_+3A_x">x</code></td>
<td>
<p>(hmm_mcmc_normal) HMM MCMC normal object</p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_normal_+3A_simulation">simulation</code></td>
<td>
<p>(logical) <code>optional parameter</code>; default is <code>simulation=FALSE</code>, so the input data was empirical. If the input data was simulated, it must be set <code>simulation=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_normal_+3A_true_means">true_means</code></td>
<td>
<p>(numeric) <code>optional parameter</code>; true means. To be used if <code>simulation=TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_normal_+3A_true_sd">true_sd</code></td>
<td>
<p>(numeric) <code>optional parameter</code>; true standard deviation. To be used if <code>simulation=TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_normal_+3A_true_mat_t">true_mat_T</code></td>
<td>
<p>(matrix) <code>optional parameter</code>; true transition matrix. To be used if <code>simulation=TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_normal_+3A_true_states">true_states</code></td>
<td>
<p>(integer) <code>optional parameter</code>; true states. To be used if <code>simulation=TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_normal_+3A_show_titles">show_titles</code></td>
<td>
<p>(logical) <code>optional parameter</code>; if <code>TRUE</code> then titles are shown for all graphs. By default, <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.hmm_mcmc_normal_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Several diagnostic plots that can be used to evaluate the MCMC simulation
of the normal HMM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(example_hmm_mcmc_normal)

</code></pre>

<hr>
<h2 id='posterior_prob_gamma_poisson'>Forward-Backward Algorithm to Calculate the Posterior Probabilities of Hidden States in Poisson-Gamma Model</h2><span id='topic+posterior_prob_gamma_poisson'></span>

<h3>Description</h3>

<p>Forward-Backward Algorithm to Calculate the Posterior Probabilities of Hidden States in Poisson-Gamma Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_prob_gamma_poisson(data, pi, mat_T, betas, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_prob_gamma_poisson_+3A_data">data</code></td>
<td>
<p>(numeric) Poisson data</p>
</td></tr>
<tr><td><code id="posterior_prob_gamma_poisson_+3A_pi">pi</code></td>
<td>
<p>(numeric) prior probability of states</p>
</td></tr>
<tr><td><code id="posterior_prob_gamma_poisson_+3A_mat_t">mat_T</code></td>
<td>
<p>(matrix) transition probability matrix</p>
</td></tr>
<tr><td><code id="posterior_prob_gamma_poisson_+3A_betas">betas</code></td>
<td>
<p>(numeric) vector with prior rates</p>
</td></tr>
<tr><td><code id="posterior_prob_gamma_poisson_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) prior scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see supplementary material at <a href="https://doi.org/10.1101/2023.06.26.546495">doi:10.1101/2023.06.26.546495</a> for more details on the algorithm.
</p>


<h3>Value</h3>

<p>List with the following elements: 
</p>

<ul>
<li> <p><code>F</code>: auxiliary forward variables
</p>
</li>
<li> <p><code>B</code>: auxiliary backward variables
</p>
</li>
<li> <p><code>s</code>: weights
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mat_T &lt;- rbind(c(1-0.01,0.01,0),
               c(0.01,1-0.02,0.01),
               c(0,0.01,1-0.01))
L &lt;- 2^10
betas &lt;- c(0.1, 0.3, 0.5)
alpha &lt;- 1

sim_data &lt;- hmm_simulate_gamma_poisson_data(L = L,
                                            mat_T = mat_T,
                                            betas = betas,
                                            alpha = alpha)
pi &lt;- sim_data$pi
hmm_poison_data &lt;- sim_data$data
hist(hmm_poison_data, breaks = 100)

# Calculate posterior probabilities of hidden states
post_prob &lt;- posterior_prob_gamma_poisson(data = hmm_poison_data,
                                          pi = pi,
                                          mat_T = mat_T,
                                          betas = betas,
                                          alpha = alpha)
str(post_prob)
</code></pre>

<hr>
<h2 id='posterior_prob_normal'>Forward-Backward Algorithm to Calculate the Posterior Probabilities of Hidden States in Normal Model</h2><span id='topic+posterior_prob_normal'></span>

<h3>Description</h3>

<p>Forward-Backward Algorithm to Calculate the Posterior Probabilities of Hidden States in Normal Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_prob_normal(data, pi, mat_T, means, sdev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_prob_normal_+3A_data">data</code></td>
<td>
<p>(numeric) normal data</p>
</td></tr>
<tr><td><code id="posterior_prob_normal_+3A_pi">pi</code></td>
<td>
<p>(numeric) prior probability of states</p>
</td></tr>
<tr><td><code id="posterior_prob_normal_+3A_mat_t">mat_T</code></td>
<td>
<p>(matrix) transition probability matrix</p>
</td></tr>
<tr><td><code id="posterior_prob_normal_+3A_means">means</code></td>
<td>
<p>(numeric) vector with prior means</p>
</td></tr>
<tr><td><code id="posterior_prob_normal_+3A_sdev">sdev</code></td>
<td>
<p>(numeric) prior standard deviation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see supplementary material at <a href="https://doi.org/10.1101/2023.06.26.546495">doi:10.1101/2023.06.26.546495</a> for more details on the algorithm.
</p>


<h3>Value</h3>

<p>List with the following elements: 
</p>

<ul>
<li> <p><code>F</code>: auxiliary forward variables
</p>
</li>
<li> <p><code>B</code>: auxiliary backward variables
</p>
</li>
<li> <p><code>s</code>: weights
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>prior_mat &lt;- rbind(c(1-0.05, 0.05, 0),
                  c(0.05, 1-0.1, 0.05),
                  c(0, 0.05, 1-0.05))

prior_means &lt;- c(-0.1, 0.0, 0.1)
prior_sd  &lt;- sqrt(0.1)
L &lt;- 100

# Simulate HMM model based on normal data based on prior information
sim_data_normal &lt;- hmm_simulate_normal_data(L = L,
                                            mat_T = prior_mat,
                                            means = prior_means,
                                            sigma = prior_sd)
pi &lt;- sim_data_normal$pi
# pi &lt;- get_pi(prior_mat)
hmm_norm_data &lt;- sim_data_normal$data

# Calculate posterior probabilities of hidden states
post_prob &lt;-  posterior_prob_normal(data = hmm_norm_data,
                                    pi = pi,
                                    mat_T = prior_mat,
                                    means = prior_means,
                                    sdev = prior_sd)
str(post_prob)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
