<!DOCTYPE html><html lang="en"><head><title>Help for package MoLE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MoLE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MoLE-package'>
<p>Modeling Language Evolution</p></a></li>
<li><a href='#ACTOR'>
<p>Determine actor role</p></a></li>
<li><a href='#AGENTFIRST'>
<p>Actor argument first</p></a></li>
<li><a href='#ALLNAS'>
<p>NA vector identification</p></a></li>
<li><a href='#ANALYZE'>
<p>Determine sentence constituents</p></a></li>
<li><a href='#CANDIDATESCORE'>
<p>Score candidate expressions</p></a></li>
<li><a href='#CHECKSUCCESS'>
<p>Determine expected communicative success</p></a></li>
<li><a href='#DECOMPOSE'>
<p>Decompose words into morphemes</p></a></li>
<li><a href='#DIE'>
<p>Kill agents</p></a></li>
<li><a href='#EROSION'>
<p>Word erosion</p></a></li>
<li><a href='#FIRSTINFIRSTOUT'>
<p>Order constituents by activation</p></a></li>
<li><a href='#FIRSTSPEAKER'>
<p>Create founding agent</p></a></li>
<li><a href='#FMATCH'>
<p>Compare forms</p></a></li>
<li><a href='#FORMS'>
<p>Generate forms</p></a></li>
<li><a href='#FOUND'>
<p>Found population</p></a></li>
<li><a href='#FREQUPDATE'>
<p>Update usage numbers</p></a></li>
<li><a href='#FUSE'>
<p>Fuse words</p></a></li>
<li><a href='#GENERALIZE'>
<p>Apply linguistic generalizations</p></a></li>
<li><a href='#GROUP'>
<p>Group words into constituents</p></a></li>
<li><a href='#INTERPRET'>
<p>Interpret utterance</p></a></li>
<li><a href='#INTERPRET.INT'>
<p>Develop an interpretation</p></a></li>
<li><a href='#MAX'>
<p>Find maximum value</p></a></li>
<li><a href='#NOUNDESEMANTICIZATION'>
<p>Bleach word meaning</p></a></li>
<li><a href='#NOUNMORPHOLOGY'>
<p>Interpret nominal morphology</p></a></li>
<li><a href='#NOUNS'>
<p>Generate nominal lexicon</p></a></li>
<li><a href='#PERSONUPDATE'>
<p>Adjust person value</p></a></li>
<li><a href='#PREPARE'>
<p>Prepare a proposition for production</p></a></li>
<li><a href='#PROCREATE'>
<p>Generate new generation of agents</p></a></li>
<li><a href='#PRODUCE'>
<p>Produce utterance</p></a></li>
<li><a href='#PROPOSITION'>
<p>Develop initial proposition</p></a></li>
<li><a href='#PROTOINTERPRETATION'>
<p>Develop interpretation</p></a></li>
<li><a href='#REDUCE'>
<p>Reduce length of expressions</p></a></li>
<li><a href='#REFCHECK'>
<p>Check referential capacity</p></a></li>
<li><a href='#RESCALE'>
<p>Rescale vector values</p></a></li>
<li><a href='#RUN'>
<p>Run simulation</p></a></li>
<li><a href='#SELECTACTOR'>
<p>Find actor expression</p></a></li>
<li><a href='#SEMUPDATE'>
<p>Update lexicon</p></a></li>
<li><a href='#SITUATION'>
<p>Create situational context</p></a></li>
<li><a href='#SUCCESS'>
<p>Determine communicative success</p></a></li>
<li><a href='#SUMMARY'>
<p>Summarize simulation results</p></a></li>
<li><a href='#TALK'>
<p>Let agents talk</p></a></li>
<li><a href='#TOPICCOPY'>
<p>Make anaphoric copy of topic</p></a></li>
<li><a href='#TOPICFIRST'>
<p>Put topic in first position</p></a></li>
<li><a href='#TURN'>
<p>Organize communicative turn</p></a></li>
<li><a href='#TYPEMATCH'>
<p>Determine role qualification</p></a></li>
<li><a href='#VERBFINAL'>
<p>Put verb final</p></a></li>
<li><a href='#VERBMORPHOLOGY'>
<p>Interpret verbal morphology</p></a></li>
<li><a href='#VERBS'>
<p>Generate verbal lexicon</p></a></li>
<li><a href='#VMATCH'>
<p>Compare vectors</p></a></li>
<li><a href='#WORDORDER'>
<p>Use word order for interpretation</p></a></li>
<li><a href='#world'>
<p>Model parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling Language Evolution</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-10-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Sander Lestrade</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sander Lestrade &lt;samlestrade@protonmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Model for simulating language evolution in terms of cultural evolution (Smith &amp; Kirby (2008) &lt;<a href="https://doi.org/10.1098%2Frstb.2008.0145">doi:10.1098/rstb.2008.0145</a>&gt;; Deacon 1997). The focus is on the emergence of argument-marking systems (Dowty (1991) &lt;<a href="https://doi.org/10.1353%2Flan.1991.0021">doi:10.1353/lan.1991.0021</a>&gt;, Van Valin 1999, Dryer 2002, Lestrade 2015a), i.e. noun marking (Aristar (1997) &lt;<a href="https://doi.org/10.1075%2Fsl.21.2.04ari">doi:10.1075/sl.21.2.04ari</a>&gt;, Lestrade (2010) &lt;<a href="https://doi.org/10.7282%2FT3ZG6R4S">doi:10.7282/T3ZG6R4S</a>&gt;), person indexing (Ariel 1999, Dahl (2000) &lt;<a href="https://doi.org/10.1075%2Ffol.7.1.03dah">doi:10.1075/fol.7.1.03dah</a>&gt;, Bhat 2004), and word order (Dryer 2013), but extensions are foreseen. Agents start out with a protolanguage (a language without grammar; Bickerton (1981) &lt;<a href="https://doi.org/10.17169%2Flangsci.b91.109">doi:10.17169/langsci.b91.109</a>&gt;, Jackendoff 2002, Arbib (2015) &lt;<a href="https://doi.org/10.1002%2F9781118346136.ch27">doi:10.1002/9781118346136.ch27</a>&gt;) and interact through language games (Steels 1997). Over time, grammatical constructions emerge that may or may not become obligatory (for which the tolerance principle is assumed; Yang 2016). Throughout the simulation, uniformitarianism of principles is assumed (Hopper (1987) &lt;<a href="https://doi.org/10.3765%2Fbls.v13i0.1834">doi:10.3765/bls.v13i0.1834</a>&gt;, Givon (1995) &lt;<a href="https://doi.org/10.1075%2Fz.74">doi:10.1075/z.74</a>&gt;, Croft (2000), Saffran (2001) &lt;<a href="https://doi.org/10.1111%2F1467-8721.01243">doi:10.1111/1467-8721.01243</a>&gt;, Heine &amp; Kuteva 2007), in which maximal psychological validity is aimed at (Grice (1975) &lt;<a href="https://doi.org/10.1057%2F9780230005853_5">doi:10.1057/9780230005853_5</a>&gt;, Levelt 1989, Gaerdenfors 2000) and language representation is usage based (Tomasello 2003, Bybee 2010). In Lestrade (2015b) &lt;<a href="https://doi.org/10.15496%2Fpublikation-8640">doi:10.15496/publikation-8640</a>&gt;, Lestrade (2015c) &lt;<a href="https://doi.org/10.1075%2Favt.32.08les">doi:10.1075/avt.32.08les</a>&gt;, and Lestrade (2016) &lt;<a href="https://doi.org/10.17617%2F2.2248195">doi:10.17617/2.2248195</a>&gt;), which reported on the results of preliminary versions, this package was announced as WDWTW (for who does what to whom), but for reasons of pronunciation and generalization the title was changed.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-10-23 12:41:11 UTC; u513129</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-10-24 07:21:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='MoLE-package'>
Modeling Language Evolution
</h2><span id='topic+MoLE-package'></span><span id='topic+MoLE'></span>

<h3>Description</h3>

<p>Model for simulating language evolution in terms of cultural evolution (Smith &amp; Kirby (2008) &lt;DOI:10.1098/rstb.2008.0145&gt;; Deacon 1997). The focus is on the emergence of argument-marking systems (Dowty (1991) &lt;DOI:10.1353/lan.1991.0021&gt;, Van Valin 1999, Dryer 2002, Lestrade 2015a), i.e. noun marking (Aristar (1997) &lt;DOI:10.1075/sl.21.2.04ari&gt;, Lestrade (2010) &lt;DOI:10.7282/T3ZG6R4S&gt;), person indexing (Ariel 1999, Dahl (2000) &lt;DOI:10.1075/fol.7.1.03dah&gt;, Bhat 2004), and word order (Dryer 2013), but extensions are foreseen. Agents start out with a protolanguage (a language without grammar; Bickerton (1981) &lt;DOI:10.17169/langsci.b91.109&gt;, Jackendoff 2002, Arbib (2015) &lt;DOI:10.1002/9781118346136.ch27&gt;) and interact through language games (Steels 1997). Over time, grammatical constructions emerge that may or may not become obligatory (for which the tolerance principle is assumed; Yang 2016). Throughout the simulation, uniformitarianism of principles is assumed (Hopper (1987) &lt;DOI:10.3765/bls.v13i0.1834&gt;, Givon (1995) &lt;DOI:10.1075/z.74&gt;, Croft (2000), Saffran (2001) &lt;DOI:10.1111/1467-8721.01243&gt;, Heine &amp; Kuteva 2007), in which maximal psychological validity is aimed at (Grice (1975) &lt;DOI:10.1057/9780230005853_5&gt;, Levelt 1989, Gaerdenfors 2000) and language representation is usage based (Tomasello 2003, Bybee 2010). In Lestrade (2015b) &lt;DOI:10.15496/publikation-8640&gt;, Lestrade (2015c) &lt;DOI:10.1075/avt.32.08les&gt;, and Lestrade (2016) &lt;DOI:10.17617/2.2248195&gt;), which reported on the results of preliminary versions, this package was announced as WDWTW (for who does what to whom), but for reasons of pronunciation and generalization the title was changed.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MoLE</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Modeling Language Evolution</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-10-23</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Sander Lestrade</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Sander Lestrade &lt;samlestrade@protonmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Model for simulating language evolution in terms of cultural evolution (Smith &amp; Kirby (2008) &lt;DOI:10.1098/rstb.2008.0145&gt;; Deacon 1997). The focus is on the emergence of argument-marking systems (Dowty (1991) &lt;DOI:10.1353/lan.1991.0021&gt;, Van Valin 1999, Dryer 2002, Lestrade 2015a), i.e. noun marking (Aristar (1997) &lt;DOI:10.1075/sl.21.2.04ari&gt;, Lestrade (2010) &lt;DOI:10.7282/T3ZG6R4S&gt;), person indexing (Ariel 1999, Dahl (2000) &lt;DOI:10.1075/fol.7.1.03dah&gt;, Bhat 2004), and word order (Dryer 2013), but extensions are foreseen. Agents start out with a protolanguage (a language without grammar; Bickerton (1981) &lt;DOI:10.17169/langsci.b91.109&gt;, Jackendoff 2002, Arbib (2015) &lt;DOI:10.1002/9781118346136.ch27&gt;) and interact through language games (Steels 1997). Over time, grammatical constructions emerge that may or may not become obligatory (for which the tolerance principle is assumed; Yang 2016). Throughout the simulation, uniformitarianism of principles is assumed (Hopper (1987) &lt;DOI:10.3765/bls.v13i0.1834&gt;, Givon (1995) &lt;DOI:10.1075/z.74&gt;, Croft (2000), Saffran (2001) &lt;DOI:10.1111/1467-8721.01243&gt;, Heine &amp; Kuteva 2007), in which maximal psychological validity is aimed at (Grice (1975) &lt;DOI:10.1057/9780230005853_5&gt;, Levelt 1989, Gaerdenfors 2000) and language representation is usage based (Tomasello 2003, Bybee 2010). In Lestrade (2015b) &lt;DOI:10.15496/publikation-8640&gt;, Lestrade (2015c) &lt;DOI:10.1075/avt.32.08les&gt;, and Lestrade (2016) &lt;DOI:10.17617/2.2248195&gt;), which reported on the results of preliminary versions, this package was announced as WDWTW (for who does what to whom), but for reasons of pronunciation and generalization the title was changed.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 6.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
ACTOR                   Determine actor role
AGENTFIRST              Actor argument first
ALLNAS                  NA vector identification
ANALYZE                 Determine sentence constituents
CANDIDATESCORE          Score candidate expressions
CHECKSUCCESS            Determine expected communicative success
DECOMPOSE               Decompose words into morphemes
DIE                     Kill agents
EROSION                 Word erosion
FIRSTINFIRSTOUT         Order constituents by activation
FIRSTSPEAKER            Create founding agent
FMATCH                  Compare forms
FORMS                   Generate forms
FOUND                   Found population
FREQUPDATE              Update usage numbers
FUSE                    Fuse words
GENERALIZE              Apply linguistic generalizations
GROUP                   Group words into constituents
INTERPRET               Interpret utterance
INTERPRET.INT           Develop an interpretation
MAX                     Find maximum value
MoLE-package            Modeling Language Evolution
NOUNDESEMANTICIZATION   Bleach word meaning
NOUNMORPHOLOGY          Interpret nominal morphology
NOUNS                   Generate nominal lexicon
PERSONUPDATE            Adjust person value
PREPARE                 Prepare a proposition for production
PROCREATE               Generate new generation of agents
PRODUCE                 Produce utterance
PROPOSITION             Develop initial proposition
PROTOINTERPRETATION     Develop interpretation
REDUCE                  Reduce length of expressions
REFCHECK                Check referential capacity
RESCALE                 Rescale vector values
RUN                     Run simulation
SELECTACTOR             Find actor expression
SEMUPDATE               Update lexicon
SITUATION               Create situational context
SUCCESS                 Determine communicative success
SUMMARY                 Summarize simulation results
TALK                    Let agents talk
TOPICCOPY               Make anaphoric copy of topic
TOPICFIRST              Put topic in first position
TURN                    Organize communicative turn
TYPEMATCH               Determine role qualification
VERBFINAL               Put verb final
VERBMORPHOLOGY          Interpret verbal morphology
VERBS                   Generate verbal lexicon
VMATCH                  Compare vectors
WORDORDER               Use word order for interpretation
world                   Model parameters
</pre>
<p>Set the model parameters in <code>world</code>. 
Found a new population (<code>FOUND</code>). 
Run a simulation (<code>RUN</code>).
</p>
<p>For language to change (and argument-marking grammar to develop), the simulation has to run for several hours.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>
<p>Maintainer: Sander Lestrade &lt;samlestrade@protonmail.com&gt;
</p>


<h3>References</h3>

<p>Ariel, M. (1999),  The development of person agreement markers: from pronouns to higher accessibility markers. In Barlow &amp; Kemmer (Eds.), Usage based models of language (pp. 197-260),  Stanford: CSLI.
</p>
<p>Aristar, A.R. (1997),  Marking and hierarchy. Types and the grammaticalization of case markers. Studies in Language, 21 (2), 313-368.
</p>
<p>Arbib, M. A.  (2015), Language evolution. An emergentist perspective. In MacWhinney and  OGrady (eds), The Handbook of Language Emergence. West Sussex, UK: Wiley/Blackwell, pp. 600-623.
</p>
<p>Bhat, D.N.S. (2004), Pronouns. Oxford [etc.]: Oxford University Press.
</p>
<p>Bickerton, D. (1981),  Roots of language. Ann Arbor, Mich.: Karoma.
</p>
<p>Bybee, J. (2010), Language, usage, and cognition. Cambridge, UK: Cambridge University Press.
</p>
<p>Croft, W. (2000),  Explaining language change: An evolutionary approach. Harlow etc.: Longman.
</p>
<p>Dahl, O. (2000),  Egophoricity in discourse and syntax. Functions of Language, 7 (1), 37-77.
</p>
<p>Deacon, T. (1997),  The symbolic species. London: Penquin.
</p>
<p>Dowty, D. (1991),  Thematic proto-roles and argument selection. Language 67 (3): 547-619.
</p>
<p>Dryer, M. S. (2002),  Case distinctions, rich verb agreement, and word order type. Theoretical Linguistics 28: 151-157.
</p>
<p>Dryer, M. S. (2013),  Order of subject, object and verb. In Dryer &amp; Haspelmath (Eds.), The World Atlas of Language Structures Online. Leipzig: Max Planck Institute for Evolutionary Anthropology.
</p>
<p>Du Bois, J.W. (1987), The discourse basis of ergativity. Language 63 (4): 805-855
</p>
<p>Gaerdenfors, P. (2000),  Conceptual spaces: The geometry of thought. Cambridge, MA: MIT.
</p>
<p>Givon, T. (1995),  Functionalism and grammar. Amsterdam/Philadelphia: John Benjamins.
</p>
<p>Grice, H. P. (1975),  Logic and conversation. In P. Cole &amp; J. L. Morgan (Eds.), Syntax and semantics: Speech acts (Vol. 3, pp. 41-58),  New York: Academic Press.
</p>
<p>Heine, B. &amp; Kuteva, T. (2007),  The genesis of grammar. A reconstruction. Oxford: Oxford University Press.
</p>
<p>Hopper, P. J. (1987),  Emergent grammar. In Proceedings of BLS (Vol. 13, pp. 139-157), 
</p>
<p>Jackendoff, R. (2002),  Foundations of language: Brain, meaning, grammar, evolution. Oxford: Oxford University Press.
</p>
<p>Levelt, W.J.M. (1989),  Speaking. From intention to articulation. Cambridge, MA: MIT Press.
</p>
<p>Lestrade, S. (2010), The space of case. PhD thesis, Radboud University Nijmegen.
</p>
<p>Lestrade, S. (2015a), The interaction of argument-marking strategies. In: S. Lestrade, P. de Swart, and L. Hogeweg (eds), Addenda. Artikelen voor Ad Foolen. Radboud University Nijmegen, 251-256.
</p>
<p>Lestrade, S. (2015b), Simulating the development of bound person marking. In: H. Baayen, et al. (eds), Proceedings of the 6th Conference on Quantitative Investigations in Theoretical Linguistics. Tuebingen: University of Tuebingen.
</p>
<p>Lestrade, S. (2015c), A case of cultural evolution: The emergence of morphological case. Linguistics in the Netherlands [AVT 32]: 105-115.
</p>
<p>Lestrade, S. (2016), The emergence of argument marking. In: S.G. Roberts et al.(eds) The Evolution of Language: Proceedings of the 11th International Conference (EVOLANG11)
</p>
<p>Saffran, J.R. (2001), Statistical language learning: Mechanisms and constraints. Current Directions in Psychological Science 12(4): 110-114.
</p>
<p>Smith, K. &amp; Kirby, S. (2008),  Cultural evolution: Implications for understanding the human language faculty and its evolution. Phil. Trans. R. Soc. B, 363, 3591-3603.
</p>
<p>Steels, L. (1997),  Constructing and sharing perceptual distinctions. Machine Learning, ECML-97, 4-13.
</p>
<p>Tomasello, M. (2003),  Constructing a language: A usage-based theory of language acquisition. Cambridge, MA: Harvard University Press.
</p>
<p>Van Valin, R. (1999),  Generalized semantic roles and the syntax-semantics interface. In F. Corblin, C. Dobrovie-Sorin, &amp; J.-M. Marandin (Eds.), Empirical issues in formal syntax and semantics 2 (pp. 373-389),  The Hague: Thesus.
</p>
<p>Yang, Ch. (2016), The price of linguistic productivity. Cambridge, MA: MIT Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
FOUND()
RUN(.00001)
(situation=SITUATION(1))
(proposition=PROPOSITION(1, situation))
(prep=PREPARE(1, proposition, situation)) 
(utterance=PRODUCE(1, prep))
(interpretation=INTERPRET(2, utterance, situation))
head(population[[1]]$nouns)

## End(Not run)
</code></pre>

<hr>
<h2 id='ACTOR'>
Determine actor role
</h2><span id='topic+ACTOR'></span>

<h3>Description</h3>

<p>Given two verb roles, which of these is most prominent and hence the actor? 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACTOR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACTOR_+3A_x">x</code></td>
<td>

<p>First verb role
</p>
</td></tr>
<tr><td><code id="ACTOR_+3A_y">y</code></td>
<td>

<p>Second verb role
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Higher meaning values are more prominent. If tie, first argument is actor
</p>


<h3>Value</h3>

<p>numeric: 1 if first role is actor, 2 if second is.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Van Valin, R. (1999). Generalized semantic roles and the syntax-semantics interface. In F. Corblin, C. Dobrovie-Sorin, &amp; J.-M. Marandin (Eds.), Empirical issues in formal syntax and semantics 2 (pp. 373-389). The Hague: Thesus.</p>


<h3>See Also</h3>

<p><code>SITUATION</code> <code>SELECTACTOR</code> <code>SELECTUNDERGOER</code> <code>PROPOSITION</code> <code>REFCHECK</code> <code>AGENTFIRST</code> <code>GENERALIZE</code> <code>CHECKSUCCESS</code> <code>WORDORDER</code> <code>VERBMORPHOLOGY</code> <code>INTERPRET.INT</code> <code>FREQUPDATE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a=rep(1, 4)
b=rep(0, 4)
ACTOR(a,b)
</code></pre>

<hr>
<h2 id='AGENTFIRST'>
Actor argument first
</h2><span id='topic+AGENTFIRST'></span>

<h3>Description</h3>

<p>Reorganizes constituents of an utterance such that actor is put in sentence-initial position. Only applies if corresponding word-order generalization has been made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AGENTFIRST(proposition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AGENTFIRST_+3A_proposition">proposition</code></td>
<td>

<p>Proposition of which the constituents are reordered. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies to intransitives too, which may not be desirable. 
</p>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Matthew S. Dryer. 2013. Order of Subject, Object and Verb. In: Dryer, Matthew S. &amp; Haspelmath, Martin (eds.) The World Atlas of Language Structures Online. Leipzig: Max Planck Institute for Evolutionary Anthropology. (Available online at http://wals.info/chapter/81, Accessed on 2017-05-24.)  
</p>


<h3>See Also</h3>

<p><code>GENERALIZE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
(proposition=PROPOSITION(1, situation))
AGENTFIRST(proposition)
</code></pre>

<hr>
<h2 id='ALLNAS'>
NA vector identification
</h2><span id='topic+ALLNAS'></span>

<h3>Description</h3>

<p>Determine whether vectors consist of NA values only. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ALLNAS(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ALLNAS_+3A_x">x</code></td>
<td>

<p>x can be simple vector or data frame. Latter is evaluated row-wise.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>T/F for single vector, vector with logicals for data frames.
</p>


<h3>Note</h3>

<p>Used as input requirement for <code>VMATCH</code>.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>VMATCH</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=rep(NA, 8)
ALLNAS(x)
y=data.frame(c(1, rep(NA,2)), rep(NA,3))
ALLNAS(y)
</code></pre>

<hr>
<h2 id='ANALYZE'>
Determine sentence constituents
</h2><span id='topic+ANALYZE'></span>

<h3>Description</h3>

<p>Decomposes an utterance into its constituents and their parts (e.g. verb and/or noun markers). All possible analyses are tried, the best is selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANALYZE(hearerID, utterance, situation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ANALYZE_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to hearer agent in the population
</p>
</td></tr>
<tr><td><code id="ANALYZE_+3A_utterance">utterance</code></td>
<td>

<p>The utterance to be analyzed.
</p>
</td></tr>
<tr><td><code id="ANALYZE_+3A_situation">situation</code></td>
<td>

<p>The situation in which the utterance is uttered.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Situation argument is necessary to determine which referential expressions have most likely been used.
Suffix could be incorporated noun (l. 51-70), the rest could be a verb, a noun, a verb adposition, or noun adposition (l. 71-102)
Nouns can have single suffix only (change once number is implemented; l. 92)
Default interpretation is noun (cf. Heine &amp; Kuteva)
Analysis starts with identifying verb
If verb can not be found by lexeme match, verb suffixes are used, if still unclear plausibility of alternative analysis is checked. 
Combinations of nouns with local person markers are penalized (to be removed if possessive marking is modelled), just like combinations of nouns with multiple markers (to be removed if case stacking is allowed)
</p>


<h3>Value</h3>

<p>A data frame with the identified constituents and their analyses as entries.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Heine, Bernd &amp; Tania Kuteva (2007), The genesis of grammar. A reconstruction. Oxford: Oxford University Press.
</p>


<h3>See Also</h3>

<p><code>INTERPRET</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
(utterance=PRODUCE(1, proposition))
ANALYZE(2, utterance, situation)
</code></pre>

<hr>
<h2 id='CANDIDATESCORE'>
Score candidate expressions
</h2><span id='topic+CANDIDATESCORE'></span>

<h3>Description</h3>

<p>Provides each candidate expression for some meaning or function with a score in which (depending on the model settings) semantic match, lexeme activation, (relative) frequency of use, recency, collostruction frequency, semantic weight, and/or economy of expression are taken into consideration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CANDIDATESCORE(lexicon, type = "referringExpression")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CANDIDATESCORE_+3A_lexicon">lexicon</code></td>
<td>

<p>lexicon with candidate expresions
</p>
</td></tr>
<tr><td><code id="CANDIDATESCORE_+3A_type">type</code></td>
<td>

<p>Type of function for which an expression has to be found (<code>referringExpression</code>, <code>nounMarker</code>, <code>verbMarker</code>, or <code>pronoun</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Collostruction frequencies are determined differently for different type of functions.
The lighter, the better; recency starts with 0.
</p>


<h3>Value</h3>

<p>Vector of scores, corresponding to the entries evaluated.
</p>


<h3>Note</h3>

<p>Match and collostruction frequency are calculated separately before <code>CANDIDATESCORE</code> can apply. In the example below, the latter is randomly set for illustration purposes.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>SELECTVERB</code>, <code>SELECTACTOR</code>, <code>SELECTUNDERGOER</code>, <code>REFCHECK</code>, <code>TOPICCOPY</code>, <code>GENERALIZE</code>, <code>CHECKSUCCESS</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
lexicon=head(population[[1]]$nouns)
lexicon$match=VMATCH(lexicon[1,1:9], lexicon)
lexicon$collostruction=sample(100, nrow(lexicon))	
lexicon$score=CANDIDATESCORE(lexicon)
</code></pre>

<hr>
<h2 id='CHECKSUCCESS'>
Determine expected communicative success
</h2><span id='topic+CHECKSUCCESS'></span>

<h3>Description</h3>

<p>Check whether the hearer is likely to arrive at the intended role distribution and elaborate if not through explicit role marking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CHECKSUCCESS(speakerID, proposition, situation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CHECKSUCCESS_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to the speaker agent
</p>
</td></tr>
<tr><td><code id="CHECKSUCCESS_+3A_proposition">proposition</code></td>
<td>

<p>The proposition that is to be conveyed
</p>
</td></tr>
<tr><td><code id="CHECKSUCCESS_+3A_situation">situation</code></td>
<td>

<p>The situation in which the event that the proposition refers to is embedded.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elaboration is necessary if best typing match leads to wrong distribution of roles, but not if (one of) the roles are marked one way or another
First try if indexes are informative, next try appropriate pronominal case form, then check if word order is informative (if generalizations are made)
N exceptions should minimally be 4(=8/ln(8)) for Yang's tolerance principle.
</p>


<h3>Value</h3>

<p>A list, i.e. a checked and possibly elaborated proposition.
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Often, the interpretation of an utterance follows automatically by world knowledge in which case no explicit marking is necessary (e.g. &quot;man book read&quot;). Role marking is only necessary if participants qualify for both roles equally well (e.g. &quot;man woman see&quot;) or if a participant qualifies better for another role and outperforms the intended performer in this (e.g. &quot;man pig kill&quot;, in which the pig is the intended actor).
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Levelt, W.J.M. 1983. &quot;Monitoring and self-repair in speech&quot;. Cognition 14.41-104
</p>
<p>Hurford, J. R. 1989. &quot;Biological evolution of the saussurean sign as a component of the language acquisition device&quot;. Lingua 77:2.187-222.
</p>
<p>Steels, L. 2003. &quot;Language re-entrance and the inner voice&quot;. Journal of Consciousness Studies 10:4-5.173-185.
</p>
<p>Blutner, Reinhard, Helen de Hoop \&amp; Petra Hendriks. 2006. Optimal Communication. Stanford: CSLI.
</p>
<p>Charles Yang (2016), The price of linguistic productivity. Cambridge, MA: MIT Press.
</p>


<h3>See Also</h3>

<p><code>PREPARE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
CHECKSUCCESS(1, proposition, situation)
</code></pre>

<hr>
<h2 id='DECOMPOSE'>
Decompose words into morphemes
</h2><span id='topic+DECOMPOSE'></span>

<h3>Description</h3>

<p>Decomposes words into morphemes on the basis of the lexical entries in the lexicon. If multiple decompositions are possible, all are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DECOMPOSE(hearerID, form)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DECOMPOSE_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to hearer agent
</p>
</td></tr>
<tr><td><code id="DECOMPOSE_+3A_form">form</code></td>
<td>

<p>Word form that is considered for decomposition
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Decomposition is not trivial: Because of sloppy pronunciation (<code>PRODUCE</code>) and differences between speakers, mental representations of morphemes need not match one-to-one the parts of an utterance.
Zero morphemes are not allowed. Reduced forms may become suffixes too. Suffixes must be minimally erosionMax long (should be automatically satisfied...). 
Function applies recursively (max twice)
</p>


<h3>Value</h3>

<p>A vector with morphologically analyzed words, in which morpheme-s are separate-d by hyphen-s (&quot;-&quot;)
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>ANALYZE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
old=world$suffixThreshold
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
(utterance=PRODUCE(1, proposition))
(utterance=gsub(' ', '', utterance))
world$suffixThreshold=20
DECOMPOSE(2, utterance)
world$suffixThreshold=old
</code></pre>

<hr>
<h2 id='DIE'>
Kill agents
</h2><span id='topic+DIE'></span>

<h3>Description</h3>

<p>After a prespecified number of utterances (and after having given birth to a new generation of speakers), agents are removed from the (actively speaking) population. Death agents are stored in the <code>graveyard</code> for later inspection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIE(agentID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DIE_+3A_agentid">agentID</code></td>
<td>

<p>Pointer to agent whose death is considered.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DIE</code> is called at the end of each turn, but only applies if the agent is old enough.
</p>


<h3>Value</h3>

<p>New entry in <code>graveyard</code>.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
population[[1]]$age=world$deathAge+1
DIE(1)
</code></pre>

<hr>
<h2 id='EROSION'>
Word erosion
</h2><span id='topic+EROSION'></span>

<h3>Description</h3>

<p>If a perceived form differs from the mental representation it is matched with and the form has not been set yet, the hearer agent adjusts its mental representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EROSION(hearerID, interpretation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EROSION_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to the hearer agent whose representations might erode.
</p>
</td></tr>
<tr><td><code id="EROSION_+3A_interpretation">interpretation</code></td>
<td>

<p>Analysis of the utterance including the actually perceived forms.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forms will only be adjusted if they have not been frequently used (yet). Pronounced forms may differ from their representations because of reduction in pronunciation (cf. <code>REDUCE</code>).
</p>


<h3>Value</h3>

<p>no actual output; the form representations of the hearer agent are updated.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>TURN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
utterance=PRODUCE(1, proposition)
interpretation=INTERPRET(2, utterance, situation)
EROSION(2, interpretation)
</code></pre>

<hr>
<h2 id='FIRSTINFIRSTOUT'>
Order constituents by activation
</h2><span id='topic+FIRSTINFIRSTOUT'></span>

<h3>Description</h3>

<p>If incremental production is assumed (cf. <code>world</code>), constituents are produced in order of activation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIRSTINFIRSTOUT(speakerID, proposition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIRSTINFIRSTOUT_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker who's formulating an utterance
</p>
</td></tr>
<tr><td><code id="FIRSTINFIRSTOUT_+3A_proposition">proposition</code></td>
<td>

<p>The proposition to be uttered and whose constituents are reordered.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Balota, D. A. &amp; Chumbley, J. I. (1985). The locus of word-frequency in the pronunciation task: Lexical access and/or production? Journal of memory and languages, 24, 89-106.
</p>
<p>Bock, K., and Levelt, W.J.M. (1994). Language production. Grammatical encoding. IN M.A. Gernsbacher (Ed.). Handbook of psycholinguistics (pp.741-779). New York: Academic Press
</p>


<h3>See Also</h3>

<p><code>PREPARE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
(proposition=PROPOSITION(1, situation))
FIRSTINFIRSTOUT(speakerID, proposition)
</code></pre>

<hr>
<h2 id='FIRSTSPEAKER'>
Create founding agent
</h2><span id='topic+FIRSTSPEAKER'></span>

<h3>Description</h3>

<p>Creates first agent of a lineage which only consists of a conventional symbolic lexicon (and the infrastructure to count word uses). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIRSTSPEAKER()
</code></pre>


<h3>Details</h3>

<p>Start with 4 for log operations later on. Only with minimally 4 exceptions, Tolerance threshold is minority indeed
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>age</code></td>
<td>
<p>age of agent at birth=0</p>
</td></tr>
<tr><td><code>generation</code></td>
<td>
<p>generation of agent</p>
</td></tr>
<tr><td><code>fertile</code></td>
<td>
<p>logical for fertility of agent (1 until procreated)</p>
</td></tr>
<tr><td><code>semupdate</code></td>
<td>
<p>logical that says that whether agent has updated its semantics already (0 at birth; cf. <code>SEMUPDATE</code>)</p>
</td></tr>
<tr><td><code>verbs</code></td>
<td>
<p>verbal lexicon</p>
</td></tr>
<tr><td><code>nouns</code></td>
<td>
<p>nominal lexicon</p>
</td></tr>
<tr><td><code>usageHistory</code></td>
<td>
<p>list with actual usages of verbs, nouns, and verb and nominal markers</p>
</td></tr>
<tr><td><code>commonGround</code></td>
<td>
<p>vector with lexemes recently discussed</p>
</td></tr>
<tr><td><code>collostructions</code></td>
<td>
<p>list with collostruction frequencies for subject-verb, object-verb, index-referent, and noun marker-noun combinations</p>
</td></tr>
<tr><td><code>topic</code></td>
<td>
<p>topic</p>
</td></tr>
<tr><td><code>wordOrder</code></td>
<td>
<p>data frame with word order frequencies</p>
</td></tr>
<tr><td><code>topicPosition</code></td>
<td>
<p>data frame with topic position frequencies</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Charles Yang (2016), The price of linguistic productivity. Cambridge, MA: MIT Press.
</p>


<h3>See Also</h3>

<p><code>FOUND</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adam=FIRSTSPEAKER()
str(adam)
</code></pre>

<hr>
<h2 id='FMATCH'>
Compare forms</h2><span id='topic+FMATCH'></span>

<h3>Description</h3>

<p>Determine match between a given (perceived) form and a list of forms (i.e., the mental representations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FMATCH(target, lexicon)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FMATCH_+3A_target">target</code></td>
<td>

<p>The form whose matching lexeme is to be identified
</p>
</td></tr>
<tr><td><code id="FMATCH_+3A_lexicon">lexicon</code></td>
<td>

<p>The lexicon in which a match is sought.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Characters are matched one by one from left to right. Mismatches are weighted according to onset priority: mismatches in the beginning of a word are more important than later ones.
</p>


<h3>Value</h3>

<p>vector of matching scores rescaled to 1-0 range.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>ANALYZE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
(lexicon=head(population[[1]]$nouns))
target=lexicon$form[1]
FMATCH(target, lexicon)
</code></pre>

<hr>
<h2 id='FORMS'>
Generate forms
</h2><span id='topic+FORMS'></span>

<h3>Description</h3>

<p>Generates set of unique forms for initial generation of speakers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FORMS(n, length = world$wordLength, vowels = world$vowels, consonants = world$consonants)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FORMS_+3A_n">n</code></td>
<td>

<p>Number of word forms to be generated
</p>
</td></tr>
<tr><td><code id="FORMS_+3A_length">length</code></td>
<td>

<p>Length (range) within which word forms have to fall.
</p>
</td></tr>
<tr><td><code id="FORMS_+3A_vowels">vowels</code></td>
<td>

<p>Vowels that are used in the language
</p>
</td></tr>
<tr><td><code id="FORMS_+3A_consonants">consonants</code></td>
<td>

<p>Vowels that are used in the language
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allows for CV and VC</p>


<h3>Value</h3>

<p>character vector
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>VERBS</code>, <code>NOUNS</code>, <code>FOUND</code>, <code>FUSE</code>, <code>PROCREATE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>world$vowels; world$consonants; world$wordLength
FORMS(10)
</code></pre>

<hr>
<h2 id='FOUND'>
Found population
</h2><span id='topic+FOUND'></span>

<h3>Description</h3>

<p>Found a new population of speakers to start a simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FOUND(nAgents = world$nAgents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FOUND_+3A_nagents">nAgents</code></td>
<td>

<p>number of agents to start with.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>starting population
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>MULTIRUN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND(4)
names(population)
</code></pre>

<hr>
<h2 id='FREQUPDATE'>
Update usage numbers
</h2><span id='topic+FREQUPDATE'></span>

<h3>Description</h3>

<p>Update frequency numbers in lexicon and usage history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FREQUPDATE(agentID, meaning, success)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FREQUPDATE_+3A_agentid">agentID</code></td>
<td>

<p>pointer to agent whose numbers are to be updated
</p>
</td></tr>
<tr><td><code id="FREQUPDATE_+3A_meaning">meaning</code></td>
<td>

<p>Meaning (proposition or interpretation) on the basis of whose constituents the numbers in the usage history and lexicon have to be updated.
</p>
</td></tr>
<tr><td><code id="FREQUPDATE_+3A_success">success</code></td>
<td>

<p>Logical for success of conversational turn (as number of successful uses are kept track of)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Difference is made between local and third-person pronouns. +1 at the end for log operation and to prevent division by zero</p>


<h3>Value</h3>

<p>No actual output: updated usage history and lexicon
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>TURN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
population[[1]]$nouns[population[[1]]$nouns$ID%in%c(proposition$external$ID),]
population[[1]]$wordOrder
FREQUPDATE(1, proposition, success=1)
population[[1]]$nouns[population[[1]]$nouns$ID%in%c(proposition$external$ID),]
population[[1]]$wordOrder
</code></pre>

<hr>
<h2 id='FUSE'>
Fuse words
</h2><span id='topic+FUSE'></span>

<h3>Description</h3>

<p>Fuses lexical items with frequently co-occuring markers into new lexical items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FUSE(agent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FUSE_+3A_agent">agent</code></td>
<td>

<p>Agent whose lexical items are considered for fusion.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Words are only fused if the combination is used frequently enough (cf. <code>world</code>) and if meaning and form result of fusion is not in the lexicon already. Meaning of lexical item is overwritten for those meaning dimensions for which marker is specified only. Semantics of host is mixed with that of marker. 
</p>


<h3>Value</h3>

<p>No actual output: agent with updated lexicon
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Bybee, J. (2010). Language, usage and cognition. New York: Cambridge University Press.
</p>
<p>Bybee, J. L. (1985). Morphology. a study of the relation between meaning and form. Amsterdam/Philadelphia: John Benjamins.
</p>


<h3>See Also</h3>

<p><code>SEMUPDATE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
agent=population[[1]]
agent$collostructions$flag[1,]$N=agent$nouns$ID[nrow(agent$nouns)-1]
agent$collostructions$flag[1,]$marker=agent$nouns$ID[nrow(agent$nouns)]
agent$collostructions$flag[1,]$frequency=100
agent$nouns[nrow(agent$nouns),]$nounMarker=100
agent$nouns[nrow(agent$nouns)-1,]$person=1
agent$nouns[nrow(agent$nouns),6:9]=NA
agent$collostructions$flag
tail(agent$nouns)

agent=FUSE(agent)
agent$collostructions$flag
tail(agent$nouns)
</code></pre>

<hr>
<h2 id='GENERALIZE'>
Apply linguistic generalizations
</h2><span id='topic+GENERALIZE'></span>

<h3>Description</h3>

<p>Checks whether the previous use of certain constructions or word orders reaches a generalization threshold. If so, the construction will be used independently from its current communicative value. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GENERALIZE(speakerID, proposition, situation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GENERALIZE_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker who's considering the use standard use of a construction
</p>
</td></tr>
<tr><td><code id="GENERALIZE_+3A_proposition">proposition</code></td>
<td>

<p>The proposition to which the construction applies
</p>
</td></tr>
<tr><td><code id="GENERALIZE_+3A_situation">situation</code></td>
<td>

<p>The communicative situation in which the utterance is made
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the generalization threshold, Yang's Tolerance principle is used, which says that the number of exceptions to a rule for it to be applied/maintained/stipulated has to be below n/log(n), with n being the number of instances the rule (could have) applied. N exceptions should minimally be 4(=8/ln(8)) for Yang to make sense.
Generalizations are checked, for word order first (in which grammatical order is overruled by topic generalizations), then for marking (since solutionMethod for marking sometimes dependent on word order). 
Noun marking first checked at general level, then for more specific dimensions of semantic role.
&quot;values=\-values[1:length(speaker$usageHistory$flag\-[[firstArgument$semRole]]$value)]&quot; is necessary for economically stored resurrected agents (if world$saveAll=F and their behavior is checked)
Third-person pronoun are only used if single third-person referent in situation.
</p>


<h3>Value</h3>

<p>A list: the proposition, possibly in a generalized form.
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Charles Yang (2016), The price of linguistic productivity. Cambridge, MA: MIT Press.
</p>


<h3>See Also</h3>

<p><code>PREPARE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
GENERALIZE(1, proposition, situation)
population[[1]]$wordOrder[3,2:3]=9999
population[[1]]$wordOrder
GENERALIZE(1, proposition, situation)
</code></pre>

<hr>
<h2 id='GROUP'>
Group words into constituents
</h2><span id='topic+GROUP'></span>

<h3>Description</h3>

<p>Determines each possible constituent ordering (assuming adjacency) of an utterance. Given A B C V, in which V is identified as the verb, B could be a marker of A, or C could be a marker of B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GROUP(hearerID, analysis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GROUP_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to the hearer agent
</p>
</td></tr>
<tr><td><code id="GROUP_+3A_analysis">analysis</code></td>
<td>

<p>Analysis of the utterance in which the individual lexemes have been determined and the verb has been identified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>VerbAdpositions are for topic cross reference only, and may be put on top of verb suffixes. 
VerbAdpositions are reanalyzed as verbSuffix if index=TRUE and no other verb suffixes (then no proper suffix was available)
Only non-local-person noun markers, to be removed if possessive marking is modelled.
</p>


<h3>Value</h3>

<p>list of all possible groupings
</p>
<table role = "presentation">
<tr><td><code>[[1]]</code></td>
<td>
<p>First possible grouping analysis</p>
</td></tr>
<tr><td><code>[[2]]</code></td>
<td>
<p>Second possible grouping analysis, if possible, etc.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>INTERPRET</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
utterance=PRODUCE(1, proposition)
utterance=paste(utterance, unlist(strsplit(utterance, ' '))[1])
analysis=ANALYZE(2, utterance, situation)
GROUP(2, analysis)
</code></pre>

<hr>
<h2 id='INTERPRET'>
Interpret utterance
</h2><span id='topic+INTERPRET'></span>

<h3>Description</h3>

<p>Determines the best interpretation of an utterance given the situational context. Compares different interpretations if multiple analyses are possible and chooses most likely one given context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INTERPRET(hearerID, utterance, situation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="INTERPRET_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to the hearer agent
</p>
</td></tr>
<tr><td><code id="INTERPRET_+3A_utterance">utterance</code></td>
<td>

<p>The utterance to be interpreted
</p>
</td></tr>
<tr><td><code id="INTERPRET_+3A_situation">situation</code></td>
<td>

<p>Set of events in which utterance was used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#first use explicit role marking
#then word order (if still necessary)
#then verb morphology (idem)
</p>


<h3>Value</h3>

<p>interpretation, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event identified on the basis of interpretation, including matching scores</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>TURN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
utterance=PRODUCE(1, proposition)
INTERPRET(2, utterance, situation)
</code></pre>

<hr>
<h2 id='INTERPRET.INT'>
Develop an interpretation
</h2><span id='topic+INTERPRET.INT'></span>

<h3>Description</h3>

<p>Translates utterance analysis into a proposition (i.e., an interpretation) and determines match with ongoing events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INTERPRET.INT(hearerID, analysis, situation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="INTERPRET.INT_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to the hearer agent that is interpreting an analysis
</p>
</td></tr>
<tr><td><code id="INTERPRET.INT_+3A_analysis">analysis</code></td>
<td>

<p>The analysis to be translated
</p>
</td></tr>
<tr><td><code id="INTERPRET.INT_+3A_situation">situation</code></td>
<td>

<p>Situation in which utterance is interpreted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>INTERPRET.INT</code> works internal to <code>INTERPRET</code>, which compares the interpretations of the different possible analyses.
VerbAdpositions overrule verbSuffixes... 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event identified on the basis of interpretation, including matching scores</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>INTERPRET</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
utterance=PRODUCE(1, proposition)
analysis=ANALYZE(2, utterance, situation)
(analysis=PROTOINTERPRETATION(2, analysis))
INTERPRET.INT(2, analysis, situation)
</code></pre>

<hr>
<h2 id='MAX'>
Find maximum value
</h2><span id='topic+MAX'></span><span id='topic+MIN'></span>

<h3>Description</h3>

<p>Extension of standard <code>max</code> and <code>min</code> functions with which rank position(s) can be specified and result can be either rank or value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAX(vector, rank = 1, value = FALSE, rank.adjust = TRUE, forceChoice = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAX_+3A_vector">vector</code></td>
<td>

<p>Vector in which maximum/minimum element needs to be identified
</p>
</td></tr>
<tr><td><code id="MAX_+3A_rank">rank</code></td>
<td>

<p>value(s) or rank(s) of maximum values. 
</p>
</td></tr>
<tr><td><code id="MAX_+3A_value">value</code></td>
<td>

<p>Should value or rank be returned?
</p>
</td></tr>
<tr><td><code id="MAX_+3A_rank.adjust">rank.adjust</code></td>
<td>

<p>If maximum value of range of ranks exceeds vector length, should this be adjusted?
</p>
</td></tr>
<tr><td><code id="MAX_+3A_forcechoice">forceChoice</code></td>
<td>

<p>In case of ties, should all results be returned or only one?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector (either value or rank)
</p>


<h3>Warning</h3>

<p>If minimum value (of a range of) rank(s) exceeds vector length, results are meaningless.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>MIN</code>, <code>NOUNS</code>, <code>SITUATION</code>, <code>SELECTVERB</code>, <code>SELECTACTOR</code>, <code>SELECTUNDERGOER</code>, <code>REFCHECK</code>, <code>TOPICCOPY</code>, <code>GENERALIZE</code>, <code>CHECKSUCCESS</code>, <code>ANALYZE</code>, <code>TYPEMATCH</code>, <code>NOUNMORPHOLOGY</code>, <code>VERBMORPHOLOGY</code>, <code>INTERPRET.INT</code>, <code>INTERPRET</code>, <code>NOUNDESEMANTICIZATION</code>, <code>VERBDESEMANTICIZATION</code>, <code>SEMUPDATE</code>, <code>DIE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a=rep(1:10, 2)
MAX(a, rank=1:3, value=TRUE, forceChoice=TRUE)
MIN(a, rank=1:3, value=TRUE, forceChoice=TRUE)
</code></pre>

<hr>
<h2 id='NOUNDESEMANTICIZATION'>
Bleach word meaning
</h2><span id='topic+NOUNDESEMANTICIZATION'></span><span id='topic+VERBDESEMANTICIZATION'></span>

<h3>Description</h3>

<p>Update meaning representations of nouns/verbs on the basis of usage history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOUNDESEMANTICIZATION(agent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NOUNDESEMANTICIZATION_+3A_agent">agent</code></td>
<td>

<p>Agent whose lexicon is to be updated
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cf. Heine and Kuteva p.39: freq is epiphenomenon of extension, not cause; extension by combinatorial flexibility
8 is minimum freq from which Yang applies.
</p>


<h3>Value</h3>

<p>agent (with updated nominal representations)
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Hopper, P. J. &amp; Traugott, E. C. (2003). Grammaticalization. Cambridge: Cambridge University Press.
</p>
<p>Heine, B. &amp; Kuteva, T. (2007). The genesis of grammar. a reconstruction. Oxford: Oxford University Press.
</p>
<p>Bybee, J. (2010). Language, usage and cognition. New York: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code>SEMUPDATE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#only effective if usage history is non-empty
FOUND()
population[[1]]=NOUNDESEMANTICIZATION(population[[1]])	
population[[1]]=VERBDESEMANTICIZATION(population[[1]])	
</code></pre>

<hr>
<h2 id='NOUNMORPHOLOGY'>
Interpret nominal morphology
</h2><span id='topic+NOUNMORPHOLOGY'></span>

<h3>Description</h3>

<p>Use noun markers to determine event-role distribution (i.e., who is actor and who is undergoer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOUNMORPHOLOGY(hearerID, analysis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NOUNMORPHOLOGY_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to hearer agent who's developing an analysis
</p>
</td></tr>
<tr><td><code id="NOUNMORPHOLOGY_+3A_analysis">analysis</code></td>
<td>

<p>Analysis of utterance (result of <code>ANALYZE</code>) in which roles have to be determined.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Marker overrules suffix with same host
Future work: allow for oblique roles.
</p>


<h3>Value</h3>

<p>Analysis (dataframe) with roles assigned on the basis of nominal markers.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>INTERPRET</code>, <code>VERBMORPHOLOGY</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
prep=PREPARE(1, proposition, situation)
utterance=PRODUCE(1, prep)
analysis=ANALYZE(2, utterance, situation)
grouping=GROUP(2, analysis)
(analysis=NOUNMORPHOLOGY(2, grouping[[length(grouping)]]))
analysis$role
#repeat if no nounAdposition is identified.
</code></pre>

<hr>
<h2 id='NOUNS'>
Generate nominal lexicon
</h2><span id='topic+NOUNS'></span>

<h3>Description</h3>

<p>Generate nominal lexicon for founding agents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOUNS(n = world$nNouns, local = world$local)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NOUNS_+3A_n">n</code></td>
<td>

<p>Number of nominal lexemes
</p>
</td></tr>
<tr><td><code id="NOUNS_+3A_local">local</code></td>
<td>

<p>Should agents have lexemes to refer to speech-act participants (i.e. 'I/me' and 'you')?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimally 2 entries are necessary to create a dataframe.
</p>


<h3>Value</h3>

<p>data frame with randomly generated forms, their meaning representations in terms of numeric vectors, and frequency counters.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>VERBS</code>, <code>FIRSTSPEAKER</code>, <code>SEMUPDATE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NOUNS(10)
</code></pre>

<hr>
<h2 id='PERSONUPDATE'>
Adjust person value
</h2><span id='topic+PERSONUPDATE'></span>

<h3>Description</h3>

<p>Adjust person value of noun from third to local (first or second) if it has been recruited frequently to express local reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PERSONUPDATE(agent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PERSONUPDATE_+3A_agent">agent</code></td>
<td>

<p>Agent whose nominal lexicon is considered.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple verb markers with same person are taken care of too. Redundant local pronouns and indexes are removed.
</p>


<h3>Value</h3>

<p>Agent (with updated lexicon)
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Zeevat, Henk. 2007. &quot;Simulating recruitment in evolution&quot;. Cognitive Foundations of Interpretation ed. by G. Bouma, I. Kraemer &amp; J. Zwarts, 175-194. Amsterdam: Royal Netherlands Academy of Arts and Sciences.
</p>


<h3>See Also</h3>

<p><code>SEMUPDATE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
population[[1]]=PERSONUPDATE(population[[1]]) #only effective if pronouns have been recruited
</code></pre>

<hr>
<h2 id='PREPARE'>
Prepare a proposition for production
</h2><span id='topic+PREPARE'></span>

<h3>Description</h3>

<p>Prepare a proposition for production by checking if it will be intelligible and applying generalizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PREPARE(speakerID, proposition, situation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PREPARE_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent
</p>
</td></tr>
<tr><td><code id="PREPARE_+3A_proposition">proposition</code></td>
<td>

<p>Proposition that is prepared for production
</p>
</td></tr>
<tr><td><code id="PREPARE_+3A_situation">situation</code></td>
<td>

<p>Situation in which proposition is to be uttered.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PREPARE</code> involves a number of subroutines: If role distribution is unclear, agents checks if this can be resolved with pronominal case forms and if not with noun markers (<code>CHECKSUCCESS</code>). If referential expression is too weak, stronger expressions are used (<code>REFCHECK</code>). If generalizations such as PutAgentFirst or IndexFirstPerson are made, they are applied (<code>GENERALIZE</code>). If words are frequently used, their forms are reduced (<code>REDUCE</code>). Etc.
Ingredients of proposition are ordered by activation before other principles apply
</p>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument, possibly including role marking</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified, , possibly including role marking</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument, possibly including person indexing</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>TURN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
(proposition=PROPOSITION(1, situation))
PREPARE(1, proposition, situation) 
#result need not be different from simple proposition, 
#depends on generalizations and typing scores
</code></pre>

<hr>
<h2 id='PROCREATE'>
Generate new generation of agents
</h2><span id='topic+PROCREATE'></span>

<h3>Description</h3>

<p>Generate new generation of agents if (to be) parent generation is old enough. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PROCREATE(speakerID, hearerID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PROCREATE_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to first parent
</p>
</td></tr>
<tr><td><code id="PROCREATE_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to second parent
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New generation is mix of vocabularies of parents (if <code>world$crossover</code> is T), with emptied usage histories. Agents procreate after number of utterances specified by <code>world$procreationAge</code>. Meanings of words that have not been used by their parents are modified slightly.
</p>


<h3>Value</h3>

<p>Set of new agents
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>TALK</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
population[[1]]$age=population[[2]]$age=world$procreationAge*world$deathAge+1
PROCREATE(1,2)
</code></pre>

<hr>
<h2 id='PRODUCE'>
Produce utterance
</h2><span id='topic+PRODUCE'></span>

<h3>Description</h3>

<p>Turns proposition into actual utterance. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRODUCE(speakerID, prep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PRODUCE_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent
</p>
</td></tr>
<tr><td><code id="PRODUCE_+3A_prep">prep</code></td>
<td>

<p>Proposition to be uttered
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal markers are produced closest to verb (cf. Dryer); not exploited by hearer.
</p>


<h3>Value</h3>

<p>Character string
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Matthew S. Dryer. 2013. Order of Subject, Object and Verb. In: Dryer, Matthew S. &amp; Haspelmath, Martin (eds.) The World Atlas of Language Structures Online.
</p>


<h3>See Also</h3>

<p><code>TURN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
PRODUCE(1, proposition)
</code></pre>

<hr>
<h2 id='PROPOSITION'>
Develop initial proposition
</h2><span id='topic+PROPOSITION'></span>

<h3>Description</h3>

<p>Develop initial proposition that consists of the expressions that refer to the participants of the event to be expressed (both objects and action). Proposition will be elaborated upon in later stages of the production processs, and word  may be replaced later if they turn out to be insufficient (cf. <code>PREPARE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PROPOSITION(speakerID, situation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PROPOSITION_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent
</p>
</td></tr>
<tr><td><code id="PROPOSITION_+3A_situation">situation</code></td>
<td>

<p>Situation with target event to be referred to and number of distractor event
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Words are ranked on the basis of a combination of semantic match (how well does word refer to its participant), frequency, and recency (cf. <code>CANDIDATEORDER</code>). The first word to be sufficiently distinctive is selected for expression.
</p>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade</p>


<h3>See Also</h3>

<p><code>TURN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
</code></pre>

<hr>
<h2 id='PROTOINTERPRETATION'>
Develop interpretation
</h2><span id='topic+PROTOINTERPRETATION'></span>

<h3>Description</h3>

<p>Develop interpretation of an utterance using simple heuristics only (i.e., ignoring grammatical markers and tendencies). Applies if grammar either did not develop yet, or does not suffice for disambiguation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PROTOINTERPRETATION(hearerID, analysis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PROTOINTERPRETATION_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to hearer agent
</p>
</td></tr>
<tr><td><code id="PROTOINTERPRETATION_+3A_analysis">analysis</code></td>
<td>

<p>Analysis of the utterance to be interpreted (cf. <code>ANALYZE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only one role is unclear, it follows from simple reasoning (V has x and y role, A is x, then B must be y). If both roles are unclear, <code>TYPEMATCH</code> is used.
</p>


<h3>Value</h3>

<p>a dataframe, i.e. the analysis input in which the role column is updated.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>VERBMORPHOLOGY</code>, <code>INTERPRET</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
utterance=PRODUCE(1, proposition)
(analysis=ANALYZE(2, utterance, situation))
PROTOINTERPRETATION(2, analysis)
</code></pre>

<hr>
<h2 id='REDUCE'>
Reduce length of expressions
</h2><span id='topic+REDUCE'></span>

<h3>Description</h3>

<p>Reduces length of frequently or recently used expressions by removing final character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REDUCE(speakerID, proposition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REDUCE_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent.
</p>
</td></tr>
<tr><td><code id="REDUCE_+3A_proposition">proposition</code></td>
<td>

<p>Proposition with words whose forms may be reduced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reduction is an online production process only. It does not affect the lexical representation of the speaker (but cf. <code>EROSION</code>)
</p>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument, possibly with shortened form</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified, possibly with shortened form</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument, possibly with shortened form</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Nettle, D. (1999). Linguistic diversity. New York: OUP.
</p>
<p>Jurafsky, Daniel, Alan Bell, Michelle Gregory &amp; William D. Raymond. 2001. &quot;Probabilistic relations between words: Evidence from reduction in lexical production&quot;. In: J. Bybee and P. Hopper (eds), Frequency and the emergence of linguistic structure, 229-255. Amsterdam/Philadelphia. John Benjamins.
</p>


<h3>See Also</h3>

<p><code>PREPARE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
REDUCE(1, proposition)	#only effective if proposition includes frequently/recently used words
</code></pre>

<hr>
<h2 id='REFCHECK'>
Check referential capacity
</h2><span id='topic+REFCHECK'></span>

<h3>Description</h3>

<p>Check if pronoun is sufficiently strong to establish reference to referent. If not, another word is recruited for support, the pronoun being suffixed to the verb.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REFCHECK(speakerID, proposition, situation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REFCHECK_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent
</p>
</td></tr>
<tr><td><code id="REFCHECK_+3A_proposition">proposition</code></td>
<td>

<p>Proposition in which the referential expressions are checked
</p>
</td></tr>
<tr><td><code id="REFCHECK_+3A_situation">situation</code></td>
<td>

<p>Situation in which referential relations have to be established
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strength is determined by formal mass, i.e. simple word length.
Non-local arguments are matched with real-world argument; local pronoun with role, after which marker is removed. If there's no local pronominal paradigm yet, select prominent noun for local ref
</p>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument, checked for strength</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified, checked for strength</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument, possibly including person indexing if original expression for (one of the) event participants fell short</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Zeevat, Henk. 2007. &quot;Simulating recruitment in evolution&quot;. Cognitive Foundations of Interpretation ed. by G. Bouma, I. Kraemer &amp; J. Zwarts, 175-194. Amsterdam: Royal Netherlands Academy of Arts and Sciences.
</p>
<p>Ariel, M. (1999). The development of person agreement markers: From pronouns to higher accessibility markers. In M. Barlow &amp; S. Kemmer (Eds.), Usage based models of language (p. 197-260). Stanford: CSLI.
</p>


<h3>See Also</h3>

<p><code>PREPARE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
(proposition=PROPOSITION(1, situation))
REFCHECK(1, proposition, situation)	
#only effective if words have grammaticalized already
</code></pre>

<hr>
<h2 id='RESCALE'>
Rescale vector values
</h2><span id='topic+RESCALE'></span>

<h3>Description</h3>

<p>Rescale vector values to -1:1 range (or 0:1 if there are no negative values)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RESCALE(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RESCALE_+3A_x">x</code></td>
<td>

<p>Vector to be rescaled
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector, with abs(max value) of 1
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>CANDIDATESCORE</code>, <code>FREQUPDATE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RESCALE(-10:5)
</code></pre>

<hr>
<h2 id='RUN'>
Run simulation
</h2><span id='topic+RUN'></span>

<h3>Description</h3>

<p>Run simulation for specified number of hours. Language change beyond phonological change to happen generally requires multiple hours of simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RUN(nHours = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RUN_+3A_nhours">nHours</code></td>
<td>

<p>Number of hours to run simulation. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No output. Objects in work space (<code>population</code>, <code>graveyard</code>, <code>situation</code>, <code>proposition</code>, <code>utterance</code>, <code>interpretation</code>) are adapted.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>MULTIRUN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
## Not run: RUN(.000001)
</code></pre>

<hr>
<h2 id='SELECTACTOR'>
Find actor expression
</h2><span id='topic+SELECTACTOR'></span><span id='topic+SELECTUNDERGOER'></span><span id='topic+SELECTVERB'></span>

<h3>Description</h3>

<p>Select best expression for actor/undergoer/verb participant in the event to be described
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SELECTACTOR(speakerID, situation, verb = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SELECTACTOR_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent
</p>
</td></tr>
<tr><td><code id="SELECTACTOR_+3A_situation">situation</code></td>
<td>

<p>Situation in which event to be described is situated
</p>
</td></tr>
<tr><td><code id="SELECTACTOR_+3A_verb">verb</code></td>
<td>

<p>Pointer to verb lexeme used in the utterance to be formulated (if present already)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Verb is relevant because of collostruction frequencies: some agents are more likely to be mentioned given certain verbs (cf. <code>CANDIDATEORDER</code>). Works other way around for <code>SELECTVERB</code>.
</p>


<h3>Value</h3>

<p>A dataframe with the lexical representation of the agent/undergoer/verb.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>PROPOSITION</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
situation[situation$target==1,]
SELECTACTOR(1, situation)
SELECTVERB(1, situation)
if(!is.na(situation[situation$target==1,]$U1)){
	SELECTUNDERGOER(1, situation)
}
</code></pre>

<hr>
<h2 id='SEMUPDATE'>
Update lexicon
</h2><span id='topic+SEMUPDATE'></span>

<h3>Description</h3>

<p>Update meaning lexicon on the basis of usage. Involves <code>NOUNDESEMANTICIZATION</code>, <code>VERBDESEMANTICIZATION</code>, <code>FUSE</code>, and <code>PERSONUPDATE</code>. Also, words that have become meaningless are replaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMUPDATE(agentID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEMUPDATE_+3A_agentid">agentID</code></td>
<td>

<p>Pointer to agent whose lexicon is to be updated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>agent with updated lexicon
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>talk</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
SEMUPDATE(1)
</code></pre>

<hr>
<h2 id='SITUATION'>
Create situational context
</h2><span id='topic+SITUATION'></span>

<h3>Description</h3>

<p>Create situational context that consists of set of events among which the target event to be described.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SITUATION(speakerID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SITUATION_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent whose concepts are used to create situation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Events are generated on the basis of agents' world knowledge. In principle, qualified participants are more likely than unqualified ones (e.g. books are read, not eaten; cf. <code>world$roleNoise</code>; <code>world$referenceNoise</code>).
Local person always known, so if world$local==T, oddsNew for Dahl numbers are adjusted.
Situations with multiple events are more likely than situations with single event.
Locals are animate.
If none of the candidates qualifies argument criterium, only recency is used for topichood (cf. DuBois: preference for actor topic)
</p>


<h3>Value</h3>

<p>dataframe with sets of vectors that specify actions and actors, and if present undergoer participants. 
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>John W. DuBois (1987), The discourse basis of ergativity. Language 63 (4)
</p>


<h3>See Also</h3>

<p><code>TURN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
SITUATION(1)
</code></pre>

<hr>
<h2 id='SUCCESS'>
Determine communicative success
</h2><span id='topic+SUCCESS'></span>

<h3>Description</h3>

<p>Determine communicative success by comparing intention of speaker (proposition) and interpretation of hearer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SUCCESS(proposition, interpretation, situation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SUCCESS_+3A_proposition">proposition</code></td>
<td>

<p>Intended/speaker meaning
</p>
</td></tr>
<tr><td><code id="SUCCESS_+3A_interpretation">interpretation</code></td>
<td>

<p>Interpretation/hearer meaning
</p>
</td></tr>
<tr><td><code id="SUCCESS_+3A_situation">situation</code></td>
<td>

<p>Contextual situation in which communication took place.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are no distractor events ongoing, success is determined by comparing the speaker and hearer meanings; otherwise, communication is successful if the same target event is selected.
</p>


<h3>Value</h3>

<p>Logical: 1 for success; 0 for failure
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>TURN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
(proposition=PROPOSITION(1, situation))
utterance=PRODUCE(1, proposition)
(interpretation=INTERPRET(2, utterance, situation))
SUCCESS(proposition, interpretation, situation)
</code></pre>

<hr>
<h2 id='SUMMARY'>
Summarize simulation results
</h2><span id='topic+SUMMARY'></span>

<h3>Description</h3>

<p>Summarize results of simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SUMMARY()
</code></pre>


<h3>Value</h3>

<p>List and plots
</p>
<table role = "presentation">
<tr><td><code>generation</code></td>
<td>
<p>generation of present agent</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>word-order generalizations</p>
</td></tr>
<tr><td><code>topic</code></td>
<td>
<p>topic-order generalizations</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>verb-marker generalizations</p>
</td></tr>
<tr><td><code>person</code></td>
<td>
<p>generalizations about role marking per person (e.g. first person undergoers should be marked)</p>
</td></tr>
<tr><td><code>actor</code></td>
<td>
<p>actor-marking generalizations on the basis of meaning (e.g. all actors with a zero value on the first dimension should be marked)</p>
</td></tr>
<tr><td><code>undergoer</code></td>
<td>
<p>undergoer-marking generalizations on the basis of meaning (e.g. all undergoer with a zero value on the first dimension should be marked)</p>
</td></tr>
<tr><td><code>markers</code></td>
<td>
<p>which words were mostly used as markers</p>
</td></tr>
<tr><td><code>nounMarkerUse1</code></td>
<td>
<p>proportion of role-marking in total</p>
</td></tr>
<tr><td><code>nounMarkerUse12</code></td>
<td>
<p>proportion of role-marking of transitive events</p>
</td></tr>
<tr><td><code>first</code></td>
<td>
<p>lexemes with first-person meaning</p>
</td></tr>
<tr><td><code>second</code></td>
<td>
<p>lexemes with second-person meaning</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>CHECKMARKER</code>, <code>HISTORY</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
FOUND()
RUN(.0001)	#create results to summarize: first generation has to die
world$deathAge=10
DIE(1)
SUMMARY()

## End(Not run)
</code></pre>

<hr>
<h2 id='TALK'>
Let agents talk
</h2><span id='topic+TALK'></span>

<h3>Description</h3>

<p>Sample two agents and let them talk with each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TALK(nTurns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TALK_+3A_nturns">nTurns</code></td>
<td>

<p>Number of communicative turns a conversation last before new agents are selected for communication.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Young agents are less likely to talk with each other.
</p>


<h3>Value</h3>

<p>On screen conversation. (Underlying update of usage history of talking agents.)
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>RUN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
## Not run: TALK(4)
</code></pre>

<hr>
<h2 id='TOPICCOPY'>
Make anaphoric copy of topic 
</h2><span id='topic+TOPICCOPY'></span>

<h3>Description</h3>

<p>Make verb-adjacent anaphoric copy of contrastive topic. Only applies if topics are moved to first position (after this generalization is made).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOPICCOPY(speakerID, proposition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TOPICCOPY_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent
</p>
</td></tr>
<tr><td><code id="TOPICCOPY_+3A_proposition">proposition</code></td>
<td>

<p>Proposition that agent is formulating
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Anaphoric copies only need to distinguish topic from other argument for reestablished/non-continuous topics (cf. Givon)
</p>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument, possibly including role marking</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified, possibly including role marking</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument, possibly including person indexing</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>T. Givon (1976), &quot;Topic, pronoun, and grammatical agreement&quot;, In: C. Li (Ed.), Subject and topic, New York, etc.: Academic Press, Inc, 149-188.
</p>


<h3>See Also</h3>

<p><code>TOPICFIRST</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
proposition$verb$topic=0; if('internal'%in%names(proposition)){proposition$internal$topic=0}
proposition$external$topic=1; proposition$external$recency=10
world$topicCopy=FALSE
proposition=TOPICFIRST(1, proposition)
PRODUCE(1, proposition)
proposition=TOPICCOPY(1, proposition)
PRODUCE(1, proposition)
</code></pre>

<hr>
<h2 id='TOPICFIRST'>
Put topic in first position
</h2><span id='topic+TOPICFIRST'></span>

<h3>Description</h3>

<p>Put topic of the utterance in first position if such a tendency was observed in and therefore generalization was made on the basis of previous utterances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOPICFIRST(speakerID, proposition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TOPICFIRST_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent
</p>
</td></tr>
<tr><td><code id="TOPICFIRST_+3A_proposition">proposition</code></td>
<td>

<p>Proposition in which topic argument is to be moved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument, possibly including role marking</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified, possibly including role marking</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument, possibly including person indexing</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr></table>
<p>,
in which the topic argument is put first
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Tomlin, R. S. (1986). Basic word order:  Functional principles (Vol. 13).  Routledge
</p>
<p>Ferrer-i-Cancho,  R.   (2014).   Why  might  SOV be  initially  preferred  and  then lost or recovered?  a theoretical framework.  In: Proceedings of the 10th international conference (evolang10), pp. 66-73.
</p>
<p>Bates,  E.,  &amp;  MacWhinney,  B.  (1987).  Competition,  variation,  and  language learning. Mechanisms of language acquisition, 157-193.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
PRODUCE(1, proposition)
proposition=TOPICFIRST(1, proposition)
PRODUCE(1, proposition)
</code></pre>

<hr>
<h2 id='TURN'>
Organize communicative turn 
</h2><span id='topic+TURN'></span>

<h3>Description</h3>

<p>Organize communicative turn in conversation. Involves generating a situation (<code>SITUATION</code>), developing an utterance (<code>PROPOSITION</code>, <code>PREPARE</code>, <code>PRODUCE</code>), interpreting the utterance (<code>INTERPRET</code>), and updating the lexicon (<code>FREQUPDATE</code>, <code>EROSION</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TURN(speakerID, hearerID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TURN_+3A_speakerid">speakerID</code></td>
<td>

<p>Pointer to speaker agent
</p>
</td></tr>
<tr><td><code id="TURN_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to hearer agent
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string on screen, real output: agents with updated usage history.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>TALK</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
TURN(1,2)
</code></pre>

<hr>
<h2 id='TYPEMATCH'>
Determine role qualification
</h2><span id='topic+TYPEMATCH'></span>

<h3>Description</h3>

<p>Determine event-role distribution of participants on the basis of role qualification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TYPEMATCH(hearerID, analysis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TYPEMATCH_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to hearer agent
</p>
</td></tr>
<tr><td><code id="TYPEMATCH_+3A_analysis">analysis</code></td>
<td>

<p>Analyzed utterance in which verb and participants have been identified
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typematch is only necessary if explicit markers and/or grammar are not sufficiently informative
</p>


<h3>Value</h3>

<p>Analysis with event-role assignment (if possible on the basis of role qualifications)
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Aristar, A. R. 1997. &quot;Marking and hierarchy. Types and the grammaticalization of case markers&quot;. Studies in Language 21:2.313-368.
</p>


<h3>See Also</h3>

<p><code>PROTOINTERPRETATION</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
utterance=PRODUCE(1, proposition)
analysis=ANALYZE(2, utterance, situation)
TYPEMATCH(2, analysis)
</code></pre>

<hr>
<h2 id='VERBFINAL'>
Put verb final
</h2><span id='topic+VERBFINAL'></span>

<h3>Description</h3>

<p>Reorganizes constituents of an utterance such that verb is put in sentence-final position. Only applies if corresponding word-order generalization has been made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VERBFINAL(proposition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VERBFINAL_+3A_proposition">proposition</code></td>
<td>

<p>Proposition of which the constituents are reordered. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Matthew S. Dryer. 2013. Order of Subject, Object and Verb. In: Dryer, Matthew S. &amp; Haspelmath, Martin (eds.) The World Atlas of Language Structures Online. Leipzig: Max Planck Institute for Evolutionary Anthropology. (Available online at http://wals.info/chapter/81, Accessed on 2017-05-24.)  
</p>


<h3>See Also</h3>

<p><code>GENERALIZE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
(proposition=PROPOSITION(1, situation))
VERBFINAL(proposition)
</code></pre>

<hr>
<h2 id='VERBMORPHOLOGY'>
Interpret verbal morphology
</h2><span id='topic+VERBMORPHOLOGY'></span>

<h3>Description</h3>

<p>Determine anaphoric reference of verb markers (either verb adpositions or suffixes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VERBMORPHOLOGY(hearerID, analysis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VERBMORPHOLOGY_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to hearer agent who's developing an analysis
</p>
</td></tr>
<tr><td><code id="VERBMORPHOLOGY_+3A_analysis">analysis</code></td>
<td>

<p>Analysis of utterance (result of <code>ANALYZE</code>) in which roles have to be determined.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If verb marker cannot be resolved anaphorically, it is reinterpret as a deictic argument.
</p>


<h3>Value</h3>

<p>Analysis (dataframe) with resolved reference of verb markers.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade</p>


<h3>See Also</h3>

<p><code>INTERPRET</code>, <code>NOUNMORPHOLOGY</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
proposition$verb$topic=0; if('internal'%in%names(proposition)){proposition$internal$topic=0}
proposition$external$topic=1; proposition$external$recency=10
proposition=TOPICFIRST(1, proposition)
utterance=PRODUCE(1, proposition)
analysis=ANALYZE(2, utterance, situation)
grouping=GROUP(2, analysis)
for(i in 1:length(grouping)){
	if('verbAdposition'%in%grouping[[i]]$role){
		print(VERBMORPHOLOGY(2, grouping[[i]]))	
}	}
</code></pre>

<hr>
<h2 id='VERBS'>
Generate verbal lexicon
</h2><span id='topic+VERBS'></span>

<h3>Description</h3>

<p>Generate verbal lexicon for founding agents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VERBS(n = world$nVerbs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VERBS_+3A_n">n</code></td>
<td>

<p>Number of verbal lexemes
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with randomly generated forms, their meaning representations in terms of sets of numeric vectors (for action, actor role, and undergoer role), and frequency counters.
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>NOUNS</code>, <code>FIRSTSPEAKER</code>, <code>SEMUPDATE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VERBS(10)
</code></pre>

<hr>
<h2 id='VMATCH'>
Compare vectors
</h2><span id='topic+VMATCH'></span>

<h3>Description</h3>

<p>Compare vectors properly taking into account uniform vectors (with same values on all dimensions) and non-specified dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VMATCH(x, y, incomparable = 0, noise=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VMATCH_+3A_x">x</code></td>
<td>

<p>target vector
</p>
</td></tr>
<tr><td><code id="VMATCH_+3A_y">y</code></td>
<td>

<p>vector (numeric or data frame/list) or set of vectors whose similarity to the target is to be determined
</p>
</td></tr>
<tr><td><code id="VMATCH_+3A_incomparable">incomparable</code></td>
<td>

<p>Value to be returned for incomparable vectors, in which all dimension pairs contain underspecified values
</p>
</td></tr>
<tr><td><code id="VMATCH_+3A_noise">noise</code></td>
<td>

<p>logical for addition of noise to outcome (default is TRUE)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Differences between vectors are determined per dimension, weighted (cf. <code>world$weigh</code>), and then averaged. If vectors are not specified for certain target dimensions, this does not count as a mismatch.
</p>


<h3>Value</h3>

<p>numeric
</p>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>See Also</h3>

<p><code>ACTOR</code>, <code>NOUNS</code>, <code>SITUATION</code>, <code>SELECTVERB</code>, <code>SELECTACTOR</code>, <code>SELECTUNDERGOER</code>, <code>PROPOSITION</code>, <code>REFCHECK</code>, <code>TOPICCOPY</code>, <code>GENERALIZE</code>, <code>CHECKSUCCESS</code>, <code>ANALYZE</code>, <code>TYPEMATCH</code>, <code>NOUNMORPHOLOGY</code>, <code>VERBMORPHOLOGY</code>, <code>INTERPRET.INT</code>, <code>SUCCESS</code>, <code>PERSONUPDATE</code>, <code>FUSE</code>, <code>SEMUPDATE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
vectors=head(population[[1]]$nouns[,1:9])
target=vectors[1,]
vectors[2,]=NA
VMATCH(target, vectors)
</code></pre>

<hr>
<h2 id='WORDORDER'>
Use word order for interpretation
</h2><span id='topic+WORDORDER'></span>

<h3>Description</h3>

<p>Use observed word-order tendencies for interpretation of role distribution. E.g., if agents were observed to come first mostly, assign first constituent agent role.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WORDORDER(hearerID, analysis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WORDORDER_+3A_hearerid">hearerID</code></td>
<td>

<p>Pointer to hearer agent 
</p>
</td></tr>
<tr><td><code id="WORDORDER_+3A_analysis">analysis</code></td>
<td>

<p>Analysis of utterance in which roles have to be determined.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To check if word order can be used, Yang's Tolerance principle is used.
</p>


<h3>Value</h3>

<p>a proposition, i.e. a list:
</p>
<table role = "presentation">
<tr><td><code>external</code></td>
<td>
<p>representation of the external argument, possibly including role marking</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>representation of the internal argument, if identified, possibly including role marking</p>
</td></tr>
<tr><td><code>verb</code></td>
<td>
<p>representation of the action argument, possibly including person indexing</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>target event to be described</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sander Lestrade
</p>


<h3>References</h3>

<p>Charles Yang (2016), The price of linguistic productivity. Cambridge, MA: MIT Press.
</p>


<h3>See Also</h3>

<p><code>INTERPRET</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOUND()
situation=SITUATION(1)
proposition=PROPOSITION(1, situation)
utterance=PRODUCE(1, proposition)
analysis=ANALYZE(2, utterance, situation)
WORDORDER(2, analysis)
population[[2]]$wordOrder[2,]$success=999	#makes AUV standard
population[[2]]$wordOrder
WORDORDER(2, analysis)
</code></pre>

<hr>
<h2 id='world'>
Model parameters
</h2><span id='topic+world'></span>

<h3>Description</h3>

<p>Model parameters that hold during the simulation for the entire lineage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("world")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 64
$ nAgents                         : num 2
$ deathAge                        : num 2000
$ procreationAge                  : num 0.55
$ crossover                       : logi TRUE
$ replace                         : logi TRUE
$ weigh                           : logi TRUE
$ distinctions                    : num [1:9] 2 2 2 2 2 9 9 9 9
$ wordLength                      : int [1:3] 8 9 10
$ vowels                          : chr [1:6] &quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; ...
$ consonants                      : chr [1:15] &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; ...
$ nNouns                          : num 499
$ nVerbs                          : num 199
$ proportionIntrans               : num 0.2
$ linkingPreference               : num 5
$ local                           : logi TRUE
$ useCommonGround                 : logi TRUE
$ commonGroundStart               : num 3
$ dahlS                           : num [1:4] 21 10 21 44
$ dahlA                           : num [1:4] 38 22 33 7
$ dahlO                           : num [1:4] 3 3 10 84
$ oddsNewA                        : num 0.0333
$ oddsNewOther                    : num 0.25
$ referenceNoise                  : num 0.2
$ roleNoise                       : num 0.3
$ nEvents                         : int [1:11] 10 11 12 13 14 15 16 17 18 19 ...
$ nTurns                          : int [1:16] 5 6 7 8 9 10 11 12 13 14 ...
$ talkAge                         : num 0.05
$ turnChange                      : num [1:2] 2 1
$ personTopicality                : num [1:4] 2 1 2 2
$ topicContinuity                 : num [1:2] 3 1
$ checkSuccess                    : logi TRUE
$ solutionMethod                  : chr &quot;bestMarker&quot;
$ reductionFrequencyThreshold     : num 0.05
$ reductionCollostructionThreshold: num 3
$ reductionRecencyThreshold       : num 2
$ formSetFrequency                : num 3
$ suffixThreshold                 : num 6
$ refCheck                        : logi TRUE
$ referenceThreshold              : num 4
$ generalization                  : logi TRUE
$ firstInFirstOut                 : logi TRUE
$ distinctiveness                 : num 0.05
$ candidateScoring                : chr &quot;all&quot;
$ frequency                       : chr &quot;relative&quot;
$ activationImpact                : num 0.2
$ collostructionImpact            : num 0.2
$ semanticWeightImpact            : num 0.1
$ economyImpact                   : num 0.1
$ recencyDamper                   : num 5
$ activationNoise                 : num 2
$ functionBlocking                : logi TRUE
$ wordOrder                       : logi TRUE
$ topicCopy                       : logi TRUE
$ semUpdateAge                    : num 0.5
$ erosion                         : logi TRUE
$ erosionMax                      : num 2
$ formBlocking                    : logi TRUE
$ desemanticization               : logi TRUE
$ desemanticizationCeiling        : num 0.4
$ desemanticizationPower          : num 2
$ minimalSpecification            : num 1
$ verbalRoleMarker                : logi FALSE
$ semUpdateThreshold              : num 0.02
$ saveAll                         : logi FALSE
</p>


<h3>Details</h3>

<p><code>nAgents</code>:    number of founding agents
</p>
<p><code>deathAge</code>:    age, in number of utterances, at which agents die
</p>
<p><code>procreationAge</code>:    point at which agents procreate (relative to their death age). If NA, no offspring. Best to procreate after semUpdate;)
</p>
<p><code>crossover</code>:    If true, lexicon of off spring is combination of those of parents. If false, each parent will get a child with identical lexicon 
</p>
<p><code>replace</code>:    Should minor modifications be made to non-used words?
</p>
<p><code>weigh</code>:    In comparing meanings and determining whose the actor, should meaning dimensions be equally important (F) or should first dimension be more important than second, but less important than second plus third, etc. (T). Slows down simulation in combination with high number of events per situation (&gt;10)
</p>
<p>The following set of parameters applies to the lexicon specifically:
</p>
<p><code>distinctions</code>:    dimensionality and distinctionality of meaning representations (distinctions are normalized to 0&ndash;1 range).
</p>
<p><code>wordLength</code>:    initial length of words, can be single valued or range.
</p>
<p><code>vowels</code>:    vowels of alphabet constituting the words
</p>
<p><code>consonants</code>:    consonants of alphabet constituting the words
</p>
<p><code>nNouns</code>:    number of nouns in the lexicon
</p>
<p><code>nVerbs</code>:    number of verbs in the lexicon
</p>
<p><code>proportionIntrans</code>:    proportion of intransitive verbs in both lexicon and events. Probably .5 in real life, but smaller in the interest of argument marking
</p>
<p><code>linkingPreference</code>:    preference of external (internal) predicate role for higher (lower) values (&quot;prominent performers&quot;). linkingPreference is odds of highest against lowest role/value. 1 is no preference.
</p>
<p><code>local</code>:    Do agents have the words/the possibility to refer to themselves?
</p>
<p>The following set of parameters applies to the generation of the situational context, i.e., the set of target and distractor events (cf. Steels).
</p>
<p><code>useCommonGround</code>:    Do speech participants share a common ground or are all words/concepts equally likely and accessible.
</p>
<p><code>commonGroundStart</code>:   number of elements (excluding speech participants) that are present in common ground when conversation starts. Elements are randomly selected from lexicon.
</p>
<p><code>dahlS</code>:    odds for intransitive subject to be 1, 2, 3Animate, and 3Inanimate person respectively (based on Dahl 2000, 45-51)
</p>
<p><code>dahlA</code>:    odds for external role to be 1, 2, 3Animate, and 3Inanimate person. First three numbers are summed if local==F. 
</p>
<p><code>dahlO</code>:    odds for internal role to be 1, 2, 3Animate, and 3Inanimate person. 
</p>
<p><code>oddsNewA</code>:    odds for a non common-ground element to enter as A argument of one of the events in the situation (element will be added to the common ground if discussed; cf. DuBois 1987: 828, Table 7)
</p>
<p><code>oddsNewOther</code>:    odds for a non common-ground element to enter as S or O argument of one of the events in the situation (element will be added to the common ground if discussed)
</p>
<p><code>referenceNoise</code>:    how much &quot;referential&quot; noise is there in the world (0&ndash;1)? The less noise, the closer the world matches the concepts and relations in the language.
</p>
<p><code>roleNoise</code>:    How much noise is there in the world with respect to the event roles that nouns are expected and found to perform. 
</p>
<p><code>nEvents</code>:    Number of events that are ongoing in speech situation, one of which is selected to talk about. If set to 1, no distractor events occur.  
</p>
<p>The following set of parameters applies to the conversations two agents have:
</p>
<p><code>nTurns</code>:    What is the range of communicative turns conversations consist of (before common ground is reset)
</p>
<p><code>talkAge</code>:    At which point (relative to their death age) do agents start to talk? (Until then, they only listen) If zero, less learning from parents
</p>
<p><code>turnChange</code>:    odds for speech-act participants to change speech-act roles
</p>
<p><code>personTopicality</code>:    Preference for speaker, addressee, animate third person, and inanimate third person respectively to be the topic of the utterance and participant in a situation (based on Dahl's S and A numbers)
</p>
<p><code>topicContinuity</code>:    odds for continuing with the same topic vs starting a new one
</p>
<p>The following set of parameters applies to the production process:
</p>
<p><code>checkSuccess</code>:    Should expected recovery of meaning be checked? (cf. Aristar for &quot;typing&quot; scores)
</p>
<p><code>solutionMethod</code>:    If check success shows utterance should be elaborated, how is this done? Options: firstFail, bestMarker, worstPerformer, random, secondArgument, internal, external, both
</p>
<p><code>reductionFrequencyThreshold</code>:    Relative frequency threshold at which forms get reduced. 
</p>
<p><code>reductionCollostructionThreshold</code>:    Absolute collostruction-frequency threshold at which forms get reduced.
</p>
<p><code>reductionRecencyThreshold</code>:    idem for recency
</p>
<p><code>formSetFrequency</code>:    number of times an item has to be used before its form is set, after which its representation will no longer change
</p>
<p><code>suffixThreshold</code>:    productionEffort threshold (in number of characters) at which words markers suffixed to their host
</p>
<p><code>refCheck</code>:    Should referential threshold be reached for words to refer?
</p>
<p><code>referenceThreshold</code>:    production effort (in number of characters)  necessary for an utterance to be sufficiently referential (a la Ariel). If lower, a more expressive expression is added sentence first.
</p>
<p><code>generalization</code>:    Should agents try to derive generalizations from the tendencies they observe? Applies from second generation onwards only (cf. Yang)
</p>
<p><code>firstInFirstOut</code>:    Is utterance production incremental? (cf. Bock and Levelt)
</p>
<p>The following set of parameters applies both to the production and interpretation process:
</p>
<p><code>distinctiveness</code>:    If two forms are similar in meaning (or in role typing in case of global marking), how big should the difference be for the speaker to think the distinction is sufficiently clear?
</p>
<p><code>candidateScoring</code>:    In what order should candidates be considered (first one to suffice is selected): by activation, frequency, match, economy, collostruction, all. 
</p>
<p><code>frequency</code>:    If frequency plays a role, should it do so absolutely or relatively (i.e. frequency as argument, or role or index marker)
</p>
<p><code>activationImpact</code>:    if candidateOrdering=='all', how should (rescaled) activation be weighed with respect to match? Activation is function of frequency and recency. Impact==1: equally, impact below 1: impact times less important, impact above 1: impact times more important.
</p>
<p><code>collostructionImpact</code>:    If candidateOrdering=='all', how should (rescaled) collostruction frequency be weighed with respect to match? Also used by VERBMORPHOLOGY
</p>
<p><code>semanticWeightImpact</code>:    If candidateOrdering=='all', how should semantic weight be weighed with respect to match (given Grice: do not say more than necessary)
</p>
<p><code>economyImpact</code>:    If candidateOrdering=='all', how should economy be weighed with respect to match (given Grice: do not say more than necessary)
</p>
<p><code>recencyDamper</code>:    decreases activation of most recent items [RESCALE(jitter(log((frequency+1)/(recency+1+recencyImpact)), factor=activationNoise))]
</p>
<p><code>activationNoise</code>:    noise factor that is added to activation values of items [RESCALE(jitter(log((frequency+1)/(recency+1+recencyImpact)), factor=activationNoise))]
</p>
<p><code>functionBlocking</code>:    Should frequent usage for some function (argument, role marker, index marker) inhibit other functions? (only applies if frequency==relative). And: should reference to certain person values block others?
</p>
<p><code>wordOrder</code>:    Should agents try to use word-order generalizations to mark/determine roles?
</p>
<p><code>topicCopy</code>:    Should a (pronominal) copy of a reestablished topic be put adjacent to the verb (a la Givon; only applies if topicFirst has been derived)? 
</p>
<p>The following set of parameters applies both to the process of language change
</p>
<p><code>semUpdateAge</code>:    At which point (relative to their death age) do agents update their lexical representations? Should be lower than procreationAge for cultural evolution to apply
</p>
<p><code>erosion</code>:    Should forms erode?
</p>
<p><code>erosionMax</code>:   How short may form representations become in number of characters?
</p>
<p><code>formBlocking</code>:    Should agent refrain from reducing forms if this leads to ambiguity?
</p>
<p><code>desemanticization</code>:    Should forms desemanticize?
</p>
<p><code>desemanticizationCeiling</code>:    proportion of utterances in which an item occurs at which it desemanticizes maximally (.3?)
</p>
<p><code>desemanticizationPower</code>:    Development of thresholds for subsequent dimensions to be removed. 1 for linear development. Best between 1 and 2? The lower, the more difficult to desemanticize, as the threshold develops linearly to the same target (desemanticizationCeiling)
</p>
<p><code>minimalSpecification</code>:    minimum number of dimensions along which referential items have to be specified (in the presence of other candidate expressions for same person). If null, words will be replaced once meaningless
</p>
<p><code>verbalRoleMarker</code>:    Can verb markers be distinctive for role (within person)? Cf. Bhat...
</p>
<p><code>semUpdateThreshold</code>:    proportion of number of utterances in which a construction has to occur before it is fused/lexicalized
</p>
<p>The following parameter is for data management:
</p>
<p><code>saveAll</code>:    Should usageHistory be stored in graveyard?
</p>


<h3>References</h3>

<p>Ariel, M. (1999). The development of person agreement markers: from pronouns to higher accessibility markers. In M. Barlow &amp; S. Kemmer (Eds.), Usage based models of language (pp. 197-260). Stanford: CSLI.
</p>
<p>Aristar, A.R. (1997). Marking and hierarchy. Types and the grammaticalization of case markers. Studies in Language, 21 (2), 313-368.
</p>
<p>Bhat, D.N.S. (2004), Pronouns. Oxford [etc.]: Oxford University Press.
</p>
<p>Croft, W. (2000). Explaining language change: An evolutionary approach. Harlow etc.: Longman.
</p>
<p>Dahl, O. (2000). Egophoricity in discourse and syntax. Functions of Language, 7 (1), 37-77.
</p>
<p>Deacon, T. (1997). The symbolic species. London: Penquin.
</p>
<p>Dowty, D. (1991). Thematic proto-roles and argument selection. Language 67 (3), 547-619.
</p>
<p>Du Bois, J.W. (1987), &quot;The discourse basis of ergativity&quot;. Language 63 (4): 805-855
</p>
<p>Gaerdenfors, P. (2000). Conceptual spaces: The geometry of thought. Cambridge, MA: MIT.
</p>
<p>Givon, T. (1995). Functionalism and grammar. Amsterdam/Philadelphia: John Benjamins.
</p>
<p>Grice, H. P. (1975). Logic and conversation. In P. Cole &amp; J. L. Morgan (Eds.), Syntax and semantics: Speech acts (Vol. 3, pp. 41-58). New York: Academic Press.
</p>
<p>Heine, B. &amp; Kuteva, T. (2007). The genesis of grammar. a reconstruction. Oxford: Oxford University Press.
</p>
<p>Hopper, P. J. (1987). Emergent grammar. In Proceedings of BLS (Vol. 13, pp. 139-157).
</p>
<p>Jackendoff, R. (2002). Foundations of language: Brain, meaning, grammar, evolution. Oxford: Oxford University Press.
</p>
<p>Levelt, W.J.M. (1989). Speaking. From intention to articulation. Cambridge, MA: MIT Press.
</p>
<p>Smith, K. &amp; Kirby, S. (2008). Cultural evolution: Implications for understanding the human language faculty and its evolution. Phil. Trans. R. Soc. B, 363, 3591-3603.
</p>
<p>Steels, L. (1997). Constructing and sharing perceptual distinctions. Machine Learning, ECML-97, 4-13.
</p>
<p>Tomasello, M. (2003). Constructing a language: A usage-based theory of language acquisition. Cambridge, MA: Harvard University Press.
</p>
<p>Van Valin, R. (1999). Generalized semantic roles and the syntax-semantics interface. In F. Corblin, C. Dobrovie-Sorin, &amp; J.-M. Marandin (Eds.), Empirical issues in formal syntax and semantics 2 (pp. 373-389). The Hague: Thesus.
</p>
<p>Yang, Ch. (2016), The price of linguistic productivity. Cambridge, MA: MIT Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>length(world)
head(world, 10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
