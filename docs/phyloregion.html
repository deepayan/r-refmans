<!DOCTYPE html><html><head><title>Help for package phyloregion</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phyloregion}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#africa'><p>Plants of southern Africa</p></a></li>
<li><a href='#arc_labels'><p>Add arc labels to plotted phylogeny</p></a></li>
<li><a href='#beta_core'><p>Taxonomic (non-phylogenetic) beta diversity</p></a></li>
<li><a href='#coldspots'><p>Computes biodiversity coldspots and hotspots</p></a></li>
<li><a href='#collapse_range'><p>Collapse nodes and ranges based on divergence times</p></a></li>
<li><a href='#counts'><p>Phyloregions for functional traits and phylogeny</p></a></li>
<li><a href='#EDGE'><p>Evolutionary Distinctiveness and Global Endangerment</p></a></li>
<li><a href='#evol_distinct'><p>Species' evolutionary distinctiveness</p></a></li>
<li><a href='#fishnet'><p>Create fishnet of regular grids</p></a></li>
<li><a href='#fitgom'><p>Fits Grade of membership models for biogeographic regionalization</p></a></li>
<li><a href='#functional_beta'><p>Functional beta diversity for mixed-type functional traits</p></a></li>
<li><a href='#get_clades'><p>Get descendant nodes of phylogeny at a given time depth</p></a></li>
<li><a href='#hexcols'><p>Generate diverging colors in HCL colour space.</p></a></li>
<li><a href='#indicators'><p>Top driving species in phyloregions</p></a></li>
<li><a href='#long2sparse'><p>Conversion of community data</p></a></li>
<li><a href='#map_trait'><p>Map species' trait values in geographic space</p></a></li>
<li><a href='#match_phylo_comm'><p>Match taxa and in phylogeny and community matrix</p></a></li>
<li><a href='#mean_dist'><p>Mean distance matrix from a set of distance matrices</p></a></li>
<li><a href='#nodepie'><p>Label phylogenetic nodes using pie</p></a></li>
<li><a href='#optimal_phyloregion'><p>Determine optimal number of clusters</p></a></li>
<li><a href='#PD'><p>Phylogenetic diversity</p></a></li>
<li><a href='#PD_ses'><p>Phylogenetic diversity standardized for species richness</p></a></li>
<li><a href='#phylo_endemism'><p>Phylogenetic Endemism</p></a></li>
<li><a href='#phylobeta_core'><p>Phylogenetic beta diversity</p></a></li>
<li><a href='#phylobeta_ses'><p>Phylogenetic beta diversity standardized for species beta diversity</p></a></li>
<li><a href='#phylobuilder'><p>Create a subtree with largest overlap from a species list.</p></a></li>
<li><a href='#phyloregion'><p>Compute phylogenetic regionalization and evolutionary distinctiveness of phyloregions</p></a></li>
<li><a href='#phyloregion-package'><p>Biogeographic regionalization and macroecology</p></a></li>
<li><a href='#plot_pie'><p>Visualize biogeographic patterns using pie charts</p></a></li>
<li><a href='#plot.phyloregion'><p>Visualize biogeographic patterns</p></a></li>
<li><a href='#plot.sparse'><p>Create illustrative sparse matrix</p></a></li>
<li><a href='#random_species'><p>Generate random species distributions in space</p></a></li>
<li><a href='#rast2comm'><p>Convert raw input distribution data to community</p></a></li>
<li><a href='#read.community'><p>Read in sparse community matrices</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#sdm'><p>Species distribution models</p></a></li>
<li><a href='#select_linkage'><p>Cluster algorithm selection and validation</p></a></li>
<li><a href='#selectbylocation'><p>Select polygon features from another layer and adds polygon attributes to layer</p></a></li>
<li><a href='#timeslice'><p>Slice phylogenetic tree at various time depths</p></a></li>
<li><a href='#unifrac'><p>UniFrac distance</p></a></li>
<li><a href='#weighted_endemism'><p>Measure the distribution of narrow-ranged or endemic species.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Biogeographic Regionalization and Macroecology</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Computational infrastructure for biogeography, community ecology,
    and biodiversity conservation (Daru et al. 2020) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13478">doi:10.1111/2041-210X.13478</a>&gt;.
    It is based on the methods described in Daru et al. (2020) &lt;<a href="https://doi.org/10.1038%2Fs41467-020-15921-6">doi:10.1038/s41467-020-15921-6</a>&gt;.
    The original conceptual work is described in Daru et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.tree.2017.08.013">doi:10.1016/j.tree.2017.08.013</a>&gt;
    on patterns and processes of biogeographical regionalization. Additionally, the package
    contains fast and efficient functions to compute more standard conservation measures
    such as phylogenetic diversity, phylogenetic endemism, evolutionary distinctiveness
    and global endangerment, as well as compositional turnover (e.g., beta diversity).</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, phangorn, Matrix, betapart, parallel, methods,
colorspace, igraph, clustMixType, maptpx, terra, vegan,
predicts, smoothr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, knitr, rmarkdown, mapproj, survival, rJava,
phyloseq, V8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/darunabas/phyloregion">https://github.com/darunabas/phyloregion</a>,
<a href="https://phyloregion.com/index.html">https://phyloregion.com/index.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/darunabas/phyloregion/issues">https://github.com/darunabas/phyloregion/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Software</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-26 23:47:36 UTC; bdaru</td>
</tr>
<tr>
<td>Author:</td>
<td>Barnabas H. Daru <a href="https://orcid.org/0000-0002-2115-0257"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Piyal Karunarathne
    <a href="https://orcid.org/0000-0002-1934-145X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Klaus Schliep <a href="https://orcid.org/0000-0003-2941-0161"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Xiaobei Zhao [ctb],
  Albin Sandelin [ctb],
  Luciano Pataro [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Barnabas H. Daru &lt;darunabas@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-15 07:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='africa'>Plants of southern Africa</h2><span id='topic+africa'></span>

<h3>Description</h3>

<p>This dataset consists of a dated phylogeny of the woody plant
species of southern Africa along with their geographical distributions.
The dataset comes from a study that maps tree diversity hotspots in southern Africa
(Daru et al. 2015). The study mapped five types of diversity hotspots including
species richness (SR), phylogenetic diversity (PD), phylogenetic endemism
(PE), species weighted endemism (CWE), and evolutionary distinctiveness and
global endangerment (EDGE). The results revealed large spatial incongruence
between biodiversity indices, resulting in unequal representation of PD,
SR, PE, CWE and EDGE in hotspots and currently protected areas, suggesting
that an integrative approach which considers multiple facets of biodiversity
is needed to maximise the conservation of tree diversity in southern Africa.
Specifically for this package, we arranged the dataset into four components:
&ldquo;comm&rdquo;, &ldquo;polys&rdquo;, &ldquo;phylo&rdquo;, &ldquo;mat&rdquo;, &ldquo;IUCN&rdquo;.
</p>


<h3>Details</h3>


<ul>
<li><p> comm: This is a sparse community composition matrix of each species
presences/absences within 50 × 50 km grid cells. A sparse matrix is a
matrix with a high proportion of zero entries (Duff 1977), of which only
the non-zero entries are stored and used for downstream analysis.
</p>
</li>
<li><p> polys: These are the grid cells covering the geographic extent of
study area. These can be created using the function <code><a href="#topic+fishnet">fishnet</a></code>.
The polys object is of class <code>SpatVector</code> and has a column labeled
&ldquo;grids&rdquo;, with the grid identities.
</p>
</li>
<li><p> phylo: This corresponds to the phylogenetic tree which was
estimated using Bayesian analysis of 1,400 species and 1,633 bp
of chloroplast DNA sequences derived from a combination of  <em>matK</em>
and  <em>rbcLa</em>, assuming an uncorrelated relaxed molecular clock model,
using the program BEAST v.1.7.5 (Drummond &amp; Rambaut, 2007). Branch
lengths were calibrated in millions of years using a Bayesian MCMC
approach by enforcing topological constraints assuming APG III backbone
from Phylomatic v.3 (Webb &amp; Donoghue, 2005) and 18 fossil calibration
points from Bell et al. (2010).
</p>
</li>
<li><p> mat: This is a distance matrix of phylogenetic beta diversity
between all grid cells at the 50 × 50 km scale.
</p>
</li>
<li><p> IUCN: This is a dataframe of IUCN conservation status of each woody
species (LC, NT, VU, EN, CR). This is useful for analysis of Evolutionary
Distinctiveness and Global Endangerment using the function
<code><a href="#topic+EDGE">EDGE</a></code>.
</p>
</li></ul>



<h3>References</h3>

<p>Bell, C.D., Soltis, D.E., &amp; Soltis, P.S. (2010). The age and diversification
of the angiosperms re-revisited. <em>American Journal of Botany</em>
<strong>97</strong>, 1296–1303.
</p>
<p>Daru, B.H., Van der Bank, M. &amp; Davies, T.J. (2015) Spatial incongruence
among hotspots and complementary areas of tree diversity in southern Africa.
<em>Diversity and Distributions</em> <strong>21</strong>, 769-780.
</p>
<p>Drummond, A.J., &amp; Rambaut, A. (2007). BEAST: Bayesian evolutionary analysis
by sampling trees. <em>BMC Evolutionary Biology</em> <strong>7</strong>, 214.
</p>
<p>Duff, I.S. (1977). A survey of sparse matrix research. <em>Proceedings
of the IEEE</em> <strong>65</strong>, 500–535.
</p>
<p>Webb, C.O., &amp; Donoghue, M.J. (2005). Phylomatic: Tree assembly for applied
phylogenetics. <em>Molecular Ecology Notes</em> <strong>5</strong>, 181–183.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
names(africa)

library(terra)
library(ape)
plot(africa$phylo)

</code></pre>

<hr>
<h2 id='arc_labels'>Add arc labels to plotted phylogeny</h2><span id='topic+arc_labels'></span><span id='topic+arc_labels.default'></span>

<h3>Description</h3>

<p>Add arc labels to plotted phylogeny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arc_labels(phy, tips, ...)

## Default S3 method:
arc_labels(
  phy = NULL,
  tips,
  text,
  plot_singletons = TRUE,
  ln.offset = 1.02,
  lab.offset = 1.06,
  cex = 1,
  orientation = "horizontal",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arc_labels_+3A_phy">phy</code></td>
<td>
<p>An object of class phylo.</p>
</td></tr>
<tr><td><code id="arc_labels_+3A_tips">tips</code></td>
<td>
<p>A character vector (or a list) with names of the
tips that belong to the clade or group. If multiple groups are
to be plotted, tips must be given in the form of a list.</p>
</td></tr>
<tr><td><code id="arc_labels_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="arc_labels_+3A_text">text</code></td>
<td>
<p>Desired clade label.</p>
</td></tr>
<tr><td><code id="arc_labels_+3A_plot_singletons">plot_singletons</code></td>
<td>
<p>Logical. If TRUE (default), adds arcs
(and labels) to single tip lineages. If FALSE, no arc or
labels will be plotted over that tip..</p>
</td></tr>
<tr><td><code id="arc_labels_+3A_ln.offset">ln.offset</code></td>
<td>
<p>Line offset (as a function of total tree height)</p>
</td></tr>
<tr><td><code id="arc_labels_+3A_lab.offset">lab.offset</code></td>
<td>
<p>Label offset.</p>
</td></tr>
<tr><td><code id="arc_labels_+3A_cex">cex</code></td>
<td>
<p>Character expansion</p>
</td></tr>
<tr><td><code id="arc_labels_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the text. Can be &ldquo;vertical&rdquo;,
&ldquo;horizontal&rdquo;, or &ldquo;curved&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
old.par &lt;- par(no.readonly = TRUE)
require(ape)
data(africa)
par(mai=rep(0,4))
plot(africa$phylo, type = "fan", show.tip.label=FALSE,
     open.angle = 180, edge.width=0.5)

y &lt;- data.frame(species=africa$phylo$tip.label)
y$genus &lt;- gsub("_.*", "\\1", y$species)

fx &lt;- split(y, f=y$genus)

suppressWarnings(invisible(lapply(fx, function(x) {
  y &lt;- seq(from = 1.03, to = 1.09, by = ((1.09 - 1.03)/(length(fx) - 1)))
  z &lt;- sample(y, 1, replace = FALSE, prob = NULL)
  if(nrow(x) &gt; 10L) arc_labels(phy = africa$phylo, tips=x$species,
                            text=as.character(unique(x$genus)),
                            orientation = "curved", cex=0.5,
                            lab.offset = z)
})))
par(old.par)

</code></pre>

<hr>
<h2 id='beta_core'>Taxonomic (non-phylogenetic) beta diversity</h2><span id='topic+beta_core'></span><span id='topic+beta_diss'></span>

<h3>Description</h3>

<p>Data are assumed to be presence / absence (0 / 1) and all values greater
zero are assumed to reflect presence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_core(x)

beta_diss(x, index.family = "sorensen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_core_+3A_x">x</code></td>
<td>
<p>an object of class Matrix, where rows are sites and columns are
species.</p>
</td></tr>
<tr><td><code id="beta_core_+3A_index.family">index.family</code></td>
<td>
<p>family of dissimilarity indices, partial match of
&quot;sorensen&quot; or &quot;jaccard&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>beta_core</code> is helper function to compute the basic quantities needed
for computing the &quot;sorensen&quot; or &quot;jaccard&quot; index.
</p>


<h3>Value</h3>

<p><code>beta_core</code> returns an object of class <code>beta_diss</code> like the
<code>betapart.core</code> function. This object can be called by
<code>beta.pair</code> or <code>beta.multi</code>.
</p>
<p><code>beta_diss</code> returns a list with three dissimilarity matrices. See
<code>beta.pair</code> for details.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep
</p>


<h3>See Also</h3>

<p><code>betapart.core</code>, <code>betapart</code>,
<code><a href="#topic+phylobeta">phylobeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
x &lt;- africa$comm
bc &lt;- beta_core(x)
beta_sorensen &lt;- beta_diss(x)
</code></pre>

<hr>
<h2 id='coldspots'>Computes biodiversity coldspots and hotspots</h2><span id='topic+coldspots'></span><span id='topic+hotspots'></span>

<h3>Description</h3>

<p><code>coldspots</code> and <code>hotspots</code> map areas or grid cells with lowest
or highest values, respectively, of a biodiversity metric e.g.
species richness, species endemism or degree of threat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coldspots(x, prob = 2.5, na.rm = TRUE, ...)

hotspots(x, prob = 2.5, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coldspots_+3A_x">x</code></td>
<td>
<p>a vector on which to compute coldspots</p>
</td></tr>
<tr><td><code id="coldspots_+3A_prob">prob</code></td>
<td>
<p>The threshold quantile for representing the lowest
(<code>coldspots</code>) or highest (<code>hotspots</code>) proportion of biodiversity in
an area. By default, the threshold is set to <code>prob = 2.5</code> percent.</p>
</td></tr>
<tr><td><code id="coldspots_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if true, any NA and NaN's are removed from x before
the quantiles are computed.</p>
</td></tr>
<tr><td><code id="coldspots_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers of 1s and 0s with 1 corresponding to the
coldspots or hotspots
</p>


<h3>Author(s)</h3>

<p>Barnabas H. Daru <a href="mailto:darunabas@gmail.com">darunabas@gmail.com</a>
</p>


<h3>References</h3>

<p>Myers, M., Mittermeier, R.A., Mittermeier, C.G., da Fonseca, G.A.B. &amp;
Kent, J. (2000) Biodiversity hotspots for conservation priorities.
<em>Nature</em> <strong>403</strong>: 853–858.
</p>
<p>Ceballos, G. &amp; Ehrlich, P.R. (2006) Global mammal distributions, biodiversity
hotspots, and conservation. <em>Proceedings of the National Academy of
Sciences USA</em> <strong>103</strong>: 19374–19379.
</p>
<p>Orme, C.D., Davies, R.G., Burgess, M., Eigenbrod, F., Pickup, N. et al.
(2005) Global hotspots of species richness are not congruent with endemism or
threat. <em>Nature</em> <strong>436</strong>: 1016–1019.
</p>
<p>Daru, B.H., Van der Bank, M. &amp; Davies, T.J. (2015) Spatial incongruence among
hotspots and complementary areas of tree diversity in southern Africa.
<em>Diversity and Distributions</em> <strong>21</strong>: 769-780.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
data(africa)
p &lt;- vect(system.file("ex/sa.json", package = "phyloregion"))

Endm &lt;- weighted_endemism(africa$comm)
C &lt;- coldspots(Endm) # coldspots
H &lt;- hotspots(Endm) # hotspots

## Merge endemism values to shapefile of grid cells.
DF &lt;- data.frame(grids=names(C), cold=C, hot=H)
m &lt;- merge(p, DF, by = "grids", all = TRUE)

plot(p, border = "grey", col = "lightgrey",
     main = "Weighted Endemism Hotspots and Coldspots")
plot(m[(m$cold == 1), ], col = "blue", add = TRUE, border = NA)
plot(m[(m$hot == 1), ], col = "red", add = TRUE, border = NA)
legend("bottomleft", fill = c("blue", "red", "yellow", "green"),
       legend = c("coldspots", "hotspots"), bty = "n", inset = .092)
</code></pre>

<hr>
<h2 id='collapse_range'>Collapse nodes and ranges based on divergence times</h2><span id='topic+collapse_range'></span>

<h3>Description</h3>

<p>This function collapses nodes and geographic ranges based on species'
divergence times at various time depths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_range(
  x,
  tree,
  n,
  species = "species",
  grids = "grids",
  format = "wide"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_range_+3A_x">x</code></td>
<td>
<p>A community matrix or data frame.</p>
</td></tr>
<tr><td><code id="collapse_range_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree.</p>
</td></tr>
<tr><td><code id="collapse_range_+3A_n">n</code></td>
<td>
<p>Time depth to slice the phylogenetic tree (often in millions of
years for dated trees).</p>
</td></tr>
<tr><td><code id="collapse_range_+3A_species">species</code></td>
<td>
<p>If <code>format =</code> &ldquo;long&rdquo; (the default),
the column with the species name.</p>
</td></tr>
<tr><td><code id="collapse_range_+3A_grids">grids</code></td>
<td>
<p>The column with the sites or grids if <code>format =</code>
&ldquo;long&rdquo;.</p>
</td></tr>
<tr><td><code id="collapse_range_+3A_format">format</code></td>
<td>
<p>Format of the community composition data:
&ldquo;long&rdquo; or &ldquo;wide&rdquo; with species as columns and sites as rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two community data frames: the <code>collapsed community data</code> and
<code>original community data</code>
</p>


<h3>References</h3>

<p>Daru, B.H., Farooq, H., Antonelli, A. &amp; Faurby, S. (2020) Endemism
patterns are scale dependent. <em>Nature Communications</em>
<strong>11</strong>: 2115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
tr1 &lt;- read.tree(text ="(((a:2,(b:1,c:1):1):1,d:3):1,e:4);")
com &lt;- matrix(c(1,0,1,1,0,0,
                1,0,0,1,1,0,
                1,1,1,1,1,1,
                1,0,1,1,0,1,
                0,0,0,1,1,0), 6, 5,
              dimnames=list(paste0("g",1:6), tr1$tip.label))

collapse_range(com, tr1, n=1)
</code></pre>

<hr>
<h2 id='counts'>Phyloregions for functional traits and phylogeny</h2><span id='topic+counts'></span>

<h3>Description</h3>

<p>Generates a sparse community matrix as input for clustering regions
based on the similairity of functional traits across species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counts(x, trait, cut = NULL, phy = NULL, bin = 10, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counts_+3A_x">x</code></td>
<td>
<p>A community data in long format with one column representing
sites labeled &ldquo;grids&rdquo; and another column representing species
labeled &ldquo;species&rdquo;.</p>
</td></tr>
<tr><td><code id="counts_+3A_trait">trait</code></td>
<td>
<p>A data frame or matrix object with the first column
labeled &ldquo;species&rdquo; containing the taxonomic groups to be
evaluated whereas the remaining columns have the various functional
traits. The variables must be a mix of numeric and categorical values.</p>
</td></tr>
<tr><td><code id="counts_+3A_cut">cut</code></td>
<td>
<p>The slice time.</p>
</td></tr>
<tr><td><code id="counts_+3A_phy">phy</code></td>
<td>
<p>is a dated phylogenetic tree with branch lengths stored
as a phylo object (as in the ape package).</p>
</td></tr>
<tr><td><code id="counts_+3A_bin">bin</code></td>
<td>
<p>The desired number of clusters or bins.</p>
</td></tr>
<tr><td><code id="counts_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, whether NA values should be removed or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a community data frame that captures the
count of each species based on its cluster membership.
</p>

<hr>
<h2 id='EDGE'>Evolutionary Distinctiveness and Global Endangerment</h2><span id='topic+EDGE'></span>

<h3>Description</h3>

<p>This function calculates EDGE by combining evolutionary distinctiveness
(ED; i.e., phylogenetic isolation of a species) with global endangerment
(GE) status as defined by the International Union for Conservation
of Nature (IUCN).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EDGE(x, phy, Redlist = "Redlist", species = "species", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EDGE_+3A_x">x</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="EDGE_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree (object of class phylo).</p>
</td></tr>
<tr><td><code id="EDGE_+3A_redlist">Redlist</code></td>
<td>
<p>column in the data frame with the IUCN ranks: <code>LC</code>,
<code>NT</code>, <code>VU</code>, <code>EN</code>, <code>CR</code>, and <code>EX</code>.</p>
</td></tr>
<tr><td><code id="EDGE_+3A_species">species</code></td>
<td>
<p>data frame column specifying the taxon</p>
</td></tr>
<tr><td><code id="EDGE_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>EDGE is calculated as: </p>
<p style="text-align: center;"><code class="reqn">log(1+ED) + GE*log(2)</code>
</p>

<p>where <em>ED</em> represents the evolutionary distinctiveness score of each
species (function <code>evol_distinct</code>), i.e. the degree of phylogenetic
isolation, and combining it with <em>GE</em>, global endangerment from IUCN
conservation threat categories. <em>GE</em> is calculated as the expected
probability of extinction over 100 years of each taxon in the phylogeny
(Redding &amp; Mooers, 2006), scaled as follows: least concern = 0.001, near
threatened and conservation dependent = 0.01, vulnerable = 0.1,
endangered = 0.67, and critically endangered = 0.999.
</p>


<h3>Value</h3>

<p>Returns a dataframe of EDGE scores
</p>


<h3>Author(s)</h3>

<p>Barnabas H. Daru
</p>


<h3>References</h3>

<p>Redding, D.W., &amp; Mooers, A.Ø. (2006) Incorporating evolutionary measures
into conservation prioritization. <em>Conservation Biology</em>
<strong>20</strong>: 1670–1678.
</p>
<p>Isaac, N.J., Turvey, S.T., Collen, B., Waterman, C. &amp; Baillie, J.E.
(2007) Mammals on the EDGE: conservation priorities based on threat
and phylogeny. <em>PLoS ONE</em> <strong>2</strong>: e296.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
y &lt;- EDGE(x=africa$IUCN, phy=africa$phylo, Redlist="IUCN", species="Species")
</code></pre>

<hr>
<h2 id='evol_distinct'>Species' evolutionary distinctiveness</h2><span id='topic+evol_distinct'></span>

<h3>Description</h3>

<p>Calculates evolutionary distinctiveness measures for a suite of species by:
a) equal splits (Redding and Mooers 2006)
b) fair proportions (Isaac et al., 2007).
This a new implementation of the picante function <code>evol.distinct</code>
however allowing multifurcations and can be orders of magnitude faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evol_distinct(
  tree,
  type = c("equal.splits", "fair.proportion"),
  scale = FALSE,
  use.branch.lengths = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evol_distinct_+3A_tree">tree</code></td>
<td>
<p>an object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="evol_distinct_+3A_type">type</code></td>
<td>
<p>a) equal splits (Redding and Mooers 2006) or b) fair proportions
(Isaac et al., 2007)</p>
</td></tr>
<tr><td><code id="evol_distinct_+3A_scale">scale</code></td>
<td>
<p>The scale option refers to whether or not the phylogeny should
be scaled to a depth of 1 or, in the case of an ultrametric tree, scaled such
that branch lengths are relative.</p>
</td></tr>
<tr><td><code id="evol_distinct_+3A_use.branch.lengths">use.branch.lengths</code></td>
<td>
<p>If use.branch.lengths=FALSE, then all branch
lengths are changed to 1.</p>
</td></tr>
<tr><td><code id="evol_distinct_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector with species scores.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep
</p>


<h3>References</h3>

<p>Redding, D.W. and Mooers, A.O. (2006). Incorporating evolutionary measures
into conservation prioritisation. <em>Conservation Biology</em>, <strong>20</strong>,
1670&ndash;1678.
</p>
<p>Isaac, N.J.B., Turvey, S.T., Collen, B., Waterman, C. and Baillie, J.E.M.
(2007). Mammals on the EDGE: conservation priorities based on threat and
phylogeny. <em>PLoS ONE</em>, <strong>2</strong>, e296.
</p>


<h3>See Also</h3>

<p><code><a href="picante.html#topic+evol.distinct">evol.distinct</a></code>, <code><a href="#topic+phyloregion">phyloregion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::rcoal(10)
evol_distinct(tree)
evol_distinct(tree, type = "fair.proportion")
</code></pre>

<hr>
<h2 id='fishnet'>Create fishnet of regular grids</h2><span id='topic+fishnet'></span>

<h3>Description</h3>

<p>The <code>fishnet</code> function creates a regular grid of locations covering
the study area at various grain sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishnet(mask, res = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fishnet_+3A_mask">mask</code></td>
<td>
<p>a vector polygon covering the boundary of the survey region.</p>
</td></tr>
<tr><td><code id="fishnet_+3A_res">res</code></td>
<td>
<p>the grain size of the grid cells in decimal degrees (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatial vector polygon object of equal area grid cells covering
the defined area.
</p>


<h3>References</h3>

<p>Phillips, S.J., Anderson, R.P. &amp; Schapire, R.E. (2006) Maximum entropy
modeling of species geographic distributions. <em>Ecological Modelling</em>
<strong>190</strong>: 231-259.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- terra::vect(system.file("ex/nigeria.json", package="phyloregion"))
f &lt;- fishnet(d, res = 0.75)
</code></pre>

<hr>
<h2 id='fitgom'>Fits Grade of membership models for biogeographic regionalization</h2><span id='topic+fitgom'></span>

<h3>Description</h3>

<p>Generates grade of membership, “admixture”, “topic”
or “Latent Dirichlet Allocation” models, by representing sampling units
as partial memberships in multiple groups. It can group regions
based on phylogenetic information or functional traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitgom(
  x,
  trait = NULL,
  cut = NULL,
  phy = NULL,
  bin = 10,
  na.rm = FALSE,
  K,
  shape = NULL,
  initopics = NULL,
  tol = 0.1,
  bf = TRUE,
  kill = 2,
  ord = TRUE,
  verb = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitgom_+3A_x">x</code></td>
<td>
<p>A community data in long format with one column representing
sites labeled &ldquo;grids&rdquo; and another column representing species
labeled &ldquo;species&rdquo;.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_trait">trait</code></td>
<td>
<p>A data frame or matrix object with the first column
labeled &ldquo;species&rdquo; containing the taxonomic groups to be
evaluated whereas the remaining columns have the various functional
traits. The variables must be a mix of numeric and categorical values.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_cut">cut</code></td>
<td>
<p>The slice time for the phylogenetic tree.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_phy">phy</code></td>
<td>
<p>is a dated phylogenetic tree with branch lengths stored
as a phylo object (as in the ape package).</p>
</td></tr>
<tr><td><code id="fitgom_+3A_bin">bin</code></td>
<td>
<p>The desired number of clusters or bins.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, whether NA values should be removed or not.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_k">K</code></td>
<td>
<p>The number of latent topics. If length(K)&gt;1,
topics will find the Bayes factor (vs a null single topic model)
for each element and return parameter estimates for the highest
probability K.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_shape">shape</code></td>
<td>
<p>Optional argument to specify the Dirichlet prior
concentration parameter as shape for topic-phrase probabilities.
Defaults to 1/(K*ncol(counts)). For fixed single K, this can also
be a ncol(counts) by K matrix of unique shapes for each topic element.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_initopics">initopics</code></td>
<td>
<p>Optional start-location for
<code class="reqn">[\theta_1, \ldots, \theta_K]</code>, the
topic-phrase probabilities. Dimensions must accord with the smallest
element of K. If NULL, the initial estimates are built by incrementally
adding topics.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_tol">tol</code></td>
<td>
<p>An indicator for whether or not to calculate the Bayes factor
for univariate K. If length(K)&gt;1, this is ignored and Bayes factors are
always calculated.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_bf">bf</code></td>
<td>
<p>An indicator for whether or not to calculate the Bayes factor
for univariate K. If length(K)&gt;1, this is ignored and Bayes factors are
always calculated.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_kill">kill</code></td>
<td>
<p>For choosing from multiple K numbers of topics (evaluated
in increasing order), the search will stop after kill consecutive drops
in the corresponding Bayes factor. Specify kill=0 if you want Bayes factors
for all elements of K.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_ord">ord</code></td>
<td>
<p>If <code>TRUE</code>, the returned topics (columns of theta) will
be ordered by decreasing usage (i.e., by decreasing <code>colSums(omega)</code>).</p>
</td></tr>
<tr><td><code id="fitgom_+3A_verb">verb</code></td>
<td>
<p>A switch for controlling printed output. verb &gt; 0 will
print something, with the level of detail increasing with verb.</p>
</td></tr>
<tr><td><code id="fitgom_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mapping phylogenetic regions (phyloregions) involves successively slicing
the phylogenetic tree at various time depths (e.g., from 1, 2, 3, 4, to 5
million years ago (Ma)), collapsing nodes and ranges that originated at
each time depth, and generating a new community matrix based on the presence
or absence of each lineage in a grid cell. A grade of membership model is
then fitted to the reduced community matrix. To map functional trait regions
(traitregions), the function uses k-means to cluster species based on their
functional traits, often for mixed-type data including categorical and
numeric functional traits. The ranges for each species in each resulting
cluster are collapsed to generate a new community matrix based on the
presence or absence of cluster representative in a grid cell. A grade of
membership model is then fitted to the new reduced community matrix. Mapping
bioregions for taxonomic diversity is based on fitting a grade of
membership model directly to the original community matrix that is often
represented with species in the columns and sites as rows.
</p>


<h3>Value</h3>

<p>An topics object list with entries
</p>

<ul>
<li> <p><code>K</code> The number of latent topics estimated. If input
<code>length(K)&gt;1</code>, on output this is a single value corresponding to
the model with the highest Bayes factor.
</p>
</li>
<li> <p><code>theta</code> The ncolcounts by K matrix of estimated
topic-phrase probabilities.
</p>
</li>
<li> <p><code>omega</code> The nrowcounts by K matrix of estimated
document-topic weights.
</p>
</li>
<li> <p><code>BF</code> The log Bayes factor for each number of topics
in the input K, against a null single topic model.
</p>
</li>
<li> <p><code>D</code> Residual dispersion: for each element of K, estimated
dispersion parameter (which should be near one for the multinomial),
degrees of freedom, and p-value for a test of whether the true dispersion
is &gt;1.
</p>
</li>
<li> <p><code>X</code> The input community matrix as a sparse matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
data(africa)
names(africa)
p &lt;- vect(system.file("ex/sa.json", package = "phyloregion"))
m &lt;- fitgom(x=sparse2long(africa$comm), K=3)

COLRS &lt;- phyloregion:::hue(m$K)
plot_pie(m$omega, pol = p, col=COLRS)
</code></pre>

<hr>
<h2 id='functional_beta'>Functional beta diversity for mixed-type functional traits</h2><span id='topic+functional_beta'></span>

<h3>Description</h3>

<p>Computes turnover of functional diversity using k-prototypes clustering
algorithm tailored for mixed-type functional traits (numeric and
categorical) to generate an integer vector of cluster assignments. The
ranges of each species in a cluster are collapsed to generate a new
community matrix based on the presence or absence of cluster membership
in a grid cell. A grade of membership model or beta diversity is then fitted
to the new reduced community matrix for further analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional_beta(
  x,
  trait = NULL,
  bin = 10,
  na.rm = "no",
  quick_elbow = FALSE,
  abundance = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="functional_beta_+3A_x">x</code></td>
<td>
<p>A dataframe or sparse community matrix of species occurrences.</p>
</td></tr>
<tr><td><code id="functional_beta_+3A_trait">trait</code></td>
<td>
<p>A data frame with the first column labeled &ldquo;species&rdquo;
containing the taxonomic groups to be evaluated whereas the remaining
columns contain the various functional traits. The variables should be
mixed-type combining numeric and categorical variables.</p>
</td></tr>
<tr><td><code id="functional_beta_+3A_bin">bin</code></td>
<td>
<p>The desired number of clusters or bins. If <code>elbow=TRUE</code>,
the optimal number of clusters is determined by running the analysis
multiple times varying from 2 to bin.</p>
</td></tr>
<tr><td><code id="functional_beta_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, whether NA values should be removed prior to
computation</p>
</td></tr>
<tr><td><code id="functional_beta_+3A_quick_elbow">quick_elbow</code></td>
<td>
<p>Quickly estimate the 'elbow' of a scree plot to determine
the optimal number of clusters.</p>
</td></tr>
<tr><td><code id="functional_beta_+3A_abundance">abundance</code></td>
<td>
<p>Logical, whether the reduced matrix should be returned as
presence or absence of cluster representation or as abundances of cluster
memberships</p>
</td></tr>
<tr><td><code id="functional_beta_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three dissimilarity matrices capturing: (i) turnover
(replacement), (ii) nestedness-resultant component, and (iii) total
dissimilarity (i.e. the sum of both components).
</p>
<p>For index.family=&quot;sorensen&quot;
the three matrices are:
</p>

<ul>
<li> <p><code>beta.sim</code> A distance object, dissimilarity matrix accounting
for spatial turnover (replacement), measured as Simpson pair-wise
dissimilarity.
</p>
</li>
<li> <p><code>beta.sne</code> <code>dist</code> object, dissimilarity matrix accounting for
nestedness-resultant dissimilarity, measured as the nestedness-fraction
of Sorensen pair-wise dissimilarity
</p>
</li>
<li> <p><code>beta.sor</code> <code>dist</code> object, dissimilarity matrix accounting
for total dissimilarity, measured as Sorensen pair-wise dissimilarity
(a monotonic transformation of beta diversity)
</p>
</li></ul>

<p>For index.family=&quot;jaccard&quot; the three matrices are:
</p>

<ul>
<li> <p><code>beta.jtu</code> A distance object, dissimilarity matrix accounting
for spatial turnover, measured as the turnover-fraction of Jaccard
pair-wise dissimilarity
</p>
</li>
<li> <p><code>beta.jne</code> <code>dist</code> object, dissimilarity matrix accounting
for nestedness-resultant dissimilarity, measured as the
nestedness-fraction of Jaccard pair-wise dissimilarity
</p>
</li>
<li> <p><code>beta.jac</code> <code>dist</code> object, dissimilarity matrix accounting
for beta diversity, measured as Jaccard pair-wise dissimilarity (a
monotonic transformation of beta diversity)
</p>
</li></ul>



<h3>References</h3>

<p>Szepannek, G. (2018) clustMixType: User-friendly clustering of mixed-type
data in R. <em>The R Journal</em>, <strong>10</strong>: 200-208.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
data(africa)
p &lt;- vect(system.file("ex/sa.json", package = "phyloregion"))
fb &lt;- functional_beta(x=africa$comm, trait = africa$trait)
p &lt;- phyloregion(fb[[1]], pol = p)
plot(p)

</code></pre>

<hr>
<h2 id='get_clades'>Get descendant nodes of phylogeny at a given time depth</h2><span id='topic+get_clades'></span>

<h3>Description</h3>

<p><code>get_clades</code> returns the tips that descend from a given node or time
depth on a dated phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clades(tree, cut = NULL, k = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_clades_+3A_tree">tree</code></td>
<td>
<p>is a dated phylogenetic tree with branch lengths stored
as a phylo object (as in the <code>ape</code> package).</p>
</td></tr>
<tr><td><code id="get_clades_+3A_cut">cut</code></td>
<td>
<p>the slice time</p>
</td></tr>
<tr><td><code id="get_clades_+3A_k">k</code></td>
<td>
<p>number of slices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of descendants
</p>


<h3>References</h3>

<p>Schliep, K.P. (2010) phangorn: phylogenetic analysis in
R. <em>Bioinformatics</em> <strong>27</strong>: 592–593.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ape)
data(bird.orders)
plot(bird.orders)
axisPhylo(side = 1)
abline(v=28-23) # the root is here at 28
get_clades(bird.orders, 23)
</code></pre>

<hr>
<h2 id='hexcols'>Generate diverging colors in HCL colour space.</h2><span id='topic+hexcols'></span>

<h3>Description</h3>

<p>A function to generate colors in Hue-Chroma-Luminance colour scheme for
mapping phyloregions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexcols(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hexcols_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A range of discrete colors differentiating between phyloregions in
terms of their shared relationships.
</p>


<h3>Author(s)</h3>

<p>Barnabas H. Daru <a href="mailto:darunabas@gmail.com">darunabas@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune)
c1 &lt;- metaMDS(dune, trace = 0)
hexcols(c1)
plot(c1$points, pch = 21, cex = 7, bg = hexcols(c1), las = 1)
</code></pre>

<hr>
<h2 id='indicators'>Top driving species in phyloregions</h2><span id='topic+indicators'></span>

<h3>Description</h3>

<p>This function applies a KL-divergence approach to a list of indicator
species in phyloregions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indicators(
  theta,
  top_indicators = 5,
  method = c("poisson", "bernoulli"),
  options = c("min", "max"),
  shared = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indicators_+3A_theta">theta</code></td>
<td>
<p>A matrix or data.frame of cluster probability distributions
from a topics modeling.</p>
</td></tr>
<tr><td><code id="indicators_+3A_top_indicators">top_indicators</code></td>
<td>
<p>Integer to obtain the top driving species in
clusters.</p>
</td></tr>
<tr><td><code id="indicators_+3A_method">method</code></td>
<td>
<p>The model assumption for KL divergence measurement.
Available choices are &quot;poisson&quot; (default) and &quot;bernoulli&quot;.</p>
</td></tr>
<tr><td><code id="indicators_+3A_options">options</code></td>
<td>
<p>Option &quot;min&quot; selects species that maximize the minimum
KL divergence of a phyloregion vs all other phyloregions.
Option &quot;max&quot; selects species that maximize the maximum KL divergence
of a phyloregion against all other phyloregions.</p>
</td></tr>
<tr><td><code id="indicators_+3A_shared">shared</code></td>
<td>
<p>Logical if TRUE, lists top species driving patterns
in more than one phyloregion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of top indicator species and their indicator values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
indsp &lt;- indicators(africa$theta, top_indicators = 5,
                    options = "max", method = "poisson")
</code></pre>

<hr>
<h2 id='long2sparse'>Conversion of community data</h2><span id='topic+long2sparse'></span><span id='topic+sparse2long'></span><span id='topic+dense2sparse'></span><span id='topic+sparse2dense'></span><span id='topic+long2dense'></span><span id='topic+dense2long'></span>

<h3>Description</h3>

<p>These functions convert a community data to compressed sparse matrix,
dense matrix and long format (e.g. species records).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long2sparse(x, grids = "grids", species = "species")

sparse2long(x)

dense2sparse(x)

sparse2dense(x)

long2dense(x)

dense2long(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="long2sparse_+3A_x">x</code></td>
<td>
<p>A community data which one wants to transform</p>
</td></tr>
<tr><td><code id="long2sparse_+3A_grids">grids</code></td>
<td>
<p>column name of the column containing grid cells</p>
</td></tr>
<tr><td><code id="long2sparse_+3A_species">species</code></td>
<td>
<p>column name of the column containing  the species / taxa names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compressed sparse community matrix of sites by species
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
africa$comm[1:5, 1:20]
long &lt;- sparse2long(africa$comm)
long[1:5, ]
sparse &lt;- long2sparse(long)
all.equal(africa$comm, sparse)

dense_comm &lt;- matrix(c(1,0,1,1,0,0,
                1,0,0,1,1,0,
                1,1,1,1,1,1,
                0,0,1,1,0,1), 6, 4,
              dimnames=list(paste0("g",1:6), paste0("sp", 1:4)))
dense_comm
sparse_comm &lt;- dense2sparse(dense_comm)
sparse_comm
sparse2long(sparse_comm)

</code></pre>

<hr>
<h2 id='map_trait'>Map species' trait values in geographic space</h2><span id='topic+map_trait'></span>

<h3>Description</h3>

<p><code>map_trait</code> add species trait values to species distribution
in geographic space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_trait(x, trait, FUN = sum, pol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_trait_+3A_x">x</code></td>
<td>
<p>A community data object - a vector (with names matching trait data)
or a data.frame or matrix (with column names matching names in trait data)</p>
</td></tr>
<tr><td><code id="map_trait_+3A_trait">trait</code></td>
<td>
<p>A data.frame of species traits with a column of species names
matching species names in the community data, and another column with
the trait values.</p>
</td></tr>
<tr><td><code id="map_trait_+3A_fun">FUN</code></td>
<td>
<p>The function used to aggregate species trait values
in geographic space. By default, if <code>FUN = sum</code>, the sum of
all species traits per area  or grid cell is calculated.</p>
</td></tr>
<tr><td><code id="map_trait_+3A_pol">pol</code></td>
<td>
<p>a vector polygon of grid cells.</p>
</td></tr>
<tr><td><code id="map_trait_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of species traits by site.
</p>


<h3>Author(s)</h3>

<p>Barnabas H. Daru <a href="mailto:darunabas@gmail.com">darunabas@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
library(terra)
p &lt;- vect(system.file("ex/sa.json", package = "phyloregion"))
x &lt;- EDGE(africa$IUCN, africa$phylo, Redlist = "IUCN",
          species = "Species")
y &lt;- map_trait(africa$comm, x, FUN = sd, pol = p)

plot(y, "traits", col = hcl.colors(n=20, palette = "Blue-Red 3", rev=FALSE))
</code></pre>

<hr>
<h2 id='match_phylo_comm'>Match taxa and in phylogeny and community matrix</h2><span id='topic+match_phylo_comm'></span>

<h3>Description</h3>

<p>match_phylo_comm compares taxa (species, labels, tips) present in a phylogeny
with a community matrix. Pruning, sorting and trying to add missing species
on genus level if possible to match in subsequent analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_phylo_comm(phy, comm, delete_empty_rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_phylo_comm_+3A_phy">phy</code></td>
<td>
<p>A phylogeny</p>
</td></tr>
<tr><td><code id="match_phylo_comm_+3A_comm">comm</code></td>
<td>
<p>A (sparse) community data matrix</p>
</td></tr>
<tr><td><code id="match_phylo_comm_+3A_delete_empty_rows">delete_empty_rows</code></td>
<td>
<p>delete rows with no observation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the function of the same name in picante but allows sparse matrices
and with taxa addition.
</p>


<h3>Value</h3>

<p>A list containing the following elements, pruned and sorted to match one another:
</p>
<table>
<tr><td><code>phy</code></td>
<td>
<p>A phylogeny object of class phylo</p>
</td></tr>
<tr><td><code>comm</code></td>
<td>
<p>A (sparse) community data matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
tree &lt;- africa$phylo
x &lt;- africa$comm

subphy &lt;- match_phylo_comm(tree, x)$phy
submat &lt;- match_phylo_comm(tree, x)$com
</code></pre>

<hr>
<h2 id='mean_dist'>Mean distance matrix from a set of distance matrices</h2><span id='topic+mean_dist'></span>

<h3>Description</h3>

<p>This function generates the mean pairwise distance matrix from a set
many pairwise distance matrices. Note: all matrices should be of the same dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_dist(files, trace = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_dist_+3A_files">files</code></td>
<td>
<p>list of pairwise distance matrices stored as CSVs or .rds
with the same dimensions.</p>
</td></tr>
<tr><td><code id="mean_dist_+3A_trace">trace</code></td>
<td>
<p>Trace the function; trace = 2 or higher will be more voluminous.</p>
</td></tr>
<tr><td><code id="mean_dist_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>average distance matrix
</p>

<hr>
<h2 id='nodepie'>Label phylogenetic nodes using pie</h2><span id='topic+nodepie'></span>

<h3>Description</h3>

<p>Label phylogenetic nodes using pie
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodepie(
  pie,
  radius = 2,
  pie_control = list(),
  legend = FALSE,
  col = hcl.colors(5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodepie_+3A_pie">pie</code></td>
<td>
<p>Estimates from ancestral character reconstruction</p>
</td></tr>
<tr><td><code id="nodepie_+3A_radius">radius</code></td>
<td>
<p>Radius of the pie</p>
</td></tr>
<tr><td><code id="nodepie_+3A_pie_control">pie_control</code></td>
<td>
<p>The list of control parameters to be passed into
the add.pie function.</p>
</td></tr>
<tr><td><code id="nodepie_+3A_legend">legend</code></td>
<td>
<p>Logical, whether to add a legend or not.</p>
</td></tr>
<tr><td><code id="nodepie_+3A_col">col</code></td>
<td>
<p>List of colors for the pies.</p>
</td></tr>
<tr><td><code id="nodepie_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no value, just add color pies on phylogenetic nodes!
</p>

<hr>
<h2 id='optimal_phyloregion'>Determine optimal number of clusters</h2><span id='topic+optimal_phyloregion'></span>

<h3>Description</h3>

<p>This function divides the hierarchical dendrogram into meaningful
clusters (&quot;phyloregions&quot;), based on the ‘elbow’ or ‘knee’ of
an evaluation graph that corresponds to the point of optimal curvature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal_phyloregion(x, method = "average", k = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal_phyloregion_+3A_x">x</code></td>
<td>
<p>a numeric matrix, data frame or &ldquo;dist&rdquo; object.</p>
</td></tr>
<tr><td><code id="optimal_phyloregion_+3A_method">method</code></td>
<td>
<p>the agglomeration method to be used. This should
be (an unambiguous abbreviation of) one of &ldquo;ward.D&rdquo;, &ldquo;ward.D2&rdquo;,
&ldquo;single&rdquo;, &ldquo;complete&rdquo;, &ldquo;average&rdquo; (= UPGMA),
&ldquo;mcquitty&rdquo; (= WPGMA),
&ldquo;median&rdquo; (= WPGMC) or &ldquo;centroid&rdquo; (= UPGMC).</p>
</td></tr>
<tr><td><code id="optimal_phyloregion_+3A_k">k</code></td>
<td>
<p>numeric, the upper bound of the number of clusters to
compute. DEFAULT: 20 or the number of observations (if less than 20).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following as returned from the GMD
package (Zhao et al. 2011):
</p>

<ul>
<li> <p><code>k</code>:	optimal number of clusters (bioregions)
</p>
</li>
<li> <p><code>totbss</code>:	total between-cluster sum-of-square
</p>
</li>
<li> <p><code>tss</code>:	total sum of squares of the data
</p>
</li>
<li> <p><code>ev</code>:	explained variance given k
</p>
</li></ul>



<h3>References</h3>

<p>Salvador, S. &amp; Chan, P. (2004) <em>Determining the number of
clusters/segments in hierarchical clustering/segmentation algorithms</em>.
Proceedings of the Sixteenth IEEE International Conference on Tools
with Artificial Intelligence, pp. 576–584. Institute of Electrical
and Electronics Engineers, Piscataway, New Jersey, USA.
</p>
<p>Zhao, X., Valen, E., Parker, B.J. &amp; Sandelin, A. (2011) Systematic
clustering of transcription start site landscapes.
<em>PLoS ONE</em> <strong>6</strong>: e23409.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
tree &lt;- africa$phylo
bc &lt;- beta_diss(africa$comm)
(d &lt;- optimal_phyloregion(bc[[1]], k=15))
plot(d$df$k, d$df$ev, ylab = "Explained variances",
  xlab = "Number of clusters")
lines(d$df$k[order(d$df$k)], d$df$ev[order(d$df$k)], pch = 1)
points(d$optimal$k, d$optimal$ev, pch = 21, bg = "red", cex = 3)
points(d$optimal$k, d$optimal$ev, pch = 21, bg = "red", type = "h")
</code></pre>

<hr>
<h2 id='PD'>Phylogenetic diversity</h2><span id='topic+PD'></span>

<h3>Description</h3>

<p><code>PD</code> calculates Faith's (1992) phylogenetic diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PD(x, phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PD_+3A_x">x</code></td>
<td>
<p>a community matrix, i.e. an object of class matrix or Matrix or an
object of class phyloseq.</p>
</td></tr>
<tr><td><code id="PD_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree (object of class phylo).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the PD for all samples.
</p>


<h3>References</h3>

<p>Faith, D.P. (1992) Conservation evaluation and phylogenetic diversity.
<em>Biological Conservation</em> <strong>61</strong>: 1–10.
</p>


<h3>See Also</h3>

<p>read.community read.tree phylobeta_core
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
library(Matrix)
tree &lt;- read.tree(text ="((t1:1,t2:1)N2:1,(t3:1,t4:1)N3:1)N1;")
com &lt;- sparseMatrix(c(1,3,4,1,4,5,1,2,3,4,5,6,3,4,6),
  c(1,1,1,2,2,2,3,3,3,3,3,3,4,4,4),x=1,
  dimnames = list(paste0("g", 1:6), tree$tip.label))

PD(com, tree)
</code></pre>

<hr>
<h2 id='PD_ses'>Phylogenetic diversity standardized for species richness</h2><span id='topic+PD_ses'></span>

<h3>Description</h3>

<p>This function computes the standard effect size of PD by correcting for
changes in species richness. The novelty of this function is its ability
to utilize sparse community matrix making it possible to
efficiently randomize very large community matrices spanning thousands of
taxa and sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PD_ses(
  x,
  phy,
  model = c("tipshuffle", "rowwise", "colwise"),
  reps = 10,
  metric = "pd",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PD_ses_+3A_x">x</code></td>
<td>
<p>a (sparse) community matrix, i.e. an object of class matrix or
Matrix.</p>
</td></tr>
<tr><td><code id="PD_ses_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree (object of class phylo).</p>
</td></tr>
<tr><td><code id="PD_ses_+3A_model">model</code></td>
<td>
<p>The null model for separating patterns from processes and
for contrasting against alternative hypotheses. Available null models
include:
</p>

<ul>
<li> <p>&ldquo;tipshuffle&rdquo;: shuffles tip labels multiple times.
</p>
</li>
<li> <p>&ldquo;rowwise&rdquo;: shuffles sites (i.e., varying richness) and
keeping species occurrence frequency constant.
</p>
</li>
<li> <p>&ldquo;colwise&rdquo;: shuffles species occurrence frequency and
keeping site richness constant.</p>
</li></ul>
</td></tr>
<tr><td><code id="PD_ses_+3A_reps">reps</code></td>
<td>
<p>Number of replications.</p>
</td></tr>
<tr><td><code id="PD_ses_+3A_metric">metric</code></td>
<td>
<p>The phylodiversity measure to compute.</p>
</td></tr>
<tr><td><code id="PD_ses_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of results for each community or grid cell
</p>

<ul>
<li><p> grids: Site identity
</p>
</li>
<li><p> richness: Number of taxa in community
</p>
</li>
<li><p> pd_obs: Observed PD in community
</p>
</li>
<li><p> pd_rand.mean: Mean PD in null communities
</p>
</li>
<li><p> pd_rand.sd: Standard deviation of PD in null communities
</p>
</li>
<li><p> pd_obs.rank: Rank of observed PD vs. null communities
</p>
</li>
<li><p> pd_obs.z: Standardized effect size of PD vs. null communities
<code class="reqn">= (pd_obs - pd_rand.mean) / pd_rand_sd</code>
</p>
</li>
<li><p> pvalue: P-value (quantile) of observed PD vs. null communities
<code class="reqn">= mpd_obs_rank / iter + 1</code>
</p>
</li>
<li><p> reps: Number of replicates
</p>
</li>
<li><p> p_obs_c_lower: Number of times observed value &lt; random value
</p>
</li>
<li><p> p_obs_c_upper: Number of times observed value &gt; random value
</p>
</li>
<li><p> p_obs_p_lower: Percentage of times observed value &lt; random value
</p>
</li>
<li><p> p_obs_p_upper: Percentage of times observed value &gt; random value
</p>
</li>
<li><p> p_obs_q: Number of the non-NA random values used for comparison
</p>
</li></ul>



<h3>References</h3>

<p>Proches, S., Wilson, J.R.U. &amp; Cowling, R.M. (2006) How much evolutionary
history in a 10 x 10m plot? <em>Proceedings of Royal Society B</em>
<strong>273</strong>: 1143-1148.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
library(Matrix)
tree &lt;- read.tree(text ="((t1:1,t2:1)N2:1,(t3:1,t4:1)N3:1)N1;")
com &lt;- sparseMatrix(c(1,3,4,1,4,5,1,2,3,4,5,6,3,4,6),
  c(1,1,1,2,2,2,3,3,3,3,3,3,4,4,4),x=1,
  dimnames = list(paste0("g", 1:6), tree$tip.label))

PD_ses(com, tree, model="rowwise")

</code></pre>

<hr>
<h2 id='phylo_endemism'>Phylogenetic Endemism</h2><span id='topic+phylo_endemism'></span>

<h3>Description</h3>

<p>Calculates phylogenetic endemism (sum of 'unique' branch lengths) of multiple
ecological samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_endemism(x, phy, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_endemism_+3A_x">x</code></td>
<td>
<p>is the community data given as a data.frame or matrix with
species/OTUs as columns and samples/sites as rows (like in the vegan
package). Columns are labeled with the names of the species/OTUs. Rows are
labelled with the names of the samples/sites. Data can be either abundance or
incidence (0/1). Column labels must match tip labels in the phylogenetic tree
exactly!</p>
</td></tr>
<tr><td><code id="phylo_endemism_+3A_phy">phy</code></td>
<td>
<p>a (rooted) phylogenetic tree (phylo) with branch lengths</p>
</td></tr>
<tr><td><code id="phylo_endemism_+3A_weighted">weighted</code></td>
<td>
<p>is a logical indicating whether weighted endemism (default)
or strict endemism should be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a community data table and a (rooted) phylogenetic tree (with branch
lengths) and calculates either strict or weighted endemism in Phylogenetic
Diversity (PD). Strict endemism equates to the total amount of branch length
found only in the sample/s and is described by Faith et al. (2004) as
PD-endemism. Weighted endemism calculates the &quot;spatial uniqueness&quot; of each
branch in the tree by taking the reciprocal of its range, multiplying by
branch length and summing for all branch lengths present at a sample/site.
Range is calculated simply as the total number of samples/sites at which the
branch is present. This latter approach is described by Rosauer et al. (2009)
as Phylogenetic endemism.
</p>


<h3>Value</h3>

<p><code>phylo_endemism</code> returns a vector of phylogenetic endemism for
each sample or site.
</p>


<h3>References</h3>

<p>Faith, D.P., Reid, C.A.M. &amp; Hunter, J. (2004) Integrating phylogenetic
diversity, complementarity, and endemism for conservation assessment.
<em>Conservation Biology</em> <strong>18</strong>(1): 255-261.
</p>
<p>Rosauer, D., Laffan, S.W., Crisp, M.D., Donnellan, C. &amp; Cook, L.G. (2009).
Phylogenetic endemism: a new approach for identifying geographical
concentrations of evolutionary history. <em>Molecular Ecology</em>
<strong>18</strong>(19): 4061-4072.
</p>
<p>Daru, B.H., Farooq, H., Antonelli, A. &amp; Faurby, S. (2020) Endemism
patterns are scale dependent. <em>Nature Communications</em> <strong>11</strong>
: 2115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
pe &lt;- phylo_endemism(africa$comm, africa$phylo)
plot(density(pe))
</code></pre>

<hr>
<h2 id='phylobeta_core'>Phylogenetic beta diversity</h2><span id='topic+phylobeta_core'></span><span id='topic+phylobeta'></span>

<h3>Description</h3>

<p><code>phylobeta_core</code> computes efficiently for large community matrices and
trees the necessary quantities used by the betapart package to compute
pairwise and multiple-site phylogenetic dissimilarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylobeta_core(x, phy)

phylobeta(x, phy, index.family = "sorensen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylobeta_core_+3A_x">x</code></td>
<td>
<p>an object of class Matrix, matrix or phyloseq</p>
</td></tr>
<tr><td><code id="phylobeta_core_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree (object of class phylo)</p>
</td></tr>
<tr><td><code id="phylobeta_core_+3A_index.family">index.family</code></td>
<td>
<p>family of dissimilarity indices, partial match of
&quot;sorensen&quot; or &quot;jaccard&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phylobeta_core</code> returns an object of class &quot;phylo.betapart&quot;,
see <code>phylo.betapart.core</code> for details. This object can be called
by <code>phylo.beta.pair</code> or <code>phylo.beta.multi</code>.
</p>
<p><code>phylobeta</code> returns a list with three phylogenetic dissimilarity
matrices. See <code>phylo.beta.pair</code> for details.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.community">read.community</a></code>, <code>phylo.betapart.core</code>,
<code><a href="#topic+beta_core">beta_core</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
tree &lt;- read.tree(text = "((t1:1,t2:1)N2:1,(t3:1,t4:1)N3:1)N1;")
com &lt;- sparseMatrix(c(1,3,4,1,4,5,1,2,3,4,5,6,3,4,6),
  c(1,1,1,2,2,2,3,3,3,3,3,3,4,4,4),x=1,
  dimnames = list(paste0("g", 1:6), tree$tip.label))
com

pbc &lt;- phylobeta_core(com, tree)
pb &lt;- phylobeta(com, tree)
</code></pre>

<hr>
<h2 id='phylobeta_ses'>Phylogenetic beta diversity standardized for species beta diversity</h2><span id='topic+phylobeta_ses'></span>

<h3>Description</h3>

<p>This function computes the standard effect size of phylogenetic beta
diversity by correcting for changes in species beta diversity. The
novelty of this function is its ability to utilize sparse community
matrix making it possible to efficiently randomize very large
community matrices spanning thousands of taxa and sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylobeta_ses(
  x,
  phy,
  index.family = "simpson",
  model = c("tipshuffle", "rowwise", "colwise"),
  reps = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylobeta_ses_+3A_x">x</code></td>
<td>
<p>a (sparse) community matrix, i.e., an object of class
matrix or Matrix.</p>
</td></tr>
<tr><td><code id="phylobeta_ses_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree (object of class phylo).</p>
</td></tr>
<tr><td><code id="phylobeta_ses_+3A_index.family">index.family</code></td>
<td>
<p>the family of dissimilarity indices including
&ldquo;simpson&rdquo;, &ldquo;sorensen&rdquo; and &ldquo;jaccard&rdquo;.</p>
</td></tr>
<tr><td><code id="phylobeta_ses_+3A_model">model</code></td>
<td>
<p>The null model for separating patterns from processes and
for contrasting against alternative hypotheses. Available null models
include:
</p>

<ul>
<li> <p>&ldquo;tipshuffle&rdquo;: shuffles phylogenetic tip labels multiple times.
</p>
</li>
<li> <p>&ldquo;rowwise&rdquo;: shuffles sites (i.e., varying richness) and
keeping species occurrence frequency constant.
</p>
</li>
<li> <p>&ldquo;colwise&rdquo;: shuffles species occurrence frequency and
keeping site richness constant.</p>
</li></ul>
</td></tr>
<tr><td><code id="phylobeta_ses_+3A_reps">reps</code></td>
<td>
<p>Number of replications.</p>
</td></tr>
<tr><td><code id="phylobeta_ses_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of results for each community or grid cell
</p>

<ul>
<li><p> phylobeta_obs: Observed phylobeta in community
</p>
</li>
<li><p> phylobeta_rand_mean: Mean phylobeta in null communities
</p>
</li>
<li><p> phylobeta_rand_sd: Standard deviation of phylobeta in null communities
</p>
</li>
<li><p> phylobeta_obs_z: Standardized effect size of phylobeta vs.
null communities <code class="reqn">= (phylobeta_obs - phylobeta_rand_mean)
  / phylobeta_rand_sd</code>
</p>
</li>
<li><p> reps: Number of replicates
</p>
</li></ul>



<h3>References</h3>

<p>Proches, S., Wilson, J.R.U. &amp; Cowling, R.M. (2006) How much evolutionary
history in a 10 x 10m plot? <em>Proceedings of Royal Society B</em>
<strong>273</strong>: 1143-1148.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
library(Matrix)
tree &lt;- read.tree(text ="((t1:1,t2:1)N2:1,(t3:1,t4:1)N3:1)N1;")
com &lt;- sparseMatrix(c(1,3,4,1,4,5,1,2,3,4,5,6,3,4,6),
  c(1,1,1,2,2,2,3,3,3,3,3,3,4,4,4),x=1,
  dimnames = list(paste0("g", 1:6), tree$tip.label))

phylobeta_ses(com, tree, model="rowwise")

</code></pre>

<hr>
<h2 id='phylobuilder'>Create a subtree with largest overlap from a species list.</h2><span id='topic+phylobuilder'></span>

<h3>Description</h3>

<p>phylobuilder creates a subtree with largest overlap from a species list.
If species in the species list are not already in the tip label, species will
be added at the most recent common ancestor at the genus or family level when
possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylobuilder(species, tree, extract = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylobuilder_+3A_species">species</code></td>
<td>
<p>A vector or matrix containing a species list</p>
</td></tr>
<tr><td><code id="phylobuilder_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree (object of class phylo)</p>
</td></tr>
<tr><td><code id="phylobuilder_+3A_extract">extract</code></td>
<td>
<p>extract the species in the list after trying to  add missing
labels to the tree. If FALSE phylobuilder adds only the taxa in the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phylobuilder</code> returns a phylogenetic tree, i.e. an object of
class <code>phylo</code>.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+add.tips">add.tips</a></code>, <code><a href="ape.html#topic+label2table">label2table</a></code>,
<code><a href="ape.html#topic+label2table">stripLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
txt &lt;- "(((((Panthera_leo,Panthera_pardus), Panthera_onca),(Panthera_uncia,
  (Panthera_tigris_altaica, Panthera_tigris_amoyensis)))Panthera)Felidae,
  (((((((Canis_lupus,Canis_lupus_familiaris),Canis_latrans),Canis_anthus),
  Canis_aureus),Lycaon_pictus),(Canis_adustus,Canis_mesomelas))Canis)
  Canidae)Carnivora;"
txt &lt;- gsub("[[:space:]]", "", txt)
cats_and_dogs &lt;- read.tree(text=txt)
plot(cats_and_dogs, node.depth=2, direction="downwards")
nodelabels(cats_and_dogs$node.label, frame="none", adj = c(0.5, 0))

tree &lt;- drop.tip(cats_and_dogs, c("Panthera_uncia", "Lycaon_pictus"),
  collapse.singles=FALSE)

dogs &lt;- c("Canis_lupus", "Canis_lupus_familiaris", "Canis_latrans",
  "Canis_anthus", "Canis_aureus", "Lycaon_pictus", "Canis_adustus",
  "Canis_mesomelas")

# try to extract tree with all 'dogs'
t1 &lt;- phylobuilder(dogs, tree)
plot(t1, direction="downwards")
attr(t1, "species_list")

# providing extra information ("Family", "Order", ...) can help
sp &lt;- data.frame(Order = c("Carnivora", "Carnivora", "Carnivora"),
  Family = c("Felidae", "Canidae", "Canidae"),
  Genus = c("Panthera", "Lycaon", "Vulpes"),
  Species = c("uncia", "pictus", "vulpes"),
  Common_name = c("Snow leopard", "Africa wild dog", "Red fox"))
sp
# Now we just add some species
t2 &lt;- phylobuilder(sp, tree, extract=FALSE)
plot(t2, direction="downwards")
attr(t2, "species_list")

</code></pre>

<hr>
<h2 id='phyloregion'>Compute phylogenetic regionalization and evolutionary distinctiveness of phyloregions</h2><span id='topic+phyloregion'></span><span id='topic+infomap'></span>

<h3>Description</h3>

<p>This function estimates evolutionary distinctiveness of each phyloregion by
computing the mean value of phylogenetic beta diversity between a focal
phyloregion and all other phyloregions in the study area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloregion(x, k = 10, method = "average", pol = NULL, ...)

infomap(x, pol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyloregion_+3A_x">x</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
<tr><td><code id="phyloregion_+3A_k">k</code></td>
<td>
<p>The desired number of phyloregions, often as determined by
<code>optimal_phyloregion</code>.</p>
</td></tr>
<tr><td><code id="phyloregion_+3A_method">method</code></td>
<td>
<p>the agglomeration method to be used. This should be (an
unambiguous abbreviation of) one of &ldquo;ward.D&rdquo;, &ldquo;ward.D2&rdquo;,
&ldquo;single&rdquo;,
&ldquo;complete&rdquo;, &ldquo;average&rdquo; (= UPGMA), &ldquo;mcquitty&rdquo; (= WPGMA),
&ldquo;median&rdquo;
(= WPGMC) or &ldquo;centroid&rdquo; (= UPGMC).</p>
</td></tr>
<tr><td><code id="phyloregion_+3A_pol">pol</code></td>
<td>
<p>a vector polygon of grid cells or spatial points.</p>
</td></tr>
<tr><td><code id="phyloregion_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>phyloregion</code> containing
</p>

<ul>
<li><p> a data frame membership with columns grids and cluster
</p>
</li>
<li><p> k the number of clusters
and additionally there can be an shape file and other objects.
This representation may still change.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Barnabas H. Daru <a href="mailto:darunabas@gmail.com">darunabas@gmail.com</a>
</p>


<h3>References</h3>

<p>Daru, B.H., Van der Bank, M., Maurin, O., Yessoufou, K., Schaefer, H.,
Slingsby, J.A. &amp; Davies, T.J. (2016) A novel phylogenetic regionalization of
the phytogeographic zones of southern Africa reveals their hidden
evolutionary affinities. <em>Journal of Biogeography</em> <strong>43</strong>: 155-166.
</p>
<p>Daru, B.H., Elliott, T.L., Park, D.S. &amp; Davies, T.J. (2017) Understanding the
processes underpinning patterns of phylogenetic regionalization.
<em>Trends in Ecology and Evolution</em> <strong>32</strong>: 845-860.
</p>
<p>Daru, B.H., Holt, B.G., Lessard, J.P., Yessoufou, K. &amp; Davies, T.J. (2017)
Phylogenetic regionalization of marine plants reveals close evolutionary
affinities among disjunct temperate assemblages.
<em>Biological Conservation</em> <strong>213</strong>: 351-356.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evol_distinct">evol_distinct</a></code>, <code><a href="#topic+optimal_phyloregion">optimal_phyloregion</a></code>,
<code><a href="picante.html#topic+evol.distinct">evol.distinct</a></code> for a different approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
tree &lt;- read.tree(text = "((t1:1,t2:1)N2:1,(t3:1,t4:1)N3:1)N1;")
com &lt;- sparseMatrix(c(1,3,4,1,4,5,1,2,3,4,5,6,3,4,6),
  c(1,1,1,2,2,2,3,3,3,3,3,3,4,4,4),x=1,
  dimnames = list(paste0("g", 1:6), tree$tip.label))
pbc &lt;- phylobeta(com, tree)
# phyloregion(pbc[[1]], k = 3)
</code></pre>

<hr>
<h2 id='phyloregion-package'>Biogeographic regionalization and macroecology</h2><span id='topic+phyloregion-package'></span>

<h3>Description</h3>

<p>This document describes the <code>phyloregion</code> package for the R software.
<code>phyloregion</code> is a computational infrastructure for biogeographic
regionalization
(the classification of geographical areas in terms of their biotas) and
spatial conservation in the R scientific computing environment. Previous
analyses of biogeographical regionalization were either focused on smaller
datasets or slower particularly when the number of species or geographic
scale is very large. With macroecological datasets of ever increasing size
and complexity, <code>phyloregion</code> offers the possibility of handling and
executing large scale biogeographic regionalization efficiently and with
extreme speed. It also allows fast and efficient for analysis of more
standard conservation measures such as phylogenetic diversity, phylogenetic
endemism, evolutionary distinctiveness and global endangerment.
<code>phyloregion</code> can run on any operating system (Mac, Linux, Windows or
even high performance computing cluster) with R 3.6.0 (or higher) installed.
</p>


<h3>How to cite <code>phyloregion</code></h3>

<p>The original implementation of phyloregion is described in:
</p>

<ul>
<li><p> Daru B.H., Karunarathne, P. &amp; Schliep, K. (2020) phyloregion:
R package for biogeographic regionalization and macroecology.
<em>Methods in Ecology and Evolution</em> <strong>11</strong>, 1483-1491.
</p>
</li></ul>

<p>It is based on the method described in:
</p>

<ul>
<li><p> Daru, B.H., Farooq, H., Antonelli, A. &amp; Faurby, S. (2020) Endemism
patterns are scale dependent. <em>Nature Communications</em> <strong>11</strong>,
2115.
</p>
</li></ul>

<p>The original conceptual is described in:
</p>

<ul>
<li><p> Daru, B.H., Elliott, T.L., Park, D.S. &amp; Davies, T.J. (2017)
Understanding the processes underpinning patterns of phylogenetic
regionalization. <em>Trends in Ecology and Evolution</em> <strong>32</strong>: 845-860.
</p>
</li></ul>



<h3>Feedback</h3>

<p>If you have any questions, suggestions or issues regarding the package,
please add them to <a href="https://github.com/darunabas/phyloregion/issues">GitHub issues</a>
</p>


<h3>Installation</h3>

<p><code>phyloregion</code> is an open-source and free package hosted on
<a href="https://github.com/darunabas/phyloregion">GitHub</a>.
You will need to install the <code>devtools</code> package. In <code>R</code>, type:
</p>
<p><code>if (!requireNamespace("devtools", quietly = TRUE))
    install.packages("devtools")</code>
</p>
<p>Then:
</p>
<p><code>devtools::install_github("darunabas/phyloregion")</code>
</p>
<p>Load the phyloregion package:
</p>
<p><code>library(phyloregion)</code>
</p>


<h3>Acknowledgments</h3>

<p>Barnabas Daru thanks Texas A&amp;M University-Corpus Christi for financial
and logistic support.
</p>


<h3>Author(s)</h3>

<p><a href="https://darulab.org/">Barnabas H. Daru</a>, Piyal Karunarathne,
<a href="https://kschliep.netlify.app/">Klaus Schliep</a>
</p>

<hr>
<h2 id='plot_pie'>Visualize biogeographic patterns using pie charts</h2><span id='topic+plot_pie'></span>

<h3>Description</h3>

<p>Visualize biogeographic patterns using pie charts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pie(
  omega,
  pol,
  radius = 0.55,
  col = hcl.colors(5),
  pie_control = list(),
  legend = FALSE,
  legend_pie = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pie_+3A_omega">omega</code></td>
<td>
<p>a matrix of phyloregion of probabilities of each species</p>
</td></tr>
<tr><td><code id="plot_pie_+3A_pol">pol</code></td>
<td>
<p>a vector polygon of grid cells with a column labeled
&ldquo;grids&rdquo;.</p>
</td></tr>
<tr><td><code id="plot_pie_+3A_radius">radius</code></td>
<td>
<p>Radius of the pie legend to be displayed</p>
</td></tr>
<tr><td><code id="plot_pie_+3A_col">col</code></td>
<td>
<p>List of colors for the pies.</p>
</td></tr>
<tr><td><code id="plot_pie_+3A_pie_control">pie_control</code></td>
<td>
<p>The list of control parameters to be passed into
the add.pie function.</p>
</td></tr>
<tr><td><code id="plot_pie_+3A_legend">legend</code></td>
<td>
<p>Logical, whether to plot a legend or not.</p>
</td></tr>
<tr><td><code id="plot_pie_+3A_legend_pie">legend_pie</code></td>
<td>
<p>Legend for the pie plots.</p>
</td></tr>
<tr><td><code id="plot_pie_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no value, just map color pies in geographic space!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
data(africa)
p &lt;- vect(system.file("ex/sa.json", package = "phyloregion"))
K &lt;- ncol(africa$omega)

CLRS &lt;- hcl.colors(K)
plot_pie(africa$omega, pol = p, col=CLRS)
</code></pre>

<hr>
<h2 id='plot.phyloregion'>Visualize biogeographic patterns</h2><span id='topic+plot.phyloregion'></span><span id='topic+plot_NMDS'></span><span id='topic+text_NMDS'></span>

<h3>Description</h3>

<p>Visualize biogeographic patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phyloregion'
plot(x, pol = NULL, palette = "NMDS", col = NULL, label = FALSE, ...)

plot_NMDS(x, ...)

text_NMDS(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.phyloregion_+3A_x">x</code></td>
<td>
<p>an object of class phyloregion from <code>phyloregion</code></p>
</td></tr>
<tr><td><code id="plot.phyloregion_+3A_pol">pol</code></td>
<td>
<p>a polygon shapefile of grid cells.</p>
</td></tr>
<tr><td><code id="plot.phyloregion_+3A_palette">palette</code></td>
<td>
<p>name of the palette to generate colors from. The default,
&ldquo;NMDS&rdquo;, allows display of phyloregions in multidimensional
scaling color space matching the color vision of the human visual
system. The name is matched to the list of available color palettes from
the <code>hcl.colors</code> function in the <code>grDevices</code> package.</p>
</td></tr>
<tr><td><code id="plot.phyloregion_+3A_col">col</code></td>
<td>
<p>vector of colors of length equal to the number of phyloregions.</p>
</td></tr>
<tr><td><code id="plot.phyloregion_+3A_label">label</code></td>
<td>
<p>Logical, whether to print cluster names or not</p>
</td></tr>
<tr><td><code id="plot.phyloregion_+3A_...">...</code></td>
<td>
<p>arguments passed among methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
data(africa)
tree &lt;- africa$phylo
x &lt;- africa$comm
p &lt;- vect(system.file("ex/sa.json", package = "phyloregion"))

subphy &lt;- match_phylo_comm(tree, x)$phy
submat &lt;- match_phylo_comm(tree, x)$com

pbc &lt;- phylobeta(submat, subphy)
y &lt;- phyloregion(pbc[[1]], pol=p)

plot_NMDS(y, cex=6)
text_NMDS(y, cex=2)
plot(y, cex=1, palette="NMDS")
plot(y, cex=1)
</code></pre>

<hr>
<h2 id='plot.sparse'>Create illustrative sparse matrix</h2><span id='topic+plot.sparse'></span>

<h3>Description</h3>

<p>This function visualizes a sparse matrix using vertical bands corresponding
to presence or absence of a species in an area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparse'
plot(x, col = c("red", "yellow"), lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sparse_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="plot.sparse_+3A_col">col</code></td>
<td>
<p>A vector of colors to represent presence or absence of a species</p>
</td></tr>
<tr><td><code id="plot.sparse_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="plot.sparse_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no value, just plot sparse matrix
</p>

<hr>
<h2 id='random_species'>Generate random species distributions in space</h2><span id='topic+random_species'></span>

<h3>Description</h3>

<p>This function generates random species distributions in geographic space as
extent of occurrence range polygons based on convex hulls of random points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_species(n, species, pol, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_species_+3A_n">n</code></td>
<td>
<p>vector of one or more elements to choose from, or a positive
integer.</p>
</td></tr>
<tr><td><code id="random_species_+3A_species">species</code></td>
<td>
<p>the desired number of species.</p>
</td></tr>
<tr><td><code id="random_species_+3A_pol">pol</code></td>
<td>
<p>the vector polygon of the study area for determining the
species distributions</p>
</td></tr>
<tr><td><code id="random_species_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector polygon of species' extent of occurrence ranges.
</p>


<h3>Author(s)</h3>

<p>Barnabas H. Daru <a href="mailto:darunabas@gmail.com">darunabas@gmail.com</a>
</p>

<hr>
<h2 id='rast2comm'>Convert raw input distribution data to community</h2><span id='topic+rast2comm'></span><span id='topic+polys2comm'></span><span id='topic+points2comm'></span>

<h3>Description</h3>

<p>The functions <code>points2comm</code>, <code>polys2comm</code>, <code>rast2comm</code>
provide convenient interfaces to convert raw distribution data often
available as point records, polygons and raster layers,
respectively, to a community composition data frame at varying spatial grains
and extents for downstream analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rast2comm(files)

polys2comm(dat, res = 0.25, pol.grids = NULL, ...)

points2comm(dat, res = 0.25, pol.grids = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rast2comm_+3A_files">files</code></td>
<td>
<p>list of SpatRaster layer objects with the same spatial
extent and resolution.</p>
</td></tr>
<tr><td><code id="rast2comm_+3A_dat">dat</code></td>
<td>
<p>layers of merged maps corresponding to species polygons for
<code>polys2comm</code>; or point occurrence data frame for <code>points2comm</code>,
with at least three columns:
</p>

<ul>
<li><p> Column 1: <code>species</code> (listing the taxon names)
</p>
</li>
<li><p> Column 2: <code>decimallongitude</code> (corresponding to decimal longitude)
</p>
</li>
<li><p> Column 3: <code>decimallatitude</code> (corresponding to decimal latitude)
</p>
</li></ul>
</td></tr>
<tr><td><code id="rast2comm_+3A_res">res</code></td>
<td>
<p>the grain size of the grid cells in decimal degrees (default).</p>
</td></tr>
<tr><td><code id="rast2comm_+3A_pol.grids">pol.grids</code></td>
<td>
<p>if specified, the vector polygon of grid cells
with a column labeled &ldquo;grids&rdquo;.</p>
</td></tr>
<tr><td><code id="rast2comm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each of these functions generate a list of two objects as follows:
</p>

<ul>
<li><p> comm_dat: (sparse) community matrix
</p>
</li>
<li><p> map: vector or raster of grid cells with the values per cell for
mapping.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="mapproj.html#topic+mapproject">mapproject</a></code> for conversion of
latitude and longitude into projected coordinates system.
<code><a href="#topic+long2sparse">long2sparse</a></code> for conversion of community data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fdir &lt;- system.file("NGAplants", package="phyloregion")
files &lt;- file.path(fdir, dir(fdir))
ras &lt;- rast2comm(files) # Note, this function generates
     # a list of two objects
head(ras[[1]])



require(terra)
s &lt;- vect(system.file("ex/nigeria.json", package="phyloregion"))
sp &lt;- random_species(100, species=5, pol=s)
pol &lt;- polys2comm(dat = sp)
head(pol[[1]])


library(terra)
s &lt;- vect(system.file("ex/nigeria.json", package="phyloregion"))
set.seed(1)
m &lt;- as.data.frame(spatSample(s, 1000, method = "random"),
                   geom = "XY")[-1]
names(m) &lt;- c("lon", "lat")
species &lt;- paste0("sp", sample(1:100))
m$taxon &lt;- sample(species, size = nrow(m), replace = TRUE)

pt &lt;- points2comm(dat = m, res = 0.5) # This generates a list of two objects
head(pt[[1]])
</code></pre>

<hr>
<h2 id='read.community'>Read in sparse community matrices</h2><span id='topic+read.community'></span>

<h3>Description</h3>

<p><code>read.community</code> reads in file containing occurrence data and returns a
sparse matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.community(file, grids = "grids", species = "species", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.community_+3A_file">file</code></td>
<td>
<p>A file name.</p>
</td></tr>
<tr><td><code id="read.community_+3A_grids">grids</code></td>
<td>
<p>Column name of the column containing grid cells.</p>
</td></tr>
<tr><td><code id="read.community_+3A_species">species</code></td>
<td>
<p>Column name of the column containing the species / taxa names.</p>
</td></tr>
<tr><td><code id="read.community_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read.community</code> returns a sparse matrix (an object of class
&quot;dgCMatrix&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(grids=paste0("g", c(1,1,2,3,3)),
                 species = paste0("sp", c(1,3,2,1,4)))
df
tmp &lt;- tempfile()
write.csv(df, tmp)
(M &lt;- read.community(tmp) )
sparse2long(M)
unlink(tmp)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+Matrix'></span><span id='topic+sparseMatrix'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>Matrix</dt><dd><p><code><a href="Matrix.html#topic+Matrix">Matrix</a></code>, <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code></p>
</dd>
</dl>

<hr>
<h2 id='sdm'>Species distribution models</h2><span id='topic+sdm'></span>

<h3>Description</h3>

<p>This function computes species distribution models using
two modelling algorithms: generalized linear models,
and maximum entropy (only if <code>rJava</code> is available).
Note: this is an experimental function, and may change in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdm(
  x,
  predictors = NULL,
  pol = NULL,
  thin = TRUE,
  thin.size = 500,
  algorithm = "all",
  size = 50,
  width = 50000,
  mask = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdm_+3A_x">x</code></td>
<td>
<p>A dataframe containing the species occurrences
and geographic coordinates. Column 1 labeled as &quot;species&quot;, column 2 &quot;lon&quot;,
column 3 &quot;lat&quot;.</p>
</td></tr>
<tr><td><code id="sdm_+3A_predictors">predictors</code></td>
<td>
<p>A <code>SpatRaster</code> to extract values from the
locations in x on which the models will be projected.</p>
</td></tr>
<tr><td><code id="sdm_+3A_pol">pol</code></td>
<td>
<p>A vector polygon specifying the boundary to restrict the
prediction. If <code>NULL</code>, the extent of input points is used.</p>
</td></tr>
<tr><td><code id="sdm_+3A_thin">thin</code></td>
<td>
<p>Whether to thin occurrences</p>
</td></tr>
<tr><td><code id="sdm_+3A_thin.size">thin.size</code></td>
<td>
<p>The size of the thin occurrences.</p>
</td></tr>
<tr><td><code id="sdm_+3A_algorithm">algorithm</code></td>
<td>
<p>Character. The choice of algorithm to run the species
distribution model. Available algorithms include:
</p>

<ul>
<li> <p>&ldquo;all&rdquo;: Calls all available algorithms: GLM, and MAXENT.
</p>
</li>
<li> <p>&ldquo;GLM&rdquo;: Calls only Generalized linear model.
</p>
</li>
<li> <p>&ldquo;MAXENT&rdquo;: Calls only Maximum entropy.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sdm_+3A_size">size</code></td>
<td>
<p>Minimum number of points required to successfully run
a species distribution model especially for species with few occurrences.</p>
</td></tr>
<tr><td><code id="sdm_+3A_width">width</code></td>
<td>
<p>Width of buffer in meter if x is in longitude/latitude CRS.</p>
</td></tr>
<tr><td><code id="sdm_+3A_mask">mask</code></td>
<td>
<p>logical. Should y be used to mask? Only used if pol is a SpatVector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following objects:
</p>

<ul>
<li> <p><code>ensemble_raster</code> The ensembled raster that predicts
the potential species distribution based on the algorithms selected.
</p>
</li>
<li> <p><code>data</code> The dataframe of occurrences used to implement the model.
</p>
</li>
<li> <p><code>polygon</code> Map polygons of the predicted distributions
analogous to extent-of-occurrence range polygon.
</p>
</li>
<li> <p><code>indiv_models</code> Raster layers for the separate models that
predict the potential species distribution.
</p>
</li></ul>



<h3>References</h3>

<p>Zurell, D., Franklin, J., König, C., Bouchet, P.J., Dormann, C.F., Elith, J.,
Fandos, G., Feng, X., Guillera‐Arroita, G., Guisan, A., Lahoz‐Monfort, J.J.,
Leitão, P.J., Park, D.S., Peterson, A.T., Rapacciuolo, G., Schmatz, D.R.,
Schröder, B., Serra‐Diaz, J.M., Thuiller, W., Yates, K.L., Zimmermann, N.E.
and Merow, C. (2020), A standard protocol for reporting species distribution
models. <em>Ecography</em>, <strong>43</strong>: 1261-1277.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get predictor variables
library(predicts)
f &lt;- system.file("ex/bio.tif", package="predicts")
preds &lt;- rast(f)
#plot(preds)

# get species occurrences
b &lt;- file.path(system.file(package="predicts"), "ex/bradypus.csv")
d &lt;- read.csv(b)

# fit ensemble model for four algorithms
m &lt;- sdm(d, predictors = preds, algorithm = "all")
# plot(m$ensemble_raster)
# plot(m$polygon, add=TRUE)

</code></pre>

<hr>
<h2 id='select_linkage'>Cluster algorithm selection and validation</h2><span id='topic+select_linkage'></span>

<h3>Description</h3>

<p>This function contrasts different hierarchical clustering algorithms
on the phylogenetic beta diversity matrix for degree of
data distortion using Sokal &amp; Rohlf’s (1962) cophenetic
correlation coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_linkage(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_linkage_+3A_x">x</code></td>
<td>
<p>a numeric matrix, data frame or &quot;dist&quot; object.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> A numeric value corresponding to the good clustering algorithm
for the distance matrix
</p>
</li>
<li><p> If plot = TRUE, a barplot of cophenetic correlation for all
the clustering algorithms is drawn.
</p>
</li></ul>



<h3>References</h3>

<p>Sokal, R.R. &amp; Rohlf, F.J. (1962) The comparison of dendrograms by
objective methods. <em>Taxon</em> <strong>11</strong>: 33–40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
tree &lt;- africa$phylo
bc &lt;- beta_diss(africa$comm)
y &lt;- select_linkage(bc[[1]])
barplot(y, horiz = TRUE, las = 1)

</code></pre>

<hr>
<h2 id='selectbylocation'>Select polygon features from another layer and adds polygon attributes to layer</h2><span id='topic+selectbylocation'></span>

<h3>Description</h3>

<p>The <code>selectbylocation</code> function selects features based on
their location relative to features in another layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectbylocation(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectbylocation_+3A_x">x</code></td>
<td>
<p>source layer of the class SpatVect</p>
</td></tr>
<tr><td><code id="selectbylocation_+3A_y">y</code></td>
<td>
<p>Target layer or mask extent to subset from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatial polygons or spatial points object pruned to the extent
of the target layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
d &lt;- vect(system.file("ex/nigeria.json", package="phyloregion"))
e &lt;- ext(d)

set.seed(1)
m &lt;- data.frame(lon = runif(1000, e[1], e[2]),
                lat = runif(1000, e[3], e[4]),
                sites = seq(1000))
m &lt;- vect(m)
z &lt;- selectbylocation(m, d)
plot(d)
points(m, col = "blue", pch = "+")
points(z, col = "red", pch = "+")
</code></pre>

<hr>
<h2 id='timeslice'>Slice phylogenetic tree at various time depths</h2><span id='topic+timeslice'></span>

<h3>Description</h3>

<p>This function slices a dated phylogenetic tree at successive time depths back
in time by collapsing younger phylogenetic branches into older ones to infer
the origins of species assemblages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeslice(phy, n = 0.2, collapse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeslice_+3A_phy">phy</code></td>
<td>
<p>A dated phylogenetic tree as an object of class &ldquo;phylo&rdquo;.</p>
</td></tr>
<tr><td><code id="timeslice_+3A_n">n</code></td>
<td>
<p>Time depth to slice the phylogenetic tree (often in millions of
years for dated trees).</p>
</td></tr>
<tr><td><code id="timeslice_+3A_collapse">collapse</code></td>
<td>
<p>Logical, collapse internal edges with zero edge length.</p>
</td></tr>
<tr><td><code id="timeslice_+3A_...">...</code></td>
<td>
<p>arguments passed among methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree with the phylogenetic structure removed at the specified time depth
</p>


<h3>Author(s)</h3>

<p>Barnabas H. Daru <a href="mailto:darunabas@gmail.com">darunabas@gmail.com</a>
</p>


<h3>References</h3>

<p>Daru, B.H., van der Bank, M. &amp; Davies, T.J. (2018) Unravelling the
evolutionary origins of biogeographic assemblages.
<em>Diversity and Distributions</em> <strong>24</strong>: 313–324.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)

set.seed(1)
tree &lt;- rcoal(50)
x &lt;- timeslice(tree, .5)

old.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
plot(tree)
axisPhylo()
plot(x)
axisPhylo()
par(old.par)
</code></pre>

<hr>
<h2 id='unifrac'>UniFrac distance</h2><span id='topic+unifrac'></span>

<h3>Description</h3>

<p><code>unifrac</code> calculates the unweighted UniFrac distance between
communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unifrac(x, phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unifrac_+3A_x">x</code></td>
<td>
<p>a community matrix, i.e. an object of class matrix or Matrix, or an
object of class phyloseq.</p>
</td></tr>
<tr><td><code id="unifrac_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree (object of class phylo).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dist object.
</p>


<h3>References</h3>

<p>Lozupone C, Knight R. (2005) UniFrac: a new phylogenetic method for comparing
microbial communities. <em>Appl Environ Microbiol.</em> <strong>71 (12)</strong>:8228&ndash;35.
<em>BMC Bioinformatics</em> 7:371.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PD">PD</a></code>, <code><a href="#topic+phylobeta">phylobeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::read.tree(text ="((t1:1,t2:1)N2:1,(t3:1,t4:1)N3:1)N1;")
com &lt;- Matrix::sparseMatrix(c(1,3,4,1,4,5,1,2,3,4,5,6,3,4,6),
  c(1,1,1,2,2,2,3,3,3,3,3,3,4,4,4),x=1,
  dimnames = list(paste0("g", 1:6), tree$tip.label))

unifrac(com, tree)
</code></pre>

<hr>
<h2 id='weighted_endemism'>Measure the distribution of narrow-ranged or endemic species.</h2><span id='topic+weighted_endemism'></span>

<h3>Description</h3>

<p><code>weighted_endemism</code> is species richness inversely weighted
by species ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_endemism(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_endemism_+3A_x">x</code></td>
<td>
<p>A (sparse) community matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of species traits by site.
</p>


<h3>References</h3>

<p>Crisp, M.D., Laffan, S., Linder, H.P. &amp; Monro, A. (2001) Endemism in the
Australian flora. <em>Journal of Biogeography</em> <strong>28</strong>: 183–198.
</p>
<p>Daru, B.H., Farooq, H., Antonelli, A. &amp; Faurby, S. (2020) Endemism
patterns are scale dependent. <em>Nature Communications</em> <strong>11</strong>
: 2115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
data(africa)
p &lt;- vect(system.file("ex/sa.json", package = "phyloregion"))
Endm &lt;- weighted_endemism(africa$comm)
m &lt;- merge(p, data.frame(grids=names(Endm), WE=Endm), by="grids")
m &lt;- m[!is.na(m$WE),]

plot(m, "WE", col = hcl.colors(20), type="continuous")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
