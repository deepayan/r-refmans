<!DOCTYPE html><html lang="en"><head><title>Help for package nadiv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nadiv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nadiv-package'><p>(Non)Additive Genetic Relatedness Matrices in Animal Model Analyses</p></a></li>
<li><a href='#aic'><p>Akaike Information Criterion</p></a></li>
<li><a href='#aiCI'><p>Confidence Intervals for Variance Components</p></a></li>
<li><a href='#aiFun'><p>Sampling (co)variances</p></a></li>
<li><a href='#constrainFun'><p>Fix a Model Parameter and Conduct Likelihood Ratio Test</p></a></li>
<li><a href='#drfx'><p>Simulated design random effects</p></a></li>
<li><a href='#F2009'><p>Pedigree adapted from Fikse 2009 with genetic groups and fuzzy classification</p></a></li>
<li><a href='#FG90'><p>Pedigree, adapted from Table 1 in Fernando &amp; Grossman (1990)</p></a></li>
<li><a href='#findDFC'><p>Finds the double first cousins in a pedigree</p></a></li>
<li><a href='#founderLine'><p>Identifies the matriline or patriline to which each individual in a pedigree</p>
belongs</a></li>
<li><a href='#genAssign'><p>Generation assignment</p></a></li>
<li><a href='#geneDrop'><p>Functions to conduct gene dropping through a pedigree</p></a></li>
<li><a href='#ggcontrib'><p>Genetic group contribution</p></a></li>
<li><a href='#ggTutorial'><p>Simulated dataset used to analyze data with genetic group animal models</p></a></li>
<li><a href='#grfx'><p>Simulated genetic random effects</p></a></li>
<li><a href='#LRTest'><p>log-Likelihood Ratio Test</p></a></li>
<li><a href='#makeA'><p>Creates the additive genetic relationship matrix</p></a></li>
<li><a href='#makeAA'><p>Creates the additive by additive epistatic genetic relationship matrix</p></a></li>
<li><a href='#makeAinv'><p>Creates the inverse additive genetic relationship matrix</p></a></li>
<li><a href='#makeAstarMult'><p>Creates the inverse additive genetic relationship matrix with genetic groups</p></a></li>
<li><a href='#makeD'><p>Create the dominance genetic relationship matrix</p></a></li>
<li><a href='#makeDomEpi'><p>Creates the additive by dominance and dominance by dominance epistatic</p>
genetic relationship matrices</a></li>
<li><a href='#makeDsim'><p>Create the dominance genetic relationship matrix through an iterative</p>
(simulation) process</a></li>
<li><a href='#makeM'><p>Creates the (additive) mutational effects relationship matrix</p></a></li>
<li><a href='#makeMinv'><p>Create the inverse (additive) mutational effects relationship matrix</p></a></li>
<li><a href='#makeS'><p>Creates the additive genetic relationship matrix for the shared sex</p>
chromosomes</a></li>
<li><a href='#makeTinv'><p>Creates components of the additive genetic relationship matrix and its inverse</p></a></li>
<li><a href='#Mrode2'><p>Pedigree from Table 2.1 of Mrode (2005)</p></a></li>
<li><a href='#Mrode3'><p>Pedigree, from chapter 3 of Mrode (2005) with genetic groups and a trait column</p></a></li>
<li><a href='#Mrode9'><p>Pedigree, adapted from example 9.1 of Mrode (2005)</p></a></li>
<li><a href='#nadiv-deprecated'><p>Deprecated functions in package <span class="pkg">nadiv</span>.</p></a></li>
<li><a href='#numPed'><p>Integer Format Pedigree</p></a></li>
<li><a href='#pcc'><p>REML convergence checks</p></a></li>
<li><a href='#pin-deprecated'><p>Approximate standard errors for linear functions of variance components</p></a></li>
<li><a href='#prepPed'><p>Prepares a pedigree by sorting and adding 'founders'</p></a></li>
<li><a href='#prunePed'><p>Prunes a pedigree based on individuals with phenotypes</p></a></li>
<li><a href='#Q1988'><p>Pedigree with genetic groups adapted from Quaas (1988) equation [5]</p></a></li>
<li><a href='#simGG'><p>Genetic group pedigree and data simulation</p></a></li>
<li><a href='#simPedDFC'><p>Double first cousin pedigree construction</p></a></li>
<li><a href='#simPedHS'><p>Half-sib pedigree construction</p></a></li>
<li><a href='#simPedMCN'><p>Middle Class Neighborhood pedigree construction</p></a></li>
<li><a href='#sm2list'><p>Converts a sparse matrix into a three column format.</p></a></li>
<li><a href='#varTrans'><p>Transforms ASReml-R gamma sampling variances to component scale</p></a></li>
<li><a href='#warcolak'><p>Pedigree and phenotypic values for a mythical population of Warcolaks</p></a></li>
<li><a href='#Wray90'><p>Pedigree, adapted from Wray (1990)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>(Non)Additive Genetic Relatedness Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>2.18.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/matthewwolak/nadiv">https://github.com/matthewwolak/nadiv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/matthewwolak/nadiv/issues">https://github.com/matthewwolak/nadiv/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>Enhances:</td>
<td>MCMCglmm, asreml</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, methods, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Constructs (non)additive genetic relationship matrices, and their
    inverses, from a pedigree to be used in linear mixed effect models (A.K.A.
    the 'animal model'). Also includes other functions to facilitate the use of
    animal models. Some functions have been created to be used in conjunction
    with the R package 'asreml' for the 'ASReml' software, which can be
    obtained upon purchase from 'VSN' international 
    (<a href="https://vsni.co.uk/software/asreml">https://vsni.co.uk/software/asreml</a>).</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-23 12:43:09 UTC; mew0099</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Wolak [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Wolak &lt;matthewwolak@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-23 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nadiv-package'>(Non)Additive Genetic Relatedness Matrices in Animal Model Analyses</h2><span id='topic+nadiv-package'></span><span id='topic+nadiv'></span>

<h3>Description</h3>

<p>Constructs (non)additive genetic relationship matrices, and their inverses,
from a pedigree to be used in linear mixed effect models (A.K.A. the 'animal
model'). Also includes other functions to facilitate the use of animal
models. Some functions have been created to be used in conjunction with the
R package for ASReml software, which can be obtained upon purchase from
VSN international (&lt;https://www.vsni.co.uk/software/asreml&gt;).
</p>


<h3>Author(s)</h3>

<p>Matthew Wolak <a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/matthewwolak/nadiv">https://github.com/matthewwolak/nadiv</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/matthewwolak/nadiv/issues">https://github.com/matthewwolak/nadiv/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aic'>Akaike Information Criterion</h2><span id='topic+aic'></span>

<h3>Description</h3>

<p>Calculates AIC/AICc values, AIC differences, Likelihood of models, and model
probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic(logLik, fp, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aic_+3A_loglik">logLik</code></td>
<td>
<p>A vector of model log-Likelihoods</p>
</td></tr>
<tr><td><code id="aic_+3A_fp">fp</code></td>
<td>
<p>A vector containing the numbers of free parameters of each model
included in the logLik vector</p>
</td></tr>
<tr><td><code id="aic_+3A_n">n</code></td>
<td>
<p>An optional vector of sample sizes for each model.  Used to
calculate AICc (small sample unbiased AIC).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations and notation follows chapter 2 of Burnham and Anderson (2002).
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>AIC </dt><dd><p>vector containing AIC/AICc (depending on value of <code>n</code>)</p>
</dd>
<dt>delta_AIC </dt><dd><p>vector containing AIC differences from the minimum 
AIC(c)</p>
</dd>
<dt>AIClik </dt><dd><p>vector containing likelihoods for each model, given the 
data.  Represents the relative strength of evidence for each model.</p>
</dd>
<dt>w </dt><dd><p>Akaike weights.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Burnham, K.P. and D.R. Anderson. 2002. Model Selection and
Multimodel Inference. A Practical Information-Theoretic Approach, 2nd edn.
Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   aic(c(-3139.076, -3136.784, -3140.879, -3152.432), c(8, 7, 8, 5)) 

</code></pre>

<hr>
<h2 id='aiCI'>Confidence Intervals for Variance Components</h2><span id='topic+aiCI'></span>

<h3>Description</h3>

<p>Produces the 1-alpha Upper and Lower Confidence Limits for the variance
components in an ASReml-R model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aiCI(asr.model, Dimnames = NULL, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aiCI_+3A_asr.model">asr.model</code></td>
<td>
<p>Object from a call to <code>asreml</code></p>
</td></tr>
<tr><td><code id="aiCI_+3A_dimnames">Dimnames</code></td>
<td>
<p>A vector of characters if names are desired for the output.
If not specified, the default labels from the <code>asreml</code> object will be
used.</p>
</td></tr>
<tr><td><code id="aiCI_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value indicating the level of Type I error for
constructing the Confidence Intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variances from the inverse of the Average Information matrix of an ASReml
model are translated according to the <code><a href="#topic+varTrans">varTrans</a></code> function and
used in constructing the 1-alpha Confidence Interval.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> is returned with a row for each variance component. 
The three columns correspond to the Lower Confidence Limit, estimate from
the <code>asreml</code> model, and Upper Confidence Limit for each variance 
component.
</p>


<h3>Note</h3>

<p>The vector of <code>Dimnames</code> should match the same order of variance
components specified in the model.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aiFun">aiFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
    library(asreml)
    ginvA &lt;- ainverse(warcolak)
    ginvD &lt;- makeD(warcolak[, 1:3])$listDinv
      attr(ginvD, "rowNames") &lt;- as.character(warcolak[, 1])
      attr(ginvD, "INVERSE") &lt;- TRUE
    warcolak$IDD &lt;- warcolak$ID
    warcolak.mod &lt;- asreml(trait1 ~ sex,
     random = ~ vm(ID, ginvA) + vm(IDD, ginvD), 
	data = warcolak) 
    summary(warcolak.mod)$varcomp
    aiCI(warcolak.mod)    
   
## End(Not run)

</code></pre>

<hr>
<h2 id='aiFun'>Sampling (co)variances</h2><span id='topic+aiFun'></span>

<h3>Description</h3>

<p>This function returns the sampling (co)variances of the variance components
fitted in an mixed model solved using the Average Information algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aiFun(model = NULL, AI.vec = NULL, inverse = TRUE, Dimnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aiFun_+3A_model">model</code></td>
<td>
<p>A model object returned by a call to the <code>asreml</code> function.</p>
</td></tr>
<tr><td><code id="aiFun_+3A_ai.vec">AI.vec</code></td>
<td>
<p>A numeric vector of the Average Information matrix. The order
must be the row-wise lower triangle of the matrix (including the diagonal).</p>
</td></tr>
<tr><td><code id="aiFun_+3A_inverse">inverse</code></td>
<td>
<p>A logical indicating whether the elements of the
<em>inverse</em> Average Information matrix are being provided. If FALSE, 
the Average Information matrix (and not its inverse) is being supplied.</p>
</td></tr>
<tr><td><code id="aiFun_+3A_dimnames">Dimnames</code></td>
<td>
<p>A vector of characters if names are desired for the output
(co)variance matrix. If not specified, either the default labels from the
<code>asreml</code> object will be used or the rows and columns will be
unlabeled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse of the Average Information matrix provides the sampling
(co)variance of each (co)variance component in the random portion of the
mixed model. If a model from the ASReml-R function is supplied (<code>model</code>
is not NULL), this function extracts the inverse of the AI matrix from an
ASReml-R model and organizes it so that the sampling covariances between
random terms are the off-diagonals and the sampling variances of random
terms are located along the diagonal. The order of the variances along the
diagonal is the same as the order entered in the random section of the
<code>asreml</code> function. This is also the same order as the rows of a call to
the summary function, <code>summary(model)$varcomp</code>.
</p>
<p>If <code>model</code> is NULL then <code>AI.vec</code> should contain the vector of
values from an Average Information matrix. The function will then
reconstruct this matrix, invert it, and supply the sampling (co) variances
for the random terms in the model as described above. Note, either
<code>model</code> or <code>AI.vec</code> must be supplied, but not both.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> of k x k dimensions is returned, if k is the number
of (co)variance components estimated in the model. Sampling covariances are
above and below the diagonal while variances are located along the
diagonal. If <code>Dimnames</code> is specified, the row and column names are
assigned according the vector of names in this argument.
</p>


<h3>Note</h3>

<p>The vector of <code>Dimnames</code> should match the same order of variance
components specified in the model.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Gilmour, A.R., Gogel, B.J., Cullis, B.R., &amp; Thompson, R. 2009.
ASReml User Guide Release 3.0. VSN International Ltd., Hemel Hempstead, UK.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
    library(asreml)
    ginvA &lt;- ainverse(warcolak)
    ginvD &lt;- makeD(warcolak[, 1:3])$listDinv
      attr(ginvD, "rowNames") &lt;- as.character(warcolak[, 1])
      attr(ginvD, "INVERSE") &lt;- TRUE
    warcolak$IDD &lt;- warcolak$ID
    warcolak.mod &lt;- asreml(trait1 ~ sex,
     random = ~ vm(ID, ginvA) + vm(IDD, ginvD), 
	data = warcolak) 
    summary(warcolak.mod)$varcomp
    aiFun(model = warcolak.mod, Dimnames = c("Va", "Vd", "Ve"), inverse = TRUE)    
   
## End(Not run)

  output &lt;- c(7.3075921, 7.0635161, 12.3423380, 1.9539486, 2.7586340, 0.6626111)
  aiFun(AI.vec = output, inverse = FALSE, Dimnames = c("Va", "Vd", "Ve"))

</code></pre>

<hr>
<h2 id='constrainFun'>Fix a Model Parameter and Conduct Likelihood Ratio Test</h2><span id='topic+constrainFun'></span>

<h3>Description</h3>

<p>Given a model object from <code>asreml</code> and a range of estimates of the
parameter, the function will supply the likelihood ratio test statistic for
the comparison of the full model to one where the parameter of interest is
constrained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrainFun(parameter.val, full, fm2, comp, G, mit = 600)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constrainFun_+3A_parameter.val">parameter.val</code></td>
<td>
<p>a value for which the log-Likelihood of a model is to
be calculated</p>
</td></tr>
<tr><td><code id="constrainFun_+3A_full">full</code></td>
<td>
<p>the full model <code>asreml</code> object</p>
</td></tr>
<tr><td><code id="constrainFun_+3A_fm2">fm2</code></td>
<td>
<p>starting values for the full model</p>
</td></tr>
<tr><td><code id="constrainFun_+3A_comp">comp</code></td>
<td>
<p>which variance component to constrain</p>
</td></tr>
<tr><td><code id="constrainFun_+3A_g">G</code></td>
<td>
<p>logical, indicating if the component is part of the G structure</p>
</td></tr>
<tr><td><code id="constrainFun_+3A_mit">mit</code></td>
<td>
<p>numeric, indicating maximum number of iterations for the
constrained asreml model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> of length 1 returning either a <code>numeric</code> value
corresponding to the likelihood ratio test statistic or else the missing 
value indicator <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+LRTest">LRTest</a></code>
</p>

<hr>
<h2 id='drfx'>Simulated design random effects</h2><span id='topic+drfx'></span>

<h3>Description</h3>

<p>This function simulates effects for random terms in a linear mixed model
based on design matrices. The intended purpose is for simulating
environmental effects from a pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drfx(G, fac, dataf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drfx_+3A_g">G</code></td>
<td>
<p>The variance-covariance matrix to model the effects after</p>
</td></tr>
<tr><td><code id="drfx_+3A_fac">fac</code></td>
<td>
<p>A character indicating the factor in <code>dataf</code> with which to
construct the design matrix</p>
</td></tr>
<tr><td><code id="drfx_+3A_dataf">dataf</code></td>
<td>
<p>A dataframe with <code>fac</code> in it</p>
</td></tr>
<tr><td><code id="drfx_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the internal use of <code><a href="#topic+grfx">grfx</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If G = x, where 'x' is a single number, then 'x' should still be specified
as a 1-by-1 matrix (e.g., <code>matrix(x)</code>).  Note, the G-matrix should
never have a structure which produces a correlation exactly equal to 1 or
-1.  Instead, covariances should be specified so as to create a correlation
of slightly less than (greater than) 1 (-1).  For example: 0.9999 or
-0.9999.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fx</code></td>
<td>
<p>A matrix with 'd' columns of random effects</p>
</td></tr> <tr><td><code>Z</code></td>
<td>
<p>A
design matrix (of the format 'Matrix') from which the random effects in
<code>fx</code> were assigned </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grfx">grfx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create maternal common environment effects for 2 traits
# with perfectly correlated effects
  Gmat &lt;- matrix(c(10, 7.071, 7.071, 5), 2, 2)
  cfx &lt;- drfx(G = Gmat, fac = "Dam", dataf = warcolak[1:200, ])


</code></pre>

<hr>
<h2 id='F2009'>Pedigree adapted from Fikse 2009 with genetic groups and fuzzy classification</h2><span id='topic+F2009'></span>

<h3>Description</h3>

<p>Pedigree adapted from Fikse 2009 with genetic groups and fuzzy classification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F2009
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 16 observations on the following 11 variables:
</p>

<dl>
<dt>id </dt><dd><p>a factor with levels indicating the unique individuals 
(including phantom parents) and genetic groups</p>
</dd>
<dt>dam </dt><dd><p>a factor of observed maternal identities</p>
</dd>
<dt>sire </dt><dd><p>a factor vector of observed paternal identities</p>
</dd>
<dt>damGG </dt><dd><p>a factor of maternal identities with genetic groups
inserted instead of <code>NA</code></p>
</dd>
<dt>sireGG </dt><dd><p>a factor of paternal identities with genetic groups
inserted instead of <code>NA</code></p>
</dd>
<dt>phantomDam </dt><dd><p>a factor of maternal identities with phantom parents
inserted instead of <code>NA</code></p>
</dd>
<dt>phantomSire </dt><dd><p>a factor of paternal identities with phantom parents
inserted instead of <code>NA</code></p>
</dd>
<dt>group </dt><dd><p>a factor of genetic groups to which each phantom parent
belongs</p>
</dd>
<dt>g1 </dt><dd><p>a numeric vector with probabilities of group <code>g1</code>
membership for each phantom parent</p>
</dd>
<dt>g2 </dt><dd><p>a numeric vector with probabilities of group <code>g2</code>
membership for each phantom parent</p>
</dd>
<dt>g3 </dt><dd><p>a numeric vector with probabilities of group <code>g3</code>
membership for each phantom parent</p>
</dd>
</dl>



<h3>Source</h3>

<p>Fikse, F. 2009. Fuzzy classification of phantom parent groups in an
animal model. Genetics Selection Evolution 41:42.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(F2009)
  str(F2009)
</code></pre>

<hr>
<h2 id='FG90'>Pedigree, adapted from Table 1 in Fernando &amp; Grossman (1990)</h2><span id='topic+FG90'></span>

<h3>Description</h3>

<p>Pedigree, adapted from Table 1 in Fernando &amp; Grossman (1990)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG90
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 8 observations on the following 4 variables:
</p>

<dl>
<dt>id </dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code> 
<code>5</code> <code>6</code> <code>7</code> <code>8</code></p>
</dd>
<dt>dam </dt><dd><p>a factor with levels <code>2</code> <code>4</code> <code>6</code></p>
</dd>
<dt>sire </dt><dd><p>a factor with levels <code>1</code> <code>3</code> <code>5</code></p>
</dd>
<dt>sex </dt><dd><p>a factor with levels <code>0</code> <code>1</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Fernando, R.L. &amp; M. Grossman. 1990. Genetic evaluation with
autosomal and X-chromosomal inheritance. Theoretical and Applied Genetics
80:75-80.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(FG90)
  str(FG90)
</code></pre>

<hr>
<h2 id='findDFC'>Finds the double first cousins in a pedigree</h2><span id='topic+findDFC'></span>

<h3>Description</h3>

<p>Given a pedigree, all pairs of individuals that are double first cousins are
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findDFC(
  pedigree,
  exact = FALSE,
  parallel = FALSE,
  ncores = getOption("mc.cores", 2L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findDFC_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree with columns organized: ID, Dam, Sire</p>
</td></tr>
<tr><td><code id="findDFC_+3A_exact">exact</code></td>
<td>
<p>A logical statement indicating if individuals who are exactly
double first cousins are to be identified</p>
</td></tr>
<tr><td><code id="findDFC_+3A_parallel">parallel</code></td>
<td>
<p>A logical statement indicating if parallelization should be
attempted.  Note, only reliable for Mac and Linux operating systems.</p>
</td></tr>
<tr><td><code id="findDFC_+3A_ncores">ncores</code></td>
<td>
<p>Number of cpus to use, default is maximum available</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When exact = TRUE, only those individuals whose grandparents are completely
unrelated will be identified as double first cousins.  When exact = FALSE,
as long as the parents of individuals i and j are two sets of siblings
(i.e., either sires full brothers/dams full sisters or two pairs of opposite
sex full sibs) then i and j will be considered double first cousins.  In the
event where the grandparents of i and j are also related, exact = FALSE will
still consider i and j full sibs, even though genetically they will be more
related than exact = TRUE double first cousins.
</p>
<p><code>parallel</code> = TRUE should only be used on Linux or Mac OSes (i.e., not
Windows).
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>PedPositionList </dt><dd><p>gives the list of row numbers for all the
pairs of individuals that are related as double first cousins.</p>
</dd>
<dt>DFC </dt><dd><p>gives the list of IDs, as characters, for all the pairs of 
individuals that are related as double first cousins.</p>
</dd>
<dt>FamilyCnt </dt><dd><p>If two individuals, i and j, are double first cousins,
then i's siblings will also be double first cousins with j's siblings.
Therefore, this is the total number of family pairs where offspring
are related as double first cousins.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>

<hr>
<h2 id='founderLine'>Identifies the matriline or patriline to which each individual in a pedigree
belongs</h2><span id='topic+founderLine'></span>

<h3>Description</h3>

<p>For every individual in a pedigree, the function identifies either the one
female or male ancestor that is a founder (defined here as an individual
identity in the pedigree for which both dam and sire information are
missing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>founderLine(pedigree, sex)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="founderLine_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire, Sex</p>
</td></tr>
<tr><td><code id="founderLine_+3A_sex">sex</code></td>
<td>
<p>Character indicating the column name in pedigree identifying
either the dam (for matriline) or sire (for patriline) identities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>Individuals with a missing parent for the column identified by the 'sex'
argument are assigned themselves as their founder line. Thus, the definition
of the founder population from a given pedigree is simply all individuals
with missing parents (and in this case just a single missing parent
classifies an individual as a founder).
</p>


<h3>Value</h3>

<p>A vector of length equal to the number of rows in the pedigree
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 founderLine(FG90, sex = "dam")  # matriline from this example pedigree

 #Create random pedigree, tracking the matrilines
 ## Then compare with founderLine() output
 K &lt;- 8  # No. individuals per generation (KEEP and even number)
 gen &lt;- 10 # No. of generations
 datArr &lt;- array(NA, dim = c(K, 5, gen))
 dimnames(datArr) &lt;- list(NULL, 
c("id", "dam", "sire", "sex", "matriline"), NULL)
 # initialize the data array
 datArr[, "id", ] &lt;- seq(K*gen)
 datArr[, "sex", ] &lt;- c(1, 2)
 femRow &lt;- which(datArr[, "sex", 1] == 2) # assume this is same each generation
 # (Why K should always be an even number)
 datArr[femRow, "matriline", 1] &lt;- femRow
 # males have overlapping generations, BUT females DO NOT
 for(g in 2:gen){
   datArr[, "sire", g] &lt;- sample(c(datArr[femRow-1, "id", 1:(g-1)]),
size = K, replace = TRUE)
   gdams &lt;- sample(femRow, size = K, replace = TRUE)
   datArr[, c("dam", "matriline"), g] &lt;- datArr[gdams, c("id", "matriline"), g-1]
 }
 ped &lt;- data.frame(apply(datArr, MARGIN = 2, FUN = function(x){x}))
 nrow(ped)
 #Now run founderLine() and compare
 ped$line &lt;- founderLine(ped, sex = "dam")
 stopifnot(identical(ped$matriline, ped$line),
	sum(ped$matriline-ped$line, na.rm = TRUE) == 0,
	range(ped$matriline-ped$line, na.rm = TRUE) == 0)


</code></pre>

<hr>
<h2 id='genAssign'>Generation assignment</h2><span id='topic+genAssign'></span><span id='topic+genAssign.default'></span><span id='topic+genAssign.numPed'></span>

<h3>Description</h3>

<p>Given a pedigree, the function assigns the generation number to which each
individual belongs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genAssign(pedigree, ...)

## Default S3 method:
genAssign(pedigree, ...)

## S3 method for class 'numPed'
genAssign(pedigree, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genAssign_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
<tr><td><code id="genAssign_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>0 is the base population.
</p>
<p>Migrants, or any individuals where both parents are unknown, are assigned to
generation zero.  If parents of an individual are from two different
generations (e.g., dam = 0 and sire = 1), the individual is assigned to the
generation following the greater of the two parents (e.g., 2 in this
example).
</p>


<h3>Value</h3>

<p>A vector of values is returned.  This vector is in the same order as
the ID column of the pedigree.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>

<hr>
<h2 id='geneDrop'>Functions to conduct gene dropping through a pedigree</h2><span id='topic+geneDrop'></span><span id='topic+geneDrop.default'></span><span id='topic+geneDrop.numPed'></span>

<h3>Description</h3>

<p>Functions that perform and summarize gene dropping conducted on supplied pedigrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geneDrop(
  pedigree,
  N,
  parallel = FALSE,
  ncores = getOption("mc.cores", 2L),
  ...
)

## Default S3 method:
geneDrop(
  pedigree,
  N,
  parallel = FALSE,
  ncores = getOption("mc.cores", 2L),
  ...
)

## S3 method for class 'numPed'
geneDrop(
  pedigree,
  N,
  parallel = FALSE,
  ncores = getOption("mc.cores", 2L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geneDrop_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree with columns organized: ID, Dam, Sire.</p>
</td></tr>
<tr><td><code id="geneDrop_+3A_n">N</code></td>
<td>
<p>The number of times to iteratively trace alleles through the
pedigree</p>
</td></tr>
<tr><td><code id="geneDrop_+3A_parallel">parallel</code></td>
<td>
<p>A logical indicating whether or not to use parallel
processing. Note, this may only be available for Mac and Linux operating
systems.</p>
</td></tr>
<tr><td><code id="geneDrop_+3A_ncores">ncores</code></td>
<td>
<p>The number of cpus to use when constructing the dominance
relatedness matrix. Default is all available.</p>
</td></tr>
<tr><td><code id="geneDrop_+3A_...">...</code></td>
<td>
<p>Other arguments that can be supplied to alter what summaries are
reported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA', '0'
, or '*'.
</p>
<p><code>parallel</code> = TRUE should only be used on Linux or Mac operating systems
(i.e., not Windows).
</p>
<p>Founder allelic values (the alleles assigned to an individual's maternal,
paternal, or both haplotypes when the maternal, paternal, or both parents are
missing) are equivalent positive and negative integer values corresponding to
the maternal and paternal haplotypes, respectively. For example, if the first
individual in the pedigree has two unknown parents it will have the following
two allelic values: 1=maternal haplotype and -1=paternal haplotype.
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>IDs </dt><dd><p>Original identities in the pedigree</p>
</dd>
<dt>maternal </dt><dd><p>Simulated maternal haplotypes</p>
</dd>
<dt>paternal </dt><dd><p>Simulated paternal haplotypes</p>
</dd> 
<dt>numericPedigree </dt><dd><p>Pedigree in class <code>numPed</code> for convenient
post-processing of haplotypes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeDsim">makeDsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  geneDrop(Mrode2, N = 10)

</code></pre>

<hr>
<h2 id='ggcontrib'>Genetic group contribution</h2><span id='topic+ggcontrib'></span>

<h3>Description</h3>

<p>Calculates the genomic contribution each genetic group makes to every
individual in a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggcontrib(pedigree, ggroups = NULL, fuzz = NULL, output = "matrix")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggcontrib_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
<tr><td><code id="ggcontrib_+3A_ggroups">ggroups</code></td>
<td>
<p>An optional vector of either: genetic group assignment for
every individual or just the unique genetic groups. <code>fuzz</code> must be
<code>NULL</code> if an object is supplied to the <code>ggroups</code> argument.</p>
</td></tr>
<tr><td><code id="ggcontrib_+3A_fuzz">fuzz</code></td>
<td>
<p>A matrix containing the fuzzy classification of phantom parents
into genetic groups. <code>ggroups</code> must be <code>NULL</code> if an object is
supplied to the <code>fuzz</code> argument.</p>
</td></tr>
<tr><td><code id="ggcontrib_+3A_output">output</code></td>
<td>
<p>Format for the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specification of genetic groups is done in one of two approaches, either
using fuzzy classification or not.
</p>
<p>Fuzzy classification enables phantom parents to be assigned to (potentially)
more than one genetic group (Fikse 2009). This method requires unique
phantom parent identities to be included in the pedigree for all observed
individuals with unknown parents. For 'p' phantom parents, 'p' identities
should be listed as individuals in the first 'p' rows of the pedigree and
these should be the only individuals in the pedigree with missing values in
their Dam and Sire columns (denoted by either 'NA', '0', or '*'). The matrix
supplied to the <code>fuzz</code> argument should have 'p' rows (one for each
phantom parent) and 'r' columns, where 'r' is the number of genetic groups.
</p>
<p>Non-fuzzy classification can handle the specification of genetic groups in
three formats:
</p>
<p>(1) similar to ASReml's format for specifying genetic groups, the first 'r'
rows of the pedigree (given to the <code>pedigree</code> argument) contain the
label for each genetic group in the ID column and indicate missing values
for the Dam and Sire columns (denoted by either 'NA', '0', or '*'). No
object is supplied to the <code>ggroups</code> argument. All individuals in the
pedigree must then have one of the 'r' genetic groups as parent(s) for each
unknown parent. Note, a warning message indicating <code>In
numPed(pedigree): Dams appearing as Sires</code> is expected, since the dam and
sire can be the same for all individuals in the pedigree composing the base
population of a genetic group.
</p>
<p>(2) similar to Jarrod Hadfield's <code>rbv</code> function arguments in the
<code>MCMCglmm</code> package, for a pedigree of dimension i x 3 (given to the
<code>pedigree</code> argument), where 'i' is the total number of individuals in
the pedigree, a similar vector of length 'i' is given to the <code>ggroups</code>
argument. This vector lists either the genetic group to which each
individual's phantom parents belong or NA if the individual is not to be
considered part of one of the base populations (genetic groups). NOTE, this
approach does not allow phantom dams and phantom sires of a given individual
to be from different genetic groups.
</p>
<p>(3) similar to DMU's format for specifying genetic groups. For a pedigree of
dimension i x 3 (given to the <code>pedigree</code> argument), where 'i' is the
total number of individuals in the pedigree, instead of missing values for a
parent, one of the 'r' genetic groups is specified. A character vector of
length 'r' with unique genetic group labels is given to the <code>ggroups</code>
argument. Note, that all individuals with a missing parent should have a
genetic group substituted instead of the missing value symbol (i.e., either
'NA', '0', or '*').
</p>


<h3>Value</h3>

<p>Returns i x r genetic group contributions to all 'i' individuals 
from each of the 'r' genetic groups. Default output is an object of class
<code>matrix</code> (dense), but this format can be changed (e.g., &quot;dgCMatrix&quot;
for a sparse matrix).
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Fikse, F. 2009. Fuzzy classification of phantom parent groups in
an animal model. Genetics, Selection, Evolution. 41:42.
</p>
<p>Quaas, R.L. 1988. Additive genetic model with groups and relationships.
Journal of Dairy Science. 71:1338-1345.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use the pedigree from Quaas 1988 (See `data(Q1988)`)
##########################
# Fuzzy classification
  ## Fuzzy classification with complete assignment to one group
    Q1988fuzz &lt;- Q1988[-c(1:2), c("id", "phantomDam", "phantomSire")]
    Qfnull &lt;- matrix(c(1,0,0,1,0, 0,1,1,0,1), nrow = 5, ncol = 2,
	dimnames = list(letters[1:5], c("g1", "g2")))
    (Qfuzznull &lt;- ggcontrib(Q1988fuzz, fuzz = Qfnull))

    ## Should be identical to the non-fuzzy classification output
    # format (1) from above
      (Q &lt;- ggcontrib(Q1988[-c(3:7), c(1,4,5)]))
    stopifnot(Qfuzznull == Q)

  ## Fuzzy classification with arbitrary assignments
    Qf &lt;- matrix(c(1,0,0.5,0.5,0.5, 0,1,0.5,0.5,0.5), nrow = 5, ncol = 2,
	dimnames = list(letters[1:5], c("g1", "g2")))
    (Qfuzz &lt;- ggcontrib(Q1988fuzz, fuzz = Qf))  

  ## Using the pedigree and fuzzy classification in Fikse (2009)
    F2009fuzz &lt;- data.frame(id = c(letters[1:7], LETTERS[1:6]),
	dam = c(rep(NA, 7), "a", "c", "e", "A", "C", "D"),
	sire = c(rep(NA, 7), "b", "d", "f", "B", "g", "E"))
    Ff &lt;- matrix(c(1,0,1,0,0,0,0.2,
		0,1,0,0.6,0,0.3,0.4,
		0,0,0,0.4,1,0.7,0.4),
		nrow = 7, ncol = 3,
		dimnames = list(letters[1:7], paste0("g", 1:3)))
    # Actual Q matrix printed in Fikse (2009)
      Fikse2009Q &lt;- matrix(c(0.5,0.5,0,0.5,0.1,0.3,
			0.5,0.3,0.15,0.4,0.275,0.3375, 
			0,0.2,0.85,0.1,0.625,0.3625),
		nrow = 6, ncol = 3,
		dimnames = list(LETTERS[1:6], paste0("g", seq(3))))

    Ffuzz &lt;- ggcontrib(F2009fuzz, fuzz = Ff)
      (diffFfuzz &lt;- Ffuzz - Fikse2009Q)
      # Encountering some rounding error
      stopifnot(length((drop0(diffFfuzz, tol = 1e-12))@x) == 0)


##########################
# Non-fuzzy classification
  # format (1) from above
    Q1 &lt;- Q1988[-c(3:7), c(1,4,5)]
    (gg1 &lt;- ggcontrib(Q1, ggroups = NULL)) # note the warning message which is typical

  # format (2) from above
    Q2 &lt;- Q1988[-c(1:7), 1:3]
    # arbitrarily assign individuals genetic groups for unknown parents
    ## Means gg2 is NOT comparable to gg1 or gg3!
    ggvec.in &lt;- c("g1", "g2", "g1", NA)
    (gg2 &lt;- ggcontrib(Q2, ggroups = ggvec.in))

  # format (3) from above
    Q3 &lt;- Q1988[-c(1:7), c(1,4,5)]
    gg3 &lt;- ggcontrib(Q3, ggroups = c("g1", "g2"))

  stopifnot(gg1 == gg3)

</code></pre>

<hr>
<h2 id='ggTutorial'>Simulated dataset used to analyze data with genetic group animal models</h2><span id='topic+ggTutorial'></span>

<h3>Description</h3>

<p>The dataset was simulated using the <code><a href="#topic+simGG">simGG</a></code> function so that the
pedigree contains a base population comprised of founders and non-founder
immigrants. These data are then used in the main manuscript and tutorials
accompanying Wolak &amp; Reid (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggTutorial
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 6000 observations on the following 10 
variables:
</p>

<dl>
<dt>id </dt><dd><p>an integer vector specifying the 6000 unique individual
identities</p>
</dd>
<dt>dam </dt><dd><p>an integer vector specifying the unique dam for each 
individual</p>
</dd>
<dt>sire </dt><dd><p>an integer vector specifying the unique sire for each 
individual</p>
</dd>
<dt>parAvgU </dt><dd><p>a numeric vector of the average autosomal total additive 
genetic effects (<code>u</code>) of each individual's parents</p>
</dd>
<dt>mendel </dt><dd><p>a numeric vector of the Mendelian sampling deviations 
from <code>parAvgU</code> autosomal total additive genetic effects that is 
unique to each individual</p>
</dd>
<dt>u </dt><dd><p>a numeric vector of the total autosomal additive genetic 
effects underlying <code>p</code></p>
</dd>
<dt>r </dt><dd><p>a numeric vector of the residual (environmental) effects 
underlying <code>p</code></p>
</dd>
<dt>p </dt><dd><p>a numeric vector of phenotypic values</p>
</dd>
<dt>is</dt><dd><p>an integer vector with <code>0</code> for individuals born in the 
focal population and <code>1</code> for individuals born outside of the 
focal population, but immigrated</p>
</dd>
<dt>gen </dt><dd><p>an integer vector specifying the generation in which each 
individual was born</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset was simulated as described in the &lsquo;examples&rsquo; section
using the <code><a href="#topic+simGG">simGG</a></code> function. Full details of the function and
dataset can be found in Wolak &amp; Reid (2017).
</p>
<p>The <code>data.frame</code> contains 6000 individuals across 15 generations. In
each generation, the carrying capacity is limited to 400 individuals, the
number of mating pairs limited to 200 pairs, and 40 immigrants per
generation arrive starting in the second generation.
</p>
<p>The breeding values of the founders are drawn from a normal distribution
with an expected mean of 0 and a variance of 1. The breeding values of all
immigrants are drawn from a normal distribution with an expected mean of 3
and variance of 1. Consequently, the expected difference between mean
breeding values in the founders and immigrants is 3. All individuals are
assigned a residual (environmental) deviation that is drawn from a normal
distribution with an expected mean of 0 and variance of 1.
</p>


<h3>Source</h3>

<p>Wolak, M.E. &amp; J.M. 2017. Accounting for genetic differences among
unknown parents in microevolutionary studies: how to include genetic
groups in quantitative genetic animal models. Journal of Animal Ecology
86:7-20. doi:10.1111/1365-2656.12597
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
  set.seed(102)     #&lt;-- seed value used originally
  library(nadiv)
  # create data using `simGG()`
  ggTutorial &lt;- simGG(K = 400, pairs = 200, noff = 4, g = 15,
    nimm = 40, nimmG = seq(2, 14, 1),		    # nimmG default value
    VAf = 1, VAi = 1, VRf = 1, VRi = 1,		    # all default values
    mup = 20, muf = 0, mui = 3, murf = 0, muri = 0, # mup and mui non-default values
    d_bvf = 0, d_bvi = 0, d_rf = 0, d_ri = 0)	    # all default values
 

</code></pre>

<hr>
<h2 id='grfx'>Simulated genetic random effects</h2><span id='topic+grfx'></span>

<h3>Description</h3>

<p>This function simulates effects for random terms in a linear mixed model
based on relatedness matrices. The intended purpose is for simulating
genetic and environmental effects from a pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grfx(n, G, incidence = NULL, output = "matrix", stdnorms = NULL, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grfx_+3A_n">n</code></td>
<td>
<p>The number of individuals for which to simulate effects</p>
</td></tr>
<tr><td><code id="grfx_+3A_g">G</code></td>
<td>
<p>The variance-covariance matrix to model the effects after</p>
</td></tr>
<tr><td><code id="grfx_+3A_incidence">incidence</code></td>
<td>
<p>A matrix of the covariance structure of the 'n' individuals
or the Cholesky factorization of class <code>CHMfactor</code> for this structure.</p>
</td></tr>
<tr><td><code id="grfx_+3A_output">output</code></td>
<td>
<p>Format for the output</p>
</td></tr>
<tr><td><code id="grfx_+3A_stdnorms">stdnorms</code></td>
<td>
<p>Standard normal deviates to use</p>
</td></tr>
<tr><td><code id="grfx_+3A_warn">warn</code></td>
<td>
<p>Should a warning message be produced when the function interprets
what to do based on the object class supplied to <code>incidence</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total number of effects simulated will be n*d, where d is the number of
columns in the 'G' matrix. The standard normal deviates can be supplied
instead of generated within the function when <code>stdnorms != NULL</code>. The
length of this vector must be <code>n*nrow(G)</code>.
</p>
<p>Supplied incidence matrices should be n-by-n symmetric matrices or cholesky
factorizations that resulted from a call to <code>Matrix::Cholesky()</code>.  For
simulated random effects using design matrices, see <code><a href="#topic+drfx">drfx</a></code>.  If
no incidence matrix is supplied, <code>incidence = NULL</code>, the Identity matrix
is used, which assumes that all 'n' random effects are independently and
identically distributed (default to Identity matrix).
</p>
<p>See examples for how to make and use a Cholesky factorized incidence matrix,
for instance in a Monte Carlo simulation. Whether such an approach results
in performance of speed improvements within the Monte Carlo simulation, by
avoiding a Cholesky decomposition of a large matrix at each iteration, has
not been tested. Setting <code>warn = FALSE</code> will suppress the warnings that
the function is assuming a Cholesky factorization is contained in the object
supplied to the <code>incidence</code> argument. Currently, Cholesky factorizations
must inherit from the class &ldquo;CHMfactor&rdquo;.
</p>
<p>If G = x, where 'x' is a single number, then 'x' should still be specified
as a 1-by-1 matrix (e.g., <code>matrix(x)</code>).  Note, the G-matrix should
never have a structure which produces a correlation exactly equal to 1 or
-1.  Instead, covariances should be specified so as to create a correlation
of slightly less than (greater than) 1 (-1).  For example: 0.9999 or
-0.9999.
</p>


<h3>Value</h3>

<p>The random effects coerced to be in the format specified by output.
The default is a &quot;matrix&quot;.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm</a></code>, <code><a href="#topic+drfx">drfx</a></code>,
<code><a href="#topic+makeA">makeA</a></code>, <code><a href="#topic+makeAA">makeAA</a></code>, <code><a href="#topic+makeD">makeD</a></code>,
<code><a href="#topic+makeDomEpi">makeDomEpi</a></code>, <code><a href="#topic+makeDsim">makeDsim</a></code>, <code><a href="#topic+makeS">makeS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create additive genetic breeding values for 2 uncorrelated traits
# with different additive genetic variances
  A &lt;- makeA(warcolak[1:200, 1:3])
  Gmat &lt;- matrix(c(20, 0, 0, 10), 2, 2)
  breedingValues &lt;- grfx(n = 200, G = Gmat, incidence = A)

 # Now with a user supplied set of standard normal deviates
  snorms &lt;- rnorm(nrow(warcolak[1:200,]) * ncol(Gmat))
  breedingValues2a &lt;- grfx(n = 200, G = Gmat, incidence = A, stdnorms = snorms)
  breedingValues2b &lt;- grfx(n = 200, G = Gmat, incidence = A, stdnorms = snorms)
  identical(breedingValues2a, breedingValues2b)  #&lt;-- TRUE
  var(breedingValues2a)
  var(breedingValues2b)

 # User supplied Cholesky factorization of the incidence matrix from above
  cA &lt;- Cholesky(A, LDL = FALSE, super = FALSE) 
    inherits(cA, "CHMfactor")  #&lt;-- TRUE
  breedingValues3 &lt;- grfx(n = 200, G = Gmat, incidence = cA, stdnorms = snorms)
  all.equal(breedingValues2a, breedingValues3)  #&lt;-- TRUE
</code></pre>

<hr>
<h2 id='LRTest'>log-Likelihood Ratio Test</h2><span id='topic+LRTest'></span>

<h3>Description</h3>

<p>Test the null hypothesis that the two models fit the data equally well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRTest(full, reduced, df = 1, boundaryCorrection = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LRTest_+3A_full">full</code></td>
<td>
<p>A numeric variable indicating the log-likelihood of the full
model</p>
</td></tr>
<tr><td><code id="LRTest_+3A_reduced">reduced</code></td>
<td>
<p>A numeric variable indicating the log-likelihood of the
reduced model</p>
</td></tr>
<tr><td><code id="LRTest_+3A_df">df</code></td>
<td>
<p>The number of degrees of freedom to use, representing the
difference between the full and reduced model in the number of parameters
estimated</p>
</td></tr>
<tr><td><code id="LRTest_+3A_boundarycorrection">boundaryCorrection</code></td>
<td>
<p>A logical argument indicating whether a boundary
correction under one degree of freedom should be included. If the parameter
that is dropped from the reduced model is estimated at the boundary of its
parameter space in the full model, the boundary correction is often
required. See Details for more.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Boundary correction should be applied if the parameter that is dropped from
the full model was on the boundary of its parameter space. In this instance,
the distribution of the log-likelihood ratio test statistic is approximated
by a mix of chi-square distributions (Self and Liang 1987). A <code>TRUE</code>
value will implement the boundary correction for a one degree of freedom
test. This is equivalent to halving the p-value from a test using a
chi-square distribution with one degree of freedom (Dominicus et al. 2006).
</p>
<p>Currently, the test assumes that both log-likelihoods are negative or both
are positive and will stop if they are of opposite sign. The interpretation
is that the model with a greater negative log-likelihood (closer to zero) or
greater positive log-likelihood provides a better fit to the data.
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>lambda </dt><dd><p>a numeric log-likelihood ratio test statistic</p>
</dd>
<dt>Pval </dt><dd><p>a numeric p-value given the <code>lambda</code> tested against a
chi-squared distribution with the number of degrees of freedom as
specified. May have had a boundary correction applied.</p>
</dd> 
<dt>corrected.Pval </dt><dd><p>a logical indicating if the p-value was derived 
using a boundary correction. See <code>Details</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Self, S. G., and K. Y. Liang. 1987. Asymptotic properties of
maximum likelihood estimators and likelihood ratio tests under nonstandard
conditions. Journal of the American Statistical Association 82:605-610.
</p>
<p>Dominicus, A., A. Skrondal, H. K. Gjessing, N. L. Pedersen, and J. Palmgren.
2006. Likelihood ratio tests in behavioral genetics: problems and solutions.
Behavior Genetics 36:331-340.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constrainFun">constrainFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# No boundary correction
(noBC &lt;- LRTest(full = -2254.148, reduced = -2258.210,
	df = 1, boundaryCorrection = FALSE))
# No boundary correction
(withBC &lt;- LRTest(full = -2254.148, reduced = -2258.210,
	df = 1, boundaryCorrection = TRUE))
stopifnot(noBC$Pval == 2*withBC$Pval)

</code></pre>

<hr>
<h2 id='makeA'>Creates the additive genetic relationship matrix</h2><span id='topic+makeA'></span>

<h3>Description</h3>

<p>This returns the additive relationship matrix in sparse matrix format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeA(pedigree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeA_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>Used as a support function to <code><a href="#topic+makeD">makeD</a></code>.
</p>
<p>See function <code><a href="#topic+makeAinv">makeAinv</a></code> for directly obtaining the inverse of
the additive genetic relationship matrix.
</p>


<h3>Value</h3>

<p>Returns A, or the numerator relationship matrix, in sparse 
matrix form.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeD">makeD</a></code>, <code><a href="#topic+makeS">makeS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 makeA(Mrode2)

</code></pre>

<hr>
<h2 id='makeAA'>Creates the additive by additive epistatic genetic relationship matrix</h2><span id='topic+makeAA'></span>

<h3>Description</h3>

<p>Given a pedigree, the matrix of additive by additive genetic relatedness
(AA) among all individuals in the pedigree is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAA(pedigree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeAA_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>The function first estimates the A matrix using <code><a href="#topic+makeA">makeA</a></code>, then it
calculates the Hadamard (element-wise) product of the A matrix with itself
(A # A).
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>AA </dt><dd><p>the AA matrix in sparse matrix form</p>
</dd>
<dt>logDet </dt><dd><p>the log determinant of the AA matrix</p>
</dd>
<dt>AAinv </dt><dd><p>the inverse of the AA matrix in sparse matrix form</p>
</dd>
<dt>listAAinv </dt><dd><p>the three column form of the non-zero elements for the
inverse of the AA matrix</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeA">makeA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  makeAA(Mrode2)

</code></pre>

<hr>
<h2 id='makeAinv'>Creates the inverse additive genetic relationship matrix</h2><span id='topic+makeAinv'></span><span id='topic+makeAinv.default'></span><span id='topic+makeAinv.fuzzy'></span><span id='topic+makeGGAinv'></span>

<h3>Description</h3>

<p>This returns the inverse of the numerator relationship matrix (inverse
additive genetic relatedness matrix). It can also be used to obtain
coefficients of inbreeding for the pedigreed population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAinv(
  pedigree,
  f = NULL,
  ggroups = NULL,
  fuzz = NULL,
  gOnTop = FALSE,
  det = TRUE,
  ...
)

## Default S3 method:
makeAinv(
  pedigree,
  f = NULL,
  ggroups = NULL,
  fuzz = NULL,
  gOnTop = FALSE,
  det = TRUE,
  ...
)

## S3 method for class 'fuzzy'
makeAinv(
  pedigree,
  f = NULL,
  ggroups = NULL,
  fuzz,
  gOnTop = FALSE,
  det = TRUE,
  ...
)

makeGGAinv(pedigree, f = NULL, ggroups = NULL, det = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeAinv_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
<tr><td><code id="makeAinv_+3A_f">f</code></td>
<td>
<p>A numeric indicating the level of inbreeding. See Details</p>
</td></tr>
<tr><td><code id="makeAinv_+3A_ggroups">ggroups</code></td>
<td>
<p>Either a vector with the unique name of each genetic group,
or a numeric indicating the number of unique genetic groups. See Details 
for different ways to specify. Note, if NULL then the regular A-inverse
will be constructed. Also, must be NULL if fuzz is non-NULL.</p>
</td></tr>
<tr><td><code id="makeAinv_+3A_fuzz">fuzz</code></td>
<td>
<p>A matrix containing the fuzzy classification of phantom parents
into genetic groups. See Details.</p>
</td></tr>
<tr><td><code id="makeAinv_+3A_gontop">gOnTop</code></td>
<td>
<p>A logical indicating if (when including genetic groups) the
A-inverse should be constructed with the &lsquo;g&rsquo; genetic groups located 
in the first &lsquo;g&rsquo; rows and columns if <code>TRUE</code>, else the
&lsquo;g&rsquo; genetic groups are located in the last &lsquo;g&rsquo; rows and 
columns of A-inverse</p>
</td></tr>
<tr><td><code id="makeAinv_+3A_det">det</code></td>
<td>
<p>Logical, indicating if the (log) determinant of the A matrix
should be returned</p>
</td></tr>
<tr><td><code id="makeAinv_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>The functions implement an adaptation of the Meuwissen and Luo (1992)
algorithm (particularly, following the description of the algorithm in
Mrode 2005) with some code borrowed from the <code>inverseA</code> function by
Jarrod Hadfield in the <code>MCMCglmm</code> package. Further, providing a
non-NULL argument to <code>ggroups</code> incorporates the Quaas (1988) algorithm
for directly obtaining the augmented A-inverse matrix for genetic groups
into Meuwissen and Luo's (1992) algorithm, thereby, considering inbreeding
during the construction of the A-inverse. Further calculations needed for
the algorithm to incorporate inbreeding and genetic groups follow the theory
presented in VanRaden (1992). Alternatively, group-specific inverse
relatedness matrices can be formed with <code>makeGGAinv</code>, see below.
</p>
<p>At the moment, providing the inbreeding level of individuals or the base
population has not been implemented. However, this argument is a placeholder
for now.
</p>
<p>Genetic groups can be incorporated into a single A-inverse by providing a value
to the <code>ggroups</code> argument in <code>makeAinv</code>. The value supplied to
<code>ggroups</code> can either be (1) a single integer indicating the number of
unique genetic groups or (2) a character vector containing the name for each
genetic group. These are referred to as pedigree types &quot;A&quot; and &quot;D&quot;,
respectively, and further details follow below.
</p>
<p>(Type=&quot;A&quot;) the pedigree contains unique IDs for the 'g' genetic groups in the
first 'g' lines of the pedigree. The dam and sire of the genetic group rows
should contain missing values (e.g., NA, &quot;0&quot;, or &quot;*&quot;). All individuals in the
pedigree should then have one of the &lsquo;g&rsquo; genetic groups instead of an unknown
parent.
(Type=&quot;D&quot;) the pedigree contains only individuals in the ID column (no
genetic groups have an ID) and there should be no missing values for any dams
or sires. Instead, individuals for whom the dam and/or sire is unknown should
have one of the genetic groups identified in the vector supplied to
<code>ggroups</code> as the dam or sire.
</p>
<p>&lsquo;Fuzzy classification&rsquo; of genetic groups (Fikse 2009) can be
implemented if a &lsquo;matrix&rsquo; (of class <code>matrix</code> or <code>Matrix</code>)
is supplied to the <code>fuzzy</code> argument. The fuzzy classification matrix
must have row names matching all of the phantom parents in the pedigree and
the column names must be present and specify the genetic groups. The fuzzy
classification matrix essentially contains probability of group membership
for each phantom parent. Therefore, each row should sum to 1. The pedigree
must have an identity in a unique row for every phantom parent and cannot
have genetic groups as either identities (in the first column) or as dam or
sire (second and third columns). Further, if fuzzy classification is
desired, the function must specify <code>ggroups = NULL</code>.
</p>
<p>When genetic groups (including the case of fuzzy classification of genetic
groups) are included in the A-inverse matrix, the argument to <code>gOnTop</code>
specifies if the genetic group elements in the A-inverse should occupy the
top-left (<code>gOnTop = TRUE</code>) or bottom-right (<code>gOnTop = FALSE</code>) of
the matrix. Depending on how the software implementing an animal model
solves the mixed model equations, the equations for the genetic groups (and
thus the elements in the augmented A-inverse) should be the first or last
set of equations.
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>Ainv </dt><dd><p>the inverse of the additive genetic relationship matrix
in sparse matrix form</p>
</dd>
<dt>listAinv </dt><dd><p>the three column list of the non-zero elements for the 
inverse of the additive genetic relationship matrix with attributes
<code>rowNames</code> and <code>geneticGroups</code>. <code>attr(*, "rowNames")</code>
links the integer for rows/columns to the ID column from the pedigree. 
<code>attr(*, "geneticGroups")</code> is a two element vector with the first 
integer indicating how many genetic groups are included in the 
pedigree. This last attribute is necessary for some software programs 
to correctly specify the residual degrees of freedom when calculating 
the log-likelihood in a model that implicitly fits fixed genetic group 
effects.</p>
</dd>
<dt>f </dt><dd><p>the individual coefficients of inbreeding for each individual 
in the pedigree (matches the order of the first/ID column of the
pedigree). If the pedigree contains &lsquo;g&rsquo; genetic groups in the 
first &lsquo;g&rsquo; rows, then the first &lsquo;g&rsquo; elements of <code>f</code> 
are assigned 0. If the pedigree contains &lsquo;p&rsquo; phantom parents in 
the first &lsquo;p&rsquo; rows, then the first &lsquo;p&rsquo; elements of
<code>f</code> are assigned 0.</p>
</dd>
<dt>logDet </dt><dd><p>the log determinant of the A matrix</p>
</dd>
<dt>dii </dt><dd><p>the (non-zero) elements of the diagonal D matrix of the A=TDT'
decomposition. Contains the variance of Mendelian sampling. Matches
the order of the first/ID column of the pedigree. If the pedigree
contains &lsquo;g&rsquo; genetic groups in the first &lsquo;g&rsquo; rows, then
the first &lsquo;g&rsquo; elements of <code>f</code> are assigned 0. If the
pedigree contains &lsquo;p&rsquo; phantom parents in the first &lsquo;p&rsquo;
rows, then the first &lsquo;p&rsquo; elements of <code>f</code> are assigned 0.</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Fikse, F. 2009. Fuzzy classification of phantom parent groups in
an animal model. Genetics Selection Evolution 41:42.
</p>
<p>Meuwissen, T.H.E &amp; Luo, Z. 1992. Computing inbreeding coefficients in large
populations. Genetics, Selection, Evolution. 24:305-313.
</p>
<p>Mrode, R.A. 2005. Linear Models for the Prediction of Animal Breeding
Values, 2nd ed.  Cambridge, MA: CABI Publishing.
</p>
<p>Quaas, R.L. 1988. Additive genetic model with groups and relationships.
Journal of Dairy Science. 71:1338-1345.
</p>
<p>VanRaden, P.M. 1992. Accounting for inbreeding and crossbreeding in genetic
evaluation of large populations. Journal of Dairy Science. 75:3136-3144.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeAstarMult">makeAstarMult</a></code>, <code><a href="#topic+makeA">makeA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ##  Without genetic groups  ##
 makeAinv(Mrode2)
 
 ##  With genetic groups  ##
  ## Type A
   typeAped &lt;- Q1988[-c(3:7), c("id", "damGG", "sireGG")]
   AstarA &lt;- makeAinv(typeAped, ggroups = 2, gOnTop = FALSE)$Ainv
  ## Type D
   typeDped &lt;- Q1988[-c(1:7), c("id", "damGG", "sireGG")]
   AstarD &lt;- makeAinv(typeDped, ggroups = c("g1", "g2"), gOnTop = FALSE)$Ainv
  stopifnot(identical(AstarA, AstarD))
  
  # Show that the augmented A-inverse with genetic groups
  # contains the normal A-inverse (i.e., without genetic groups)
   ## Augmented A-inverse with genetic groups
    ggAinv &lt;- makeAinv(Mrode3[-c(1,2), c("calf", "damGG", "sireGG")],
	ggroups = c("g1", "g2"), gOnTop = FALSE)$Ainv
    noggAinv &lt;- makeAinv(Mrode3[-c(1,2), c("calf", "dam", "sire")],
	ggroups = NULL)$Ainv
    # First 8 rows &amp; columns of ggAinv are same as A-inverse without 
    ## genetic groups
    ggAinv[1:8, 1:8]
    noggAinv
   stopifnot(all.equal(ggAinv[1:8, 1:8], structure(noggAinv, geneticGroups = NULL)))
   
 ##  With fuzzy classification of genetic groups  ##
  ## example in Fikse (2009)
  Fped &lt;- F2009[-c(1:3), c("id", "phantomDam", "phantomSire")]
    Fped$id &lt;- factor(Fped$id, levels = as.character(unique(Fped$id)))
  Ffuzz &lt;- as.matrix(F2009[4:10, c("g1", "g2", "g3")])
    dimnames(Ffuzz)[[1]] &lt;- as.character(F2009[4:10, 1])
  AstarF &lt;- makeAinv(Fped, fuzz = Ffuzz, gOnTop = FALSE)$Ainv

  ## Show that A-inverse with fuzzy classification of genetic groups
  ### can be the same as genetic group A-inverse without fuzzy classification
  ### Create a 'null' fuzzy classification matrix for Q1988 pedigree
  QfuzzNull &lt;- matrix(c(1,0,0,1,0, 0,1,1,0,1), nrow = 5, ncol = 2,
	dimnames = list(letters[1:5], c("g1", "g2")))
  typeFped &lt;- Q1988[-c(1:2), c("id", "phantomDam", "phantomSire")]
  AstarNullFuzzy &lt;- makeAinv(typeFped, fuzz = QfuzzNull, gOnTop = FALSE)$Ainv
  # Same as above using either pedigree type 'A' or 'D'
  stopifnot(identical(AstarNullFuzzy, AstarA),
	identical(AstarNullFuzzy, AstarD))

 ##  With genetic groups  ##
  ## Type A
   typeAped &lt;- Q1988[-c(3:7), c("id", "damGG", "sireGG")]
   (AinvOutA &lt;- makeGGAinv(typeAped, ggroups = 2)$Ainv)
  ## Type D
   typeDped &lt;- Q1988[-c(1:7), c("id", "damGG", "sireGG")]
   (AinvOutD &lt;- makeGGAinv(typeDped, ggroups = c("g1", "g2"))$Ainv)
  stopifnot(identical(AinvOutA, AinvOutD))

</code></pre>

<hr>
<h2 id='makeAstarMult'>Creates the inverse additive genetic relationship matrix with genetic groups</h2><span id='topic+makeAstarMult'></span>

<h3>Description</h3>

<p>This returns the inverse of the additive genetic relationship matrix with
genetic groups (A*). The matrix is set up through matrix multiplication of
two sub-matrices instead of directly (as <code><a href="#topic+makeAinv">makeAinv</a></code> does).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAstarMult(pedigree, ggroups, fuzz = NULL, gOnTop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeAstarMult_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
<tr><td><code id="makeAstarMult_+3A_ggroups">ggroups</code></td>
<td>
<p>Either a vector with the unique name of each genetic group,
or a numeric indicating the number of unique genetic groups. See Details 
for different ways to specify. Note, cannot be NULL.</p>
</td></tr>
<tr><td><code id="makeAstarMult_+3A_fuzz">fuzz</code></td>
<td>
<p>A matrix containing the fuzzy classification of individuals into
genetic groups.</p>
</td></tr>
<tr><td><code id="makeAstarMult_+3A_gontop">gOnTop</code></td>
<td>
<p>A logical indicating if the A-inverse should be constructed
with the &lsquo;g&rsquo; genetic groups located in the first &lsquo;g&rsquo; rows 
and columns if TRUE, else the &lsquo;g&rsquo; genetic groups are located in the 
last &lsquo;g&rsquo; rows and columns of A-inverse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>The function implements the matrix multiplication, using sub-matrices
<code>Q</code> and <code>A^-1</code>, as detailed in Quaas (1988, pp. 1342-1343).
</p>
<p>Genetic groups can be incorporated into the A-inverse by providing a value
to the <code>ggroups</code> argument. The value supplied to <code>ggroups</code> can
either be (1) a single integer indicating the number of unique genetic
groups or (2) a character vector containing the name for each genetic group.
These are referred to as pedigree types &quot;A&quot; and &quot;D&quot;, respectively, and
further details follow below.  (Type=&quot;A&quot;) the pedigree contains unique IDs
for the 'g' genetic groups in the first 'g' lines of the pedigree. The dam
and sire of the genetic group rows should contain missing values (e.g., NA,
&quot;0&quot;, or &quot;*&quot;). All individuals in the pedigree should then have one of the
'g' genetic groups instead of an unknown parent.  (Type=&quot;D&quot;) the pedigree
contains only individuals in the ID column (no genetic groups have an ID)
and there should be no missing values for any dams or sires. Instead,
individuals for whom the dam and/or sire is unknown should have one of the
genetic groups identified in the vector supplied to <code>ggroups</code> as the
dam or sire.
</p>
<p>Fuzzy classification of genetic groups is implemented when <code>fuzz</code> is
non-NULL.
</p>
<p>The argument to <code>gOnTop</code> specifies if the elements in the A-inverse
should come at the beginning (<code>gOnTop = TRUE</code>) or end (<code>gOnTop =
FALSE</code>) of the matrix. Depending on how the software implementing an animal
model solves the mixed model equations, the equations for the genetic groups
(and thus the elements in the augmented A-inverse) should be the first or
last set of equations.
</p>
<p>See function <code><a href="#topic+makeAinv">makeAinv</a></code> for directly obtaining the inverse of
the additive genetic relationship matrix with genetic groups.
</p>


<h3>Value</h3>

<p>Returns A*, or the inverse of the numerator relationship with
groups, in sparse matrix form.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Quaas, R.L. 1988. Additive genetic model with groups and
relationships. Journal of Dairy Science. 71:1338-1345.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeAinv">makeAinv</a></code>, <code><a href="#topic+ggcontrib">ggcontrib</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Using the Q1988 dataset in nadiv
 ## assign a null fuzzy classification matrix
 QfuzzNull &lt;- matrix(c(1,0,0,1,0, 0,1,1,0,1), nrow = 5, ncol = 2,
	dimnames = list(letters[1:5], c("g1", "g2")))

 # Type A
 ## no fuzzy classification
  Astar_A &lt;- makeAstarMult(Q1988[-c(3:7), c(1,4,5)], ggroups = 2)
 ## with fuzzy classification
  Astar_Afuzzy &lt;- makeAstarMult(Q1988[, c(1, 6, 7)],
	ggroups = 2, fuzz = QfuzzNull)

 # Type D
 ## no fuzzy classification
  Astar_D &lt;- makeAstarMult(Q1988[-c(1:7), c(1, 4, 5)], ggroups = c("g1", "g2"))
 ## with fuzzy classification
  Astar_Dfuzzy &lt;- makeAstarMult(Q1988[-c(1:2), c(1, 6, 7)],
	ggroups = c("g1", "g2"), fuzz = QfuzzNull)


 # Obtain the matrix directly 
 ## no fuzzy classification
 Astar_direct &lt;- makeAinv(Q1988[-c(3:7), c(1,4,5)], ggroups = 2)$Ainv
 stopifnot(length(drop0(round(Astar_direct
	- (Astar_A - Astar_Afuzzy)
	- (Astar_D - Astar_Dfuzzy)
	- Astar_direct, 10))@x) == 0)

 ## with fuzzy classification
 Astar_directF &lt;- makeAinv(Q1988[-c(1:2), c(1, 6, 7)], fuzz = QfuzzNull)$Ainv
 stopifnot(length(drop0(round(Astar_directF
	- (Astar_A - Astar_Afuzzy)
	- (Astar_D - Astar_Dfuzzy)
	- Astar_direct, 10))@x) == 0)
 

</code></pre>

<hr>
<h2 id='makeD'>Create the dominance genetic relationship matrix</h2><span id='topic+makeD'></span><span id='topic+makeSd'></span>

<h3>Description</h3>

<p>Given a pedigree, the matrix of coefficients of fraternity are returned -
the D matrix for autosomes and the Sd matrix for sex chromosomes. Note,
inbreeding is not directly incorporated into the calculation of the
coefficients (see Details). Functions will return the inverses of the D and
Sd matrices by default, otherwise this operation can be skipped if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeD(
  pedigree,
  parallel = FALSE,
  ncores = getOption("mc.cores", 2L),
  invertD = TRUE,
  returnA = FALSE,
  det = TRUE,
  verbose = TRUE
)

makeSd(
  pedigree,
  heterogametic,
  DosageComp = c(NULL, "ngdc", "hori", "hedo", "hoha", "hopi"),
  parallel = FALSE,
  ncores = getOption("mc.cores", 2L),
  invertSd = TRUE,
  returnS = FALSE,
  det = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeD_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree with columns organized: ID, Dam, Sire. For use
with <code>makeSd</code>, a fourth column indicates the sex of each individual in
the pedigree.</p>
</td></tr>
<tr><td><code id="makeD_+3A_parallel">parallel</code></td>
<td>
<p>Logical, indicating whether computation should be run on
multiple processors at once. See details for considerations.</p>
</td></tr>
<tr><td><code id="makeD_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use when parallel = TRUE.  Default is
maximum available.  Otherwise, set with an integer. See details for
considerations.</p>
</td></tr>
<tr><td><code id="makeD_+3A_invertd">invertD</code>, <code id="makeD_+3A_invertsd">invertSd</code></td>
<td>
<p>A logical indicating whether or not to invert the D
or S matrix</p>
</td></tr>
<tr><td><code id="makeD_+3A_returna">returnA</code>, <code id="makeD_+3A_returns">returnS</code></td>
<td>
<p>Logical, indicating if the numerator relationship
matrix (A or S) should be stored and returned.</p>
</td></tr>
<tr><td><code id="makeD_+3A_det">det</code></td>
<td>
<p>Logical, indicating if the determinant of the D or Sd matrix
should be returned.</p>
</td></tr>
<tr><td><code id="makeD_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating if progress messages should be displayed.</p>
</td></tr>
<tr><td><code id="makeD_+3A_heterogametic">heterogametic</code></td>
<td>
<p>Character indicating the label corresponding to the
heterogametic sex used in the &quot;Sex&quot; column of the pedigree</p>
</td></tr>
<tr><td><code id="makeD_+3A_dosagecomp">DosageComp</code></td>
<td>
<p>A character indicating which model of dosage compensation.
If <code>NULL</code> then the &ldquo;ngdc&rdquo; model is assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>There exists no convenient method of obtaining the inverse of the dominance
genetic relatedness matrix (or the D matrix itself) directly from a pedigree
(such as for the inverse of A, i.e., Quaas (1995)). Therefore, these
functions computes the coefficient of fraternity (Lynch and Walsh, 1998) for
every individual in the pedigree with a non-zero additive genetic
relatedness in the case of autosomes (<code>makeD</code>) or for the homogametic
sex only in the case of sex chromosomes (<code>makeSd</code>, because the
heterogametic sex has only one copy of the shared sex chromosome and
therefore cannot express dominance allelic interactions).
</p>
<p>The coefficients of fraternity are only approximations that assume no
inbreeding. The algorithm used here, however, incorporates inbreeding into
the calculation of coefficients of coancestry (using 'makeA()') that are
used to calculate coefficients of fraternity. Similarly, the diagonals of
the D and Sd matrices are corrected for inbreeding. Meaning, the diagonals
of D and Sd are (1-f) so that the overall dominance genetic variance is
equal to (1-f)V_D, where f is the coefficient of inbreeding and V_D is
dominance genetic variance. This is interpreted as the amount of dominance
genetic variance that would be expected if the allele frequencies in the
inbred population were representative of a non-inbred, randomly mating
population (Shaw et al. 1998; Wolak and Keller 2014). Note, the construction
of the D matrix is more computationally demanding (in computing time and
space requirements) than is the construction of A. This is possibly also the
case for construction of Sd in comparison to the S matrix.
</p>
<p>To overcome the computational difficulties, this function can enable
parallel processing (see package <code>parallel</code> included in the R
distribution) to speed up the execution. Note this is not be possible on
Windows (See <code>parallel</code> documentation for further information),
therefore <code>parallel</code> = TRUE should only be used on Linux or Mac
operating systems (i.e., not Windows). The default is to use the maximum
number of cpus available to the machine, but this can be restricted by
indicating the number desired in the argument <code>ncores</code>. Setting up the
multi-processing takes some overhead, so no real advantage is gained for
small pedigrees. Also, since all processes are sharing a fixed amount of
RAM, very large pedigrees using many processes in parallel may not be
feasible due to RAM restrictions (i.e., if each process needs &quot;n&quot; amount of
RAM to run, then <code>ncores</code> should be set to = total RAM/n). Otherwise
the machine can become overworked.
</p>
<p>Note, for very large pedigrees <code>returnA</code> or <code>returnS</code> should be
set to FALSE to avoid drastically increasing the memory requirements while
making D or Sd, respectively. When this occurs, 'NULL' is returned for the
element of 'A' in the output of <code>makeD</code> or for the element of 'S' in
the output of <code>makeSd</code>.
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>A,S </dt><dd><p>the A or S matrix in sparse matrix form</p>
</dd>
<dt>D,Sd </dt><dd><p>the D or Sd matrix in sparse matrix form</p>
</dd>
<dt>logDet </dt><dd><p>the log determinant of the D or Sd matrix</p>
</dd> 
<dt>Dinv,Sdinv </dt><dd><p>the inverse of the D or inverse of the Sd matrix in
sparse matrix form</p>
</dd>
<dt>listDinv,listSdinv </dt><dd><p>the three column form of the non-zero 
elements for the inverse of the D or the inverse of the Sd matrix</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Quaas, R.L. 1995. Fx algorithms. An unpublished note.
</p>
<p>Lynch M., &amp; Walsh, B. 1998. Genetics and Analysis of Quantitative Traits.
Sinauer, Sunderland, Massachusetts.
</p>
<p>Shaw, R.G., D.L. Byers, and F.H. Shaw. 1998. Genetic components of variation
in Nemophila menziesii undergoing inbreeding: Morphology and flowering time.
Genetics. 150:1649-1661.
</p>
<p>Wolak, M.E. and L.F. Keller. 2014. Dominance genetic variance and inbreeding
in natural populations. In Quantitative Genetics in the Wild, A.
Charmantier, L.E.B. Kruuk, and D. Garant eds. Oxford University Press, pp.
104-127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeDsim">makeDsim</a></code>, <code><a href="#topic+makeSdsim">makeSdsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  DinvMat &lt;- makeD(Mrode9, parallel = FALSE)$Dinv

  SdinvMat &lt;- makeSd(FG90, heterogametic = "0", parallel = FALSE)$Sdinv
  # Check to make sure getting correct elements
  ## `simPedDFC()` for pedigree with 4 unique sex-linked dominance relatedness values
  uSdx &lt;- unique(makeSd(simPedDFC(3), heterogametic = "M", returnS = FALSE)$Sd@x)
  stopifnot(all(uSdx %in% c(1, 0.5, 3/16, 1/16))) #&lt;-- must match one of these 4

</code></pre>

<hr>
<h2 id='makeDomEpi'>Creates the additive by dominance and dominance by dominance epistatic
genetic relationship matrices</h2><span id='topic+makeDomEpi'></span>

<h3>Description</h3>

<p>Given a pedigree, the matrix of additive by dominance (AD) genetic
relatedness, dominance by dominance (DD) genetic relatedness, or both are
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDomEpi(
  pedigree,
  output = c("AD", "DD", "both"),
  parallel = FALSE,
  invertD = FALSE,
  det = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeDomEpi_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
<tr><td><code id="makeDomEpi_+3A_output">output</code></td>
<td>
<p>Character(s) denoting which matrix and its inverse is to be
constructed.</p>
</td></tr>
<tr><td><code id="makeDomEpi_+3A_parallel">parallel</code></td>
<td>
<p>A logical indicating whether or not to use parallel
processing. Note, this may only be available on Mac and Linux operating
systems.</p>
</td></tr>
<tr><td><code id="makeDomEpi_+3A_invertd">invertD</code></td>
<td>
<p>A logical indicating whether or not to invert the D matrix</p>
</td></tr>
<tr><td><code id="makeDomEpi_+3A_det">det</code></td>
<td>
<p>A logical indicating whether or not to return the determinants
for the epistatic relationship matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>Because of the computational demands of constructing the D matrix (see
<code><a href="#topic+makeD">makeD</a></code>), this function allows for the inverses that are derived
from the D matrix (i.e., D-inverse, AD-inverse, and DD-inverse)to be
constructed at the same time.  This way, the D matrix will only have to be
constructed once for use in the three separate genetic relatedness inverse
matrices that depend upon it.  However, using the <code>output</code> and
<code>invertD</code> options in different combinations will ensure that only the
desired matrix inverses are constructed.
</p>
<p><code>parallel</code> = TRUE should only be used on Linux or Mac OSes (i.e., not
Windows).
</p>
<p>Both the AD and DD matrix are computed from the Hadamard product of the
respective matrices (see also, <code><a href="#topic+makeAA">makeAA</a></code>).
</p>


<h3>Value</h3>

<p>All of the following will be returned. However, the values of the
<code>output</code> and <code>invertD</code> options passed to the function will
determine which of the following are not NULL objects within the list:
</p>
 
<dl>
<dt>D </dt><dd><p>the D matrix in sparse matrix form</p>
</dd>
<dt>logDetD </dt><dd><p>the log determinant of the D matrix</p>
</dd>
<dt>AD </dt><dd><p>the AD matrix in sparse matrix form</p>
</dd>
<dt>logDetAD </dt><dd><p>the log determinant of the AD matrix</p>
</dd>
<dt>DD </dt><dd><p>the DD matrix in sparse matrix form</p>
</dd> 
<dt>logDetDD </dt><dd><p>the log determinant of the DD matrix</p>
</dd>
<dt>Dinv </dt><dd><p>the inverse of the D matrix in sparse matrix form</p>
</dd>
<dt>ADinv </dt><dd><p>the inverse of the AD matrix in sparse matrix form</p>
</dd>
<dt>DDinv </dt><dd><p>the inverse of the DD matrix in sparse matrix form</p>
</dd>
<dt>listDinv </dt><dd><p>the three column form of the non-zero elements for the
inverse of the D matrix</p>
</dd>
<dt>listADinv </dt><dd><p>the three column form of the non-zero elements for the 
inverse of the AD matrix</p>
</dd>
<dt>listDDinv </dt><dd><p>the three column form of the non-zero elements for the 
inverse of the DD matrix</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeA">makeA</a></code>, <code><a href="#topic+makeD">makeD</a></code>, <code><a href="#topic+makeAA">makeAA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  Boutput &lt;- makeDomEpi(Mrode9, output = "b", parallel = FALSE, invertD = FALSE)
  str(Boutput)
	
  DADoutput &lt;- makeDomEpi(Mrode9, output = "AD", parallel = FALSE, invertD = TRUE)
  str(DADoutput)

</code></pre>

<hr>
<h2 id='makeDsim'>Create the dominance genetic relationship matrix through an iterative
(simulation) process</h2><span id='topic+makeDsim'></span><span id='topic+makeSdsim'></span>

<h3>Description</h3>

<p>Alleles are explicitly traced through a pedigree to obtain coefficients of
fraternity between pairs of individuals (the probability of sharing both
alleles identical by descent) - for either autosomes or sex chromosomes.
This is accomplished in an iterative process to account for the various
routes by which an allele will progress through a pedigree due to Mendelian
sampling at either autosomes or sex chromosomes. The autosomal case is an
implementation of the simulation approach of Ovaskainen et al. (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDsim(
  pedigree,
  N,
  parallel = FALSE,
  ncores = getOption("mc.cores", 2L),
  invertD = TRUE,
  calcSE = FALSE,
  returnA = FALSE,
  verbose = TRUE
)

makeSdsim(
  pedigree,
  heterogametic,
  N,
  DosageComp = c(NULL, "ngdc", "hori", "hedo", "hoha", "hopi"),
  parallel = FALSE,
  ncores = getOption("mc.cores", 2L),
  invertSd = TRUE,
  calcSE = FALSE,
  returnS = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeDsim_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree with columns organized: ID, Dam, Sire. For use
with <code>makeSdsim</code>, a fourth column indicates the sex of each individual
in the pedigree.</p>
</td></tr>
<tr><td><code id="makeDsim_+3A_n">N</code></td>
<td>
<p>The number of times to iteratively trace alleles through the
pedigree</p>
</td></tr>
<tr><td><code id="makeDsim_+3A_parallel">parallel</code></td>
<td>
<p>A logical indicating whether or not to use parallel
processing. Note, this may only be available for Mac and Linux operating
systems.</p>
</td></tr>
<tr><td><code id="makeDsim_+3A_ncores">ncores</code></td>
<td>
<p>The number of cpus to use when constructing the dominance
relatedness matrix. Default is all available.</p>
</td></tr>
<tr><td><code id="makeDsim_+3A_invertd">invertD</code>, <code id="makeDsim_+3A_invertsd">invertSd</code></td>
<td>
<p>A logical indicating whether or not to invert the D
or Sd matrix</p>
</td></tr>
<tr><td><code id="makeDsim_+3A_calcse">calcSE</code></td>
<td>
<p>A logical indicating whether or not the standard errors for
each coefficient of fraternity should be calculated</p>
</td></tr>
<tr><td><code id="makeDsim_+3A_returna">returnA</code>, <code id="makeDsim_+3A_returns">returnS</code></td>
<td>
<p>Logical, indicating if the numerator relationship
matrix (A or S) should be stored and returned.</p>
</td></tr>
<tr><td><code id="makeDsim_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating if progress messages should be displayed.</p>
</td></tr>
<tr><td><code id="makeDsim_+3A_heterogametic">heterogametic</code></td>
<td>
<p>Character indicating the label corresponding to the
heterogametic sex used in the &quot;Sex&quot; column of the pedigree</p>
</td></tr>
<tr><td><code id="makeDsim_+3A_dosagecomp">DosageComp</code></td>
<td>
<p>A character indicating which model of dosage compensation.
If <code>NULL</code> then the &ldquo;ngdc&rdquo; model is assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p><code>parallel</code> = TRUE should only be used on Linux or Mac operating systems
(i.e., not Windows).
</p>
<p>Ovaskainen et al. (2008) indicated that the method of calculating the D
matrix (see <code><a href="#topic+makeD">makeD</a></code>) is only an approximation.  They proposed a
simulation method that is implemented here.  This should be more
appropriate, especially when inbreeding occurs in the pedigree.
</p>
<p>The objects <code>listDsim</code> and <code>listSdsim</code> will list both the
approximate values (returned from <code><a href="#topic+makeD">makeD</a></code> or
<code><a href="#topic+makeSd">makeSd</a></code>) as well as the simulated values.  If <code>calcSE</code> is
TRUE, these values will be listed in <code>listDsim</code> or <code>listSdsim</code>.
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>A,S </dt><dd><p>the A or S matrix in sparse matrix form</p>
</dd>
<dt>D,Sd </dt><dd><p>the approximate D or Sd matrix in sparse matrix form</p>
</dd>
<dt>logDetD,logDetSd </dt><dd><p>the log determinant of the D or Sd matrix</p>
</dd>
<dt>Dinv,Sdinv </dt><dd><p>the inverse of the approximate D or approximate Sd
matrix in sparse matrix form</p>
</dd>
<dt>listDinv,listSdinv </dt><dd><p>the three column form of the non-zero elements 
for the inverse of the approximate D matrix or the inverse of the
approximate Sd matrix</p>
</dd>
<dt>Dsim,Sdsim </dt><dd><p>the simulated D or Sd matrix in sparse matrix form</p>
</dd>
<dt>logDetDsim,logDetSdsim </dt><dd><p>the log determinant of the simulated D or
simulated Sd matrix</p>
</dd>
<dt>Dsiminv,Sdsiminv </dt><dd><p>the inverse of the simulated D or simulated Sd
matrix in sparse matrix form</p>
</dd>
<dt>listDsim,listSdsim </dt><dd><p>the three column form of the non-zero and
non-self elements for the simulated D or simulated Sd matrix</p>
</dd>
<dt>listDsiminv,listSdsiminv </dt><dd><p>the three column form of the non-zero
elements for the inverse of the simulated D or the inverse of the 
simulated Sd matrix</p>
</dd>
</dl>



<h3>Note</h3>

<p>This simulation can take a long time for large pedigrees (a few
thousand and higher) and large values of <code>N</code> (one thousand and 
higher). If unsure, it is advisable to start with a lower <code>N</code> and 
gradually increase to obtain a sense of the time required to execute a 
desired <code>N</code>.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Ovaskainen, O., Cano, J.M., &amp; Merila, J. 2008. A Bayesian
framework for comparative quantitative genetics. Proceedings of the Royal
Society B 275, 669-678.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeD">makeD</a></code>, <code><a href="#topic+makeSd">makeSd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  simD &lt;- makeDsim(Mrode9, N = 1000, parallel = FALSE,
		invertD = TRUE, calcSE = TRUE)$listDsim

  simSd &lt;- makeSdsim(FG90, heterogametic = "0", N = 1000, parallel = FALSE,
		invertSd = TRUE, calcSE = TRUE)$listSdsim
</code></pre>

<hr>
<h2 id='makeM'>Creates the (additive) mutational effects relationship matrix</h2><span id='topic+makeM'></span>

<h3>Description</h3>

<p>This returns the (additive) mutational effects relationship matrix in sparse
matrix format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeM(pedigree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeM_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>See function <code><a href="#topic+makeMinv">makeMinv</a></code> for directly obtaining the inverse of
the (additive) mutational effects genetic relationship matrix.
</p>


<h3>Value</h3>

<p>Returns M, or the mutational effects relationship matrix, in sparse 
matrix form.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeA">makeA</a></code>, <code><a href="#topic+makeS">makeS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 makeM(Mrode2)

</code></pre>

<hr>
<h2 id='makeMinv'>Create the inverse (additive) mutational effects relationship matrix</h2><span id='topic+makeMinv'></span><span id='topic+makeMinvML'></span>

<h3>Description</h3>

<p>Returns the inverse of the (additive) mutational effects relationship matrix.
It can also be used to obtain components needed for the calculations in the
underlying algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMinv(pedigree, ...)

makeMinvML(pedigree, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeMinv_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
<tr><td><code id="makeMinv_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>Note the assumption under the infinitesimal model, that mutation has essentially
zero probability of affecting an inbred locus (hence removing inbred
identity-by-descent), however, mutations may themselves be subject to
inbreeding (Wray 1990).
</p>
<p>By default, the algorithm described in Casellas and Medrano (2008) is
implemented here, in which the inverse-M is separate from the typical inverse
relatedness matrix (inverse-A). Casellas and Medrano's algorithm allows
separate partitioning of additive genetic variance attributed to inheritance
of allelic variation present in the base population (inverse-A) from
additive genetic variance arising from mutation and subsequent sharing of
mutant alleles identical-by-descent. Alternatively, Wray (1990) formulates
an algorithm which combines both of these processes (i.e., the A-inverse with
the M-inverse matrices). If the Wray algorithm is desired, this can be
implemented by specifying a numeric value to an argument named <code>theta</code>.
The value used for <code>theta</code> should be as described in Wray (1990). See
examples below for use of this argument.
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>Minv </dt><dd><p>the inverse of the (additive) mutational effects
relationship matrix in sparse matrix form</p>
</dd>
<dt>listMinv </dt><dd><p>the three column list of the non-zero elements for the 
inverse of the (additive) mutational effects relationship matrix.
<code>attr(*, "rowNames")</code> links the integer for rows/columns to the ID
column from the pedigree.</p>
</dd>
<dt>h </dt><dd><p>the amount by which segregation variance is reduced by
inbreeding. Similar to the individual coefficients of inbreeding (f)
derived during the construction of the inverse numerator relatedness matrix.
in the pedigree (matches the order of the first/ID column of the
pedigree).</p>
</dd>
<dt>logDet </dt><dd><p>the log determinant of the M matrix</p>
</dd>
<dt>dii </dt><dd><p>the (non-zero) elements of the diagonal D matrix of the M=TDT'
decomposition. Contains the variance of Mendelian sampling. Matches
the order of the first/ID column of the pedigree. Note Wray (1990) and
Casellas and Medrano (2008) algorithms use <code>v=sqrt(dii)</code>.</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Casellas, J. and J.F. Medrano. 2008. Within-generation mutation
variance for litter size in inbred mice. Genetics. 179:2147-2155. 
</p>
<p>Meuwissen, T.H.E &amp; Luo, Z. 1992. Computing inbreeding
coefficients in large populations. Genetics, Selection, Evolution. 24:305-313.
</p>
<p>Mrode, R.A. 2005. Linear Models for the Prediction of Animal Breeding
Values, 2nd ed.  Cambridge, MA: CABI Publishing.
</p>
<p>Wray, N.A. 1990. Accounting for mutation effects in the additive genetic
variance-covariance matrix and its inverse. Biometrics. 46:177-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ##  Example pedigree from Wray 1990
 #### Implement Casellas &amp; Medrano (2008) algorithm
   Mout &lt;- makeMinv(Wray90[, 1:3])
 #### Wray (1990) algorithm with extra argument `theta`
   Mwray &lt;- makeMinv(Wray90[, 1:3], theta = 10.0)$Minv # compare to Wray p.184
</code></pre>

<hr>
<h2 id='makeS'>Creates the additive genetic relationship matrix for the shared sex
chromosomes</h2><span id='topic+makeS'></span>

<h3>Description</h3>

<p>The function returns the inverse of the additive relationship matrix in
sparse matrix format for the sex chromosomes (e.g., either X or Z).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeS(
  pedigree,
  heterogametic,
  DosageComp = c(NULL, "ngdc", "hori", "hedo", "hoha", "hopi"),
  returnS = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeS_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire, Sex</p>
</td></tr>
<tr><td><code id="makeS_+3A_heterogametic">heterogametic</code></td>
<td>
<p>Character indicating the label corresponding to the
heterogametic sex used in the &ldquo;Sex&rdquo; column of the pedigree</p>
</td></tr>
<tr><td><code id="makeS_+3A_dosagecomp">DosageComp</code></td>
<td>
<p>A character indicating which model of dosage compensation.
If <code>NULL</code> then the &ldquo;ngdc&rdquo; model is assumed.</p>
</td></tr>
<tr><td><code id="makeS_+3A_returns">returnS</code></td>
<td>
<p>Logical statement, indicating if the relationship matrix
should be constructed in addition to the inverse</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>The inverse of the sex-chromosome additive genetic relationship matrix
(S-matrix) is constructed implementing the Meuwissen and Luo (1992)
algorithm to directly construct inverse additive relationship matrices
(borrowing code from Jarrod Hadfield's MCMCglmm function, <code>inverseA</code>)
and using equations presented in Fernando &amp; Grossman (1990; see Wolak et al.
2013).  Additionally, the S-matrix itself can be constructed (although this
takes much longer than computing S-inverse directly).
</p>
<p>The choices of dosage compensation models are: no global dosage compensation
(&quot;ngdc&quot;), random inactivation in the homogametic sex (&quot;hori&quot;), doubling of
the single shared sex chromosome in the heterogametic sex (&quot;hedo&quot;), halving
expression of both sex chromosomes in the homogametic sex (&quot;hoha&quot;), or
inactivation of the paternal sex chromosome in the homogametic sex (&quot;hopi&quot;).
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>model </dt><dd><p>the model of sex-chromosome dosage compensation assumed.</p>
</dd>
<dt>S </dt><dd><p>the sex-chromosome relationship matrix in sparse matrix
form or NULL if <code>returnS</code> = FALSE</p>
</dd>
<dt>logDet </dt><dd><p>the log determinant of the S matrix</p>
</dd>
<dt>Sinv </dt><dd><p>the inverse of the S matrix in sparse matrix form</p>
</dd>
<dt>listSinv </dt><dd><p>the three column form of the non-zero elements for the 
inverse of the S matrix</p>
</dd>
<dt>inbreeding </dt><dd><p>the sex-linked inbreeding coefficients for all 
individuals in the pedigree</p>
</dd>
<dt>vii </dt><dd><p>a vector of the (non-zero) elements of the diagonal V matrix
of the S=TVT' decomposition. Contains the variance of Mendelian
sampling for a sex-linked locus</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Wolak, M.E., D.A. Roff, and D.J. Fairbairn. in prep. The
contribution of sex chromosomal additive genetic (co)variation to the
phenotypic resemblance between relatives under alternative models of dosage
compensation.
</p>
<p>Fernando, R.L. &amp; Grossman, M. 1990. Genetic evaluation with autosomal and
X-chromosomal inheritance. Theoretical and Applied Genetics, 80:75-80.
</p>
<p>Meuwissen, T.H.E. and Z. Luo. 1992. Computing inbreeding coefficients in
large populations. Genetics, Selection, Evolution, 24:305-313.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 makeS(FG90, heterogametic = "0", returnS = TRUE)

</code></pre>

<hr>
<h2 id='makeTinv'>Creates components of the additive genetic relationship matrix and its inverse</h2><span id='topic+makeTinv'></span><span id='topic+makeT'></span><span id='topic+makeT.default'></span><span id='topic+makeT.numPed'></span><span id='topic+makeTinv.default'></span><span id='topic+makeTinv.numPed'></span><span id='topic+makeDiiF'></span><span id='topic+makeDiiF.default'></span><span id='topic+makeDiiF.numPed'></span>

<h3>Description</h3>

<p>This returns the Cholesky decomposition of the numerator relationship matrix
and its inverse. It can also be used to obtain coefficients of inbreeding for
the pedigreed population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTinv(pedigree, ...)

## Default S3 method:
makeTinv(pedigree, ...)

## S3 method for class 'numPed'
makeTinv(pedigree, ...)

## Default S3 method:
makeT(pedigree, genCol = NULL, ...)

## Default S3 method:
makeDiiF(pedigree, f = NULL, ...)

## S3 method for class 'numPed'
makeDiiF(pedigree, f = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeTinv_+3A_pedigree">pedigree</code></td>
<td>
<p>A pedigree where the columns are ordered ID, Dam, Sire</p>
</td></tr>
<tr><td><code id="makeTinv_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
<tr><td><code id="makeTinv_+3A_gencol">genCol</code></td>
<td>
<p>An integer value indicating the generation up to which the
<code>T</code> matrix is to be created (corresponding to columns of the lower
triangle <code>T</code> matrix). The first generation is numbered 0, default is
all generations.</p>
</td></tr>
<tr><td><code id="makeTinv_+3A_f">f</code></td>
<td>
<p>A numeric vector indicating the level of inbreeding. See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>The function implements an adaptation of the Meuwissen and Luo (1992)
algorithm (particularly, following the description of the algorithm in
Mrode 2005) with some code borrowed from the <code>inverseA</code> function by
Jarrod Hadfield in the <code>MCMCglmm</code> package. 
</p>
<p>The inbreeding level of individuals can be provided instead of calculated.
<code>f</code> must be a vector that is the same length as individuals in the
pedigree. Supplied coefficients of inbreeding are used instead of being 
calculated until a <code>NA</code> is encountered in the vector. From this position
on, then coefficients of inbreeding are calculated and replace entries in 
<code>f</code>. This can be used, for example, to calculate coefficients of
inbreeding for later generations when coefficients of inbreeding in the
previous generations have already been calculated. To specify an average
coefficient of inbreeding for the base population, modify the pedigree to
include a single phantom parent and specify this individual's non-zero
coefficient of inbreeding in <code>f</code> with the rest of the terms as NA.
</p>


<h3>Value</h3>

<p>a <code>list</code>:
</p>

<dl>
<dt>Tinv </dt><dd><p>the inverse of the Cholesky decomposition of the additive
genetic relationship matrix (Ainv=Tinv' Dinv Tinv) in sparse matrix form</p>
</dd>
<dt>D </dt><dd><p>the diagonal D matrix of the A=TDT' Cholesky decomposition.
Contains the variance of Mendelian sampling. Matches
the order of the first/ID column of the pedigree.</p>
</dd> 
<dt>f </dt><dd><p>the individual coefficients of inbreeding for each individual 
in the pedigree (matches the order of the first/ID column of the
pedigree).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Meuwissen, T.H.E &amp; Luo, Z. 1992. Computing inbreeding 
coefficients in large populations. Genetics, Selection, Evolution. 24:305-313.
</p>
<p>Mrode, R.A. 2005. Linear Models for the Prediction of Animal Breeding
Values, 2nd ed.  Cambridge, MA: CABI Publishing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeAinv">makeAinv</a></code>, <code><a href="#topic+makeA">makeA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 Tinv &lt;- makeTinv(Mrode2)
 # Method for a numeric pedigree (of `nadiv` class "numPed")
 nPed &lt;- numPed(Mrode2)
 Tinv2 &lt;- makeTinv(nPed)

 ########
 DF &lt;- makeDiiF(Mrode2)
 # manually construct the inverse of the relatedness matrix `Ainv`
 Dinv &lt;- DF$D  #&lt;-- not the inverse yet, just copying the object
 Dinv@x &lt;- 1 / DF$D@x  #&lt;-- inverse of a diagonal matrix
 handAinv &lt;- crossprod(Tinv, Dinv) %*% Tinv
   # make the A-inverse directly
   Ainv &lt;- makeAinv(Mrode2)$Ainv
   # Compare
   handAinv
   Ainv
   stopifnot(all(abs((Ainv - handAinv)@x) &lt; 1e-6))

 # supply previous generation coefficients of inbreeding (f)
 ## to keep from re-calculating their f when analyzing subsequent generations
 DF &lt;- makeDiiF(Mrode2[, 1:3])
 Mrode2$gen &lt;- genAssign(Mrode2)
 Mrode2$f_full &lt;- DF$f
 Mrode2$f_in &lt;- with(Mrode2, c(f_full[gen &lt;= 1], rep(NA, sum(gen &gt; 1))))
 DF2 &lt;- makeDiiF(Mrode2[, 1:3], f = Mrode2$f_in) 
 stopifnot(identical(DF, DF2))

</code></pre>

<hr>
<h2 id='Mrode2'>Pedigree from Table 2.1 of Mrode (2005)</h2><span id='topic+Mrode2'></span>

<h3>Description</h3>

<p>Pedigree from Table 2.1 of Mrode (2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mrode2
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 6 observations on the following 3 variables:
</p>

<dl>
<dt>id </dt><dd><p>a numeric vector</p>
</dd>
<dt>dam </dt><dd><p>a numeric vector</p>
</dd>
<dt>sire </dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mrode, R.A. 2005. Linear Models for the Prediction of Animal
Breeding Values, 2nd ed.  Cambridge, MA: CABI Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  str(Mrode2)
</code></pre>

<hr>
<h2 id='Mrode3'>Pedigree, from chapter 3 of Mrode (2005) with genetic groups and a trait column</h2><span id='topic+Mrode3'></span>

<h3>Description</h3>

<p>Pedigree, from chapter 3 of Mrode (2005) with genetic groups and a trait column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mrode3
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 10 observations on the following 8 variables:
</p>

<dl>
<dt>calf </dt><dd><p>a factor with levels indicating the unique genetic groups 
and individuals</p>
</dd>
<dt>dam </dt><dd><p>a numeric vector of maternal identities</p>
</dd>
<dt>sire </dt><dd><p>a numeric vector of paternal identities</p>
</dd>
<dt>damGG </dt><dd><p>a factor of maternal identities with genetic groups 
inserted instead of <code>NA</code></p>
</dd>
<dt>sireGG </dt><dd><p>a factor of paternal identities with genetic groups 
inserted instead of <code>NA</code></p>
</dd>
<dt>sex </dt><dd><p>a factor with levels <code>female</code> <code>male</code></p>
</dd>
<dt>WWG </dt><dd><p>a numeric vector of pre-weaning weight gain (kg) for five 
beef calves</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mrode, R.A. 2005. Linear Models for the Prediction of Animal
Breeding Values, 2nd ed.  Cambridge, MA: CABI Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Mrode3)
  str(Mrode3)
</code></pre>

<hr>
<h2 id='Mrode9'>Pedigree, adapted from example 9.1 of Mrode (2005)</h2><span id='topic+Mrode9'></span>

<h3>Description</h3>

<p>Pedigree, adapted from example 9.1 of Mrode (2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mrode9
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 12 observations on the following 3 variables:
</p>

<dl>
<dt>pig </dt><dd><p>a numeric vector</p>
</dd>
<dt>dam </dt><dd><p>a numeric vector</p>
</dd>
<dt>sire </dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mrode, R.A. 2005. Linear Models for the Prediction of Animal
Breeding Values, 2nd ed.  Cambridge, MA: CABI Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Mrode9)
  str(Mrode9)
</code></pre>

<hr>
<h2 id='nadiv-deprecated'>Deprecated functions in package <span class="pkg">nadiv</span>.</h2><span id='topic+nadiv-deprecated'></span><span id='topic+pin'></span>

<h3>Description</h3>

<p>The functions listed below are deprecated and will be defunct in
the near future. When possible, alternative functions with similar
functionality are also mentioned. Help pages for deprecated functions are
available at <code>help("&lt;function&gt;-deprecated")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pin(object, transform)
</code></pre>


<h3><code>pin</code></h3>

<p>For <code>pin</code> with asreml version 4 objects, use <code>asreml::vpredict</code>
</p>

<hr>
<h2 id='numPed'>Integer Format Pedigree</h2><span id='topic+numPed'></span><span id='topic+ronPed'></span>

<h3>Description</h3>

<p>Conversion, checking, and row re-ordering of a pedigree in integer form of
class &lsquo;numPed&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numPed(pedigree, check = TRUE)

ronPed(x, i, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numPed_+3A_pedigree">pedigree</code></td>
<td>
<p>A three column pedigree object, where the columns correspond 
to: ID, Dam, &amp; Sire</p>
</td></tr>
<tr><td><code id="numPed_+3A_check">check</code></td>
<td>
<p>A logical argument indicating if checks on the validity of the 
pedigree structure should be made, but see Details</p>
</td></tr>
<tr><td><code id="numPed_+3A_x">x</code></td>
<td>
<p>A pedigree of class &lsquo;<code>numPed</code>&rsquo;</p>
</td></tr>
<tr><td><code id="numPed_+3A_i">i</code>, <code id="numPed_+3A_...">...</code></td>
<td>
<p>Index specifying elements to extract or replace: see
<code><a href="base.html#topic++5B">[</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', '-998', or '*'.
</p>
<p>Individuals must appear in the ID column in rows preceding where they
appear in either the Dam or Sire column. See the
<code><a href="#topic+prepPed">prepPed</a></code> function if this is not the case.
</p>
<p>If pedigree inherits the class &quot;numPed&quot; (from a previous call to
<code>numPed()</code>) and <code>check = TRUE</code>, the checks are skipped. If
<code>check = FALSE</code> any pedigree will be transformed into a pedigree
consisting of integers and missing values denoted by '-998'.
</p>
<p>Based on code from the <code>MCMCglmm</code> package
</p>


<h3>Value</h3>

<p>An S3 object of class &ldquo;numPed&rdquo; representing the pedigree, 
where individuals are now numbered from 1 to <code>n</code> and unknown parents 
are assigned a value of &lsquo;-998&rsquo;.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepPed">prepPed</a></code>, <code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm</a></code>,
<code><a href="base.html#topic++5B">[</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(nPed &lt;- numPed(Mrode2))
class(nPed)

# re-order and retain class 'numPed'
ronPed(nPed, order(nPed[, 2], nPed[, 3]))
class(nPed)

</code></pre>

<hr>
<h2 id='pcc'>REML convergence checks</h2><span id='topic+pcc'></span>

<h3>Description</h3>

<p>Mainly checks to ensure the variance components in a REML mixed model do not
change between the last two iterations more than what is allowed by the
tolerance value.  See details for extra check on asreml-R models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcc(object, traces = NULL, tol = 0.01, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcc_+3A_object">object</code></td>
<td>
<p>A list with at least one element named: <code>monitor</code> (see
Details)</p>
</td></tr>
<tr><td><code id="pcc_+3A_traces">traces</code></td>
<td>
<p>Optionally, a matrix to substitute instead of the monitor
element to <code>object</code>.  Each row corresponds to a different variance
component in the model and each column is a different iteration of the
likelihood calculation (column 1 is the first iterate).</p>
</td></tr>
<tr><td><code id="pcc_+3A_tol">tol</code></td>
<td>
<p>The tolerance level for which to check against all of the changes
in variance component parameter estimates</p>
</td></tr>
<tr><td><code id="pcc_+3A_silent">silent</code></td>
<td>
<p>Optional argument to silence the output of helpful (indicating
default underlying behavior) messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Object is intended to be an asreml-R model output. NOTE, The first 3 rows
are ignored and thus should not be variance components from the model (e.g.,
they should be the loglikelihood or degrees of freedom, etc.).  Also, the
last column is ignored and should not be an iteration of the model (e.g., it
indicates the constraint).
</p>
<p>The function also checks <code>object</code> to ensure that the output from the
asreml-R model does not contain a log-likelihood value of exactly 0.00.  An
ASReml model can sometimes fail while still returning a <code>monitor</code>
object and <code>TRUE</code> value in the <code>converge</code> element of the output.
This function will return <code>FALSE</code> if this is the case.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if all variance parameters change less than the
value specified by <code>tol</code>, otherwise returns <code>FALSE</code>. Also see the
<code>details</code> section for other circumstances when <code>FALSE</code> might be
returned.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Below is the last 3 iterations from the trace from an animal model of 
# tait1 of the warcolak dataset.
# Re-create the output from a basic, univariate animal model in asreml-R
   tracein &lt;- matrix(c(0.6387006, 1, 0.6383099, 1, 0.6383294, 1, 0.6383285, 1),
	nrow = 2, ncol = 4, byrow = FALSE)
   dimnames(tracein) &lt;- list(c("ped(ID)!ped", "R!variance"), c(6, 7, 8, 9))

   pcc(object = NULL, trace = tracein)


</code></pre>

<hr>
<h2 id='pin-deprecated'>Approximate standard errors for linear functions of variance components</h2><span id='topic+pin-deprecated'></span>

<h3>Description</h3>

<p>This function is Deprecated and will be removed in a future version. The pin
function works with an asreml-R version 3 model object. Since ASReml has
updated to version 4, they have changed their model output. ASReml has also
provided their own <code>vpredict</code> function that does (for asreml v4 model
objects) what <code>pin</code> did for asreml v3 model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pin(object, transform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pin-deprecated_+3A_object">object</code></td>
<td>
<p>A list with at least the following elements: <code>gammas</code>,
<code>gammas.type</code>, and <code>ai</code> from a REML mixed model</p>
</td></tr>
<tr><td><code id="pin-deprecated_+3A_transform">transform</code></td>
<td>
<p>A formula specifying the linear transformation of variance
components to conduct</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to the pin calculations performed by the standalone
ASReml.  This function, written by Ian White, applies the delta method for
the estimation of approximate standard errors on linear functions of
variance components from a REML mixed model
</p>
<p>Object is intended to be an asreml-R model output.
</p>
<p>The formula can use <code>V1,..., Vn</code> to specify any one of the <code>n</code>
variance components.  These should be in the same order as they are in the
object (e.g., see the row order of <code>summary(object)$varcomp</code> for
asreml-R models.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with row names corresponding to the operator on 
the left hand side of the <code>transform</code> formula and the entries 
corresponding to the <code>Estimate</code> and approximate <code>SE</code> of the 
linear transformation.
</p>


<h3>Author(s)</h3>

<p>Ian White
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+nadiv-deprecated">nadiv-deprecated</a></code>,  <code><a href="#topic+aiCI">aiCI</a></code>,
<code><a href="#topic+aiFun">aiFun</a></code>
</p>

<hr>
<h2 id='prepPed'>Prepares a pedigree by sorting and adding 'founders'</h2><span id='topic+prepPed'></span>

<h3>Description</h3>

<p>This function takes a pedigree, adds missing founders, and then sorts the
pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepPed(pedigree, gender = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepPed_+3A_pedigree">pedigree</code></td>
<td>
<p>An object, where the first 3 columns correspond to: ID, Dam,
&amp; Sire. See details.</p>
</td></tr>
<tr><td><code id="prepPed_+3A_gender">gender</code></td>
<td>
<p>An optional character for the name of the column in
<code>pedigree</code> that corresponds to the gender/sex of individuals. If
specified, <code>prepPed</code> will assign a gender to any founders it adds to
the pedigree.</p>
</td></tr>
<tr><td><code id="prepPed_+3A_check">check</code></td>
<td>
<p>A logical argument indicating if checks on the validity of the
pedigree structure should be made</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many functions (both in nadiv and from other programs) dealing with
pedigrees must first sort a pedigree such that individuals appear in the ID
column in rows preceding where they appear in either the Dam or Sire
column.  Further, these functions and programs require that all individuals
in the dam and sire columns of a pedigree also have an entry in the ID
column.  This function easily prepares data sets to accommodate these
requirements using a very fast topological sorting algorithm.
</p>
<p>NOTE: more columns than just a pedigree can be passed in the <code>pedigree</code>
argument.  In the case of missing founders, these columns are given NA
values for all rows where founders have been added to the pedigree.  The
entire object supplied to <code>pedigree</code> is ordered, ensuring that all
information remains connected to the individual
</p>
<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>When a non-null argument is given to <code>gender</code>, dams without an entry in
the ID column (that are subsequently added to the pedigree) are given the
gender designated for other dams (and similarly for sires).
</p>
<p>The <code>check</code> argument performs checks on the format of the pedigree
supplied to try and identify any issues regarding the notation of missing
values and validity of the basic pedigree for further processing.
</p>


<h3>Value</h3>

<p>The pedigree object (can have more columns than just ID, Dam, and
Sire), where: (1) the ID column contains an ID for all individuals from the
original pedigree object's ID, Dam, and Sire columns (i.e., founders are
added) and (2) the pedigree is now sorted so that individuals are not in
rows preceding either their Dam or Sire.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genAssign">genAssign</a></code>, <code><a href="#topic+prunePed">prunePed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First create an unordered pedigree with (4) missing founders
  warcolak_unsuitable &lt;- warcolak[sample(seq(5, nrow(warcolak), 1),
	size = (nrow(warcolak) - 4), replace = FALSE), ]
  nrow(warcolak)
  nrow(warcolak_unsuitable)
# Fix and sort the pedigree
## Automatically assign the correct gender to the added founders
### Also sort the data accompanying each individual
  warcolak_fixed_ordered &lt;- prepPed(warcolak_unsuitable, gender = "sex")
  head(warcolak_fixed_ordered)

</code></pre>

<hr>
<h2 id='prunePed'>Prunes a pedigree based on individuals with phenotypes</h2><span id='topic+prunePed'></span><span id='topic+prunePed.default'></span><span id='topic+prunePed.numPed'></span>

<h3>Description</h3>

<p>This function removes individuals who are either not themselves or not
ancestors to phenotyped individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prunePed(pedigree, phenotyped, ...)

## Default S3 method:
prunePed(pedigree, phenotyped, ...)

## S3 method for class 'numPed'
prunePed(pedigree, phenotyped, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prunePed_+3A_pedigree">pedigree</code></td>
<td>
<p>An object, where the first 3 columns correspond to: ID, Dam,
&amp; Sire. See details.</p>
</td></tr>
<tr><td><code id="prunePed_+3A_phenotyped">phenotyped</code></td>
<td>
<p>A vector indicating which individuals in the pedigree have
phenotypic information available.</p>
</td></tr>
<tr><td><code id="prunePed_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often mixed effect models run much faster when extraneous information is
removed before running the model. This is particularly so when reducing the
number of random effects associated with a relationship matrix constructed
from a pedigree.
</p>
<p>NOTE: more columns than just a pedigree can be passed in the <code>pedigree</code>
argument.
</p>
<p>Missing parents (e.g., base population) should be denoted by either 'NA',
'0', or '*'.
</p>
<p>This function is very similar to (and the code is heavily borrowed from) a
function of the same name in the <code>MCMCglmm</code> package by Jarrod Hadfield.
</p>


<h3>Value</h3>

<p>The pedigree object (can have more columns than just ID, Dam, and
Sire), where the ID column contains an ID for all individuals who are
actually phenotyped or are an ancestor to an individual with a phenotype
(and are thus informative for estimating parameters in the base 
population).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepPed">prepPed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Make a pedigree (with sex) from the warcolak dataset
  warcolak_ped &lt;- warcolak[, 1:4]

# Reduce the number of individuals that have a phenotype for "trait1" in
  #the warcolak dataset
  t1phenotyped &lt;- warcolak
  t1phenotyped[sample(seq.int(nrow(warcolak)), 1500, replace = FALSE), "trait1"] &lt;- NA
  t1phenotyped &lt;- t1phenotyped[which(!is.na(t1phenotyped$trait1)), ]

# The following will give a pedigree with only individuals that have a 
# phenotype for "trait1" OR are an ancestor to a phenotyped individual.
  pruned_warcolak_ped &lt;- prunePed(warcolak_ped, phenotyped = t1phenotyped$ID)

# Now compare the sizes (note, pruned_warcolak_ped retained its column indicating sex.
  dim(warcolak_ped)
  dim(pruned_warcolak_ped)
# We could have kept all of the data associated with individuals who had phenotypic
# information on "trait1" by instead specifying 
  pruned_fullt1_warcolak_ped &lt;- prunePed(warcolak, phenotyped = t1phenotyped$ID) 
  dim(pruned_fullt1_warcolak_ped)  #&lt;-- compare number of columns with above

</code></pre>

<hr>
<h2 id='Q1988'>Pedigree with genetic groups adapted from Quaas (1988) equation [5]</h2><span id='topic+Q1988'></span>

<h3>Description</h3>

<p>Pedigree with genetic groups adapted from Quaas (1988) equation [5]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q1988
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 11 observations on the following 8 variables:
</p>

<dl>
<dt>id </dt><dd><p>a factor with levels indicating the unique individuals 
(including phantom parents) and genetic groups</p>
</dd>
<dt>dam </dt><dd><p>a factor of observed maternal identities</p>
</dd>
<dt>sire </dt><dd><p>a factor vector of observed paternal identities</p>
</dd>
<dt>damGG </dt><dd><p>a factor of maternal identities with genetic groups 
inserted instead of <code>NA</code></p>
</dd>
<dt>sireGG </dt><dd><p>a factor of paternal identities with genetic groups 
inserted instead of <code>NA</code></p>
</dd>
<dt>phantomDam </dt><dd><p>a factor of maternal identities with phantom parents 
inserted instead of <code>NA</code></p>
</dd>
<dt>phantomSire </dt><dd><p>a factor of paternal identities with phantom parents 
inserted instead of <code>NA</code></p>
</dd>
<dt>group </dt><dd><p>a factor of genetic groups to which each phantom parent
belongs</p>
</dd>
</dl>



<h3>Source</h3>

<p>Quaas, R.L. 1988. Additive genetic model with groups and
relationships. Journal of Dairy Science 71:1338-1345.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Q1988)
  str(Q1988)
</code></pre>

<hr>
<h2 id='simGG'>Genetic group pedigree and data simulation</h2><span id='topic+simGG'></span>

<h3>Description</h3>

<p>Simulates a pedigree and phenotype for a focal population receiving
immigrants. Genetic and environmental differences can be specified between
the focal and immigrant populations. Further, these differences can have
temporal trends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simGG(
  K,
  pairs,
  noff,
  g,
  nimm = 2,
  nimmG = seq(2, g - 1, 1),
  VAf = 1,
  VAi = 1,
  VRf = 1,
  VRi = 1,
  mup = 20,
  muf = 0,
  mui = 0,
  murf = 0,
  muri = 0,
  d_bvf = 0,
  d_bvi = 0,
  d_rf = 0,
  d_ri = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simGG_+3A_k">K</code></td>
<td>
<p>Integer number of individuals per generation, or the focal
population carrying capacity</p>
</td></tr>
<tr><td><code id="simGG_+3A_pairs">pairs</code></td>
<td>
<p>Integer number of mating pairs created by sampling with
replacement from adults of a given generation</p>
</td></tr>
<tr><td><code id="simGG_+3A_noff">noff</code></td>
<td>
<p>Integer number of offspring each pair contributes to the next
generation</p>
</td></tr>
<tr><td><code id="simGG_+3A_g">g</code></td>
<td>
<p>Integer number of (non-overlapping) generations to simulate</p>
</td></tr>
<tr><td><code id="simGG_+3A_nimm">nimm</code></td>
<td>
<p>Integer number of immigrants added to the population each
generation of migration</p>
</td></tr>
<tr><td><code id="simGG_+3A_nimmg">nimmG</code></td>
<td>
<p>Sequence of integers for the generations in which immigrants
arrive in the focal population</p>
</td></tr>
<tr><td><code id="simGG_+3A_vaf">VAf</code></td>
<td>
<p>Numeric value for the expected additive genetic variance in the
first generation of the focal population - the founders</p>
</td></tr>
<tr><td><code id="simGG_+3A_vai">VAi</code></td>
<td>
<p>Numeric value for the expected additive genetic variance in each
generation of immigrants</p>
</td></tr>
<tr><td><code id="simGG_+3A_vrf">VRf</code></td>
<td>
<p>Numeric value for the expected residual variance in the focal
population</p>
</td></tr>
<tr><td><code id="simGG_+3A_vri">VRi</code></td>
<td>
<p>Numeric value for the expected residual variance in each
generation of the immigrants</p>
</td></tr>
<tr><td><code id="simGG_+3A_mup">mup</code></td>
<td>
<p>Numeric value for the expected mean phenotypic value in the first
generation of the focal population - the founders</p>
</td></tr>
<tr><td><code id="simGG_+3A_muf">muf</code></td>
<td>
<p>Numeric value for the expected mean breeding value in the first
generation of the focal population - the founders</p>
</td></tr>
<tr><td><code id="simGG_+3A_mui">mui</code></td>
<td>
<p>Numeric value for the expected mean breeding value for the
immigrants</p>
</td></tr>
<tr><td><code id="simGG_+3A_murf">murf</code></td>
<td>
<p>Numeric value for the expected mean residual (environmental)
deviation in the first generation of the focal population - the founders</p>
</td></tr>
<tr><td><code id="simGG_+3A_muri">muri</code></td>
<td>
<p>Numeric value for the expected mean residual (environmental)
deviation for the immigrants</p>
</td></tr>
<tr><td><code id="simGG_+3A_d_bvf">d_bvf</code></td>
<td>
<p>Numeric value for the expected change between generations in
the mean breeding value of the focal population. Sets the rate of genetic
selection occurring across generations</p>
</td></tr>
<tr><td><code id="simGG_+3A_d_bvi">d_bvi</code></td>
<td>
<p>Numeric value for the expected change between generations in
the mean breeding value of the immigrant population each generation</p>
</td></tr>
<tr><td><code id="simGG_+3A_d_rf">d_rf</code></td>
<td>
<p>Numeric value for the expected change between generations in the
mean residual (environmental) deviation of the focal population each
generation</p>
</td></tr>
<tr><td><code id="simGG_+3A_d_ri">d_ri</code></td>
<td>
<p>Numeric value for the expected change between generations in the
mean residual (environmental) deviation of the immigrant population each
generation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Offspring total additive genetic values <code>u</code> are the average of their
parents <code>u</code> plus a Mendelian sampling deviation drawn from a normal
distribution with mean of 0 and variance equal to <code class="reqn">0.5V_{A} (1 -
f_{sd})</code> where <code class="reqn">V_A</code> is <code>VAf</code> and
<code class="reqn">f_{sd}</code> is the average of the parents' coefficient of inbreeding
<em>f</em> (p. 447 Verrier et al. 1993). Each &lsquo;immigrant&rsquo; (individual
with unknown parents in generations &gt;1) is given a total additive genetic
effect that is drawn from a normal distribution with mean of <code>mui</code> and
variance equal to <code>VAi</code>. Residual deviations are sampled for
&lsquo;focal&rsquo; and &lsquo;immigrant&rsquo; populations separately, using normal
distributions with means of <code>murf</code> and <code>muri</code>, respectively, and
variances of <code>VRf</code> and <code>VRi</code>, respectively. Phenotypes are the sum
of total additive genetic effects and residual deviations plus an overall
mean <code>mup</code>.
</p>
<p>Trends in total additive genetic effects and/or residual deviations can be
specified for both the focal and immigrant populations. Trends in total
additive genetic effects occurring in the immigrants, in the residual
deviations occurring in the focal population, and in the residual deviations
occurring in the immigrants are produced by altering the mean each
generation for the separate distribution from which these effects are each
drawn. The change in mean over a generation is specified in units of
standard deviations of the respective distributions (e.g., square roots of
<code>VAi</code>, <code>VRf</code>, and <code>VRi</code>) and is set with <code>d_bvi</code>,
<code>d_rf</code>, or <code>d_ri</code>, respectively.
</p>
<p>Trends in total additive genetic effects for the focal population are
produced by selecting individuals to be parents of the next generation
according to their <em>predicted</em> total additive genetic effects.
Individuals are assigned probabilities of being selected as a parent of the
next generation depending on how closely their predicted total additive
genetic effect matches an optimum value. Probabilities are assigned:
</p>
<p style="text-align: center;"><code class="reqn">exp((\frac{-1}{2\sigma_{x}}) (x - \theta)^{2})</code>
</p>
<p> where <code>x</code> is the vector of predicted total additive
genetic effects (<code>u</code>), <code class="reqn">\sigma_{x}</code> is the standard
deviation of <code>x</code>, and <code class="reqn">\theta</code> is the optimum value.
Sampling is conducted with replacement based on these probabilities.
</p>
<p>The parameter <code>d_bvf</code> specifies how much the optimal total additive
genetic effect changes per generation. The optimal total additive genetic
effect in a given generation is calculated as: <code>muf + d_bvf
*</code><code>sqrt(VAf) * (i-2)</code>. Individuals with predicted total additive
genetic effects closest to this optimum have a higher probability of being
randomly sampled to be parents of the next generation. This represents
selection directly on predicted total additive genetic effects.
</p>
<p>Total additive genetic effects are predicted for the first generation of
focal individuals and all immigrants using equation 1.3 in Mrode (2005,
p.3): <code class="reqn">h^{2} * (phenotype_{i} - mean population phenotype)</code>. The
heritability is either <code>VAf</code> / (<code>VAf + VRf</code>) or <code>VAi</code> /
(<code>VAi + VRi</code>). Total additive genetic effects are predicted for all
other individuals using equation 1.9 in Mrode (2005, p. 10) - or as the
average of each individual's parents' predicted total additive genetic
effects.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns corresponding to:
</p>

<dl>
<dt>id </dt><dd><p>Integer for each individual's unique identifying code</p>
</dd>
<dt>dam </dt><dd><p>Integer indicating each individual's dam</p>
</dd>
<dt>sire </dt><dd><p>Integer indicating each individual's sire</p>
</dd>
<dt>parAvgU </dt><dd><p>Numeric value for the average of each individual's dam 
and sire additive genetic effects</p>
</dd>
<dt>mendel </dt><dd><p>Numeric value for each individual's Mendelian sampling 
deviate from the mid-parental total additive genetic value</p>
</dd>
<dt>u </dt><dd><p>Numeric value of each individual's total additive genetic 
effect</p>
</dd>
<dt>r </dt><dd><p>Numeric value of each individual's residual (environmental) 
deviation</p>
</dd>
<dt>p </dt><dd><p>Numeric value of each individual's phenotypic value</p>
</dd>
<dt>pred.u </dt><dd><p>Numeric value of each individual's predicted total 
additive genetic effect</p>
</dd>
<dt>is </dt><dd><p>Integer of either <code>0</code> if an individual was born in the 
focal population or <code>1</code> if they were born in an immigrant 
population</p>
</dd>
<dt>gen </dt><dd><p>Integer value of the generation in which each individual was 
born</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Verrier, V., J.J. Colleau, and J.L. Foulley. 1993. Long-term
effects of selection based on the animal model BLUP in a finite population.
Theoretical and Applied Genetics. 87:446-454.
</p>
<p>Mrode, R.A. 2005. Linear Models for the Prediction of Animal Breeding
Values, 2nd ed.  Cambridge, MA: CABI Publishing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggTutorial">ggTutorial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  
  # The dataset 'ggTutorial' was simulated as:
  set.seed(102)      		# seed used to simulate ggTutorial
  ggTutorial &lt;- simGG(K = 400, pairs = 200, noff = 4, g = 15,
	nimm = 40, nimmG = seq(2, 14, 1),
	muf = 0, mui = 3)
  

# Use genetic group methods to approximate the breeding values for ggTutorial
  ## First, construct a pedigree with genetic groups
  ggPed &lt;- ggTutorial[, c("id", "dam", "sire", "is", "gen")]
  naPar &lt;- which(is.na(ggPed[, 2]))
  ggPed$GG &lt;- rep("NA", nrow(ggPed))
    # 'focal' population genetic group = "foc0" and 'immigrant' = "g1"
    # obtained by pasting "foc" &amp; "g" with immigrant status "0" or "1", respectively
    ggPed$GG[naPar] &lt;- as.character(ggPed$is[naPar])
    ggPed$GG[ggPed$GG == "0"] &lt;- paste0("foc", ggPed$GG[ggPed$GG == "0"])
    ggPed$GG[ggPed$GG == "1"] &lt;- paste0("g", ggPed$GG[ggPed$GG == "1"])
  ggPed[naPar, 2:3] &lt;- ggPed[naPar, "GG"]

  ## Now create the Q matrix
  Q &lt;- ggcontrib(ggPed[, 1:3], ggroups = c("foc0", "g1"))

  ## obtain the true values of the genetic group means
  foc0_mean &lt;- mean(ggTutorial$u[which(ggTutorial$gen == 1 &amp; ggTutorial$is == 0)])
  g1_mean &lt;- mean(ggTutorial$u[which(ggTutorial$is == 1)])
  g_exp &lt;- matrix(c(foc0_mean, g1_mean), ncol = 1)

  ## breeding values (a) are:
  ### tot. add. gen. effects (u) minus genetic group effects for each individual (Qg):
  a &lt;- ggTutorial$u - Q %*% g_exp


</code></pre>

<hr>
<h2 id='simPedDFC'>Double first cousin pedigree construction</h2><span id='topic+simPedDFC'></span>

<h3>Description</h3>

<p>Simulates a pedigree for the &ldquo;double first cousin&rdquo; mating design
(Fairbairn and Roff 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPedDFC(U, gpn = 4, fsn = 4, s = 2, fws = 2, prefix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simPedDFC_+3A_u">U</code></td>
<td>
<p>An integer number of units or blocks for the design</p>
</td></tr>
<tr><td><code id="simPedDFC_+3A_gpn">gpn</code></td>
<td>
<p>Number of grandparent pairs in the generation 0 (GP)
(must be &gt;= 2). Equals the number of full-sib families in generation 1 (P).</p>
</td></tr>
<tr><td><code id="simPedDFC_+3A_fsn">fsn</code></td>
<td>
<p>Number of offspring in each full-sib family of generations 1 and 2
(P and F1 - must be an even number &gt;= 4).</p>
</td></tr>
<tr><td><code id="simPedDFC_+3A_s">s</code></td>
<td>
<p>Number of sires per full-sib family in generation 1 (P - must be &gt;=2)</p>
</td></tr>
<tr><td><code id="simPedDFC_+3A_fws">fws</code></td>
<td>
<p>Number of generation 1 (P) families with sires. Together, with
<code>s</code>, sets up how cousins and double first cousins are produced</p>
</td></tr>
<tr><td><code id="simPedDFC_+3A_prefix">prefix</code></td>
<td>
<p>Optional prefix to add to every identity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an adaption to a half-sib breeding design which also produces first
cousins and double first cousins. Double first cousins are produced by
mating two brothers to two sisters (the offspring of the resulting two
families are double first cousins with one another). This is described in
Fairbairn and Roff (2006) as being particularly effective for separating
autosomal additive genetic variance from sex chromosomal additive genetic
variance. It is also amenable to estimating dominance variance, however, it
still has difficulty separating dominance variance from common maternal
environmental variance (Meyer 2008).
</p>
<p>For a given unit of the design (<code>U</code> total), <code>2*gpn</code> 0-generation 
(grandparental or GP) individuals are created and paired to make <code>gpn</code>
full-sib families. Then the first <code>fws</code> families are each allocated
<code>s</code> males/sires and <code>s*(fws-1)</code> females/dams in the 1 (parental or P)
generation. The remaining (<code>gpn-fws</code>) families (only when: 
<code>gpn &gt; fws</code>) are assigned <code>s*fws</code> females/dams. If
<code>fsn &gt; (s*fws)</code>, the remaining generation 1 (P) individuals in each 
full-sib family (<code>fsn - (s*fws)</code>) are allocated to each family with
equal numbers of females and males [this allows for more individuals to be
phenotyped in generation 1 (P) than are used to produce generation 2 (F1)].
Generation 2 (F1) is then assigned, based on the mating design in Fairbairn
and Roff (2006) - essentially each sire [of the <code>s</code> per full-sib family
in generation 1 (P)] is mated to a female from each of the other <code>gpn-1</code>
full-sib families to produce <code>fsn</code> offspring (with equal numbers of
females and males).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns corresponding to: id, dam, sire,
and sex. Sex is <code>M</code> for males and <code>F</code> for females.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Fairbairn, D.J. and D.A. Roff. 2006.  The quantitative genetics
of sexual dimorphism: assessing the importance of sex-linkage. Heredity
97:319-328.
</p>
<p>Meyer, K. 2008.  Likelihood calculations to evaluate experimental designs to
estimate genetic variances. Heredity 101:212-221.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simPedHS">simPedHS</a></code>, <code><a href="#topic+warcolak">warcolak</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  DFC1 &lt;- simPedDFC(U = 1, gpn = 2, fsn = 4, s = 2, fws = 2)

</code></pre>

<hr>
<h2 id='simPedHS'>Half-sib pedigree construction</h2><span id='topic+simPedHS'></span>

<h3>Description</h3>

<p>Simulates a pedigree for a half-sib mating design (sometimes also called the
North Carolina Design 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPedHS(s, d, n, uniqueDname = TRUE, prefix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simPedHS_+3A_s">s</code></td>
<td>
<p>Number of sires</p>
</td></tr>
<tr><td><code id="simPedHS_+3A_d">d</code></td>
<td>
<p>Number of dams per sire</p>
</td></tr>
<tr><td><code id="simPedHS_+3A_n">n</code></td>
<td>
<p>Number of offspring per mating (must be &gt; or = 2)</p>
</td></tr>
<tr><td><code id="simPedHS_+3A_uniquedname">uniqueDname</code></td>
<td>
<p>Logical indicating if dams should have unique names
within sire families or throughout the entire pedigree</p>
</td></tr>
<tr><td><code id="simPedHS_+3A_prefix">prefix</code></td>
<td>
<p>Optional prefix to add to every identity</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>n</code> must be greater than or equal to 2, because one male and one female
offspring are produced from each mating
</p>
<p>Some functions/calculations get bogged down if no two dams have the same ID
in the entire pedigree (e.g., <code>aov</code>).  However, other functions must
have unique identifiers for every individual.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns corresponding to: id, dam, sire,
and sex. Sex is &quot;M&quot; for males and &quot;F&quot; for females.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simPedDFC">simPedDFC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  simPedHS(s = 1, d = 3, n = 2)

</code></pre>

<hr>
<h2 id='simPedMCN'>Middle Class Neighborhood pedigree construction</h2><span id='topic+simPedMCN'></span>

<h3>Description</h3>

<p>Simulates a pedigree for the &ldquo;middle class neighborhood&rdquo; mating design
(Shabalina, Yampolsky, and Kondrashov 1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPedMCN(pedTemp, g, Nfam = NULL, noff = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simPedMCN_+3A_pedtemp">pedTemp</code></td>
<td>
<p>A <code>data.frame</code> pedigree of a template pedigree from which
the middle class neighborhood design should continue. If <code>NULL</code>, a new
pedigree will be created with <code>Nfam</code> families.</p>
</td></tr>
<tr><td><code id="simPedMCN_+3A_g">g</code></td>
<td>
<p>Integer number of generations to produce from the middle class
neighborhood design</p>
</td></tr>
<tr><td><code id="simPedMCN_+3A_nfam">Nfam</code></td>
<td>
<p>Integer number of families with which to start a new pedigree
following the middle class neighborhood design.</p>
</td></tr>
<tr><td><code id="simPedMCN_+3A_noff">noff</code></td>
<td>
<p>Integer number of full-sib offspring produced by each family
(must be &gt;=2).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This creates a pedigree following a breeding design which maintains equal
contributions to the next generation by each family in the design. It
effectively removes the effect of natural selection which makes it amenable
to quantify the contribution of mutations to phenotypic variance over the
course of the breeding design.
</p>
<p>For a starting pedigree template (<code>pedTemp</code>), the last generation is used
as parents to begin the breeding design for the next <code>g</code> generations.
The number of families in the last generation of the template pedigree
(<code>pedTemp</code>) will be the number of families in each generation.
</p>
<p>Alternatively, if no template pedigree is provided (<code>pedTemp=NULL</code>),
<code>Nfam</code> number of families will be produced in the first generation from
<code>Nfam</code> unique sire and <code>Nfam</code> unique dams.
</p>
<p>Either <code>pedTemp</code> or <code>Nfam</code> must be <code>NULL</code>, but not both.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns corresponding to: id, dam, sire, sex,
and generation. Sex is <code>M</code> for males and <code>F</code> for females. The
first generation produced in the middle class neighborhood scheme is assigned
a value of &ldquo;1&rdquo;, with their parents being assigned to generation
<code>0</code>. If <code>pedTemp</code> was provided, the generations from this pedigree
will be denoted with negative integers.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Shabalina, S.A, L.Y. Yampolsky, and A.S. Kondrashov. 1997. Rapid
decline of fitness in panmictic populations of Drosophila melanogaster
maintained under relaxed natural selection. Proc. Natl. Acad. Sci. USA.
94:13034-13039.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simPedHS">simPedHS</a></code>, <code><a href="#topic+simPedDFC">simPedDFC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # No template pedigree provided - start from scrtach
  mcn1 &lt;- simPedMCN(pedTemp = NULL, g = 3, Nfam = 4, noff = 2)

 # Provide a template pedigree (half-sib design)
  hsped &lt;- simPedHS(s = 2, d = 2, n = 4)
  mcnHS &lt;- simPedMCN(pedTemp = hsped, g = 3)
</code></pre>

<hr>
<h2 id='sm2list'>Converts a sparse matrix into a three column format.</h2><span id='topic+sm2list'></span>

<h3>Description</h3>

<p>From a sparse matrix object, the three column, row ordered lower triangle of
non-zero elements is created.  Mostly used within other functions (i.e.,
<code>makeD</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2list(A, rownames = NULL, colnames = c("row", "column", "A"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm2list_+3A_a">A</code></td>
<td>
<p>a sparse matrix</p>
</td></tr>
<tr><td><code id="sm2list_+3A_rownames">rownames</code></td>
<td>
<p>a list of rownames from the 'A' matrix.</p>
</td></tr>
<tr><td><code id="sm2list_+3A_colnames">colnames</code></td>
<td>
<p>the columns will be labeled however they are entered in
this character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sparse matrix and three column format must fit CERTAIN assumptions about
row/column sorting and lower/upper triangle matrix.
</p>
<p>Adapted from a function in the <code>MCMCglmm</code> package
</p>


<h3>Value</h3>

<p>returns the list form of the sparse matrix as a <code>data.frame</code>
</p>


<h3>See Also</h3>

<p><code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm</a></code>
</p>

<hr>
<h2 id='varTrans'>Transforms ASReml-R gamma sampling variances to component scale</h2><span id='topic+varTrans'></span>

<h3>Description</h3>

<p>The inverse of the Average Information matrix in an ASReml-R object produces
the sampling variances of the (co)variance components on the gamma scale.
This function scales these variances to the original component scale.  This
allows for Confidence Intervals to be constructed about the variance
component estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varTrans(asr.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varTrans_+3A_asr.object">asr.object</code></td>
<td>
<p>Object from a call to <code>asreml</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector of variances for each variance component in
an ASReml-R model.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
    library(asreml)
    ginvA &lt;- ainverse(warcolak)
    ginvD &lt;- makeD(warcolak[, 1:3])$listDinv
      attr(ginvD, "rowNames") &lt;- as.character(warcolak[, 1])
      attr(ginvD, "INVERSE") &lt;- TRUE
    warcolak$IDD &lt;- warcolak$ID
    warcolak.mod &lt;- asreml(trait1 ~ sex,
     random = ~ vm(ID, ginvA) + vm(IDD, ginvD), 
	data = warcolak) 
    summary(warcolak.mod)$varcomp
    sqrt(varTrans(warcolak.mod))  # sqrt() so can compare with standard errors from summary
   
## End(Not run)

</code></pre>

<hr>
<h2 id='warcolak'>Pedigree and phenotypic values for a mythical population of Warcolaks</h2><span id='topic+warcolak'></span>

<h3>Description</h3>

<p>A two trait example pedigree from the three generation breeding design of
Fairbairn &amp; Roff (2006) with two uncorrelated traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warcolak
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 5400 observations on the following 13 variables:
</p>

<dl>
<dt>ID </dt><dd><p>a factor specifying 5400 unique individual identities</p>
</dd>
<dt>Dam </dt><dd><p>a factor specifying the unique Dam for each individual</p>
</dd>
<dt>Sire </dt><dd><p>a factor specifying the unique Sire for each individual</p>
</dd>
<dt>sex </dt><dd><p>a factor specifying &ldquo;M&rdquo; if the individual is a male 
and &ldquo;F&rdquo; if it is a female</p>
</dd>
<dt>trait1 </dt><dd><p>a numeric vector of phenotypic values: see 
&lsquo;Details&rsquo;</p>
</dd>
<dt>trait2 </dt><dd><p>a numeric vector of phenotypic values: see 
&lsquo;Details&rsquo;</p>
</dd>
<dt>t1_a </dt><dd><p>a numeric vector of the autosomal additive genetic effects 
underlying &lsquo;trait1&rsquo;</p>
</dd>
<dt>t2_a </dt><dd><p>a numeric vector of the autosomal additive genetic effects 
underlying &lsquo;trait2&rsquo;</p>
</dd>
<dt>t2_s </dt><dd><p>a numeric vector of the sex-chromosomal additive genetic 
effects underlying &lsquo;trait2&rsquo;</p>
</dd>
<dt>t1_d </dt><dd><p>a numeric vector of the autosomal dominance genetic effects 
underlying &lsquo;trait1&rsquo;</p>
</dd>
<dt>t2_d </dt><dd><p>a numeric vector of the autosomal dominance genetic effects 
underlying &lsquo;trait2&rsquo;</p>
</dd>
<dt>t2_r </dt><dd><p>a numeric vector of the residual (environmental) effects 
underlying &lsquo;trait1&rsquo;</p>
</dd>
<dt>t2_r </dt><dd><p>a numeric vector of the residual (environmental) effects 
underlying &lsquo;trait2&rsquo;</p>
</dd>
</dl>



<h3>Details</h3>

<p>Unique sets of relatives are specified for a three generation breeding
design (Fairbairn &amp; Roff, 2006).  Each set contains 72 individuals. This
pedigree reflects an experiment which produces 75 of these basic sets from
Fairbairn &amp; Roff's design. The pedigree was created using
<code>simPedDFC()</code>.
</p>
<p>The dataset was simulated to have two uncorrelated traits with different
genetic architectures (see <code>examples</code> below). The trait means are both
equal to 1 for males and 2 for females. The additive genetic, dominance
genetic, and environmental (or residual) variances for both <code>trait1</code>
and <code>trait2</code> are 0.4, 0.3, &amp; 0.3, respectively. However, the additive
genetic variance for <code>trait2</code> can be further decomposed to autosomal
additive genetic variance (0.3) and X-linked additive genetic variance (0.1;
assuming the &lsquo;no global dosage compensation&rsquo; mechanism).
</p>
<p>Females and males have equal variances (except for sex-chromosomal additive
genetic variance, where by definition, males have half of the additive
genetic variance as females; Wolak 2013) and a between-sex correlation of
one for all genetic and residual effects (except the cross-sex residual
covariance=0). All random effects were drawn from multivariate random normal
distributions [e.g., autosomal additive genetic effects: N ~ (0,
kronecker(A, G))] with means of zero and (co)variances equal to the product
of the expected sex-specific (co)variances (e.g., G) and the relatedness (or
incidence) matrix (e.g., A).
</p>
<p>The actual variance in random effects will vary slightly from the amount
specified in the simulation, because of Monte Carlo error. Thus, the random
effects have been included as separate columns in the dataset. See
<code>examples</code> below for the code that generated the dataset.
</p>


<h3>Note</h3>

<p>Before nadiv version 2.14.0, the <code>warcolak</code> dataset used a 0/1
coding for &lsquo;sex&rsquo; and did not contain the random effects.
</p>


<h3>References</h3>

<p>Fairbairn, D.J. &amp; Roff, D.A. 2006. The quantitative genetics of
sexual dimorphism: assessing the importance of sex-linkage. Heredity 97,
319-328.
</p>
<p>Wolak, M.E. 2013. The Quantitative Genetics of Sexual Differences: New
Methodologies and an Empirical Investigation of Sex-Linked, Sex-Specific,
Non-Additive, and Epigenetic Effects. Ph.D. Dissertation. University of
California Riverside.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
  set.seed(101)
  library(nadiv)
  # create pedigree
  warcolak &lt;- simPedDFC(U = 75, gpn = 4, fsn = 4, s = 2)
  names(warcolak)[1:3] &lt;- c("ID", "Dam", "Sire")
  warcolak$trait2 &lt;- warcolak$trait1 &lt;- NA

  # Define covariance matrices for random effects:
  ## Autosomal additive genetic (trait1)
  Ga_t1 &lt;- matrix(c(0.4, rep(0.399999, 2), 0.4), 2, 2)
  ## Autosomal additive genetic (trait2)
  Ga_t2 &lt;- matrix(c(0.3, rep(0.299999, 2), 0.3), 2, 2)
  ## Sex-chromosomal additive genetic (trait2)
  Gs_t2 &lt;- matrix(c(0.1, rep(0.099999, 2), 0.1), 2, 2)
  ## Autosomal dominance genetic
  Gd &lt;- matrix(c(0.3, rep(0.299999, 2), 0.3), 2, 2)
  ## Environmental (or residual)
  ### Assumes no correlated environmental effects between sexes
  R &lt;- diag(c(0.3, 0.3))

  ## define variables to be re-used
  pedn &lt;- nrow(warcolak)
  # Female (homogametic sex chromosomes) in first column
  # Male (heterogametic sex chromosomes) in second column
  sexcol &lt;- as.integer(warcolak$sex)

  # Create random effects
  ## Additive genetic
  ### trait1 autosomal
  tmp_a &lt;- grfx(pedn, G = Ga_t1, incidence = makeA(warcolak[, 1:3]))
    var(tmp_a)
  warcolak$t1_a &lt;- tmp_a[cbind(seq(pedn), sexcol)]
  ### trait2 autosomal
  tmp_a &lt;- grfx(pedn, G = Ga_t2, incidence = makeA(warcolak[, 1:3]))
    var(tmp_a)
  warcolak$t2_a &lt;- tmp_a[cbind(seq(pedn), sexcol)]
  ### trait2 sex-chromosomal
  tmp_s &lt;- grfx(pedn, G = Gs_t2, incidence = makeS(warcolak[, 1:4],
	heterogametic = "M", DosageComp = "ngdc", returnS = TRUE)$S)
    matrix(c(var(tmp_s[which(sexcol == 1), 1]),
	rep(cov(tmp_s)[2, 1], 2), var(tmp_s[which(sexcol == 2), 2])), 2, 2)
    # NOTE above should be: covar = male var = 0.5* female var 
  warcolak$t2_s &lt;- tmp_s[cbind(seq(pedn), sexcol)]

  ## Dominance genetic
  ### trait1 
  tmp_d &lt;- grfx(pedn, G = Gd, incidence = makeD(warcolak[, 1:3], invertD = FALSE)$D)
    var(tmp_d)
  warcolak$t1_d &lt;- tmp_d[cbind(seq(pedn), sexcol)]
  ### trait2
  tmp_d &lt;- grfx(pedn, G = Gd, incidence = makeD(warcolak[, 1:3], invertD = FALSE)$D)
    var(tmp_d)
  warcolak$t2_d &lt;- tmp_d[cbind(seq(pedn), sexcol)]

  ## Residual
  ### trait1
  tmp_r &lt;- grfx(pedn, G = R, incidence = NULL) # warning of identity matrix
    var(tmp_r)
  warcolak$t1_r &lt;- tmp_r[cbind(seq(pedn), sexcol)]
  ### trait2
  tmp_r &lt;- grfx(pedn, G = R, incidence = NULL) # warning of identity matrix
    var(tmp_r)
  warcolak$t2_r &lt;- tmp_r[cbind(seq(pedn), sexcol)]

  # Sum random effects and add sex-specific means to get phenotypes
  ## females have slightly greater mean trait values
  warcolak$trait1 &lt;- 1 + (-1*sexcol + 2) + rowSums(warcolak[, c("t1_a", "t1_d", "t1_r")])
  warcolak$trait2 &lt;- 1 + (-1*sexcol + 2) + rowSums(warcolak[, c("t2_a", "t2_s", "t2_d", "t2_r")])
 

</code></pre>

<hr>
<h2 id='Wray90'>Pedigree, adapted from Wray (1990)</h2><span id='topic+Wray90'></span>

<h3>Description</h3>

<p>Pedigree, adapted from Wray (1990)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wray90
</code></pre>


<h3>Format</h3>

<p>A data frame with 8 observations on the following 4 variables:
</p>

<dl>
<dt><code>id</code> </dt><dd><p>a numeric vector</p>
</dd>
<dt><code>dam</code> </dt><dd><p>a numeric vector</p>
</dd>
<dt><code>sire</code> </dt><dd><p>a numeric vector</p>
</dd>
<dt><code>time</code> </dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wray, N.A. 1990. Accounting for mutation effects in the additive
genetic variance-covariance matrix and its inverse. Biometrics. 46:177-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Wray90)
  str(Wray90)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
