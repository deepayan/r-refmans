<!DOCTYPE html><html><head><title>Help for package LexFindR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LexFindR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_escape'><p>Escape sep and target in regex</p></a></li>
<li><a href='#check_input'><p>Check input and raise warnings as needed</p></a></li>
<li><a href='#get_cohorts'><p>Get cohort competitors</p></a></li>
<li><a href='#get_cohortsP'><p>Get CohortsPrime</p></a></li>
<li><a href='#get_embeds_in_target'><p>Get embedding competitors</p></a></li>
<li><a href='#get_embeds_in_targetP'><p>Get embeds-in-target PRIME</p></a></li>
<li><a href='#get_fw'><p>Get the log Frequency Weight (FW) of a competitor set</p></a></li>
<li><a href='#get_fwcp'><p>Get the log Frequency Weighted Competitor Probability (FWCP)</p></a></li>
<li><a href='#get_generic'><p>Get competitors in spoken word recognition</p></a></li>
<li><a href='#get_homoforms'><p>Get homophones</p></a></li>
<li><a href='#get_neighbors'><p>Get phonological neighbors</p></a></li>
<li><a href='#get_neighborsP'><p>Get NeighborssPrime</p></a></li>
<li><a href='#get_nohorts'><p>Get nohorts</p></a></li>
<li><a href='#get_return'><p>Return lexical items the appropriate type</p></a></li>
<li><a href='#get_rhymes'><p>Get rhyme competitors</p></a></li>
<li><a href='#get_target_embeds_in'><p>Get embedded competitors</p></a></li>
<li><a href='#get_target_embeds_inP'><p>Get target-embeds-in PRIME</p></a></li>
<li><a href='#get_uniqpt'><p>Get phonological uniqueness point</p></a></li>
<li><a href='#lemmalex'><p>Lemmalex dictionary</p></a></li>
<li><a href='#LexFindR'><p>LexFindR: A package for finding related items and lexical dimensions in a</p>
lexicon.</a></li>
<li><a href='#slex'><p>slex ARPAbet</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Find Related Items and Lexical Dimensions in a Lexicon</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-23</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements code to identify lexical competitors in a given list
  of words. We include many of the standard competitor types used in spoken word
  recognition research, such as functions to find cohorts, neighbors, and
  rhymes, amongst many others. The package includes documentation for using a
  variety of lexicon files, including those with form codes made up of multiple
  letters (i.e., phoneme codes) and also basic orthographies. Importantly, the
  code makes use of multiple CPU cores and vectorization when possible, making
  it extremely fast and able to handle large lexicons. Additionally, the package
  contains documentation for users to easily write new functions, allowing
  researchers to examine other relationships within a lexicon. 
  Preprint: <a href="https://psyarxiv.com/8dyru/">https://psyarxiv.com/8dyru/</a>. Open access: <a href="https://link.springer.com/epdf/10.3758/s13428-021-01667-6?sharing_token=9WlO9soCc9y0uSuwWSUYfJAH0g46feNdnc402WrhzyrdKcK8uzZx_hDEtgbYzn3gvxdG5Cuj0j0cC4lVMFBqYCGTQmE2blN2Gwo74LJ8ro1pEOAYDRFy6Lhf1nc719vD-zU7GDvKOQxDAwPbrisvPBeXSIu0NkqXF7Jx3IuUwIs%3D">https://link.springer.com/epdf/10.3758/s13428-021-01667-6?sharing_token=9WlO9soCc9y0uSuwWSUYfJAH0g46feNdnc402WrhzyrdKcK8uzZx_hDEtgbYzn3gvxdG5Cuj0j0cC4lVMFBqYCGTQmE2blN2Gwo74LJ8ro1pEOAYDRFy6Lhf1nc719vD-zU7GDvKOQxDAwPbrisvPBeXSIu0NkqXF7Jx3IuUwIs%3D</a>. 
  Citation: Li, Z., Crinnion, A.M. &amp; Magnuson, J.S. (2021). 
  &lt;<a href="https://doi.org/10.3758%2Fs13428-021-01667-6">doi:10.3758/s13428-021-01667-6</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tidyverse, knitr, rmarkdown, testthat, future.apply, tictoc</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/maglab-uconn/LexFindR">https://github.com/maglab-uconn/LexFindR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/maglab-uconn/LexFindR/issues">https://github.com/maglab-uconn/LexFindR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-28 13:40:11 UTC; zhaobinli</td>
</tr>
<tr>
<td>Author:</td>
<td>ZhaoBin Li [aut, cre],
  Anne Marie Crinnion [aut],
  James S. Magnuson [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>ZhaoBin Li &lt;bzilplj@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-29 06:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_escape'>Escape sep and target in regex</h2><span id='topic+add_escape'></span>

<h3>Description</h3>

<p>Escape sep and target in regex
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_escape(target, sep, split = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_escape_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="add_escape_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="add_escape_+3A_split">split</code></td>
<td>
<p>Whether to split the target based on sep
and escape every element in the character list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>escaped sep and target
</p>

<hr>
<h2 id='check_input'>Check input and raise warnings as needed</h2><span id='topic+check_input'></span>

<h3>Description</h3>

<p>Check input and raise warnings as needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_input(target, lexicon, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_input_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="check_input_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="check_input_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>

<hr>
<h2 id='get_cohorts'>Get cohort competitors</h2><span id='topic+get_cohorts'></span>

<h3>Description</h3>

<p>Cohorts overlap in onset phoneme(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cohorts(
  target,
  lexicon,
  sep = " ",
  form = FALSE,
  count = FALSE,
  overlap = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cohorts_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_cohorts_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_cohorts_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_cohorts_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_cohorts_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
<tr><td><code id="get_cohorts_+3A_overlap">overlap</code></td>
<td>
<p>(<em>get_cohorts</em> only) Integer specifying the number of
onset phonemes to overlap for matching with the target word</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_cohorts("AA R K", c("AA R K", "AA R T", "B AA B"))
</code></pre>

<hr>
<h2 id='get_cohortsP'>Get CohortsPrime</h2><span id='topic+get_cohortsP'></span>

<h3>Description</h3>

<p>Cohorts that are not neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cohortsP(
  target,
  lexicon,
  neighbors = "das",
  sep = " ",
  form = FALSE,
  count = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cohortsP_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_cohortsP_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_cohortsP_+3A_neighbors">neighbors</code></td>
<td>
<p>(<em>get_neighbors</em> only) Character vector specifying the
type of neighbor to return. Return the delete, add, substitute neighbors of
the target when 'd', 'a', and/or 's' is in neighbors respectively</p>
</td></tr>
<tr><td><code id="get_cohortsP_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_cohortsP_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_cohortsP_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_cohortsP("AA R K", c("AA R K", "AA R", "B AA B"), neighbors = "das")
</code></pre>

<hr>
<h2 id='get_embeds_in_target'>Get embedding competitors</h2><span id='topic+get_embeds_in_target'></span>

<h3>Description</h3>

<p>Embedding competitors are items embedded in target
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_embeds_in_target(target, lexicon, sep = " ", form = FALSE, count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_embeds_in_target_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_embeds_in_target_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_embeds_in_target_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_embeds_in_target_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_embeds_in_target_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_embeds_in_target("AA R K", c("AA R K", "AA R", "B AA B"))
</code></pre>

<hr>
<h2 id='get_embeds_in_targetP'>Get embeds-in-target PRIME</h2><span id='topic+get_embeds_in_targetP'></span>

<h3>Description</h3>

<p>Items embedded in the target which are not cohorts or neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_embeds_in_targetP(
  target,
  lexicon,
  neighbors = "das",
  sep = " ",
  form = FALSE,
  count = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_embeds_in_targetP_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_embeds_in_targetP_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_embeds_in_targetP_+3A_neighbors">neighbors</code></td>
<td>
<p>(<em>get_neighbors</em> only) Character vector specifying the
type of neighbor to return. Return the delete, add, substitute neighbors of
the target when 'd', 'a', and/or 's' is in neighbors respectively</p>
</td></tr>
<tr><td><code id="get_embeds_in_targetP_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_embeds_in_targetP_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_embeds_in_targetP_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_embeds_in_targetP("B AA R K IY", c("AA R K", "AA R", "AA R K IY", "B AA R"))
</code></pre>

<hr>
<h2 id='get_fw'>Get the log Frequency Weight (FW) of a competitor set</h2><span id='topic+get_fw'></span>

<h3>Description</h3>

<p>Get the log Frequency Weight (FW) of a competitor set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fw(competitors_freq, pad = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fw_+3A_competitors_freq">competitors_freq</code></td>
<td>
<p>Numeric vector containing the frequencies of
competitors (including itself)</p>
</td></tr>
<tr><td><code id="get_fw_+3A_pad">pad</code></td>
<td>
<p>Value to add to frequencies before taking log; if your
minimum frequency is 0, consider adding a value between 1 and 2;
if your minimum frequency is between 0 and 1, consider adding 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FW
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_fw(c(10, 50), pad = 1)
</code></pre>

<hr>
<h2 id='get_fwcp'>Get the log Frequency Weighted Competitor Probability (FWCP)</h2><span id='topic+get_fwcp'></span>

<h3>Description</h3>

<p>Get the log Frequency Weighted Competitor Probability (FWCP)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fwcp(target_freq, competitors_freq, pad = 0, add_target = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fwcp_+3A_target_freq">target_freq</code></td>
<td>
<p>Frequency of target word</p>
</td></tr>
<tr><td><code id="get_fwcp_+3A_competitors_freq">competitors_freq</code></td>
<td>
<p>Numeric vector containing the frequencies of
competitors (including itself)</p>
</td></tr>
<tr><td><code id="get_fwcp_+3A_pad">pad</code></td>
<td>
<p>Value to add to frequencies before taking log; if your
minimum frequency is 0, consider adding a value between 1 and 2;
if your minimum frequency is between 0 and 1, consider adding 1</p>
</td></tr>
<tr><td><code id="get_fwcp_+3A_add_target">add_target</code></td>
<td>
<p>Boolean; set to TRUE if you want the target
frequency added to the denominator; only do this if the target is
not already included in the competitor set (e.g., if the target
is in the lexicon, it will be captured as its own neighbor, its
own cohort, etc.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log FWCP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_fwcp(100, c(10, 50), pad = 1)
</code></pre>

<hr>
<h2 id='get_generic'>Get competitors in spoken word recognition</h2><span id='topic+get_generic'></span>

<h3>Description</h3>

<p>Get competitors in spoken word recognition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_generic(target, lexicon, neighbors, sep, form, count, overlap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_generic_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_generic_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_generic_+3A_neighbors">neighbors</code></td>
<td>
<p>(<em>get_neighbors</em> only) Character vector specifying the
type of neighbor to return. Return the delete, add, substitute neighbors of
the target when 'd', 'a', and/or 's' is in neighbors respectively</p>
</td></tr>
<tr><td><code id="get_generic_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_generic_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_generic_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
<tr><td><code id="get_generic_+3A_overlap">overlap</code></td>
<td>
<p>(<em>get_cohorts</em> only) Integer specifying the number of
onset phonemes to overlap for matching with the target word</p>
</td></tr>
<tr><td><code id="get_generic_+3A_mismatch">mismatch</code></td>
<td>
<p>(<em>get_rhymes</em> only) Integer specifying the number of
onset phonemes to mismatch for matching with the target word</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>

<hr>
<h2 id='get_homoforms'>Get homophones</h2><span id='topic+get_homoforms'></span>

<h3>Description</h3>

<p>Homophones are items which sound similar to the target
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_homoforms(target, lexicon, sep = " ", form = FALSE, count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_homoforms_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_homoforms_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_homoforms_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_homoforms_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_homoforms_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_homoforms("AA R K", c("AA R K", "AA R", "B AA B"))
</code></pre>

<hr>
<h2 id='get_neighbors'>Get phonological neighbors</h2><span id='topic+get_neighbors'></span>

<h3>Description</h3>

<p>Phonological neighbors are items which can be converted
to the target by one add, delete and substitute operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_neighbors(
  target,
  lexicon,
  neighbors = "das",
  sep = " ",
  form = FALSE,
  count = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_neighbors_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_neighbors_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_neighbors_+3A_neighbors">neighbors</code></td>
<td>
<p>(<em>get_neighbors</em> only) Character vector specifying the
type of neighbor to return. Return the delete, add, substitute neighbors of
the target when 'd', 'a', and/or 's' is in neighbors respectively</p>
</td></tr>
<tr><td><code id="get_neighbors_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_neighbors_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_neighbors_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_neighbors("AA R K", c("AA R K", "AA R", "B AA B"), "d")
get_neighbors("AA R K", c("AA R K", "AA R", "B AA B"), "da")
get_neighbors("AA R K", c("AA R K", "AA R", "B AA B"), "das")
</code></pre>

<hr>
<h2 id='get_neighborsP'>Get NeighborssPrime</h2><span id='topic+get_neighborsP'></span>

<h3>Description</h3>

<p>Neighbors which are not cohorts or rhymes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_neighborsP(
  target,
  lexicon,
  neighbors = "das",
  sep = " ",
  form = FALSE,
  count = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_neighborsP_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_neighborsP_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_neighborsP_+3A_neighbors">neighbors</code></td>
<td>
<p>(<em>get_neighbors</em> only) Character vector specifying the
type of neighbor to return. Return the delete, add, substitute neighbors of
the target when 'd', 'a', and/or 's' is in neighbors respectively</p>
</td></tr>
<tr><td><code id="get_neighborsP_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_neighborsP_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_neighborsP_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_neighborsP("AA R K", c("AA R K", "AA R", "B AA B"), neighbors = "das")
</code></pre>

<hr>
<h2 id='get_nohorts'>Get nohorts</h2><span id='topic+get_nohorts'></span>

<h3>Description</h3>

<p>Items which are both cohorts and neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nohorts(
  target,
  lexicon,
  neighbors = "das",
  sep = " ",
  form = FALSE,
  count = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nohorts_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_nohorts_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_nohorts_+3A_neighbors">neighbors</code></td>
<td>
<p>(<em>get_neighbors</em> only) Character vector specifying the
type of neighbor to return. Return the delete, add, substitute neighbors of
the target when 'd', 'a', and/or 's' is in neighbors respectively</p>
</td></tr>
<tr><td><code id="get_nohorts_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_nohorts_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_nohorts_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_nohorts("AA R K", c("AA R K", "AA R", "B AA B"), neighbors = "das")
</code></pre>

<hr>
<h2 id='get_return'>Return lexical items the appropriate type</h2><span id='topic+get_return'></span>

<h3>Description</h3>

<p>Return lexical items the appropriate type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_return(idx, lexicon, form, count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_return_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_return_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_return_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the appropriate type
</p>

<hr>
<h2 id='get_rhymes'>Get rhyme competitors</h2><span id='topic+get_rhymes'></span>

<h3>Description</h3>

<p>Rhymes overlap in all except onset phoneme(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rhymes(
  target,
  lexicon,
  sep = " ",
  form = FALSE,
  count = FALSE,
  mismatch = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_rhymes_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_rhymes_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_rhymes_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_rhymes_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_rhymes_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
<tr><td><code id="get_rhymes_+3A_mismatch">mismatch</code></td>
<td>
<p>(<em>get_rhymes</em> only) Integer specifying the number of
onset phonemes to mismatch for matching with the target word</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_rhymes("AA R K", c("AA R K", "B AA R K", "B AA B"))
</code></pre>

<hr>
<h2 id='get_target_embeds_in'>Get embedded competitors</h2><span id='topic+get_target_embeds_in'></span>

<h3>Description</h3>

<p>Embedded competitors are items which the target embedded in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_target_embeds_in(target, lexicon, sep = " ", form = FALSE, count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_target_embeds_in_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_target_embeds_in_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_target_embeds_in_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_target_embeds_in_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_target_embeds_in_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_target_embeds_in("AA R K", c("AA R K", "B AA R K", "B AA B"))
</code></pre>

<hr>
<h2 id='get_target_embeds_inP'>Get target-embeds-in PRIME</h2><span id='topic+get_target_embeds_inP'></span>

<h3>Description</h3>

<p>Items the target embeds into which are not cohorts or neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_target_embeds_inP(
  target,
  lexicon,
  neighbors = "das",
  sep = " ",
  form = FALSE,
  count = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_target_embeds_inP_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_target_embeds_inP_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_target_embeds_inP_+3A_neighbors">neighbors</code></td>
<td>
<p>(<em>get_neighbors</em> only) Character vector specifying the
type of neighbor to return. Return the delete, add, substitute neighbors of
the target when 'd', 'a', and/or 's' is in neighbors respectively</p>
</td></tr>
<tr><td><code id="get_target_embeds_inP_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
<tr><td><code id="get_target_embeds_inP_+3A_form">form</code></td>
<td>
<p>Whether to return words in lexicon</p>
</td></tr>
<tr><td><code id="get_target_embeds_inP_+3A_count">count</code></td>
<td>
<p>Whether to return count of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indexes of the competitors in the lexical database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_target_embeds_inP("B AA R K", c("AA R K", "AA R", "B AA R K IY", "B AA R"))
</code></pre>

<hr>
<h2 id='get_uniqpt'>Get phonological uniqueness point</h2><span id='topic+get_uniqpt'></span>

<h3>Description</h3>

<p>Phonological uniqueness point is the index at which the
target becomes unique in the lexicon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_uniqpt(target, lexicon, sep = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_uniqpt_+3A_target">target</code></td>
<td>
<p>Character string containing a target word</p>
</td></tr>
<tr><td><code id="get_uniqpt_+3A_lexicon">lexicon</code></td>
<td>
<p>Character vector containing the lexical database</p>
</td></tr>
<tr><td><code id="get_uniqpt_+3A_sep">sep</code></td>
<td>
<p>Separator in target and lexicon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Target is not unique: length + 1, else index where target
becomes unique in lexicon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_uniqpt("AA R K", c("AA R", "B AA B", "B AA R K"))
</code></pre>

<hr>
<h2 id='lemmalex'>Lemmalex dictionary</h2><span id='topic+lemmalex'></span>

<h3>Description</h3>

<p>Lemmalex is primarily based on the SUBTLEXus subtitle corpus
(based on American subtitles with 51 million items in total)
reduced to lemma using a copyrighted database (Francis and Kučera, 1982).
The pronunciation is given by CMU Pronouncing Dictionary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lemmalex
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 17750 rows and 3 columns.
</p>


<h3>Details</h3>

<p>Reference: Brysbaert, M., &amp; New, B. (2009). Moving beyond Kučera and Francis:
A critical evaluation of current word frequency norms and the introduction of
a new and improved word frequency measure for American English. Behavior
research methods, 41(4), 977-990.
</p>
<p>Kučera, H., &amp; Francis, W. N. (1967). Computational analysis of present-day
American English. Brown university press.
</p>
<p>CMU Pronouncing Dictionary: http://www.speech.cs.cmu.edu/cgi-bin/cmudict
</p>
<p>@format A table with 20,293 rows and 3 variables:
</p>

<dl>
<dt>Item</dt><dd><p>SUBTLEXus dictionary reduced to lemmas</p>
</dd>
<dt>Frequency</dt><dd><p>Number of times the item appeared in the SUBTLEXus corpus</p>
</dd>
<dt>Pronunciation</dt><dd><p>ARPAbet transcription according to CMU</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://www.ugent.be/pp/experimentele-psychologie/en/research/documents/subtlexus">https://www.ugent.be/pp/experimentele-psychologie/en/research/documents/subtlexus</a>
</p>

<hr>
<h2 id='LexFindR'>LexFindR: A package for finding related items and lexical dimensions in a
lexicon.</h2><span id='topic+LexFindR'></span>

<h3>Description</h3>

<p>This package implements code to identify lexical competitors in a given list
of words. We include many of the standard competitor types used in spoken
word recognition research, such as functions to find cohorts, neighbors, and
rhymes, amongst many others. The package includes documentation for using a
variety of lexicon files, including those with form codes made up of multiple
letters (i.e., phoneme codes) and also basic orthographies. Importantly, the
code makes use of multiple CPU cores and vectorization when possible, making
it extremely fast and able to handle large lexicons. Additionally, the
package contains documentation for users to easily write new functions,
allowing researchers to examine other relationships within a lexicon.
</p>

<hr>
<h2 id='slex'>slex ARPAbet</h2><span id='topic+slex'></span>

<h3>Description</h3>

<p>TRACE slex lexicon translated by Nenadić and Tucker into ARPAbet
pronunciation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slex
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 212 rows and 3 columns.
</p>


<h3>Details</h3>

<p>TRACE slex lexicon with Frequencies: McClelland, J. L., &amp; Elman, J. L.
(1986). The TRACE model of speech perception. Cognitive psychology, 18(1),
1-86.
</p>
<p>APRAbet transcription: Nenadić, F., &amp; Tucker, B. V. (2020). Computational
modelling of an auditory lexical decision experiment using jTRACE and TISK.
Language, Cognition and Neuroscience, 1-29.
</p>
<p>@format A table with 212 rows and 2 variables:
</p>

<dl>
<dt>Item</dt><dd><p>TRACE slex transcription</p>
</dd>
<dt>Pronunciation</dt><dd><p>ARPAbet transcription</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://era.library.ualberta.ca/items/61319cc6-436a-428c-b960-545bdc9bd5d3">https://era.library.ualberta.ca/items/61319cc6-436a-428c-b960-545bdc9bd5d3</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
