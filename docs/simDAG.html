<!DOCTYPE html><html><head><title>Help for package simDAG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simDAG}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simDAG-package'>
<p>Simulate Data from a DAG and Associated Node Information</p></a></li>
<li><a href='#add_node'>
<p>Add a <code>DAG.node</code> object to a <code>DAG</code> object</p></a></li>
<li><a href='#as.igraph.DAG'>
<p>Transform a DAG object into an <code>igraph</code> object</p></a></li>
<li><a href='#dag_from_data'>
<p>Fills a partially specified <code>DAG</code> object with parameters estimated from reference data</p></a></li>
<li><a href='#dag2matrix'>
<p>Obtain a Adjacency Matrix from a <code>DAG</code> object</p></a></li>
<li><a href='#do'>
<p>Pearls do-operator for <code>DAG</code> objects</p></a></li>
<li><a href='#empty_dag'>
<p>Initialize an empty <code>DAG</code> object</p></a></li>
<li><a href='#long2start_stop'>
<p>Transform a <code>data.table</code> in the long-format to a <code>data.table</code> in the start-stop format</p></a></li>
<li><a href='#matrix2dag'>
<p>Obtain a <code>DAG</code> object from a Adjacency Matrix and a List of Node Types</p></a></li>
<li><a href='#node'>
<p>Create a node object to grow a DAG step-by-step</p></a></li>
<li><a href='#node_binomial'>
<p>Simulate a Node Using Logistic Regression</p></a></li>
<li><a href='#node_competing_events'>
<p>Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation</p></a></li>
<li><a href='#node_conditional_distr'>
<p>Simulate a Node by Sampling from Different Distributions based on Strata</p></a></li>
<li><a href='#node_conditional_prob'>
<p>Simulate a Node Using Conditional Probabilities</p></a></li>
<li><a href='#node_cox'>
<p>Simulate a Node Using Cox-Regression</p></a></li>
<li><a href='#node_custom'>
<p>Create Your Own Function to Simulate a Root Node, Child Node or Time-Dependent Node</p></a></li>
<li><a href='#node_gaussian'>
<p>Simulate a Node Using Linear Regression</p></a></li>
<li><a href='#node_multinomial'>
<p>Simulate a Node Using Multinomial Regression</p></a></li>
<li><a href='#node_negative_binomial'>
<p>Simulate a Node Using Negative Binomial Regression</p></a></li>
<li><a href='#node_poisson'>
<p>Simulate a Node Using Poisson Regression</p></a></li>
<li><a href='#node_time_to_event'>
<p>Simulate a Time-to-Event Node in Discrete-Time Simulation</p></a></li>
<li><a href='#plot.DAG'>
<p>Plot a <code>DAG</code> object</p></a></li>
<li><a href='#plot.simDT'>
<p>Create a Simple Flowchart for a Discrete-Time Simulation</p></a></li>
<li><a href='#rbernoulli'>
<p>Generate Random Draws from a Bernoulli Distribution</p></a></li>
<li><a href='#rcategorical'>
<p>Generate Random Draws from a Discrete Set of Labels with Associated Probabilities</p></a></li>
<li><a href='#rconstant'>
<p>Use a single constant value for a root node</p></a></li>
<li><a href='#sim_discrete_time'>
<p>Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information</p></a></li>
<li><a href='#sim_from_dag'>
<p>Simulate Data from a Given DAG and Node Information</p></a></li>
<li><a href='#sim_n_datasets'>
<p>Generate multiple datasets from a single <code>DAG</code> object</p></a></li>
<li><a href='#sim2data'>
<p>Transform <code>sim_discrete_time</code> output into the start-stop, long- or wide-format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulate Data from a DAG and Associated Node Information</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin Denz &lt;robin.denz@rub.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate complex data from a given directed acyclic graph and information about each individual node.
	Root nodes are simply sampled from the specified distribution. Child Nodes are simulated according to
	one of many implemented regressions, such as logistic regression, linear
	regression, poisson regression and more. Also includes a comprehensive framework for discrete-time
	simulation, which can generate even more complex longitudinal data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinDenz1/simDAG">https://github.com/RobinDenz1/simDAG</a>,
<a href="https://robindenz1.github.io/simDAG/">https://robindenz1.github.io/simDAG/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinDenz1/siMDAG/issues">https://github.com/RobinDenz1/siMDAG/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.15.0), Rfast, rlang, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), vdiffr (&ge; 1.0.0),
ggplot2, ggforce, MASS, covr, foreach, doSNOW, doRNG, parallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Contact:</td>
<td>&lt;robin.denz@rub.de&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-13 14:23:42 UTC; Robin Denz</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin Denz [aut, cre],
  Katharina Meiszl [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-13 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simDAG-package'>
Simulate Data from a DAG and Associated Node Information
</h2><span id='topic+simDAG-package'></span>

<h3>Description</h3>

<p><strong><em>What is this package about?</em></strong>
</p>
<p>This package aims to give a comprehensive framework to simulate static and longitudinal data given a directed acyclic graph and some information about each node. Our goal is to make this package as user-friendly and intuitive as possible, while allowing extreme flexibility and while keeping the underlying code as fast and RAM efficient as possible.
</p>
<p><strong><em>What features are included in this package?</em></strong>
</p>
<p>This package includes two main simulation functions: the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function, which can be used to simulate data from a previously defined causal DAG and node information and the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function, which implements a framework to conduct discrete-time simulations. The former is very easy to use, but cannot deal with time-varying variable easily. The latter is a little more difficult to use (usually requiring the user to write some functions himself), but allows the simulation of arbitrarily complex longitudinal data.
</p>
<p>Through a collection of implemented node types, this package allows the user to generate data with a mix of binary, categorical, count and time-to-event data. The <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function additionally enables the user to generate time-to-event data with, if desired, a mix of competing events, recurrent events, time-varying variables that influence each other and any types of censoring.
</p>
<p>The package also includes a few functions to transform resulting data into multiple formats, to augment existing DAGs, to plot DAGs and to plot a flow-chart of the data generation process.
</p>
<p><strong><em>What does a typical workflow using this package look like?</em></strong>
</p>
<p>Users should start by defining a <code>DAG</code> object using the <code><a href="#topic+empty_dag">empty_dag</a></code> and <code><a href="#topic+node">node</a></code> functions. This <code>DAG</code> can then be passed to one of the two simulation functions included in this package. More information on how to do this can be found in the respective documentation pages and the three vignettes of this package.
</p>
<p><strong><em>When should I use <code>sim_from_dag</code> and when <code>sim_discrete_time</code>?</em></strong>
</p>
<p>If you want to simulate data that is easily described using a standard DAG without time-varying variables, you should use the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function. If the DAG includes time-varying variables, but you only want to consider a few points in time and can easily describe the relations between those manually, you can still use the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function. If you want more complex data with time-varying variables, particularly with time-to-event outcomes, you should consider using the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function.
</p>
<p><strong><em>What features are missing from this package?</em></strong>
</p>
<p>The package currently only implements some possible child nodes. In the future we would like to implement more child node types, such as nodes with generalized mixed linear models or more complex survival time models.
</p>
<p><strong><em>Why should I use this package instead of the <span class="pkg">simCausal</span> package?</em></strong>
</p>
<p>The <span class="pkg">simCausal</span> package was a big inspiration for this package. In contrast to it, however, it allows quite a bit more flexibility. A big difference is that this package includes a comprehensive framework for discrete-time simulations and the <span class="pkg">simCausal</span> package does not.
</p>
<p><strong><em>Where can I get more information?</em></strong>
</p>
<p>The documentation pages contain a lot of information, relevant examples and some literature references. Additional examples can be found in the vignettes of this package, which can be accessed using:
</p>

<ul>
<li><p><code>vignette(topic="v_sim_from_dag", package="simDAG")</code>
</p>
</li>
<li><p><code>vignette(topic="v_sim_discrete_time", package="simDAG")</code>
</p>
</li>
<li><p><code>vignette(topic="v_covid_example", package="simDAG")</code>
</p>
</li></ul>

<p>We are also working on a separate article on this package that is going to be published in a peer-reviewed journal.
</p>
<p><strong><em>I have a problem using the <code>sim_discrete_time</code> function</em></strong>
</p>
<p>The <code>sim_discrete_time</code> function can become difficult to use depending on what kind of data the user wants to generate. For this reason we put in extra effort to make the documentation and examples as clear and helpful as possible. Please consult the relevant documentation pages and the vignettes before contacting the authors directly with programming related questions that are not clearly bugs in the code.
</p>
<p><strong><em>I want to suggest a new feature / I want to report a bug. Where can I do this?</em></strong>
</p>
<p>Bug reports, suggestions and feature requests are highly welcome. Please file an issue on the official github page or contact the author directly using the supplied e-mail address.
</p>


<h3>Author(s)</h3>

<p>Robin Denz, &lt;robin.denz@rub.de&gt;
</p>


<h3>References</h3>

<p>Banks, Jerry, John S. Carson II, Barry L. Nelson, and David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited.
</p>

<hr>
<h2 id='add_node'>
Add a <code>DAG.node</code> object to a <code>DAG</code> object
</h2><span id='topic+add_node'></span><span id='topic++2B.DAG'></span>

<h3>Description</h3>

<p>This function allows users to add <code>DAG.node</code> objects created using the <code><a href="#topic+node">node</a></code> or <code><a href="#topic+node_td">node_td</a></code> function to <code>DAG</code> objects created using the <code><a href="#topic+empty_dag">empty_dag</a></code> function, which makes it easy to fully specify a DAG to use in the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function and <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_node(dag, node)

## S3 method for class 'DAG'
object_1 + object_2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_node_+3A_dag">dag</code></td>
<td>

<p>A <code>DAG</code> object created using the <code><a href="#topic+empty_dag">empty_dag</a></code> function.
</p>
</td></tr>
<tr><td><code id="add_node_+3A_node">node</code></td>
<td>

<p>A <code>DAG.node</code> object created using the <code><a href="#topic+node">node</a></code> function or <code><a href="#topic+node_td">node_td</a></code> function.
</p>
</td></tr>
<tr><td><code id="add_node_+3A_object_1">object_1</code></td>
<td>

<p>Either a <code>DAG</code> object or a <code>DAG.node</code> object. The order of the objects does not change the result.
</p>
</td></tr>
<tr><td><code id="add_node_+3A_object_2">object_2</code></td>
<td>

<p>See argument <code>object_1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two ways of adding a node to a <code>DAG</code> object are: <code>dag &lt;- add_node(dag, node(...))</code> and <code>dag &lt;- dag + node(...)</code>, which give identical results (note that the <code>...</code> should be replaced with actual arguments and that the initial <code>dag</code> should be created with a call to <code>empty_dag</code>). See <code><a href="#topic+node">node</a></code> for more information on how to specify a <code>DAG</code> for use in the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> and <code><a href="#topic+node_td">node_td</a></code> functions.
</p>


<h3>Value</h3>

<p>Returns an <code>DAG</code> object with the <code>DAG.node</code> object added to it.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

## add nodes to DAG using +
dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=5) +
  node("sex", type="rbernoulli", p=0.5) +
  node("income", type="gaussian", parents=c("age", "sex"), betas=c(1.1, 0.2),
       intercept=-5, error=4)

## add nodes to DAG using add_node()
dag &lt;- empty_dag()
dag &lt;- add_node(dag, node("age", type="rnorm", mean=50, sd=5))
</code></pre>

<hr>
<h2 id='as.igraph.DAG'>
Transform a DAG object into an <code>igraph</code> object
</h2><span id='topic+as.igraph.DAG'></span>

<h3>Description</h3>

<p>This function extends the <code>as.igraph</code> function from the <code>igraph</code> package to allow the input of a <code>DAG</code> object. The result is an <code>igraph</code> object that includes only the structure of the DAG, not any specifications. May be useful for plotting purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DAG'
as.igraph(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.igraph.DAG_+3A_x">x</code></td>
<td>

<p>A <code>DAG</code> object created using the <code><a href="#topic+empty_dag">empty_dag</a></code> function with nodes added to it using the <code>+</code> syntax. See <code>?empty_dag</code> or <code>?node</code> for more details. Supports DAGs with time-dependent nodes added using the <code><a href="#topic+node_td">node_td</a></code> function. However, including such DAGs may result in cyclic causal structures, because time is not represented in the output matrix.
</p>
</td></tr>
<tr><td><code id="as.igraph.DAG_+3A_...">...</code></td>
<td>

<p>Currently not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>igraph</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

# some example DAG
dag &lt;- empty_dag() +
  node("death", type="binomial", parents=c("age", "sex"), betas=c(1, 2),
       intercept=-10) +
  node("age", type="rnorm", mean=10, sd=2) +
  node("sex", parents="", type="rbernoulli", p=0.5) +
  node("smoking", parents=c("sex", "age"), type="binomial",
       betas=c(0.6, 0.2), intercept=-2)

if (requireNamespace("igraph")) {
  g &lt;- igraph::as.igraph(dag)
  plot(g)
}
</code></pre>

<hr>
<h2 id='dag_from_data'>
Fills a partially specified <code>DAG</code> object with parameters estimated from reference data
</h2><span id='topic+dag_from_data'></span>

<h3>Description</h3>

<p>Given a partially specified <code>DAG</code> object, where only the <code>name</code>, <code>type</code> and the <code>parents</code> are specified plus a <code>data.frame</code> containing realizations of these nodes, return a fully specified <code>DAG</code> (with beta-coefficients, intercepts, errors, ...). The returned <code>DAG</code> can be used directly to simulate data with the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag_from_data(dag, data, return_models=FALSE, na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag_from_data_+3A_dag">dag</code></td>
<td>

<p>A partially specified <code>DAG</code> object created using the <code><a href="#topic+empty_dag">empty_dag</a></code> and <code><a href="#topic+node">node</a></code> functions. See <code>?node</code> for a more detailed description on how to do this. All nodes need to contain information about their <code>name</code>, <code>type</code> and <code>parents</code>. All other attributes will be added (or overwritten if already in there) when using this function. Currently does not support DAGs with time-dependent nodes added with the <code><a href="#topic+node_td">node_td</a></code> function.
</p>
</td></tr>
<tr><td><code id="dag_from_data_+3A_data">data</code></td>
<td>

<p>A <code>data.frame</code> or <code>data.table</code> used to obtain the parameters needed in the <code>DAG</code> object. It needs to contain a column for every node specified in the <code>dag</code> argument.
</p>
</td></tr>
<tr><td><code id="dag_from_data_+3A_return_models">return_models</code></td>
<td>

<p>Whether to return a list of all models that were fit to estimate the information for all child nodes (elements in <code>dag</code> where the <code>parents</code> argument is not <code>NULL</code>).
</p>
</td></tr>
<tr><td><code id="dag_from_data_+3A_na.rm">na.rm</code></td>
<td>

<p>Whether to remove missing values or not.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong><em>How it works</em></strong>:
</p>
<p>It can be cumbersome to specify all the node information needed for the simulation, especially when there are a lot of nodes to consider. Additionally, if data is available, it is natural to fit appropriate models to the data to get an empirical estimate of the node information for the simulation. This function automates this process. If the user has a reasonable DAG and knows the node types, this is a very fast way to generate synthetic data that corresponds well to the empirical data.
</p>
<p>All the user has to do is create a minimal <code>DAG</code> object including only information on the <code>parents</code>, the <code>name</code> and the node <code>type</code>. For root nodes, the required distribution parameters are extracted from the data. For child nodes, regression models corresponding to the specified <code>type</code> are fit to the data using the <code>parents</code> as independent covariates and the <code>name</code> as dependent variable. All required information is extracted from these models and added to the respective node. The output contains a fully specified <code>DAG</code> object which can then be used directly in the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function. It may also include a list containing the fitted models for further inspection, if <code>return_models=TRUE</code>.
</p>
<p><strong><em>Supported root node types</em></strong>:
</p>
<p>Currently, the following root node types are supported:
</p>

<ul>
<li><p><code>"rnorm"</code>: Estimates parameters of a normal distribution.
</p>
</li>
<li><p><code>"rbernoulli"</code>: Estimates the <code>p</code> parameter of a Bernoulli distribution.
</p>
</li>
<li><p><code>"rcategorical"</code>: Estimates the class probabilities in a categorical distribution.
</p>
</li></ul>

<p>Other types need to be implemented by the user.
</p>
<p><strong><em>Supported child node types</em></strong>:
</p>
<p>Currently, the following child node types are supported:
</p>

<ul>
<li><p><code>"gaussian"</code>: Estimates parameters for a node of type <code>"<a href="#topic+node_gaussian">gaussian</a>"</code>.
</p>
</li>
<li><p><code>"binomial"</code>: Estimates parameters for a node of type <code>"<a href="#topic+node_binomial">binomial</a>"</code>.
</p>
</li>
<li><p><code>"poisson"</code>: Estimates parameters for a node of type <code>"<a href="#topic+node_poisson">poisson</a>"</code>.
</p>
</li>
<li><p><code>"negative_binomial"</code>: Estimates parameters for a node of type <code>"<a href="#topic+node_negative_binomial">negative_binomial</a>"</code>.
</p>
</li>
<li><p><code>"conditional_prob"</code>: Estimates parameters for a node of type <code>"<a href="#topic+node_conditional_prob">conditional_prob</a>"</code>.
</p>
</li></ul>

<p>Other types need to be implemented by the user.
</p>
<p><strong><em>Support for custom nodes</em></strong>:
</p>
<p>The <code>sim_from_dag</code> function supports custom node functions, as described in <code><a href="#topic+node_custom">node_custom</a></code>. It is impossible for us to directly support these custom types in this function directly. However, the user can extend this function easily to accommodate any of his/her custom types. Similar to defining a custom node type, the user simply has to write a function that returns a correctly specified <code>node.DAG</code> object, given the named arguments <code>name</code>, <code>parents</code>, <code>type</code>, <code>data</code> and <code>return_model</code>. The first three arguments should simply be added directly to the output. The <code>data</code> should be used inside your function to fit a model or obtain the required parameters in some other way. The <code>return_model</code> argument should control whether the model should be added to the output (in a named argument called <code>model</code>). The function name should be <code>paste0("gen_node_", YOURTYPE)</code>. An examples is given below.
</p>
<p><strong><em>Interactions &amp; cubic terms</em></strong>:
</p>
<p>This function currently does not support the usage of interaction effects or non-linear terms (such as using <code>A ~ B + I(B^2)</code> as a formula). Instead, it will be assumed that all values in <code>parents</code> have a linear effect on the respective node. For example, using <code>parents=c("A", "B")</code> for a node named <code>"C"</code> will use the formula <code>C ~ A + B</code>. If other behavior is desired, users need to integrate this into their own custom function as described above.
</p>


<h3>Value</h3>

<p>A list of length two containing the new fully specified <code>DAG</code> object named <code>dag</code> and a list of the fitted models (if <code>return_models=TRUE</code>) in the object named <code>models</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(457456)

# get some example data from a known DAG
dag &lt;- empty_dag() +
  node("death", type="binomial", parents=c("age", "sex"), betas=c(1, 2),
       intercept=-10) +
  node("age", type="rnorm", mean=10, sd=2) +
  node("sex", parents="", type="rbernoulli", p=0.5) +
  node("smoking", parents=c("sex", "age"), type="binomial",
       betas=c(0.6, 0.2), intercept=-2)

data &lt;- sim_from_dag(dag=dag, n_sim=1000)

# suppose we only know the causal structure and the node type:
dag &lt;- empty_dag() +
  node("death", type="binomial", parents=c("age", "sex")) +
  node("age", type="rnorm") +
  node("sex", type="rbernoulli") +
  node("smoking", type="binomial", parents=c("sex", "age"))

# get parameter estimates from data
dag_full &lt;- dag_from_data(dag=dag, data=data)

# can now be used to simulate data
data2 &lt;- sim_from_dag(dag=dag_full$dag, n_sim=100)
</code></pre>

<hr>
<h2 id='dag2matrix'>
Obtain a Adjacency Matrix from a <code>DAG</code> object
</h2><span id='topic+dag2matrix'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function requires the user to specify the causal relationships inside a <code>DAG</code> object containing node information. This function takes this object as input and outputs the underlying adjacency matrix. This can be useful to plot the theoretical DAG or to check if the nodes have been specified correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag2matrix(dag, include_root_nodes=TRUE, include_td_nodes=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag2matrix_+3A_dag">dag</code></td>
<td>

<p>A <code>DAG</code> object created using the <code><a href="#topic+empty_dag">empty_dag</a></code> function with nodes added to it using the <code>+</code> syntax. See <code>?empty_dag</code> or <code>?node</code> for more details. Supports DAGs with time-dependent nodes added using the <code><a href="#topic+node_td">node_td</a></code> function. However, including such DAGs may result in cyclic causal structures, because time is not represented in the output matrix.
</p>
</td></tr>
<tr><td><code id="dag2matrix_+3A_include_root_nodes">include_root_nodes</code></td>
<td>

<p>Whether to include root nodes in the output matrix. Should usually be kept at <code>TRUE</code> (default).
</p>
</td></tr>
<tr><td><code id="dag2matrix_+3A_include_td_nodes">include_td_nodes</code></td>
<td>

<p>Whether to include time-dependent nodes added to the <code>dag</code> using the <code><a href="#topic+node_td">node_td</a></code> function or not. When including these types of nodes, it is possible for the adjacency matrix to contain cycles, e.g. that it is not a classic DAG anymore, due to the matrix not representing the passage of time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An adjacency matrix is simply a square matrix in which each node has one column and one row associated with it. For example, if the node A has a causal effect on node B, the matrix will contain <code>1</code> in the spot <code>matrix["A", "B"]</code>.
</p>
<p>If a time-varying node is also defined as a time-fixed node, the parents of both parts will be pooled when creating the output matrix.
</p>


<h3>Value</h3>

<p>Returns a numeric square matrix with one row and one column per used node in <code>dag</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

# some example DAG
dag &lt;- empty_dag() +
  node("death", type="binomial", parents=c("age", "sex"), betas=c(1, 2),
       intercept=-10) +
  node("age", type="rnorm", mean=10, sd=2) +
  node("sex", parents="", type="rbernoulli", p=0.5) +
  node("smoking", parents=c("sex", "age"), type="binomial",
       betas=c(0.6, 0.2), intercept=-2)

# get adjacency matrix
dag2matrix(dag)

# get adjacency matrix using only the child nodes
dag2matrix(dag, include_root_nodes=FALSE)

## adding time-varying nodes
dag &lt;- dag +
  node_td("disease", type="time_to_event", parents=c("age", "smoking"),
          prob_fun=0.01) +
  node_td("death", type="time_to_event", parents=c("age", "sex", "smoking",
                                                   "disease"),
          prob_fun=0.001, event_duration=Inf)

# get adjacency matrix including all nodes
dag2matrix(dag, include_td_nodes=TRUE)

# get adjacency matrix including only time-constant nodes
dag2matrix(dag, include_td_nodes=FALSE)

# get adjacency matrix using only the child nodes
dag2matrix(dag, include_root_nodes=FALSE)
</code></pre>

<hr>
<h2 id='do'>
Pearls do-operator for <code>DAG</code> objects
</h2><span id='topic+do'></span>

<h3>Description</h3>

<p>This function can be used to set one or more nodes in a given <code>DAG</code> object to a specific value, which corresponds to an intervention on a DAG as defined by the do-operator introduced by Judea Pearl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do(dag, names, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_+3A_dag">dag</code></td>
<td>

<p>A <code>DAG</code> object created using the <code><a href="#topic+empty_dag">empty_dag</a></code> and <code><a href="#topic+node">node</a></code> functions. See <code>?node</code> for more information on how to specify a DAG.
</p>
</td></tr>
<tr><td><code id="do_+3A_names">names</code></td>
<td>

<p>A character string specifying names of nodes in the <code>dag</code> object. The value of these nodes will be set to the corresponding value specified in the <code>values</code> argument. If the node is not already defined in <code>dag</code>, a new one will be added without warning.
</p>
</td></tr>
<tr><td><code id="do_+3A_values">values</code></td>
<td>

<p>A vector or list of any values. These nodes defined with the <code>names</code> argument will be set to those values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally this function simply removes the old node definition of all nodes in <code>names</code> and replaces it with a new node definition that defines the node as a constant value, irrespective of the original definition. The same effect can be created by directly specifying the <code>DAG</code> in this way from the start (see examples).
</p>
<p>This function does not alter the original <code>DAG</code> in place. Instead, it returns a modified version of the <code>DAG</code>. In other words, using only <code>do(dag, names="A", values=3)</code> will not change the <code>dag</code> object.
</p>


<h3>Value</h3>

<p>Returns a <code>DAG</code> object with updated node definitions.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>References</h3>

<p>Judea Pearl (2009). Causality: Models, Reasoning and Inference. 2nd ed. Cambridge: Cambridge University Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

# define some initial DAG
dag &lt;- empty_dag() +
  node("death", "binomial", c("age", "sex"), betas=c(1, 2), intercept=-10) +
  node("age", type="rnorm", mean=10, sd=2) +
  node("sex", parents="", type="rbernoulli", p=0.5) +
  node("smoking", parents=c("sex", "age"), type="binomial",
       betas=c(0.6, 0.2), intercept=-2)

# return new DAG with do(smoking = TRUE)
dag2 &lt;- do(dag, names="smoking", values=TRUE)

# which is equivalent to
dag2 &lt;- empty_dag() +
  node("death", "binomial", c("age", "sex"), betas=c(1, 2), intercept=-10) +
  node("age", type="rnorm", mean=10, sd=2) +
  node("sex", parents="", type="rbernoulli", p=0.5) +
  node("smoking", type="rconstant", constant=TRUE)

# use do() on multiple variables: do(smoking = TRUE, sex = FALSE)
dag2 &lt;- do(dag, names=c("smoking", "sex"), values=list(TRUE, FALSE))
</code></pre>

<hr>
<h2 id='empty_dag'>
Initialize an empty <code>DAG</code> object
</h2><span id='topic+empty_dag'></span>

<h3>Description</h3>

<p>This function should be used in conjunction with multiple calls to <code><a href="#topic+node">node</a></code> or <code><a href="#topic+node_td">node_td</a></code> to create a <code>DAG</code> object, which can then be used to simulate data using the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> and <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_dag()
</code></pre>


<h3>Details</h3>

<p>Note that this function is only used to initialize an empty <code>DAG</code> object. Actual information about the respective nodes have to be added using the <code><a href="#topic+node">node</a></code> function or the <code><a href="#topic+node_td">node_td</a></code> function. The documentation page of that function contains more information on how to correctly do this.
</p>


<h3>Value</h3>

<p>Returns an empty <code>DAG</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

# just an empty DAG
empty_dag()

# adding a node to it
empty_dag() + node("age", type="rnorm", mean=20, sd=5)
</code></pre>

<hr>
<h2 id='long2start_stop'>
Transform a <code>data.table</code> in the long-format to a <code>data.table</code> in the start-stop format
</h2><span id='topic+long2start_stop'></span>

<h3>Description</h3>

<p>This function transforms a <code>data.table</code> in the long-format (one row per person per time point) to a <code>data.table</code> in the start-stop format (one row per person-specific period in which no variables changed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long2start_stop(data, id, time, varying, overlap=FALSE,
                check_inputs=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="long2start_stop_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> or an object that can be coerced to a <code>data.table</code> (such as a <code>data.frame</code>) including data in the long-format.
</p>
</td></tr>
<tr><td><code id="long2start_stop_+3A_id">id</code></td>
<td>

<p>A single character string specifying a unique person identifier included in in <code>data</code>.
</p>
</td></tr>
<tr><td><code id="long2start_stop_+3A_time">time</code></td>
<td>

<p>A single character string specifying a time variable included in in <code>data</code> coded as integers starting from 1.
</p>
</td></tr>
<tr><td><code id="long2start_stop_+3A_varying">varying</code></td>
<td>

<p>A character vector specifying names of variables included in in <code>data</code> that may change over time.
</p>
</td></tr>
<tr><td><code id="long2start_stop_+3A_overlap">overlap</code></td>
<td>

<p>Specifies whether the intervals should overlap or not. If <code>TRUE</code>, the <code>"stop"</code> column is simply increased by one, as compared to the output when <code>overlap=FALSE</code>. This means that changes for a given <code class="reqn">t</code> are recorded at the start of the next interval, but the previous interval ends on that same day.
</p>
</td></tr>
<tr><td><code id="long2start_stop_+3A_check_inputs">check_inputs</code></td>
<td>

<p>Whether to check if the user input is correct or not. Can be turned off by setting it to <code>FALSE</code> to save computation time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies on <code>data.table</code> syntax to make the data transformation as RAM efficient and fast as possible.
</p>


<h3>Value</h3>

<p>Returns a <code>data.table</code> containing the columns <code>.id</code> (the unique person identifier), <code>.time</code> (an integer variable encoding the time) and all other variables included in the input <code>data</code> in the long format.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)
library(data.table)

# generate example data in long format
long &lt;- data.table(.id=rep(seq_len(10), each=5),
                   .time=rep(seq_len(5), 10),
                   A=c(rep(FALSE, 43), TRUE, TRUE, rep(FALSE, 3), TRUE,
                           TRUE),
                   B=FALSE)
setkey(long, .id, .time)

# transform to start-stop format
long2start_stop(data=long, id=".id", time=".time", varying=c("A", "B"))
</code></pre>

<hr>
<h2 id='matrix2dag'>
Obtain a <code>DAG</code> object from a Adjacency Matrix and a List of Node Types
</h2><span id='topic+matrix2dag'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function requires the user to specify the causal relationships inside a <code>DAG</code> object containing node information. This function creates such an object using a adjacency matrix and a list of node types. The resulting <code>DAG</code> will be only partially specified, which may be useful for the <code><a href="#topic+dag_from_data">dag_from_data</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2dag(mat, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix2dag_+3A_mat">mat</code></td>
<td>

<p>A p x p adjacency matrix where p is the number of variables. The matrix should be filled with zeros. Only places where the variable specified by the row has a direct causal effect on the variable specified by the column should be 1. Both the columns and the rows should be named with the corresponding variable names.
</p>
</td></tr>
<tr><td><code id="matrix2dag_+3A_type">type</code></td>
<td>

<p>A named list with one entry for each variable in <code>mat</code>, specifying the <code>type</code> of the corresponding node. See <code><a href="#topic+node">node</a></code> for available node types.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An adjacency matrix is simply a square matrix in which each node has one column and one row associated with it. For example, if the node A has a causal effect on node B, the matrix will contain <code>1</code> in the spot <code>matrix["A", "B"]</code>. This function uses this kind of matrix and additional information about the node type to create a <code>DAG</code> object. The resulting <code>DAG</code> cannot be used in the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function directly, because it will not contain the necessary parameters such as beta-coefficients or intercepts etc. It may, however, be passed directly to the <code><a href="#topic+dag_from_data">dag_from_data</a></code> function. This is pretty much it's only valid use-case. If the goal is to to specify a full <code>DAG</code> manually, the user should use the <code><a href="#topic+empty_dag">empty_dag</a></code> function in conjunction with <code><a href="#topic+node">node</a></code> calls instead, as described in the respective documentation pages and the vignettes.
</p>
<p>The output will never contain time-dependent nodes. If this is necessary, the user needs to manually define the DAG.
</p>


<h3>Value</h3>

<p>Returns a partially specified <code>DAG</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+dag_from_data">dag_from_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

# simple example adjacency matrix
mat &lt;- matrix(c(0, 0, 1, 0, 0, 1, 0, 0, 0), ncol=3, byrow=TRUE)
colnames(mat) &lt;- c("age", "sex", "death")
rownames(mat) &lt;- c("age", "sex", "death")

type &lt;- list(age="rnorm", sex="rbernoulli", death="binomial")

matrix2dag(mat=mat, type=type)
</code></pre>

<hr>
<h2 id='node'>
Create a node object to grow a DAG step-by-step
</h2><span id='topic+node'></span><span id='topic+node_td'></span>

<h3>Description</h3>

<p>These functions should be used in conjunction with the <code><a href="#topic+empty_dag">empty_dag</a></code> function to create <code>DAG</code> objects, which can then be used to simulate data using the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function or the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node(name, type, parents=NULL, formula=NULL, ...)

node_td(name, type, parents=NULL, formula=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_+3A_name">name</code></td>
<td>

<p>A character vector with at least one entry specifying the name of the node. If a character vector containing multiple different names is supplied, one separate node will be created for each name. These nodes are completely independent, but have the exact same node definition as supplied by the user. If only a single character string is provided, only one node is generated.
</p>
</td></tr>
<tr><td><code id="node_+3A_type">type</code></td>
<td>

<p>A single character string specifying the type of the node. Depending on whether the node is a root node, a child node or a time-dependent node different node types are allowed. See details.
</p>
</td></tr>
<tr><td><code id="node_+3A_parents">parents</code></td>
<td>

<p>A character vector of names, specifying the parents of the node or <code>NULL</code> (default). If <code>NULL</code>, the node is treated as a root node. For convenience it is also allowed to set <code>parents=""</code> to indicate that the node is a root node.
</p>
</td></tr>
<tr><td><code id="node_+3A_formula">formula</code></td>
<td>

<p>An optional <code>formula</code> object to describe how the node should be generated or <code>NULL</code> (default). If supplied it should start with <code>~</code>, having nothing else on the left hand side. The right hand side may contain any valid formula syntax, such as <code>A + B</code> or <code>A + B + I(A^2)</code>, allowing non-linear effects. If this argument is defined, there is no need to define the <code>parents</code> argument. For example, using <code>parents=c("A", "B")</code> is equal to using <code>formula= ~ A + B</code>. This is currently only supported for nodes of type <code>"binomial"</code>, <code>"gaussian"</code>, <code>"poisson"</code>, <code>"negative_binomial"</code> and <code>"cox"</code>.
</p>
</td></tr>
<tr><td><code id="node_+3A_...">...</code></td>
<td>

<p>Further named arguments needed to specify the node. Those can be parameters of distribution functions such as the <code>p</code> argument in the <code><a href="#topic+rbernoulli">rbernoulli</a></code> function for root nodes or arbitrary named arguments such as the <code>betas</code> argument of the <code><a href="#topic+node_gaussian">node_gaussian</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate data using the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function or the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function, it is required to create a <code>DAG</code> object first. This object needs to contain information about the causal structure of the data (e.g. which variable causes which variable) and the specific structural equations for each variable (information about causal coefficients, type of distribution etc.). In this package, the <code>node</code> and/or <code>node_td</code> function is used in conjunction with the <code><a href="#topic+empty_dag">empty_dag</a></code> function to create this object.
</p>
<p>This works by first initializing an empty <code>DAG</code> using the <code><a href="#topic+empty_dag">empty_dag</a></code> function and then adding multiple calls to the <code>node</code> and/or <code>node_td</code> functions to it using a simple <code>+</code>, where each call to <code>node</code> and/or <code>node_td</code> adds information about a single node that should be generated. Multiple examples are given below.
</p>
<p>In each call to <code>node</code> or <code>node_td</code> the user needs to indicate what the node should be called (<code>name</code>), which function should be used to generate the node (<code>type</code>), whether the node has any parents and if so which (<code>parents</code>) and any additional arguments needed to actually call the data-generating function of this node later passed to the three-dot syntax (<code>...</code>).
</p>
<p><strong><em><code>node</code> vs. <code>node_td</code></em></strong>:
</p>
<p>By calling <code>node</code> you are indicating that this node is a time-fixed variable which should only be generated once. By using <code>node_td</code> you are indicating that it is a time-dependent node, which will be updated at each step in time when using a discrete-time simulation.
</p>
<p><code>node_td</code> should only be used if you are planning to perform a discrete-time simulation with the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function. <code>DAG</code> objects including time-dependent nodes may not be used in the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function.
</p>
<p><strong><em>Implemented Root Node Types</em></strong>:
</p>
<p>Any function can be used to generate root nodes. The only requirement is that the function has at least one named argument called <code>n</code> which controls the length of the resulting vector. For example, the user could specify a node of type <code>"rnorm"</code> to create a normally distributed node with no parents. The argument <code>n</code> will be set internally, but any additional arguments can be specified using the <code>...</code> syntax. In the <code>type="rnorm"</code> example, the user could set the mean and standard deviation using <code>node(name="example", type="rnorm", mean=10, sd=5)</code>.
</p>
<p>For convenience, this package additionally includes three custom root-node functions:
</p>

<ul>
<li><p>&quot;<a href="#topic+rbernoulli">rbernoulli</a>&quot;: Draws randomly from a bernoulli distribution.
</p>
</li>
<li><p>&quot;<a href="#topic+rcategorical">rcategorical</a>&quot;: Draws randomly from any discrete probability density function.
</p>
</li>
<li><p>&quot;<a href="#topic+rconstant">rconstant</a>&quot;: Used to set a variable to a constant value.
</p>
</li></ul>

<p><strong><em>Implemented Child Node Types</em></strong>:
</p>
<p>Currently, the following node types are implemented directly for convenience:
</p>

<ul>
<li><p>&quot;<a href="#topic+node_gaussian">gaussian</a>&quot;: A node based on linear regression.
</p>
</li>
<li><p>&quot;<a href="#topic+node_binomial">binomial</a>&quot;: A node based on logistic regression.
</p>
</li>
<li><p>&quot;<a href="#topic+node_conditional_prob">conditional_prob</a>&quot;: A node based on conditional probabilities.
</p>
</li>
<li><p>&quot;<a href="#topic+node_conditional_distr">conditional_distr</a>&quot;: A node based on conditional draws from different distributions.
</p>
</li>
<li><p>&quot;<a href="#topic+node_multinomial">multinomial</a>&quot;: A node based on multinomial regression.
</p>
</li>
<li><p>&quot;<a href="#topic+node_poisson">poisson</a>&quot;: A node based on poisson regression.
</p>
</li>
<li><p>&quot;<a href="#topic+node_negative_binomial">negative_binomial</a>&quot;: A node based on negative binomial regression.
</p>
</li>
<li><p>&quot;<a href="#topic+node_cox">cox</a>&quot;: A node based on cox-regression.
</p>
</li></ul>

<p>For custom child node types, see below.
</p>
<p><strong><em>Implemented Time-Dependent Node Types</em></strong>:
</p>
<p>Currently, the following node types are implemented directly for convenience to use in <code>node_td</code> calls:
</p>

<ul>
<li><p>&quot;<a href="#topic+node_time_to_event">time_to_event</a>&quot;: A node based on repeatedly checking whether an event occurs at each point in time.
</p>
</li>
<li><p>&quot;<a href="#topic+node_competing_events">competing_events</a>&quot;: A node based on repeatedly checking whether one of multiple mutually exclusive events occurs at each point in time.
</p>
</li></ul>

<p>However, the user may also use any of the child node types in a <code>node_td</code> call directly. For custom time-dependent node types, see below.
</p>
<p><strong><em>Custom Node Types</em></strong>
</p>
<p>It is very simple to write a new custom <code>node_function</code> to be used instead, allowing the user to use any <code>type</code> of data-generation mechanism for any type of node (root / child / time-dependent). All that is required of this function is, that it has the named arguments <code>data</code> (the sample as generated so far) and, if it's a child node, <code>parents</code> (a character vector specifying the parents) and outputs either a vector containing <code>n_sim</code> entries, or a <code>data.frame</code> with <code>n_sim</code> rows and an arbitrary amount of columns. More information about this can be found on the <code>node_custom</code> documentation page.
</p>
<p><strong><em>Using child nodes as parents for other nodes</em></strong>:
</p>
<p>Most child nodes can be easily used as parents for other nodes. This allows the resulting DAG to be rather complex. However, if the data generated by the child node is categorical (such as when using <code>node_multinomial</code>) or when it has complex data structures in general (such as when using <code>node_cox</code>), it may be difficult to use the output as parents. Using a custom node type, the user may use any node as parents as he or she see fit. Using the nodes of type <code>"cox"</code>, <code>"multinomial"</code> or (depending on the utilized parameters) <code>"conditional_prob"</code> as parents may result in errors when using standard child node types such as <code>"binomial"</code> or <code>"gaussian"</code>.
</p>
<p><strong><em>Cyclic causal structures</em></strong>:
</p>
<p>The name DAG (directed <strong>acyclic</strong> graph) implies that cycles are not allowed. This means that if you start from any node and only follow the arrows in the direction they are pointing, there should be no way to get back to your original node. This is necessary both theoretically and for practical reasons if we are dealing with static DAGs created using the <code>node</code> function. If the user attempts to generate data from a static cyclic graph using the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function, an error will be produced.
</p>
<p>However, in the realm of discrete-time simulations, cyclic causal structures are perfectly reasonable. A variable <code class="reqn">A</code> at <code class="reqn">t = 1</code> may influence a variable <code class="reqn">B</code> at <code class="reqn">t = 2</code>, which in turn may influence variable <code class="reqn">A</code> at <code class="reqn">t = 3</code> again. Therefore, when using the <code>node_td</code> function to simulate time-dependent data using the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function, cyclic structures are allowed to be present and no error will be produced.
</p>


<h3>Value</h3>

<p>Returns a <code>DAG.node</code> object which can be added to a <code>DAG</code> object directly.
</p>


<h3>Note</h3>

<p>Contrary to the R standard, this function does <b>NOT</b> support partial matching of argument names. This means that supplying <code>nam="age"</code> will not be recognized as <code>name="age"</code> and instead will be added as additional node argument used in the respective data-generating function call when using <code>sim_from_dag</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

# creating a DAG with a single root node
dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=30, sd=4)

# creating a DAG with multiple root nodes
dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node("income", type="rnorm", mean=2700, sd=500)

# creating a DAG with multiple root nodes + multiple names in one node
dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node(c("income_1", "income_2"), type="rnorm", mean=2700, sd=500)

# also using child nodes
dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node("income", type="rnorm", mean=2700, sd=500) +
  node("sickness", type="binomial", parents=c("sex", "income"),
       betas=c(1.2, -0.3), intercept=-15) +
  node("death", type="binomial", parents=c("sex", "income", "sickness"),
       betas=c(0.1, -0.4, 0.8), intercept=-20)

# using time-dependent nodes
# NOTE: to simulate data from this DAG, the sim_discrete_time() function needs
#       to be used due to "sickness" being a time-dependent node
dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node("income", type="rnorm", mean=2700, sd=500) +
  node_td("sickness", type="binomial", parents=c("sex", "income"),
          betas=c(0.1, -0.4), intercept=-50)

# we could also use a DAG with only time-varying variables
dag &lt;- empty_dag() +
  node_td("vaccine", type="time_to_event", prob_fun=0.001, event_duration=21) +
  node_td("covid", type="time_to_event", prob_fun=0.01, event_duration=15,
          immunity_duration=100)
</code></pre>

<hr>
<h2 id='node_binomial'>
Simulate a Node Using Logistic Regression
</h2><span id='topic+node_binomial'></span>

<h3>Description</h3>

<p>Data from the parents is used to generate the node using logistic regression by predicting the covariate specific probability of 1 and sampling from a Bernoulli distribution accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_binomial(data, parents, formula=NULL, betas, intercept,
              return_prob=FALSE, coerce2factor=FALSE,
              coerce2numeric=FALSE, labels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_binomial_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> (or something that can be coerced to a <code>data.table</code>) containing all columns specified by <code>parents</code>.
</p>
</td></tr>
<tr><td><code id="node_binomial_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has. If non-linear combinations or interaction effects should be included, the user may specify the <code>formula</code> argument instead.
</p>
</td></tr>
<tr><td><code id="node_binomial_+3A_formula">formula</code></td>
<td>

<p>An optional <code>formula</code> object to describe how the node should be generated or <code>NULL</code> (default). If supplied it should start with <code>~</code>, having nothing else on the left hand side. The right hand side may contain any valid formula syntax, such as <code>A + B</code> or <code>A + B + I(A^2)</code>, allowing non-linear effects. If this argument is defined, there is no need to define the <code>parents</code> argument. For example, using <code>parents=c("A", "B")</code> is equal to using <code>formula= ~ A + B</code>.
</p>
</td></tr>
<tr><td><code id="node_binomial_+3A_betas">betas</code></td>
<td>

<p>A numeric vector with length equal to <code>parents</code>, specifying the causal beta coefficients used to generate the node.
</p>
</td></tr>
<tr><td><code id="node_binomial_+3A_intercept">intercept</code></td>
<td>

<p>A single number specifying the intercept that should be used when generating the node.
</p>
</td></tr>
<tr><td><code id="node_binomial_+3A_return_prob">return_prob</code></td>
<td>

<p>Either <code>TRUE</code> or <code>FALSE</code> (default). If <code>TRUE</code>, the calculated probability is returned instead of the results of bernoulli trials.
</p>
</td></tr>
<tr><td><code id="node_binomial_+3A_coerce2factor">coerce2factor</code></td>
<td>

<p>Either <code>TRUE</code> or <code>FALSE</code> (default). If <code>TRUE</code>, the resulting vector is coerced to a factor variable. Levels of this factor can be set using the <code>labels</code> argument.
</p>
</td></tr>
<tr><td><code id="node_binomial_+3A_coerce2numeric">coerce2numeric</code></td>
<td>

<p>Either <code>TRUE</code> or <code>FALSE</code> (default). If <code>TRUE</code>, the resulting vector is coerced to a numeric variable (0/1).
</p>
</td></tr>
<tr><td><code id="node_binomial_+3A_labels">labels</code></td>
<td>

<p>A character vector of length 2 or <code>NULL</code> (default). If <code>NULL</code>, the resulting vector is returned as is. If a character vector is supplied all <code>TRUE</code> values are replaced by the first entry of this vector and all <code>FALSE</code> values are replaced by the second argument of this vector. The output will then be a character variable, unless <code>coerce2factor</code> is set to <code>TRUE</code> in which case it will be a factor variable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the normal form a logistic regression model, the observation specific event probability is generated for every observation in the dataset. Using the <code>rbernoulli</code> function, this probability is then used to take one bernoulli sample for each observation in the dataset. If only the probability should be returned <code>return_prob</code> should be set to <code>TRUE</code>.
</p>
<p><strong><em>Formal Description</em></strong>:
</p>
<p>Formally, the data generation can be described as:
</p>
<p style="text-align: center;"><code class="reqn">Y \sim Bernoulli(logit(\texttt{intercept} + \texttt{parents}_1 \cdot \texttt{betas}_1 + ... + \texttt{parents}_n \cdot \texttt{betas}_n)),</code>
</p>

<p>where <code class="reqn">Bernoulli(p)</code> denotes one Bernoulli trial with success probability <code class="reqn">p</code>, <code class="reqn">n</code> is the number of parents (<code>length(parents)</code>) and the <code class="reqn">logit(x)</code> function is defined as:
</p>
<p style="text-align: center;"><code class="reqn">logit(x) = ln(\frac{x}{1-x}).</code>
</p>

<p>For example, given <code>intercept=-15</code>, <code>parents=c("A", "B")</code> and <code>betas=c(0.2, 1.3)</code> the data generation process is defined as:
</p>
<p style="text-align: center;"><code class="reqn">Y \sim Bernoulli(logit(-15 + A \cdot 0.2 + B \cdot 1.3)).</code>
</p>

<p><strong><em>Output Format</em></strong>:
</p>
<p>By default this function returns a logical vector containing only <code>TRUE</code> and <code>FALSE</code> entries, where <code>TRUE</code> corresponds to an event and <code>FALSE</code> to no event. If those should be coded as 0/1 instead, the user can use the <code>coerce2numeric</code> argument. If they should be coded as a character with specific labels, the user can use the <code>labels</code> argument. To additionally output it as a factor, the user may use the <code>coerce2factor</code> argument. If both <code>coerce2factor</code> and <code>coerce2numeric</code> are set to <code>TRUE</code>, the result will be a factor. The last three arguments of this function are ignored if <code>return_prob</code> is set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>Returns a logical vector (or numeric vector if <code>return_prob=TRUE</code>) of length <code>nrow(data)</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_from_dag">sim_from_dag</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(5425)

# define needed DAG
dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("smoking", type="binomial", parents=c("age", "sex"),
       betas=c(1.1, 0.4), intercept=-2)

# simulate data from it
sim_dat &lt;- sim_from_dag(dag=dag, n_sim=100)

# returning only the estimated probability instead
dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("smoking", type="binomial", parents=c("age", "sex"),
       betas=c(1.1, 0.4), intercept=-2, return_prob=TRUE)

sim_dat &lt;- sim_from_dag(dag=dag, n_sim=100)
</code></pre>

<hr>
<h2 id='node_competing_events'>
Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation
</h2><span id='topic+node_competing_events'></span>

<h3>Description</h3>

<p>This node essentially models a categorical time-dependent variable for which the time and the type of the event will be important for later usage. It adds two columns to <code>data</code>: <code>name_event</code> (which type of event the person is currently experiencing) and <code>name_time</code> (the time at which the current event started). Can only be used inside of the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function, not outside of it. Past events and their kind are stored in two lists. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_competing_events(data, parents, sim_time, name,
                      prob_fun, ..., event_duration=c(1, 1),
                      immunity_duration=max(event_duration),
                      save_past_events=TRUE, check_inputs=TRUE,
                      envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_competing_events_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> containing all columns specified by <code>parents</code>. Similar objects such as <code>data.frame</code>s are not supported.
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has.
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_sim_time">sim_time</code></td>
<td>

<p>The current time of the simulation.
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_name">name</code></td>
<td>

<p>The name of the node. This will be used as prefix before the <code>_event</code>, <code>_time</code>, <code>_past_event_times</code> and <code>_past_event_kind</code> columns.
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_prob_fun">prob_fun</code></td>
<td>

<p>A function that returns a numeric matrix with <code>nrow(data)</code> rows and one column storing probabilities of occurrence for each possible event type plus a column for no events. For example, if there are two possible events such as recurrence and death, the matrix would need to contain three columns. The first storing the probability of no-event and the other two columns storing probabilities for recurrence and death per person. Since the numbers are probabilities, the matrix should only contain numbers between 0 and 1 that sum to 1 in each row. These numbers specify the person-specific probability of experiencing the events modeled by this node at the particular point in time of the simulation. The corresponding event will be generated internally using the <code><a href="#topic+rcategorical">rcategorical</a></code> function.
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_...">...</code></td>
<td>

<p>An arbitrary number of additional named arguments passed to <code>prob_fun</code>. Ignore this if you do not want to pass any arguments.
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_event_duration">event_duration</code></td>
<td>

<p>A numeric vector containing one positive integer for each type of event of interest, specifying how long that event should last. For example, if we are interested in modelling the time to a cardiovascular event with death as competing event, this argument would need 2 entries. One would specify the duration of the cardiovascular event and the other would be <code>Inf</code> (because death is a terminal event).
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_immunity_duration">immunity_duration</code></td>
<td>

<p>A single number &gt;= <code>max(event_duration)</code> specifying how long the person should be immune to all events after experiencing one. The count internally starts when the event starts, so in order to use an immunity duration of 10 time units after the event is over <code>max(event_duration) + 10</code> should be used.
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_save_past_events">save_past_events</code></td>
<td>

<p>When the event modeled using this node is recurrent (<code>immunity_duration &lt; Inf &amp; any(event_duration &lt; Inf)</code>), the same person may experience multiple events over the course of the simulation. Those are generally stored in the <code>ce_past_events</code> list and <code>ce_past_causes</code> list which are included in the output of the <code>sim_discrete_time</code> function. This extends the runtime and increases RAM usage, so if you are not interested in the timing of previous events or if you are using <code>save_states="all"</code> this functionality can be turned off by setting this argument to <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_check_inputs">check_inputs</code></td>
<td>

<p>Whether to perform plausibility checks for the user input or not. Is set to <code>TRUE</code> by default, but can be set to <code>FALSE</code> in order to speed things up when using this function in a simulation study or something similar.
</p>
</td></tr>
<tr><td><code id="node_competing_events_+3A_envir">envir</code></td>
<td>

<p>Only used internally to efficiently store the past event times. Cannot be used by the user.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When performing discrete-time simulation using the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function, the standard node functions implemented in this package are usually not sufficient because they don't capture the time-dependent nature of some very interesting variables. Often, the variable that should be modelled has some probability of occurring at each point in time. Once it does occur, it has some kind of influence on other variables for a period of time until it goes back to normal (or doesn't). This could be a car crash, a surgery, a vaccination etc. The <code><a href="#topic+node_time_to_event">node_time_to_event</a></code> node function can be used to model these kinds of nodes in a fairly straightforward fashion.
</p>
<p>This function is an extended version of the <code><a href="#topic+node_time_to_event">node_time_to_event</a></code> function. Instead of simulating a binary event, it can generate multiple competing events, where the occurrence of one event at time <code class="reqn">t</code> is mutually exclusive with the occurrence of an other event at that time. In other words, multiple events are possible, but only one can occur at a time.
</p>
<p><strong><em>How it Works</em></strong>:
</p>
<p>At <code class="reqn">t = 1</code>, this node will be initialized for the first time. It adds two columns to the data: <code>name_event</code> (whether the person currently has an event) and <code>name_time</code> (the time at which the current event started) where <code>name</code> is the name of the node. Additionally, it adds a list with <code>max_t</code> entries to the <code>ce_past_events</code> list returned by the <code>sim_discrete_time</code> function, which records which individuals experienced a new event at each point in time. The <code>ce_past_causes</code> list additionally records which kind of event happened at that time.
</p>
<p>In a nutshell, it simply models the occurrence of some event by calculating the probability of occurrence at <code class="reqn">t</code> and drawing a single multinomial trial from this probability. If the trial is a &quot;success&quot;, the corresponding event column will be set to the drawn event type (described using integers, where 0 is no event and all other events are numbered consecutively), the time column will be set to the current simulation time <code class="reqn">t</code> and the columns storing the past event times and types will receive an entry.
</p>
<p>The event column will stay at its new integer value until the event is over. The duration for that is controlled by the <code>event_duration</code> parameter. When modeling terminal events such as death, one can simply set this parameter to <code>Inf</code>, making the event eternal. In many cases it will also be necessary to implement some kind of immunity after the event, which can be done using the <code>immunity_duration</code> argument. This effectively sets the probability of another occurrence of the event to 0 in the next <code>immunity_duration</code> time steps. During the immunity duration, the event may be <code>&gt; 0</code> (if the event is still ongoing) or <code>0</code> (if the <code>event_duration</code> for that event type has already passed).
</p>
<p>The probability of occurrence is calculated using the function provided by the user using the <code>prob_fun</code> argument. This can be an arbitrary complex function. The only requirement is that it takes <code>data</code> as a first argument. The columns defined by the <code>parents</code> argument will be passed to this argument automatically. If it has an argument called <code>sim_time</code>, the current time of the simulation will automatically be passed to it as well. Any further arguments can be passed using the <code>prob_fun_args</code> argument. A simple example could be a multinomial logistic regression node, in which the probabilities are calculated as an additive linear combination of the columns defined by <code>parents</code>. A more complex function could include simulation-time dependent effects, further effects dependent on past event times etc. Examples can be found below and in the vignettes.
</p>
<p><strong><em>What can be done with it</em></strong>:
</p>
<p>This type of node naturally support the implementation of competing events, where some may be terminal or recurrent in nature and may be influenced by pretty much anything. By specifying the <code>parents</code> and <code>prob_fun</code> arguments correctly, it is possible to create an event type that is dependent on past events of itself or other time-to-event variables and other variables in general. The user can include any amount of these nodes in their simulation. It may also be used to simulate any kind of binary time-dependent variable that one would usually not associate with the name &quot;event&quot; as well. It is very flexible, but it does require the user to do some coding by themselves.
</p>
<p><strong><em>What can't be done with it</em></strong>:
</p>
<p>This function may only be used to generate competing events, meaning that the occurrence of event 1 at <code class="reqn">t = 1</code> makes it impossible for event 2 at <code class="reqn">t = 1</code> to occur. If the user wants to generate multiple events that are not mutually exclusive, he or she may add multiple <code><a href="#topic+node_time_to_event">node_time_to_event</a></code> based nodes to the <code>dag</code> argument of the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function.
</p>
<p>In fact, a competing events node may be simulated using multiple calls to the <code><a href="#topic+node_time_to_event">node_time_to_event</a></code> based nodes as well, by defining the <code>prob_fun</code> argument of these nodes in such a way that the occurrence of event A makes the occurrence of event B impossible. This might actually be easier to implement in some situations, because it doesn't require the user to manually define a probability function that outputs a matrix of subject-specific probabilities.
</p>


<h3>Value</h3>

<p>Returns a <code>data.table</code> containing the updated columns of the node.
</p>


<h3>Note</h3>

<p>This function cannot be called outside of the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function. It only makes sense to use it as a type in a <code><a href="#topic+node_td">node_td</a></code> function call, as described in the documentation and vignettes.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_from_dag">sim_from_dag</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

## a competing_events node with only terminal events, all with a constant
## probability of occurrence, independent of any other variable
prob_death_illness &lt;- function(data) {

  # simply repeat the same probabilities for everyone
  n &lt;- nrow(data)
  p_mat &lt;- matrix(c(rep(0.9, n), rep(0.005, n), rep(0.005, n)),
                  byrow = FALSE, ncol=3)

  return(p_mat)
}

dag &lt;- empty_dag() +
  node_td("death_illness", type="competing_events", prob_fun=prob_death_illness,
          event_duration=c(Inf, Inf))

## making one of the event-types terminal and the other recurrent
dag &lt;- empty_dag() +
  node_td("death_illness", type="competing_events", prob_fun=prob_death_illness,
          event_duration=c(15, Inf))

## call the sim_discrete_time function to generate data from it
sim &lt;- sim_discrete_time(dag, n_sim=100, max_t=500)

## more examples on how to use the sim_discrete_time function can be found
## in the documentation page of the node_time_to_event function and
## in the package vignettes
</code></pre>

<hr>
<h2 id='node_conditional_distr'>
Simulate a Node by Sampling from Different Distributions based on Strata
</h2><span id='topic+node_conditional_distr'></span>

<h3>Description</h3>

<p>This function can be used to generate any kind of dichotomous, categorical or numeric variables dependent on one or more categorical variables by randomly sampling from user-defined distributions in each strata defined by the nodes parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_conditional_distr(data, parents, distr, default_distr=NULL,
                       default_distr_args=list(), default_val=NA_real_,
                       coerce2numeric=TRUE, check_inputs=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_conditional_distr_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> (or something that can be coerced to a <code>data.table</code>) containing all columns specified by <code>parents</code>.
</p>
</td></tr>
<tr><td><code id="node_conditional_distr_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has.
</p>
</td></tr>
<tr><td><code id="node_conditional_distr_+3A_distr">distr</code></td>
<td>

<p>A named list where each element corresponds to one stratum defined by parents. If only one name is given in <code>parents</code>, this means that there should be one element for possible values of the variable given in <code>parents</code>. If the node has multiple <code>parents</code>, there needs to be one element for possible combinations of <code>parents</code> (see examples). The values of those elements should be a <code>list</code> themselves, with the first argument being a callable function (such as <code>rnorm</code>, <code>rcategorical</code>, ...) and the rest should be named arguments of that function. Any function can be used, as long as it returns a vector of <code>n</code> values, with <code>n</code> being an argument of the function. <code>n</code> is set internally based on the stratum size and cannot be set by the user. If this list does not contain one element for each possible strata defined by <code>parents</code>, the <code>default_val</code> or <code>default_distr</code> arguments will be used.
</p>
</td></tr>
<tr><td><code id="node_conditional_distr_+3A_default_distr">default_distr</code></td>
<td>

<p>A function that should be used to generate values for all strata that are not explicitly mentioned in the <code>distr</code> argument, or <code>NULL</code> (default). If <code>NULL</code>, the <code>default_val</code> argument will be used to fill the missing strata with values. A  function passed to this argument should contain the argument <code>n</code>, which should define the number of samples to generate. It should return a vector with <code>n</code> values. Some examples are (again), <code><a href="stats.html#topic+rnorm">rnorm</a></code> or <code><a href="#topic+rbernoulli">rbernoulli</a></code>.
</p>
</td></tr>
<tr><td><code id="node_conditional_distr_+3A_default_distr_args">default_distr_args</code></td>
<td>

<p>A named list of arguments which are passed to the function defined by the <code>default_distr</code> argument. Ignored if <code>default_distr</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="node_conditional_distr_+3A_default_val">default_val</code></td>
<td>

<p>A single value which is used as an output for strata that are not mentioned in <code>distr</code>. Ignored if <code>default_distr</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="node_conditional_distr_+3A_coerce2numeric">coerce2numeric</code></td>
<td>

<p>A single logical value specifying whether to try to coerce the resulting variable to numeric or not.
</p>
</td></tr>
<tr><td><code id="node_conditional_distr_+3A_check_inputs">check_inputs</code></td>
<td>

<p>A single logical value specifying whether to perform input checks or not. May be set to <code>TRUE</code> to speed up things a little if you are sure your input is correct.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utilizing the user-defined distribution in each stratum of <code>parents</code> (supplied using the <code>distr</code> argument), this function simply calls the user-defined function with the arguments given by the user to generate a new variable. This allows the new variable to consist of a mix of different distributions, based on categorical <code>parents</code>.
</p>
<p><strong><em>Formal Description</em></strong>:
</p>
<p>Formally, the data generation process can be described as a series of conditional equations. For example, suppose that there is just one parent node <code>sex</code> with the levels <code>male</code> and <code>female</code> with the goal of creating a continuous outcome that has a normal distribution of <code class="reqn">N(10, 3)</code> for males and <code class="reqn">N(7, 2)</code> for females. The conditional equation is then:
</p>
<p style="text-align: center;"><code class="reqn">Y \sim \begin{cases}
			N(10, 3), &amp; \text{if } \texttt{sex="male"} \\
			N(7, 2), &amp; \text{if } \texttt{sex="female"} \\
		\end{cases},</code>
</p>

<p>If there are more than two variables, the conditional distribution would be stratified by the intersection of all subgroups defined by the variables.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of length <code>nrow(data)</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_from_dag">sim_from_dag</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(42)

#### with one parent node ####

# define conditional distributions
distr &lt;- list(male=list("rnorm", mean=100, sd=5),
              female=list("rcategorical", probs=c(0.1, 0.2, 0.7)))

# define DAG
dag &lt;- empty_dag() +
  node("sex", type="rcategorical", labels=c("male", "female"),
       coerce2factor=TRUE, probs=c(0.4, 0.6)) +
  node("chemo", type="rbernoulli", p=0.5) +
  node("A", type="conditional_distr", parents="sex", distr=distr)

# generate data
data &lt;- sim_from_dag(dag=dag, n_sim=1000)


#### with two parent nodes ####

# define conditional distributions with interaction between parents
distr &lt;- list(male.FALSE=list("rnorm", mean=100, sd=5),
              male.TRUE=list("rnorm", mean=100, sd=20),
              female.FALSE=list("rbernoulli", p=0.5),
              female.TRUE=list("rcategorical", probs=c(0.1, 0.2, 0.7)))

# define DAG
dag &lt;- empty_dag() +
  node("sex", type="rcategorical", labels=c("male", "female"),
       coerce2factor=TRUE, probs=c(0.4, 0.6)) +
  node("chemo", type="rbernoulli", p=0.5) +
  node("A", type="conditional_distr", parents=c("sex", "chemo"), distr=distr)

# generate data
data &lt;- sim_from_dag(dag=dag, n_sim=1000)
</code></pre>

<hr>
<h2 id='node_conditional_prob'>
Simulate a Node Using Conditional Probabilities
</h2><span id='topic+node_conditional_prob'></span>

<h3>Description</h3>

<p>This function can be used to generate dichotomous or categorical variables dependent on one or more categorical variables where the probabilities of occurrence in each strata defined by those variables is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_conditional_prob(data, parents, probs, default_probs=NULL,
                      default_val=NA, labels=NULL,
                      coerce2factor=FALSE, check_inputs=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_conditional_prob_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> (or something that can be coerced to a <code>data.table</code>) containing all columns specified by <code>parents</code>.
</p>
</td></tr>
<tr><td><code id="node_conditional_prob_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has.
</p>
</td></tr>
<tr><td><code id="node_conditional_prob_+3A_probs">probs</code></td>
<td>

<p>A named list where each element corresponds to one stratum defined by parents. If only one name is given in <code>parents</code>, this means that there should be one element for possible value of the variable given in <code>parents</code>. If the node has multiple <code>parents</code>, there needs to be one element for possible combinations of <code>parents</code> (see examples). The values of those elements should either be a single number, corresponding to the probability of occurrence of a single event/value in case of a dichotomous variable, or a vector of probabilities that sum to 1, corresponding to class probabilities. In either case, the length of all elements should be the same. If possible strata of <code>parents</code> (or their possible combinations in case of multiple <code>parents</code>) are omitted, the result will be set to <code>default_val</code> for these omitted strata. See argument <code>default_val</code> and argument <code>default_probs</code> for an alternative.
</p>
</td></tr>
<tr><td><code id="node_conditional_prob_+3A_default_probs">default_probs</code></td>
<td>

<p>If not all possible strata of <code>parents</code> are included in <code>probs</code>, the user may set default probabilities for all omitted strata. For example, if there are three strata (A, B and C) defined by <code>parents</code> and <code>probs</code> only contains defined probabilities for strata A, the probabilities for strata B and C can be set simultaneously by using this argument. Should be a single value between 0 and 1 for Bernoulli trials and a numeric vector with sum 1 for multinomial trials. If <code>NULL</code> (default) the value of the produced output for missing strata will be set to <code>default_val</code> (see below).
</p>
</td></tr>
<tr><td><code id="node_conditional_prob_+3A_default_val">default_val</code></td>
<td>

<p>Value of the produced variable in strata that are not included in the <code>probs</code> argument. If <code>default_probs</code> is not <code>NULL</code>, that arguments functionality will be used instead.
</p>
</td></tr>
<tr><td><code id="node_conditional_prob_+3A_labels">labels</code></td>
<td>

<p>A vector of labels for the generated output. If <code>NULL</code> (default) and the output is dichotomous, a logical variable will be returned. If <code>NULL</code> and the output is categorical, it simply uses integers starting from 1 as class labels.
</p>
</td></tr>
<tr><td><code id="node_conditional_prob_+3A_coerce2factor">coerce2factor</code></td>
<td>

<p>A single logical value specifying whether to return the drawn events as a factor or not.
</p>
</td></tr>
<tr><td><code id="node_conditional_prob_+3A_check_inputs">check_inputs</code></td>
<td>

<p>A single logical value specifying whether input checks should be performed or not. Set to <code>FALSE</code> to save some computation time in simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utilizing the user-defined discrete probability distribution in each stratum of <code>parents</code> (supplied using the <code>probs</code> argument), this function simply calls either the <code><a href="#topic+rbernoulli">rbernoulli</a></code> or the <code><a href="#topic+rcategorical">rcategorical</a></code> function.
</p>
<p><strong><em>Formal Description</em></strong>:
</p>
<p>Formally, the data generation process can be described as a series of conditional equations. For example, suppose that there is just one parent node <code>sex</code> with the levels <code>male</code> and <code>female</code> with the goal of creating a binary outcome that has a probability of occurrence of 0.5 for males and 0.7 for females. The conditional equation is then:
</p>
<p style="text-align: center;"><code class="reqn">Y \sim Bernoulli(p),</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">p = \begin{cases}
			0.5, &amp; \text{if } \texttt{sex="male"} \\
			0.7, &amp; \text{if } \texttt{sex="female"} \\
		\end{cases},</code>
</p>

<p>and <code class="reqn">Bernoulli(p)</code> is the Bernoulli distribution with success probability <code class="reqn">p</code>. If the outcome has more than two categories, the Bernoulli distribution would be replaced by <code class="reqn">Multinomial(p)</code> with <code class="reqn">p</code> being replaced by a matrix of class probabilities. If there are more than two variables, the conditional distribution would be stratified by the intersection of all subgroups defined by the variables.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of length <code>nrow(data)</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_from_dag">sim_from_dag</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(42)

#### two classes, one parent node ####

# define conditional probs
probs &lt;- list(male=0.5, female=0.8)

# define DAG
dag &lt;- empty_dag() +
  node("sex", type="rcategorical", labels=c("male", "female"),
       coerce2factor=TRUE, probs=c(0.5, 0.5)) +
  node("chemo", type="rbernoulli", p=0.5) +
  node("A", type="conditional_prob", parents="sex", probs=probs)

# generate data
data &lt;- sim_from_dag(dag=dag, n_sim=1000)


#### three classes, one parent node ####

# define conditional probs
probs &lt;- list(male=c(0.5, 0.2, 0.3), female=c(0.8, 0.1, 0.1))

# define DAG
dag &lt;- empty_dag() +
  node("sex", type="rcategorical", labels=c("male", "female"),
       coerce2factor=TRUE, probs=c(0.5, 0.5)) +
  node("chemo", type="rbernoulli", p=0.5) +
  node("A", type="conditional_prob", parents="sex", probs=probs)

# generate data
data &lt;- sim_from_dag(dag=dag, n_sim=1000)


#### two classes, two parent nodes ####

# define conditional probs
probs &lt;- list(male.FALSE=0.5,
              male.TRUE=0.8,
              female.FALSE=0.1,
              female.TRUE=0.3)

# define DAG
dag &lt;- empty_dag() +
  node("sex", type="rcategorical", labels=c("male", "female"),
       coerce2factor=TRUE, probs=c(0.5, 0.5)) +
  node("chemo", type="rbernoulli", p=0.5) +
  node("A", type="conditional_prob", parents=c("sex", "chemo"), probs=probs)

# generate data
data &lt;- sim_from_dag(dag=dag, n_sim=1000)


#### three classes, two parent nodes ####

# define conditional probs
probs &lt;- list(male.FALSE=c(0.5, 0.1, 0.4),
              male.TRUE=c(0.8, 0.1, 0.1),
              female.FALSE=c(0.1, 0.7, 0.2),
              female.TRUE=c(0.3, 0.4, 0.3))

# define dag
dag &lt;- empty_dag() +
  node("sex", type="rcategorical", labels=c("male", "female"),
       coerce2factor=TRUE, probs=c(0.5, 0.5)) +
  node("chemo", type="rbernoulli", p=0.5) +
  node("A", type="conditional_prob", parents=c("sex", "chemo"), probs=probs)

# generate data
data &lt;- sim_from_dag(dag=dag, n_sim=1000)
</code></pre>

<hr>
<h2 id='node_cox'>
Simulate a Node Using Cox-Regression
</h2><span id='topic+node_cox'></span>

<h3>Description</h3>

<p>Data from the parents is used to generate the node using cox-regression using the method of Bender et al. (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_cox(data, parents, formula=NULL, betas, surv_dist, lambda, gamma,
         cens_dist, cens_args, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_cox_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> (or something that can be coerced to a <code>data.table</code>) containing all columns specified by <code>parents</code>.
</p>
</td></tr>
<tr><td><code id="node_cox_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has. If non-linear combinations or interaction effects should be included, the user may specify the <code>formula</code> argument instead.
</p>
</td></tr>
<tr><td><code id="node_cox_+3A_formula">formula</code></td>
<td>

<p>An optional <code>formula</code> object to describe how the node should be generated or <code>NULL</code> (default). If supplied it should start with <code>~</code>, having nothing else on the left hand side. The right hand side may contain any valid formula syntax, such as <code>A + B</code> or <code>A + B + I(A^2)</code>, allowing non-linear effects. If this argument is defined, there is no need to define the <code>parents</code> argument. For example, using <code>parents=c("A", "B")</code> is equal to using <code>formula= ~ A + B</code>.
</p>
</td></tr>
<tr><td><code id="node_cox_+3A_betas">betas</code></td>
<td>

<p>A numeric vector with length equal to <code>parents</code>, specifying the causal beta coefficients used to generate the node.
</p>
</td></tr>
<tr><td><code id="node_cox_+3A_surv_dist">surv_dist</code></td>
<td>

<p>A single character specifying the distribution that should be used when generating the survival times. Can be either <code>"weibull"</code> or <code>"exponential"</code>.
</p>
</td></tr>
<tr><td><code id="node_cox_+3A_lambda">lambda</code></td>
<td>

<p>A single number used as parameter defined by <code>surv_dist</code>.
</p>
</td></tr>
<tr><td><code id="node_cox_+3A_gamma">gamma</code></td>
<td>

<p>A single number used as parameter defined by <code>surv_dist</code>.
</p>
</td></tr>
<tr><td><code id="node_cox_+3A_cens_dist">cens_dist</code></td>
<td>

<p>A single character naming the distribution function that should be used to generate the censoring times. For example, <code>"runif"</code> could be used to generate uniformly distributed censoring times. Set to <code>NULL</code> to get no censoring.
</p>
</td></tr>
<tr><td><code id="node_cox_+3A_cens_args">cens_args</code></td>
<td>

<p>A list of named arguments which will be passed to the function specified by the <code>cens_dist</code> argument.
</p>
</td></tr>
<tr><td><code id="node_cox_+3A_name">name</code></td>
<td>

<p>A single character string specifying the name of the node.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival times are generated according to the cox proportional-hazards regression model as defined by the user. How exactly the data-generation works is described in detail in Bender et al. (2005). To also include censoring, this function allows the user to supply a function that generates random censoring times. If the censoring time is smaller than the generated survival time, the individual is considered censored.
</p>
<p>Unlike the other <code><a href="#topic+node">node</a></code> type functions, this function adds <strong>two</strong> columns to the resulting dataset instead of one. The first column is called <code>paste0(name, "_event")</code> and is a logical variable, where <code>TRUE</code> indicates that the event has happened and <code>FALSE</code> indicates right-censoring. The second column is named <code>paste0(name, "_time")</code> and includes the survival or censoring time corresponding to the previously mentioned event indicator. This is the standard format for right-censored time-to-event data without time-varying covariates.
</p>
<p>To simulate more complex time-to-event data, the user may need to use the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function instead.
</p>


<h3>Value</h3>

<p>Returns a <code>data.table</code> of length <code>nrow(data)</code> containing two columns. Both starting with the nodes <code>name</code> and ending with <code>_event</code> and <code>_time</code>. The first is a logical vector, the second a numeric one.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>References</h3>

<p>Bender R, Augustin T, Blettner M. Generating survival times to simulate Cox proportional hazards models. Statistics in Medicine. 2005; 24 (11): 1713-1723.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(3454)

# define DAG
dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("death", type="cox", parents=c("sex", "age"), betas=c(1.1, 0.4),
       surv_dist="weibull", lambda=1.1, gamma=0.7, cens_dist="runif",
       cens_args=list(min=0, max=1))

sim_dat &lt;- sim_from_dag(dag=dag, n_sim=1000)
</code></pre>

<hr>
<h2 id='node_custom'>
Create Your Own Function to Simulate a Root Node, Child Node or Time-Dependent Node
</h2><span id='topic+node_custom'></span>

<h3>Description</h3>

<p>This page describes in detail how to define custom functions to allow the usage of root nodes, child nodes or time-dependent nodes that are not directly implemented in this package. By doing so, users may create data with any functional dependence they can think of.
</p>


<h3>Details</h3>

<p>The number of available types of nodes is limited, but this package allows the user to easily implement their own node types by writing a single custom function. Users may create their own root nodes, child nodes and time-dependent nodes. The requirements for each node type are listed below. Some simple examples for each node type are given further below.
</p>
<p>If you think that your custom node type might be useful to others, please contact the maintainer of this package via the supplied e-mail address or github and we might add it to this package.
</p>
<p><strong><em>Root Nodes</em></strong>:
</p>
<p>Any function that generates some vector of size <code class="reqn">n</code> with <code>n==nrow(data)</code>, or a <code>data.frame</code> with as many rows as the current data can be used as a child node. The only requirement is:
</p>

<ul>
<li> <p><strong>1.)</strong> The function should have an argument called <code>n</code> which controls how many samples to generate.
</p>
</li></ul>

<p>Some examples that are already implemented in R outside of this package are <code>rnorm()</code>, <code>rgamma()</code> and <code>rbeta()</code>. The function may take any amount of further arguments, which will be passed through the three-dot syntax.
</p>
<p><strong><em>Child Nodes</em></strong>:
</p>
<p>Again, almost any function may be used to generate a child node. Only four things are required for this to work properly:
</p>

<ul>
<li> <p><strong>1.)</strong> Its' name should start with <code>node_</code>.
</p>
</li>
<li> <p><strong>2.)</strong> It should contain an argument called <code>data</code> (contains the already generated data).
</p>
</li>
<li> <p><strong>3.)</strong> It should contain an argument called <code>parents</code> (contains a vector of the child nodes parents).
</p>
</li>
<li> <p><strong>4.)</strong> It should return either a vector of length <code>n_sim</code> or a <code>data.frame</code> with any number of columns and <code>n_sim</code> rows.
</p>
</li></ul>

<p>The function may include any amount of additional arguments specified by the user.
</p>
<p><strong><em>Time-Dependent Nodes</em></strong>:
</p>
<p>By time-dependent nodes we mean nodes that are created using the <code><a href="#topic+node_td">node_td</a></code> function. In general, this works in essentially the same way as for simple root nodes or child nodes. The requirements are:
</p>

<ul>
<li> <p><strong>1.)</strong> Its' name should start with <code>node_</code>.
</p>
</li>
<li> <p><strong>2.)</strong> It should contain an argument called <code>data</code> (contains the already generated data).
</p>
</li>
<li> <p><strong>3.)</strong> If it is a child node, it should contain an argument called <code>parents</code> (contains a vector of the child nodes parents). This is not necessary for nodes that are independently generated.
</p>
</li>
<li> <p><strong>4.)</strong> It should return either a vector of length <code>n_sim</code> or a <code>data.frame</code> with any number of columns and <code>n_sim</code> rows.
</p>
</li></ul>

<p>Again, any number of additional arguments is allowed and will be passed through the three-dot syntax. Additionally, users may add an argument to this function called <code>sim_time</code>. If included in the function definition, the current time of the simulation will be passed to the function on every call made to it.
</p>


<h3>Value</h3>

<p>Should return either a vector of length <code>nrow(data)</code> or a <code>data.table</code> or <code>data.frame</code> with <code>nrow(data)</code> rows.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(3545)

################ Custom Root Nodes ###################

# using external functions without defining them yourself can be done this way
dag &lt;- empty_dag() +
  node("A", type="rgamma", shape=0.1, rate=2) +
  node("B", type="rbeta", shape1=2, shape2=0.3)

## define your own root node instead
# this function takes the sum of a normally distributed random number and an
# uniformly distributed random number
custom_root &lt;- function(n, min=0, max=1, mean=0, sd=1) {
  out &lt;- runif(n, min=min, max=max) + rnorm(n, mean=mean, sd=sd)
  return(out)
}

dag &lt;- empty_dag() +
  node("A", type="custom_root", min=0, max=10, mean=5, sd=2)

############### Custom Child Nodes ###################

# create a custom node function, which is just a gaussian node that
# includes (bad) truncation
node_gaussian_trunc &lt;- function(data, parents, betas, intercept, error,
                                left, right) {
  out &lt;- node_gaussian(data=data, parents=parents, betas=betas,
                       intercept=intercept, error=error)
  out &lt;- ifelse(out &lt;= left, left,
                ifelse(out &gt;= right, right, out))
  return(out)
}

# another custom node function, which simply returns a sum of the parents
node_parents_sum &lt;- function(data, parents, betas=NULL) {
  out &lt;- rowSums(data[, parents, with=FALSE])
  return(out)
}

# an example of using these new node types in a simulation
dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("custom_1", type="gaussian_trunc", parents=c("sex", "age"),
       betas=c(1.1, 0.4), intercept=-2, error=2, left=10, right=25) +
  node("custom_2", type="parents_sum", parents=c("age", "custom_1"))

sim_dat &lt;- sim_from_dag(dag=dag, n_sim=100)

########## Custom Time-Dependent Nodes ###############

## example for a custom time-dependent node with no parents
# this node simply draws a new value from a normal distribution at
# each point in time
node_custom_root_td &lt;- function(data, n, mean=0, sd=1) {
  return(rnorm(n=n, mean=mean, sd=sd))
}

n_sim &lt;- 100

dag &lt;- empty_dag() +
  node_td(name="Something", type="custom_root_td", n=n_sim, mean=10, sd=5)

sim &lt;- sim_discrete_time(dag, n_sim=n_sim, max_t=10)

## example for a custom time-dependent child node
# draw from a normal distribution with different specifications based on
# whether a previously updated time-dependent node is currently TRUE
node_custom_child &lt;- function(data, parents) {
  out &lt;- numeric(nrow(data))
  out[data$other_event] &lt;- rnorm(n=sum(data$other_event), mean=10, sd=3)
  out[!data$other_event] &lt;- rnorm(n=sum(!data$other_event), mean=5, sd=10)
  return(out)
}

dag &lt;- empty_dag() +
  node_td("other", type="time_to_event", prob_fun=0.1) +
  node_td("whatever", type="custom_child", parents="other_event")

sim &lt;- sim_discrete_time(dag, n_sim=50, max_t=10)

## using the sim_time argument in a custom node function
# this function returns a continuous variable that is simply the
# current simulation time squared
node_square_sim_time &lt;- function(data, sim_time, n_sim) {
  return(rep(sim_time^2, n=n_sim))
}

# note that we should not actually define the sim_time argument in the
# node_td() call below, because it will be passed internally, just like data
dag &lt;- empty_dag() +
  node_td("unclear", type="square_sim_time", n_sim=100)

sim &lt;- sim_discrete_time(dag, n_sim=100, max_t=10)
</code></pre>

<hr>
<h2 id='node_gaussian'>
Simulate a Node Using Linear Regression
</h2><span id='topic+node_gaussian'></span>

<h3>Description</h3>

<p>Data from the parents is used to generate the node using linear regression by predicting the covariate specific mean and sampling from a normal distribution with that mean and a specified standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_gaussian(data, parents, formula=NULL, betas, intercept, error)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_gaussian_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> (or something that can be coerced to a <code>data.table</code>) containing all columns specified by <code>parents</code>.
</p>
</td></tr>
<tr><td><code id="node_gaussian_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has. If non-linear combinations or interaction effects should be included, the user may specify the <code>formula</code> argument instead.
</p>
</td></tr>
<tr><td><code id="node_gaussian_+3A_formula">formula</code></td>
<td>

<p>An optional <code>formula</code> object to describe how the node should be generated or <code>NULL</code> (default). If supplied it should start with <code>~</code>, having nothing else on the left hand side. The right hand side may contain any valid formula syntax, such as <code>A + B</code> or <code>A + B + I(A^2)</code>, allowing non-linear effects. If this argument is defined, there is no need to define the <code>parents</code> argument. For example, using <code>parents=c("A", "B")</code> is equal to using <code>formula= ~ A + B</code>.
</p>
</td></tr>
<tr><td><code id="node_gaussian_+3A_betas">betas</code></td>
<td>

<p>A numeric vector with length equal to <code>parents</code>, specifying the causal beta coefficients used to generate the node.
</p>
</td></tr>
<tr><td><code id="node_gaussian_+3A_intercept">intercept</code></td>
<td>

<p>A single number specifying the intercept that should be used when generating the node.
</p>
</td></tr>
<tr><td><code id="node_gaussian_+3A_error">error</code></td>
<td>

<p>A single number specifying the sigma error that should be used when generating the node.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the general linear regression equation, the observation-specific value that would be expected given the model is generated for every observation in the dataset generated thus far. We could stop here, but this would create a perfect fit for the node, which is unrealistic. Instead, we add an error term by taking one sample of a normal distribution for each observation with mean zero and standard deviation <code>error</code>. This error term is then added to the predicted mean.
</p>
<p><strong><em>Formal Description</em></strong>:
</p>
<p>Formally, the data generation can be described as:
</p>
<p style="text-align: center;"><code class="reqn">Y \sim \texttt{intercept} + \texttt{parents}_1 \cdot \texttt{betas}_1 + ... + \texttt{parents}_n \cdot \texttt{betas}_n+ N(0, \texttt{error}),</code>
</p>

<p>where <code class="reqn">N(0, \texttt{error})</code> denotes the normal distribution with mean 0 and a standard deviation of <code>error</code> and <code class="reqn">n</code> is the number of parents (<code>length(parents)</code>).
</p>
<p>For example, given <code>intercept=-15</code>, <code>parents=c("A", "B")</code>, <code>betas=c(0.2, 1.3)</code> and <code>error=2</code> the data generation process is defined as:
</p>
<p style="text-align: center;"><code class="reqn">Y \sim -15 + A \cdot 0.2 + B \cdot 1.3 + N(0, 2).</code>
</p>



<h3>Value</h3>

<p>Returns a numeric vector of length <code>nrow(data)</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_from_dag">sim_from_dag</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(12455432)

dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("bmi", type="gaussian", parents=c("sex", "age"),
       betas=c(1.1, 0.4), intercept=12, error=2)

sim_dat &lt;- sim_from_dag(dag=dag, n_sim=100)
</code></pre>

<hr>
<h2 id='node_multinomial'>
Simulate a Node Using Multinomial Regression
</h2><span id='topic+node_multinomial'></span>

<h3>Description</h3>

<p>Data from the parents is used to generate the node using multinomial regression by predicting the covariate specific probability of each class and sampling from a multinomial distribution accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_multinomial(data, parents, betas, intercepts,
                 labels=NULL, coerce2factor=TRUE,
                 return_prob=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_multinomial_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> (or something that can be coerced to a <code>data.table</code>) containing all columns specified by <code>parents</code>.
</p>
</td></tr>
<tr><td><code id="node_multinomial_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has.
</p>
</td></tr>
<tr><td><code id="node_multinomial_+3A_betas">betas</code></td>
<td>

<p>A numeric matrix with <code>length(parents)</code> columns and one row for each class that should be simulated, specifying the causal beta coefficients used to generate the node.
</p>
</td></tr>
<tr><td><code id="node_multinomial_+3A_intercepts">intercepts</code></td>
<td>

<p>A numeric vector with one entry for each class that should be simulated, specifying the intercepts used to generate the node.
</p>
</td></tr>
<tr><td><code id="node_multinomial_+3A_labels">labels</code></td>
<td>

<p>An optional character vector giving the factor levels of the generated classes. If <code>NULL</code> (default), the integers are simply used as factor levels.
</p>
</td></tr>
<tr><td><code id="node_multinomial_+3A_coerce2factor">coerce2factor</code></td>
<td>

<p>A single logical value specifying whether to return the drawn events as a factor (default) or as integers.
</p>
</td></tr>
<tr><td><code id="node_multinomial_+3A_return_prob">return_prob</code></td>
<td>

<p>Either <code>TRUE</code> or <code>FALSE</code> (default). Specifies whether to return the matrix of class probabilities or not. If you are using this function inside of a <code><a href="#topic+node">node</a></code> call, you cannot set this to <code>TRUE</code> because it will return a matrix. It may, however, be useful when using this function by itself, or as a probability generating function for the <code><a href="#topic+node_competing_events">node_competing_events</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works essentially like the <code><a href="#topic+node_binomial">node_binomial</a></code> function. First, the matrix of <code>betas</code> coefficients is used in conjunction with the values defined in the <code>parents</code> nodes and the <code>intercepts</code> to calculate the expected subject-specific probabilities of occurrence for each possible category. This is done using the standard multinomial regression equations. Using those probabilities in conjunction with the <code><a href="#topic+rcategorical">rcategorical</a></code> function, a single one of the possible categories is drawn for each individual.
</p>
<p>Since this function produces categorical output (as it should), it may be difficult to use this node type as a parent for other nodes. Nevertheless, it is of course possible using a user-defined node type (see <code><a href="#topic+node_custom">node_custom</a></code> for some infos on how to define those).
</p>


<h3>Value</h3>

<p>Returns a vector of length <code>nrow(data)</code>. Depending on the used arguments, this vector may be of type character, numeric of factor. If <code>return_prob</code> was used it instead returns a numeric matrix containing one column per possible event and <code>nrow(data)</code> rows.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_from_dag">sim_from_dag</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(3345235)

dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("UICC", type="multinomial", parents=c("sex", "age"),
       betas=matrix(c(0.2, 0.4, 0.1, 0.5, 1.1, 1.2), ncol=2),
       intercepts=1)

sim_dat &lt;- sim_from_dag(dag=dag, n_sim=100)
</code></pre>

<hr>
<h2 id='node_negative_binomial'>
Simulate a Node Using Negative Binomial Regression
</h2><span id='topic+node_negative_binomial'></span>

<h3>Description</h3>

<p>Data from the parents is used to generate the node using negative binomial regression by applying the betas to the design matrix and sampling from the <code>rnbinom</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_negative_binomial(data, parents, formula=NULL, betas,
                       intercept, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_negative_binomial_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> (or something that can be coerced to a <code>data.table</code>) containing all columns specified by <code>parents</code>.
</p>
</td></tr>
<tr><td><code id="node_negative_binomial_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has. If non-linear combinations or interaction effects should be included, the user may specify the <code>formula</code> argument instead.
</p>
</td></tr>
<tr><td><code id="node_negative_binomial_+3A_formula">formula</code></td>
<td>

<p>An optional <code>formula</code> object to describe how the node should be generated or <code>NULL</code> (default). If supplied it should start with <code>~</code>, having nothing else on the left hand side. The right hand side may contain any valid formula syntax, such as <code>A + B</code> or <code>A + B + I(A^2)</code>, allowing non-linear effects. If this argument is defined, there is no need to define the <code>parents</code> argument. For example, using <code>parents=c("A", "B")</code> is equal to using <code>formula= ~ A + B</code>.
</p>
</td></tr>
<tr><td><code id="node_negative_binomial_+3A_betas">betas</code></td>
<td>

<p>A numeric vector with length equal to <code>parents</code>, specifying the causal beta coefficients used to generate the node.
</p>
</td></tr>
<tr><td><code id="node_negative_binomial_+3A_intercept">intercept</code></td>
<td>

<p>A single number specifying the intercept that should be used when generating the node.
</p>
</td></tr>
<tr><td><code id="node_negative_binomial_+3A_theta">theta</code></td>
<td>

<p>A single number specifying the theta parameter (<code>size</code> argument in <code>rnbinom</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the linear predictor defined by the <code>betas</code> and the input design matrix to sample from a subject-specific negative binomial distribution. It does to by calculating the linear predictor using the <code>data</code>, <code>betas</code> and <code>intercept</code>, exponentiating it and passing it to the <code>mu</code> argument of the <code>rnbinom</code> function of the <span class="pkg">stats</span> package.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of length <code>nrow(data)</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_from_dag">sim_from_dag</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(124554)

dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("smoking", type="negative_binomial", parents=c("sex", "age"),
       betas=c(1.1, 0.4), intercept=-2, theta=0.05)

sim_dat &lt;- sim_from_dag(dag=dag, n_sim=100)
</code></pre>

<hr>
<h2 id='node_poisson'>
Simulate a Node Using Poisson Regression
</h2><span id='topic+node_poisson'></span>

<h3>Description</h3>

<p>Data from the parents is used to generate the node using poisson regression by predicting the covariate specific lambda and sampling from a poisson distribution accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_poisson(data, parents, formula=NULL, betas, intercept)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_poisson_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> (or something that can be coerced to a <code>data.table</code>) containing all columns specified by <code>parents</code>.
</p>
</td></tr>
<tr><td><code id="node_poisson_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has. If non-linear combinations or interaction effects should be included, the user may specify the <code>formula</code> argument instead.
</p>
</td></tr>
<tr><td><code id="node_poisson_+3A_formula">formula</code></td>
<td>

<p>An optional <code>formula</code> object to describe how the node should be generated or <code>NULL</code> (default). If supplied it should start with <code>~</code>, having nothing else on the left hand side. The right hand side may contain any valid formula syntax, such as <code>A + B</code> or <code>A + B + I(A^2)</code>, allowing non-linear effects. If this argument is defined, there is no need to define the <code>parents</code> argument. For example, using <code>parents=c("A", "B")</code> is equal to using <code>formula= ~ A + B</code>.
</p>
</td></tr>
<tr><td><code id="node_poisson_+3A_betas">betas</code></td>
<td>

<p>A numeric vector with length equal to <code>parents</code>, specifying the causal beta coefficients used to generate the node.
</p>
</td></tr>
<tr><td><code id="node_poisson_+3A_intercept">intercept</code></td>
<td>

<p>A single number specifying the intercept that should be used when generating the node.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, this function simply calculates the linear predictor defined by the <code>betas</code>-coefficients, the <code>intercept</code> and the values of the <code>parents</code>. The exponential function is then applied to this predictor and the result is passed to the <code><a href="stats.html#topic+rpois">rpois</a></code> function. The result is a draw from a subject-specific poisson distribution, resembling the user-defined poisson regression model.
</p>
<p><strong><em>Formal Description</em></strong>:
</p>
<p>Formally, the data generation can be described as:
</p>
<p style="text-align: center;"><code class="reqn">Y \sim Poisson(\lambda),</code>
</p>

<p>where <code class="reqn">Poisson()</code> means that the variable is Poisson distributed with:
</p>
<p style="text-align: center;"><code class="reqn">P_\lambda(k) = \frac{\lambda^k e^{-\lambda}}{k!}.</code>
</p>

<p>Here, <code class="reqn">k</code> is the count and <code class="reqn">e</code> is eulers number. The parameter <code class="reqn">\lambda</code> is determined as:
</p>
<p style="text-align: center;"><code class="reqn">\lambda = \exp(\texttt{intercept} + \texttt{parents}_1 \cdot \texttt{betas}_1 + ... + \texttt{parents}_n \cdot \texttt{betas}_n),</code>
</p>

<p>where <code class="reqn">n</code> is the number of parents (<code>length(parents)</code>).
</p>
<p>For example, given <code>intercept=-15</code>, <code>parents=c("A", "B")</code>, <code>betas=c(0.2, 1.3)</code> the data generation process is defined as:
</p>
<p style="text-align: center;"><code class="reqn">Y \sim Poisson(\exp(-15 + A \cdot 0.2 + B \cdot 1.3)).</code>
</p>



<h3>Value</h3>

<p>Returns a numeric vector of length <code>nrow(data)</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_from_dag">sim_from_dag</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(345345)

dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("smoking", type="poisson", parents=c("sex", "age"),
       betas=c(1.1, 0.4), intercept=-2)

sim_dat &lt;- sim_from_dag(dag=dag, n_sim=100)
</code></pre>

<hr>
<h2 id='node_time_to_event'>
Simulate a Time-to-Event Node in Discrete-Time Simulation
</h2><span id='topic+node_time_to_event'></span>

<h3>Description</h3>

<p>This node essentially models a dichotomous time-dependent variable for which the time of the event will be important for later usage. It adds two columns to <code>data</code>: <code>name_event</code> (whether the person currently has an event) and <code>name_time</code> (the time at which the current event started). Past events are stored in a list. Can only be used inside of the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function, not outside of it. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_time_to_event(data, parents, sim_time, name,
                   prob_fun, ..., event_duration=1,
                   immunity_duration=event_duration,
                   time_since_last=FALSE, event_count=FALSE,
                   save_past_events=TRUE, check_inputs=TRUE,
                   envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_time_to_event_+3A_data">data</code></td>
<td>

<p>A <code>data.table</code> containing all columns specified by <code>parents</code>. Similar objects such as <code>data.frame</code>s are not supported.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_parents">parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has. Those child nodes should be valid column names in <code>data</code>. Because the state of this variable is by definition dependent on its previous states, the columns produced by this function will automatically be considered its parents without the user having to manually specify this.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_sim_time">sim_time</code></td>
<td>

<p>The current time of the simulation.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_name">name</code></td>
<td>

<p>The name of the node. This will be used as prefix before the <code>_event</code>, <code>_time</code> columns. If the <code>time_since_last</code> or <code>event_count</code> arguments are set to <code>TRUE</code>, this will also be used as prefix for those respective columns.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_prob_fun">prob_fun</code></td>
<td>

<p>A function that returns a numeric vector of size <code>nrow(data)</code> containing only numbers between 0 and 1. These numbers specify the person-specific probability of experiencing the event modeled by this node at the particular point in time of the simulation. The corresponding event will be generated internally using the <code><a href="#topic+rbernoulli">rbernoulli</a></code> function. The function needs to have a named argument called <code>data</code>. If the function has an argument named <code>sim_time</code>, the current simulation time will also be passed to this function automatically, allowing time-dependent probabilities to be generated. Alternatively this argument can be set to a single number (between 0 and 1), resulting in a fixed probability of occurrence for every simulated individual at every point in time.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_...">...</code></td>
<td>

<p>An arbitrary amount of additional named arguments passed to <code>prob_fun</code>. Ignore this if you do not want to pass any arguments. Also ignored if <code>prob_fun</code> is a single number.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_event_duration">event_duration</code></td>
<td>

<p>A single number &gt; 0 specifying how long the event should last. The point in time at which an event occurs also counts into this duration. For example, if an event occurs at <code class="reqn">t = 2</code> and it has a duration of 3, the event will be set to <code>TRUE</code> on <code class="reqn">t \in \{2, 3, 4\}</code>. Therefore, all events must have a duration of at least 1 unit (otherwise they never happened).
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_immunity_duration">immunity_duration</code></td>
<td>

<p>A single number &gt;= <code>event_duration</code> specifying how long the person should be immune to the event after it is over. The count internally starts when the event starts, so in order to use an immunity duration of 10 time units after the event is over <code>event_duration + 10</code> should be used.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_time_since_last">time_since_last</code></td>
<td>

<p>Either <code>TRUE</code> or <code>FALSE</code> (default), indicating whether an additional column should be generated that tracks the number of time units since the individual had its last event onset. For example, if the individual experienced a single event at <code class="reqn">t = 10</code>, this column would be <code>NA</code> before time 10, 0 at time 10 and increased by 1 at each point in time. If another event happens, the time is set to 0 again. The column is named <code>paste0(name, "_time_since_last")</code>. The difference to the column ending with <code>"_time"</code> is that this column will not be set to <code>NA</code> again if the <code>immunity_duration</code> is over. It keeps counting until the end of the simulation, which may be useful when constructing event-time dependent probability functions.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_event_count">event_count</code></td>
<td>

<p>Either <code>TRUE</code> or <code>FALSE</code> (default), indicating whether an additional column should be generated that tracks the number of events the individual has already experienced. This column is 0 for all individuals at t = 0. Each time a new event occurs, the counter is increased by one. Note that only new events increase this counter. For example, an individual with an event at t = 10 that has an <code>event_duration</code> of 15 will have a value of 0 before t = 10, and will have a value of 1 at t = 10 and afterwards. The column will be named <code>paste0(name, "_event_count")</code>.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_save_past_events">save_past_events</code></td>
<td>

<p>When the event modeled using this node is recurrent (<code>immunity_duration &lt; Inf &amp; event_duration &lt; Inf</code>), the same person may experience multiple events over the course of the simulation. Those are generally stored in the <code>tte_past_events</code> list which is included in the output of the <code>sim_discrete_time</code> function. This extends the runtime and increases RAM usage, so if you are not interested in the timing of previous events or if you are using <code>save_states="all"</code> this functionality can be turned off by setting this argument to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_check_inputs">check_inputs</code></td>
<td>

<p>Whether to perform plausibility checks for the user input or not. Is set to <code>TRUE</code> by default, but can be set to <code>FALSE</code> in order to speed things up when using this function in a simulation study or something similar.
</p>
</td></tr>
<tr><td><code id="node_time_to_event_+3A_envir">envir</code></td>
<td>

<p>Only used internally to efficiently store the past event times. Cannot be used by the user.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When performing discrete-time simulation using the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function, the standard node functions implemented in this package are usually not sufficient because they don't capture the time-dependent nature of some very interesting variables. Often, the variable that should be modelled has some probability of occurring at each point in time. Once it does occur, it has some kind of influence on other variables for a period of time until it goes back to normal (or doesn't). This could be a car crash, a surgery, a vaccination etc. The <code>time_to_event</code> node function can be used to model these kinds of nodes in a fairly straightforward fashion.
</p>
<p><strong><em>How it Works</em></strong>:
</p>
<p>At <code class="reqn">t = 1</code>, this node will be initialized for the first time. It adds two columns to the data: <code>name_event</code> (whether the person currently has an event) and <code>name_time</code> (the time at which the current event started) where <code>name</code> is the name of the node. Additionally, it adds a list with <code>max_t</code> entries to the <code>tte_past_events</code> list returned by the <code>sim_discrete_time</code> function, which records which individuals experienced a new event at each point in time.
</p>
<p>In a nutshell, it simply models the occurrence of some event by calculating the probability of occurrence at <code class="reqn">t</code> and drawing a single bernoulli trial from this probability. If the trial is a &quot;success&quot;, the corresponding event column will be set to <code>TRUE</code>, the time column will be set to the current simulation time <code class="reqn">t</code> and the column storing the past event times will receive an entry.
</p>
<p>The <code>_event</code> column will stay <code>TRUE</code> until the event is over. The duration for that is controlled by the <code>event_duration</code> parameter. When modeling terminal events such as death, one can simply set this parameter to <code>Inf</code>, making the event eternal. In many cases it will also be necessary to implement some kind of immunity after the event, which can be done using the <code>immunity_duration</code> argument. This effectively sets the probability of another occurrence of the event to 0 in the next <code>immunity_duration</code> time steps. During the immunity duration, the event may be <code>TRUE</code> (if the event is still ongoing) or <code>FALSE</code> (if the <code>event_duration</code> has already passed). The <code>_time</code> column is similarly set to the time of occurrence of the event and reset to <code>NA</code> when the <code>immunity_duration</code> is over.
</p>
<p>The probability of occurrence is calculated using the function provided by the user using the <code>prob_fun</code> argument. This can be an arbitrary complex function. The only requirement is that it takes <code>data</code> as a first argument. The columns defined by the <code>parents</code> argument will be passed to this argument automatically. If it has an argument called <code>sim_time</code>, the current time of the simulation will automatically be passed to it as well. Any further arguments can be passed using the <code>...</code> syntax. A simple example could be a logistic regression node, in which the probability is calculated as an additive linear combination of the columns defined by <code>parents</code>. A more complex function could include simulation-time dependent effects, further effects dependent on past event times etc. Examples can be found below and in the vignettes.
</p>
<p><strong><em>How it is Used</em></strong>:
</p>
<p>This function should never be called directly by the user. Instead, the user should define a DAG object using the <code><a href="#topic+empty_dag">empty_dag</a></code> and <code><a href="#topic+node_td">node_td</a></code> functions and set the <code>type</code> argument inside of a <code>node_td</code> call to <code>"time_to_event"</code>. This DAG can be passed to the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function to generate the desired data. Many examples and more explanations are given below and in the vignettes of this package.
</p>
<p><strong><em>What can be done with it</em></strong>:
</p>
<p>This type of node naturally supports the implementation of terminal and recurrent events that may be influenced by pretty much anything. By specifying the <code>parents</code> and <code>prob_fun</code> arguments correctly, it is possible to create an event type that is dependent on past events of itself or other time-to-event variables and other variables in general. The user can include any amount of these nodes in their simulation. It may also be used to simulate any kind of binary time-dependent variable that one would usually not associate with the name &quot;event&quot; as well. It is very flexible, but it does require the user to do some coding by themselves (e.g. creating a suitable function for the <code>prob_fun</code> argument).
</p>
<p><strong><em>What can't be done with it</em></strong>:
</p>
<p>Currently this function only allows binary events. Categorical event types may be implemented using the <code><a href="#topic+node_competing_events">node_competing_events</a></code> function, which works in a very similar fashion.
</p>


<h3>Value</h3>

<p>Returns a <code>data.table</code> containing at least two columns with updated values of the node.
</p>


<h3>Note</h3>

<p>This function cannot be called outside of the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function. It only makes sense to use it as a type in a <code><a href="#topic+node_td">node_td</a></code> function call, as described in the documentation and vignettes.
</p>


<h3>Author(s)</h3>

<p>Robin Denz, Katharina Meiszl
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

## a simple terminal time-to-event node, with a constant probability of
## occurrence, independent of any other variable
dag &lt;- empty_dag() +
  node_td("death", type="time_to_event", prob_fun=0.0001,
          event_duration=Inf)

## a simple recurrent time-to-event node with a constant probability of
## occurrence, independent of any other variable
dag &lt;- empty_dag() +
  node_td("car_crash", type="time_to_event", prob_fun=0.001, event_duration=1)

## a time-to-event node with a time-dependent probability function that
## has an additional argument
prob_car_crash &lt;- function(data, sim_time, base_p) {
  return(base_p + sim_time * 0.0001)
}

dag &lt;- empty_dag() +
  node_td("car_crash", type="time_to_event", prob_fun=prob_car_crash,
          event_duration=1, base_p=0.0001)

## a time-to-event node with a probability function dependent on a
## time-fixed variable
prob_car_crash &lt;- function(data) {
  ifelse(data$sex==1, 0.001, 0.01)
}

dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node_td("car_crash", type="time_to_event", prob_fun=prob_car_crash,
          parents="sex")

## a little more complex car crash simulation, where the probability for
## a car crash is dependent on the sex, and the probability of death is
## highly increased for 3 days after a car crash happened
prob_car_crash &lt;- function(data) {
  ifelse(data$sex==1, 0.001, 0.01)
}

prob_death &lt;- function(data) {
  ifelse(data$car_crash_event, 0.1, 0.0001)
}

dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node_td("car_crash", type="time_to_event", prob_fun=prob_car_crash,
          parents="sex") +
  node_td("death", type="time_to_event", prob_fun=prob_death,
          parents="car_crash_event")

# use the sim_discrete_time function to simulate data from one of these DAGs:
sim &lt;- sim_discrete_time(dag, n_sim=20, max_t=500)

## more examples can be found in the vignettes of this package
</code></pre>

<hr>
<h2 id='plot.DAG'>
Plot a <code>DAG</code> object
</h2><span id='topic+plot.DAG'></span>

<h3>Description</h3>

<p>Using the node information contained in the <code>DAG</code> object this function plots the corresponding DAG in a quick and convenient way. Some options to customize the plot are available, but it may be advisable to use other packages made explicitly to visualize DAGs instead if those do not meet the users needs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DAG'
plot(x, layout="nicely", node_size=0.2,
     node_names=NULL, node_color="black",
     node_fill="red", node_linewidth=0.5,
     node_linetype="solid", node_alpha=1,
     node_text_color="black", node_text_alpha=1,
     node_text_size=8, node_text_family="sans",
     node_text_fontface="bold", arrow_color="black",
     arrow_linetype="solid", arrow_linewidth=1,
     arrow_alpha=1, arrow_head_size=0.3,
     arrow_head_unit="cm", arrow_type="closed",
     arrow_node_dist=0.03, gg_theme=ggplot2::theme_void(),
     include_td_nodes=TRUE, mark_td_nodes=TRUE,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DAG_+3A_x">x</code></td>
<td>

<p>A <code>DAG</code> object created using the <code><a href="#topic+empty_dag">empty_dag</a></code> function with nodes added to it using the <code>+</code> syntax. See <code><a href="#topic+empty_dag">empty_dag</a></code> or <code><a href="#topic+node">node</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_layout">layout</code></td>
<td>

<p>A single character string specifying the layout of the plot. This internally calls the <code>layout_</code> function of the <span class="pkg">igraph</span> package, which offers a great variety of ways to layout the nodes of a graph. Defaults to <code>"nicely"</code>. Some other options are: <code>"as_star"</code>, <code>"as_tree"</code>, <code>"in_circle"</code>, <code>"on_spere"</code>, <code>"randomly"</code> and many more. For more details see <code>?layout_</code>.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_size">node_size</code></td>
<td>

<p>Either a single positive number or a numeric vector with one entry per node in the DAG, specifying the radius of the circles used to draw the nodes. If a single number is supplied, all nodes will be the same size (default).
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_names">node_names</code></td>
<td>

<p>A character vector with one entry for each node in the DAG specifying names that should be used for in the nodes or <code>NULL</code> (default). If <code>NULL</code>, the node names that were set during the creation of the DAG object will be used as names.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_color">node_color</code></td>
<td>

<p>A single character string specifying the color of the outline of the node circles.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_fill">node_fill</code></td>
<td>

<p>A single character string specifying the color with which the nodes are filled. Ignored if time-varying nodes are present and both <code>include_td_nodes</code> and <code>mark_td_nodes</code> are set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_linewidth">node_linewidth</code></td>
<td>

<p>A single number specifying the width of the outline of the node circles.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_linetype">node_linetype</code></td>
<td>

<p>A single character string specifying the linetype of the outline of the node circles.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_alpha">node_alpha</code></td>
<td>

<p>A single number between 0 and 1 specifying the transparency level of the nodes.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_text_color">node_text_color</code></td>
<td>

<p>A single character string specifying the color of the text inside the node circles.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_text_alpha">node_text_alpha</code></td>
<td>

<p>A single number between 0 and 1 specifying the transparency level of the text inside the node circles.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_text_size">node_text_size</code></td>
<td>

<p>A single number specifying the size of the text inside of the node circles.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_text_family">node_text_family</code></td>
<td>

<p>A single character string specifying the family of the text inside the node circles.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_node_text_fontface">node_text_fontface</code></td>
<td>

<p>A single character string specifying the fontface of the text inside the node circles.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_arrow_color">arrow_color</code></td>
<td>

<p>A single character string specifying the color of the arrows between the nodes.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_arrow_linetype">arrow_linetype</code></td>
<td>

<p>A single character string specifying the linetype of the arrows.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_arrow_linewidth">arrow_linewidth</code></td>
<td>

<p>A single number specifying the width of the arrows.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_arrow_alpha">arrow_alpha</code></td>
<td>

<p>A single number between 0 and 1 specifying the transparency level of the arrows.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_arrow_head_size">arrow_head_size</code></td>
<td>

<p>A single number specifying the size of the arrow heads. The unit for this size parameter can be changed using the <code>arrow_head_unit</code> argument.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_arrow_head_unit">arrow_head_unit</code></td>
<td>

<p>A single character string specifying the unit of the <code>arrow_head_size</code> argument.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_arrow_type">arrow_type</code></td>
<td>

<p>Either <code>"open"</code> or <code>"closed"</code>, which controls the type of head the arrows should have. See <code>?arrow</code>.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_arrow_node_dist">arrow_node_dist</code></td>
<td>

<p>A single positive number specifying the distance between nodes and the arrows. By setting this to values greater than 0 the arrows will not touch the node circles, leaving a bit of space instead.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_gg_theme">gg_theme</code></td>
<td>

<p>A <code>ggplot2</code> theme. By default this is set to <code>theme_void</code>, to get rid off everything but the plotted nodes (e.g. everything about the axis and the background). Might be useful to change this to something else when searching for good parameters of the number arguments of this function.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_include_td_nodes">include_td_nodes</code></td>
<td>

<p>Whether to include time-varying nodes added to the <code>dag</code> using the <code><a href="#topic+node_td">node_td</a></code> function or not. If one node is both specified as a time-fixed and time-varying node, it's parents in both calls will be pooled and it will be considered a time-varying node if this argument is <code>TRUE</code>. It will, however, also show up if it's argument is <code>FALSE</code>. In this case however, only the parents of that node in the standard <code><a href="#topic+node">node</a></code> call will be considered.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_mark_td_nodes">mark_td_nodes</code></td>
<td>

<p>Whether to distinguish time-varying and time-fixed nodes by <code>fill</code> color. If <code>TRUE</code>, the color will be set automatically using the standard <code>ggplot2</code> palette, ignoring the color specified in <code>node_fill</code>. Ignored if <code>include_td_nodes=FALSE</code> or if there are no time-varying variables.
</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_...">...</code></td>
<td>

<p>Currently not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <span class="pkg">igraph</span> package to find a suitable layout for the plot and then uses the <span class="pkg">ggplot2</span> package in conjunction with the <code>geom_circle</code> function of the <span class="pkg">ggforce</span> package to plot the directed acyclic graph defined by a <code>DAG</code> object. Since it returns a <code>ggplot</code> object, the user may use any standard <code>ggplot2</code> syntax to augment the plot or to save it using the <code>ggsave</code> function.
</p>
<p>Note that there are multiple great packages specifically designed to plot directed acyclic graphs, such as the <span class="pkg">igraph</span> package. This function is not meant to be a competitor to those packages. The functionality offered here is rather limited. It is designed to produce decent plots for small DAGs which are easy to create. If this function is not enough to create an adequate plot, users can use the <code><a href="#topic+dag2matrix">dag2matrix</a></code> function to obtain an adjacency matrix from the <code>DAG</code> object and directly use this matrix and the <span class="pkg">igraph</span> package (or similar ones) to get much better plots.
</p>
<p>If the <code>DAG</code> supplied to this function contains time-varying variables, the resulting plot may contain cycles or even bi-directional arrows, depending on the <code>DAG</code>. The reason for that is, that the time-dimension is not shown in the plot. Note also that even though, technically, every time-varying node has itself as a parent, no arrows showing this dependence will be added to the plot.
</p>


<h3>Value</h3>

<p>Returns a standard <code>ggplot2</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)
library(ggplot2)
library(igraph)
library(ggforce)

# 2 root nodes, 1 child node
dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("smoking", type="binomial", parents=c("sex", "age"), betas=c(1.1, 0.4),
       intercept=-2)

plot(dag)

# get plot using the igraph package instead
g1 &lt;- as.igraph(dag)
plot(g1)

# plot with a time-varying node
dag &lt;- dag +
  node_td("lottery", type="time_to_event", parents=c("age", "smoking"))

plot(dag)
</code></pre>

<hr>
<h2 id='plot.simDT'>
Create a Simple Flowchart for a Discrete-Time Simulation
</h2><span id='topic+plot.simDT'></span>

<h3>Description</h3>

<p>Given a <code>simDT</code> object obtained with the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function, plots a relatively simple flowchart of how the simulation was performed. Shows only some general information extracted from the <code>dag</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simDT'
plot(x, right_boxes=TRUE,
     box_hdist=1, box_vdist=1,
     box_l_width=0.35, box_l_height=0.23,
     box_r_width=box_l_width,
     box_r_height=box_l_height + 0.1,
     box_alpha=0.5, box_linetype="solid",
     box_linewidth=0.5, box_border_colors=NULL,
     box_fill_colors=NULL, box_text_color="black",
     box_text_alpha=1, box_text_angle=0,
     box_text_family="sans", box_text_fontface="plain",
     box_text_size=5, box_text_lineheight=1,
     box_1_text_left="Create initial data",
     box_1_text_right=NULL, box_2_text="Increase t by 1",
     box_l_node_labels=NULL, box_r_node_labels=NULL,
     box_last_text=paste0("t &lt;= ", x$max_t, "?"),
     arrow_line_type="solid", arrow_line_width=0.5,
     arrow_line_color="black", arrow_line_alpha=1,
     arrow_head_angle=30, arrow_head_size=0.3,
     arrow_head_unit="cm", arrow_head_type="closed",
     arrow_left_pad=0.3, hline_width=0.5,
     hline_type="dashed", hline_color="black",
     hline_alpha=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.simDT_+3A_x">x</code></td>
<td>

<p>A <code>simDT</code> object created using the <code>sim_discrete_time</code> function.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_right_boxes">right_boxes</code></td>
<td>

<p>Either <code>TRUE</code> (default) or <code>FALSE</code>, specifying whether to add boxes on the right with some additional information about the nodes on the left.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_hdist">box_hdist</code></td>
<td>

<p>A single positive number specifying the horizontal distance of the left and the right boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_vdist">box_vdist</code></td>
<td>

<p>A single positive number specifying the vertical distance of the boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_l_width">box_l_width</code></td>
<td>

<p>A single positive number specifying the width of the boxes on the left side.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_l_height">box_l_height</code></td>
<td>

<p>A single positive number specifying the height of the boxes on the left side.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_r_width">box_r_width</code></td>
<td>

<p>A single positive number specifying the width of the boxes on the right side. Ignored if <code>right_boxes=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_r_height">box_r_height</code></td>
<td>

<p>A single positive number specifying the height of the boxes on the right side. Ignored if <code>right_boxes=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_alpha">box_alpha</code></td>
<td>

<p>A single number between 0 and 1 specifying the transparency level of the boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_linetype">box_linetype</code></td>
<td>

<p>A single positive number specifying the linetype of the box outlines.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_linewidth">box_linewidth</code></td>
<td>

<p>A single positive number specifying the width of the box outlines.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_border_colors">box_border_colors</code></td>
<td>

<p>A character vector of length two specifying the colors of the box outlines. Set to <code>NULL</code> (default) to use <code>ggplot2</code> default colors.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_fill_colors">box_fill_colors</code></td>
<td>

<p>A character vector of length two specifying the colors of the inside of the boxes. Set to <code>NULL</code> (default) to use <code>ggplot2</code> default colors.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_text_color">box_text_color</code></td>
<td>

<p>A single character string specifying the color of the text inside the boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_text_alpha">box_text_alpha</code></td>
<td>

<p>A single number between 0 and 1 specifying the transparency level of the text inside the boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_text_angle">box_text_angle</code></td>
<td>

<p>A single positive number specifying the angle of the text inside the boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_text_family">box_text_family</code></td>
<td>

<p>A single character string specifying the family of the text inside the boxes. May be one of <code>"sans", "serif", "mono"</code>.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_text_fontface">box_text_fontface</code></td>
<td>

<p>A single character string specifying the fontface of the text inside the boxes. May be one of <code>"plain", "bold", "italic", "bold.italic"</code>.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_text_size">box_text_size</code></td>
<td>

<p>A single number specifying the size of the text inside the boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_text_lineheight">box_text_lineheight</code></td>
<td>

<p>A single number specifying the lineheight of the text inside the boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_1_text_left">box_1_text_left</code></td>
<td>

<p>A single character string specifying the text inside the first box from the top on the left side.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_1_text_right">box_1_text_right</code></td>
<td>

<p>A single character string specifying the text inside the first box from the top on the right side or <code>NULL</code>. If <code>NULL</code> (default) it will simply state which variables were generated at t = 0.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_2_text">box_2_text</code></td>
<td>

<p>A single character string specifying the text inside the second box from the top.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_l_node_labels">box_l_node_labels</code></td>
<td>

<p>A character vector with one entry for each time-varying node used in the simulation. These will be used to fill the boxes on the left side of the plot. Set to <code>NULL</code> to use default values.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_r_node_labels">box_r_node_labels</code></td>
<td>

<p>A character vector with one entry for each time-varying node used in the simulation. These will be used to fill the boxes on the right side of the plot. Set to <code>NULL</code> to use default values. Ignored if <code>right_boxes=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_box_last_text">box_last_text</code></td>
<td>

<p>A single character string specifying the text inside the last box on the left side. By default it uses the <code>max_t</code> argument from the initial function call to construct a fitting text.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_arrow_line_type">arrow_line_type</code></td>
<td>

<p>A single character string specifying the linetype of the arrows.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_arrow_line_width">arrow_line_width</code></td>
<td>

<p>A single positive number specifying the line width of the arrows.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_arrow_line_color">arrow_line_color</code></td>
<td>

<p>A single character string specifying the color of the arrows.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_arrow_line_alpha">arrow_line_alpha</code></td>
<td>

<p>A single number between 0 and 1 specifying the transparency level of the arrows.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_arrow_head_angle">arrow_head_angle</code></td>
<td>

<p>A single number specifying the angle of the arrow heads.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_arrow_head_size">arrow_head_size</code></td>
<td>

<p>A single number specifying the size of the arrow heads. The unit is defined by the <code>arrow_head_size</code> argument.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_arrow_head_unit">arrow_head_unit</code></td>
<td>

<p>A single character string specifying which unit to use when specifying the <code>arrow_head_size</code> argument. Defaults to <code>"cm"</code>.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_arrow_head_type">arrow_head_type</code></td>
<td>

<p>A single character string specifying which type of arrow head to use. See <code>?arrow</code> for more details.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_arrow_left_pad">arrow_left_pad</code></td>
<td>

<p>A single positive number specifying the distance between the left boxes and the arrow line to the left of it.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_hline_width">hline_width</code></td>
<td>

<p>A single number specifying the width of the horizontal lines between the left and right boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_hline_type">hline_type</code></td>
<td>

<p>A single character string specifying the linetype of the horizontal lines between the left and right boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_hline_color">hline_color</code></td>
<td>

<p>A single character string specifying the color of the horizontal lines between the left and right boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_hline_alpha">hline_alpha</code></td>
<td>

<p>A single number between 0 and 1 specifying the transparency level of the horizontal lines between the left and right boxes.
</p>
</td></tr>
<tr><td><code id="plot.simDT_+3A_...">...</code></td>
<td>

<p>Currently not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting flowchart includes two columns of boxes next to each other. On the left side it always starts with the same two boxes: a box about the creation of the initial data and a box about increasing the simulation time by 1. Next, there will be a box for each time-varying variable in the <code>simDT</code> object. Afterwards there is another box which asks if the maximum simulation time was reached. An arrow to the left that points back to the second box from the top indicates the iterative nature of the simulation process. The right column of boxes includes additional information about the boxes on the left.
</p>
<p>The text in all boxes may be changed to custom text by using the <code>box_1_text_left</code>, <code>box_1_text_right</code>, <code>box_2_text</code>, <code>box_l_node_labels</code>, <code>box_r_node_labels</code> and <code>box_last_text</code> arguments. It is also possible to completely remove the left line of boxes and to change various sizes and appearances. Although these are quite some options, it is still a rather fixed function in nature. One cannot add further boxes or arrows in a simple way. The general structure may also not be changed. It may be useful to visualize a general idea of the simulation flow, but it may be too limited for usage in scientific publications if the simulation is more complex.
</p>
<p>The graphic is created using the <code>ggplot2</code> package and the output is a standard <code>ggplot</code> object. This means that the user can change the result using standard <code>ggplot</code> syntax (adding more stuff, changing geoms, ...).
</p>


<h3>Value</h3>

<p>Returns a standard <code>ggplot</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(435345)

## exemplary car crash simulation, where the probability for
## a car crash is dependent on the sex, and the probability of death is
## highly increased for 3 days after a car crash happened
prob_car_crash &lt;- function(data) {
  ifelse(data$sex==1, 0.001, 0.01)
}

prob_death &lt;- function(data) {
  ifelse(data$car_crash_event, 0.1, 0.0001)
}

dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node_td("car_crash", type="time_to_event", prob_fun=prob_car_crash,
          parents="sex") +
  node_td("death", type="time_to_event", prob_fun=prob_death,
          parents="car_crash_event")

# generate some data
sim &lt;- sim_discrete_time(dag, n_sim=20, max_t=500, save_states="last")

# default plot
plot(sim)

# removing boxes on the right
plot(sim, right_boxes=FALSE)
</code></pre>

<hr>
<h2 id='rbernoulli'>
Generate Random Draws from a Bernoulli Distribution
</h2><span id='topic+rbernoulli'></span>

<h3>Description</h3>

<p>A very fast implementation for generating bernoulli trials. Can take a vector of probabilities which makes it very useful for simulation studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbernoulli(n, p=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbernoulli_+3A_n">n</code></td>
<td>

<p>How many draws to make.
</p>
</td></tr>
<tr><td><code id="rbernoulli_+3A_p">p</code></td>
<td>

<p>A numeric vector of probabilities, used when drawing the trials.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, it uses only a single call to <code>runif</code>, making it much faster and more memory efficient than using <code>rbinomial</code>.
</p>
<p>Note that this function accepts values of <code>p</code> that are smaller then 0 and greater than 1. For <code>p &lt; 0</code> it will always return <code>FALSE</code>, for <code>p &gt; 1</code> it will always return <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>Returns a logical vector of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

# generating 5 bernoulli random draws from an unbiased coin
rbernoulli(n=5, p=0.5)

# using different probabilities for each coin throw
rbernoulli(n=5, p=c(0.1, 0.2, 0.3, 0.2, 0.7))
</code></pre>

<hr>
<h2 id='rcategorical'>
Generate Random Draws from a Discrete Set of Labels with Associated Probabilities
</h2><span id='topic+rcategorical'></span>

<h3>Description</h3>

<p>Allows different class probabilities for each person by supplying a matrix with one column for each class and one row for each person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcategorical(n, probs, labels=NULL, coerce2factor=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcategorical_+3A_n">n</code></td>
<td>

<p>How many draws to make. Passed to the <code>size</code> argument of the <code>sample</code> function if <code>probs</code> is not a matrix.
</p>
</td></tr>
<tr><td><code id="rcategorical_+3A_probs">probs</code></td>
<td>

<p>Either a numeric vector of probabilities which sums to one or a matrix with one column for each desired class and <code>n</code> rows. Passed to the <code>probs</code> argument of the <code>sample</code> function if a numeric vector is passed.
</p>
</td></tr>
<tr><td><code id="rcategorical_+3A_labels">labels</code></td>
<td>

<p>A vector of labels to draw from. If <code>NULL</code> (default), it simply uses integers starting from 1. Passed to the <code>x</code> argument of the <code>sample</code> function if <code>probs</code> is not a matrix.
</p>
</td></tr>
<tr><td><code id="rcategorical_+3A_coerce2factor">coerce2factor</code></td>
<td>

<p>A single logical value specifying whether to return the drawn events as a factor or not.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of a simple numeric vector (class probabilities should be the same for all draws), this function is only a wrapper for the <code>sample</code> function, to make the code more consistent. It uses weighted sampling with replacement. Otherwise, custom code is used which is faster than the standard <code>rmultinom</code> function.
</p>


<h3>Value</h3>

<p>Returns a numeric vector (or factor vector if <code>coerce2factor=TRUE</code>) of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

rcategorical(n=5, labels=c("A", "B", "C"), probs=c(0.1, 0.2, 0.7))

rcategorical(n=2, probs=matrix(c(0.1, 0.2, 0.5, 0.7, 0.4, 0.1), nrow=2))
</code></pre>

<hr>
<h2 id='rconstant'>
Use a single constant value for a root node
</h2><span id='topic+rconstant'></span>

<h3>Description</h3>

<p>This is a small convenience function that simply returns the value passed to it, in order to allow the use of a constant node as root node in the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rconstant(n, constant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rconstant_+3A_n">n</code></td>
<td>

<p>The number of times the constant should be repeated.
</p>
</td></tr>
<tr><td><code id="rconstant_+3A_constant">constant</code></td>
<td>

<p>A single value of any kind which is used as the only value of the resulting variable.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of length <code>n</code> with the same type as <code>constant</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

rconstant(n=10, constant=7)

rconstant(n=4, constant="Male")
</code></pre>

<hr>
<h2 id='sim_discrete_time'>
Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information
</h2><span id='topic+sim_discrete_time'></span>

<h3>Description</h3>

<p>Similar to the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function, this function can be used to generate data from a given DAG. In contrast to the <code>sim_from_dag</code> function, this function utilizes a discrete-time simulation approach. This is not an &quot;off-the-shelves&quot; simulation function, it should rather be seen as a &quot;framework-function&quot;, making it easier to create discrete-time-simulations. It usually requires custom functions written by the user. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_discrete_time(dag, n_sim=NULL, t0_sort_dag=TRUE,
                  t0_data=NULL, t0_transform_fun=NULL,
                  t0_transform_args=list(), max_t,
                  tx_nodes_order=NULL, tx_transform_fun=NULL,
                  tx_transform_args=list(),
                  save_states="last", save_states_at=NULL,
                  verbose=FALSE, check_inputs=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_discrete_time_+3A_dag">dag</code></td>
<td>

<p>A <code>DAG</code> object created using the <code>empty_dag</code> function with <code>node_td</code> calls added to it (see details and examples). If the <code>dag</code> contains root nodes and child nodes which are time-fixed (those who were added using <code>node</code> calls), data according to this DAG will be generated for time = 0. That data will then be used as starting data for the following simulation. Alternatively, the user can specify the <code>t0_data</code> argument directly. In either case, the supplied <code>dag</code> needs to contain at least one time-dependent node added using the <code>node_td</code> function.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_n_sim">n_sim</code></td>
<td>

<p>A single number specifying how many observations should be generated. If a <code>data.table</code> is supplied to the <code>t0_data</code> argument, this argument is ignored. The sample size will then correspond to the number of rows in <code>t0_data</code>.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_t0_sort_dag">t0_sort_dag</code></td>
<td>

<p>Corresponds to the <code>sort_dag</code> argument in the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function. Ignored if <code>t0_data</code> is specified.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_t0_data">t0_data</code></td>
<td>

<p>An optional <code>data.table</code> like object (also accepts a <code>data.frame</code>, <code>tibble</code> etc.) containing values for all relevant variables at <code class="reqn">t = 0</code>. This dataset will then be transformed over time according to the node functions specified in <code>tx_nodes</code>. Alternatively, data for <code class="reqn">t = 0</code> may be generated automatically by this function if standard <code><a href="#topic+node">node</a></code> calls were added to the <code>dag</code>.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_t0_transform_fun">t0_transform_fun</code></td>
<td>

<p>An optional function that takes the data created at <code class="reqn">t = 0</code> as the first argument. The function will be applied to the starting data and its output will replace the <code>data.table</code>. Can be used to perform arbitrary data transformations after the starting data was created. Set to <code>NULL</code> (default) to not use this functionality.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_t0_transform_args">t0_transform_args</code></td>
<td>

<p>A named list of additional arguments passed to the <code>t0_transform_fun</code>. Ignored if <code>t0_transform_fun=NULL</code>.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_max_t">max_t</code></td>
<td>

<p>A single integer specifying the final point in time to which the simulation should be carried out. The simulation will start at <code class="reqn">t = 1</code> (after creating the starting data with the arguments above) and will continue until <code>max_t</code> by increasing the time by one unit at every step, updating the time-dependent nodes along the way.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_tx_nodes_order">tx_nodes_order</code></td>
<td>

<p>A numeric vector specifying the order in which the time-dependent nodes added to the <code>dag</code> object using the <code><a href="#topic+node_td">node_td</a></code> function should be executed at each time step. If <code>NULL</code> (default), the nodes will be generated in the order in which they were originally added.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_tx_transform_fun">tx_transform_fun</code></td>
<td>

<p>An optional function that takes the data created after every point in time  <code class="reqn">t &gt; 0</code> as the first argument and the simulation time as the second argument. The function will be applied to that data after all node functions at that point in time have been executed and its output will replace the previous <code>data.table</code>. Can be used to perform arbitrary data transformations at every point in time. Set to <code>NULL</code> (default) to not use this functionality.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_tx_transform_args">tx_transform_args</code></td>
<td>

<p>A named list of additional arguments passed to the <code>tx_transform_fun</code>. Ignored if <code>tx_transform_fun=NULL</code>.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_save_states">save_states</code></td>
<td>

<p>Specifies the amount of simulation states that should be saved in the output object. Has to be one of <code>"all"</code>, <code>"at_t"</code> or <code>"last"</code> (default). If set to <code>"all"</code>, a list of containing the <code>data.table</code> after every point in time will be added to the output object. If <code>"at_t"</code>, only the states at specific points in time specified by the <code>save_states_at</code> argument will be saved (plus the final state). If <code>"last"</code>, only the final state of the <code>data.table</code> is added to the output.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_save_states_at">save_states_at</code></td>
<td>

<p>The specific points in time at which the simulated <code>data.table</code> should be saved. Ignored if <code>save_states!="at_t"</code>.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code> prints one line at every point in time before a node function is executed. This can be useful when debugging custom node functions. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="sim_discrete_time_+3A_check_inputs">check_inputs</code></td>
<td>

<p>Whether to perform plausibility checks for the user input or not. Is set to <code>TRUE</code> by default, but can be set to <code>FALSE</code> in order to speed things up when using this function in a simulation study or something similar.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes it is necessary to simulate complex data that cannot be described easily with a single DAG and node information. This may be the case if the desired data should contain multiple time-dependent variables or time-to-event variables in which the event has time-dependent effects on other events. An example for this is data on vaccinations and their effects on the occurrence of adverse events (see vignette). Discrete-Time Simulation can be an effective tool to generate these kinds of datasets.
</p>
<p><strong><em>What is Discrete-Time Simulation?</em></strong>:
</p>
<p>In a discrete-time simulation, there are entities who have certain states associated with them that only change at discrete points in time. For example, the entities could be people and the state could be alive or dead. In this example we could generate 100 people with some covariates such as age, sex etc.. We then start by increasing the simulation time by one day. For each person we now check if the person has died using a bernoulli trial, where the probability of dying is generated at each point in time based on some of the covariates. The simulation time is then increased again and the process is repeated until we reach <code>max_t</code>.
</p>
<p>Due to the iterative process it is very easy to simulate arbitrarily complex data. The covariates may change over time in arbitrary ways, the event probability can have any functional relationship with the covariates and so on. If we want to model an event type that is not terminal, such as occurrence of cardiovascular disease, events can easily be simulated to be dependent on the timing and number of previous events. Since Discrete-Time Simulation is a special case of Discrete-Event Simulation, introductory textbooks on the latter can be of great help in getting a better understanding of the former.
</p>
<p><strong><em>How it Works</em></strong>:
</p>
<p>Internally, this function works by first simulating data using the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function. Alternatively, the user can supply a custom <code>data.table</code> using the <code>t0_data</code> argument. This data defines the state of all entities at <code class="reqn">t = 0</code>. Afterwards, the simulation time is increased by one unit and the data is transformed in place by calling each node function defined by the time-dependent nodes which were added to the <code>dag</code> using the <code><a href="#topic+node_td">node_td</a></code> function (either in the order in which they were added to the <code>dag</code> object or by the order defined by the <code>tx_nodes_order</code> argument). Usually, each transformation changes the state of the entities in some way. For example if there is an <code>age</code> variable, we would probably increase the age of each person by one time unit at every step. Once <code>max_t</code> is reached, the resulting <code>data.table</code> will be returned. It contains the state of all entities at the last step with additional information of when they experienced some events (if <code><a href="#topic+node_time_to_event">node_time_to_event</a></code> was used as time-dependent node). Multiple in-depth examples can be found in the vignettes of this package.
</p>
<p><strong><em>Specifying the <code>dag</code> argument</em></strong>:
</p>
<p>The <code>dag</code> argument should be specified as described in the <code><a href="#topic+node">node</a></code> documentation page. More examples specific to discrete-time simulations can be found in the vignettes and the examples. The only difference to specifying a <code>dag</code> for the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function is that the <code>dag</code> here should contain at least one time-dependent node added using the <code><a href="#topic+node_td">node_td</a></code> function.
</p>
<p><strong><em>Speed Considerations</em></strong>:
</p>
<p>All functions in this package rely on the <code>data.table</code> backend in order to make them more memory efficient and faster. It is however important to note that the time to simulate a dataset increases non-linearly with an increasing <code>max_t</code> value and additional time-dependent nodes. This is usually not a concern for smaller datasets, but if <code>n_sim</code> is very large (say &gt; 1 million) this function will get rather slow.
</p>
<p><strong><em>What do I do with the output?</em></strong>:
</p>
<p>This function outputs a <code>simDT</code> object, not a <code>data.table</code>. To obtain an actual dataset from the output of this function, users should use the <code><a href="#topic+sim2data">sim2data</a></code> function to transform it into the desired format. Currently, the long-format, the wide-format and the start-stop format are supported. See <code><a href="#topic+sim2data">sim2data</a></code> for more information.
</p>
<p><strong><em>A Few Words of Caution</em></strong>:
</p>
<p>In most cases it will be necessary for the user to write their own functions in order to actually use the <code>sim_discrete_time</code> function. Unlike the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function, in which many popular node types can be implemented in a re-usable way, discrete-time simulation will always require some custom input by the user. This is the price users have to pay for the almost unlimited flexibility offered by this simulation methodology.
</p>


<h3>Value</h3>

<p>Returns a <code>simDT</code> object, containing some general information about the simulated data as well as the final state of the simulated dataset (and more states, depending on the specification of the <code>save_states</code> argument). In particular, it includes the following objects:
</p>

<ul>
<li><p><code>past_states</code>: A list containing the generated data at the specified points in time.
</p>
</li>
<li><p><code>save_states</code>: The value of the <code>save_states</code> argument supplied by the user.
</p>
</li>
<li><p><code>data</code>: The data at time <code>max_t</code>.
</p>
</li>
<li><p><code>tte_past_events</code>: A list storing the times at which events happened in variables of type <code>"time_to_event"</code>, if specified.
</p>
</li>
<li><p><code>ce_past_events</code>: A list storing the times at which events happened in variables of type <code>"competing_events"</code>, if specified.
</p>
</li>
<li><p><code>ce_past_causes</code>: A list storing the types of events which happened at in variables of type <code>"competing_events"</code>, if specified.
</p>
</li>
<li><p><code>tx_nodes</code>: A list of all time-varying nodes, as specified in the supplied <code>dag</code> object.
</p>
</li>
<li><p><code>max_t</code>: The value of <code>max_t</code>, as supplied by the user.
</p>
</li>
<li><p><code>t0_var_names</code>: A character vector containing the names of all variable names that do not vary over time.
</p>
</li></ul>

<p>To obtain a single dataset from this function that can be processed further, please use the <code><a href="#topic+sim2data">sim2data</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Robin Denz, Katharina Meiszl
</p>


<h3>References</h3>

<p>Tang, Jiangjun, George Leu, und Hussein A. Abbass. 2020. Simulation and Computational Red Teaming for Problem Solving. Hoboken: IEEE Press.
</p>
<p>Banks, Jerry, John S. Carson II, Barry L. Nelson, and David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim2data">sim2data</a></code>, <code><a href="#topic+plot.simDT">plot.simDT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(454236)

## simulating death dependent on age, sex, bmi
## NOTE: this example is explained in detail in one of the vignettes

# initializing a DAG with nodes for generating data at t0
dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("bmi", type="gaussian", parents=c("sex", "age"),
       betas=c(1.1, 0.4), intercept=12, error=2)

# a function that increases age as time goes on
node_advance_age &lt;- function(data) {
  return(data$age + 1/365)
}

# a function to calculate the probability of death as a
# linear combination of age, sex and bmi on the log scale
prob_death &lt;- function(data, beta_age, beta_sex, beta_bmi, intercept) {
  prob &lt;- intercept + data$age*beta_age + data$sex*beta_sex + data$bmi*beta_bmi
  prob &lt;- 1/(1 + exp(-prob))
  return(prob)
}

# adding time-dependent nodes to the dag
dag &lt;- dag +
  node_td("age", type="advance_age", parents="age") +
  node_td("death", type="time_to_event", parents=c("age", "sex", "bmi"),
          prob_fun=prob_death, beta_age=0.1, beta_bmi=0.3, beta_sex=-0.2,
          intercept=-20, event_duration=Inf, save_past_events=FALSE)

# run simulation for 100 people, 50 days long
sim_dt &lt;- sim_discrete_time(n_sim=100,
                            dag=dag,
                            max_t=50,
                            verbose=FALSE)
</code></pre>

<hr>
<h2 id='sim_from_dag'>
Simulate Data from a Given DAG and Node Information
</h2><span id='topic+sim_from_dag'></span>

<h3>Description</h3>

<p>This function can be used to generate data from a given DAG. It additionally requires information on node distributions, beta coefficients and, depending on the node type, more parameters such as intercepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_from_dag(dag, n_sim, sort_dag=TRUE, check_inputs=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_from_dag_+3A_dag">dag</code></td>
<td>

<p>A <code>DAG</code> object created using the <code><a href="#topic+empty_dag">empty_dag</a></code> function with nodes added to it using the <code>+</code> syntax. See details.
</p>
</td></tr>
<tr><td><code id="sim_from_dag_+3A_n_sim">n_sim</code></td>
<td>

<p>A single number specifying how many observations should be generated.
</p>
</td></tr>
<tr><td><code id="sim_from_dag_+3A_sort_dag">sort_dag</code></td>
<td>

<p>Whether to topologically sort the DAG before starting the simulation or not. If the nodes in <code>dag</code> were already added in a topologically sorted manner, this argument can be set to <code>FALSE</code> to safe some computation time. This usually won't safe too much time though, because it internally uses the <code>topological_sort</code> function from the <span class="pkg">Rfast</span> package, which is very fast.
</p>
</td></tr>
<tr><td><code id="sim_from_dag_+3A_check_inputs">check_inputs</code></td>
<td>

<p>Whether to perform plausibility checks for the user input or not. Is set to <code>TRUE</code> by default, but can be set to <code>FALSE</code> in order to speed things up when using this function in a simulation study or something similar.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong><em>How it Works</em></strong>:
</p>
<p>First, <code>n_sim</code> i.i.d. samples from the root nodes are drawn. Children of these nodes are then generated one by one according to specified relationships and causal coefficients. For example, lets suppose there are two root nodes, <code>age</code> and <code>sex</code>. Those are generated from a normal distribution and a bernoulli distribution respectively. Afterward, the child node <code>height</code> is generated using both of these variables as parents according to a linear regression with defined coefficients, intercept and sigma (random error). This works because every DAG has at least one topological ordering, which is a linear ordering of vertices such that for every directed edge <code class="reqn">u</code> <code class="reqn">v</code>, vertex <code class="reqn">u</code> comes before <code class="reqn">v</code> in the ordering. By using <code>sort_dag=TRUE</code> it is ensured that the nodes are processed in such an ordering.
</p>
<p>This procedure is simple in theory, but can get very complex when manually coded. This function offers a simplified workflow by only requiring the user to define the <code>dag</code> object with appropriate information (see documentation of <code><a href="#topic+node">node</a></code> function). A sample of size <code>n_sim</code> is then generated from the DAG specified by those two arguments.
</p>
<p><strong><em>Specifying the DAG</em></strong>:
</p>
<p>Concrete details on how to specify the needed <code>dag</code> object are given in the documentation page of the <code><a href="#topic+node">node</a></code> function and in the vignettes of this package.
</p>
<p><strong><em>Can this function create longitudinal data?</em></strong>
</p>
<p>Yes and no. It theoretically can, but only if the user-specified <code>dag</code> directly specifies a node for each desired point in time. Using the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> is better in some cases. A brief discussion about this topic can be found in the vignettes of this package.
</p>
<p>If time-dependent nodes were added to the <code>dag</code> using <code><a href="#topic+node_td">node_td</a></code> calls, this function may not be used. Only the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function will work in that case.
</p>


<h3>Value</h3>

<p>Returns a single <code>data.table</code> including the simulated data with (at least) one column per node specified in <code>dag</code> and <code>n_sim</code> rows.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+plot.DAG">plot.DAG</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(345345)

dag &lt;- empty_dag() +
  node("age", type="rnorm", mean=50, sd=4) +
  node("sex", type="rbernoulli", p=0.5) +
  node("bmi", type="gaussian", parents=c("sex", "age"),
       betas=c(1.1, 0.4), intercept=12, error=2)

sim_dat &lt;- sim_from_dag(dag=dag, n_sim=1000)

# More examples for each directly supported node type as well as for custom
# nodes can be found in the documentation page of the respective node function
</code></pre>

<hr>
<h2 id='sim_n_datasets'>
Generate multiple datasets from a single <code>DAG</code> object
</h2><span id='topic+sim_n_datasets'></span>

<h3>Description</h3>

<p>This function takes a single <code>DAG</code> object and generates a list of multiple datasets, possible using parallel processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_n_datasets(dag, n_sim, n_repeats, n_cores=parallel::detectCores(),
               data_format="raw", data_format_args=list(),
               seed=stats::runif(1), progressbar=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_n_datasets_+3A_dag">dag</code></td>
<td>

<p>A <code>DAG</code> object created using the <code><a href="#topic+empty_dag">empty_dag</a></code> function with nodes added to it using the <code>+</code> syntax. See <code>?empty_dag</code> or <code>?node</code> for more details. If the <code>dag</code> contains time-varying nodes added using the <code><a href="#topic+node_td">node_td</a></code> function, the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function will be used to generate the data. Otherwise, the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function will be used.
</p>
</td></tr>
<tr><td><code id="sim_n_datasets_+3A_n_sim">n_sim</code></td>
<td>

<p>A single number specifying how many observations per dataset should be generated.
</p>
</td></tr>
<tr><td><code id="sim_n_datasets_+3A_n_repeats">n_repeats</code></td>
<td>

<p>A single number specifying how many datasets should be generated.
</p>
</td></tr>
<tr><td><code id="sim_n_datasets_+3A_n_cores">n_cores</code></td>
<td>

<p>A single number specifying the amount of cores that should be used. If <code>n_cores = 1</code>, a simple for loop is used to generate the datasets with no parallel processing. If <code>n_cores &gt; 1</code> is used, the <span class="pkg">doSNOW</span> package is used in conjunction with the <span class="pkg">doRNG</span> package to generate the datasets in parallel. By using the <span class="pkg">doRNG</span> package, the results are completely reproducible by setting a <code>seed</code>.
</p>
</td></tr>
<tr><td><code id="sim_n_datasets_+3A_data_format">data_format</code></td>
<td>

<p>An optional character string specifying the output format of the generated datasets. If <code>"raw"</code> (default), the dataset will be returned as generated by the respective data generation function. If the <code>dag</code> contains time-varying nodes added using the <code><a href="#topic+node_td">node_td</a></code> function and this argument is set to either <code>"start_stop"</code>, <code>"long"</code> or <code>"wide"</code>, the <code><a href="#topic+sim2data">sim2data</a></code> function will be called to transform the dataset into the defined format. If any other string is supplied, regardless of whether time-varying nodes are included in the <code>dag</code> or not, the function with the name given in the string is called to transform the data. This can be any function. The only requirement is that it has a named argument called <code>data</code>. Arguments to the function can be set using the <code>data_format_args</code> argument (see below).
</p>
</td></tr>
<tr><td><code id="sim_n_datasets_+3A_data_format_args">data_format_args</code></td>
<td>

<p>An optional list of named arguments passed to the function specified by <code>data_format</code>. Set to <code>list()</code> to use no arguments. Ignored if <code>data_format="raw"</code>.
</p>
</td></tr>
<tr><td><code id="sim_n_datasets_+3A_seed">seed</code></td>
<td>

<p>A seed for the random number generator. By supplying a value to this argument, the results will be replicable, even if parallel processing is used to generate the datasets (using <code>n_cores &gt; 1</code>), thanks to the magic performed by the <span class="pkg">doRNG</span> package.
</p>
</td></tr>
<tr><td><code id="sim_n_datasets_+3A_progressbar">progressbar</code></td>
<td>

<p>Either <code>TRUE</code> (default) or <code>FALSE</code>, specifying whether a progressbar should be used. Currently only works if <code>n_cores &gt; 1</code>, ignored otherwise.
</p>
</td></tr>
<tr><td><code id="sim_n_datasets_+3A_...">...</code></td>
<td>

<p>Further arguments passed to the <code><a href="#topic+sim_from_dag">sim_from_dag</a></code> function (if the <code>dag</code> does not contain time-varying nodes) or the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function (if the <code>dag</code> contains time-varying nodes).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generating a number of datasets from a single defined <code>dag</code> object is usually the first step when conducting monte-carlo simulation studies. This is simply a convenience function which automates this process using parallel processing (if specified).
</p>
<p>Note that for more complex monte-carlo simulations this function may not be ideal, because it does not allow the user to vary aspects of the data-generation mechanism inside the main for loop, because it can only handle a single <code>dag</code>. For example, if the user wants to simulate <code>n_repeats</code> datasets with confounding and <code>n_repeats</code> datasets without confounding, he/she has to call this function twice. This is not optimal, because setting up the clusters for parallel processing takes some processing time. If many different <code>dag</code>s should be used, it would make more sense to write a single function that generates the <code>dag</code> itself for each of the desired settings. This can sadly not be automated by us though.
</p>


<h3>Value</h3>

<p>Returns a list of length <code>n_repeats</code> containing datasets generated according to the supplied <code>dag</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_dag">empty_dag</a></code>, <code><a href="#topic+node">node</a></code>, <code><a href="#topic+node_td">node_td</a></code>, <code><a href="#topic+sim_from_dag">sim_from_dag</a></code>, <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>, <code><a href="#topic+sim2data">sim2data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

# some example DAG
dag &lt;- empty_dag() +
  node("death", type="binomial", parents=c("age", "sex"), betas=c(1, 2),
       intercept=-10) +
  node("age", type="rnorm", mean=10, sd=2) +
  node("sex", parents="", type="rbernoulli", p=0.5) +
  node("smoking", parents=c("sex", "age"), type="binomial",
       betas=c(0.6, 0.2), intercept=-2)

# generate 10 datasets without parallel processing
out &lt;- sim_n_datasets(dag, n_repeats=10, n_cores=1, n_sim=100)

# generate 10 datasets with parallel processing
out &lt;- sim_n_datasets(dag, n_repeats=10, n_cores=2, n_sim=100)

# generate 10 datasets and transforming the output
# (using the sim2data function internally)
dag &lt;- dag + node_td("CV", type="time_to_event", prob_fun=0.01)
out &lt;- sim_n_datasets(dag, n_repeats=10, n_cores=1, n_sim=100,
                      max_t=20, data_format="start_stop")
</code></pre>

<hr>
<h2 id='sim2data'>
Transform <code>sim_discrete_time</code> output into the start-stop, long- or wide-format
</h2><span id='topic+sim2data'></span><span id='topic+as.data.table.simDT'></span><span id='topic+as.data.frame.simDT'></span>

<h3>Description</h3>

<p>This function transforms the output of the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function into a single <code>data.table</code> structured in the start-stop format (also known as counting process format), the long format (one row per person per point in time) or the wide format (one row per person, one column per point in time for time-varying variables). See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim2data(sim, to, use_saved_states=sim$save_states=="all",
         overlap=FALSE, target_event=NULL,
         keep_only_first=FALSE, as_data_frame=FALSE,
         check_inputs=TRUE, ...)

## S3 method for class 'simDT'
as.data.table(x, keep.rownames=FALSE, to, overlap=FALSE,
              target_event=NULL, keep_only_first=FALSE,
              use_saved_states=x$save_states=="all",
              check_inputs=TRUE, ...)

## S3 method for class 'simDT'
as.data.frame(x, row.names=NULL, optional=FALSE, to,
              overlap=FALSE, target_event=NULL,
              keep_only_first=FALSE,
              use_saved_states=x$save_states=="all",
              check_inputs=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim2data_+3A_sim">sim</code>, <code id="sim2data_+3A_x">x</code></td>
<td>

<p>An object created with the <code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code> function.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_to">to</code></td>
<td>

<p>Specifies the format of the output data. Must be one of: <code>"start_stop"</code>, <code>"long"</code>, <code>"wide"</code>.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_use_saved_states">use_saved_states</code></td>
<td>

<p>Whether the saved simulation states (argument <code>save_states</code> in <code>sim_discrete_time</code> function) should be used to construct the resulting data or not. See details.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_overlap">overlap</code></td>
<td>

<p>Only used when <code>to="start_stop"</code>. Specifies whether the intervals should overlap or not. If <code>TRUE</code>, the <code>"stop"</code> column is simply increased by one, as compared to the output when <code>overlap=FALSE</code>. This means that changes for a given <code class="reqn">t</code> are recorded at the start of the next interval, but the previous interval ends on that same day.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_target_event">target_event</code></td>
<td>

<p>Only used when <code>to="start_stop"</code>. By default (keeping this argument at <code>NULL</code>) all time-to-event nodes are treated equally when creating the start-stop intervals. This can be changed by supplying a single character string to this argument, naming one time-to-event node. This node will then be treated as the outcome. The output then corresponds to what would be needed to fit a Cox proportional hazards model. See details.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_keep_only_first">keep_only_first</code></td>
<td>

<p>Only used when <code>to="start_stop"</code> and <code>target_event</code> is not <code>NULL</code>. Either <code>TRUE</code> or <code>FALSE</code> (default). If <code>TRUE</code>, all information after the first event per person will be discarded. Useful when <code>target_event</code> should be treated as a terminal variable.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_as_data_frame">as_data_frame</code></td>
<td>

<p>Set this argument to <code>TRUE</code> to return a <code>data.frame</code> instead of a <code>data.table</code>.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_check_inputs">check_inputs</code></td>
<td>

<p>Whether to perform input checks (<code>TRUE</code> by default). Prints warning messages if the output may be incorrect due to missing information.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_keep.rownames">keep.rownames</code></td>
<td>

<p>Currently not used.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_row.names">row.names</code></td>
<td>

<p>Passed to the <code>as.data.frame</code> function which is called on the finished <code>data.table</code>. See <code>?as.data.frame</code> for more information.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_optional">optional</code></td>
<td>

<p>Passed to the <code>as.data.frame</code> function which is called on the finished <code>data.table</code>. See <code>?as.data.frame</code> for more information.
</p>
</td></tr>
<tr><td><code id="sim2data_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code>as.data.frame</code> (conversion from finished <code>data.table</code> to <code>data.frame</code>). Only available when directly calling <code>sim2data</code> with <code>as_data_frame=TRUE</code> or when using <code>as.data.frame.simDT</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw output of the <code>sim_discrete_time</code> function may be difficult to use for further analysis. Using one of these functions, it is straightforward to transform that output into three different formats, which are described below. Note that some caution needs to be applied when using this function, which is also described below. Both <code>as.data.table</code> and <code>as.data.frame</code> internally call <code>sim2data</code> and only exist for user convenience.
</p>
<p><strong><em>The start-stop format</em>:</strong>
</p>
<p>The start-stop format (<code>to="start_stop"</code>), also known as counting process or period format corresponds to a <code>data.table</code> containing multiple rows per person, where each row corresponds to a period of time in which no variables changed. These intervals are defined by the <code>start</code> and <code>stop</code> columns. The <code>start</code> column gives the time at which the period started, the <code>stop</code> column denotes the time when the period ended. By default these intervals are coded to be non-overlapping, meaning that the edges of the periods are included in the period itself. For example, if the respective period is exactly 1 point in time long, <code>start</code> will be equal to <code>stop</code>. If non-overlapping periods are desired, the user can specify <code>overlap=TRUE</code> instead.
</p>
<p>By default, all time-to-event nodes are treated equally. This is not optimal when the goal is to fit survival regression models. In this case, we usually want the target event to be treated in a special way (see for example Chiou et al. 2023). In general, instead of creating new intervals for it we want existing intervals to end at event times with the corresponding event indicator. This can be achieved by naming the target outcome in the <code>target_event</code> variable. The previously specified duration of this target event is then ignored. If only the first occurrence of the event is of interest, users may also set <code>keep_only_first=TRUE</code> to keep only information up until the first event per person.
</p>
<p><strong><em>The long format</em>:</strong>
</p>
<p>The long format (<code>to="long"</code>) corresponds to a <code>data.table</code> in which there is one row per person per point in time. The unique person identifier is stored in the <code>.id</code> column and the unique points in time are given in the <code>.time</code> column.
</p>
<p><strong><em>The wide format</em>:</strong>
</p>
<p>The wide format (<code>to="wide"</code>) corresponds to a <code>data.table</code> with exactly one row per person and multiple columns per points in time for each time-varying variable. All time-varying variables are coded as their original variable name with an underscore and the time-point appended to the end. For example, the variable <code>sickness</code> at time-point 3 is named <code>"sickness_3"</code>.
</p>
<p><strong><em>Output with <code>use_saved_states=TRUE</code></em>:</strong>
</p>
<p>If <code>use_saved_states=TRUE</code>, this function will use only the data that is stored in the <code>past_states</code> list of the <code>sim</code> object to construct the resulting <code>data.table</code>. This results in the following behavior, depending on which <code>save_states</code> option was used in the original <code>sim_discrete_time</code> function call:
</p>

<ul>
<li><p><code>save_states="all"</code>: A complete <code>data.table</code> in the desired format with information for <strong>all observations</strong> at <strong>all points in time</strong> for <strong>all variables</strong> will be created. This is the safest option, but also uses the most RAM and computational time.
</p>
</li>
<li><p><code>save_states="at_t"</code>: A <code>data.table</code> in the desired format with correct information for <strong>all observations</strong> at the <strong>user specified times</strong> (<code>save_states_at</code> argument) for <strong>all variables</strong> will be created. The state of the simulation at all other times will be ignored, because it wasn't stored. This may be useful in some scenarios, but is generally discouraged unless you have good reasons to use it. A warning message about this is printed if <code>check_inputs=TRUE</code>.
</p>
</li>
<li><p><code>save_states="last"</code>: Since only the last state of the simulation was saved, an error message is returned. <strong>No</strong> <code>data.table</code> is produced.
</p>
</li></ul>

<p><strong><em>Output with <code>use_saved_states=FALSE</code></em>:</strong>
</p>
<p>If <code>use_saved_states=FALSE</code>, this function will use only the data that is stored in the final state of the simulation (<code>data</code> object in <code>sim</code>) and information about <code>node_time_to_event</code> objects. If all <code>tx_nodes</code> are <code>time_to_event</code> nodes or if all the user cares about are the <code>time_to_event</code> nodes and time-fixed variables, this is the best option.
</p>
<p>A <code>data.table</code> in the desired format with correct information about <code>all observations</code> at <code>all times</code> is produced, but only with correct entries for <strong>some time-varying variables</strong>, namely <code>time_to_event</code> nodes. Note that this information will also only be correct if the user used <code>save_past_events=TRUE</code> in all <code>time_to_event</code> nodes. Support for <code>competing_events</code> nodes will be implemented in the future as well.
</p>
<p>The other time-varying variables specified in the <code>tx_nodes</code> argument will still appear in the output, but it will only be the value that was observed at the last state of the simulation.
</p>
<p><strong><em>Optional columns created using a <code>time_to_event</code> node</em>:</strong>
</p>
<p>When using a time-dependent node of type <code>"time_to_event"</code> with <code>event_count=TRUE</code> or <code>time_since_last=TRUE</code>, the columns created using either argument are <strong>not</strong> included in the output if <code>to="start_stop"</code>, but will be included if <code>to</code> is set to either <code>"long"</code> or <code>"wide"</code>. The reason for this behavior is that including these columns would lead to nonsense intervals in the start-stop format, but makes sense in the other formats.
</p>
<p><strong><em>What about <code>tx_nodes</code> that are not <code>time_to_event</code> nodes?</em>:</strong>
</p>
<p>If you want the correct output for all <code>tx_nodes</code> and one or more of those are not <code>time_to_event</code> nodes, you will have to use <code>save_states="all"</code> in the original <code>sim_discrete_time</code> call. We plan to add support for <code>competing_events</code> with other <code>save_states</code> arguments in the near future. Support for arbitrary <code>tx_nodes</code> will probably take longer.
</p>


<h3>Value</h3>

<p>Returns a single <code>data.table</code> (or <code>data.frame</code>) containing all simulated variables in the desired format.
</p>


<h3>Note</h3>

<p>Using the node names <code>"start"</code>, <code>"stop"</code>, <code>".id"</code>, <code>".time"</code> or names that are automatically generated by time-dependent nodes of type <code>"time_to_event"</code> may break this function.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>References</h3>

<p>Sy Han Chiou, Gongjun Xu, Jun Yan, and Chiung-Yu Huang (2023). &quot;Regression Modeling for Recurrent Events Possibly with an Informative Terminal Event Using R Package reReg&quot;. In: Journal of Statistical Software. 105.5, pp. 1-34.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_discrete_time">sim_discrete_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simDAG)

set.seed(435345)

## exemplary car crash simulation, where the probability for
## a car crash is dependent on the sex, and the probability of death is
## highly increased for 3 days after a car crash happened
prob_car_crash &lt;- function(data) {
  ifelse(data$sex==1, 0.001, 0.01)
}

prob_death &lt;- function(data) {
  ifelse(data$car_crash_event, 0.1, 0.001)
}

dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node_td("car_crash", type="time_to_event", prob_fun=prob_car_crash,
          parents="sex", event_duration=3) +
  node_td("death", type="time_to_event", prob_fun=prob_death,
          parents="car_crash_event", event_duration=Inf)

# generate some data, only saving the last state
# not a problem here, because the only time-varying nodes are
# time-to-event nodes where the event times are saved
sim &lt;- sim_discrete_time(dag, n_sim=20, max_t=500, save_states="last")

# transform to standard start-stop format
d_start_stop &lt;- sim2data(sim, to="start_stop")
head(d_start_stop)

# transform to "death" centric start-stop format
# and keep only information until death, cause it's a terminal event
# (this could be used in a Cox model)
d_start_stop &lt;- sim2data(sim, to="start_stop", target_event="death",
                         keep_only_first=TRUE, overlap=TRUE)
head(d_start_stop)

# transform to long-format
d_long &lt;- sim2data(sim, to="long")
head(d_long)

# transform to wide-format
d_wide &lt;- sim2data(sim, to="wide")
#head(d_wide)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
