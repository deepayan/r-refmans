<!DOCTYPE html><html><head><title>Help for package rmumps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmumps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rmumps-package'>
<p>Rcpp port of MUMPS library for LU or LDL^t factorization of sparse matrices</p></a></li>
<li><a href='#Rcpp_Rmumps-class'>
<p>Rcpp Exported Class Wrapping MUMPS library</p></a></li>
<li><a href='#Rmumps__del_ptr'><p>Delete via Pointer</p></a></li>
<li><a href='#Rmumps__get_permutation'><p>Get Permutation Parameter</p></a></li>
<li><a href='#Rmumps__ptr_ijv'><p>Construct via Triplet Pointers</p></a></li>
<li><a href='#Rmumps__set_mat_ptr'><p>Set Matrix via Pointer</p></a></li>
<li><a href='#Rmumps__set_permutation'><p>Set Permutation Parameter</p></a></li>
<li><a href='#Rmumps__solveptr'><p>Solve via Pointer</p></a></li>
<li><a href='#Rmumps__triplet'><p>Explore via Triplet</p></a></li>
<li><a href='#RMUMPS_PERM'><p>Exported Constants</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wrapper for MUMPS Library</td>
</tr>
<tr>
<td>Version:</td>
<td>5.2.1-29</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-29</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Serguei Sokol &lt;sokol@insa-toulouse.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Some basic features of 'MUMPS' (Multifrontal Massively Parallel
         sparse direct Solver) are wrapped in a class whose methods can be used
         for sequentially solving a sparse linear system (symmetric or not)
         with one or many right hand sides (dense or sparse).
         There is a possibility to do separately symbolic analysis,
         LU (or LDL^t) factorization and system solving.
         Third part ordering libraries are included and can be used: 'PORD', 'METIS', 'SCOTCH'.
         'MUMPS' method was first described in Amestoy et al. (2001) &lt;<a href="https://doi.org/10.1137%2FS0895479899358194">doi:10.1137/S0895479899358194</a>&gt;
         and Amestoy et al. (2006) &lt;<a href="https://doi.org/10.1016%2Fj.parco.2005.07.004">doi:10.1016/j.parco.2005.07.004</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU Make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Biarch:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, Matrix, slam</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sgsokol/rmumps/issues">https://github.com/sgsokol/rmumps/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.mumps-solver.org/">http://www.mumps-solver.org/</a>, <a href="https://github.com/sgsokol/rmumps/">https://github.com/sgsokol/rmumps/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-29 16:11:35 UTC; sokol</td>
</tr>
<tr>
<td>Author:</td>
<td>Serguei Sokol [aut, cre],
  Emmanuel Agullo [ctb],
  Patrick Amestoy [ctb, cph],
  Maurice Bremond [ctb],
  Alfredo Buttari [ctb],
  Philippe Combes [ctb],
  Marie Durand [ctb],
  Aurelia Fevre [ctb],
  Abdou Guermouche [ctb],
  Guillaume Joslin [ctb],
  Jacko Koster [ctb],
  Jean-Yves L'Excellent [ctb],
  Stephane Pralet [ctb],
  Chiara Puglisi [ctb],
  Francois-Henry Rouet [ctb],
  Wissam Sid-Lakhdar [ctb],
  Tzvetomila Slavova [ctb],
  Bora Ucar [ctb],
  Clement Weisbecker [ctb],
  Juergen Schulze [ctb],
  George Karypis [ctb],
  Douglas C. Schmidt [ctb],
  Isamu Hasegawa [ctb],
  Alexander Chemeris [ctb],
  Makoto Matsumoto [ctb],
  Takuji Nishimura [ctb],
  Francois Pellegrini [ctb],
  David Goudin [ctb],
  Pascal Henon [ctb],
  Pierre Ramet [ctb],
  Sebastien Fourestier [ctb],
  Jun-Ho Her [ctb],
  Cedric Chevalier [ctb],
  Timothy A. Davis [ctb, cph],
  Iain S. Duff [ctb, cph],
  John K. Reid [ctb, cph],
  Richard Stallman [ctb],
  Samuel Thibault [ctb, cph],
  CERFACS [cph],
  CNRS [cph],
  ENS Lyon [cph],
  INP Toulouse [cph],
  INRIA [cph],
  University of Bordeaux [cph],
  Regents of the University of Minnesota [cph],
  Free Software Foundation, Inc [cph],
  Alexander Chemeris [cph],
  Makoto Matsumoto [cph],
  Takuji Nishimura [cph],
  Universite de Bordeaux [cph],
  CNRS [cph],
  INSA [cph],
  INRAE [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-29 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rmumps-package'>
Rcpp port of MUMPS library for LU or LDL^t factorization of sparse matrices
</h2><span id='topic+rmumps-package'></span><span id='topic+rmumps'></span>

<h3>Description</h3>

<p>Creates a MUMPS compatible object storing a sparse matrix.
Gives a possibility to do separately symbolic analysis,
factorization and system solving.
</p>


<h3>Details</h3>

<p>Create a new Rmumps object with <code>A &lt;- Rmumps$new(asparse)</code> then solve a
linear system with one or many right hand sides <code>x &lt;- solve(A, b)</code>.
Cf. <a href="#topic+Rmumps">Rmumps</a>  
</p>


<h3>Author(s)</h3>

<p>Serguei Sokol, INRA
</p>
<p>Maintainer: Serguei Sokol (sokol at insa-toulouse.fr)
</p>


<h3>References</h3>

<p>MUMPS official site http://mumps.enseeiht.fr
</p>
<p>Sokol S (2024). _Rmumps: Rcpp port of MUMPS_. rmumps package version 5.2.1-29, &lt;URL: http://CRAN.R-project.org/package=rmumps&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    A &lt;- Rmumps$new(asparse)
    x &lt;- solve(A, b)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='Rcpp_Rmumps-class'>
Rcpp Exported Class Wrapping MUMPS library
</h2><span id='topic+Rcpp_Rmumps-class'></span><span id='topic+Rmumps'></span><span id='topic+solve.Rcpp_Rmumps'></span><span id='topic+solvet'></span><span id='topic+solvet.Rcpp_Rmumps'></span><span id='topic+determinant.Rcpp_Rmumps'></span><span id='topic+dim.Rcpp_Rmumps'></span><span id='topic+nrow.Rcpp_Rmumps'></span><span id='topic+ncol.Rcpp_Rmumps'></span><span id='topic+print.Rcpp_Rmumps'></span><span id='topic+show.Rcpp_Rmumps'></span>

<h3>Description</h3>

<p>This class can be used for storing sparse matrix
and solving corresponding linear system with one or many right
hand sides. There is a possibility to do separately symbolic analysis,
LU factorization and system solving.
</p>


<h3>Fields</h3>


<dl>
<dt><code>sym</code>:</dt><dd><p>integer (read only), 0=non symmetric matrix, 1=symmetric with pivots on diagonal or 2=general symmetric</p>
</dd>
<dt><code>copy</code>:</dt><dd><p>logical, copy or not rhs and matrix values</p>
</dd>
<dt><code>mrhs</code>:</dt><dd><p>numeric matrix, multiple rhs (always overwritten with solution)</p>
</dd>
<dt><code>rhs</code>:</dt><dd><p>numeric vector, single rhs (always overwritten with solution)</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>new(asp, sym=0, copy=TRUE)</code>:</dt><dd><p>constructor from Matrix::dgTMatrix class (or from convertible to it) and slam::simple_triplet_matrix class</p>
</dd>
<dt><code>new(i, j, x, n, copy=TRUE)</code>:</dt><dd><p>constructor from triade rows, cols, vals</p>
</dd>
<dt><code>symbolic()</code>:</dt><dd><p>do symbolic analysis (stored internally)</p>
</dd>
<dt><code>numeric()</code>:</dt><dd><p>do LU or LDL^t factorization (stored internally)</p>
</dd>
<dt><code>solve(b)</code>:</dt><dd><p>solve single rhs (if b is a vector) or
multiple rhs if b is a matrix (can be dense or sparse). Return the solution(s).</p>
</dd>
<dt><code>solvet(b)</code>:</dt><dd><p>same as solve() but solves with transposed matrix</p>
</dd>
<dt><code>det()</code>:</dt><dd><p>Return determinant of the matrix</p>
</dd>
<dt><code>inv()</code>:</dt><dd><p>Return inverse of the matrix)</p>
</dd>
<dt><code>set_mat_data(x)</code>:</dt><dd><p>updates matrix entries (x must be in the same order as in previous calls</p>
</dd>
<dt><code>set_icntl(iv, ii)</code>:</dt><dd><p>set ICNTL parameter vector</p>
</dd>
<dt><code>get_icntl()</code>:</dt><dd><p>get ICNTL parameter vector</p>
</dd>
<dt><code>set_cntl(v, iv)</code>:</dt><dd><p>set CNTL parameter vector</p>
</dd>
<dt><code>get_cntl()</code>:</dt><dd><p>get CNTL parameter vector</p>
</dd>
<dt><code>get_infos()</code>:</dt><dd><p>get a named list of information vectors: info, rinfo, infog and rinfog</p>
</dd>
<dt><code>dim()</code>:</dt><dd><p>Return a dimension vector of the matrix</p>
</dd>
<dt><code>nrow()</code>:</dt><dd><p>Return a row number of the matrix</p>
</dd>
<dt><code>ncol()</code>:</dt><dd><p>Return a column number of the matrix</p>
</dd>
<dt><code>print()</code>:</dt><dd><p>Print summary information on the matrix</p>
</dd>
<dt><code>show()</code>:</dt><dd><p>Print summary information on the matrix</p>
</dd>
<dt><code>set_keep()</code>:</dt><dd><p>Set KEEP array elements (undocumented feature of MUMPS)</p>
</dd>
<dt><code>get_keep()</code>:</dt><dd><p>Get a copy of KEEP array elements (length=500)</p>
</dd>
<dt><code>set_permutation(perm)</code>:</dt><dd><p>Set permutation type which can impact storage and factorization performances. Parameter perm can take one of the following predefined integer values RMUMPS_PERM_AMD, RMUMPS_PERM_AMF, RMUMPS_PERM_SCOTCH, RMUMPS_PERM_PORD, RMUMPS_PERM_METIS, RMUMPS_PERM_QAMD. This method should be called once and before symbolic analysis of the matrix. If it is called afterward, a new symbolic and numeric factorization will be performed when one of other methods (e.g. solve()) will request them. In other words, previous symbolic and numeric factorizations are canceled by this method.</p>
</dd>
<dt><code>get_permutation()</code>:</dt><dd><p>get permutation type currently set in the object</p>
</dd>
<dt><code>mumps_version()</code>:</dt><dd><p>Return a string with MUMPS version used in rmumps</p>
</dd>
</dl>



<h3>Note</h3>

<p>When creating a symmetric matrix (sym=1 or sym=2), the upper (or lower) mart of the input matrix must be zeroed.
</p>
<p>For meaning of entries in MUMPS vectors cntl, icntl, info, rinfo, infog and rinfog cf. original documentation of MUMPS project.
</p>
<p>No need to call symbolic() and numeric() methods before a solve() call.
</p>
<p>If in constructor, a parameter <code>copy</code> is set to FALSE, no rhs neither matrix copying is done.
The solution is written &quot;in place&quot; thus overwriting rhs (watch out side effects)
</p>
<p>For a detailed error diagnostic (e.g. when factorizing a singular matrix), use method get_infos() and cf. MUMPS documentation on the official MUMPS site).
</p>


<h3>Author(s)</h3>

<p>Serguei Sokol, INRA
</p>


<h3>References</h3>

<p>MUMPS official site http://mumps.enseeiht.fr
</p>
<p>Sokol S (2020). _Rmumps: Rcpp port of MUMPS_. rmumps package version 5.2.1-X, &lt;URL:
http://CRAN.R-project.org/package=rmumps&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
  # prepare random sparse matrix
  library(Matrix)
  library(rmumps)
  n=2000
  a=Matrix(0, n, n)
  set.seed(7)
  ij=sample(1:(n*n), 15*n)
  a[ij]=runif(ij)
  diag(a)=0
  diag(a)=-rowSums(a)
  a[1,1]=a[1,1]-1
  am=Rmumps$new(a)
  b=as.double(a%*%(1:n)) # rhs for an exact solution vector 1:n
  # following time includes symbolic analysis, LU factorization and system solving
  system.time(x&lt;-solve(am, b))
  bb=2*b
  # this second time should be much shorter
  # as symbolic analysis and LU factorization are already done
  system.time(xx&lt;-solve(am, bb))
  # compare to Matrix corresponding times
  system.time(xm&lt;-solve(a, b))
  system.time(xxm&lt;-solve(a, bb))
  # compare to Matrix precision
  range(x-1:n)  # mumps
  range(xm-1:n) # Matrix

  # matrix inversion
  system.time(aminv &lt;- solve(am))
  system.time(ainv &lt;- solve(a)) # the same in Matrix
  
  # symmetric matrix
  asy=as(a+t(a), "symmetricMatrix")
  bs=as.double(asy%*%(1:n)) # rhs for 1:n solution
  au=asy
  # Here, we keep only diagonal and upper values of asy matrix.
  # It could be also diagonal and lower values.
  au[row(au)&gt;col(au)]=0
  ams=Rmumps$new(au, sym=1)
  system.time(xs&lt;-solve(ams, bs)) # rmumps
  system.time(xsm&lt;-solve(asy, bs))# Matrix
  # compare to Matrix precision
  range(xs-1:n)  # mumps
  range(xsm-1:n) # Matrix

  # clean up by hand to avoid possible interference between gc() and
  # Rcpp object destructor after unloading this namespace
  rm(am, ams)
  gc()
 
## End(Not run)
</code></pre>

<hr>
<h2 id='Rmumps__del_ptr'>Delete via Pointer</h2><span id='topic+Rmumps__del_ptr'></span>

<h3>Description</h3>

<p>This is a C wrapper to <code>Rmumps::~Rmumps()</code> destructor. Available in R too.
In C++ code can be used as <code>rmumps::Rmumps__del_ptr(pm)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmumps__del_ptr(pm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rmumps__del_ptr_+3A_pm">pm</code></td>
<td>
<p>pointer of type XPtr&lt;Rmumps&gt;, object to be deleted</p>
</td></tr>
</table>

<hr>
<h2 id='Rmumps__get_permutation'>Get Permutation Parameter</h2><span id='topic+Rmumps__get_permutation'></span>

<h3>Description</h3>

<p>This is a C wrapper to <code>Rmumps::get_permutation()</code> method. Available in R too.
In C++ code can be used as <code>rmumps::Rmumps__get_permutation(pm)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmumps__get_permutation(pm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rmumps__get_permutation_+3A_pm">pm</code></td>
<td>
<p>pointer of type XPtr&lt;Rmumps&gt;, object having sparse matrix permuted according to some method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer defining permutation method used before matrix decomposition.
</p>

<hr>
<h2 id='Rmumps__ptr_ijv'>Construct via Triplet Pointers</h2><span id='topic+Rmumps__ptr_ijv'></span>

<h3>Description</h3>

<p>This is a C wrapper to <code>Rmumps::Rmumps(i, j, v, n, nz, sym)</code> constructor. Available in R too.
In C++ code can be used as <code>rmumps::Rmumps__ptr_ijv(pi, pj, pa, n, nz, sym)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmumps__ptr_ijv(pi, pj, pa, n, nz, sym)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rmumps__ptr_ijv_+3A_pi">pi</code></td>
<td>
<p>pointer of type XPtr&lt;int&gt;, vector of i-indeces for sparse triplet</p>
</td></tr>
<tr><td><code id="Rmumps__ptr_ijv_+3A_pj">pj</code></td>
<td>
<p>pointer of type XPtr&lt;int&gt;, vector of j-indeces for sparse triplet</p>
</td></tr>
<tr><td><code id="Rmumps__ptr_ijv_+3A_pa">pa</code></td>
<td>
<p>pointer of type XPtr&lt;double&gt;, vector or values for sparse triplet</p>
</td></tr>
<tr><td><code id="Rmumps__ptr_ijv_+3A_n">n</code></td>
<td>
<p>integer, size of the matrix (n x n)</p>
</td></tr>
<tr><td><code id="Rmumps__ptr_ijv_+3A_nz">nz</code></td>
<td>
<p>integer, number of non zeros in the matrix</p>
</td></tr>
<tr><td><code id="Rmumps__ptr_ijv_+3A_sym">sym</code></td>
<td>
<p>integer, 0 means general (non symmetric) matrix, 1 - symmetric with pivotes on the main diagonal, 2 - general symmetric (pivotes may be anywhere)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pointer of type XPtr&lt;Rmumps&gt; pointing to newly created object. To avoid memory leakage, it is user's responsibility to call <code>Rmumps__del_ptr(pm)</code> in a due moment (where <code>pm</code> is the returned pointer).
</p>

<hr>
<h2 id='Rmumps__set_mat_ptr'>Set Matrix via Pointer</h2><span id='topic+Rmumps__set_mat_ptr'></span>

<h3>Description</h3>

<p>This is a C wrapper to <code>Rmumps::set_mat_ptr(a)</code> method. Available in R too.
In C++ code can be used as <code>rmumps::Rmumps__set_mat_ptr(pm)</code>. Using this method invalidates previous numeric decomposition (but not symbolic one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmumps__set_mat_ptr(pm, pa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rmumps__set_mat_ptr_+3A_pm">pm</code></td>
<td>
<p>pointer of type XPtr&lt;Rmumps&gt;, object having sparse matrix to be replaced with second parameter</p>
</td></tr>
<tr><td><code id="Rmumps__set_mat_ptr_+3A_pa">pa</code></td>
<td>
<p>pointer of type XPtr&lt;double&gt;, value vector from sparse triplet providing a new matrix. Structure of the new matrix must be identical to the old one. That's why there is no need to provide i and j for the new triplet.</p>
</td></tr>
</table>

<hr>
<h2 id='Rmumps__set_permutation'>Set Permutation Parameter</h2><span id='topic+Rmumps__set_permutation'></span>

<h3>Description</h3>

<p>This is a C wrapper to <code>Rmumps::set_permutation(permutation)</code> method. Available in R too.
In C++ code can be used as <code>rmumps::Rmumps__set_permutation(pm, permutation)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmumps__set_permutation(pm, permutation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rmumps__set_permutation_+3A_pm">pm</code></td>
<td>
<p>pointer of type XPtr&lt;Rmumps&gt;, object having sparse matrix permuted according to a chosen method.</p>
</td></tr>
<tr><td><code id="Rmumps__set_permutation_+3A_permutation">permutation</code></td>
<td>
<p>integer one of predefined constants (cf. <code><a href="#topic+RMUMPS_PERM">RMUMPS_PERM</a></code>). Setting a new permutation invalidates current symbolic and numeric matrix decompositions.</p>
</td></tr>
</table>

<hr>
<h2 id='Rmumps__solveptr'>Solve via Pointer</h2><span id='topic+Rmumps__solveptr'></span>

<h3>Description</h3>

<p>This is a C wrapper to <code>Rmumps::solveptr()</code> method. Available in R too.
In C++ code can be used as <code>rmumps::Rmumps__solveptr(pobj, pb, lrhs, nrhs)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmumps__solveptr(pobj, pb, lrhs, nrhs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rmumps__solveptr_+3A_pobj">pobj</code></td>
<td>
<p>pointer of type XPtr&lt;Rmumps&gt;, object having sparse matrix</p>
</td></tr>
<tr><td><code id="Rmumps__solveptr_+3A_pb">pb</code></td>
<td>
<p>pointer of type XPtr&lt;double&gt;, vector or dense matrix of rhs</p>
</td></tr>
<tr><td><code id="Rmumps__solveptr_+3A_lrhs">lrhs</code></td>
<td>
<p>integer, leading dimension in pb</p>
</td></tr>
<tr><td><code id="Rmumps__solveptr_+3A_nrhs">nrhs</code></td>
<td>
<p>integer, number of rhs to solve.</p>
</td></tr>
</table>

<hr>
<h2 id='Rmumps__triplet'>Explore via Triplet</h2><span id='topic+Rmumps__triplet'></span>

<h3>Description</h3>

<p>This is a C wrapper to <code>Rmumps::triplet()</code> method. Available in R too.
In C++ code can be used as <code>rmumps::Rmumps__triplet(pm)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmumps__triplet(pm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rmumps__triplet_+3A_pm">pm</code></td>
<td>
<p>pointer of type XPtr&lt;Rmumps&gt;, object having sparse matrix to be explored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with sparse triplet described with fields i, j, v
</p>

<hr>
<h2 id='RMUMPS_PERM'>Exported Constants</h2><span id='topic+RMUMPS_PERM'></span><span id='topic+RMUMPS_PERM_AMD'></span><span id='topic+RMUMPS_PERM_AMF'></span><span id='topic+RMUMPS_PERM_SCOTCH'></span><span id='topic+RMUMPS_PERM_PORD'></span><span id='topic+RMUMPS_PERM_METIS'></span><span id='topic+RMUMPS_PERM_QAMD'></span><span id='topic+RMUMPS_PERM_AUTO'></span>

<h3>Description</h3>

<p>Integer constants defining permutation types and exported from rmumps are following:
</p>

<ul>
<li><p><code>RMUMPS_PERM_AMD</code>
</p>
</li>
<li><p><code>RMUMPS_PERM_AMF</code>
</p>
</li>
<li><p><code>RMUMPS_PERM_SCOTCH</code>
</p>
</li>
<li><p><code>RMUMPS_PERM_PORD</code>
</p>
</li>
<li><p><code>RMUMPS_PERM_METIS</code>
</p>
</li>
<li><p><code>RMUMPS_PERM_QAMD</code>
</p>
</li>
<li><p><code>RMUMPS_PERM_AUTO</code>
</p>
</li></ul>

<p>They are all regrouped in a named vector <code>RMUMPS_PERM</code> where names are items above and values are corresponding constants.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>am=rmumps::Rmumps$new(slam::as.simple_triplet_matrix(diag(1:3)))
am$set_permutation(RMUMPS_PERM_SCOTCH)
am$solve(1:3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
