<!DOCTYPE html><html><head><title>Help for package NetworkToolbox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NetworkToolbox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NetworkToolbox-package'><p>NetworkToolbox&ndash;package</p></a></li>
<li><a href='#adapt.a'><p>Adaptive Alpha</p></a></li>
<li><a href='#behavOpen'><p>NEO-PI-3 for Resting-state Data</p></a></li>
<li><a href='#betweenness'><p>Betweenness Centrality</p></a></li>
<li><a href='#binarize'><p>Binarize Network</p></a></li>
<li><a href='#closeness'><p>Closeness Centrality</p></a></li>
<li><a href='#clustcoeff'><p>Clustering Coefficient</p></a></li>
<li><a href='#comcat'><p>Communicating Nodes</p></a></li>
<li><a href='#comm.close'><p>Community Closeness Centrality</p></a></li>
<li><a href='#comm.eigen'><p>Community Eigenvector Centrality</p></a></li>
<li><a href='#comm.str'><p>Community Strength/Degree Centrality</p></a></li>
<li><a href='#conn'><p>Network Connectivity</p></a></li>
<li><a href='#convert2igraph'><p>Convert Network(s) to igraph's Format</p></a></li>
<li><a href='#convertConnBrainMat'><p>Import CONN Toolbox Brain Matrices to R format</p></a></li>
<li><a href='#cor2cov'><p>Convert Correlation Matrix to Covariance Matrix</p></a></li>
<li><a href='#core.items'><p>Core Items</p></a></li>
<li><a href='#cpm'><p>Connectome-based Predictive Modeling</p></a></li>
<li><a href='#dCor'><p>Distance Correlation for ROI Time Series</p></a></li>
<li><a href='#dCor.parallel'><p>Parallelization of Distance Correlation for ROI Time Series</p></a></li>
<li><a href='#degree'><p>Degree</p></a></li>
<li><a href='#depend'><p>Dependency Network Approach</p></a></li>
<li><a href='#depna'><p>Dependency Neural Networks</p></a></li>
<li><a href='#desc'><p>Variable Descriptive Statistics</p></a></li>
<li><a href='#desc.all'><p>Dataset Descriptive Statistics</p></a></li>
<li><a href='#distance'><p>Distance</p></a></li>
<li><a href='#diversity'><p>Diversity Coefficient</p></a></li>
<li><a href='#ECO'><p>ECO Neural Network Filter</p></a></li>
<li><a href='#ECOplusMaST'><p>ECO+MaST Network Filter</p></a></li>
<li><a href='#edgerep'><p>Edge Replication</p></a></li>
<li><a href='#eigenvector'><p>Eigenvector Centrality</p></a></li>
<li><a href='#flow.frac'><p>Flow Fraction</p></a></li>
<li><a href='#gain.functions'><p>MFCF Gain Functions</p></a></li>
<li><a href='#gateway'><p>Gateway Coefficient</p></a></li>
<li><a href='#hybrid'><p>Hybrid Centrality</p></a></li>
<li><a href='#impact'><p>Node Impact</p></a></li>
<li><a href='#is.graphical'><p>Determines if Network is Graphical</p></a></li>
<li><a href='#kld'><p>Kullback-Leibler Divergence</p></a></li>
<li><a href='#lattnet'><p>Generates a Lattice Network</p></a></li>
<li><a href='#leverage'><p>Leverage Centrality</p></a></li>
<li><a href='#LoGo'><p>Local/Global Inversion Method</p></a></li>
<li><a href='#louvain'><p>Louvain Community Detection Algorithm</p></a></li>
<li><a href='#MaST'><p>Maximum Spanning Tree</p></a></li>
<li><a href='#MFCF'><p>Maximally Filtered Clique Forest</p></a></li>
<li><a href='#neoOpen'><p>NEO-PI-3 Openness to Experience Data</p></a></li>
<li><a href='#net.coverage'><p>Network Coverage</p></a></li>
<li><a href='#network.coverage'><p>Network Coverage</p></a></li>
<li><a href='#network.permutation'><p>Permutation Test for Network Measures</p></a></li>
<li><a href='#neuralnetfilter'><p>Neural Network Filter</p></a></li>
<li><a href='#openness'><p>Four Inventories of Openness to Experience</p></a></li>
<li><a href='#participation'><p>Participation Coefficient</p></a></li>
<li><a href='#pathlengths'><p>Characteristic Path Lengths</p></a></li>
<li><a href='#plot.cpm'><p>Plots CPM results</p></a></li>
<li><a href='#randnet'><p>Generates a Random Network</p></a></li>
<li><a href='#reg'><p>Regression Matrix</p></a></li>
<li><a href='#resp.rep'><p>Repeated Responses Check</p></a></li>
<li><a href='#rmse'><p>Root Mean Square Error</p></a></li>
<li><a href='#rspbc'><p>Randomized Shortest Paths Betweenness Centrality</p></a></li>
<li><a href='#sim.chordal'><p>Simulate Chordal Network</p></a></li>
<li><a href='#sim.swn'><p>Simulate Small-world Network</p></a></li>
<li><a href='#smallworldness'><p>Small-worldness Measure</p></a></li>
<li><a href='#stable'><p>Stabilizing Nodes</p></a></li>
<li><a href='#strength'><p>Node Strength</p></a></li>
<li><a href='#threshold'><p>Threshold Network Estimation Methods</p></a></li>
<li><a href='#TMFG'><p>Triangulated Maximally Filtered Graph</p></a></li>
<li><a href='#transitivity'><p>Transitivity</p></a></li>
<li><a href='#un.direct'><p>Convert Directed Network to Undirected Network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Methods and Measures for Brain, Cognitive, and Psychometric
Network Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements network analysis and graph theory measures used in neuroscience, cognitive science, and psychology. Methods include various filtering methods and approaches such as threshold, dependency (Kenett, Tumminello, Madi, Gur-Gershgoren, Mantegna, &amp; Ben-Jacob, 2010 &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0015032">doi:10.1371/journal.pone.0015032</a>&gt;), Information Filtering Networks (Barfuss, Massara, Di Matteo, &amp; Aste, 2016 &lt;<a href="https://doi.org/10.1103%2FPhysRevE.94.062306">doi:10.1103/PhysRevE.94.062306</a>&gt;), and Efficiency-Cost Optimization (Fallani, Latora, &amp; Chavez, 2017 &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1005305">doi:10.1371/journal.pcbi.1005305</a>&gt;). Brain methods include the recently developed Connectome Predictive Modeling (see references in package). Also implements several network measures including local network characteristics (e.g., centrality), community-level network characteristics (e.g., community centrality), global network characteristics (e.g., clustering coefficient), and various other measures associated with the reliability and reproducibility of network analysis. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>psych, corrplot, fdrtool, R.matlab, igraph, qgraph, ppcor,
parallel, foreach, doParallel, MASS, pwr, IsingFit, pbapply</td>
</tr>
<tr>
<td>Suggests:</td>
<td>googledrive</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-28 11:16:44 UTC; apchr</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Christensen
    <a href="https://orcid.org/0000-0002-9798-7037"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Guido Previde Massara
    <a href="https://orcid.org/0000-0003-0502-2789"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-28 11:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='NetworkToolbox-package'>NetworkToolbox&ndash;package</h2><span id='topic+NetworkToolbox'></span><span id='topic+NetworkToolbox-package'></span>

<h3>Description</h3>

<p>Implements network analysis and graph theory measures used
in neuroscience, cognitive science, and psychology.
Methods include various filtering methods and approaches such as
threshold, dependency, Information Filtering Networks, and Efficiency-Cost Optimization.
Brain methods include the recently developed Connectome Predictive Modeling.
Also implements several network measures including local network characteristics
(e.g., centrality), global network characteristics (e.g., clustering coefficient),
and various other measures associated with the reliability and
reproducibility of network analysis.
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Christensen, A. P. (in press).
NetworkToolbox: Methods and measures for brain, cognitive, and psychometric network analysis in R.
<em>The R Journal</em>, <em>10</em>, 422-439.
</p>

<hr>
<h2 id='adapt.a'>Adaptive Alpha</h2><span id='topic+adapt.a'></span>

<h3>Description</h3>

<p>Compute an alpha value adjusted for sample size. The adjusted value is based on
Perez and Pericchi's (2014) formula (equation 11, see below) using a reference sample, which can be
defined a priori or estimated using the sample size calculation from power.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\alpha * \sqrt{n_0 \times (log(n_0) + \chi^{2}_{\alpha}(1))}}{\sqrt{n^* \times (log(n^*) + \chi^{2}_{\alpha}(1))}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>adapt.a(
  test = c("anova", "chisq", "cor", "one.sample", "two.sample", "paired"),
  ref.n = NULL,
  n = NULL,
  alpha = 0.05,
  power = 0.8,
  efxize = c("small", "medium", "large"),
  groups = NULL,
  df = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adapt.a_+3A_test">test</code></td>
<td>
<p>Type of statistical test being used.
Can be any of the tests listed</p>
</td></tr>
<tr><td><code id="adapt.a_+3A_ref.n">ref.n</code></td>
<td>
<p><em>n0</em> in the above equation.
Reference sample size.
If sample size was determined a priori, then the reference
number of participants can be set. This removes the calculation of sample
size based on power</p>
</td></tr>
<tr><td><code id="adapt.a_+3A_n">n</code></td>
<td>
<p><em>n*</em> in the above equation.
Number of participants in the experiment sample (or per group)</p>
</td></tr>
<tr><td><code id="adapt.a_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> in the above equation.
Alpha value to adjust.
Defaults to <code>.05</code></p>
</td></tr>
<tr><td><code id="adapt.a_+3A_power">power</code></td>
<td>
<p>Power (<code class="reqn">1 - \beta</code>) value.
Used to estimate the reference sample size (n0).
Defaults to <code>.80</code></p>
</td></tr>
<tr><td><code id="adapt.a_+3A_efxize">efxize</code></td>
<td>
<p>Effect size to be used to estimate the reference sample size.
Effect sizes are based on Cohen (1992).
Numeric values can be used.
Defaults to <code>"medium"</code></p>
</td></tr>
<tr><td><code id="adapt.a_+3A_groups">groups</code></td>
<td>
<p>Number of groups (only for <code>test = "anova"</code>)</p>
</td></tr>
<tr><td><code id="adapt.a_+3A_df">df</code></td>
<td>
<p>Number of degrees of freedom (only for <code>test = "chisq"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>
<table>
<tr><td><code>adapt.a</code></td>
<td>
<p>The adapted alpha value</p>
</td></tr>
<tr><td><code>crit.value</code></td>
<td>
<p>The critical value associated with the adapted alpha value</p>
</td></tr>
<tr><td><code>orig.a</code></td>
<td>
<p>The original alpha value</p>
</td></tr>
<tr><td><code>ref.n</code></td>
<td>
<p>The reference sample size based on alpha, power, effect size, and test</p>
</td></tr>
<tr><td><code>exp.n</code></td>
<td>
<p>The sample size of the experimental sample</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>The power used to determine the reference sample size</p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p>The type of statistical test used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Cohen, J. (1992).
A power primer.
<em>Psychological Bulletin</em>, <em>112</em>, 155-159.
</p>
<p>Perez, M. E., &amp; Pericchi, L. R. (2014).
Changing statistical significance with the amount of information: The adaptive <em>a</em> significance level.
<em>Statistics &amp; Probability Letters</em>, <em>85</em>, 20-24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#ANOVA
adapt.anova &lt;- adapt.a(test = "anova", n = 200, alpha = .05, power = .80, groups = 3)

#Chi-square
adapt.chisq &lt;- adapt.a(test = "chisq", n = 200, alpha = .05, power = .80, df = 3)

#Correlation
adapt.cor &lt;- adapt.a(test = "cor", n = 200, alpha = .05, power = .80)

#One-sample t-test
adapt.one &lt;- adapt.a(test = "one.sample", n = 200, alpha = .05, power = .80)

#Two-sample t-test
adapt.two &lt;- adapt.a(test = "two.sample", n = 200, alpha = .05, power = .80)

#Paired sample t-test
adapt.paired &lt;- adapt.a(test = "paired", n = 200, alpha = .05, power = .80, efxize = "medium")

</code></pre>

<hr>
<h2 id='behavOpen'>NEO-PI-3 for Resting-state Data</h2><span id='topic+behavOpen'></span>

<h3>Description</h3>

<p>NEO-PI-3 Openness to Experience associated with resting-state data (<em>n</em> = 144).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(behavOpen)
</code></pre>


<h3>Format</h3>

<p>behavOpen (vector, length = 144)
</p>


<h3>Details</h3>

<p>Behavioral data of NEO-PI-3 associated with each connectivity matrix (open).
</p>
<p>To access the resting-state brain data, please go to <a href="https://drive.google.com/file/d/1ugwi7nRrlHQYuGPzEB4wYzsizFrIMvKR/view">https://drive.google.com/file/d/1ugwi7nRrlHQYuGPzEB4wYzsizFrIMvKR/view</a>
</p>


<h3>References</h3>

<p>Beaty, R. E., Chen, Q., Christensen, A. P., Qiu, J., Silvia, P. J., &amp; Schacter, D. L. (2018).
Brain networks of the imaginative mind: Dynamic functional connectivity of default and cognitive control networks relates to Openness to Experience.
<em>Human Brain Mapping</em>, <em>39</em>, 811-821.
</p>
<p>Beaty, R. E., Kenett, Y. N., Christensen, A. P., Rosenberg, M. D., Benedek, M., Chen, Q., ... &amp; Silvia, P. J. (2018).
Robust prediction of individual creative ability from brain functional connectivity.
<em>Proceedings of the National Academy of Sciences</em>, 201713532.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("behavOpen")
</code></pre>

<hr>
<h2 id='betweenness'>Betweenness Centrality</h2><span id='topic+betweenness'></span>

<h3>Description</h3>

<p>Computes betweenness centrality of each node in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betweenness(A, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betweenness_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="betweenness_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for unweighted measure of betweenness centrality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of betweenness centrality values for each node in the network
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

#Weighted BC
BCw &lt;- betweenness(A)

#Unweighted BC
BC &lt;- betweenness(A, weighted = FALSE)

</code></pre>

<hr>
<h2 id='binarize'>Binarize Network</h2><span id='topic+binarize'></span>

<h3>Description</h3>

<p>Converts weighted adjacency matrix to a binarized adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarize(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binarize_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data (or an array of matrices)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix of 1's and 0's
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

neoB &lt;- binarize(A)

</code></pre>

<hr>
<h2 id='closeness'>Closeness Centrality</h2><span id='topic+closeness'></span>

<h3>Description</h3>

<p>Computes closeness centrality of each node in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closeness(A, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeness_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="closeness_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for unweighted measure of closeness centrality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of closeness centrality values for each node in the network
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

#Weighted LC
LC &lt;- closeness(A)

#Unweighted LC
LC &lt;- closeness(A, weighted = FALSE)

</code></pre>

<hr>
<h2 id='clustcoeff'>Clustering Coefficient</h2><span id='topic+clustcoeff'></span>

<h3>Description</h3>

<p>Computes global clustering coefficient (CC) and local clustering coefficient (CCi)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustcoeff(A, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustcoeff_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="clustcoeff_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> for weighted measures of CC and CCi</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>CC</code></td>
<td>
<p>Global clustering coefficient. The average clustering coefficient for each node in the network</p>
</td></tr>
<tr><td><code>CCi</code></td>
<td>
<p>Local clustering coefficient. The clustering coefficient for each node in the network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

#Unweighted CC
CCu &lt;- clustcoeff(A)

#Weighted CC
CCw &lt;- clustcoeff(A, weighted=TRUE)

</code></pre>

<hr>
<h2 id='comcat'>Communicating Nodes</h2><span id='topic+comcat'></span>

<h3>Description</h3>

<p>Computes the between-community strength for each node in the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comcat(
  A,
  comm = c("walktrap", "louvain"),
  cent = c("strength", "degree"),
  absolute = TRUE,
  metric = c("across", "each"),
  diagonal = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comcat_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="comcat_+3A_comm">comm</code></td>
<td>
<p>Can be a vector of community assignments or community detection algorithms
(<code>"walktrap"</code> or <code>"louvain"</code>) can be used to determine the number of factors.
Defaults to <code>"walktrap"</code>.
Set to <code>"louvain"</code> for <code><a href="#topic+louvain">louvain</a></code> community detection</p>
</td></tr>
<tr><td><code id="comcat_+3A_cent">cent</code></td>
<td>
<p>Centrality measure to be used.
Defaults to <code>"strength"</code>.</p>
</td></tr>
<tr><td><code id="comcat_+3A_absolute">absolute</code></td>
<td>
<p>Should network use absolute weights?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for signed weights</p>
</td></tr>
<tr><td><code id="comcat_+3A_metric">metric</code></td>
<td>
<p>Whether the metric should be compute for across all of the communities
(a single value) or for each community (a value for each community).
Defaults to <code>"across"</code>.
Set to <code>"each"</code> for values for each community</p>
</td></tr>
<tr><td><code id="comcat_+3A_diagonal">diagonal</code></td>
<td>
<p>Sets the diagonal values of the <code>A</code> input.
Defaults to <code>0</code></p>
</td></tr>
<tr><td><code id="comcat_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code>
and <code><a href="#topic+louvain">louvain</a></code> community detection algorithms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the between-community strength value for each node
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Blanken, T. F., Deserno, M. K., Dalege, J., Borsboom, D., Blanken, P., Kerkhof, G. A., &amp; Cramer, A. O. (2018).
The role of stabilizing and communicating symptoms given overlapping communities in psychopathology networks.
<em>Scientific Reports</em>, <em>8</em>, 5854.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

communicating &lt;- comcat(A, comm = "walktrap", cent = "strength", metric = "across")

</code></pre>

<hr>
<h2 id='comm.close'>Community Closeness Centrality</h2><span id='topic+comm.close'></span>

<h3>Description</h3>

<p>Computes the community closeness centrality measure of each
community in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.close(A, comm, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comm.close_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="comm.close_+3A_comm">comm</code></td>
<td>
<p>A vector or matrix corresponding to the
community each node belongs to</p>
</td></tr>
<tr><td><code id="comm.close_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> for weighted measures</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of community closeness centrality values for each specified
community in the network
(larger values suggest more central positioning)
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Christensen, A. P. (in press).
NetworkToolbox: Methods and measures for brain, cognitive, and psychometric network analysis in R.
<em>The R Journal</em>, <em>10</em>, 422-439.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

comm &lt;- igraph::walktrap.community(convert2igraph(abs(A)))$membership

#Weighted
result &lt;- comm.close(A, comm)

#Unweighted
result &lt;- comm.close(A, comm, weighted = FALSE)

</code></pre>

<hr>
<h2 id='comm.eigen'>Community Eigenvector Centrality</h2><span id='topic+comm.eigen'></span>

<h3>Description</h3>

<p>Computes the <a href="#topic+flow.frac">flow.frac</a> for each
community in the network. The values are equivalent to the community's
eigenvector centrality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.eigen(A, comm, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comm.eigen_+3A_a">A</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
<tr><td><code id="comm.eigen_+3A_comm">comm</code></td>
<td>
<p>A vector or matrix corresponding to the
community each node belongs to</p>
</td></tr>
<tr><td><code id="comm.eigen_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for weighted measures</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of community eigenvector centrality values for
each specified community in the network
(larger values suggest more central positioning)
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Giscard, P. L., &amp; Wilson, R. C. (2018).
A centrality measure for cycles and subgraphs II.
<em>Applied Network Science</em>, <em>3</em>, 9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

comm &lt;- igraph::walktrap.community(convert2igraph(abs(A)))$membership

result &lt;- comm.eigen(A, comm)

</code></pre>

<hr>
<h2 id='comm.str'>Community Strength/Degree Centrality</h2><span id='topic+comm.str'></span>

<h3>Description</h3>

<p>Computes the community
<code><a href="#topic+strength">strength</a></code>/<code><a href="#topic+degree">degree</a></code>
centrality measure of each community in a network  or computes the
<code><a href="#topic+strength">strength</a></code>/<code><a href="#topic+degree">degree</a></code>
centrality measure of each community's connections to the other communities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.str(A, comm, weighted = TRUE, measure = c("within", "between"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comm.str_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="comm.str_+3A_comm">comm</code></td>
<td>
<p>A vector corresponding to the
community each node belongs to</p>
</td></tr>
<tr><td><code id="comm.str_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for weighted measures</p>
</td></tr>
<tr><td><code id="comm.str_+3A_measure">measure</code></td>
<td>
<p>Type of measure to compute:
</p>

<ul>
<li><p><code>"within"</code>
Computes the community strength or degree of nodes within
its own community
</p>
</li>
<li><p><code>"between"</code>
Computes the community strength or degree of nodes outside
of its own community
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of community strength/degree centrality values for each specified
community in the network
(larger values suggest more central positioning)
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

comm &lt;- igraph::walktrap.community(convert2igraph(abs(A)))$membership

#Strength
within.ns &lt;- comm.str(A, comm, measure = "within")
between.ns &lt;- comm.str(A, comm, measure = "between")

#Degree
within.deg &lt;- comm.str(A, comm, weighted = FALSE, measure = "within")
between.deg &lt;- comm.str(A, comm, weighted = FALSE, measure = "between")

</code></pre>

<hr>
<h2 id='conn'>Network Connectivity</h2><span id='topic+conn'></span>

<h3>Description</h3>

<p>Computes the average and standard deviation of the weights in the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conn(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conn_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of a network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>weights</code></td>
<td>
<p>Each edge weight in the network</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>The mean of the edge weights in the network</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>The standard deviation of the edge weights in the network</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>The sum total of the edge weights in the network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

connectivity &lt;- conn(A)

</code></pre>

<hr>
<h2 id='convert2igraph'>Convert Network(s) to igraph's Format</h2><span id='topic+convert2igraph'></span>

<h3>Description</h3>

<p>Converts single or multiple networks into <code><a href="igraph.html#topic+igraph">igraph</a></code>'s format for network analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2igraph(A, neural = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert2igraph_+3A_a">A</code></td>
<td>
<p>Adjacency matrix (network matrix) or brain connectivity array
(from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code>)</p>
</td></tr>
<tr><td><code id="convert2igraph_+3A_neural">neural</code></td>
<td>
<p>Is input a brain connectivity array (i.e., m x m x n)?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> to convert each brain connectivity matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a network matrix in <code><a href="igraph.html#topic+igraph">igraph</a></code>'s format or
returns a list of brain connectivity matrices each of which have been
convert to <code><a href="igraph.html#topic+igraph">igraph</a></code>'s format
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

igraphNetwork &lt;- convert2igraph(A)

## Not run:  
neuralarray &lt;- convertConnBrainMat()

igraphNeuralList &lt;- convert2igraph(neuralarray, neural = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='convertConnBrainMat'>Import CONN Toolbox Brain Matrices to R format</h2><span id='topic+convertConnBrainMat'></span>

<h3>Description</h3>

<p>Converts a Matlab brain z-score connectivity array (n x n x m)
where <strong>n</strong> is the n x n connectivity matrices and <strong>m</strong> is the participant.
If you would like to simply import a connectivity array from Matlab, then see the examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertConnBrainMat(MatlabData, progBar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertConnBrainMat_+3A_matlabdata">MatlabData</code></td>
<td>
<p>Input for Matlab data file.
Defaults to interactive file choice</p>
</td></tr>
<tr><td><code id="convertConnBrainMat_+3A_progbar">progBar</code></td>
<td>
<p>Should progress bar be displayed?
Defaults to <code>TRUE</code>.
Set <code>FALSE</code> for no progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>rmat</code></td>
<td>
<p>Correlation matrices for each participant (m) in an array (n x n x m)</p>
</td></tr>
<tr><td><code>zmat</code></td>
<td>
<p>Z-score matrices for each participant (m) in an array (n x n x m)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neuralarray &lt;- convertConnBrainMat()

#Import correlation connectivity array from Matlab
library(R.matlab)
neuralarray&lt;-readMat(file.choose())

## End(Not run)

</code></pre>

<hr>
<h2 id='cor2cov'>Convert Correlation Matrix to Covariance Matrix</h2><span id='topic+cor2cov'></span>

<h3>Description</h3>

<p>Converts a correlation matrix to a covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2cov(cormat, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor2cov_+3A_cormat">cormat</code></td>
<td>
<p>A correlation matrix</p>
</td></tr>
<tr><td><code id="cor2cov_+3A_data">data</code></td>
<td>
<p>The dataset the correlation matrix is from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a covariance matrix
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cormat &lt;- cor(neoOpen)

covmat &lt;- cor2cov(cormat,neoOpen)

</code></pre>

<hr>
<h2 id='core.items'>Core Items</h2><span id='topic+core.items'></span>

<h3>Description</h3>

<p>Automatically determines core, intermediary, and peripheral items in the network.
The entire network or within-community gradations can be determined. Based on the
<code><a href="#topic+hybrid">hybrid</a></code> centrality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>core.items(A, comm, by = c("network", "communities"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="core.items_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="core.items_+3A_comm">comm</code></td>
<td>
<p>A vector or matrix corresponding to the community each node belongs to</p>
</td></tr>
<tr><td><code id="core.items_+3A_by">by</code></td>
<td>
<p>Should the core items be defined by network or communities?
Defaults to <code>"network"</code>.
Set to <code>"communities"</code> to define core items within communities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>core</code></td>
<td>
<p>Core items for each community</p>
</td></tr>
<tr><td><code>inter</code></td>
<td>
<p>Intermediate items for each community</p>
</td></tr>
<tr><td><code>peri</code></td>
<td>
<p>Peripheral items for each community</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#network
# Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

#core items by network
coreBYnetwork &lt;- core.items(A, by = "network")

#theoretical factors
comm &lt;- c(rep(1,8),rep(2,8),rep(3,8),rep(4,8),rep(5,8),rep(6,8))

#core items by communities
coreBYcomm &lt;- core.items(A, comm, by = "communities")

</code></pre>

<hr>
<h2 id='cpm'>Connectome-based Predictive Modeling</h2><span id='topic+cpm'></span><span id='topic+cpmIV'></span><span id='topic+cpmEV'></span><span id='topic+cpmFP'></span><span id='topic+cpmFPperm'></span><span id='topic+cpmIVperm'></span><span id='topic+cpmPlot'></span>

<h3>Description</h3>

<p>Suite of functions for Connectome-based Predictive Modeling (CPM).
<strong>See and cite Finn et al., 2015; Rosenberg et al., 2016; Shen et al., 2017</strong>
</p>

<ul>
<li><p><code>cpmIV</code>
</p>
<p>Internal Validation method (Rosenberg et al., 2016; Shen et al., 2017). Using a leave-one-out approach,
this method correlates a behavioral statistic <code>bstat</code> with each edge of a whole-brain network across
participants. Using the significant edges in the network <code>thresh</code>, a connectome model
is built (without the participant's network). A linear regression model is fit, with the behavioral
statistic being regressed on the connectome model. The left out participants connectome model is then
used with the linear regression weights to compute their predicted behavioral score. This is repeated
for every participant. The predicted scores are correlated with their observed score. Significant values
suggest that the connectome is related to the behavioral statistic
</p>
</li>
<li><p><code>cpmIVperm</code>
</p>
<p>Performs a permutation test of the results obtained by <code>cpmIV</code>. The permutation test quantifies
whether the results obtained by the original <code>cpmIV</code> are significantly different than a random model
(see Shen et al., 2017)
</p>
</li>
<li><p><code>cpmEV</code>
</p>
<p>UNDER DEVELOPMENT. External Validation method (Beaty et al., 2018). Performs similar function as <code>cpmIV</code> but uses data
to train <code>train_na</code> the connectome model using a behavioral statistic <code>train_b</code>.
This training connectome model is then used to predict another dataset <code>valid_na</code>,
using the same behavioral statistic <code>valid_b</code>. The full training dataset <code>FALSE</code> or
the leave-one-out <code>overlap = TRUE</code> approach can be used
</p>
</li>
<li><p><code>cpmFP</code>
</p>
<p>Fingerprinting method (Finn et al., 2015). Uses CPM approach to identify participants across two
sessions
</p>
</li>
<li><p><code>cpmFPperm</code>
</p>
<p>Fingerprinting method (Finn et al., 2015). Uses permutation method to estimate the significance of
of the <code>cpmFP</code> results
</p>
</li>
<li><p><code>cpmPlot</code>
</p>
<p>Plots the CPM results
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cpmIV(neuralarray, bstat, kfolds, covar, thresh = .01,
      connections = c("separate", "overall"), groups = NULL,
      method = c("mean", "sum"), model = c("linear","quadratic","cubic"),
      corr = c("pearson","spearman"), nEdges, 
      standardize = FALSE, cores, progBar = TRUE, plots = TRUE)
      
cpmIVperm(iter = 1000, ...)
      
cpmEV(train_na, train_b, valid_na, valid_b, thresh = .01,
      overlap = FALSE, progBar = TRUE)
      
cpmFP(session1, session2, progBar = TRUE)

cpmFPperm(session1, session2, iter = 1000, progBar = TRUE)

cpmPlot(cpm.obj, visual.nets = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpm_+3A_neuralarray">neuralarray</code></td>
<td>
<p>Array from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> function</p>
</td></tr>
<tr><td><code id="cpm_+3A_bstat">bstat</code></td>
<td>
<p>Behavioral statistic for each participant with neural data (a vector)</p>
</td></tr>
<tr><td><code id="cpm_+3A_kfolds">kfolds</code></td>
<td>
<p>Numeric.
Number of <em>k</em>-fold validation samples.
Defaults to the number of participants in the sample (i.e., <em>n</em>),
which is also known as leave-one-out validation.
Recommended folds are <code>5</code> and <code>10</code></p>
</td></tr>
<tr><td><code id="cpm_+3A_covar">covar</code></td>
<td>
<p>Covariates to be included in predicting relevant edges (<strong>time consuming</strong>).
<strong>Must</strong> be input as a <code>list()</code> (see examples)</p>
</td></tr>
<tr><td><code id="cpm_+3A_thresh">thresh</code></td>
<td>
<p>Sets an <code class="reqn">\alpha</code> threshold for edge weights to be retained.
Defaults to <code>.01</code></p>
</td></tr>
<tr><td><code id="cpm_+3A_connections">connections</code></td>
<td>
<p>Character.
Should positive and negative correlations be separated or used together?
Defaults to <code>"separate"</code></p>
</td></tr>
<tr><td><code id="cpm_+3A_groups">groups</code></td>
<td>
<p>Allows grouping variables to be used for plotting points.
<strong>Must</strong> be a vector.
Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="cpm_+3A_method">method</code></td>
<td>
<p>Use <code>"mean"</code> or <code>"sum"</code> of edge strengths in the positive and negative connectomes.
Defaults to <code>"mean"</code></p>
</td></tr>
<tr><td><code id="cpm_+3A_model">model</code></td>
<td>
<p>Regression model to use for fitting the data.
Defaults to <code>"linear"</code></p>
</td></tr>
<tr><td><code id="cpm_+3A_corr">corr</code></td>
<td>
<p>Correlation method for assessing the relationship between the behavioral measure and edges between ROIs.
Defaults to <code>"pearson"</code>.
Set to <code>"spearman"</code> for non-linear or monotonic associations</p>
</td></tr>
<tr><td><code id="cpm_+3A_nedges">nEdges</code></td>
<td>
<p>Number of participants that are required
to have an edge to appear in the plots.
Defaults to 10 percent of edges in participants</p>
</td></tr>
<tr><td><code id="cpm_+3A_standardize">standardize</code></td>
<td>
<p>Should the behavioral statistic (<code>bstat</code>) be standardized?
Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="cpm_+3A_cores">cores</code></td>
<td>
<p>Number of computer processing cores to use when performing covariate analyses.
Defaults to <em>n</em> - 1 total number of cores.
Set to any number between 1 and maximum amount of cores on your computer</p>
</td></tr>
<tr><td><code id="cpm_+3A_progbar">progBar</code></td>
<td>
<p>Should progress bar be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for no progress bar</p>
</td></tr>
<tr><td><code id="cpm_+3A_plots">plots</code></td>
<td>
<p>Should plots be plotted?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to hide plots</p>
</td></tr>
<tr><td><code id="cpm_+3A_train_na">train_na</code></td>
<td>
<p>Training dataset
(an array from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> function)</p>
</td></tr>
<tr><td><code id="cpm_+3A_train_b">train_b</code></td>
<td>
<p>Behavioral statistic for each participant for the <strong>training</strong> neural data (a vector)</p>
</td></tr>
<tr><td><code id="cpm_+3A_valid_na">valid_na</code></td>
<td>
<p>Validation dataset
(an array from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> function)</p>
</td></tr>
<tr><td><code id="cpm_+3A_valid_b">valid_b</code></td>
<td>
<p>Behavioral statistic for each participant for the <strong>validation</strong> neural data (a vector)</p>
</td></tr>
<tr><td><code id="cpm_+3A_overlap">overlap</code></td>
<td>
<p>Should leave-one-out cross-validation be used?
Defaults to <code>FALSE</code> (use full dataset, no leave-one-out).
Set to <code>TRUE</code> to select edges that appear in every leave-one-out cross-validation network (<em>time consuming</em>)</p>
</td></tr>
<tr><td><code id="cpm_+3A_session1">session1</code></td>
<td>
<p>Array from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> function
(first session)</p>
</td></tr>
<tr><td><code id="cpm_+3A_session2">session2</code></td>
<td>
<p>Array from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> function
(second session)</p>
</td></tr>
<tr><td><code id="cpm_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to perform.
Defaults to <code>1000</code></p>
</td></tr>
<tr><td><code id="cpm_+3A_cpm.obj">cpm.obj</code></td>
<td>
<p><code><a href="#topic+cpm">cpm</a></code> object</p>
</td></tr>
<tr><td><code id="cpm_+3A_visual.nets">visual.nets</code></td>
<td>
<p>Boolean.
Uses <code><a href="qgraph.html#topic+qgraph">qgraph</a></code> to plot connectivity
between the networks as a network.
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> to visualize the networks</p>
</td></tr>
<tr><td><code id="cpm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed from a <code>cpm</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cpmIV</code> and <code>cpmEV</code>:
</p>
<p>Returns a list containing:
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>A matrix containing: r coefficient (<code>r</code>), p-value (<code>p-value</code>),
mean absolute error (<code>mae</code>), root mean square error (<code>rmse</code>)</p>
</td></tr>
<tr><td><code>posMask</code></td>
<td>
<p>Positive connectivity for input in
<a href="https://bioimagesuiteweb.github.io/webapp/connviewer.html">BioImage Suite Connectivity Viewer</a></p>
</td></tr>
<tr><td><code>negMask</code></td>
<td>
<p>Negative connectivity for input in
<a href="https://bioimagesuiteweb.github.io/webapp/connviewer.html">BioImage Suite Connectivity Viewer</a></p>
</td></tr>
</table>
<p><code>cpmIVperm</code>:
</p>
<p>Returns a matrix containing <em>p</em>-values for positive and negative prediction models 
</p>
<p><code>cpmFP</code>:
</p>
<p>Returns a matrix containing the percentage
and number of correctly identified subjects for sessions 1 and 2
</p>
<p><code>cpmPlot</code>:
</p>
<p>Returns plot of connectivity differences between the
positive and negative masks
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Beaty, R. E., Kenett, Y. N., Christensen, A. P., Rosenberg, M. D., Benedek, M., Chen, Q.,
Fink, A., Qiu, J., Kwapil, T. R., Kane, M. J., &amp; Silvia, P. J. (2018).
Robust prediction of individual creative ability from brain functional connectivity.
<em>Proceedings of the National Academy of Sciences</em>, <em>115</em>, 1087-1092.
</p>
<p>Finn, E. S., Shen, X., Scheinost, D., Rosenberg, M. D., Huang, J., Chun, M. M., Papademetris, X., Constable, R. T. (2015).
Functional connectome fingerprinting: Identifying individuals using patterns of brain connectivity.
<em>Nature Neuroscience</em>, <em>18</em>, 1664-1671.
</p>
<p>Rosenberg, M. D., Finn, E. S., Scheinost, D., Papademetris, X., Shen, X., Constable, R. T., Chun, M. M. (2016).
A neuromarker of sustained attention from whole-brain functional connectivity.
<em>Nature Neuroscience</em>, <em>19</em>, 165-171.
</p>
<p>Shen, X. Finn, E. S., Scheinost, D., Rosenberg, M. D., Chun, M. M., Papademetris, X., Constable, R. T. (2017).
Using connectome-based predictive modeling to predict individual behavior from brain connectivity.
<em>Nature Protocols</em>, <em>12</em>, 506-518.
</p>
<p>Wei, T. &amp; Simko, V.(2017).
R package &quot;corrplot&quot;: Visualization of a correlation matrix (Version 0.84).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
behav &lt;- behavOpen

## Not run: 

# Create path to temporary file
temp &lt;- tempfile()

# Download to temporary file
googledrive::drive_download(
paste("https://drive.google.com/file/d/",
"1T7_mComB6HPxJxZZwwsLLSYHXsOuvOBt",
"/view?usp=sharing", sep = ""),
path = temp
)

# Load resting state brain data
load(temp)

# Run cpmIV
res &lt;- cpmIV(neuralarray = restOpen, bstat = behav, cores = 4)

# Plot cpmIV results
cpmPlot(res)


## End(Not run)

</code></pre>

<hr>
<h2 id='dCor'>Distance Correlation for ROI Time Series</h2><span id='topic+dCor'></span>

<h3>Description</h3>

<p>Computes the distance correlation (Yoo et al., 2019) for 
ROI time series data. This function is mainly a subroutine for the
<code><a href="#topic+dCor.parallel">dCor.parallel</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCor(neurallist, centering = c("U", "double"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCor_+3A_neurallist">neurallist</code></td>
<td>
<p>List.
A time series list from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> function</p>
</td></tr>
<tr><td><code id="dCor_+3A_centering">centering</code></td>
<td>
<p>Character.
Options for centering the Euclidean distances.
</p>

<ul>
<li><p><code>"U"</code>
Uses number of time points minus 2 in the computation of the mean
</p>
</li>
<li><p><code>"double"</code>
Uses the mean
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <em>m</em> x <em>m</em> matrix corresponding to distance correlations
between ROIs
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Yoo, K., Rosenberg, M. D., Noble, S., Scheinost, D., Constable, R. T., &amp; Chun, M. M. (2019).
Multivariate approaches improve the reliability and validity of functional connectivity and prediction of individual behaviors.
<em>NeuroImage</em>, <em>197</em>, 212-223.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Import time series data
neurallist &lt;- convertConnBrainMat()

# Run distance correlation
dCor(neurallist)


## End(Not run)

</code></pre>

<hr>
<h2 id='dCor.parallel'>Parallelization of Distance Correlation for ROI Time Series</h2><span id='topic+dCor.parallel'></span>

<h3>Description</h3>

<p>Parallelizes the <code><a href="#topic+dCor">dCor</a></code> function
for faster computation times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCor.parallel(neurallist, cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCor.parallel_+3A_neurallist">neurallist</code></td>
<td>
<p>List of lists.
A list containing the time series list from all participants imported from the
<code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> function</p>
</td></tr>
<tr><td><code id="dCor.parallel_+3A_cores">cores</code></td>
<td>
<p>Number of computer processing cores to use when performing covariate analyses.
Defaults to <em>n</em> - 1 total number of cores.
Set to any number between 1 and maximum amount of cores on your computer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <em>m</em> x <em>m</em> x <em>n</em> array corresponding to distance correlations
between ROIs (<em>m</em> x <em>m</em> matrix) for <em>n</em> participants
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Yoo, K., Rosenberg, M. D., Noble, S., Scheinost, D., Constable, R. T., &amp; Chun, M. M. (2019).
Multivariate approaches improve the reliability and validity of functional connectivity and prediction of individual behaviors.
<em>NeuroImage</em>, <em>197</em>, 212-223.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Import time series data 
for(i in 1:5)

# Run distance correlation
dCor.parallel(mat.list, cores = 2)


## End(Not run)

</code></pre>

<hr>
<h2 id='degree'>Degree</h2><span id='topic+degree'></span>

<h3>Description</h3>

<p>Computes degree of each node in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of degree values for each node in the network.
</p>
<p>If directed network, returns a list containing:
</p>
<table>
<tr><td><code>inDegree</code></td>
<td>
<p>Degree of incoming edges (pointing to the node)</p>
</td></tr>
<tr><td><code>outDegree</code></td>
<td>
<p>Degree of outgoing edges (pointing away from the node)</p>
</td></tr>
<tr><td><code>relInf</code></td>
<td>
<p>Relative degree of incoming and outgoing edges.
Positive values indicate more outgoing degree relative to incoming degree.
Negative values indicate more incoming degree relative to outgoing degree</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Undirected network
## Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

deg &lt;- degree(A)

#Directed network
## Not run: 
dep &lt;- depend(neoOpen)

Adep &lt;- TMFG(dep, depend = TRUE)$A

deg &lt;- degree(Adep)

## End(Not run)

</code></pre>

<hr>
<h2 id='depend'>Dependency Network Approach</h2><span id='topic+depend'></span>

<h3>Description</h3>

<p>Generates a dependency matrix of the data (index argument is still in testing phase)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depend(
  data,
  normal = FALSE,
  na.data = c("pairwise", "listwise", "fiml", "none"),
  index = FALSE,
  fisher = FALSE,
  progBar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depend_+3A_data">data</code></td>
<td>
<p>A set of data</p>
</td></tr>
<tr><td><code id="depend_+3A_normal">normal</code></td>
<td>
<p>Should data be transformed to a normal distribution?
Defaults to <code>FALSE</code>. Data is not transformed to be normal.
Set to <code>TRUE</code> if data should be transformed to be normal
(computes correlations using the <a href="qgraph.html#topic+cor_auto">cor_auto</a> function)</p>
</td></tr>
<tr><td><code id="depend_+3A_na.data">na.data</code></td>
<td>
<p>How should missing data be handled?
For <code>"listwise"</code> deletion the <code><a href="stats.html#topic+na.omit">na.omit</a></code> function is applied.
Set to <code>"fiml"</code> for Full Information Maximum Likelihood (<a href="psych.html#topic+corFiml">corFiml</a>).
Full Information Maximum Likelihood is <strong>recommended</strong> but time consuming</p>
</td></tr>
<tr><td><code id="depend_+3A_index">index</code></td>
<td>
<p>Should correlation with the latent variable
(i.e., weighted average of all variables) be removed?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> to remove common latent factor</p>
</td></tr>
<tr><td><code id="depend_+3A_fisher">fisher</code></td>
<td>
<p>Should Fisher's Z-test be used to keep significantly higher influences (index only)?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> to remove non-significant influences</p>
</td></tr>
<tr><td><code id="depend_+3A_progbar">progBar</code></td>
<td>
<p>Should progress bar be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for no progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix of dependencies
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Kenett, D. Y., Tumminello, M., Madi, A., Gur-Gershgoren, G., Mantegna, R. N., &amp; Ben-Jacob, E. (2010).
Dominating clasp of the financial sector revealed by partial correlation analysis of the stock market.
<em>PLoS one</em>, <em>5</em>, e15032.
</p>
<p>Kenett, D. Y., Huang, X., Vodenska, I., Havlin, S., &amp; Stanley, H. E. (2015).
Partial correlation analysis: Applications for financial markets.
<em>Quantitative Finance</em>, <em>15</em>, 569-578.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
D &lt;- depend(neoOpen)

Dindex &lt;- depend(neoOpen, index = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='depna'>Dependency Neural Networks</h2><span id='topic+depna'></span>

<h3>Description</h3>

<p>Applies the dependency network approach to neural network array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depna(neuralarray, cores, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depna_+3A_neuralarray">neuralarray</code></td>
<td>
<p>Array from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> function</p>
</td></tr>
<tr><td><code id="depna_+3A_cores">cores</code></td>
<td>
<p>Numeric.
Number of cores to use in computing results.
Set to <code>1</code> to not use parallel computing.
Recommended to use maximum number of cores minus one</p>
</td></tr>
<tr><td><code id="depna_+3A_...">...</code></td>
<td>
<p>Additional arguments from <code><a href="#topic+depend">depend</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array of n x n x m dependency matrices
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Jacob, Y., Winetraub, Y., Raz, G., Ben-Simon, E., Okon-Singer, H., Rosenberg-Katz, K., ... &amp; Ben-Jacob, E. (2016).
Dependency Network Analysis (DEPNA) reveals context related influence of brain network nodes.
<em>Scientific Reports</em>, <em>6</em>, 27444.
</p>
<p>Kenett, D. Y., Tumminello, M., Madi, A., Gur-Gershgoren, G., Mantegna, R. N., &amp; Ben-Jacob, E. (2010).
Dominating clasp of the financial sector revealed by partial correlation analysis of the stock market.
<em>PLoS one</em>, <em>5</em>, e15032.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neuralarray &lt;- convertConnBrainMat()

dependencyneuralarray &lt;- depna(neuralarray)

## End(Not run)

</code></pre>

<hr>
<h2 id='desc'>Variable Descriptive Statistics</h2><span id='topic+desc'></span>

<h3>Description</h3>

<p>Computes <code>mean</code>, standard deviation (<code>sd</code>), minimum value (<code>min</code>),
maximum value (<code>max</code>),
and univariate normal statistics (<code>normal?</code>) for a variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc(data, column, histplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desc_+3A_data">data</code></td>
<td>
<p>A matrix or data frame</p>
</td></tr>
<tr><td><code id="desc_+3A_column">column</code></td>
<td>
<p>Column name or number in <code>data</code></p>
</td></tr>
<tr><td><code id="desc_+3A_histplot">histplot</code></td>
<td>
<p>A histogram plot of the variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing values for <code>n</code> (number of cases),
<code>missing</code> (number of missing cases), <code>mean</code>, <code>sd</code>, <code>min</code>, and <code>max</code>. <code>normal?</code>
will contain yes/no for whether the variable is normally distributed based
on the <code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code> for a variable
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
desc(neoOpen,1)

</code></pre>

<hr>
<h2 id='desc.all'>Dataset Descriptive Statistics</h2><span id='topic+desc.all'></span>

<h3>Description</h3>

<p>Computes <code>mean</code>, standard deviation (<code>sd</code>), minimum value (<code>min</code>),
maximum value (<code>max</code>),
and univariate normal statistics (<code>normal?</code>) for the entire dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc.all(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desc.all_+3A_data">data</code></td>
<td>
<p>A matrix or data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing values for <code>n</code> (number of cases),
<code>missing</code> (number of missing cases), <code>mean</code>, <code>sd</code>, <code>min</code>, and <code>max</code>. <code>normal?</code>
will contain yes/no for whether the variable is normally distributed based
on the <code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code> for the entire dataset
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
desc.all(neoOpen)

</code></pre>

<hr>
<h2 id='distance'>Distance</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>Computes distance matrix of the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(A, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="distance_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> for weighted measure of distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix of the network
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

#Unweighted
Du &lt;- distance(A)

#Weighted
Dw &lt;- distance(A, weighted = TRUE)

</code></pre>

<hr>
<h2 id='diversity'>Diversity Coefficient</h2><span id='topic+diversity'></span>

<h3>Description</h3>

<p>Computes the diversity coefficient for each node. The diversity
coefficient measures a node's connections to communitites outside of its
own community. Nodes that have many connections to other communities will
have higher diversity coefficient values. Positive and negative signed weights
for diversity coefficients are computed separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity(A, comm = c("walktrap", "louvain"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversity_+3A_a">A</code></td>
<td>
<p>Network adjacency matrix</p>
</td></tr>
<tr><td><code id="diversity_+3A_comm">comm</code></td>
<td>
<p>A vector of corresponding to each item's community.
Defaults to <code>"walktrap"</code> for the <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> community detection algorithm.
Set to <code>"louvain"</code> for the <code><a href="#topic+louvain">louvain</a></code> community detection algorithm.
Can also be set to user-specified communities (see examples)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values closer to 1 suggest greater between-community connectivity and 
values closer to 0 suggest greater within-community connectivity
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>overall</code></td>
<td>
<p>Diversity coefficient without signs considered</p>
</td></tr>
<tr><td><code>positive</code></td>
<td>
<p>Diversity coefficient with only positive sign</p>
</td></tr>
<tr><td><code>negative</code></td>
<td>
<p>Diversity coefficient with only negative sign</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

#theoretical communities
comm &lt;- rep(1:8, each = 6)

gdiv &lt;- diversity(A, comm = comm)

#walktrap communities
wdiv &lt;- diversity(A, comm = "walktrap")

</code></pre>

<hr>
<h2 id='ECO'>ECO Neural Network Filter</h2><span id='topic+ECO'></span>

<h3>Description</h3>

<p>Applies the ECO neural network filtering method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ECO(data, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ECO_+3A_data">data</code></td>
<td>
<p>Can be a dataset or a correlation matrix</p>
</td></tr>
<tr><td><code id="ECO_+3A_directed">directed</code></td>
<td>
<p>Is the network directed?
Defaults to <code>FALSE</code>.
Set <code>TRUE</code> if the network is directed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse association matrix
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Fallani, F. D. V., Latora, V., &amp; Chavez, M. (2017).
A topological criterion for filtering information in complex brain networks.
<em>PLoS Computational Biology</em>, <em>13</em>, e1005305.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eco.net &lt;- ECO(neoOpen)

</code></pre>

<hr>
<h2 id='ECOplusMaST'>ECO+MaST Network Filter</h2><span id='topic+ECOplusMaST'></span>

<h3>Description</h3>

<p>Applies the <code><a href="#topic+ECO">ECO</a></code> neural network filtering method
combined with the <code><a href="#topic+MaST">MaST</a></code> filtering method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ECOplusMaST(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ECOplusMaST_+3A_data">data</code></td>
<td>
<p>Can be a dataset or a correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse association matrix
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Fallani, F. D. V., Latora, V., &amp; Chavez, M. (2017).
A topological criterion for filtering information in complex brain networks.
<em>PLoS Computational Biology</em>, <em>13</em>, e1005305.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># half the variables for CRAN checks
ECOplusMaST.net &lt;- ECOplusMaST(neoOpen[,c(1:24)])

</code></pre>

<hr>
<h2 id='edgerep'>Edge Replication</h2><span id='topic+edgerep'></span>

<h3>Description</h3>

<p>Computes the number of edges that replicate between two cross-sectional networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgerep(A, B, corr = c("pearson", "spearman", "kendall"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgerep_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network A</p>
</td></tr>
<tr><td><code id="edgerep_+3A_b">B</code></td>
<td>
<p>An adjacency matrix of network B</p>
</td></tr>
<tr><td><code id="edgerep_+3A_corr">corr</code></td>
<td>
<p>Correlation method for assessing the relationship between the replicated edge weights.
Defaults to <code>"pearson"</code>.
Set to <code>"spearman"</code> for non-linear or monotonic associations.
Set to <code>"kendall"</code> for rank-order correlations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>replicatedEdges</code></td>
<td>
<p>The edges that replicated and their weights</p>
</td></tr>
<tr><td><code>replicated</code></td>
<td>
<p>Number of edges that replicated</p>
</td></tr>
<tr><td><code>meanDiff</code></td>
<td>
<p>The average edge weight difference between the edges that replicated</p>
</td></tr>
<tr><td><code>sdDiff</code></td>
<td>
<p>The standard deviation edge weight difference between the edges that replicated</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>The correlation between the edges that replicated</p>
</td></tr>
</table>
<p>Lists for each network contain:
</p>
<table>
<tr><td><code>totalEdges</code></td>
<td>
<p>Total possible number of edges to be replicated</p>
</td></tr>
<tr><td><code>percentage</code></td>
<td>
<p>Percentage of edges that replicated relative to total possible</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>The density of the network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># normal set to FALSE for CRAN tests
tmfg &lt;- TMFG(neoOpen, normal = FALSE)$A

# normal set to FALSE for CRAN tests
mast &lt;- MaST(neoOpen, normal = FALSE)

edges &lt;- edgerep(tmfg, mast)

</code></pre>

<hr>
<h2 id='eigenvector'>Eigenvector Centrality</h2><span id='topic+eigenvector'></span>

<h3>Description</h3>

<p>Computes eigenvector centrality of each node in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenvector(A, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenvector_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="eigenvector_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for unweighted measure of eigenvector centrality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of eigenvector centrality values for each node in the network
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

#Weighted
EC &lt;- eigenvector(A)

#Unweighted 
EC &lt;- eigenvector(A, weighted = FALSE)

</code></pre>

<hr>
<h2 id='flow.frac'>Flow Fraction</h2><span id='topic+flow.frac'></span>

<h3>Description</h3>

<p>Computes <code><a href="#topic+eigenvector">eigenvector</a></code> centrality over nodes in a subset of nodes
in the network. This measure generalizes across any subset of nodes and
is not specific to communities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flow.frac(A, nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flow.frac_+3A_a">A</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
<tr><td><code id="flow.frac_+3A_nodes">nodes</code></td>
<td>
<p>A subset of nodes in the network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a flow fraction value
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Giscard, P. L., &amp; Wilson, R. C. (2018).
A centrality measure for cycles and subgraphs II.
<em>Applied Network Science</em>, <em>3</em>, 9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

nodes &lt;- seq(1,48,2)

result &lt;- flow.frac(A, nodes)

</code></pre>

<hr>
<h2 id='gain.functions'>MFCF Gain Functions</h2><span id='topic+gain.functions'></span><span id='topic+gfcnv_logdet'></span><span id='topic+gfcnv_logdet_val'></span><span id='topic+gdcnv_lmfit'></span>

<h3>Description</h3>

<p>These functions maximize a gain criterion
for adding a node to a clique (and the larger network).
The flexibility of <code><a href="#topic+MFCF">MFCF</a></code>
allows for any multivariate function to be used as a
scoring function.
</p>

<ul>
<li><p><code>"logLik"</code>
</p>
<p>The log determinant of the matrix restricted to 
the separator minus the log determinant of the matrix restricted
to the clique.
</p>
</li>
<li><p><code>"logLik.val"</code>
</p>
<p><code>"logLik"</code> with a further validation based on
the likelihood ratio. If the increase in gain is not significant
the routine stops adding nodes to the separator.
</p>
</li>
<li><p><code>"rSquared.val"</code>
</p>
<p>The R squared from the regression of the node against the clique. Only
the clique nodes with a regression coefficient significantly different
from zero are added to the separator / new clique. The gain is different from 
zero only if the F-values is significant, It assumed that the <code>data</code> 
matrix is a dataset of realizations (i.e., <code>p</code>
variables and <code>n</code> observations). 
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>"logLik"
gfcnv_logdet(data, clique_id, cl, excl_nodes, ctreeControl)

"logLik.val"
gfcnv_logdet_val(data, clique_id, cl, excl_nodes, ctreeControl)

"rSquared.val"
gdcnv_lmfit(data, clique_id, cl, excl_nodes, ctreeControl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gain.functions_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Can be a dataset or a correlation matrix</p>
</td></tr>
<tr><td><code id="gain.functions_+3A_clique_id">clique_id</code></td>
<td>
<p>Numeric.
Number corresponding to clique to add another node to</p>
</td></tr>
<tr><td><code id="gain.functions_+3A_cl">cl</code></td>
<td>
<p>List.
List of cliques already assembled in the network</p>
</td></tr>
<tr><td><code id="gain.functions_+3A_excl_nodes">excl_nodes</code></td>
<td>
<p>Numeric vector.
A vector of numbers corresponding to nodes not already
included in the network</p>
</td></tr>
<tr><td><code id="gain.functions_+3A_ctreecontrol">ctreeControl</code></td>
<td>
<p>List (length = 5).
A list containing several parameters for controlling
the clique tree sizes:
</p>

<ul>
<li><p><code>min_size</code>
Numeric. Minimum number of nodes allowed per
clique. Defaults to <code>1</code>
</p>
</li>
<li><p><code>max_size</code>
Numeric. Maximum number of nodes allowed per
clique. Defaults to <code>8</code>
</p>
</li>
<li><p><code>pval</code>
Numeric. <em>p</em>-value used to determine cut-offs for nodes
to include in a clique. Defaults to <code>.05</code>
</p>
</li>
<li><p><code>pen</code>
Numeric. Multiplies the number of edges added to penalize 
complex models. Similar to the penalty term in AIC
</p>
</li>
<li><p><code>drop_sep</code>
Boolean. This parameter influences the MFCF only. If TRUE any
separator can be used only once, as in the TMFG.
</p>
</li>
<li><p><code>use_returns</code>
Boolean. Only used in rSquared.val. If set to TRUE the regression is 
performed on log-returns. Defaults to <code>FALSE</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value with the maximum gain
</p>


<h3>Author(s)</h3>

<p>Guido Previde Massara &lt;gprevide@gmail.com&gt; and Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Massara, G. P. &amp; Aste, T. (2019).
Learning clique forests.
<em>ArXiv</em>.
</p>

<hr>
<h2 id='gateway'>Gateway Coefficient</h2><span id='topic+gateway'></span>

<h3>Description</h3>

<p>Computes the gateway coefficient for each node. The gateway
coefficient measures a node's connections between its community and other communities.
Nodes that are solely responsible for inter-community connectivity will
have higher gateway coefficient values. Positive and negative signed weights
for gateway coefficients are computed separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gateway(
  A,
  comm = c("walktrap", "louvain"),
  cent = c("strength", "betweenness")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gateway_+3A_a">A</code></td>
<td>
<p>Network adjacency matrix</p>
</td></tr>
<tr><td><code id="gateway_+3A_comm">comm</code></td>
<td>
<p>A vector of corresponding to each item's community.
Defaults to <code>"walktrap"</code> for the <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> community detection algorithm.
Set to <code>"louvain"</code> for the <code><a href="#topic+louvain">louvain</a></code> community detection algorithm.
Can also be set to user-specified communities (see examples)</p>
</td></tr>
<tr><td><code id="gateway_+3A_cent">cent</code></td>
<td>
<p>Centrality to community gateway coefficient.
Defaults to <code>"strength"</code>.
Set to <code>"betweenness"</code> to use the <code><a href="#topic+betweenness">betweenness</a></code> centrality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>overall</code></td>
<td>
<p>Gateway coefficient without signs considered</p>
</td></tr>
<tr><td><code>positive</code></td>
<td>
<p>Gateway coefficient with only positive sign</p>
</td></tr>
<tr><td><code>negative</code></td>
<td>
<p>Gateway coefficient with only negative sign</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>
<p>Vargas, E. R., &amp; Wahl, L. M. (2014).
The gateway coefficient: A novel metric for identifying critical connections in modular networks.
<em>The European Physical Journal B</em>, <em>87</em>, 1-10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#theoretical communities
comm &lt;- rep(1:8, each = 6)

# Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

gw &lt;- gateway(A, comm = comm)

#walktrap communities
wgw &lt;- gateway(A, comm = "walktrap")

</code></pre>

<hr>
<h2 id='hybrid'>Hybrid Centrality</h2><span id='topic+hybrid'></span>

<h3>Description</h3>

<p>Computes hybrid centrality of each node in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hybrid(A, BC = c("standard", "random"), beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hybrid_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="hybrid_+3A_bc">BC</code></td>
<td>
<p>How should the betweenness centrality be computed?
Defaults to <code>"random"</code>.
Set to <code>"standard"</code> for standard <code><a href="#topic+betweenness">betweenness</a></code>.</p>
</td></tr>
<tr><td><code id="hybrid_+3A_beta">beta</code></td>
<td>
<p>Beta parameter to be passed to the <code><a href="#topic+rspbc">rspbc</a></code> function
Defaults to .01</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of hybrid centrality values for each node in the network
(higher values are more central, lower values are more peripheral)
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Christensen, A. P., Kenett, Y. N., Aste, T., Silvia, P. J., &amp; Kwapil, T. R. (2018).
Network structure of the Wisconsin Schizotypy Scales-Short Forms:
Examining psychometric network filtering approaches.
<em>Behavior Research Methods</em>, <em>50</em>, 2531-2550.
</p>
<p>Pozzi, F., Di Matteo, T., &amp; Aste, T. (2013).
Spread of risk across financial markets: Better to invest in the peripheries. 
<em>Scientific Reports</em>, <em>3</em>, 1655.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

HC &lt;- hybrid(A)
</code></pre>

<hr>
<h2 id='impact'>Node Impact</h2><span id='topic+impact'></span>

<h3>Description</h3>

<p>Computes impact measure or how much the average distance in the
network changes with that node removed of each node in a network
(<strong>Please see and cite Kenett et al., 2011</strong>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impact(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impact_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of node impact values for each node in the network
(impact &gt; 0, greater ASPL when node is removed; impact &lt; 0,
lower ASPL when node is removed)
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Cotter, K. N., Christensen, A. P., &amp; Silvia, P. J. (in press).
Understanding inner music: A dimensional approach to musical imagery.
<em>Psychology of Aesthetics, Creativity, and the Arts</em>.
</p>
<p>Kenett, Y. N., Kenett, D. Y., Ben-Jacob, E., &amp; Faust, M. (2011).
Global and local features of semantic networks: Evidence from the Hebrew mental lexicon.
<em>PLoS one</em>, <em>6</em>, e23912.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># normal set to FALSE for CRAN tests
A &lt;- TMFG(neoOpen, normal = FALSE)$A

nodeimpact &lt;- impact(A)

</code></pre>

<hr>
<h2 id='is.graphical'>Determines if Network is Graphical</h2><span id='topic+is.graphical'></span>

<h3>Description</h3>

<p>Tests for whether the network is graphical.
Input must be a partial correlation network.
Function assumes that partial correlations were computed from a multivariate normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.graphical(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.graphical_+3A_a">A</code></td>
<td>
<p>A partial correlation network (adjacency matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a TRUE/FALSE for whether network is graphical
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
A &lt;- LoGo(neoOpen, normal = TRUE, partial = TRUE)

is.graphical(A)

## End(Not run)

</code></pre>

<hr>
<h2 id='kld'>Kullback-Leibler Divergence</h2><span id='topic+kld'></span>

<h3>Description</h3>

<p>Estimates the Kullback-Leibler Divergence which measures how one probability distribution
diverges from the original distribution (equivalent means are assumed)
Matrices <strong>must</strong> be positive definite inverse covariance matrix for accurate measurement.
This is a <strong>relative</strong> metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kld(base, test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kld_+3A_base">base</code></td>
<td>
<p>Full or base model</p>
</td></tr>
<tr><td><code id="kld_+3A_test">test</code></td>
<td>
<p>Reduced or testing model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value greater than 0.
Smaller values suggest the probability distribution of the reduced model is near the full model
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Kullback, S., &amp; Leibler, R. A. (1951).
On information and sufficiency.
<em>The Annals of Mathematical Statistics</em>, <em>22</em>, 79-86.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1 &lt;- solve(cov(neoOpen))

## Not run: 
A2 &lt;- LoGo(neoOpen)

kld_value &lt;- kld(A1, A2)

## End(Not run)

</code></pre>

<hr>
<h2 id='lattnet'>Generates a Lattice Network</h2><span id='topic+lattnet'></span>

<h3>Description</h3>

<p>Generates a lattice network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lattnet(nodes, edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lattnet_+3A_nodes">nodes</code></td>
<td>
<p>Number of nodes in lattice network</p>
</td></tr>
<tr><td><code id="lattnet_+3A_edges">edges</code></td>
<td>
<p>Number of edges in lattice network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix of a lattice network
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>latt &lt;- lattnet(10, 27)

</code></pre>

<hr>
<h2 id='leverage'>Leverage Centrality</h2><span id='topic+leverage'></span>

<h3>Description</h3>

<p>Computes leverage centrality of each node in a network
(the degree of connected neighbors; <strong>Please see and cite Joyce et al., 2010</strong>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leverage(A, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leverage_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="leverage_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for unweighted measure of leverage centrality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of leverage centrality values for each node in the network
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Joyce, K. E., Laurienti, P. J., Burdette, J. H., &amp; Hayasaka, S. (2010).
A new measure of centrality for brain networks. 
<em>PLoS One</em>, <em>5</em> e12200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

#Weighted
levW &lt;- leverage(A)

#Unweighted
levU &lt;- leverage(A, weighted = FALSE)

</code></pre>

<hr>
<h2 id='LoGo'>Local/Global Inversion Method</h2><span id='topic+LoGo'></span>

<h3>Description</h3>

<p>Applies the Local/Global method to estimate
a Gaussian Graphical Model (GGM) using a <code><a href="#topic+TMFG">TMFG</a></code>-filtered network
(<strong>see and cite Barfuss et al., 2016</strong>). Also used to 
convert clique and separator structure from
<code><a href="#topic+MFCF">MFCF</a></code> into partial correlation
and precision matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoGo(
  data,
  cliques,
  separators,
  normal = TRUE,
  na.data = c("pairwise", "listwise", "fiml", "none"),
  partial = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoGo_+3A_data">data</code></td>
<td>
<p>Must be a dataset</p>
</td></tr>
<tr><td><code id="LoGo_+3A_cliques">cliques</code></td>
<td>
<p>Cliques defined in the network.
Input can be a list or matrix</p>
</td></tr>
<tr><td><code id="LoGo_+3A_separators">separators</code></td>
<td>
<p>Separators defined in the network.
Input can be a list or matrix</p>
</td></tr>
<tr><td><code id="LoGo_+3A_normal">normal</code></td>
<td>
<p>Should data be transformed to a normal distribution?
Defaults to <code>TRUE</code> (computes correlations using the <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> function).
Set to <code>FALSE</code> for Pearson's correlations</p>
</td></tr>
<tr><td><code id="LoGo_+3A_na.data">na.data</code></td>
<td>
<p>How should missing data be handled?
For <code>"listwise"</code> deletion the <code><a href="stats.html#topic+na.omit">na.omit</a></code> function is applied.
Set to <code>"fiml"</code> for Full Information Maximum Likelihood (<code><a href="psych.html#topic+corFiml">corFiml</a></code>).
Full Information Maximum Likelihood is <strong>recommended</strong> but time consuming</p>
</td></tr>
<tr><td><code id="LoGo_+3A_partial">partial</code></td>
<td>
<p>Should the output network's connections be the partial correlation between two nodes given all other nodes?
Defaults to <code>TRUE</code>, which returns a partial correlation matrix.
Set to <code>FALSE</code> for a sparse inverse covariance matrix</p>
</td></tr>
<tr><td><code id="LoGo_+3A_...">...</code></td>
<td>
<p>Additional arguments (deprecated arguments)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the sparse LoGo-filtered inverse covariance matrix (<code>partial = FALSE</code>)
or LoGo-filtered partial correlation matrix (<code>partial = TRUE</code>)
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Barfuss, W., Massara, G. P., Di Matteo, T., &amp; Aste, T. (2016).
Parsimonious modeling with information filtering networks.
<em>Physical Review E</em>, <em>94</em>, 062306.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># normal set to FALSE for CRAN tests
LoGonet &lt;- LoGo(neoOpen, normal = FALSE, partial = TRUE)

</code></pre>

<hr>
<h2 id='louvain'>Louvain Community Detection Algorithm</h2><span id='topic+louvain'></span>

<h3>Description</h3>

<p>Computes a vector of communities (community) and a global modularity measure (Q)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>louvain(A, gamma, M0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="louvain_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="louvain_+3A_gamma">gamma</code></td>
<td>
<p>Defaults to <code>1</code>.
Set to <code>gamma</code> &gt; 1 to detect smaller modules and <code>gamma</code> &lt; 1 for larger modules</p>
</td></tr>
<tr><td><code id="louvain_+3A_m0">M0</code></td>
<td>
<p>Input can be an initial community vector.
Defaults to <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>community</code></td>
<td>
<p>A community vector corresponding to each node's community</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>Modularity statistic. A measure of how well the communities are compartmentalized</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Blondel, V. D., Guillaume, J. L., Lambiotte, R., &amp; Lefebvre, E. (2008).
Fast unfolding of communities in large networks. 
<em>Journal of Statistical Mechanics: Theory and Experiment</em>, <em>2008</em>, P10008.
</p>
<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

modularity &lt;- louvain(A)

</code></pre>

<hr>
<h2 id='MaST'>Maximum Spanning Tree</h2><span id='topic+MaST'></span>

<h3>Description</h3>

<p>Applies the Maximum Spanning Tree (MaST) filtering method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaST(
  data,
  normal = TRUE,
  na.data = c("pairwise", "listwise", "fiml", "none"),
  depend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaST_+3A_data">data</code></td>
<td>
<p>Can be a dataset or a correlation matrix</p>
</td></tr>
<tr><td><code id="MaST_+3A_normal">normal</code></td>
<td>
<p>Should data be transformed to a normal distribution?
Input must be a dataset.
Defaults to <code>TRUE</code>.
Computes correlations using the <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> function.
Set to <code>FALSE</code> for Pearson's correlation</p>
</td></tr>
<tr><td><code id="MaST_+3A_na.data">na.data</code></td>
<td>
<p>How should missing data be handled?
For <code>"listwise"</code> deletion the <code><a href="stats.html#topic+na.omit">na.omit</a></code> function is applied.
Set to <code>"fiml"</code> for Full Information Maximum Likelihood (<code><a href="psych.html#topic+corFiml">corFiml</a></code>).
Full Information Maximum Likelihood is <strong>recommended</strong> but time consuming</p>
</td></tr>
<tr><td><code id="MaST_+3A_depend">depend</code></td>
<td>
<p>Is network a dependency (or directed) network?
Defaults to <code>FALSE</code>.
Set <code>TRUE</code> to generate a MaST-filtered dependency network
(output obtained from the <code><a href="#topic+depend">depend</a></code> function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse association matrix
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
MaST.net &lt;- MaST(neoOpen, normal = FALSE)

</code></pre>

<hr>
<h2 id='MFCF'>Maximally Filtered Clique Forest</h2><span id='topic+MFCF'></span>

<h3>Description</h3>

<p>Applies the Maximally Filtered Clique Forest (MFCF) filtering method
(<strong>Please see and cite Massara &amp; Aste</strong>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFCF(
  data,
  cases = NULL,
  na.data = c("pairwise", "listwise", "fiml", "none"),
  time.series = FALSE,
  gain.fxn = c("logLik", "logLik.val", "rSquared.val"),
  min_size = 0,
  max_size = 8,
  pval = 0.05,
  pen = 0,
  drop_sep = FALSE,
  use_returns = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MFCF_+3A_data">data</code></td>
<td>
<p>Matrix (n <code>x</code> n or p <code>x</code> n) or data frame.
Can be a dataset or a correlation matrix</p>
</td></tr>
<tr><td><code id="MFCF_+3A_cases">cases</code></td>
<td>
<p>Numeric. If <code>data</code> is a (partial) correlation
matrix, then number of cases must be input.
Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="MFCF_+3A_na.data">na.data</code></td>
<td>
<p>Character.
How should missing data be handled?
</p>

<ul>
<li><p><code>"listwise"</code>
Removes case if <strong>any</strong> missing data exists.
Applies <code><a href="stats.html#topic+na.omit">na.omit</a></code>
</p>
</li>
<li><p><code>"pairwise"</code>
Estimates correlations using the available data
for each variable
</p>
</li>
<li><p><code>"fiml"</code>
Estimates correlations using the Full Information
Maximum Likelihood. Recommended and most robust but time consuming
</p>
</li>
<li><p><code>"none"</code>
Default. No missing data or missing data has been
handled by the user
</p>
</li></ul>
</td></tr>
<tr><td><code id="MFCF_+3A_time.series">time.series</code></td>
<td>
<p>Boolean.
Is <code>data</code> a time-series dataset?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> to handle time-series data (n <code>x</code> p)</p>
</td></tr>
<tr><td><code id="MFCF_+3A_gain.fxn">gain.fxn</code></td>
<td>
<p>Character.
Gain function to be used for inclusion of nodes in cliques.
There are several options available
(see <code><a href="#topic+gain.functions">gain.functions</a></code> for more details):
<code>"logLik"</code>, <code>"logLik.val"</code>, <code>"rSquared.val"</code>.
Defaults to <code>"rSquared.val"</code></p>
</td></tr>
<tr><td><code id="MFCF_+3A_min_size">min_size</code></td>
<td>
<p>Numeric. Minimum number of nodes allowed per
clique. Defaults to <code>0</code></p>
</td></tr>
<tr><td><code id="MFCF_+3A_max_size">max_size</code></td>
<td>
<p>Numeric. Maximum number of nodes allowed per
clique. Defaults to <code>8</code></p>
</td></tr>
<tr><td><code id="MFCF_+3A_pval">pval</code></td>
<td>
<p>Numeric. <em>p</em>-value used to determine cut-offs for nodes
to include in a clique</p>
</td></tr>
<tr><td><code id="MFCF_+3A_pen">pen</code></td>
<td>
<p>Numeric. Multiplies the number of edges added to penalise 
complex models. Similar to the penalty term in AIC</p>
</td></tr>
<tr><td><code id="MFCF_+3A_drop_sep">drop_sep</code></td>
<td>
<p>Boolean. This parameter influences the MFCF only.
Defaults to <code>FALSE</code>.
If <code>TRUE</code>, then any separator can be used only once (similar
to the <code><a href="#topic+TMFG">TMFG</a></code>)</p>
</td></tr>
<tr><td><code id="MFCF_+3A_use_returns">use_returns</code></td>
<td>
<p>Boolean. Only used in <code>"gain.fxn = rSquared.val"</code>.
If set to <code>TRUE</code> the regression is 
performed on log-returns.
Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>MFCF filtered partial correlation network (adjacency matrix)</p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>MFCF filtered inverse covariance matrix (precision matrix)</p>
</td></tr>
<tr><td><code>cliques</code></td>
<td>
<p>Cliques in the network
(output for <code><a href="#topic+LoGo">LoGo</a></code>)</p>
</td></tr>
<tr><td><code>separators</code></td>
<td>
<p>Separators in the network
(output for <code><a href="#topic+LoGo">LoGo</a></code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guido Previde Massara &lt;gprevide@gmail.com&gt; and Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Massara, G. P. &amp; Aste, T. (2019).
Learning clique forests.
<em>ArXiv</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- neoOpen

## Not run:  
# Use polychoric correlations and R-squared method
MFCF.net &lt;- MFCF(qgraph::cor_auto(data), cases = nrow(neoOpen))$A


## End(Not run)

</code></pre>

<hr>
<h2 id='neoOpen'>NEO-PI-3 Openness to Experience Data</h2><span id='topic+neoOpen'></span>

<h3>Description</h3>

<p>A response matrix (<em>n</em> = 802) of NEO-PI-3's Openness to Experience
from Christensen, Cotter, &amp; Silvia (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neoOpen)
</code></pre>


<h3>Format</h3>

<p>A 802x48 response matrix
</p>


<h3>References</h3>

<p>Christensen, A. P., Cotter, K. N., &amp; Silvia, P. J. (2019).
Reopening openness to experience: A network analysis of four openness to experience inventories.
<em>Journal of Personality Assessment</em>, <em>101</em>, 574-588.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("neoOpen")

</code></pre>

<hr>
<h2 id='net.coverage'>Network Coverage</h2><span id='topic+net.coverage'></span>

<h3>Description</h3>

<p>Computes the mean distance across a subset of nodes in a network.
This measure can be used to identify the effectiveness of a subset of nodes'
coverage of the network space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.coverage(A, nodes, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.coverage_+3A_a">A</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
<tr><td><code id="net.coverage_+3A_nodes">nodes</code></td>
<td>
<p>Subset of nodes to examine the coverage of the network</p>
</td></tr>
<tr><td><code id="net.coverage_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> for weighted measures</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>The average distance from the subset of nodes to all other nodes in the network</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>The standard deviation of distance from the subset of nodes to all other nodes in the network</p>
</td></tr>
<tr><td><code>range</code></td>
<td>
<p>The range of distance from the subset of nodes to all other nodes in the network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt; and
Mathias Benedek &lt;mathias.benedek@uni-graz.at&gt;
</p>


<h3>References</h3>

<p>Christensen, A. P., Cotter, K. N., Silvia, P. J., &amp; Benedek, M. (2018)
Scale development via network analysis: A comprehensive and concise measure of Openness to Experience
<em>PsyArXiv</em>, 1-40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

nodes &lt;- seq(1,48,2)

result &lt;- net.coverage(A, nodes)

</code></pre>

<hr>
<h2 id='network.coverage'>Network Coverage</h2><span id='topic+network.coverage'></span>

<h3>Description</h3>

<p>Computes the mean distance across a subset of nodes in a network.
This measure can be used to identify the effectiveness of a subset of nodes'
coverage of the network space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.coverage(A, nodes, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.coverage_+3A_a">A</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
<tr><td><code id="network.coverage_+3A_nodes">nodes</code></td>
<td>
<p>Subset of nodes to examine the coverage of the network</p>
</td></tr>
<tr><td><code id="network.coverage_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> for weighted measures</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>The average distance from the subset of nodes to all other nodes in the network</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>The standard deviation of distance from the subset of nodes to all other nodes in the network</p>
</td></tr>
<tr><td><code>range</code></td>
<td>
<p>The range of distance from the subset of nodes to all other nodes in the network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt; and Mathias Benedek &lt;mathias.benedek@uni-graz.at&gt;
</p>


<h3>References</h3>

<p>Christensen, A. P., Cotter, K. N., Silvia, P. J., &amp; Benedek, M. (2018)
Scale development via network analysis: A comprehensive and concise measure of Openness to Experience
<em>PsyArXiv</em>, 1-40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

nodes &lt;- seq(1,48,2)

result &lt;- network.coverage(A, nodes)

</code></pre>

<hr>
<h2 id='network.permutation'>Permutation Test for Network Measures</h2><span id='topic+network.permutation'></span>

<h3>Description</h3>

<p>Computes a permutation test to determine whether
there are difference in centrality and global network measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.permutation(
  sample1 = NULL,
  sample2 = NULL,
  iter,
  network = c("glasso", "ising", "TMFG", "LoGo"),
  measure = c("betweenness", "closeness", "strength", "eigenvector", "rspbc", "hybrid",
    "ASPL", "CC", "S", "Q"),
  alternative = c("less", "greater", "two.tailed"),
  ncores,
  prev.perm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.permutation_+3A_sample1">sample1</code></td>
<td>
<p>Matrix or data frame.
Sample to be compared with <code>sample2</code></p>
</td></tr>
<tr><td><code id="network.permutation_+3A_sample2">sample2</code></td>
<td>
<p>Matrix or data frame.
Sample to be compared with <code>sample1</code></p>
</td></tr>
<tr><td><code id="network.permutation_+3A_iter">iter</code></td>
<td>
<p>Numeric.
Number of iterations to perform.
Defaults to <code>1000</code></p>
</td></tr>
<tr><td><code id="network.permutation_+3A_network">network</code></td>
<td>
<p>Character.
Network estimation method to apply to the datasets.
Defaults to <code>"glasso"</code></p>
</td></tr>
<tr><td><code id="network.permutation_+3A_measure">measure</code></td>
<td>
<p>Character.
Network measure to be compared in the permutation test</p>
</td></tr>
<tr><td><code id="network.permutation_+3A_alternative">alternative</code></td>
<td>
<p>Character.
Alternative hypothesis test to perform.
Defaults to <code>"two.tailed"</code></p>
</td></tr>
<tr><td><code id="network.permutation_+3A_ncores">ncores</code></td>
<td>
<p>Numeric.
Number of computer processing cores to use for bootstrapping samples.
Defaults to <em>n</em> - 1 total number of cores.
Set to any number between 1 and maximum amount of cores on your computer
(see <code>parellel::detectCores()</code>)</p>
</td></tr>
<tr><td><code id="network.permutation_+3A_prev.perm">prev.perm</code></td>
<td>
<p><code>network.permutation</code> class object.
An object of previously performed permutation test. The
networks generated in the previous permutation will be
used to compute other network measures. This saves time
when computing multiple permutation tests</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing two objects:
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>The results of the permutation test. For centrality measures,
this is a matrix where the rows represent each node and the columns are
the observed values of the centrality measure for <code>sample1</code>, <code>sample2</code>,
and the <em>p</em>-value from the permutation test. For global network measures,
this is a vector with the observed values of the global network measure for
<code>sample1</code>, <code>sample2</code>, and the <em>p</em>-value from the permutation test.</p>
</td></tr>
<tr><td><code>networks</code></td>
<td>
<p>A list containing two lists: <code>network1</code> and <code>network2</code>.
The network lists correspond to the networks generated in the permutation test
for <code>sample1</code> and <code>sample2</code>, respectively. This output is used primarily
for the computation of other network measures using the same datasets
(see <code>prev.perm</code> explanation)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split data (only for example)
split1 &lt;- neoOpen[c(1:401),]
split2 &lt;- neoOpen[c(402:802),]


# Perform permutation test
perm.str &lt;- network.permutation(split1, split2, iter = 1000, network = "glasso",
measure = "strength", alternative = "two.tailed", ncores = 2)

# Check results
perm.str$result

# Permutation to check other measures (using networks from previous result)
perm.aspl &lt;- network.permutation(prev.perm = perm.str, measure = "ASPL", ncores = 2)

# Check results
perm.aspl$result

</code></pre>

<hr>
<h2 id='neuralnetfilter'>Neural Network Filter</h2><span id='topic+neuralnetfilter'></span>

<h3>Description</h3>

<p>Applies a network filtering methodology to neural network array.
Removes edges from the neural network output from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> 
using a network filtering approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neuralnetfilter(
  neuralarray,
  method = c("TMFG", "MaST", "ECOplusMaST", "ECO", "threshold"),
  progBar = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neuralnetfilter_+3A_neuralarray">neuralarray</code></td>
<td>
<p>Array from <code><a href="#topic+convertConnBrainMat">convertConnBrainMat</a></code> function</p>
</td></tr>
<tr><td><code id="neuralnetfilter_+3A_method">method</code></td>
<td>
<p>Filtering method to be applied</p>
</td></tr>
<tr><td><code id="neuralnetfilter_+3A_progbar">progBar</code></td>
<td>
<p>Should progress bar be displayed?
Defaults to <code>TRUE</code>.
Set <code>FALSE</code> for no progress bar</p>
</td></tr>
<tr><td><code id="neuralnetfilter_+3A_...">...</code></td>
<td>
<p>Additional arguments from network filtering methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array of n x n x m filtered matrices
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: neuralarray &lt;- convertConnBrainMat()

filteredneuralarray &lt;- neuralnetfilter(neuralarray, method = "threshold", thresh = .50)

dependencyarray &lt;- depna(neuralarray)

filtereddependencyarray &lt;- neuralnetfilter(dependencyarray, method = "TMFG", depend = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='openness'>Four Inventories of Openness to Experience</h2><span id='topic+openness'></span><span id='topic+openness.key'></span>

<h3>Description</h3>

<p>A response matrix (<em>n</em> = 794) of all four Openness to Experience
inventories from Christensen, Cotter, &amp; Silvia (2019). The
key provides inventory, facet, and item description information
for the item labels. Note that because of NEO's copyrights the
items have been shortened and paraphrased
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(openness)

data(openness.key)
</code></pre>


<h3>Format</h3>

<p>A 794 x 138 response matrix (openness) and 138 x 7 matrix (openness.key).
Here are detailed descriptions of the key:
</p>

<ul>
<li><p><code>Inventory</code>
The personality inventory the item belongs to
</p>
</li>
<li><p><code>Facet</code>
The personality inventory defined facet
</p>
</li>
<li><p><code>JPA.Domains</code>
The broad domains identified by Christensen, Cotter, and Silvia (2019)
</p>
</li>
<li><p><code>JPA.Facets</code>
The facets identified by Christensen, Cotter, and Silvia (2019)
</p>
</li>
<li><p><code>Item.Label</code>
The labels used in Christensen, Cotter, and Silvia (2019)
</p>
</li>
<li><p><code>Item.Description</code>
Descriptions of each item. Note that the NEO-PI-3 items are protected by 
copyright and therefore have been paraphrased. These item descriptions
do not represent the item as given to the participant
</p>
</li>
<li><p><code>Reversed</code>
Whether an item should be reversed or not (<code>openness</code> is already reversed)
</p>
</li></ul>



<h3>References</h3>

<p>Christensen, A. P., Cotter, K. N., &amp; Silvia, P. J. (2019).
Reopening openness to experience: A network analysis of four openness to experience inventories.
<em>Journal of Personality Assessment</em>, <em>101</em>, 574-588.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading data
data("openness")
data("openness.key")

# Change item labels
colnames(openness) &lt;- openness.key$Item.Description

</code></pre>

<hr>
<h2 id='participation'>Participation Coefficient</h2><span id='topic+participation'></span>

<h3>Description</h3>

<p>Computes the participation coefficient for each node. The participation
coefficient measures the strength of a node's connections within its community. Positive
and negative signed weights for participation coefficients are computed separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>participation(A, comm = c("walktrap", "louvain"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="participation_+3A_a">A</code></td>
<td>
<p>Network adjacency matrix</p>
</td></tr>
<tr><td><code id="participation_+3A_comm">comm</code></td>
<td>
<p>A vector of corresponding to each item's community.
Defaults to <code>"walktrap"</code> for the <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> community detection algorithm.
Set to <code>"louvain"</code> for the <code><a href="#topic+louvain">louvain</a></code> community detection algorithm.
Can also be set to user-specified communities (see examples)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values closer to 1 suggest greater within-community connectivity and 
values closer to 0 suggest greater between-community connectivity
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>overall</code></td>
<td>
<p>Participation coefficient without signs considered</p>
</td></tr>
<tr><td><code>positive</code></td>
<td>
<p>Participation coefficient with only positive sign</p>
</td></tr>
<tr><td><code>negative</code></td>
<td>
<p>Participation coefficient with only negative sign</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Guimera, R., &amp; Amaral, L. A. N. (2005).
Functional cartography of complex metabolic networks.
<em>Nature</em>, <em>433</em>, 895-900.
</p>
<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#theoretical factors
comm &lt;- rep(1:8, each = 6)

# Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

pc &lt;- participation(A, comm = comm)

# Walktrap factors
wpc &lt;- participation(A, comm = "walktrap")

</code></pre>

<hr>
<h2 id='pathlengths'>Characteristic Path Lengths</h2><span id='topic+pathlengths'></span>

<h3>Description</h3>

<p>Computes global average shortest path length,
local average shortest path length, eccentricity,
and diameter of a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathlengths(A, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathlengths_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="pathlengths_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> for weighted measures</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>ASPL</code></td>
<td>
<p>Global average shortest path length</p>
</td></tr>
<tr><td><code>ASPLi</code></td>
<td>
<p>Local average shortest path length</p>
</td></tr>
<tr><td><code>ecc</code></td>
<td>
<p>Eccentricity (i.e., maximal shortest path length between a node and any other node)</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Diameter of the network (i.e., the maximum of eccentricity)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

#Unweighted
PL &lt;- pathlengths(A)

#Weighted
PL &lt;- pathlengths(A, weighted = TRUE)

</code></pre>

<hr>
<h2 id='plot.cpm'>Plots CPM results</h2><span id='topic+plot.cpm'></span>

<h3>Description</h3>

<p>Plots CPM results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cpm_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+cpm">cpm</a></code> object</p>
</td></tr>
<tr><td><code id="plot.cpm_+3A_...">...</code></td>
<td>
<p>Additional arguments for <a href="base.html#topic+plot">plot</a></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>

<hr>
<h2 id='randnet'>Generates a Random Network</h2><span id='topic+randnet'></span>

<h3>Description</h3>

<p>Generates a random binary network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randnet(nodes = NULL, edges = NULL, A = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randnet_+3A_nodes">nodes</code></td>
<td>
<p>Numeric.
Number of nodes in random network</p>
</td></tr>
<tr><td><code id="randnet_+3A_edges">edges</code></td>
<td>
<p>Numeric.
Number of edges in random network</p>
</td></tr>
<tr><td><code id="randnet_+3A_a">A</code></td>
<td>
<p>Matrix or data frame.
An adjacency matrix (i.e., network) to be used to estimated a random network with
fixed edges (allows for asymmetric network estimation)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix of a random network
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>
<p>Csardi, G., &amp; Nepusz, T. (2006).
The <em>igraph</em> software package for complex network research.
<em>InterJournal, Complex Systems</em>, 1695.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rand &lt;- randnet(10, 27)

</code></pre>

<hr>
<h2 id='reg'>Regression Matrix</h2><span id='topic+reg'></span>

<h3>Description</h3>

<p>Computes regression such that one variable is regressed over all other variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg(
  data,
  family = c("binomial", "gaussian", "Gamma", "poisson"),
  symmetric = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reg_+3A_data">data</code></td>
<td>
<p>A dataset</p>
</td></tr>
<tr><td><code id="reg_+3A_family">family</code></td>
<td>
<p>Error distribution to be used in the regression model.
Defaults to <code>"logistic"</code>.
Set to any family used in function <code><a href="stats.html#topic+family">family</a></code></p>
</td></tr>
<tr><td><code id="reg_+3A_symmetric">symmetric</code></td>
<td>
<p>Should matrix be symmetric?
Defaults to <code>TRUE</code>, taking the mean of the two edge weights
(i.e., <code>[i,j]</code> and <code>[j,i]</code>)
Set to <code>FALSE</code> for asymmetric weights
(i.e., <code>[i,j]</code> does not equal <code>[j,i]</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of fully regressed coefficients where
one variable is regressed over all others
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#binarize responses
psyb &lt;- ifelse(neoOpen&gt;=4, 1, 0)

#perform logistic regression
mat &lt;- reg(psyb)

</code></pre>

<hr>
<h2 id='resp.rep'>Repeated Responses Check</h2><span id='topic+resp.rep'></span>

<h3>Description</h3>

<p>Screens data to identify potential cases of repeated responding.
The function is based on two criteria: no variance (i.e., a standard
deviation of zero for given responses)and frequency proportion of the 
response values (which is set by <code>freq.prop</code>). Note that these
criteria are highly related. Additional criteria will be added in 
the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp.rep(data, scale.lens = NULL, max.val, reverse = NULL, freq.prop = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resp.rep_+3A_data">data</code></td>
<td>
<p>A dataset</p>
</td></tr>
<tr><td><code id="resp.rep_+3A_scale.lens">scale.lens</code></td>
<td>
<p>The number of items for each scale in the data.
A vector indicating the length for each scale to be checked in the data</p>
</td></tr>
<tr><td><code id="resp.rep_+3A_max.val">max.val</code></td>
<td>
<p>Maximum value for data (or scales).
If scales have different maximum values, then a vector must be
input with each scale's maximum value (see examples)</p>
</td></tr>
<tr><td><code id="resp.rep_+3A_reverse">reverse</code></td>
<td>
<p>Reverse scored responses.
If responses have not yet reversed, then do not reverse them.
If responses have been reversed, then a vector indicating
which responses have been reverse-scored should be input (see examples).
Can be TRUE/FALSE or 1/0 (reversed/not reversed)</p>
</td></tr>
<tr><td><code id="resp.rep_+3A_freq.prop">freq.prop</code></td>
<td>
<p>Frequency proportion of the response values.
Allows the researcher to determine the maximum frequency proportion
of a certain response value is suspicious.
The default is set to <code>.80</code> (or 80 percent responses are a single value)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a case is returned, then it does not mean that it is a bad case.
Researchers should thoroughly inspect each case that is returned.
A general guideline is that if a participant responded with all middle
values (e.g., all 3's on a 5-point Likert scale), then they should be
dropped. Note that a participant who responds with all maximum or
minimum values may be a real case or a bad case. It is up to the
researcher to decide and justify why or why not a case is kept.
</p>


<h3>Value</h3>

<p>Returns a matrix when <code>scale.lens = NULL</code> and a
list with elements corresponding to the order of scales. In general,
the output contains potential bad cases that should be further
inspected by the researcher.
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Re-reverse responses
rev.vec &lt;- c(TRUE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,TRUE,FALSE,
TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,TRUE,FALSE,TRUE,
FALSE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,TRUE,FALSE,TRUE,
FALSE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE)

#Maximum value (5-point Likert scale)
mv.vec &lt;- 5

#Repeated responses check
resp.rep(neoOpen, reverse = rev.vec, max.val = mv.vec)

#Example with multiple scales

#Facet scale lengths of NEO-PI-3 Openness to Experience
s.len &lt;- c(8, 8, 8, 8, 8, 8)

#Maximum values
mv.vec &lt;- c(5, 5, 5, 5, 5, 5)

#Re-reverse responses
rev.vec &lt;- c(TRUE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,TRUE,FALSE,
TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,TRUE,FALSE,TRUE,
FALSE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,TRUE,FALSE,TRUE,
FALSE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE)

#Repeated responses check
resp.rep(neoOpen, scale.lens = s.len, max.val = mv.vec, reverse = rev.vec)

</code></pre>

<hr>
<h2 id='rmse'>Root Mean Square Error</h2><span id='topic+rmse'></span>

<h3>Description</h3>

<p>Computes the root mean square error (RMSE) of a sparse model to a full model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(base, test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmse_+3A_base">base</code></td>
<td>
<p>Base (or full) model to be evaluated against</p>
</td></tr>
<tr><td><code id="rmse_+3A_test">test</code></td>
<td>
<p>Reduced (or testing) model (e.g., a sparse correlation or covariance matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RMSE value (lower values suggest more similarity between the full and sparse model)
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1 &lt;- solve(cov(neoOpen))

## Not run: 
A2 &lt;- LoGo(neoOpen)

root &lt;- rmse(A1, A2)

## End(Not run)

</code></pre>

<hr>
<h2 id='rspbc'>Randomized Shortest Paths Betweenness Centrality</h2><span id='topic+rspbc'></span>

<h3>Description</h3>

<p>Computes betweenness centrality based on randomized shortest paths
of each node in a network
(<strong>Please see and cite Kivimaki et al., 2016</strong>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspbc(A, beta = 0.01, comm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspbc_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="rspbc_+3A_beta">beta</code></td>
<td>
<p>Sets the beta parameter.
Defaults to <code>0.01</code> (recommended).
Beta &gt; 0.01 measure gets closer to weighted
betweenness centrality (10) and beta &lt; 0.01
measure gets closer to degree (.0001)</p>
</td></tr>
<tr><td><code id="rspbc_+3A_comm">comm</code></td>
<td>
<p>Vector.
Community vector containing a value for each node.
Computes &quot;bridge&quot; RSPBC, where the number of times
a node is used on a random path between to another community</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of randomized shortest paths betweenness
centrality values for each node in the network
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Kivimaki, I., Lebichot, B., Saramaki, J., &amp; Saerens, M. (2016).
Two betweenness centrality measures based on Randomized Shortest Paths.
<em>Scientific Reports</em>, <em>6</em>, 19668.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

rspbc &lt;- rspbc(A, beta=0.01)

</code></pre>

<hr>
<h2 id='sim.chordal'>Simulate Chordal Network</h2><span id='topic+sim.chordal'></span>

<h3>Description</h3>

<p>Simulates a chordal network based on number of nodes.
Data will also be simulated based on the true network structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.chordal(
  nodes,
  inverse = c("cases", "matrix"),
  n = NULL,
  ordinal = FALSE,
  ordLevels = NULL,
  idio = NULL,
  eps = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.chordal_+3A_nodes">nodes</code></td>
<td>
<p>Numeric.
Number of nodes in the simulated network</p>
</td></tr>
<tr><td><code id="sim.chordal_+3A_inverse">inverse</code></td>
<td>
<p>Character.
Method to produce inverse covariance matrix.
</p>

<ul>
<li><p><code>"cases"</code>Estimates inverse covariance matrix
based on <code>n</code> number of cases and <code>nodes</code> number of
variables, which are drawn from a random normal distribution
<code><a href="stats.html#topic+rnorm">rnorm</a></code>. Data generated will be continuous unless
<code>ordinal</code> is set to <code>TRUE</code>
</p>
</li>
<li><p><code>"matrix"</code>Estimates inverse covariance matrix
based on ??eps??
</p>
</li></ul>
</td></tr>
<tr><td><code id="sim.chordal_+3A_n">n</code></td>
<td>
<p>Numeric.
Number of cases in the simulated dataset</p>
</td></tr>
<tr><td><code id="sim.chordal_+3A_ordinal">ordinal</code></td>
<td>
<p>Boolean.
Should simulated continuous data be converted to ordinal?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> for simulated ordinal data</p>
</td></tr>
<tr><td><code id="sim.chordal_+3A_ordlevels">ordLevels</code></td>
<td>
<p>Numeric.
If <code>ordinal = TRUE</code>, then how many levels should be used?
Defaults to <code>5</code>.
Set to desired number of intervals</p>
</td></tr>
<tr><td><code id="sim.chordal_+3A_idio">idio</code></td>
<td>
<p>Numeric.
DESCRIPTION.
Defaults to <code>0.10</code></p>
</td></tr>
<tr><td><code id="sim.chordal_+3A_eps">eps</code></td>
<td>
<p>Numeric.
DESCRIPTION.
Defaults to <code>2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing: 
</p>
<table>
<tr><td><code>cliques</code></td>
<td>
<p>The cliques in the network</p>
</td></tr>
<tr><td><code>separators</code></td>
<td>
<p>The separators in the network</p>
</td></tr>
<tr><td><code>inverse</code></td>
<td>
<p>Simulated inverse covariance matrix of the network</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Simulated data from sim.correlation in the <code><a href="psych.html#topic+psych">psych</a></code>
package based on the simulated network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guido Previde Massara &lt;gprevide@gmail.com&gt;
</p>


<h3>References</h3>

<p>Massara, G. P. &amp; Aste, T. (2019).
Learning clique forests.
<em>ArXiv</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Continuous data
sim.Norm &lt;- sim.chordal(nodes = 20, inverse = "cases", n = 1000)

#Ordinal data
sim.Likert &lt;- sim.chordal(nodes = 20, inverse = "cases", n = 1000, ordinal = TRUE)

#Dichotomous data
sim.Binary &lt;- sim.chordal(nodes = 20, inverse = "cases", n = 1000, ordinal = TRUE, ordLevels = 5)

</code></pre>

<hr>
<h2 id='sim.swn'>Simulate Small-world Network</h2><span id='topic+sim.swn'></span>

<h3>Description</h3>

<p>Simulates a small-world network based on specified topological properties.
Data will also be simulated based on the true network structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.swn(
  nodes,
  n,
  pos = 0.8,
  ran = c(0.3, 0.7),
  nei = 1,
  p = 0.5,
  corr = FALSE,
  replace = NULL,
  ordinal = FALSE,
  ordLevels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.swn_+3A_nodes">nodes</code></td>
<td>
<p>Number of nodes in the simulated network</p>
</td></tr>
<tr><td><code id="sim.swn_+3A_n">n</code></td>
<td>
<p>Number of cases in the simulated dataset</p>
</td></tr>
<tr><td><code id="sim.swn_+3A_pos">pos</code></td>
<td>
<p>Proportion of positive correlations in the simulated network</p>
</td></tr>
<tr><td><code id="sim.swn_+3A_ran">ran</code></td>
<td>
<p>Range of correlations in the simulated network</p>
</td></tr>
<tr><td><code id="sim.swn_+3A_nei">nei</code></td>
<td>
<p>Adjusts the number of connections each node has to
neighboring nodes (see <code><a href="igraph.html#topic+sample_smallworld">sample_smallworld</a></code>)</p>
</td></tr>
<tr><td><code id="sim.swn_+3A_p">p</code></td>
<td>
<p>Adjusts the rewiring probability (default is .5).
p &gt; .5 rewires the simulated network closer to a random network.
p &lt; .5 rewires the simulated network closer to a lattice network</p>
</td></tr>
<tr><td><code id="sim.swn_+3A_corr">corr</code></td>
<td>
<p>Should the simulated network be a correlation network?
Defaults to FALSE.
Set to TRUE for a simulated correlation network</p>
</td></tr>
<tr><td><code id="sim.swn_+3A_replace">replace</code></td>
<td>
<p>If noise &gt; 0, then should participants be sampled with replacement?
Defaults to TRUE.
Set to FALSE to not allow the potential for participants to be consecutively entered
into the simulated dataset.</p>
</td></tr>
<tr><td><code id="sim.swn_+3A_ordinal">ordinal</code></td>
<td>
<p>Should simulated continuous data be converted to ordinal?
Defaults to FALSE.
Set to TRUE for simulated ordinal data</p>
</td></tr>
<tr><td><code id="sim.swn_+3A_ordlevels">ordLevels</code></td>
<td>
<p>If ordinal = TRUE, then how many levels should be used?
Defaults to NULL.
Set to desired number of intervals (defaults to 5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing: 
</p>
<table>
<tr><td><code>simNetwork</code></td>
<td>
<p>Adjacency matrix of the simulated network</p>
</td></tr>
<tr><td><code>simData</code></td>
<td>
<p>Simulated data from sim.correlation in the <code><a href="psych.html#topic+psych">psych</a></code> package
based on the simulated network</p>
</td></tr>
<tr><td><code>simRho</code></td>
<td>
<p>Simulated correlation from sim.correlation in the <code><a href="psych.html#topic+psych">psych</a></code> package</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Csardi, G., &amp; Nepusz, T. (2006).
The <em>igraph</em> software package for complex network research.
<em>InterJournal, Complex Systems</em>, <em>1695</em>, 1-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Continuous data
sim.Norm &lt;- sim.swn(25, 500, nei = 3)

#Ordinal data
sim.Likert &lt;- sim.swn(25, 500, nei = 3, replace = TRUE, ordinal = TRUE, ordLevels = 5)

#Dichotomous data
sim.Binary &lt;- sim.swn(25, 500, nei = 3, replace = TRUE, ordinal = TRUE, ordLevels = 2)

</code></pre>

<hr>
<h2 id='smallworldness'>Small-worldness Measure</h2><span id='topic+smallworldness'></span>

<h3>Description</h3>

<p>Computes the small-worldness measure of a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smallworldness(
  A,
  iter = 100,
  progBar = FALSE,
  method = c("HG", "rand", "TJHBL")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smallworldness_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="smallworldness_+3A_iter">iter</code></td>
<td>
<p>Number of random (or lattice) networks to generate,
which are used to calculate the mean random ASPL and CC (or lattice)</p>
</td></tr>
<tr><td><code id="smallworldness_+3A_progbar">progBar</code></td>
<td>
<p>Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> to see progress bar</p>
</td></tr>
<tr><td><code id="smallworldness_+3A_method">method</code></td>
<td>
<p>Defaults to <code>"HG"</code> (Humphries &amp; Gurney, 2008).
Set to <code>"rand"</code> for the CC to be calculated using a random network or
set to <code>"TJHBL"</code> for (Telesford et al., 2011) where CC is calculated from a lattice network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>"rand"</code>, values &gt; 1 indicate a small-world network.
For <code>"HG"</code>, values &gt; 3 indicate a small-world network.
For <code>"TJHBL"</code>, values near 0 indicate a small-world network,
while &lt; 0 indicates a more regular network and &gt; 0 indicates a more random network
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>swm</code></td>
<td>
<p>Small-worldness value</p>
</td></tr>
<tr><td><code>rASPL</code></td>
<td>
<p>Global average shortest path length from random network</p>
</td></tr>
<tr><td><code>lrCCt</code></td>
<td>
<p>When <code>"rand"</code>, clustering coefficient from a random network.
When <code>"HG"</code>, transitivity from a random network.
When <code>"TJHBL"</code>, clustering coefficient from a lattice network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Humphries, M. D., &amp; Gurney, K. (2008).
Network 'small-world-ness': A quantitative method for determining canonical network equivalence.
<em>PLoS one</em>, <em>3</em>, e0002051.
</p>
<p>Telesford, Q. K., Joyce, K. E., Hayasaka, S., Burdette, J. H., &amp; Laurienti, P. J. (2011).
The ubiquity of small-world networks.
<em>Brain Connectivity</em>, <em>1</em>(5), 367-375.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A


swmHG &lt;- smallworldness(A, method="HG")

swmRand &lt;- smallworldness(A, method="rand")

swmTJHBL &lt;- smallworldness(A, method="TJHBL")

</code></pre>

<hr>
<h2 id='stable'>Stabilizing Nodes</h2><span id='topic+stable'></span>

<h3>Description</h3>

<p>Computes the within-community centrality for each node in the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stable(
  A,
  comm = c("walktrap", "louvain"),
  cent = c("betweenness", "rspbc", "closeness", "strength", "degree", "hybrid"),
  absolute = TRUE,
  diagonal = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stable_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="stable_+3A_comm">comm</code></td>
<td>
<p>Can be a vector of community assignments or community detection algorithms
(<code>"walktrap"</code> or <code>"louvain"</code>) can be used to determine the number of factors.
Defaults to <code>"walktrap"</code>.
Set to <code>"louvain"</code> for <code><a href="#topic+louvain">louvain</a></code> community detection</p>
</td></tr>
<tr><td><code id="stable_+3A_cent">cent</code></td>
<td>
<p>Centrality measure to be used.
Defaults to <code>"strength"</code>.</p>
</td></tr>
<tr><td><code id="stable_+3A_absolute">absolute</code></td>
<td>
<p>Should network use absolute weights?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for signed weights</p>
</td></tr>
<tr><td><code id="stable_+3A_diagonal">diagonal</code></td>
<td>
<p>Sets the diagonal values of the <code>A</code> input.
Defaults to <code>0</code></p>
</td></tr>
<tr><td><code id="stable_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code>
and <code><a href="#topic+louvain">louvain</a></code> community detection algorithms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the within-community centrality value for each node
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Blanken, T. F., Deserno, M. K., Dalege, J., Borsboom, D., Blanken, P., Kerkhof, G. A., &amp; Cramer, A. O. (2018).
The role of stabilizing and communicating symptoms given overlapping communities in psychopathology networks.
<em>Scientific Reports</em>, <em>8</em>, 5854.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

stabilizing &lt;- stable(A, comm = "walktrap")

</code></pre>

<hr>
<h2 id='strength'>Node Strength</h2><span id='topic+strength'></span>

<h3>Description</h3>

<p>Computes strength of each node in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strength(A, absolute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strength_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="strength_+3A_absolute">absolute</code></td>
<td>
<p>Should network use absolute weights?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> for signed weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of strength values for each node in the network.
</p>
<p>If directed network, returns a list containing:
</p>
<table>
<tr><td><code>inStrength</code></td>
<td>
<p>Strength of incoming edges (pointing to the node)</p>
</td></tr>
<tr><td><code>outStrength</code></td>
<td>
<p>Strength of outgoing edges (pointing away from the node)</p>
</td></tr>
<tr><td><code>relInf</code></td>
<td>
<p>Relative degree of incoming and outgoing edges.
Positive values indicate more outgoing strength relative to incoming strength.
Negative values indicate more incoming strength relative to outgoing strength</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em> 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

str &lt;- strength(A)

#Directed network
## Not run: 
dep &lt;- depend(neoOpen)

Adep &lt;- TMFG(dep, depend = TRUE)$A

str &lt;- strength(Adep)

## End(Not run)

</code></pre>

<hr>
<h2 id='threshold'>Threshold Network Estimation Methods</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>Filters the network based on an r-value, alpha, adaptive alpha,
bonferroni, false-discovery rate (FDR), or proportional density (fixed number of edges) value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(
  data,
  a,
  thresh = c("alpha", "adaptive", "bonferroni", "FDR", "proportional"),
  normal = FALSE,
  na.data = c("pairwise", "listwise", "fiml", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_data">data</code></td>
<td>
<p>Can be a dataset or a correlation matrix</p>
</td></tr>
<tr><td><code id="threshold_+3A_a">a</code></td>
<td>
<p>When <code>thresh = "alpha"</code>, <code>"adaptive"</code>, and <code>"bonferroni"</code>
an <code class="reqn">\alpha</code> threshold is applied (defaults to <code>.05</code>).
For <code>"adaptive"</code>, beta (Type II error) is set to <code class="reqn">\alpha*5</code> for a medium effect size (<em>r</em> = .3).
When <code>thresh = "FDR"</code>, a q-value threshold is applied (defaults to <code>.10</code>).
When <code>thresh = "proportional"</code>, a density threshold is applied (defaults to <code>.15</code>)</p>
</td></tr>
<tr><td><code id="threshold_+3A_thresh">thresh</code></td>
<td>
<p>Sets threshold. Defaults to <code>"alpha"</code>.
Set to any value 0&gt; <em>r</em> &gt;1 to retain values greater than set value,
<code>"adaptive"</code> for an <code><a href="#topic+adapt.a">adapt.a</a></code> based on sample size (Perez &amp; Pericchi, 2014),
<code>"bonferroni"</code> for the bonferroni correction on alpha,
<code>"FDR"</code> for local false discovery rate,
and <code>"proportional"</code> for a fixed density of edges (keeps strongest correlations within density)</p>
</td></tr>
<tr><td><code id="threshold_+3A_normal">normal</code></td>
<td>
<p>Should data be transformed to a normal distribution?
Defaults to FALSE.
Data is not transformed to be normal.
Set to TRUE if data should be transformed to be normal
(computes correlations using the <a href="qgraph.html#topic+cor_auto">cor_auto</a> function)</p>
</td></tr>
<tr><td><code id="threshold_+3A_na.data">na.data</code></td>
<td>
<p>How should missing data be handled?
For <code>"listwise"</code> deletion the <code><a href="stats.html#topic+na.omit">na.omit</a></code> function is applied.
Set to <code>"fiml"</code> for Full Information Maximum Likelihood (<code><a href="psych.html#topic+corFiml">corFiml</a></code>).
Full Information Maximum Likelihood is <strong>recommended</strong> but time consuming</p>
</td></tr>
<tr><td><code id="threshold_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code> and <code><a href="#topic+adapt.a">adapt.a</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>The filtered adjacency matrix</p>
</td></tr>
<tr><td><code>r.cv</code></td>
<td>
<p>The critical correlation value used to filter the network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Strimmer, K. (2008).
fdrtool: A versatile R package for estimating local and tail area-based false discovery rates.
<em>Bioinformatics</em>, <em>24</em>, 1461-1462.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>threshnet&lt;-threshold(neoOpen)

alphanet&lt;-threshold(neoOpen, thresh = "alpha", a = .05)

bonnet&lt;-threshold(neoOpen, thresh = "bonferroni", a = .05)

FDRnet&lt;-threshold(neoOpen, thresh = "FDR", a = .10)

propnet&lt;-threshold(neoOpen, thresh = "proportional", a = .15)
</code></pre>

<hr>
<h2 id='TMFG'>Triangulated Maximally Filtered Graph</h2><span id='topic+TMFG'></span>

<h3>Description</h3>

<p>Applies the Triangulated Maximally Filtered Graph (TMFG) filtering method
(<strong>Please see and cite Massara et al., 2016</strong>). The TMFG method uses a structural
constraint that limits the number of zero-order correlations included in the network
(3n - 6; where <em>n</em> is the number of variables). The TMFG algorithm begins by
identifying four variables which have the largest sum of correlations to all other
variables. Then, it iteratively adds each variable with the largest sum of three
correlations to nodes already in the network until all variables have been added to
the network. This structure can be associated with the inverse correlation matrix
(i.e., precision matrix) to be turned into a GGM (i.e., partial correlation network)
by using <code><a href="#topic+LoGo">LoGo</a></code>. See Details for more information on this
network estimation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TMFG(
  data,
  normal = TRUE,
  na.data = c("pairwise", "listwise", "fiml", "none"),
  depend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TMFG_+3A_data">data</code></td>
<td>
<p>Can be a dataset or a correlation matrix</p>
</td></tr>
<tr><td><code id="TMFG_+3A_normal">normal</code></td>
<td>
<p>Should data be transformed to a normal distribution?
Input must be a dataset.
Defaults to <code>TRUE</code>.
Computes correlations using the <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> function.
Set to <code>FALSE</code> for Pearson's correlation</p>
</td></tr>
<tr><td><code id="TMFG_+3A_na.data">na.data</code></td>
<td>
<p>How should missing data be handled?
For <code>"listwise"</code> deletion the <code><a href="stats.html#topic+na.omit">na.omit</a></code> function is applied.
Set to <code>"fiml"</code> for Full Information Maximum Likelihood (<code><a href="psych.html#topic+corFiml">corFiml</a></code>).
Full Information Maximum Likelihood is <strong>recommended</strong> but time consuming</p>
</td></tr>
<tr><td><code id="TMFG_+3A_depend">depend</code></td>
<td>
<p>Is network a dependency (or directed) network?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> to generate a TMFG-filtered dependency network
(output obtained from the <code><a href="#topic+depend">depend</a></code> function)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TMFG method applies a structural constraint on the network,
which restrains the network to retain a certain number of edges (3<em>n</em>-6, where <em>n</em>
is the number of nodes; Massara et al., 2016). The network is also composed of 3- and 4-node
cliques (i.e., sets of connected nodes; a triangle and tetrahedron, respectively). The
TMFG method constructs a network using zero-order correlations and the resulting network
can be associated with the inverse covariance matrix
(yielding a GGM; Barfuss, Massara, Di Matteo, &amp; Aste, 2016).
Notably, the TMFG can use any association measure and thus does not assume the data is multivariate normal.
</p>
<p>Construction begins by forming a tetrahedron of the four nodes that have
the highest sum of correlations that are greater than the average correlation in the
correlation matrix. Next, the algorithm iteratively identifies the node that maximizes
its sum of correlations to a connected set of three nodes (triangles) already included
in the network and then adds that node to the network. The process is completed once
every node is connected in the network. In this process, the network automatically
generates what’s called a planar network. A planar network is a network that could be
drawn on a sphere with no edges crossing (often, however, the networks are depicted
with edges crossing; Tumminello, Aste, Di Matteo, &amp; Mantegna, 2005).
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>The filtered adjacency matrix</p>
</td></tr>
<tr><td><code>separators</code></td>
<td>
<p>The separators (3-cliques) in the network
(wrapper output for <code><a href="#topic+LoGo">LoGo</a></code>)</p>
</td></tr>
<tr><td><code>cliques</code></td>
<td>
<p>The cliques (4-cliques) in the network
(wrapper output for <code><a href="#topic+LoGo">LoGo</a></code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Christensen, A. P., Kenett, Y. N., Aste, T., Silvia, P. J., &amp; Kwapil, T. R. (2018).
Network structure of the Wisconsin Schizotypy Scales-Short Forms: Examining psychometric network filtering approaches.
<em>Behavior Research Methods</em>, <em>50</em>, 2531-2550.
</p>
<p>Massara, G. P., Di Matteo, T., &amp; Aste, T. (2016).
Network filtering for big data: Triangulated maximally filtered graph.
<em>Journal of Complex Networks</em>, <em>5</em>, 161-178.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

</code></pre>

<hr>
<h2 id='transitivity'>Transitivity</h2><span id='topic+transitivity'></span>

<h3>Description</h3>

<p>Computes transitivity of a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitivity(A, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitivity_+3A_a">A</code></td>
<td>
<p>An adjacency matrix of network data</p>
</td></tr>
<tr><td><code id="transitivity_+3A_weighted">weighted</code></td>
<td>
<p>Is the network weighted?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> for a weighted measure of transitivity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a value of transitivity
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rubinov, M., &amp; Sporns, O. (2010). 
Complex network measures of brain connectivity: Uses and interpretations. 
<em>NeuroImage</em>, <em>52</em>, 1059-1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

trans &lt;- transitivity(A, weighted=TRUE)
</code></pre>

<hr>
<h2 id='un.direct'>Convert Directed Network to Undirected Network</h2><span id='topic+un.direct'></span>

<h3>Description</h3>

<p>Converts a directed network to an undirected network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>un.direct(A, diagonal = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="un.direct_+3A_a">A</code></td>
<td>
<p>Matrix or data frame.
Adjacency matrix (network matrix)</p>
</td></tr>
<tr><td><code id="un.direct_+3A_diagonal">diagonal</code></td>
<td>
<p>Numeric.
Number to be placed on the diagonal.
Defaults to <code>0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a symmetric adjacency matrix
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pearson's correlation only for CRAN checks
A &lt;- TMFG(neoOpen, normal = FALSE)$A

# create a directed network
dir &lt;- A * sample(c(0,1), size = length(A), replace = TRUE)

# undirect the directed network
undir &lt;- un.direct(dir)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
