<!DOCTYPE html><html><head><title>Help for package nph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#logrank.maxtest'><p>Maximum combination (MaxCombo) log-rank test</p></a></li>
<li><a href='#logrank.test'><p>Weighted log-rank test</p></a></li>
<li><a href='#m2r'><p>Transform median time into rate</p></a></li>
<li><a href='#nph_gui'><p>Launch a GUI (shiny app) for the nph package</p></a></li>
<li><a href='#nphparams'><p>Simultaneous Inference For Parameters Quantifying Differences Between Two Survival Functions</p></a></li>
<li><a href='#pchaz'><p>Calculate survival for piecewise constant hazard</p></a></li>
<li><a href='#pembro'><p>Reconstructed Data Set Based On Survival Curves In Burtess et al. 2019</p></a></li>
<li><a href='#plot_diagram'><p>Draw a state space figure</p></a></li>
<li><a href='#plot_shhr'><p>Plot of survival, hazard and hazard ratio of two groups as a function of time</p></a></li>
<li><a href='#plot_subgroups'><p>Draw a population composition plot</p></a></li>
<li><a href='#plot.mixpch'><p>Plot mixpch Objects</p></a></li>
<li><a href='#plot.nphparams'><p>Plot nphparams Objects</p></a></li>
<li><a href='#pop_pchaz'><p>Calculate survival for piecewise constant hazards with change after random time and mixture of subpopulations</p></a></li>
<li><a href='#print.nphparams'><p>Print nphparams Objects</p></a></li>
<li><a href='#rSurv_conditional_fun'><p>Draw conditional random survival times from mixpch object.</p></a></li>
<li><a href='#rSurv_fun'><p>Draw random survival times from mixpch object.</p></a></li>
<li><a href='#sample_conditional_fun'><p>Draw conditional survival times based on study settings</p></a></li>
<li><a href='#sample_fun'><p>Draw survival times based on study settings</p></a></li>
<li><a href='#subpop_pchaz'><p>Calculate survival for piecewise constant hazards with change after random time</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Planning and Analysing Survival Studies under Non-Proportional
Hazards</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Piecewise constant hazard functions are used to flexibly model survival distributions with non-proportional hazards and 
	to simulate data from the specified distributions. A function to calculate weighted log-rank tests for the comparison of two
	hazard functions is included. Also, a function to calculate a test using the maximum of a set of test statistics from weighted
	log-rank tests (MaxCombo test) is provided. This test utilizes the asymptotic multivariate normal joint distribution of the
	separate test statistics. The correlation is estimated from the data. These methods are described in Ristl et al. (2021) 
	&lt;<a href="https://doi.org/10.1002%2Fpst.2062">doi:10.1002/pst.2062</a>&gt;.
	Finally, a function is provided for the estimation and inferential statistics of various parameters that quantify the difference
	between two survival curves. Eligible parameters are differences in survival probabilities, log survival probabilities,
	complementary log log (cloglog) transformed survival probabilities, quantiles of the survival functions, log transformed quantiles,
	restricted mean survival times, as well as an average hazard ratio, the Cox model score statistic (logrank statistic), and the
	Cox-model hazard ratio. Adjustments for multiple testing and simultaneous confidence intervals are calculated using a multivariate
	normal approximation to the set of selected parameters.</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin Ristl &lt;robin.ristl@meduniwien.ac.at&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, mvtnorm, ggplot2, muhaz, survival, multcomp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, shiny, shinycssloaders, formatR, styler, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-16 19:57:14 UTC; Robin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin Ristl [aut, cre],
  Nicolas Ballarini [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-16 23:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='logrank.maxtest'>Maximum combination (MaxCombo) log-rank test</h2><span id='topic+logrank.maxtest'></span><span id='topic+print.wlogrank_max'></span>

<h3>Description</h3>

<p>Calculates a MaxCombo test for the comparison of two groups based on the maximum of test statistics of a set of weighted log-rank tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logrank.maxtest(
  time,
  event,
  group,
  alternative = c("two.sided", "less", "greater"),
  rho = c(0, 0, 1),
  gamma = c(0, 1, 0),
  event_time_weights = NULL,
  algorithm = mvtnorm::GenzBretz(maxpts = 50000, abseps = 1e-05, releps = 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logrank.maxtest_+3A_time">time</code></td>
<td>
<p>Vector of observed event/censored times</p>
</td></tr>
<tr><td><code id="logrank.maxtest_+3A_event">event</code></td>
<td>
<p>logical vector or numeric vector with entries 0 or 1, indicating if an event was observed (TRUE or 1) or the time is censored (FALSE or 0)</p>
</td></tr>
<tr><td><code id="logrank.maxtest_+3A_group">group</code></td>
<td>
<p>Vector of group allocations</p>
</td></tr>
<tr><td><code id="logrank.maxtest_+3A_alternative">alternative</code></td>
<td>
<p>Either of <code>"two.sided"</code>,<code>"less"</code> or <code>"greater"</code>, specifies if two-sided or respective
one-sided p-values are calculated. In any case the z test statistic of each included weighted log-rank test
is based on the (weighted) sum of expected minus observed
events in the group corresponding to the first factor level of <code>group</code>. Hence a small value of the test statistic corresponds to a
lower (weighted average) hazard rate in the first group.</p>
</td></tr>
<tr><td><code id="logrank.maxtest_+3A_rho">rho</code></td>
<td>
<p>Vector of parameter values rho for a set of weighting functions in the rho-gamma family</p>
</td></tr>
<tr><td><code id="logrank.maxtest_+3A_gamma">gamma</code></td>
<td>
<p>Vector of parameter values gamma for a set of weighting functions in the rho-gamma family</p>
</td></tr>
<tr><td><code id="logrank.maxtest_+3A_event_time_weights">event_time_weights</code></td>
<td>
<p>Optional matrix, each column containing a different weighting vector for the event times.
These weight vectors need to have one entry per event time (not per event, as multiple events may
occur at the same time) and must be sorted by increasing event time.</p>
</td></tr>
<tr><td><code id="logrank.maxtest_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm for the multivariate normal integration to be used in <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To perform a maximum-type combination test, a set of <code class="reqn">m</code> different weight
functions <code class="reqn">w_1(t), \dots, w_m(t)</code> is specified and the correspondingly
weighted logrank statistics <code class="reqn">z_1,\dots,z_m</code> are calculated. The maximum
test statistic is <code class="reqn">z_{max}=\max_{i=1,\dots,m} z_i</code>. If at least one of
the selected weight functions results in high power, we may expect a large
value of <code class="reqn">z_{max}</code>.
Under the least favorable configuration in <code class="reqn">H_0</code>, approximately
<code class="reqn">(Z_1,\dots,Z_m)\sim N_m({0},{\Sigma})</code>. The p-value of the maximum
test, <code class="reqn">P_{H_0}(Z_{max}&gt;z_{max})=1-P(Z_1 \leq z_{max},\dots,Z_m \leq z_{max})</code>,
is calculated based on this multivariate normal approximation via numeric integration.
The integration is done using <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>. The default settings in
<code>logrank.maxtest</code> correspond to greater precision than the original default of
<code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>. Precision can be set via the argument <code>algorithm</code>.
Lower precision settings may speed up caclulation.
</p>
<p>The multivariate normal approach automatically corrects for multiple testing with
different weights and does so efficiently since the correlation between the different
tests is incorporated in <code class="reqn">{\Sigma}</code>. For actual calculations, <code class="reqn">{\Sigma}</code> is
replaced by an estimate.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<dl>
<dt><code>pmult</code></dt><dd><p>The two sided p-value for the null hypothesis of equal hazard functions in both groups, based on the multivariate
normal approximation for the z-statistics of differently weighted log-rank tests.</p>
</dd>
<dt><code>p.Bonf</code></dt><dd><p>The two sided p-value for the null hypothesis of equal hazard functions in both groups, based on a
Bonferroni multiplicity adjustment for differently weighted log-rank tests.</p>
</dd>
<dt><code>tests</code></dt><dd><p>Data frame with z-statistics and two-sided unadjusted p-values of the individual weighted log-rank tests</p>
</dd>
<dt><code>korr</code></dt><dd><p>Estimated correlation matrix for the z-statistics of the differently weighted log-rank tests.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>
<p>Pranab Ghosh, Robin Ristl, Franz König, Martin Posch, Christopher Jennison, Heiko Götte, Armin Schüler, Cyrus Mehta. Robust group sequential
designs for trials with survival endpoints and delayed response. Biometrical Journal. First published online: 21 December 2021
</p>
<p>Tarone RE. On the distribution of the maximum of the logrank statistic and the modified wilcoxon statistic. Biometrics. 1981; 37:79-85.
</p>
<p>Lee S-H. On the versatility of the combination of the weighted log-rank statistics. Comput Stat Data Anal. 2007; 51(12):6557-6564.
</p>
<p>Karrison TG et al. Versatile tests for comparing survival curves based on weighted log-rank statistics. Stata J. 2016; 16(3):678-690.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logrank.test">logrank.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.2, 0.6, 0.2), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.4, 0.4), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
B &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.1, 0.6, 0.1), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.04, 0.04), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
dat &lt;- sample_fun(A, B, r0 = 0.5, eventEnd = 30,
  lambdaRecr = 0.5, lambdaCens = 0.25 / 365,
 maxRecrCalendarTime = 2 * 365,
 maxCalendar = 4 * 365)
logrank.maxtest(dat$y, dat$event, dat$group)

</code></pre>

<hr>
<h2 id='logrank.test'>Weighted log-rank test</h2><span id='topic+logrank.test'></span><span id='topic+print.wlogrank'></span>

<h3>Description</h3>

<p>Calculates a weighted log-rank test for the comparison of two groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logrank.test(
  time,
  event,
  group,
  alternative = c("two.sided", "less", "greater"),
  rho = 0,
  gamma = 0,
  event_time_weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logrank.test_+3A_time">time</code></td>
<td>
<p>Vector of observed event/censored times</p>
</td></tr>
<tr><td><code id="logrank.test_+3A_event">event</code></td>
<td>
<p>logical vector or numeric vector with entries 0 or 1, indicating if an event was observed (TRUE or 1) or the time is censored (FALSE or 0)</p>
</td></tr>
<tr><td><code id="logrank.test_+3A_group">group</code></td>
<td>
<p>Vector of group allocations</p>
</td></tr>
<tr><td><code id="logrank.test_+3A_alternative">alternative</code></td>
<td>
<p>Either of <code>"two.sided"</code>,<code>"less"</code> or <code>"greater"</code>, specifies if two-sided or respective
one-sided p-values are calculated. In any case the z test statistic of each included weighted log-rank test
is based on the (weighted) sum of expected minus observed
events in the group corresponding to the first factor level of <code>group</code>. Hence a small value of the test statistic corresponds to a
lower (weighted average) hazard rate in the first group.</p>
</td></tr>
<tr><td><code id="logrank.test_+3A_rho">rho</code></td>
<td>
<p>Parameter to calculate weights in the rho-gamma family</p>
</td></tr>
<tr><td><code id="logrank.test_+3A_gamma">gamma</code></td>
<td>
<p>Parameter to calculate weights in the rho-gamma family</p>
</td></tr>
<tr><td><code id="logrank.test_+3A_event_time_weights">event_time_weights</code></td>
<td>
<p>Optional vector of user defined weights. This weight vector needs to have one entry per event time (not per event, as multiple events may
occur at the same time) and must be sorted by increasing event time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given sample, let <code class="reqn">\mathcal{D}</code> be the set of unique event times.
For a time-point <code class="reqn">t \in \mathcal{D}</code>, let <code class="reqn">n_{t,ctr}</code> and <code class="reqn">n_{t,trt}</code> be
the number of patients at risk in the control and treatment group and let
<code class="reqn">d_{t,ctr}</code> and <code class="reqn">d_{t,trt}</code> be the respective number of events.
The expected number of events in the control group is calculated under the
least favorable configuration in <code class="reqn">H_0</code>,
<code class="reqn">\lambda_{ctr}(t) = \lambda_{trt}(t)</code>, as <code class="reqn">e_{t,ctr}=(d_{t,ctr}+d_{t,trt}) 
\frac{n_{t0}}{n_{t0}+n_{t1}}</code>. The conditional variance of <code class="reqn">d_{t,ctr}</code>
is calculated from a hypergeometric distribution as
<code class="reqn">var(d_{t,ctr})=\frac{n_{t0} n_{t1} (d_{t0}+d_{t1}) (n_{t0}+n_{t1} - d_{t0} - d_{t1})}{(n_{t0}+n_{t1})^2 (n_{t0}+n_{t1}-1)}</code>.
Further define a weighting function <code class="reqn">w(t)</code>.
The weighted logrank test statistic for a comparison of two groups is
</p>
<p style="text-align: center;"><code class="reqn">z=\sum_{t \in \mathcal{D}} w(t) (d_{t,ctr}-e_{t,ctr}) / \sqrt{\sum_{t \in \mathcal{D}} w(t)^2 var(d_{t,ctr})}</code>
</p>

<p>Under the the least favorable configuration in <code class="reqn">H_0</code>,
the test statistic is asymptotically standard normally distributed and large
values of <code class="reqn">z</code> are in favor of the alternative.
</p>
<p>The function consider particular weights in the Fleming-Harrington <code class="reqn">\rho-\gamma</code>
family <code class="reqn">w(t)=\hat S(t-)^\rho (1-\hat S(t-))^\gamma</code>.
Here, <code class="reqn">\hat{S}(t)=\prod_{s \in \mathcal{D}: s \leq t} 1-\frac{d_{t,ctr}+d_{t,trt}}{n_{t,ctr}+n_{t,trt}}</code>
is the pooled sample Kaplan-Meier estimator.
(Note: Prior to package version 2.1, <code class="reqn">S(t)</code> was used in the definition of <code class="reqn">\rho-\gamma</code> weights,
this was changed to <code class="reqn">S(t-)</code> with version 2.1.)
Weights <code class="reqn">\rho=0, \gamma=0</code> correspond to the standard logrank test with
constant weights <code class="reqn">w(t)=1</code>. Choosing <code class="reqn">\rho=0, \gamma=1</code> puts more weight on
late events, <code class="reqn">\rho=1, \gamma=0</code> puts more weight on early events and
<code class="reqn">\rho=1, \gamma=1</code> puts most weight on events at intermediate time points.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<dl>
<dt><code>D</code></dt><dd><p>A data frame event numbers, numbers at risk and expected number of events for each event time</p>
</dd>
<dt><code>test</code></dt><dd><p>A data frame containing the z and chi-squared statistic for the one-sided and two-sided test, respectively,
of the null hypothesis of equal hazard functions in both groups and the p-value for the one-sided test.
</p>
</dd>
<dt><code>var</code></dt><dd><p>The estimated variance of the sum of expected minus observed events in the first group.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>
<p>Thomas R Fleming and David P Harrington. Counting processes and survival analysis. John Wiley &amp; Sons, 2011
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logrank.maxtest">logrank.maxtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.2, 0.6, 0.2), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.4, 0.4), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
B &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.1, 0.6, 0.1), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.04, 0.04), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
dat &lt;- sample_fun(A, B, r0 = 0.5, eventEnd = 30,
  lambdaRecr = 0.5, lambdaCens = 0.25 / 365,
 maxRecrCalendarTime = 2 * 365,
 maxCalendar = 4 * 365)
logrank.test(dat$y, dat$event, dat$group)


</code></pre>

<hr>
<h2 id='m2r'>Transform median time into rate</h2><span id='topic+m2r'></span>

<h3>Description</h3>

<p>This helper function calculates the hazard rate per day of an exponential
distribution from the median given in months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2r(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2r_+3A_x">x</code></td>
<td>
<p>The median time in months to be transformed into rate</p>
</td></tr>
</table>

<hr>
<h2 id='nph_gui'>Launch a GUI (shiny app) for the nph package</h2><span id='topic+nph_gui'></span>

<h3>Description</h3>

<p>Launch a GUI (shiny app) for the nph package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nph_gui()
</code></pre>


<h3>Details</h3>

<p>The packages <code>shinycssloaders</code>, <code>formatR</code> and <code>styler</code> are required for correct display of the GUI.
The package <code>rmarkdown</code> with access to pandoc is required to save reports.
</p>

<hr>
<h2 id='nphparams'>Simultaneous Inference For Parameters Quantifying Differences Between Two Survival Functions</h2><span id='topic+nphparams'></span>

<h3>Description</h3>

<p>Hypothesis tests with parametric multiple testing adjustment and simultaneous confidence intervals
for a set of parameters, which quantify differences between two survival functions. Eligible parameters are differences in survival probabilities, log survival probabilities,
complementary log log (cloglog) transformed survival probabilities, quantiles of the survival functions,
log transformed quantiles, restricted mean survival times, as well as an average hazard ratio, the Cox model score statistic
(logrank statistic), and the Cox-model hazard ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nphparams(
  time,
  event,
  group,
  data = parent.frame(),
  param_type,
  param_par = NA,
  param_alternative = NA,
  lvl = 0.95,
  closed_test = FALSE,
  alternative_test = "two.sided",
  alternative_CI = "two.sided",
  haz_method = "local",
  rhs = 0,
  perturb = FALSE,
  Kpert = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nphparams_+3A_time">time</code></td>
<td>
<p>vector of observed event/censored times.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_event">event</code></td>
<td>
<p>Vector with entries 0 or 1 (or FALSE/TRUE) indicating if an event was observed (1) or the time is censored (0).</p>
</td></tr>
<tr><td><code id="nphparams_+3A_group">group</code></td>
<td>
<p>group indicator, must be a vector with entries 0 or 1 indicating the allocation of a subject to one of two groups.
Group 0 is regarded as reference group when calculating parameters.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the time, event and group data.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_param_type">param_type</code></td>
<td>
<p>character vector defining the set of parameters that should be analysed. Possible entries are &quot;S&quot;,&quot;logS&quot;,&quot;cloglogS&quot;,
&quot;Q&quot;,&quot;logQ&quot;,&quot;RMST&quot;,&quot;avgHR&quot;,&quot;score&quot; and &quot;HR&quot;, representing differences in survival probabilities, log survival probabilities,
complementary log log (cloglog) transformed survival probabilities, quantiles of the survival functions,
log transformed quantiles, restricted mean survival times, as well as an average hazard ratio, the Cox model score statistic (logrank statistic),
and the Cox-model hazard ratio.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_param_par">param_par</code></td>
<td>
<p>numeric vector which contains the time points at which the requested parameters are evaluated (e.g. x-year survival or RMST after x-years),
or, in case of analysing quantiles, the according probability. May be <code>NA</code> for parameter types &quot;RMST&quot;,&quot;avgHR&quot;,&quot;score&quot; or &quot;HR&quot;. In this case,
the minimum of the largest event times of the two groups is used. Also, times greater than this minimum are replaced by this minumum for &quot;RMST&quot;,&quot;avgHR&quot;,&quot;score&quot; or &quot;HR&quot;.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_param_alternative">param_alternative</code></td>
<td>
<p>optional character vector with entries &quot;less&quot; or &quot;greater&quot;, defining the alternative for each parameter.
Only required if one-sided tests or one-sided confidence intervals are requested.
Note that group 0 is regarded as reference group when calculating parameters and therefore whether &quot;greater&quot; or &quot;less&quot; corresponds
to a benefit may depend on the type of parameter. In general, to show
larger survival in group 1 compared to group 0, alternatives would be &quot;greater&quot; for parameter types &quot;S&quot;, &quot;logS&quot;, &quot;Q&quot;, &quot;logQ&quot; and &quot;RMST&quot;
and would be &quot;less&quot; for parameters types &quot;cloglogS&quot;,
&quot;avgHR&quot;,&quot;HR&quot;, and &quot;score&quot;.
(The score test is defined here such that alternative &quot;less&quot; corresponds to smaller hazard (and better survival) in group 1 compared to group 0.)</p>
</td></tr>
<tr><td><code id="nphparams_+3A_lvl">lvl</code></td>
<td>
<p>Confidence level. Applies to, both, unadjusted and multiplicity adjusted (simultaneous) confidence intervals.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_closed_test">closed_test</code></td>
<td>
<p>logical indicating whether p-values should be adjusted using a closed testing procedure. Default is <code>FALSE</code>, and in this case
p-values will be adjusted by a single step procedure.
With <code class="reqn">k</code> hypotheses this involves the computation of <code class="reqn">2^k</code> tests, which may require considerable computation time.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_alternative_test">alternative_test</code></td>
<td>
<p>character with possible values &quot;tow.sided&quot; (default) or &quot;one-sided&quot;. Specifies whether hypothesis tests should be two-sided or one-sided. In the #'    latter case, <code>param_alternative</code> must be defined.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_alternative_ci">alternative_CI</code></td>
<td>
<p>character with possible values &quot;tow.sided&quot; (default) or &quot;one-sided&quot;. Specifies whether confidence intervals should be two-sided or one-sided.
In the latter case, <code>param_alternative</code> must be defined.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_haz_method">haz_method</code></td>
<td>
<p>character with possible values &quot;local&quot; or &quot;muhaz&quot;. Specifies whether local hazard should be calculated under a local constant hazard assumption (default) #'    or using the function <code><a href="muhaz.html#topic+muhaz">muhaz</a></code> from the muhaz package. Only relevant when median or log(median) survival
times are analysed.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_rhs">rhs</code></td>
<td>
<p>right-hand side vector of null hypotheses. Refers to log-scaled difference for ratios. Default is to consider for all null hypothesis a difference of 0.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_perturb">perturb</code></td>
<td>
<p>logical, indicating whether the perturbation based estiamte should be used instead of the asymptotic estimate to calculate the covariance matrix.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nphparams_+3A_kpert">Kpert</code></td>
<td>
<p>The number of perturbation samples to be used with the perturbation approach for covariance estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>nphparams</code> with elements:
</p>

<dl>
<dt><code>est</code></dt><dd><p>Estimated differences (at log-scale in case of ratios).</p>
</dd>
<dt><code>V</code></dt><dd><p>Estimated covariance matrix of differences.</p>
</dd>
<dt><code>tab</code></dt><dd><p>A data frame with analysis results. Contains the parameter type (Parameter) and settings (Time_or_which_quantile), the estimated difference (Estimate),
its standard error (SE), unadjusted confidence interval lower and upper bounds (lwr_unadjusted, upr_unadjusted), unadjusted p-values (p_unadj),
mulitplicity adjusted confidence interval lower and upper bounds (lwr_adjusted, upr_adjusted), single-step multiplcity adjusted p-values (p_adj),
closed-test adjusted p-values, if requested (p_adjusted_closed_test) and for comparison Bonferroni-Holm adjusted p-values (p_Holm).</p>
</dd>
<dt><code>param</code></dt><dd><p>The used parameter settings. If <code>param_par</code> was <code>NA</code> for &quot;HR&quot;,&quot;avgHR&quot; or &quot;RMST&quot;, it is replaced by <code>minmaxt</code> here.</p>
</dd>
<dt><code>paramin</code></dt><dd><p>The parameter settings as provided to the function. The only difference to <code>param</code> is in <code>param_par</code>, as <code>NA</code> is not replaced here.</p>
</dd>
<dt><code>dat0</code></dt><dd><p>A data frame with information on all observed events in group 0. Contains time (t), number of events (ev), Nelson-Aalen estimate (NAsurv)
and Kaplan-Meier estimate (KMsurv) of survival, and the number at risk (atrisk).</p>
</dd>
<dt><code>dat1</code></dt><dd><p>A data frame with information on all observed events in group 1. Contains time (t), number of events (ev), Nelson-Aalen estimate (NAsurv)
and Kaplan-Meier estimate (KMsurv) of survival, and the number at risk (atrisk).</p>
</dd>
<dt><code>minmaxt</code></dt><dd><p>Minimum of the largest event times of the two groups.</p>
</dd>
<dt><code>est0</code></dt><dd><p>Estimated parameter values in group 0.</p>
</dd>
<dt><code>est1</code></dt><dd><p>Estimated parameter values in group 1.</p>
</dd>
<dt><code>V0</code></dt><dd><p>Estimated covariance matrix of parameter estimates in group 0.</p>
</dd>
<dt><code>V1</code></dt><dd><p>Estimated covariance matrix of parameter estimates in group 1.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.nphparams">print.nphparams</a></code>, <code><a href="#topic+plot.nphparams">plot.nphparams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pembro)
set1&lt;-nphparams(time=time, event=event, group=group,data=pembro,
param_type=c("score","S"),
param_par=c(3.5,2),
param_alternative=c("less","greater"),
closed_test=TRUE,alternative_test="one.sided")
print(set1)
plot(set1,trt_name="Pembrolizumab",ctr_name="Cetuximab")

set2&lt;-nphparams(time=time, event=event, group=group, data=pembro,  
param_type=c("S","S","S","Q","RMST"),
param_par=c(0.5,1,2,0.5,3.5))
print(set2)
plot(set2,showlines=TRUE,show_rmst_diff=TRUE)

#Create a summary table for set2, showing parameter estimates for each group and the
#estimated differences between groups. Also show unadjusted and multiplicity adjusted
#confidence intervals using the multivariate normal method and, for comparison,
#Bonferroni adjusted confidence intervals:

set2Bonf&lt;-nphparams(time=time, event=event, group=group, data=pembro,  
param_type=c("S","S","S","Q","RMST"),
param_par=c(0.5,1,2,0.5,3.5),
lvl=1-0.05/5)
KI_paste&lt;-function(x,r) {
x&lt;-round(x,r)
paste("[",x[,1],", ",x[,2],"]",sep="")
}
r&lt;-3
tab&lt;-data.frame(
Parameter=paste(set2$tab[,1],set2$tab[,2]),
Pembrolizumab=round(set2$est1,r),
Cetuximab=round(set2$est0,r),
Difference=round(set2$tab$Estimate,r),
CI_undadj=KI_paste(set2$tab[,5:6],r),
CI_adj=KI_paste(set2$tab[,8:9],r),
CI_Bonf=KI_paste(set2Bonf$tab[,c(5:6)],r))
tab

</code></pre>

<hr>
<h2 id='pchaz'>Calculate survival for piecewise constant hazard</h2><span id='topic+pchaz'></span>

<h3>Description</h3>

<p>Calculates hazard, cumulative hazard, survival and distribution function
based on hazards that are constant over pre-specified time-intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pchaz(Tint, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pchaz_+3A_tint">Tint</code></td>
<td>
<p>vector of length <code class="reqn">k+1</code>, for the boundaries of <code class="reqn">k</code> time intervals (presumably in days) with piecewise constant hazard. The boundaries should be increasing and the first one should
be <code>0</code>, the last one should be larger than the assumed trial duration.</p>
</td></tr>
<tr><td><code id="pchaz_+3A_lambda">lambda</code></td>
<td>
<p>vector of length <code class="reqn">k</code> with the piecewise constant hazards for the intervals specified via <code>Tint</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">k</code> time intervals <code class="reqn">[t_{j-1},t_j), j=1,\dots,k</code> with
<code class="reqn">0 =  t_0 &lt; t_1 \dots &lt; t_k</code>, the function assume constant hazards <code class="reqn">\lambda_{j}</code> at each interval.
The resulting hazard function is
<code class="reqn">\lambda(t) =\sum_{j=1}^k \lambda_{j} {1}_{t \in [t_{j-1},t_j)}</code>,
the cumulative hazard function is\
<code class="reqn">\Lambda(t) = \int_0^t \lambda(s) ds =\sum_{j=1}^k \left( (t_j-t_{j-1})\lambda_{j} {1}_{t &gt; t_j} + (t-t_{j-1}) \lambda_{j} {1}_{t \in [t_{j-1},t_j) } \right)</code>
and the survival function <code class="reqn">S(t) = e^{-\Lambda(t)}</code>.
The output includes the functions values calculated for all integer time points
between 0 and the maximum of <code>Tint</code>.
Additionally, a list with functions is also given to calculate the values at any arbitrary point <code class="reqn">t</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>mixpch</code> containing the following components:
</p>

<dl>
<dt><code>haz</code></dt><dd><p>Values of the hazard function over discrete times t.</p>
</dd>
<dt><code>cumhaz</code></dt><dd><p>Values of the cumulative hazard function over discrete times t.</p>
</dd>
<dt><code>S</code></dt><dd><p>Values of the survival function over discrete times t.</p>
</dd>
<dt><code>F</code></dt><dd><p>Values of the distribution function over discrete times t.</p>
</dd>
<dt><code>t</code></dt><dd><p>Time points for which the values of the different functions are calculated.</p>
</dd>
<dt><code>Tint</code></dt><dd><p>Input vector of boundaries of time intervals.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Input vector of piecewise constant hazards.</p>
</dd>
<dt><code>funs</code></dt><dd><p>A list with functions to calculate the hazard, cumulative hazard, survival, pdf and cdf over arbitrary continuous times.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>, Nicolas Ballarini
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subpop_pchaz">subpop_pchaz</a></code>, <code><a href="#topic+pop_pchaz">pop_pchaz</a></code>, <code><a href="#topic+plot.mixpch">plot.mixpch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pchaz(Tint = c(0, 40, 100), lambda=c(.02, .05))
</code></pre>

<hr>
<h2 id='pembro'>Reconstructed Data Set Based On Survival Curves In Burtess et al. 2019</h2><span id='topic+pembro'></span>

<h3>Description</h3>

<p>The data set was approximately reconstructed from the survival curves shown in Figure 2D of Burtness et al. 2019 (see references). It contains survival times and event #' indicator under treatment with pembrolizumab (group 1) versus cetuximab with chemotherapy (group 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pembro)
</code></pre>


<h3>Format</h3>

<p>A data frame.
</p>


<h3>References</h3>

<p>Burtness, B., Harrington, K. J., Greil, R., Soulières, D., Tahara, M., de Castro Jr, G., ... &amp; Abel, E. (2019). Pembrolizumab alone or with chemotherapy
versus cetuximab with chemotherapy for recurrent or metastatic squamous cell carcinoma of the head and neck (KEYNOTE-048): a randomised, open-label,
phase 3 study. The Lancet, 394(10212), 1915-1928.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pembro)
head(pembro)
</code></pre>

<hr>
<h2 id='plot_diagram'>Draw a state space figure</h2><span id='topic+plot_diagram'></span>

<h3>Description</h3>

<p>A figure that shows the states and the possible transitions between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_diagram(
  A,
  B,
  A_subgr_labels = "",
  B_subgr_labels = "",
  which = c("Both", "Experimental", "Control"),
  treatment_labels = c("Experimental", "Control"),
  colors = "default",
  show.rate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_diagram_+3A_a">A</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 0</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_b">B</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 1</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_a_subgr_labels">A_subgr_labels</code></td>
<td>
<p>A character vector with the same length as A$p. It indicates names for the subgroups in A</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_b_subgr_labels">B_subgr_labels</code></td>
<td>
<p>A character vector with the same length as B$p. It indicates names for the subgroups in B</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_which">which</code></td>
<td>
<p>Which treatment arm should be shown? One of &quot;Both&quot;, &quot;Experimental&quot;, &quot;Control&quot;.</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_treatment_labels">treatment_labels</code></td>
<td>
<p>A character vector of length 2 indicating the treatment labels.</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_colors">colors</code></td>
<td>
<p>Either a vector of length two with colors for A and B, or &quot;default&quot;.</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_show.rate">show.rate</code></td>
<td>
<p>A logical indicating whether the rate should be shown in the diagram</p>
</td></tr>
</table>

<hr>
<h2 id='plot_shhr'>Plot of survival, hazard and hazard ratio of two groups as a function of time</h2><span id='topic+plot_shhr'></span>

<h3>Description</h3>

<p>A convenience function that uses the generic plot function in the nph package to
plot the three functions in a layout of 3 columns and 1 row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_shhr(A, B, main = "", xmax = NULL, ymax_haz = NULL, ymax_hr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_shhr_+3A_a">A</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 0</p>
</td></tr>
<tr><td><code id="plot_shhr_+3A_b">B</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 1</p>
</td></tr>
<tr><td><code id="plot_shhr_+3A_main">main</code></td>
<td>
<p>An overall title for the plot</p>
</td></tr>
<tr><td><code id="plot_shhr_+3A_xmax">xmax</code></td>
<td>
<p>A maximum value for the x-axis. The plot is drawn using xlim = c(0, xmax)</p>
</td></tr>
<tr><td><code id="plot_shhr_+3A_ymax_haz">ymax_haz</code></td>
<td>
<p>A maximum value for the y-axis for the hazards plot. The plot is drawn using ylim = c(0, ymax_haz)</p>
</td></tr>
<tr><td><code id="plot_shhr_+3A_ymax_hr">ymax_hr</code></td>
<td>
<p>A maximum value for the y-axis for the hazards ratio plot. The plot is drawn using ylim = c(0, ymax_hr)</p>
</td></tr>
</table>

<hr>
<h2 id='plot_subgroups'>Draw a population composition plot</h2><span id='topic+plot_subgroups'></span>

<h3>Description</h3>

<p>A figure that shows the composition of the population under study though time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_subgroups(
  A,
  B,
  colors = "default",
  max_time = max(A$Tint),
  position = c("stack", "fill"),
  title = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_subgroups_+3A_a">A</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 0</p>
</td></tr>
<tr><td><code id="plot_subgroups_+3A_b">B</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 1</p>
</td></tr>
<tr><td><code id="plot_subgroups_+3A_colors">colors</code></td>
<td>
<p>Either a vector of length four with colors for A and B and subgroup 1 and 2, or &quot;default&quot;.</p>
</td></tr>
<tr><td><code id="plot_subgroups_+3A_max_time">max_time</code></td>
<td>
<p>the maximum value for the x-axis.</p>
</td></tr>
<tr><td><code id="plot_subgroups_+3A_position">position</code></td>
<td>
<p>Either &quot;stack&quot; or &quot;fill&quot;. By default (stack), the total population decreases through time. If position=&quot;fill&quot;, the size of the population is rescaled to show conditional percentages.</p>
</td></tr>
<tr><td><code id="plot_subgroups_+3A_title">title</code></td>
<td>
<p>The text for the title.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>, Nicolas Ballarini
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop_pchaz">pop_pchaz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- pop_pchaz(Tint = c(0, 90, 365),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.2, 0.6, 0.2), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.4, 0.4), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
B &lt;- pop_pchaz(Tint = c(0, 90, 365),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.1, 0.6, 0.1), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.04, 0.04), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
plot_subgroups(A, B, title = "position='stack'")
plot_subgroups(A, B, position='fill', title = "position='fill'")


</code></pre>

<hr>
<h2 id='plot.mixpch'>Plot mixpch Objects</h2><span id='topic+plot.mixpch'></span>

<h3>Description</h3>

<p>Plots survival and other functions stored in <code>mixpch</code> objects versus time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixpch'
plot(
  x,
  fun = c("S", "F", "haz", "cumhaz"),
  add = FALSE,
  ylab = fun,
  xlab = "Time",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mixpch_+3A_x">x</code></td>
<td>
<p>an object of class <code>mixpch</code>.</p>
</td></tr>
<tr><td><code id="plot.mixpch_+3A_fun">fun</code></td>
<td>
<p>character string in <code>c("S","F","haz","cumhaz")</code> indicating which function to plot. Select <code>"S"</code> for the survival function,
<code>"F"</code> for the distribution functin, <code>"haz"</code> for the hazard function or <code>"cumhaz"</code> for the cumulative hazard function.</p>
</td></tr>
<tr><td><code id="plot.mixpch_+3A_add">add</code></td>
<td>
<p>logical, indicates if the drawing should be added to an existing plot.</p>
</td></tr>
<tr><td><code id="plot.mixpch_+3A_ylab">ylab</code></td>
<td>
<p>label of the y-axis</p>
</td></tr>
<tr><td><code id="plot.mixpch_+3A_xlab">xlab</code></td>
<td>
<p>label of the x-axis</p>
</td></tr>
<tr><td><code id="plot.mixpch_+3A_...">...</code></td>
<td>
<p>further arguments passed to the plotting functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pchaz">pchaz</a></code>, <code><a href="#topic+subpop_pchaz">subpop_pchaz</a></code>, <code><a href="#topic+pop_pchaz">pop_pchaz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.2, 0.6, 0.2), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.4, 0.4), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
plot(A)
plot(A, "haz", add = TRUE)

</code></pre>

<hr>
<h2 id='plot.nphparams'>Plot nphparams Objects</h2><span id='topic+plot.nphparams'></span>

<h3>Description</h3>

<p>Plots the estimated survival distributions, shows numbers at risk and indicates the requested parameters for quantifying differences between the survival curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nphparams'
plot(
  x,
  xlim = NULL,
  ylim = c(0, 1),
  trt_name = "Treatment",
  ctr_name = "Control",
  xlab = "Time",
  ylab = "Survival",
  main = "",
  col_ctr = 1,
  col_trt = 2,
  atrisktimes = 0:3,
  bold = 2,
  showlines = FALSE,
  show_rmst_diff = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nphparams_+3A_x">x</code></td>
<td>
<p>an object of class <code>nphparams</code>.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_xlim">xlim</code></td>
<td>
<p>limits of the x-axis, must be a numeric vector of length two</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_ylim">ylim</code></td>
<td>
<p>limits of the y-axis, must be a numeric vector of length two</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_trt_name">trt_name</code></td>
<td>
<p>character, an optional name for group 1 to be shown with the number at risk table in the plot. Default is &quot;Treatment&quot;.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_ctr_name">ctr_name</code></td>
<td>
<p>character, an optional name for group 0 to be shown with the number at risk table in the plot. Default is &quot;Control&quot;.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_xlab">xlab</code></td>
<td>
<p>character, an optional label for the x-axis. Default is &quot;Time&quot;.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_ylab">ylab</code></td>
<td>
<p>character, an optional label for the x-axis. Default is &quot;Survival&quot;.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_main">main</code></td>
<td>
<p>character, an optional title of the plot. Default is &quot;&quot;, showing  no title.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_col_ctr">col_ctr</code></td>
<td>
<p>the color of the survival curve estimate of group 0. Default is 1 (black).</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_col_trt">col_trt</code></td>
<td>
<p>the color of the survival curve estimate of group 1. Default is 2 (red).</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_atrisktimes">atrisktimes</code></td>
<td>
<p>numeric vector of time-points for which the number at risk is displayed.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_bold">bold</code></td>
<td>
<p>numeric, passed to linewidth and font settings. Default is 2, resulting in lines
of width 2 and boldfont. Use 1 for line-width 1 and standard font.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_showlines">showlines</code></td>
<td>
<p>logical, indicating whether the time-points or the quantile-probabilites defined
for the requested parametes should be shown in terms of vertical or horizontal lines. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_show_rmst_diff">show_rmst_diff</code></td>
<td>
<p>logical, indicating whether the estiamted difference in restricted mean survival times should
by visualized by a gray background area.</p>
</td></tr>
<tr><td><code id="plot.nphparams_+3A_...">...</code></td>
<td>
<p>further arguments, not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When setting <code>show_lines</code>, line type 2 (dashed) is used for survival probabilities and quantiles, line type
3 (dotted) is used for the score test, average hazard ratio and Cox model hazard ratio and
line type 5 (long dashed) is used for restricted mean survival time.
</p>


<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nphparams">nphparams</a></code>, <code><a href="#topic+plot.nphparams">plot.nphparams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pembro)
set1&lt;-nphparams(time=time, event=event, group=group,data=pembro,
param_type=c("score","S"),
param_par=c(3.5,2),
param_alternative=c("less","greater"),
closed_test=TRUE,alternative_test="one.sided")
print(set1)
plot(set1,trt_name="Pembrolizumab",ctr_name="Cetuximab")

set2&lt;-nphparams(time=time, event=event, group=group, data=pembro,  
param_type=c("S","S","S","Q","RMST"),
param_par=c(0.5,1,2,0.5,3.5))
print(set2)
plot(set2,showlines=TRUE,show_rmst_diff=TRUE)

</code></pre>

<hr>
<h2 id='pop_pchaz'>Calculate survival for piecewise constant hazards with change after random time and mixture of subpopulations</h2><span id='topic+pop_pchaz'></span>

<h3>Description</h3>

<p>Calculates hazard, cumulative hazard, survival and distribution function
based on hazards that are constant over pre-specified time-intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_pchaz(
  Tint,
  lambdaMat1,
  lambdaMat2,
  lambdaProgMat,
  p,
  timezero = FALSE,
  int_control = list(rel.tol = .Machine$double.eps^0.4, abs.tol = 1e-09),
  discrete_approximation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop_pchaz_+3A_tint">Tint</code></td>
<td>
<p>vector of length <code class="reqn">k+1</code>, for the boundaries of <code class="reqn">k</code> time intervals (presumably in days) with piecewise constant hazard. The boundaries should be increasing and the first one should
be <code>0</code>, the last one should be larger than the assumed trial duration.</p>
</td></tr>
<tr><td><code id="pop_pchaz_+3A_lambdamat1">lambdaMat1</code></td>
<td>
<p>matrix of dimension <code class="reqn">m</code>-by-<code class="reqn">k</code>, each row contains the vector of piecewise constant hazards for one subpopulation before the changeing event happens, for the intervals speciefied via <code>Tint</code>.</p>
</td></tr>
<tr><td><code id="pop_pchaz_+3A_lambdamat2">lambdaMat2</code></td>
<td>
<p>matrix of dimension <code class="reqn">m</code>-by-<code class="reqn">k</code>, each row contains the vector piecewise constant hazards for one subpopulation after the changeing event has happened, for the intervals speciefied via <code>Tint</code>.</p>
</td></tr>
<tr><td><code id="pop_pchaz_+3A_lambdaprogmat">lambdaProgMat</code></td>
<td>
<p>matrix of dimension <code class="reqn">m</code>-by-<code class="reqn">k</code>, each row contains the vector of piecewise constant hazards for one subpopulation for the changeing event, for the intervals speciefied via <code>Tint</code>.</p>
</td></tr>
<tr><td><code id="pop_pchaz_+3A_p">p</code></td>
<td>
<p>vector of length <code class="reqn">m</code> for relative sizes (proportions) of the subpopulations. They should sum up to 1.</p>
</td></tr>
<tr><td><code id="pop_pchaz_+3A_timezero">timezero</code></td>
<td>
<p>logical, indicating whether after the changing event the timecount, governing which interval in <code>Tint</code> and which according value in
<code>lambda2</code> is used, should restart at zero. This argument is either of length 1 (applying the same to all subgroups) or the same length as the number of subgroups.</p>
</td></tr>
<tr><td><code id="pop_pchaz_+3A_int_control">int_control</code></td>
<td>
<p>A list with additional paramaters to be passed to the  <code><a href="stats.html#topic+integrate">integrate</a></code> function.</p>
</td></tr>
<tr><td><code id="pop_pchaz_+3A_discrete_approximation">discrete_approximation</code></td>
<td>
<p>if TRUE, the function uses an approximation based on discretizing the time, instead of integrating. This speeds up the calculations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">m</code> subgroups with relative sizes <code class="reqn">p_1, \dots, p_m</code> and
subgroup-specific survival functions <code class="reqn">S{l}(t)</code>,
the marginal survival function is the mixture <code class="reqn">S(t)=\sum_{l=1}^m p_l S_{l}(t)</code>.
Note that the respective hazard function is not a linear combination of the
subgroup-specific hazard functions.
It may be calculated by the general relation <code class="reqn">\lambda(t)=-\frac{dS(t)}{dt}\frac{1}{S(t)}</code>.
In each subgroup, the hazard is modelled as a piecewise constant hazard, with
the possibility to also model disease progression.
Therefore, each row of the hazard rates is used in <code><a href="#topic+subpop_pchaz">subpop_pchaz</a></code>.
See <code><a href="#topic+pchaz">pchaz</a></code> and <code><a href="#topic+subpop_pchaz">subpop_pchaz</a></code>
for more details.
The output includes the function values calculated for all integer time points
between 0 and the maximum of <code>Tint</code>.
</p>
<p>Note: this function may be very slow in cases where many time points need to be calculated. If this happens, use
<code>discrete_approximation = TRUE</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>mixpch</code> containing the following components:
</p>

<dl>
<dt><code>haz</code></dt><dd><p>Values of the hazard function.</p>
</dd>
<dt><code>cumhaz</code></dt><dd><p>Values of the cumulative hazard function.</p>
</dd>
<dt><code>S</code></dt><dd><p>Values of the survival function.</p>
</dd>
<dt><code>F</code></dt><dd><p>Values of the distribution function.</p>
</dd>
<dt><code>t</code></dt><dd><p>Time points for which the values of the different functions are calculated.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>, Nicolas Ballarini
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pchaz">pchaz</a></code>, <code><a href="#topic+subpop_pchaz">subpop_pchaz</a></code>, <code><a href="#topic+plot.mixpch">plot.mixpch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop_pchaz(Tint = c(0, 40, 100),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2),
 lambdaMat2 = matrix(c(0.5, 0.2, 0.6, 0.2), 2, 2),
 lambdaProg = matrix(c(0.5, 0.5, 0.4, 0.4), 2, 2),
 p = c(0.8, 0.2),
 timezero = FALSE, discrete_approximation = TRUE)
</code></pre>

<hr>
<h2 id='print.nphparams'>Print nphparams Objects</h2><span id='topic+print.nphparams'></span>

<h3>Description</h3>

<p>Prints the results table of an nphparams object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nphparams'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nphparams_+3A_x">x</code></td>
<td>
<p>an object of class <code>nphparams</code>.</p>
</td></tr>
<tr><td><code id="print.nphparams_+3A_...">...</code></td>
<td>
<p>further arguments, not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estiamtes corresponding to differences at a log scale are transformed by taking exp(), and are labelled as ratios. I.e. differnces in log urvival probabilites,
differences in log quantiles, cloglog survival differences (equivalent to the log cumulative hazard ratio), log average hazard ratios or Cox model log hazard ratioss are
transformed to survival probability ratios, quantile ratios, cumulative hazard ratios, average hazard ratios or Cox model hazard ratios, respectively. In the output,
the standard error at the backtransformed scale is calculated by the delta-method. Confidence interval bounds are calculated at the log-scale, though, and then
transformed by taking exp().
</p>


<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nphparams">nphparams</a></code>, <code><a href="#topic+plot.nphparams">plot.nphparams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pembro)
set1&lt;-nphparams(time=time, event=event, group=group,data=pembro,
param_type=c("score","S"),
param_par=c(3.5,2),
param_alternative=c("less","greater"),
closed_test=TRUE,alternative_test="one.sided")
print(set1)
plot(set1,trt_name="Pembrolizumab",ctr_name="Cetuximab")

set2&lt;-nphparams(time=time, event=event, group=group, data=pembro,  
param_type=c("S","S","S","Q","RMST"),
param_par=c(0.5,1,2,0.5,3.5))
print(set2)
plot(set2,showlines=TRUE,show_rmst_diff=TRUE)

</code></pre>

<hr>
<h2 id='rSurv_conditional_fun'>Draw conditional random survival times from mixpch object.</h2><span id='topic+rSurv_conditional_fun'></span>

<h3>Description</h3>

<p>Draws independent random survival times from <code>mixpch</code> objects conditional on
observed time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSurv_conditional_fun(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSurv_conditional_fun_+3A_x">x</code></td>
<td>
<p>An object of class <code>mixpch</code></p>
</td></tr>
<tr><td><code id="rSurv_conditional_fun_+3A_y">y</code></td>
<td>
<p>A vector of observed right censored times</p>
</td></tr>
</table>


<h3>Details</h3>

<pre>Note that the mixpch object stores the survival function up to some time T. For random times equal or larger T, the value T is returned.
</pre>


<h3>Value</h3>

<p>A vector of random survival times, conditional on the observed censored times.
</p>


<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSurv_fun">rSurv_fun</a></code>, <code><a href="#topic+sample_fun">sample_fun</a></code>, <code><a href="#topic+sample_conditional_fun">sample_conditional_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.2, 0.6, 0.2), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.4, 0.4), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
rSurv_conditional_fun(x = A, y = c(10,15,9,2,1))
</code></pre>

<hr>
<h2 id='rSurv_fun'>Draw random survival times from mixpch object.</h2><span id='topic+rSurv_fun'></span>

<h3>Description</h3>

<p>Draws independent random survival times from <code>mixpch</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSurv_fun(n, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSurv_fun_+3A_n">n</code></td>
<td>
<p>Number of random draws</p>
</td></tr>
<tr><td><code id="rSurv_fun_+3A_x">x</code></td>
<td>
<p>An object of class <code>mixpch</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mixpch object stores the survival function up to some time T. For random times equal or larger T, the value T is returned.
</p>


<h3>Value</h3>

<p>A vector of random survival times.
</p>


<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSurv_conditional_fun">rSurv_conditional_fun</a></code>, <code><a href="#topic+sample_fun">sample_fun</a></code>, <code><a href="#topic+sample_conditional_fun">sample_conditional_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.2, 0.6, 0.2), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.4, 0.4), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
rSurv_fun(n = 10, x = A)

</code></pre>

<hr>
<h2 id='sample_conditional_fun'>Draw conditional survival times based on study settings</h2><span id='topic+sample_conditional_fun'></span>

<h3>Description</h3>

<p>Simulates data for a randomized controlled survival study conditional on observed interim data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_conditional_fun(
  dat,
  A,
  B,
  r0 = 0.5,
  eventEnd,
  lambdaRecr,
  lambdaCens,
  maxRecrCalendarTime,
  maxCalendar
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_conditional_fun_+3A_dat">dat</code></td>
<td>
<p>A data frame with the same structure and column names as the output of <code><a href="#topic+sample_fun">sample_fun</a></code>, containing the data to condition on</p>
</td></tr>
<tr><td><code id="sample_conditional_fun_+3A_a">A</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 0</p>
</td></tr>
<tr><td><code id="sample_conditional_fun_+3A_b">B</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 1</p>
</td></tr>
<tr><td><code id="sample_conditional_fun_+3A_r0">r0</code></td>
<td>
<p>Allocation ratio to group 1 (must be a number between 0 and 1)</p>
</td></tr>
<tr><td><code id="sample_conditional_fun_+3A_eventend">eventEnd</code></td>
<td>
<p>Number of events, after which the study stops</p>
</td></tr>
<tr><td><code id="sample_conditional_fun_+3A_lambdarecr">lambdaRecr</code></td>
<td>
<p>Rate per day for recruiting patients, assuming recruitung follows a Poisson process</p>
</td></tr>
<tr><td><code id="sample_conditional_fun_+3A_lambdacens">lambdaCens</code></td>
<td>
<p>Rate per day for random censoring, assuming censoring times are exponential</p>
</td></tr>
<tr><td><code id="sample_conditional_fun_+3A_maxrecrcalendartime">maxRecrCalendarTime</code></td>
<td>
<p>Maximal duration of recruitment in days</p>
</td></tr>
<tr><td><code id="sample_conditional_fun_+3A_maxcalendar">maxCalendar</code></td>
<td>
<p>Maximal total study duration in days, after which the study stops</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simulating the data, patients are allocated randomly to either group (unrestricted randomization).
</p>


<h3>Value</h3>

<p>A data frame with each line representing data for one patient and the following columns:
</p>

<dl>
<dt><code>group</code></dt><dd><p>Treatment group</p>
</dd>
<dt><code>inclusion</code></dt><dd><p>Start of observation in terms of calendar time</p>
</dd>
<dt><code>y</code></dt><dd><p>Observed survival/censored time</p>
</dd>
<dt><code>yCalendar</code></dt><dd><p>End of observation in terms of calendar time.</p>
</dd>
<dt><code>event</code></dt><dd><p>logical, <code>TRUE</code> indicates the observation ended with an event, <code>FALSE</code> corresponds to censored times</p>
</dd>
<dt><code>adminCens</code></dt><dd><p>logical, <code>True</code> indicates that the observation is subject to administrative censoring, i.e. the subject was observed until the
end of the study without an event.</p>
</dd>
<dt><code>cumEvents</code></dt><dd><p>Cumulative number of events over calendar time of end of observation</p>
</dd>
</dl>

<p>The data frame is ordered by <code>yCalendar</code>
</p>


<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSurv_fun">rSurv_fun</a></code>, <code><a href="#topic+rSurv_conditional_fun">rSurv_conditional_fun</a></code>, <code><a href="#topic+sample_fun">sample_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.2, 0.6, 0.2), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.4, 0.4), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
B &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.1, 0.6, 0.1), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.04, 0.04), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
datinterim &lt;- sample_fun(A, B, r0 = 0.5, eventEnd = 30, lambdaRecr = 1,
  lambdaCens = 0.25 / 365,
 maxRecrCalendarTime = 3 * 365,
 maxCalendar = 4 * 365)
datcond &lt;- sample_conditional_fun(datinterim, A, B, r0 = 0.5, eventEnd = 60,
  lambdaRecr = 1, lambdaCens = 0.25 / 365, maxRecrCalendarTime = 3 * 365, 
  maxCalendar = 4 * 365)
</code></pre>

<hr>
<h2 id='sample_fun'>Draw survival times based on study settings</h2><span id='topic+sample_fun'></span>

<h3>Description</h3>

<p>Simulates data for a randomized controlled survival study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fun(
  A,
  B,
  r0 = 0.5,
  eventEnd,
  lambdaRecr,
  lambdaCens,
  maxRecrCalendarTime,
  maxCalendar
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_fun_+3A_a">A</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 0</p>
</td></tr>
<tr><td><code id="sample_fun_+3A_b">B</code></td>
<td>
<p>An object of class <code>mixpch</code>, resembling the survival function in treatment group 1</p>
</td></tr>
<tr><td><code id="sample_fun_+3A_r0">r0</code></td>
<td>
<p>Allocation ratio to group 0 (must be a number between 0 and 1)</p>
</td></tr>
<tr><td><code id="sample_fun_+3A_eventend">eventEnd</code></td>
<td>
<p>Number of events, after which the study stops</p>
</td></tr>
<tr><td><code id="sample_fun_+3A_lambdarecr">lambdaRecr</code></td>
<td>
<p>Rate per day for recruiting patients, assuming recruitung follows a Poisson process</p>
</td></tr>
<tr><td><code id="sample_fun_+3A_lambdacens">lambdaCens</code></td>
<td>
<p>Rate per day for random censoring, assuming censoring times are exponential</p>
</td></tr>
<tr><td><code id="sample_fun_+3A_maxrecrcalendartime">maxRecrCalendarTime</code></td>
<td>
<p>Maximal duration of recruitment in days</p>
</td></tr>
<tr><td><code id="sample_fun_+3A_maxcalendar">maxCalendar</code></td>
<td>
<p>Maximal total study duration in days, after which the study stops</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simulating the data, patients are allocated randomly to either group (unrestricted randomization).
</p>


<h3>Value</h3>

<p>A data frame with each line representing data for one patient and the following columns:
</p>

<dl>
<dt><code>group</code></dt><dd><p>Treatment group</p>
</dd>
<dt><code>inclusion</code></dt><dd><p>Start of observation in terms of calendar time</p>
</dd>
<dt><code>y</code></dt><dd><p>Observed survival/censored time</p>
</dd>
<dt><code>yCalendar</code></dt><dd><p>End of observation in terms of calendar time.</p>
</dd>
<dt><code>event</code></dt><dd><p>logical, <code>TRUE</code> indicates the observation ended with an event, <code>FALSE</code> corresponds to censored times</p>
</dd>
<dt><code>adminCens</code></dt><dd><p>logical, <code>True</code> indicates that the observation is subject to administrative censoring, i.e. the subject was observed until the
end of the study without an event.</p>
</dd>
<dt><code>cumEvents</code></dt><dd><p>Cumulative number of events over calendar time of end of observation</p>
</dd>
</dl>

<p>The data frame is ordered by <code>yCalendar</code>
</p>


<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSurv_fun">rSurv_fun</a></code>, <code><a href="#topic+rSurv_conditional_fun">rSurv_conditional_fun</a></code>, <code><a href="#topic+sample_conditional_fun">sample_conditional_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.2, 0.6, 0.2), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.4, 0.4), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
B &lt;- pop_pchaz(Tint = c(0, 90, 1500),
  lambdaMat1 = matrix(c(0.2, 0.1, 0.4, 0.1), 2, 2) / 365,
 lambdaMat2 = matrix(c(0.5, 0.1, 0.6, 0.1), 2, 2) / 365,
 lambdaProg = matrix(c(0.5, 0.5, 0.04, 0.04), 2, 2) / 365,
 p = c(0.8, 0.2), 
 timezero = FALSE, discrete_approximation = TRUE)
plot(A)
plot(B, add = TRUE)
dat &lt;- sample_fun(A, B, r0 = 0.5, eventEnd = 30, lambdaRecr = 0.5,
  lambdaCens = 0.25 / 365, maxRecrCalendarTime = 2 * 365,
  maxCalendar = 4 * 365)
</code></pre>

<hr>
<h2 id='subpop_pchaz'>Calculate survival for piecewise constant hazards with change after random time</h2><span id='topic+subpop_pchaz'></span>

<h3>Description</h3>

<p>Calculates hazard, cumulative hazard, survival and distribution function
based on hazards that are constant over pre-specified time-intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subpop_pchaz(
  Tint,
  lambda1,
  lambda2,
  lambdaProg,
  timezero = FALSE,
  int_control = list(rel.tol = .Machine$double.eps^0.4, abs.tol = 1e-09),
  discrete_approximation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subpop_pchaz_+3A_tint">Tint</code></td>
<td>
<p>vector of length <code class="reqn">k+1</code>, for the boundaries of <code class="reqn">k</code> time intervals (presumably in days) with piecewise constant hazard. The boundaries should be increasing and the first one should
be <code>0</code>, the last one should be larger than the assumed trial duration.</p>
</td></tr>
<tr><td><code id="subpop_pchaz_+3A_lambda1">lambda1</code></td>
<td>
<p>vector of length <code class="reqn">k</code> for piecewise constant hazards before the changing event happens, for the intervals specified via <code>T</code>.</p>
</td></tr>
<tr><td><code id="subpop_pchaz_+3A_lambda2">lambda2</code></td>
<td>
<p>vector of length <code class="reqn">k</code> for piecewise constant hazards after the changing event has happened, for the intervals specified via <code>T</code>.</p>
</td></tr>
<tr><td><code id="subpop_pchaz_+3A_lambdaprog">lambdaProg</code></td>
<td>
<p>vector of length <code class="reqn">k</code> for piecewise constant hazards for the changing event, for the intervals specified via <code>T</code>.</p>
</td></tr>
<tr><td><code id="subpop_pchaz_+3A_timezero">timezero</code></td>
<td>
<p>logical, indicating whether after the changeing event the timecount, governing which interval in <code>Tint</code> and which according value in
<code>lambda2</code> is used, should restart at zero.</p>
</td></tr>
<tr><td><code id="subpop_pchaz_+3A_int_control">int_control</code></td>
<td>
<p>A list with the <code>rel.tol</code> and <code>abs.tol</code> paramaters to be passed to the  <code><a href="stats.html#topic+integrate">integrate</a></code> function.</p>
</td></tr>
<tr><td><code id="subpop_pchaz_+3A_discrete_approximation">discrete_approximation</code></td>
<td>
<p>if TRUE, the function uses an approximation based on discretizing the time, instead of integrating. This speeds up the calculations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that the time to disease progression <code class="reqn">T_{PD}</code> is governed
by a separate process with hazard function <code class="reqn">\eta(t)</code>,
which does not depend on the hazard function for death <code class="reqn">\lambda(t)</code>.
<code class="reqn">\eta(t)</code>, too, may be modelled as piecewise constant or, for simplicity,
as constant over time. We define <code class="reqn">\lambda_{prePD}(t)</code> and <code class="reqn">\lambda_{postPD}(t)</code>
as the hazard functions for death before and after disease progression.
Conditional on <code class="reqn">T_{PD}=s</code>, the hazard function for death is
<code class="reqn">\lambda(t|T_{PD}=s)=\lambda_{prePD}(t){I}_{t\leq s}+\lambda_{postPD}(t){I}_{t&gt;s}</code>.
The conditional survival function is
<code class="reqn">S(t|T_{PD}=s)=\exp(-\int_0^t \lambda(t|T_{PD}=s)ds)</code>.
The unconditional survival function results from integration over all
possible progression times as <code class="reqn">S(t)=\int_0^t S(t|T_{PD}=s)dP(T_{PD}=s)</code>.
The output includes the function values calculated for all integer time points
between 0 and the maximum of <code>Tint</code>.
Additionally, a list with functions is also given to calculate the values at any arbitrary point <code class="reqn">t</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>mixpch</code> containing the following components:
</p>

<dl>
<dt><code>haz</code></dt><dd><p>Values of the hazard function.</p>
</dd>
<dt><code>cumhaz</code></dt><dd><p>Values of the cumulative hazard function.</p>
</dd>
<dt><code>S</code></dt><dd><p>Values of the survival function.</p>
</dd>
<dt><code>F</code></dt><dd><p>Values of the distribution function.</p>
</dd>
<dt><code>t</code></dt><dd><p>Time points for which the values of the different functions are calculated.</p>
</dd>
<dt><code>Tint</code></dt><dd><p>Input vector of boundaries of time intervals.</p>
</dd>
<dt><code>lambda1</code></dt><dd><p>Input vector of piecewise constant hazards before the changing event happen.</p>
</dd>
<dt><code>lambda2</code></dt><dd><p>Input vector of piecewise constant hazards after the changing event happen.</p>
</dd>
<dt><code>lambdaProg</code></dt><dd><p>Input vector of piecewise constant hazards for the changing event.</p>
</dd>
<dt><code>funs</code></dt><dd><p>A list with functions to calculate the hazard, cumulative hazard, survival, and cdf over arbitrary continuous times.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>, Nicolas Ballarini
</p>


<h3>References</h3>

<p>Robin Ristl, Nicolas Ballarini, Heiko Götte, Armin Schüler, Martin Posch, Franz König. Delayed treatment effects, treatment switching and
heterogeneous patient populations: How to design and analyze RCTs in oncology. Pharmaceutical statistics. 2021; 20(1):129-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pchaz">pchaz</a></code>, <code><a href="#topic+pop_pchaz">pop_pchaz</a></code>, <code><a href="#topic+plot.mixpch">plot.mixpch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subpop_pchaz(Tint = c(0, 40, 100), lambda1 = c(0.2, 0.4), lambda2 = c(0.1, 0.01),
lambdaProg = c(0.5, 0.4),timezero = FALSE, discrete_approximation = TRUE)
subpop_pchaz(Tint = c(0, 40, 100), lambda1 = c(0.2, 0.4), lambda2 = c(0.1, 0.01),
lambdaProg = c(0.5, 0.4), timezero = TRUE, discrete_approximation = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
