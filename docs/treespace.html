<!DOCTYPE html><html><head><title>Help for package treespace</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treespace}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.render.server.info'><p>Auxiliary functions</p></a></li>
<li><a href='#DengueBEASTMCC'><p>Dengue fever BEAST MCC tree</p></a></li>
<li><a href='#DengueSeqs'><p>Dengue fever sequences</p></a></li>
<li><a href='#DengueTrees'><p>BEAST analysis of Dengue fever</p></a></li>
<li><a href='#findGroves'><p>Identify clusters of similar trees</p></a></li>
<li><a href='#findMRCIs'><p>Find MRCIs</p></a></li>
<li><a href='#fluTrees'><p>BEAST analysis of seasonal influenza (A/H3N2)</p></a></li>
<li><a href='#linearMrca'><p>Linear MRCA function</p></a></li>
<li><a href='#makeCollapsedTree'><p>Collapse a tree into a single tip per category</p></a></li>
<li><a href='#medTree'><p>Geometric median tree function</p></a></li>
<li><a href='#multiDist'><p>Metric function for <code>multiPhylo</code> input</p></a></li>
<li><a href='#plotGroves'><p>Scatterplot of groups of trees</p></a></li>
<li><a href='#plotGrovesD3'><p>Scatterplot of groups of trees using <code>scatterD3</code></p></a></li>
<li><a href='#plotTreeDiff'><p>Plot tree differences</p></a></li>
<li><a href='#refTreeDist'><p>Metric function for comparing a reference <code>phylo</code> to <code>multiPhylo</code> input</p></a></li>
<li><a href='#relatedTreeDist'><p>Tree distance when trees have &quot;related&quot; tips</p></a></li>
<li><a href='#simulateIndTree'><p>Simulate randomised &quot;individuals&quot; tree</p></a></li>
<li><a href='#tipDiff'><p>Find tip position differences</p></a></li>
<li><a href='#tipsMRCAdepths'><p>Tip-tip MRCA depths</p></a></li>
<li><a href='#treeConcordance'><p>Tree concordance</p></a></li>
<li><a href='#treeDist'><p>Metric function</p></a></li>
<li><a href='#treespace'><p>Phylogenetic tree exploration</p></a></li>
<li><a href='#treespaceServer'><p>Web-based tree explorer</p></a></li>
<li><a href='#treeVec'><p>Tree vector function</p></a></li>
<li><a href='#wiwMedTree'><p>Median transmission tree</p></a></li>
<li><a href='#wiwTreeDist'><p>Transmission tree distance</p></a></li>
<li><a href='#woodmiceTrees'><p>Bootstrap trees from woodmouse dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistical Exploration of Landscapes of Phylogenetic Trees</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-07</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for the exploration of distributions of phylogenetic trees.
    This package includes a 'shiny' interface which can be started from R using
    treespaceServer(). 
    For further details see Jombart et al. (2017) &lt;<a href="https://doi.org/10.1111%2F1755-0998.12676">doi:10.1111/1755-0998.12676</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), ape, ade4</td>
</tr>
<tr>
<td>Imports:</td>
<td>adegenet, adegraphics, combinat, compiler, distory, fields,
htmlwidgets, MASS, methods, parallel, phangorn, phytools, Rcpp,
rgl, RLumShiny, scatterD3, shiny, shinyBS, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, igraph, knitr, pander, RColorBrewer, reshape2,
rmarkdown, sf, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>RcppExports.R metrics.R medTree.R treespace.R findGroves.R
plotGroves.R plotTreeDiff.R servers.R transmissionTrees.R
data.R makeCollapsedTree.R relatedTreeDist.R simulateIndTree.R
tipsMRCAdepths.R treeConcordance.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=treespace">https://cran.r-project.org/package=treespace</a>,
<a href="https://github.com/thibautjombart/treespace">https://github.com/thibautjombart/treespace</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thibautjombart/treespace/issues">https://github.com/thibautjombart/treespace/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-07 15:27:18 UTC; michellekendall</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-07 16:10:02 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Thibaut Jombart <a href="https://orcid.org/0000-0003-2226-8692"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Michelle Kendall <a href="https://orcid.org/0000-0001-7344-7071"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jacob Almagro-Garcia
    <a href="https://orcid.org/0000-0002-0595-7333"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Caroline Colijn <a href="https://orcid.org/0000-0001-6097-6708"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michelle Kendall &lt;michelle.kendall@warwick.ac.uk&gt;</td>
</tr>
</table>
<hr>
<h2 id='.render.server.info'>Auxiliary functions</h2><span id='topic+.render.server.info'></span>

<h3>Description</h3>

<p>These functions are not supposed to be used by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.render.server.info()
</code></pre>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>

<hr>
<h2 id='DengueBEASTMCC'>Dengue fever BEAST MCC tree</h2><span id='topic+DengueBEASTMCC'></span>

<h3>Description</h3>

<p>The maximum clade credibility (MCC) tree from <code><a href="#topic+DengueTrees">DengueTrees</a></code>
</p>


<h3>Format</h3>

<p>A phylo object
</p>


<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Source</h3>

<p>http://bmcevolbiol.biomedcentral.com/articles/10.1186/1471-2148-7-214
</p>


<h3>References</h3>

<p>Drummond, A. J., and Rambaut, A. (2007) 
BEAST: Bayesian evolutionary analysis by sampling trees.
<em>BMC Evolutionary Biology</em>, 7(1), 214.
</p>
<p>Lanciotti, R. S., Gubler, D. J., and Trent, D. W. (1997)
Molecular evolution and phylogeny of dengue-4 viruses.
<em>Journal of General Virology</em>, 78(9), 2279-2286.
</p>

<hr>
<h2 id='DengueSeqs'>Dengue fever sequences</h2><span id='topic+DengueSeqs'></span>

<h3>Description</h3>

<p>17 dengue virus serotype 4 sequences from Lanciotti et al. (1997)
</p>


<h3>Format</h3>

<p>A DNAbin object containing 17 DNA sequences, each of length 1485.
</p>


<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Source</h3>

<p>http://bmcevolbiol.biomedcentral.com/articles/10.1186/1471-2148-7-214
</p>


<h3>References</h3>

<p>Lanciotti, R. S., Gubler, D. J., and Trent, D. W. (1997)
Molecular evolution and phylogeny of dengue-4 viruses.
<em>Journal of General Virology</em>, 78(9), 2279-2286.
</p>

<hr>
<h2 id='DengueTrees'>BEAST analysis of Dengue fever</h2><span id='topic+DengueTrees'></span>

<h3>Description</h3>

<p>These trees were created using one of the <code>xml</code> files provided with the original BEAST paper by Drummond and Rambaut (2007).
They provide an example of 17 dengue virus serotype 4 sequences from Lanciotti et al. (1997) (available as <code><a href="#topic+DengueSeqs">DengueSeqs</a></code>) and <code>xml</code> files with varying priors for model and clock rate.
Here we include a random sample of 500 of the trees (from the second half of the posterior) produced using BEAST v1.8 with the standard GTR + Gamma + I substitution model with uncorrelated lognormal-distributed relaxed molecular clock (file 4).
</p>


<h3>Format</h3>

<p>A multiPhylo object containing 500 trees, each with 17 tips
</p>


<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Source</h3>

<p>http://bmcevolbiol.biomedcentral.com/articles/10.1186/1471-2148-7-214
</p>


<h3>References</h3>

<p>Drummond, A. J., and Rambaut, A. (2007) 
BEAST: Bayesian evolutionary analysis by sampling trees.
<em>BMC Evolutionary Biology</em>, 7(1), 214.
</p>
<p>Lanciotti, R. S., Gubler, D. J., and Trent, D. W. (1997)
Molecular evolution and phylogeny of dengue-4 viruses.
<em>Journal of General Virology</em>, 78(9), 2279-2286.
</p>

<hr>
<h2 id='findGroves'>Identify clusters of similar trees</h2><span id='topic+findGroves'></span>

<h3>Description</h3>

<p>This function uses hierarchical clustering on principal components output by <code><a href="#topic+treespace">treespace</a></code> to identify groups of similar trees. Clustering relies on <code><a href="stats.html#topic+hclust">hclust</a></code>, using Ward's method by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findGroves(
  x,
  method = "treeVec",
  nf = NULL,
  clustering = "ward.D2",
  nclust = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findGroves_+3A_x">x</code></td>
<td>
<p>an object of the class multiPhylo or the output of the function <code>treespace</code></p>
</td></tr>
<tr><td><code id="findGroves_+3A_method">method</code></td>
<td>
<p>(ignored if x is from <code>treespace</code>) this specifies a function which outputs the summary of a tree in the form of a vector. Defaults to <code>treeVec</code>.</p>
</td></tr>
<tr><td><code id="findGroves_+3A_nf">nf</code></td>
<td>
<p>(ignored if x is from <code>treespace</code>) the number of principal components to retain</p>
</td></tr>
<tr><td><code id="findGroves_+3A_clustering">clustering</code></td>
<td>
<p>a character string indicating the clustering method to be used; defaults to Ward's method; see argument <code>method</code> in <code>?hclust</code> for more details.</p>
</td></tr>
<tr><td><code id="findGroves_+3A_nclust">nclust</code></td>
<td>
<p>an integer indicating the number of clusters to find; if not provided, an interactive process based on cutoff threshold selection is used.</p>
</td></tr>
<tr><td><code id="findGroves_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>treespace</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> groups: a factor defining groups of trees
</p>
</li>
<li><p> treespace: the output of treespace
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>
<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotGroves">plotGroves</a></code> to display results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("adegenet") &amp;&amp; require("adegraphics")){
## load data
data(woodmiceTrees)

## run findGroves: treespace+clustering
res &lt;- findGroves(woodmiceTrees, nf=5, nclust=6)

## plot results on first 2 axes
PCs &lt;- res$treespace$pco$li
s.class(PCs, fac=res$groups, col=funky(6))

## using plotGroves
plotGroves(res)
}


</code></pre>

<hr>
<h2 id='findMRCIs'>Find MRCIs</h2><span id='topic+findMRCIs'></span>

<h3>Description</h3>

<p>Function to find the most recent common infector (MRCI) matrix from &quot;who infected whom&quot; information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMRCIs(wiw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findMRCIs_+3A_wiw">wiw</code></td>
<td>
<p>a two-column matrix where the first column gives the infectors and the second column gives the infectees; each row corresponds to a transmission event from an infector to an infectee.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns three objects:
</p>

<ul>
<li> <p><code>sourceCase</code>: the number of the node which is the source case, i.e. the common infector of all cases (outputs a warning if there is more than one source case).
</p>
</li>
<li> <p><code>mrcis</code>: a matrix where, for each pair of individuals i and j, the entry (i,j) is the node number of their MRCI. Note that if i infected j then this entry is i itself.
</p>
</li>
<li> <p><code>mrciDepths</code>: a matrix where, for each pair of individuals i and j, the entry (i,j) is the depth of their MRCI, defined as the number of edges from the source case. The source case has depth zero, its direct infectees have depth 1, and so on. 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## a simple who infected whom matrix:
tree1 &lt;- cbind(Infector=1:5,Infectee=2:6) 
findMRCIs(tree1)


</code></pre>

<hr>
<h2 id='fluTrees'>BEAST analysis of seasonal influenza (A/H3N2)</h2><span id='topic+fluTrees'></span>

<h3>Description</h3>

<p>These trees were created using BEAST on hemagglutinin (HA) segments
of seasonal influenza A/H3N2 samples collected in New-York city (US)  between 2000 and 2003. This data comes from the influenza BEAST tutorial distributed at:
http://beast.bio.ed.ac.uk/tutorials
</p>


<h3>Format</h3>

<p>A multiPhylo object containing 200 trees, each with 165 tips
</p>


<h3>Details</h3>

<p>Only the first 200 trees (out of 10,000) were retained.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>Source</h3>

<p>http://beast.bio.ed.ac.uk/tutorials
</p>


<h3>References</h3>

<p>http://beast.bio.ed.ac.uk/tutorials
</p>

<hr>
<h2 id='linearMrca'>Linear MRCA function</h2><span id='topic+linearMrca'></span>

<h3>Description</h3>

<p>Function to make the most recent common ancestor (MRCA) matrix of a tree, where entry (i,j) gives the MRCA of tips i and j.
The function is linear, exploiting the fact that the tree is rooted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearMrca(tree, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearMrca_+3A_tree">tree</code></td>
<td>
<p>an object of the class <code>phylo</code> which should be rooted.</p>
</td></tr>
<tr><td><code id="linearMrca_+3A_k">k</code></td>
<td>
<p>(optional) number of tips in tree, for faster computation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a random tree
x &lt;- rtree(6)

## create matrix of MRCAs: entry (i,j) is the node number of the MRCA of tips i and j
linearMrca(x,6)


</code></pre>

<hr>
<h2 id='makeCollapsedTree'>Collapse a tree into a single tip per category</h2><span id='topic+makeCollapsedTree'></span>

<h3>Description</h3>

<p>Reduce a tree with many tips into a tree with a single tip per category. 
Where a category's tips form a monophyletic clade, the clade is replaced by a single tip labelled by that category.
Where a category's tips are paraphyletic, the largest clade for that category is treated as above, and all other tips pruned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCollapsedTree(tree, df, warnings = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCollapsedTree_+3A_tree">tree</code></td>
<td>
<p>an object of the class <code>phylo</code>: the tree to collapse.</p>
</td></tr>
<tr><td><code id="makeCollapsedTree_+3A_df">df</code></td>
<td>
<p>a two-column data frame linking tip labels (column 2) with their corresponding categories (column 1).</p>
</td></tr>
<tr><td><code id="makeCollapsedTree_+3A_warnings">warnings</code></td>
<td>
<p>a logical determining whether a warning should be given if there are paraphyletic categories (default TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree (class <code>phylo</code>) whose tip labels are exactly the set of unique categories from <code>df</code>.
</p>


<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treeConcordance">treeConcordance</a></code> <code><a href="#topic+simulateIndTree">simulateIndTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# simulate a tree which is monophyletic per category
tree &lt;- simulateIndTree(rtree(5), permuteTips=FALSE)

df &lt;- cbind(sort(rep(rtree(5)$tip.label,5)),sort(tree$tip.label))
palette &lt;- c("red","blue","black","green","purple")#' 
tipCols &lt;- palette[as.factor(sapply(tree$tip.label, function(l) df[which(df[,2]==l),1]))]
plot(tree, tip.color=tipCols)
collapsedTree &lt;- makeCollapsedTree(tree,df)
plot(collapsedTree, tip.color=palette[as.factor(collapsedTree$tip.label)])

# simulate a tree which is paraphyletic per category
tree &lt;- simulateIndTree(rtree(5), tipPercent=20)
tipCols &lt;- palette[as.factor(sapply(tree$tip.label, function(l) df[which(df[,2]==l),1]))]
plot(tree, tip.color=tipCols)
collapsedTree &lt;- makeCollapsedTree(tree,df)
plot(collapsedTree, tip.color=palette[as.factor(collapsedTree$tip.label)])

</code></pre>

<hr>
<h2 id='medTree'>Geometric median tree function</h2><span id='topic+medTree'></span>

<h3>Description</h3>

<p>Finds the geometric median of a set of trees according to the Kendall Colijn metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medTree(
  x,
  groups = NULL,
  lambda = 0,
  weights = NULL,
  emphasise.tips = NULL,
  emphasise.weight = 2,
  return.lambda.function = FALSE,
  save.memory = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medTree_+3A_x">x</code></td>
<td>
<p>A list of trees of the class multiPhylo, for which the median tree will be computed, <br />
OR a matrix of tree vectors as given by <code>treespace$vectors</code>.</p>
</td></tr>
<tr><td><code id="medTree_+3A_groups">groups</code></td>
<td>
<p>an optional factor defining groups of trees; if provided, one median tree will be found for each group.</p>
</td></tr>
<tr><td><code id="medTree_+3A_lambda">lambda</code></td>
<td>
<p>a number in [0,1] which specifies the extent to which topology (default, with lambda=0)  or branch lengths (lambda=1) are emphasised. This argument is ignored if <code>return.lambda.function=TRUE</code> or if the vectors are already supplied as the object <code>x</code>.</p>
</td></tr>
<tr><td><code id="medTree_+3A_weights">weights</code></td>
<td>
<p>A vector of weights for the trees. Defaults to a vector of 1's so that all trees are equally weighted, but can be used to encode likelihood, posterior probabilities or other characteristics.</p>
</td></tr>
<tr><td><code id="medTree_+3A_emphasise.tips">emphasise.tips</code></td>
<td>
<p>an optional list of tips whose entries in the tree vectors should be emphasised. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="medTree_+3A_emphasise.weight">emphasise.weight</code></td>
<td>
<p>applicable only if a list is supplied to <code>emphasise.tips</code>, this value (default 2) is the number by which vector entries corresponding to those tips are emphasised.</p>
</td></tr>
<tr><td><code id="medTree_+3A_return.lambda.function">return.lambda.function</code></td>
<td>
<p>If true, a function that can be invoked with different lambda values is returned.
This function returns the vector of metric values for the given lambda. Ignored if the tree vectors are already supplied as the object <code>x</code>.</p>
</td></tr>
<tr><td><code id="medTree_+3A_save.memory">save.memory</code></td>
<td>
<p>A flag that saves a lot of memory but increases the execution time (not compatible with return.lambda.function=TRUE). Ignored if the tree vectors are already supplied as the object <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of five objects: 
</p>

<ul>
<li><p> $centre is the &quot;central vector&quot;, that is, the (weighted) mean of the tree vectors (which typically does not correspond to a tree itself); 
</p>
</li>
<li><p> $distances gives the distance of each tree from the central vector; 
</p>
</li>
<li><p> $mindist is the minimum of these distances; 
</p>
</li>
<li><p> $treenumbers gives the numbers (and, if supplied, names) of the &quot;median tree(s)&quot;, that is, the tree(s) which achieve this minimum distance to the centre; 
</p>
</li>
<li><p> $trees if trees were supplied then this returns the median trees as a multiPhylo object. 
</p>
</li></ul>

<p>If groups are provided, then one list is returned for each group.
If <code>return.lambda.function=TRUE</code> then a function is returned that produces this list for a given value of lambda.
</p>


<h3>Author(s)</h3>

<p>Jacob Almagro-Garcia <a href="mailto:nativecoder@gmail.com">nativecoder@gmail.com</a>
</p>
<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>
<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## EXAMPLE WITH WOODMICE DATA
data(woodmiceTrees)

## LOOKING FOR A SINGLE MEDIAN
## get median tree(s)
res &lt;- medTree(woodmiceTrees)
res

## plot first tree
med.tree &lt;- res$trees[[1]]
plot(med.tree)

## LOOKING FOR MEDIANS IN SEVERAL CLUSTERS
## identify 6 clusters
groves &lt;- findGroves(woodmiceTrees, nf=3, nclust=6)

## find median trees
res.with.grp &lt;- medTree(woodmiceTrees, groves$groups)

## there is one output per cluster
names(res.with.grp)

## get the first median of each
med.trees &lt;- lapply(res.with.grp, function(e) ladderize(e$trees[[1]]))

## plot trees
par(mfrow=c(2,3))
for(i in 1:length(med.trees)) plot(med.trees[[i]], main=paste("cluster",i))

## highlight the differences between a pair of median trees
plotTreeDiff(med.trees[[1]],med.trees[[5]])

</code></pre>

<hr>
<h2 id='multiDist'>Metric function for <code>multiPhylo</code> input</h2><span id='topic+multiDist'></span>

<h3>Description</h3>

<p>Comparison of a list of trees using the Kendall Colijn metric. Output is given as a pairwise distance matrix. This is equivalent to the <code>$D</code> output from <code>treespace</code> but may be preferable for large datasets, and when principal co-ordinate analysis is not required. It includes an option to save memory at the expense of computation time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiDist(
  trees,
  lambda = 0,
  return.lambda.function = FALSE,
  save.memory = FALSE,
  emphasise.tips = NULL,
  emphasise.weight = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiDist_+3A_trees">trees</code></td>
<td>
<p>an object of the class <code>multiPhylo</code> containing the trees to be compared</p>
</td></tr>
<tr><td><code id="multiDist_+3A_lambda">lambda</code></td>
<td>
<p>a number in [0,1] which specifies the extent to which topology (default, with lambda=0)  or branch lengths (lambda=1) are emphasised. This argument is ignored if <code>return.lambda.function=TRUE</code>.</p>
</td></tr>
<tr><td><code id="multiDist_+3A_return.lambda.function">return.lambda.function</code></td>
<td>
<p>If true, a function that can be invoked with different lambda values is returned.
This function returns the matrix of metric values for the given lambda.</p>
</td></tr>
<tr><td><code id="multiDist_+3A_save.memory">save.memory</code></td>
<td>
<p>A flag that saves a lot of memory but increases the execution time (not compatible with return.lambda.function=TRUE).</p>
</td></tr>
<tr><td><code id="multiDist_+3A_emphasise.tips">emphasise.tips</code></td>
<td>
<p>an optional list of tips whose entries in the tree vectors should be emphasised. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="multiDist_+3A_emphasise.weight">emphasise.weight</code></td>
<td>
<p>applicable only if a list is supplied to <code>emphasise.tips</code>, this value (default 2) is the number by which vector entries corresponding to those tips are emphasised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pairwise tree distance matrix or a function that produces the distance matrix given a value for lambda.
</p>


<h3>Author(s)</h3>

<p>Jacob Almagro-Garcia <a href="mailto:nativecoder@gmail.com">nativecoder@gmail.com</a>
</p>
<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate 10 random trees, each with 6 tips
trees &lt;- rmtree(10,6)

## pairwise distance matrix when lambda=0
multiDist(trees)

## pairwise distance matrix as a function of lambda:
m &lt;- multiDist(trees, return.lambda.function=TRUE)

## evaluate at lambda=0. Equivalent to multiDist(trees).
m0 &lt;- m(0)

## save memory by recomputing each tree vector for each pairwise tree comparison (for fixed lambda):
m0.5 &lt;- multiDist(trees,0.5,save.memory=TRUE)


</code></pre>

<hr>
<h2 id='plotGroves'>Scatterplot of groups of trees</h2><span id='topic+plotGroves'></span>

<h3>Description</h3>

<p>This function displays the scatterplot of the Multidimensional
Scaling (MDS) output by treespace, superimposing group information
(derived by <code><a href="#topic+findGroves">findGroves</a></code>) using colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGroves(
  x,
  groups = NULL,
  xax = 1,
  yax = 2,
  type = c("chull", "ellipse"),
  col.pal = funky,
  bg = "white",
  lab.show = FALSE,
  lab.col = "black",
  lab.cex = 1,
  lab.optim = TRUE,
  point.cex = 1,
  scree.pal = NULL,
  scree.size = 0.2,
  scree.posi = c(0.02, 0.02),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGroves_+3A_x">x</code></td>
<td>
<p>a list returned by <code><a href="#topic+findGroves">findGroves</a></code> or a MDS with class <code>dudi</code></p>
</td></tr>
<tr><td><code id="plotGroves_+3A_groups">groups</code></td>
<td>
<p>a factor defining groups of trees</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_xax">xax</code></td>
<td>
<p>a number indicating which principal component to be used as 'x' axis</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_yax">yax</code></td>
<td>
<p>a number indicating which principal component to be used as 'y' axis</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_type">type</code></td>
<td>
<p>a character string indicating which type of graph to use</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_col.pal">col.pal</code></td>
<td>
<p>a color palette to be used for the groups</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_bg">bg</code></td>
<td>
<p>the background color</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_lab.show">lab.show</code></td>
<td>
<p>a logical indicating whether labels should be displayed</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_lab.col">lab.col</code></td>
<td>
<p>a color for the labels</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_lab.cex">lab.cex</code></td>
<td>
<p>the size of the labels</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_lab.optim">lab.optim</code></td>
<td>
<p>a logical indicating whether label positions should be optimized to avoid overlap; better display but time-consuming for large datasets</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_point.cex">point.cex</code></td>
<td>
<p>the size of the points</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_scree.pal">scree.pal</code></td>
<td>
<p>a color palette for the screeplot</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_scree.size">scree.size</code></td>
<td>
<p>a size factor for the screeplot, between 0 and 1</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_scree.posi">scree.posi</code></td>
<td>
<p>either a character string or xy coordinates indicating the position of the screeplot.</p>
</td></tr>
<tr><td><code id="plotGroves_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>s.class</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies on <code><a href="adegraphics.html#topic+s.class">s.class</a></code>
from the <code>adegraphics</code> package.
</p>


<h3>Value</h3>

<p>An <code>adegraphics</code> object (class: <code>ADEgS</code>)
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findGroves">findGroves</a></code> to find any clusters in the tree landscape
<code><a href="adegraphics.html#topic+s.class">s.class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
if(require("adegenet") &amp;&amp; require("adegraphics")){
## load data
data(woodmiceTrees)

## run findGroves: treespace+clustering
res &lt;- findGroves(woodmiceTrees, nf=5, nclust=6)

## basic plot
plotGroves(res)

## adding labels
plotGroves(res, lab.show=TRUE)

## customizing
plotGroves(res, lab.show=TRUE,
bg="black", lab.col="white", scree.size=.35)

## customizing
plotGroves(res, type="ellipse", lab.show=TRUE,
lab.optim=FALSE, scree.size=.35)

## example with no group information
plotGroves(res$treespace$pco)

## adding labels
plotGroves(res$treespace$pco, lab.show=TRUE, lab.cex=2)

}

## End(Not run)

</code></pre>

<hr>
<h2 id='plotGrovesD3'>Scatterplot of groups of trees using <code>scatterD3</code></h2><span id='topic+plotGrovesD3'></span>

<h3>Description</h3>

<p>This function displays the scatterplot of the Multidimensional
Scaling (MDS) output by treespace, superimposing group information
(derived by <code><a href="#topic+findGroves">findGroves</a></code>) using colors.
<code>scatterD3</code> enables interactive plotting based on d3.js, including zooming, panning and fading effects in the legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGrovesD3(
  x,
  groups = NULL,
  xax = 1,
  yax = 2,
  treeNames = NULL,
  symbol_var = NULL,
  xlab = paste0("Axis ", xax),
  ylab = paste0("Axis ", yax),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGrovesD3_+3A_x">x</code></td>
<td>
<p>a list returned by <code><a href="#topic+findGroves">findGroves</a></code> or a MDS with class <code>dudi</code></p>
</td></tr>
<tr><td><code id="plotGrovesD3_+3A_groups">groups</code></td>
<td>
<p>a factor defining groups of trees. If x is a list returned by <code><a href="#topic+findGroves">findGroves</a></code> these will be detected automatically.</p>
</td></tr>
<tr><td><code id="plotGrovesD3_+3A_xax">xax</code></td>
<td>
<p>a number indicating which principal component to be used as 'x' axis</p>
</td></tr>
<tr><td><code id="plotGrovesD3_+3A_yax">yax</code></td>
<td>
<p>a number indicating which principal component to be used as 'y' axis</p>
</td></tr>
<tr><td><code id="plotGrovesD3_+3A_treenames">treeNames</code></td>
<td>
<p>if a list of tree names or labels are given, these will be plotted alongside the points. Their size can be altered using <code>labels_size</code> - see <code>?scatterD3</code> for more information.</p>
</td></tr>
<tr><td><code id="plotGrovesD3_+3A_symbol_var">symbol_var</code></td>
<td>
<p>a factor by which to vary the symbols in the plot</p>
</td></tr>
<tr><td><code id="plotGrovesD3_+3A_xlab">xlab</code></td>
<td>
<p>the label for the 'x' axis. Defaults to use the value of 'xax'</p>
</td></tr>
<tr><td><code id="plotGrovesD3_+3A_ylab">ylab</code></td>
<td>
<p>the label for the 'y' axis. Defaults to use the value of 'yax'</p>
</td></tr>
<tr><td><code id="plotGrovesD3_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>scatterD3</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scatterD3</code> plot
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findGroves">findGroves</a></code> to find any clusters in the tree landscape
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
if(require("adegenet") &amp;&amp; require("scatterD3")){
## load data
data(woodmiceTrees)

## run findGroves: treespace+clustering
res &lt;- findGroves(woodmiceTrees, nf=5, nclust=6)

## basic plot
plotGrovesD3(res)

## adding tree labels
plotGrovesD3(res, treeNames=1:201)

## customizing: vary the colour and the symbol by group
plotGrovesD3(res, symbol_var=res$groups)

## example with no group information
plotGrovesD3(res$treespace$pco)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='plotTreeDiff'>Plot tree differences</h2><span id='topic+plotTreeDiff'></span>

<h3>Description</h3>

<p>Highlight the topological differences between two trees, plotted side by side. 
This function is useful for comparing representative &quot;median&quot; trees - see <code><a href="#topic+medTree">medTree</a></code>.
It relies on the function <code><a href="#topic+tipDiff">tipDiff</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTreeDiff(
  tr1,
  tr2,
  tipDiff = NULL,
  vec1 = NULL,
  vec2 = NULL,
  sizeOfDifferences = FALSE,
  tipMatch = TRUE,
  treesFacing = FALSE,
  baseCol = "grey",
  col1 = "peachpuff",
  col2 = "red2",
  colourMethod = "ramp",
  palette = lightseasun,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTreeDiff_+3A_tr1">tr1</code></td>
<td>
<p>an object of the class <code>phylo</code>: the first tree to plot.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_tr2">tr2</code></td>
<td>
<p>an object of the class <code>phylo</code>: the second tree to plot.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_tipdiff">tipDiff</code></td>
<td>
<p>an optional input, the result of <code><a href="#topic+tipDiff">tipDiff</a></code>. Supplying this will save time if calling <code>plotTreeDiff</code> repeatedly, for example with different aesthetics.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_vec1">vec1</code></td>
<td>
<p>an optional input, the result of <code>treeVec(tr1, lambda=0)</code>. This argument is ignored if <code>tipDiff</code> is supplied; otherwise supplying this will save time if calling <code>plotTreeDiff</code> repeatedly, for example with different aesthetics.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_vec2">vec2</code></td>
<td>
<p>an optional input, the result of <code>treeVec(tr2, lambda=0)</code>. This argument is ignored if <code>tipDiff</code> is supplied; otherwise supplying this will save time if calling <code>plotTreeDiff</code> repeatedly, for example with different aesthetics.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_sizeofdifferences">sizeOfDifferences</code></td>
<td>
<p>a logical (default FALSE) specifying whether the size of the tip differences should be used, or just a count of the number of differences (see <code>tipDiff</code>)</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_tipmatch">tipMatch</code></td>
<td>
<p>a logical (default TRUE) specifying whether the second tree should be rotated so that, as far as possible, each of its tips lies opposite its equivalent in the first tree</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_treesfacing">treesFacing</code></td>
<td>
<p>a logical (default FALSE) specifying whether the trees should be plotted facing each other - that is, with the second tree plotted &quot;leftwards&quot;.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_basecol">baseCol</code></td>
<td>
<p>the colour used for tips with identical ancestry in the two trees. Defaults to &quot;grey&quot;.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_col1">col1</code></td>
<td>
<p>the first colour used to define the colour spectrum for tips with differences. This colour will be used for tips with minor differences. Defaults to &quot;peachpuff&quot;. Ignored if <code>colourMethod="palette"</code>.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_col2">col2</code></td>
<td>
<p>the second colour used to define the colour spectrum for tips with differences. This colour will be used for tips with major differences. Defaults to &quot;red2&quot;. Ignored if <code>colourMethod="palette"</code>.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_colourmethod">colourMethod</code></td>
<td>
<p>the method to use for colouring. Default is &quot;ramp&quot;, corresponding to the original implementation, where the function <code>colorRampPalette</code> is used to create a palette which ranges from <code>col1</code> to <code>col2</code>. For large trees this can be hard to interpret, and method <code>palette</code> may be preferred, which permits the selection of a palette to use in <code>adegenet</code>'s function <code>num2col</code>.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_palette">palette</code></td>
<td>
<p>the colour palette to be used if <code>colourMethod="palette"</code>. For a list of available palettes see <code>?num2col</code>.</p>
</td></tr>
<tr><td><code id="plotTreeDiff_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the two trees side by side. Tips are coloured in the following way:
</p>

<ul>
<li><p> if each ancestor of a tip in tree 1 occurs in tree 2 with the same partition of tip descendants, then the tip is coloured grey (or supplied &quot;baseCol&quot;)
</p>
</li>
<li><p> if not, the tip gets coloured pale orange to red on a scale according to how many differences there are amongst its most recent common ancestors with other tips. The colour spectrum can be changed according to preference.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+medTree">medTree</a></code>, <code><a href="#topic+tipDiff">tipDiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple example on trees with five tips:
tr1 &lt;- read.tree(text="((A:1,B:1):1,((C:1,D:1):1,E:1):1):1;")
tr2 &lt;- read.tree(text="((A:1,B:1):1,(C:1,(D:1,E:1):1):1):1;")
plotTreeDiff(tr1,tr2)

## example on larger woodmice trees
data(woodmiceTrees)
tr1 &lt;- woodmiceTrees[[1]]
tr2 &lt;- woodmiceTrees[[57]] # for example

# find the tip differences in advance, to avoid recalculating with each plot
wmTipDiff &lt;- tipDiff(tr1,tr2, sizeOfDifferences=TRUE)
plotTreeDiff(tr1,tr2, tipDiff=wmTipDiff, tipMatch=TRUE)

## change aesthetics:
# trees facing each other:
plotTreeDiff(tr1,tr2, tipDiff=wmTipDiff, treesFacing=TRUE)

# radial plots, and change colours:
plotTreeDiff(tr1,tr2, tipDiff=wmTipDiff,
   baseCol="grey2", col1="cyan", col2="navy", 
   edge.width=2, type="radial", cex=0.5, font=2)
# cladogram plots, and use colour palette from adegenet to see differences more clearly:
plotTreeDiff(tr1,tr2, tipDiff=wmTipDiff,
   treesFacing=TRUE, baseCol="black", colourMethod="palette", 
   edge.width=2, type="cladogram", cex=0.5, font=2)    

# including the size of the differences highlights tip "No0906s" a little more:
# (this is typically a more informative plot in cases where many tips have the 
# same difference count, for example when a whole clade has been shifted "up" 
# or "down" the tree but its internal topology remains the same.) 
 
plotTreeDiff(tr1,tr2, tipDiff=wmTipDiff, sizeOfDifferences=TRUE,
   treesFacing=TRUE, baseCol="black", colourMethod="palette", 
   edge.width=2, type="cladogram", cex=0.5, font=2)  

</code></pre>

<hr>
<h2 id='refTreeDist'>Metric function for comparing a reference <code>phylo</code> to <code>multiPhylo</code> input</h2><span id='topic+refTreeDist'></span>

<h3>Description</h3>

<p>Comparison of a single reference tree to a list of trees using the Kendall Colijn metric. Output is given as a vector of distances from the reference tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refTreeDist(
  refTree,
  trees,
  lambda = 0,
  return.lambda.function = FALSE,
  emphasise.tips = NULL,
  emphasise.weight = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refTreeDist_+3A_reftree">refTree</code></td>
<td>
<p>a tree of class <code>phylo</code>, the &quot;reference tree&quot;.</p>
</td></tr>
<tr><td><code id="refTreeDist_+3A_trees">trees</code></td>
<td>
<p>an object of the class <code>multiPhylo</code> containing the trees to be compared to the reference tree</p>
</td></tr>
<tr><td><code id="refTreeDist_+3A_lambda">lambda</code></td>
<td>
<p>a number in [0,1] which specifies the extent to which topology (default, with lambda=0)  or branch lengths (lambda=1) are emphasised. This argument is ignored if <code>return.lambda.function=TRUE</code>.</p>
</td></tr>
<tr><td><code id="refTreeDist_+3A_return.lambda.function">return.lambda.function</code></td>
<td>
<p>If true, a function that can be invoked with different lambda values is returned.
This function returns the vector of metric values for the given lambda.</p>
</td></tr>
<tr><td><code id="refTreeDist_+3A_emphasise.tips">emphasise.tips</code></td>
<td>
<p>an optional list of tips whose entries in the tree vectors should be emphasised. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="refTreeDist_+3A_emphasise.weight">emphasise.weight</code></td>
<td>
<p>applicable only if a list is supplied to <code>emphasise.tips</code>, this value (default 2) is the number by which vector entries corresponding to those tips are emphasised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of distances, where entry i corresponds to the distance between the i'th tree and the reference tree, or a function that produces the vector of distances given a value for lambda.
</p>


<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a single reference tree with 6 tips
refTree &lt;- rtree(6)

## generate 10 random trees, each with 6 tips
trees &lt;- rmtree(10,6)

## find the distances from each of the 10 random trees to the single reference tree
refTreeDist(refTree,trees)

</code></pre>

<hr>
<h2 id='relatedTreeDist'>Tree distance when trees have &quot;related&quot; tips</h2><span id='topic+relatedTreeDist'></span>

<h3>Description</h3>

<p>This function calculates the distances between trees whose tips belong to the same categories but are not necessarily identically labelled
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedTreeDist(trees, df, checkTrees = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relatedTreeDist_+3A_trees">trees</code></td>
<td>
<p>a list of trees or multiphylo object</p>
</td></tr>
<tr><td><code id="relatedTreeDist_+3A_df">df</code></td>
<td>
<p>a data frame specifying to which category each individual (from all the trees) belongs. Each row gives: an individual (column 2) and its corresponding category (column 1)</p>
</td></tr>
<tr><td><code id="relatedTreeDist_+3A_checktrees">checkTrees</code></td>
<td>
<p>a logical (default TRUE) specifying whether the trees should be checked. When TRUE, error messages will be helpful in locating problematic trees, that is, any trees with repeated tip labels, or any trees with missing categories.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># we will simulate some trees as an example, each "based" on the same tree:
baseTree &lt;- rtree(5)
baseTree$tip.label &lt;- letters[5:1]
plot(baseTree)

tree1 &lt;- simulateIndTree(baseTree, itips=3, permuteTips=FALSE)
tree2 &lt;- simulateIndTree(baseTree, itips=4, permuteTips=FALSE)
tree3 &lt;- simulateIndTree(baseTree, itips=4, permuteTips=TRUE, tipPercent=20)
tree4 &lt;- simulateIndTree(baseTree, itips=4, permuteTips=TRUE, tipPercent=60)
tree5 &lt;- simulateIndTree(baseTree, itips=4, permuteTips=TRUE, tipPercent=100)
# combine:
trees &lt;- list(tree1,tree2,tree3,tree4,tree5)

df &lt;- cbind(sort(rep(letters[1:5],4)),sort(paste0(letters[1:5],"_",rep(1:4,5))))
head(df)

# Find distances:
relatedTreeDist(trees,df)

# Note that trees 1 and 2 have different numbers of tips but the relationships between those tips
# are identical at the category level, hence the related tree distance is 0.
# We can see that the distances between trees increase the more the trees are permuted.


</code></pre>

<hr>
<h2 id='simulateIndTree'>Simulate randomised &quot;individuals&quot; tree</h2><span id='topic+simulateIndTree'></span>

<h3>Description</h3>

<p>This function takes in a &quot;category&quot; tree and outputs a simulated corresponding &quot;individuals&quot; tree, for testing the concordance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateIndTree(
  catTree,
  itips = 5,
  permuteCat = FALSE,
  permuteTips = TRUE,
  tipPercent = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateIndTree_+3A_cattree">catTree</code></td>
<td>
<p>object of class phylo, the category-level tree</p>
</td></tr>
<tr><td><code id="simulateIndTree_+3A_itips">itips</code></td>
<td>
<p>number of individual tips to assign per category</p>
</td></tr>
<tr><td><code id="simulateIndTree_+3A_permutecat">permuteCat</code></td>
<td>
<p>logical specifying whether to permute the category labels on the category tree before grafting on individual tips. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="simulateIndTree_+3A_permutetips">permuteTips</code></td>
<td>
<p>logical specifying whether to permute the individual tip labels after building the individual level tree based on the category tree. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="simulateIndTree_+3A_tippercent">tipPercent</code></td>
<td>
<p>number specifying the percentage of tips to be permuted. Defaults to 100, ignored if permuteTips=FALSE.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+treeConcordance">treeConcordance</a></code> <code><a href="#topic+makeCollapsedTree">makeCollapsedTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- simulateIndTree(rtree(3))
plot(tree)

</code></pre>

<hr>
<h2 id='tipDiff'>Find tip position differences</h2><span id='topic+tipDiff'></span>

<h3>Description</h3>

<p>Find the topologicial differences between two trees with the same tip labels. The function returns a data frame of the tips and the number of differences in their ancestry between the two trees.
Called by <code><a href="#topic+plotTreeDiff">plotTreeDiff</a></code>, which highlights the differing tips in a plot of the two trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tipDiff(tr1, tr2, vec1 = NULL, vec2 = NULL, sizeOfDifferences = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tipDiff_+3A_tr1">tr1</code></td>
<td>
<p>an object of the class <code>phylo</code>: the first tree to compare.</p>
</td></tr>
<tr><td><code id="tipDiff_+3A_tr2">tr2</code></td>
<td>
<p>an object of the class <code>phylo</code>: the second tree to compare.</p>
</td></tr>
<tr><td><code id="tipDiff_+3A_vec1">vec1</code></td>
<td>
<p>an optional input, the result of <code>treeVec(tr1, lambda=0)</code>, to speed up the computation.</p>
</td></tr>
<tr><td><code id="tipDiff_+3A_vec2">vec2</code></td>
<td>
<p>an optional input, the result of <code>treeVec(tr2, lambda=0)</code>, to speed up the computation.</p>
</td></tr>
<tr><td><code id="tipDiff_+3A_sizeofdifferences">sizeOfDifferences</code></td>
<td>
<p>a logical (default FALSE) specifying whether the size of the differences in the vectors per tip is also computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of the tree tips and the number of ancestral differences between them in the two trees, in order of increasing difference.
A tip is said to have zero difference if each of its ancestral nodes admits the same tip partition in the two trees.
</p>


<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+medTree">medTree</a></code> <code><a href="#topic+plotTreeDiff">plotTreeDiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple example on trees with five tips:
tr1 &lt;- read.tree(text="((A:1,B:1):1,((C:1,D:1):1,E:1):1):1;")
tr2 &lt;- read.tree(text="((A:1,B:1):1,(C:1,(D:1,E:1):1):1):1;")
tipDiff(tr1,tr2)

## example on larger woodmice trees
data(woodmiceTrees)
tipDiff(woodmiceTrees[[1]],woodmiceTrees[[2]])

</code></pre>

<hr>
<h2 id='tipsMRCAdepths'>Tip-tip MRCA depths</h2><span id='topic+tipsMRCAdepths'></span>

<h3>Description</h3>

<p>This function creates a matrix where columns 1 and 2 correspond to tip labels and column 3 gives the depth of the MRCA of that pair of tips.
It is strongly based on <code>treeVec</code> and is used by <code>relatedTreeDist</code> and <code>treeConcordance</code> where tip labels belong to &quot;categories&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tipsMRCAdepths(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tipsMRCAdepths_+3A_tree">tree</code></td>
<td>
<p>An object of class phylo</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- rtree(10)
plot(tree)
tipsMRCAdepths(tree)

</code></pre>

<hr>
<h2 id='treeConcordance'>Tree concordance</h2><span id='topic+treeConcordance'></span>

<h3>Description</h3>

<p>This function calculates the concordance between a category tree and an individuals tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeConcordance(catTree, indTree, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeConcordance_+3A_cattree">catTree</code></td>
<td>
<p>object of class phylo</p>
</td></tr>
<tr><td><code id="treeConcordance_+3A_indtree">indTree</code></td>
<td>
<p>object of class phylo</p>
</td></tr>
<tr><td><code id="treeConcordance_+3A_df">df</code></td>
<td>
<p>data frame specifying to which category each individual belongs. Each row gives an individual (column 2) and its corresponding category (column 1)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simulateIndTree">simulateIndTree</a></code> <code><a href="#topic+makeCollapsedTree">makeCollapsedTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an example category tree
catTree &lt;- read.tree(text="(C:1,(B:1,A:1):1);")
plot(catTree)

# make individuals tree with complete concordance:
indTree1 &lt;- read.tree(text="(((c4,c3),(c2,c1)),((b1,b2),((a3,a2),a1)));")
plot(indTree1)

# create data frame linking categories with individuals
df &lt;- cbind(c(rep("A",3),rep("B",2),rep("C",4)),sort(indTree1$tip.label))

treeConcordance(catTree,indTree1,df)

# make a less concordant tree:
indTree2 &lt;- read.tree(text="((((c4,c3),(c2,c1)),b2),(b1,((a3,a2),a1)));")
plot(indTree2)
treeConcordance(catTree,indTree2,df)

# simulate larger example:
catTree &lt;- rtree(10)
indTree3 &lt;- simulateIndTree(catTree, tipPercent=10)
df &lt;- cbind(sort(rep(catTree$tip.label,5)),sort(indTree3$tip.label))
plot(indTree3)
treeConcordance(catTree,indTree3,df)

</code></pre>

<hr>
<h2 id='treeDist'>Metric function</h2><span id='topic+treeDist'></span>

<h3>Description</h3>

<p>Comparison of two trees using the Kendall Colijn metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeDist(
  tree.a,
  tree.b,
  lambda = 0,
  return.lambda.function = FALSE,
  emphasise.tips = NULL,
  emphasise.weight = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeDist_+3A_tree.a">tree.a</code></td>
<td>
<p>an object of the class <code>phylo</code></p>
</td></tr>
<tr><td><code id="treeDist_+3A_tree.b">tree.b</code></td>
<td>
<p>an object of the class <code>phylo</code> (with the same tip labels as tree.a)</p>
</td></tr>
<tr><td><code id="treeDist_+3A_lambda">lambda</code></td>
<td>
<p>a number in [0,1] which specifies the extent to which topology (default, with lambda=0)  or branch lengths (lambda=1) are emphasised. This argument is ignored if <code>return.lambda.function=TRUE</code>.</p>
</td></tr>
<tr><td><code id="treeDist_+3A_return.lambda.function">return.lambda.function</code></td>
<td>
<p>If true, a function that can be invoked with different lambda values is returned.
This function returns the vector of metric values for the given lambda.</p>
</td></tr>
<tr><td><code id="treeDist_+3A_emphasise.tips">emphasise.tips</code></td>
<td>
<p>an optional list of tips whose entries in the tree vectors should be emphasised. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="treeDist_+3A_emphasise.weight">emphasise.weight</code></td>
<td>
<p>applicable only if a list is supplied to <code>emphasise.tips</code>, this value (default 2) is the number by which vector entries corresponding to those tips are emphasised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between the two trees according to the metric for the given value of lambda, or a function that produces the distance given a value of lambda.
</p>


<h3>Author(s)</h3>

<p>Jacob Almagro-Garcia <a href="mailto:nativecoder@gmail.com">nativecoder@gmail.com</a>
</p>
<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate random trees
tree.a &lt;- rtree(6)
tree.b &lt;- rtree(6)
treeDist(tree.a,tree.b) # lambda=0
treeDist(tree.a,tree.b,1)  # lambda=1
dist.func &lt;- treeDist(tree.a,tree.b,return.lambda.function=TRUE) # distance as a function of lambda
dist.func(0) # evaluate at lambda=0. Equivalent to treeDist(tree.a,tree.b).
## We can see how the distance changes when moving from focusing on topology to length:
plot(sapply(seq(0,1,length.out=100), function(x) dist.func(x)), type="l",ylab="",xlab="")

## The distance may also change if we emphasise the position of certain tips:
plot(sapply(tree.a$tip.label, function(x) treeDist(tree.a,tree.b,emphasise.tips=x)),
     xlab="Tip number",ylab="Distance when  vector entries corresponding to tip are doubled")


</code></pre>

<hr>
<h2 id='treespace'>Phylogenetic tree exploration</h2><span id='topic+treespace'></span>

<h3>Description</h3>

<p>Compares phylogenetic trees using a choice of metrics / measures, and maps their pairwise distances into a small number of dimensions for easy visualisation and identification of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treespace(
  x,
  method = "treeVec",
  nf = NULL,
  lambda = 0,
  return.tree.vectors = FALSE,
  processors = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treespace_+3A_x">x</code></td>
<td>
<p>an object of the class multiPhylo</p>
</td></tr>
<tr><td><code id="treespace_+3A_method">method</code></td>
<td>
<p>the method for summarising the tree as a vector.
Choose from:
</p>

<ul>
<li> <p><code>treeVec</code> (default) the Kendall Colijn metric vector (for rooted trees)
</p>
</li>
<li> <p><code>BHV</code> the Billera, Holmes Vogtmann metric using <code>dist.multiPhylo</code> from package <code>distory</code> (for rooted trees)
</p>
</li>
<li> <p><code>KF</code> the Kuhner Felsenstein metric (branch score distance) using <code>KF.dist</code> from package <code>phangorn</code> (considers the trees unrooted)
</p>
</li>
<li> <p><code>RF</code> the Robinson Foulds metric using <code>RF.dist</code> from package <code>phangorn</code> (considers the trees unrooted)
</p>
</li>
<li> <p><code>wRF</code> the weighted Robinson Foulds metric using <code>wRF.dist</code> from package <code>phangorn</code> (considers the trees unrooted)
</p>
</li>
<li> <p><code>nNodes</code> the Steel &amp; Penny tip-tip path difference metric, (topological, ignoring branch lengths), using <code>path.dist</code> from package <code>phangorn</code> (considers the trees unrooted)
</p>
</li>
<li> <p><code>patristic</code> the Steel &amp; Penny tip-tip path difference metric, using branch lengths, calling <code>path.dist</code> from package <code>phangorn</code> (considers the trees unrooted)
</p>
</li>
<li> <p><code>Abouheif</code>: performs Abouheif's test, inherited from <code>distTips</code> in <code>adephylo</code>. See Pavoine et al. (2008) and <code>adephylo</code>.
</p>
</li>
<li> <p><code>sumDD</code>: sum of direct descendants of all nodes on the path, related to Abouheif's test, inherited from <code>distTips</code> in <code>adephylo</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="treespace_+3A_nf">nf</code></td>
<td>
<p>the number of principal components to retain</p>
</td></tr>
<tr><td><code id="treespace_+3A_lambda">lambda</code></td>
<td>
<p>a number in [0,1] which specifies the extent to which topology (default, with lambda=0)  or branch lengths (lambda=1) are emphasised in the Kendall Colijn metric.</p>
</td></tr>
<tr><td><code id="treespace_+3A_return.tree.vectors">return.tree.vectors</code></td>
<td>
<p>if using the Kendall Colijn metric, this option will return the tree vectors as part of the output. Note that this can use a lot of memory so defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="treespace_+3A_processors">processors</code></td>
<td>
<p>value (default 1) to be passed to mcmapply specifying the number of cores to use. Must be 1 on Windows (see <code>mcmapply</code> for more details).</p>
</td></tr>
<tr><td><code id="treespace_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>method</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>
<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate list of trees
x &lt;- rmtree(10, 20)
names(x) &lt;- paste("tree", 1:10, sep = "")

## use treespace
res &lt;- treespace(x, nf=3)
table.paint(as.matrix(res$D))
scatter(res$pco)

data(woodmiceTrees)
woodmiceDists &lt;- treespace(woodmiceTrees,nf=3)
plot(woodmiceDists$pco$li[,1],woodmiceDists$pco$li[,2])
woodmicedf &lt;- woodmiceDists$pco$li
if(require(ggplot2)){
woodmiceplot &lt;- ggplot(woodmicedf, aes(x=A1, y=A2)) # create plot
woodmiceplot + geom_density2d(colour="gray80") + # contour lines
geom_point(size=6, shape=1, colour="gray50") + # grey edges
geom_point(size=6, alpha=0.2, colour="navy") + # transparent blue points
xlab("") + ylab("") + theme_bw(base_family="") # remove axis labels and grey background
}

## Not run: 
if(require(rgl)){
plot3d(woodmicedf[,1], woodmicedf[,2], woodmicedf[,3], type="s", size=1.5,
col="navy", alpha=0.5, xlab="", ylab="", zlab="")
}

## End(Not run)


</code></pre>

<hr>
<h2 id='treespaceServer'>Web-based tree explorer</h2><span id='topic+treespaceServer'></span>

<h3>Description</h3>

<p>This function opens up an application in a web browser for an interactive exploration of the diversity in a set of trees.
For further details please see the &quot;help&quot; tab within the application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treespaceServer()
</code></pre>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>
<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>See Also</h3>

<p>For convenience, <code>treespaceServer</code> is also available as a separate web app which can be used from any browser (it is not necessary to have <span class="rlang"><b>R</b></span> installed): <a href="https://mkendall.shinyapps.io/treespace/">https://mkendall.shinyapps.io/treespace/</a>
</p>

<hr>
<h2 id='treeVec'>Tree vector function</h2><span id='topic+treeVec'></span>

<h3>Description</h3>

<p>Function which takes an object of class phylo and outputs the vector for the Kendall Colijn metric.
The elements of the vector are numeric if <code>return.lambda.function=FALSE</code> (default),
and otherwise they are functions of lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeVec(
  tree,
  lambda = 0,
  return.lambda.function = FALSE,
  emphasise.tips = NULL,
  emphasise.weight = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeVec_+3A_tree">tree</code></td>
<td>
<p>an object of the class <code>phylo</code></p>
</td></tr>
<tr><td><code id="treeVec_+3A_lambda">lambda</code></td>
<td>
<p>a number in [0,1] which specifies the extent to which topology (default, with lambda=0)  or branch lengths (lambda=1) are emphasised. This argument is ignored if <code>return.lambda.function=TRUE</code>.</p>
</td></tr>
<tr><td><code id="treeVec_+3A_return.lambda.function">return.lambda.function</code></td>
<td>
<p>If true, a function that can be invoked with different lambda values is returned. This function returns the vector of metric values for the given lambda.</p>
</td></tr>
<tr><td><code id="treeVec_+3A_emphasise.tips">emphasise.tips</code></td>
<td>
<p>an optional list of tips whose entries in the tree vector should be emphasised. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="treeVec_+3A_emphasise.weight">emphasise.weight</code></td>
<td>
<p>applicable only if a list is supplied to <code>emphasise.tips</code>, this value (default 2) is the number by which vector entries corresponding to those tips are emphasised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of values according to the metric, or a function that produces the vector given a value of lambda.
</p>


<h3>Author(s)</h3>

<p>Jacob Almagro-Garcia <a href="mailto:nativecoder@gmail.com">nativecoder@gmail.com</a>
</p>
<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a random tree
tree &lt;- rtree(6)
## topological vector of mrca distances from root:
treeVec(tree)
## vector of mrca distances from root when lambda=0.5:
treeVec(tree,0.5)
## vector of mrca distances as a function of lambda:
vecAsFunction &lt;- treeVec(tree,return.lambda.function=TRUE)
## evaluate the vector at lambda=0.5:
vecAsFunction(0.5)


</code></pre>

<hr>
<h2 id='wiwMedTree'>Median transmission tree</h2><span id='topic+wiwMedTree'></span>

<h3>Description</h3>

<p>Function to find the median of a list of transmission scenarios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wiwMedTree(matList, sampled = NULL, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wiwMedTree_+3A_matlist">matList</code></td>
<td>
<p>a list of matrices, each of which is the output of <code>findMRCIs$mrciDepths</code></p>
</td></tr>
<tr><td><code id="wiwMedTree_+3A_sampled">sampled</code></td>
<td>
<p>a vector of node IDs which corresponds to those nodes which are sampled cases</p>
</td></tr>
<tr><td><code id="wiwMedTree_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights to correspond to the entries of matList</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns three objects:
</p>

<ul>
<li> <p><code>centre</code>: the mean of the matList entries, restricted to the sampled cases
</p>
</li>
<li> <p><code>distances</code>: for each entry of matList, its distance from <code>centre</code>
</p>
</li>
<li> <p><code>mindist</code>: the minimum of <code>distances</code>
</p>
</li>
<li> <p><code>median</code>: the number of the median entry of matList, i.e. the one(s) which achieve the <code>mindist</code> from the <code>centre</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some simple "who infected whom" scenarios:
tree1 &lt;- cbind(Infector=1:5,Infectee=2:6) 
tree2 &lt;- cbind(Infector=c(1,5,2,2,3),Infectee=2:6)
tree3 &lt;- cbind(Infector=c(2,2,3,4,5),Infectee=c(1,3,4,5,6)) 
# create list of the MRCI depth matrices:
matList &lt;- lapply(list(tree1,tree2,tree3), function(x) findMRCIs(x)$mrciDepths)

# median tree, assuming all cases are sampled:
wiwMedTree(matList)
# median tree when cases 1, 2 and 4 are sampled:
wiwMedTree(matList, sampled=c(1,2,4))

</code></pre>

<hr>
<h2 id='wiwTreeDist'>Transmission tree distance</h2><span id='topic+wiwTreeDist'></span>

<h3>Description</h3>

<p>Function to find the distance between transmission trees by comparing their MRCI depth matrices; to be precise, by finding the Euclidean distance between the tree vectors, restricted to their sampled node entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wiwTreeDist(matList, sampled = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wiwTreeDist_+3A_matlist">matList</code></td>
<td>
<p>a list of matrices, each of which is the output of <code>findMRCIs$mrciDepths</code></p>
</td></tr>
<tr><td><code id="wiwTreeDist_+3A_sampled">sampled</code></td>
<td>
<p>a vector of node IDs which corresponds to those nodes which are sampled cases. Default is to treat all nodes as sampled cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a distance matrix, where entry (i,j) is the transmission tree distance between matrices i and j in <code>matList</code>
</p>


<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some simple "who infected whom" scenarios:
tree1 &lt;- cbind(Infector=1:5,Infectee=2:6) 
tree2 &lt;- cbind(Infector=c(1,5,2,2,3),Infectee=2:6)
tree3 &lt;- cbind(Infector=c(2,2,3,4,5),Infectee=c(1,3,4,5,6)) 
# create list of the MRCI depth matrices:
matList &lt;- lapply(list(tree1,tree2,tree3), function(x) findMRCIs(x)$mrciDepths)

# transmission tree distance, assuming all cases are sampled:
wiwTreeDist(matList)
# transmission tree distance when cases 1, 2 and 4 are sampled:
wiwTreeDist(matList, sampled=c(1,2,4))

</code></pre>

<hr>
<h2 id='woodmiceTrees'>Bootstrap trees from woodmouse dataset</h2><span id='topic+woodmiceTrees'></span>

<h3>Description</h3>

<p>These trees were created using the neighbour-joining and bootstrapping
example from the ape documentation.
</p>


<h3>Format</h3>

<p>A multiPhylo object containing 201 trees, each with 15 tips
</p>


<h3>Author(s)</h3>

<p>Michelle Kendall <a href="mailto:michelle.louise.kendall@gmail.com">michelle.louise.kendall@gmail.com</a>
</p>


<h3>Source</h3>

<p>A set of 15 sequences of the mitochondrial gene cytochrome b of the
woodmouse (Apodemus sylvaticus) which is a subset of the data analysed by
Michaux et al. (2003). The full data set is available through GenBank
(accession numbers AJ511877 to AJ511987)
</p>


<h3>References</h3>

<p>Michaux, J. R., Magnanou, E., Paradis, E., Nieberding, C. and
Libois, R. (2003) Mitochondrial phylogeography of the Woodmouse (Apodemus
sylvaticus) in the Western Palearctic region. <em>Molecular Ecology</em>, 12,
685-697
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
