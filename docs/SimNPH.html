<!DOCTYPE html><html lang="en"><head><title>Help for package SimNPH</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimNPH}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SimNPH'><p>SimNPH</p></a></li>
<li><a href='#analyse_aft'><p>Analyse Dataset with accelarated failure time models</p></a></li>
<li><a href='#analyse_ahr'><p>Analyse the dataset using extimators for the the average hazard ratio</p></a></li>
<li><a href='#analyse_coxph'><p>Analyse Dataset with the Cox Protportional Hazards Model</p></a></li>
<li><a href='#analyse_describe'><p>Create a Function for Descriptive Statistics of a Dataset</p></a></li>
<li><a href='#analyse_diff_median_survival'><p>Analyse the dataset using differnce in median survival</p></a></li>
<li><a href='#analyse_gehan_wilcoxon'><p>Create Analyse function for Gehan Wilcoxon test</p></a></li>
<li><a href='#analyse_group_sequential'><p>Create Analyse Functions for Group Sequential Design</p></a></li>
<li><a href='#analyse_logrank'><p>Analyse Dataset with the Logrank Test</p></a></li>
<li><a href='#analyse_logrank_fh_weights'><p>Analyse Dataset with the Fleming Harrington weighted Logrank Test</p></a></li>
<li><a href='#analyse_maxcombo'><p>Analyse Dataset with the Maxcombo Test</p></a></li>
<li><a href='#analyse_milestone_survival'><p>Analyse the Dataset using difference or quotient of milestone survival</p></a></li>
<li><a href='#analyse_modelstly_weighted'><p>Create Analyse function for the modestly weighted logrank test</p></a></li>
<li><a href='#analyse_piecewise_exponential'><p>Create Analyse function for piecewise exponential model</p></a></li>
<li><a href='#analyse_rmst_diff'><p>Analyse the Dataset using the difference in RMST</p></a></li>
<li><a href='#analyse_weibull'><p>Analyse Dataset with Weibull Regression</p></a></li>
<li><a href='#assumptions_progression'><p>Create an empty assumtions data.frame for generate_progression</p></a></li>
<li><a href='#combination_tests_delayed'><p>Results of an example simulation</p></a></li>
<li><a href='#create_summarise_function'><p>Create a summarise function from a named list of functions</p></a></li>
<li><a href='#design_fixed_followup'><p>Create a data.frame with an example fixed design</p></a></li>
<li><a href='#design_group_sequential'><p>Create a data.frame with an example group sequential design</p></a></li>
<li><a href='#generate_crossing_hazards'><p>Generate Dataset with crossing hazards</p></a></li>
<li><a href='#generate_delayed_effect'><p>Generate Dataset with delayed effect</p></a></li>
<li><a href='#generate_subgroup'><p>Generate Dataset with different treatment effect in subgroup</p></a></li>
<li><a href='#labs_from_labels'><p>Add ggplot axis labels from labels attribute</p></a></li>
<li><a href='#mixture_haz_fun'><p>Fast implementation of hazard, cumulative hazard, ... for mixtures of subpopulations</p></a></li>
<li><a href='#progression_cdf_fun'><p>Fast implementation of cumulative density function, survival function, ... for scenarios with progression</p></a></li>
<li><a href='#r2m'><p>Functions to Convert Between Days and Months and Medians and Rates</p></a></li>
<li><a href='#random_censoring_exp'><p>Apply Random Exponentially Distributed Censoring</p></a></li>
<li><a href='#recruitment_uniform'><p>Add recruitment time to Dataset</p></a></li>
<li><a href='#rename_results_column'><p>Rename Columns in Simulation Results and Update Attributes</p></a></li>
<li><a href='#results_pivot_longer'><p>Functions for Plotting and Reporting Results</p></a></li>
<li><a href='#shhr_gg'><p>Plot of survival, hazard and hazard ratio of two groups as a function of time using ggplot and patchwork</p></a></li>
<li><a href='#summarise_estimator'><p>Generic Summarise function for esitmators</p></a></li>
<li><a href='#summarise_test'><p>Generic summarise function for tests</p></a></li>
<li><a href='#upsert_merge'><p>Merge results from additional or updated simulations</p></a></li>
<li><a href='#wrap_all_in_trycatch'><p>Wrappers around Analyse Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate Non-Proportional Hazards</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.6</td>
</tr>
<tr>
<td>License:</td>
<td><a href="http://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit for simulation studies concerning time-to-event endpoints
    with non-proportional hazards. 'SimNPH' encompasses functions for simulating
    time-to-event data in various scenarios, simulating different trial designs
    like fixed-followup, event-driven, and group sequential designs. The package
    provides functions to calculate the true values of common summary statistics
    for the implemented scenarios and offers common analysis methods for
    time-to-event data. Helper functions for running simulations with the
    'SimDesign' package and for aggregating and presenting the results are also
    included. Results of the conducted simulation study are available in the 
    paper: "A Comparison of Statistical Methods for Time-To-Event Analyses in 
    Randomized Controlled Trials Under Non-Proportional Hazards", 
    Klinglmüller et al. (2025) &lt;<a href="https://doi.org/10.1002%2Fsim.70019">doi:10.1002/sim.70019</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>SimDesign, survival, R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), covr, withr, ldbounds,
ggplot2, patchwork</td>
</tr>
<tr>
<td>Imports:</td>
<td>miniPCH (&ge; 0.3.0), purrr (&ge; 1.0.0), rlang, tibble, nph,
nphRCT, car, dplyr, stringr, methods, tidyr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://simnph.github.io/SimNPH/">https://simnph.github.io/SimNPH/</a>,
<a href="https://github.com/SimNPH/SimNPH/">https://github.com/SimNPH/SimNPH/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SimNPH/SimNPH/issues/">https://github.com/SimNPH/SimNPH/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-20 11:52:35 UTC; Tobias11</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Fellinger <a href="https://orcid.org/0000-0001-9474-2731"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Florian Klinglmueller
    <a href="https://orcid.org/0000-0002-7346-3669"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Fellinger &lt;tobias.fellinger@ages.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-20 12:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='SimNPH'>SimNPH</h2><span id='topic+SimNPH-package'></span><span id='topic+SimNPH'></span>

<h3>Description</h3>

<p>SimNPH: Simulate Non Proportional Hazards
</p>


<h3>Details</h3>

<p>This package provides several functions to simulate survival data with non
proportional hazards using the general purpose simulation package SimDesign.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tobias Fellinger <a href="mailto:tobias.fellinger@ages.at">tobias.fellinger@ages.at</a> (<a href="https://orcid.org/0000-0001-9474-2731">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Florian Klinglmueller (<a href="https://orcid.org/0000-0002-7346-3669">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://simnph.github.io/SimNPH/">https://simnph.github.io/SimNPH/</a>
</p>
</li>
<li> <p><a href="https://github.com/SimNPH/SimNPH/">https://github.com/SimNPH/SimNPH/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SimNPH/SimNPH/issues/">https://github.com/SimNPH/SimNPH/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='analyse_aft'>Analyse Dataset with accelarated failure time models</h2><span id='topic+analyse_aft'></span>

<h3>Description</h3>

<p>Analyse Dataset with accelarated failure time models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_aft(level = 0.95, dist = "weibull", alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_aft_+3A_level">level</code></td>
<td>
<p>confidence level for CI computation</p>
</td></tr>
<tr><td><code id="analyse_aft_+3A_dist">dist</code></td>
<td>
<p>passed to survival::survreg</p>
</td></tr>
<tr><td><code id="analyse_aft_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>alternative</code> can be &quot;two.sided&quot; for a two sided test of equality of the
summary statistic or &quot;one.sided&quot; for a one sided test testing H0: treatment
has equal or shorter survival than control vs. H1 treatment has longer
survival than control.
</p>


<h3>Value</h3>

<p>an analyse function that returns a list with the elements
</p>

<ul>
<li> <p><code>p</code> p value of the score test (two.sided) or the Wald test (one.sided)
</p>
</li>
<li> <p><code>alternative</code> the alternative used
</p>
</li>
<li> <p><code>coef</code> coefficient for <code>trt</code>
</p>
</li>
<li> <p><code>lower</code> lower 95% confidence intervall boundary for the coefficient
</p>
</li>
<li> <p><code>upper</code>lower 95% confidence intervall boundary for the coefficient
</p>
</li>
<li> <p><code>CI_level</code> the CI level used
</p>
</li>
<li> <p><code>N_pat</code> number of patients
</p>
</li>
<li> <p><code>N_evt</code> number of events
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by = NULL
) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_aft()(condition, dat)
analyse_aft(dist="lognormal")(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_ahr'>Analyse the dataset using extimators for the the average hazard ratio</h2><span id='topic+analyse_ahr'></span>

<h3>Description</h3>

<p>Analyse the dataset using extimators for the the average hazard ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_ahr(
  max_time = NA,
  type = "AHR",
  level = 0.95,
  alternative = "two.sided"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_ahr_+3A_max_time">max_time</code></td>
<td>
<p>time for which the AHR is calculated</p>
</td></tr>
<tr><td><code id="analyse_ahr_+3A_type">type</code></td>
<td>
<p>&quot;AHR&quot; for average hazard ratio &quot;gAHR&quot; for geometric average hazard ratio</p>
</td></tr>
<tr><td><code id="analyse_ahr_+3A_level">level</code></td>
<td>
<p>confidence level for CI computation</p>
</td></tr>
<tr><td><code id="analyse_ahr_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation from the nph package is used, see the documentation there
for details.
</p>
<p><code>alternative</code> can be &quot;two.sided&quot; for a two sided test of equality of the
summary statistic or &quot;one.sided&quot; for a one sided test testing H0: treatment
has equal or shorter survival than control vs. H1 treatment has longer
survival than control.
</p>
<p>The data.frame returned by the created function includes the follwing
columns:
</p>

<ul>
<li> <p><code>p</code> p value of the test, see Details
</p>
</li>
<li> <p><code>alternative</code> the alternative used
</p>
</li>
<li> <p><code>AHR</code>/<code>gAHR</code> estimated (geometric) average hazard ratio
</p>
</li>
<li> <p><code>AHR_lower</code>/<code>gAHR_lower</code> unadjusted lower bound of the confidence interval for the (geometric) average hazard ratio
</p>
</li>
<li> <p><code>AHR_upper</code>/<code>gAHR_upper</code> unadjusted upper bound of the confidence interval for the (geometric) average hazard ratio
</p>
</li>
<li> <p><code>CI_level</code> the CI level used
</p>
</li>
<li> <p><code>N_pat</code> number of patients
</p>
</li>
<li> <p><code>N_evt</code> number of events
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an analysis function, that can be used in runSimulations
</p>


<h3>See Also</h3>

<p><a href="nph.html#topic+nphparams">nph::nphparams</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by = NULL
) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_ahr()(condition, dat)
analyse_ahr(type = "gAHR")(condition, dat)
analyse_ahr(max_time = 50, type = "AHR")(condition, dat)
analyse_ahr(max_time = 50, type = "gAHR")(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_coxph'>Analyse Dataset with the Cox Protportional Hazards Model</h2><span id='topic+analyse_coxph'></span>

<h3>Description</h3>

<p>Analyse Dataset with the Cox Protportional Hazards Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_coxph(level = 0.95, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_coxph_+3A_level">level</code></td>
<td>
<p>confidence level for CI computation</p>
</td></tr>
<tr><td><code id="analyse_coxph_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>alternative</code> can be &quot;two.sided&quot; for a two sided test of equality of the
summary statistic or &quot;one.sided&quot; for a one sided test testing H0: treatment
has equal or shorter survival than control vs. H1 treatment has longer
survival than control.
</p>


<h3>Value</h3>

<p>an analyse function that returns a list with the elements
</p>

<ul>
<li> <p><code>p</code> p value of the score test (two.sided) or the Wald test (one.sided)
</p>
</li>
<li> <p><code>alternative</code> the alternative used
</p>
</li>
<li> <p><code>coef</code> coefficient for <code>trt</code>
</p>
</li>
<li> <p><code>hr</code> hazard ratio for <code>trt</code>
</p>
</li>
<li> <p><code>hr_lower</code> lower 95% confidence intervall boundary for the hazard ratio for <code>trt</code>
</p>
</li>
<li> <p><code>hr_upper</code>lower 95% confidence intervall boundary for the hazard ratio for <code>trt</code>
</p>
</li>
<li> <p><code>CI_level</code> the CI level used
</p>
</li>
<li> <p><code>N_pat</code> number of patients
</p>
</li>
<li> <p><code>N_evt</code> number of events
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by = NULL
) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_coxph()(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_describe'>Create a Function for Descriptive Statistics of a Dataset</h2><span id='topic+analyse_describe'></span><span id='topic+summarise_describe'></span>

<h3>Description</h3>

<p>Create a Function for Descriptive Statistics of a Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_describe()

summarise_describe(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_describe_+3A_name">name</code></td>
<td>
<p>name for the summarise function, appended to the name of the analysis method in the final results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an analyse function that returns a list with the elements
</p>

<ul>
<li> <p><code>followup</code> follow up time
</p>
</li>
<li> <p><code>events</code> table of events vs. treatment
</p>
</li>
<li> <p><code>ice</code> if column ice is present, table of intercurrent events, events, treatment
</p>
</li>
<li> <p><code>subgroup</code> if column subgroup is present, table of subgroup, events, treatment
</p>
</li></ul>

<p>A function that can be used in Summarise that returns a data frame with
columns with means and standard deviations for every variable in the
description.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>summarise_describe()</code>: Summarise Descriptive Statistics
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
    assumptions_delayed_effect(),
    design_fixed_followup(),
    by=NULL
  ) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_describe()(condition, dat)
condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by=NULL
) |&gt;
  tail(4) |&gt;
  head(1)

summarise_all &lt;- create_summarise_function(
  describe=summarise_describe()
)

# runs simulations
sim_results &lt;- runSimulation(
  design=condition,
  replications=100,
  generate=generate_delayed_effect,
  analyse=list(
    describe=analyse_describe()
  ),
  summarise = summarise_all
)

# study time is missing, since there was no admin. censoring
sim_results[, 9:16]
</code></pre>

<hr>
<h2 id='analyse_diff_median_survival'>Analyse the dataset using differnce in median survival</h2><span id='topic+analyse_diff_median_survival'></span>

<h3>Description</h3>

<p>Analyse the dataset using differnce in median survival
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_diff_median_survival(
  quant = 0.5,
  level = 0.95,
  alternative = "two.sided"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_diff_median_survival_+3A_quant">quant</code></td>
<td>
<p>quantile for which the difference should be calculated, defaults to the median</p>
</td></tr>
<tr><td><code id="analyse_diff_median_survival_+3A_level">level</code></td>
<td>
<p>confidence level for CI computation</p>
</td></tr>
<tr><td><code id="analyse_diff_median_survival_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation from the nph package is used, see the documentation there
for details.
</p>
<p>The data.frame returned by the created function includes the follwing
columns:
</p>

<ul>
<li> <p><code>p</code> p value of the test, see Details
</p>
</li>
<li> <p><code>alternative</code> the alternative used
</p>
</li>
<li> <p><code>diff_Q</code> estimated differnce in quantile of the suvivla functions
</p>
</li>
<li> <p><code>diff_Q_lower</code> unadjusted lower bound of the confidence interval for the differnce in quantile of the suvivla functions
</p>
</li>
<li> <p><code>diff_Q_upper</code> unadjusted upper bound of the confidence interval for the differnce in quantile of the suvivla functions
</p>
</li>
<li> <p><code>CI_level</code> the CI level used
</p>
</li>
<li> <p><code>quantile</code> quantile used for extimation
</p>
</li>
<li> <p><code>N_pat</code> number of patients
</p>
</li>
<li> <p><code>N_evt</code> number of events
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an analysis function, that can be used in runSimulations
</p>


<h3>See Also</h3>

<p><a href="nph.html#topic+nphparams">nph::nphparams</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by = NULL
) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_diff_median_survival()(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_gehan_wilcoxon'>Create Analyse function for Gehan Wilcoxon test</h2><span id='topic+analyse_gehan_wilcoxon'></span>

<h3>Description</h3>

<p>Create Analyse function for Gehan Wilcoxon test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_gehan_wilcoxon(alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_gehan_wilcoxon_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>alternative</code> can be &quot;two.sided&quot; for a two sided test of equality of the
summary statistic or &quot;one.sided&quot; for a one sided test testing H0: treatment
has equal or shorter survival than control vs. H1 treatment has longer
survival than control.
</p>


<h3>Value</h3>

<p>an analyse function that can be used in runSimulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by = NULL
) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_gehan_wilcoxon()(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_group_sequential'>Create Analyse Functions for Group Sequential Design</h2><span id='topic+analyse_group_sequential'></span><span id='topic+summarise_group_sequential'></span>

<h3>Description</h3>

<p>Create Analyse Functions for Group Sequential Design
</p>
<p>Summarise Output from Analyse Functions for Group Sequential Design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_group_sequential(followup, followup_type, alpha, analyse_functions)

summarise_group_sequential(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_group_sequential_+3A_followup">followup</code></td>
<td>
<p>followup events or time</p>
</td></tr>
<tr><td><code id="analyse_group_sequential_+3A_followup_type">followup_type</code></td>
<td>
<p>&quot;events&quot; or &quot;time&quot;</p>
</td></tr>
<tr><td><code id="analyse_group_sequential_+3A_alpha">alpha</code></td>
<td>
<p>nominal alpha at each stage</p>
</td></tr>
<tr><td><code id="analyse_group_sequential_+3A_analyse_functions">analyse_functions</code></td>
<td>
<p>analyse function or list of analyse functions</p>
</td></tr>
<tr><td><code id="analyse_group_sequential_+3A_name">name</code></td>
<td>
<p>name attribute of the returned closure</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>followup</code>, <code>followup_type</code> and <code>alpha</code> are evaluated for every simulated
dataset, i.e. the arguments to the Analyse function are available,
expressions like <code>followup=c(condition$interim, condition$max_followup)</code> are
valid arguments.
</p>
<p>analyse_functions should take arguments condition, dataset and fixed_objects
and return a list conatining p-value, number of patients and number of event
in the columsn <code>p</code>, <code>N_pat</code> and <code>N_evt</code>.
</p>


<h3>Value</h3>

<p>an analyse function that can be used in runSimulation
</p>
<p>Returns a function with the arguments:
</p>

<ul>
<li><p> condition
</p>
</li>
<li><p> results
</p>
</li>
<li><p> fixed objects
</p>
</li></ul>

<p>that can be passed to create_summarise_function or to
SimDesign::runSimulation and that returns a <code>data.frame</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>summarise_group_sequential()</code>: Summarise Output from Analyse Functions for Group Sequential Design
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># create a function to analyse after interim_events and maximum followup time
# given in the condition row of the design data.frame with given
# nominal alpha
analyse_maxcombo_sequential &lt;- analyse_group_sequential(
  followup = c(condition$interim_events, condition$followup),
  followup_type = c("event", "time"),
  alpha = c(0.025, 0.05),
  analyse_functions = analyse_maxcombo()
)
Summarise &lt;- create_summarise_function(
  maxcombo_seq = summarise_group_sequential(),
  logrank_seq = summarise_group_sequential(name="logrank")
)
</code></pre>

<hr>
<h2 id='analyse_logrank'>Analyse Dataset with the Logrank Test</h2><span id='topic+analyse_logrank'></span>

<h3>Description</h3>

<p>Analyse Dataset with the Logrank Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_logrank(alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_logrank_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>alternative</code> can be &quot;two.sided&quot; for a two sided test of equality of the
summary statistic or &quot;one.sided&quot; for a one sided test testing H0: treatment
has equal or shorter survival than control vs. H1 treatment has longer
survival than control.
</p>


<h3>Value</h3>

<p>an analysis function that returns a data.frame with the columns
</p>

<ul>
<li> <p><code>p</code> p-value of the logrank test
</p>
</li>
<li> <p><code>alternative</code> the alternative used
</p>
</li>
<li> <p><code>N_pat</code> number of patients
</p>
</li>
<li> <p><code>N_evt</code> number of events
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by = NULL
) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_logrank()(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_logrank_fh_weights'>Analyse Dataset with the Fleming Harrington weighted Logrank Test</h2><span id='topic+analyse_logrank_fh_weights'></span>

<h3>Description</h3>

<p>Analyse Dataset with the Fleming Harrington weighted Logrank Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_logrank_fh_weights(rho, gamma, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_logrank_fh_weights_+3A_rho">rho</code></td>
<td>
<p>rho for the rho-gamma family of weights</p>
</td></tr>
<tr><td><code id="analyse_logrank_fh_weights_+3A_gamma">gamma</code></td>
<td>
<p>gamma for the rho-gamma family of weights</p>
</td></tr>
<tr><td><code id="analyse_logrank_fh_weights_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>alternative</code> can be &quot;two.sided&quot; for a two sided test of equality of the
summary statistic or &quot;one.sided&quot; for a one sided test testing H0: treatment
has equal or shorter survival than control vs. H1 treatment has longer
survival than control.
</p>


<h3>Value</h3>

<p>a function with the arguments condition, dat and fixed_objects that
returns a dataframe with the p-value of the weighted logrank test in the
column p. See ?SimDesign::Analyse for details on the arguments condition,
dat, fixed_arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by = NULL
) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
# create two functions with different weights
analyse_01 &lt;- analyse_logrank_fh_weights(rho = 0, gamma = 1)
analyse_10 &lt;- analyse_logrank_fh_weights(rho = 1, gamma = 0)
# run the tests created before
analyse_01(condition, dat)
analyse_10(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_maxcombo'>Analyse Dataset with the Maxcombo Test</h2><span id='topic+analyse_maxcombo'></span>

<h3>Description</h3>

<p>Analyse Dataset with the Maxcombo Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_maxcombo(alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_maxcombo_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>alternative</code> can be &quot;two.sided&quot; for a two sided test of equality of the
summary statistic or &quot;one.sided&quot; for a one sided test testing H0: treatment
has equal or shorter survival than control vs. H1 treatment has longer
survival than control.
</p>


<h3>Value</h3>

<p>an analyse function that returns a data.frame with the combined
p-value of the max combo test in the column p
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by = NULL
) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_maxcombo()(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_milestone_survival'>Analyse the Dataset using difference or quotient of milestone survival</h2><span id='topic+analyse_milestone_survival'></span>

<h3>Description</h3>

<p>Analyse the Dataset using difference or quotient of milestone survival
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_milestone_survival(
  times,
  what = "quot",
  level = 0.95,
  alternative = "two.sided"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_milestone_survival_+3A_times">times</code></td>
<td>
<p>followup times at which the the survival should be compared</p>
</td></tr>
<tr><td><code id="analyse_milestone_survival_+3A_what">what</code></td>
<td>
<p>&quot;quot&quot; for quotient and &quot;diff&quot; for differnce of surival probabilities</p>
</td></tr>
<tr><td><code id="analyse_milestone_survival_+3A_level">level</code></td>
<td>
<p>confidence level for CI computation</p>
</td></tr>
<tr><td><code id="analyse_milestone_survival_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation from the nph package is used, see the documentation there
for details.
</p>
<p><code>alternative</code> can be &quot;two.sided&quot; for a two sided test of equality of the
summary statistic or &quot;one.sided&quot; for a one sided test testing H0: treatment
has equal or shorter survival than control vs. H1 treatment has longer
survival than control.
</p>
<p>The data.frame returned by the created function includes the follwing
columns:
</p>

<ul>
<li> <p><code>milestone_surv_ratio</code> / <code>milestone_surv_diff</code> ratio or differnce of survival probabilities
</p>
</li>
<li> <p><code>times</code> followup times at which the the survival are compared
</p>
</li>
<li> <p><code>N_pat</code> number of patients
</p>
</li>
<li> <p><code>N_evt</code> number of events
</p>
</li>
<li> <p><code>p</code> p value for the H0 that the ratios are 1 or the differnce is 0 respectively
</p>
</li>
<li> <p><code>alternative</code> the alternative used
</p>
</li>
<li> <p><code>milestone_surv_ratio_lower</code> / <code>milestone_surv_diff_lower</code> upper/lower CI for the estimate
</p>
</li>
<li> <p><code>milestone_surv_ratio_upper</code> / <code>milestone_surv_diff_upper</code> upper/lower CI for the estimate
</p>
</li>
<li> <p><code>CI_level</code> the CI level used
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an analysis function, that can be used in runSimulations
</p>


<h3>See Also</h3>

<p><a href="nph.html#topic+nphparams">nph::nphparams</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
    assumptions_delayed_effect(),
    design_fixed_followup(),
    by=NULL
  ) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_milestone_survival(3:5)(condition, dat)
analyse_milestone_survival(3:5, what="diff")(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_modelstly_weighted'>Create Analyse function for the modestly weighted logrank test</h2><span id='topic+analyse_modelstly_weighted'></span>

<h3>Description</h3>

<p>Create Analyse function for the modestly weighted logrank test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_modelstly_weighted(t_star)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_modelstly_weighted_+3A_t_star">t_star</code></td>
<td>
<p>parameter t* of the modestly weighted logrank test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an analyse function that can be used in runSimulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
   assumptions_delayed_effect(),
   design_fixed_followup(),
   by=NULL
 ) |&gt;
 head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_modelstly_weighted(20)(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_piecewise_exponential'>Create Analyse function for piecewise exponential model</h2><span id='topic+analyse_piecewise_exponential'></span>

<h3>Description</h3>

<p>Create Analyse function for piecewise exponential model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_piecewise_exponential(cuts, testing_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_piecewise_exponential_+3A_cuts">cuts</code></td>
<td>
<p>interval boundaries for the piecewise exponential model</p>
</td></tr>
<tr><td><code id="analyse_piecewise_exponential_+3A_testing_only">testing_only</code></td>
<td>
<p>if set to <code>TRUE</code> omits all statistics in the
intervals and just returns the p value of the global test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there's any time interval no patients ever enter, NA is returned
for all time intervals. This behavior will likely change in future package
versions.
</p>


<h3>Value</h3>

<p>an analyse function that can be used in runSimulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
   assumptions_delayed_effect(),
   design_fixed_followup(),
   by=NULL
 ) |&gt;
 head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_piecewise_exponential(cuts=c(90, 360))(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_rmst_diff'>Analyse the Dataset using the difference in RMST</h2><span id='topic+analyse_rmst_diff'></span>

<h3>Description</h3>

<p>Analyse the Dataset using the difference in RMST
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_rmst_diff(max_time = NA, level = 0.95, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_rmst_diff_+3A_max_time">max_time</code></td>
<td>
<p>time for which the RMST is calculated</p>
</td></tr>
<tr><td><code id="analyse_rmst_diff_+3A_level">level</code></td>
<td>
<p>confidence level for CI computation</p>
</td></tr>
<tr><td><code id="analyse_rmst_diff_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation from the nph package is used, see the documentation there
for details.
</p>
<p><code>alternative</code> can be &quot;two.sided&quot; for a two sided test of equality of the
summary statistic or &quot;one.sided&quot; for a one sided test testing H0: treatment
has equal or shorter survival than control vs. H1 treatment has longer
survival than control.
</p>
<p>The data.frame returned by the created function includes the follwing
columns:
</p>

<ul>
<li> <p><code>p</code> p value of the test, see Details
</p>
</li>
<li> <p><code>alternative</code> the alternative used
</p>
</li>
<li> <p><code>rmst_diff</code> estimated differnce in RMST
</p>
</li>
<li> <p><code>rmst_diff_lower</code> unadjusted lower bound of the confidence interval for differnce in RMST
</p>
</li>
<li> <p><code>rmst_diff_upper</code> unadjusted upper bound of the confidence interval for differnce in RMST
</p>
</li>
<li> <p><code>CI_level</code> the CI level used
</p>
</li>
<li> <p><code>N_pat</code> number of patients
</p>
</li>
<li> <p><code>N_evt</code> number of events
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an analysis function, that can be used in runSimulations
</p>


<h3>See Also</h3>

<p><a href="nph.html#topic+nphparams">nph::nphparams</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by = NULL
) |&gt;
  head(1)
dat &lt;- generate_delayed_effect(condition)
analyse_rmst_diff()(condition, dat)
</code></pre>

<hr>
<h2 id='analyse_weibull'>Analyse Dataset with Weibull Regression</h2><span id='topic+analyse_weibull'></span>

<h3>Description</h3>

<p>Analyse Dataset with Weibull Regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_weibull(level = 0.95, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_weibull_+3A_level">level</code></td>
<td>
<p>confidence level for CI computation</p>
</td></tr>
<tr><td><code id="analyse_weibull_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis for the tests &quot;two.sided&quot; or &quot;one.sieded&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the columns in the return are the two-sided p-value for the test of
equal medians. The estimated medians in the treatment and control group and
the estimated difference in median survival with confidence intervals.
</p>
<p>The estimates and tests are comstructed by fitting seperate Weibull
regression models in the treatment and control groups and then estimating
the medians and respective variances with the delta-method.
</p>


<h3>Value</h3>

<p>an analysis function that returns a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>condition &lt;- merge(
    assumptions_delayed_effect(),
    design_fixed_followup(),
    by=NULL
  ) |&gt;
  head(3) |&gt;
  tail(1)
dat &lt;- generate_delayed_effect(condition)
analyse_weibull()(condition, dat)
</code></pre>

<hr>
<h2 id='assumptions_progression'>Create an empty assumtions data.frame for generate_progression</h2><span id='topic+assumptions_progression'></span><span id='topic+generate_progression'></span><span id='topic+true_summary_statistics_progression'></span><span id='topic+progression_rate_from_progression_prop'></span><span id='topic+cen_rate_from_cen_prop_progression'></span><span id='topic+hazard_before_progression_from_PH_effect_size'></span>

<h3>Description</h3>

<p>Create an empty assumtions data.frame for generate_progression
</p>
<p>Generate Dataset with changing hazards after disease progression
</p>
<p>Calculate progression rate from proportion of patients who progress
</p>
<p>Calculate hr after onset of treatment effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assumptions_progression(print = interactive())

generate_progression(condition, fixed_objects = NULL)

true_summary_statistics_progression(
  Design,
  what = "os",
  cutoff_stats = NULL,
  fixed_objects = NULL,
  milestones = NULL
)

progression_rate_from_progression_prop(design)

cen_rate_from_cen_prop_progression(design)

hazard_before_progression_from_PH_effect_size(
  design,
  target_power_ph = NA_real_,
  final_events = NA_real_,
  target_alpha = 0.025
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assumptions_progression_+3A_print">print</code></td>
<td>
<p>print code to generate parameter set?</p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_condition">condition</code></td>
<td>
<p>condition row of Design dataset</p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_fixed_objects">fixed_objects</code></td>
<td>
<p>additional settings, see details</p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_design">Design</code></td>
<td>
<p>Design data.frame for subgroup</p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_what">what</code></td>
<td>
<p>True summary statistics for which estimand</p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_cutoff_stats">cutoff_stats</code></td>
<td>
<p>(optionally named) cutoff time, see details</p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_milestones">milestones</code></td>
<td>
<p>(optionally named) vector of times at which milestone survival should be calculated</p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_design">design</code></td>
<td>
<p>design data.frame</p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_target_power_ph">target_power_ph</code></td>
<td>
<p>target power under proportional hazards</p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_final_events">final_events</code></td>
<td>
<p>target events for inversion of Schönfeld Formula, defaults to <code>condition$final_events</code></p>
</td></tr>
<tr><td><code id="assumptions_progression_+3A_target_alpha">target_alpha</code></td>
<td>
<p>target one-sided alpha level for the power calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>assumptions_progression generates a default design <code>data.frame</code> for
use with generate_progression If print is <code>TRUE</code> code to produce the
template is also printed for copying, pasting and editing by the user.
(This is the default when run in an interactive session.)
</p>
<p>Condidtion has to contain the following columns:
</p>

<ul>
<li><p> n_trt number of paitents in treatment arm
</p>
</li>
<li><p> n_ctrl number of patients in control arm
</p>
</li>
<li><p> hazard_ctrl hazard in the control arm
</p>
</li>
<li><p> hazard_trt hazard in the treatment arm for not cured patients
</p>
</li>
<li><p> hazard_after_prog hazard after disease progression
</p>
</li>
<li><p> prog_rate_ctrl hazard rate for disease progression unter control
</p>
</li>
<li><p> prog_rate_trt hazard rate for disease progression unter treatment
</p>
</li></ul>

<p><code>what</code> can be <code>"os"</code> for overall survival and <code>"pfs"</code> for progression free
survival.
</p>
<p>The if <code>fixed_objects</code> contains <code>t_max</code> then this value is used as the
maximum time to calculate function like survival, hazard, ... of the data
generating models. If this is not given <code>t_max</code> is choosen as the minimum of
the <code>1-(1/10000)</code> quantile of all survival distributions in the model.
</p>
<p><code>cutoff_stats</code> are the times used to calculate the statistics like average
hazard ratios and RMST, that are only calculated up to a certain point.
</p>
<p>For progression_rate_from_progression_prop, the design data.frame,
has to contain the columns <code>prog_prop_trt</code> and <code>prog_prop_ctrl</code> with the
proportions of patients, who progress in the respective arms.
</p>
<p>cen_rate_from_cen_prop_progression takes the proportion of
censored patients from the column <code>censoring_prop</code>. This column describes
the proportion of patients who are censored randomly before experiencing an
event, without regard to administrative censoring.
</p>
<p><code>hazard_before_progression_from_PH_effect_size</code> calculates the
hazard ratio after onset of treatment effect as follows: First calculate
the hazard in the control arm that would give the same median survival
under an exponential model. Then calculate the median survival in the
treatment arm that would give the desired power of the logrank test under
exponential models in control and treatment arm. Then callibrate the hazard
before progression in the treatment arm to give the same median survival
time.
</p>
<p>This is a heuristic and to some extent arbitrary approach to calculate
hazard ratios that correspond to reasonable and realistic scenarios.
</p>


<h3>Value</h3>

<p>For generate_progression: a design tibble with default values invisibly
</p>
<p>For generate_progression: A dataset with the columns t (time) and trt
(1=treatment, 0=control), evt (event, currently TRUE for all observations),
t_ice (time of intercurrent event), ice (intercurrent event)
</p>
<p>For true_summary_statistics_subgroup: the design data.frame
passed as argument with the additional columns
</p>
<p>For progression_rate_from_progression_prop: the design data.frame passed as
argument with the additional columns prog_rate_trt, prog_rate_ctrl
</p>
<p>for cen_rate_from_cen_prop_progression: design data.frame with the
additional column random_withdrawal
</p>
<p>For hazard_before_progression_from_PH_effect_size: the design
data.frame passed as argument with the additional column hazard_trt.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>assumptions_progression()</code>: generate default assumptions <code>data.frame</code>
</p>
</li>
<li> <p><code>generate_progression()</code>: simulates a dataset with changing hazards after disease progression
</p>
</li>
<li> <p><code>true_summary_statistics_progression()</code>: calculate true summary statistics for scenarios with disease progression
</p>
</li>
<li> <p><code>progression_rate_from_progression_prop()</code>: Calculate progression rate from proportion of patients who progress
</p>
</li>
<li> <p><code>cen_rate_from_cen_prop_progression()</code>: calculate censoring rate from censoring proportion
</p>
</li>
<li> <p><code>hazard_before_progression_from_PH_effect_size()</code>: Calculate hazard in the treatment arm before progression from PH effect size
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>Design &lt;- assumptions_progression()
Design
one_simulation &lt;- merge(
    assumptions_progression(),
    design_fixed_followup(),
    by=NULL
  ) |&gt;
  tail(1) |&gt;
  generate_progression()
head(one_simulation)
tail(one_simulation)

my_design &lt;- merge(
  assumptions_progression(),
  design_fixed_followup(),
  by=NULL
)

my_design_os  &lt;- true_summary_statistics_progression(my_design, "os")
my_design_pfs &lt;- true_summary_statistics_progression(my_design, "pfs")
my_design_os
my_design_pfs
my_design &lt;- merge(
    assumptions_progression(),
    design_fixed_followup(),
    by=NULL
  )
my_design$prog_rate_ctrl &lt;- NA_real_
my_design$prog_rate_trt &lt;- NA_real_
my_design$prog_prop_trt &lt;- 0.2
my_design$prog_prop_ctrl &lt;- 0.3
my_design &lt;- progression_rate_from_progression_prop(my_design)
my_design
design &lt;- expand.grid(
hazard_ctrl         = m2r(15),          # hazard under control
hazard_trt          = m2r(18),          # hazard under treatment
hazard_after_prog   = m2r(3),           # hazard after progression
prog_rate_ctrl      = m2r(12),          # hazard for disease progression under control
prog_rate_trt       = m2r(c(12,16,18)), # hazard for disease progression under treatment
censoring_prop      = 0.1,              # rate of random withdrawal
followup            = 100,              # follow up time
n_trt               = 50,               # patients in treatment arm
n_ctrl              = 50                # patients in control arm
)
cen_rate_from_cen_prop_progression(design)

my_design &lt;- merge(
  design_fixed_followup(),
  assumptions_progression(),
  by=NULL
)

my_design$hazard_trt &lt;- NULL
my_design$final_events &lt;- ceiling(0.75 * (my_design$n_trt + my_design$n_ctrl))

my_design &lt;- hazard_before_progression_from_PH_effect_size(my_design, target_power_ph=0.7)
my_design

</code></pre>

<hr>
<h2 id='combination_tests_delayed'>Results of an example simulation</h2><span id='topic+combination_tests_delayed'></span>

<h3>Description</h3>

<p>Results of an example simulation study comparing the power of logrank
max-combo and modelstly weighted logrank test in differnt scenarios with
delayed onset of treatment effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combination_tests_delayed
</code></pre>


<h3>Format</h3>

<p>a <code>tibble</code> as returned by <code>SimDesign::runSimulation</code>.
</p>

<hr>
<h2 id='create_summarise_function'>Create a summarise function from a named list of functions</h2><span id='topic+create_summarise_function'></span>

<h3>Description</h3>

<p>Create a summarise function from a named list of functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_summarise_function(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_summarise_function_+3A_...">...</code></td>
<td>
<p>summarise function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the names of the list of functions correspond to the names in the
list of analyse functions, each summarise function is applied to the
results of the analyse function of the same name, names not present in both
lists are ommitted in either list.
</p>
<p>The functions in the list should have the arguments <code>condition</code>, <code>results</code>
and <code>fixed_objects</code>. <code>results</code> is a list of lists. The outer list has one
element for each replication, the inner list has one entry for each Analyse
function. (Analyse functions have to return lists for this to work,
otherwise the results are simplified to data.frames. Analyse functions from
the SimNPH package all return lists.)
</p>
<p>The individual summarise functions have to return data.frames, which are
concatendated column-wise to give one row per condition. The names of the
analyse methods are prepended to the respective coumn names, if the
functions have a &quot;name&quot; attribute this is appended to the column names of
the output. Column names not unique after that are appended numbers by
<code>make.unique</code>.
</p>


<h3>Value</h3>

<p>a function with arguments condition, results, fixed objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Summarise &lt;- create_summarise_function(
  maxcombo = function(condition, results, fixed_objects=NULL){
    data.frame("rejection"=mean(results$p &lt; alpha))
  },
  logrank  = function(condition, results, fixed_objects=NULL){
    data.frame("rejection"=mean(results$p &lt; alpha))
  }
)
</code></pre>

<hr>
<h2 id='design_fixed_followup'>Create a data.frame with an example fixed design</h2><span id='topic+design_fixed_followup'></span>

<h3>Description</h3>

<p>Create a data.frame with an example fixed design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_fixed_followup(print = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_fixed_followup_+3A_print">print</code></td>
<td>
<p>print code to generate parameter set?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>design_fixed_followup generates a default design <code>data.frame</code> for
use with generate_delayed_effect or other generate_... functions. If print
is <code>TRUE</code> code to produce the template is also printed for copying, pasting
and editing by the user. (This is the default when run in an interactive
session.)
</p>


<h3>Value</h3>

<p>For design_fixed_followup: a design tibble with default values invisibly
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>design_fixed_followup()</code>: generate default fixed design
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>Design &lt;- design_fixed_followup()
Design
</code></pre>

<hr>
<h2 id='design_group_sequential'>Create a data.frame with an example group sequential design</h2><span id='topic+design_group_sequential'></span>

<h3>Description</h3>

<p>Create a data.frame with an example group sequential design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_group_sequential(print = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_group_sequential_+3A_print">print</code></td>
<td>
<p>print code to generate parameter set?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>design_group_sequential generates a default design <code>data.frame</code> for
use with generate_delayed_effect or other generate_... functions. If print
is <code>TRUE</code> code to produce the template is also printed for copying, pasting
and editing by the user. (This is the default when run in an interactive
session.)
</p>


<h3>Value</h3>

<p>For design_group_sequential: a design tibble with default values invisibly
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>design_group_sequential()</code>: generate default group sequential design
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>Design &lt;- design_group_sequential()
Design
</code></pre>

<hr>
<h2 id='generate_crossing_hazards'>Generate Dataset with crossing hazards</h2><span id='topic+generate_crossing_hazards'></span><span id='topic+assumptions_crossing_hazards'></span><span id='topic+hr_after_crossing_from_PH_effect_size'></span><span id='topic+cen_rate_from_cen_prop_crossing_hazards'></span><span id='topic+true_summary_statistics_crossing_hazards'></span>

<h3>Description</h3>

<p>Generate Dataset with crossing hazards
</p>
<p>Create an empty assumtions data.frame for generate_crossing_hazards
</p>
<p>Calculate hr after crossing the hazard functions
</p>
<p>Calculate true summary statistics for scenarios with crossing hazards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_crossing_hazards(condition, fixed_objects = NULL)

assumptions_crossing_hazards(print = interactive())

hr_after_crossing_from_PH_effect_size(
  design,
  target_power_ph = NA_real_,
  final_events = NA_real_,
  target_alpha = 0.025
)

cen_rate_from_cen_prop_crossing_hazards(design)

true_summary_statistics_crossing_hazards(
  Design,
  cutoff_stats = NULL,
  milestones = NULL,
  fixed_objects = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_crossing_hazards_+3A_condition">condition</code></td>
<td>
<p>condition row of Design dataset</p>
</td></tr>
<tr><td><code id="generate_crossing_hazards_+3A_fixed_objects">fixed_objects</code></td>
<td>
<p>additional settings, see details</p>
</td></tr>
<tr><td><code id="generate_crossing_hazards_+3A_print">print</code></td>
<td>
<p>print code to generate parameter set?</p>
</td></tr>
<tr><td><code id="generate_crossing_hazards_+3A_design">design</code></td>
<td>
<p>design data.frame</p>
</td></tr>
<tr><td><code id="generate_crossing_hazards_+3A_target_power_ph">target_power_ph</code></td>
<td>
<p>target power under proportional hazards</p>
</td></tr>
<tr><td><code id="generate_crossing_hazards_+3A_final_events">final_events</code></td>
<td>
<p>target events for inversion of Schönfeld Formula, defaults to <code>condition$final_events</code></p>
</td></tr>
<tr><td><code id="generate_crossing_hazards_+3A_target_alpha">target_alpha</code></td>
<td>
<p>target one-sided alpha level for the power calculation</p>
</td></tr>
<tr><td><code id="generate_crossing_hazards_+3A_design">Design</code></td>
<td>
<p>Design data.frame for crossing hazards</p>
</td></tr>
<tr><td><code id="generate_crossing_hazards_+3A_cutoff_stats">cutoff_stats</code></td>
<td>
<p>(optionally named) cutoff time, see details</p>
</td></tr>
<tr><td><code id="generate_crossing_hazards_+3A_milestones">milestones</code></td>
<td>
<p>(optionally named) vector of times at which milestone survival should be calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Condidtion has to contain the following columns:
</p>

<ul>
<li><p> n_trt number of paitents in treatment arm
</p>
</li>
<li><p> n_ctrl number of patients in control arm
</p>
</li>
<li><p> crossing time of crossing of the hazards
</p>
</li>
<li><p> hazard_ctrl hazard in the control arm = hazard before onset of treatment
effect
</p>
</li>
<li><p> hazard_trt_before hazard in the treatment arm before onset of treatment effect
</p>
</li>
<li><p> hazard_trt_after hazard in the treatment arm afert onset of treatment effect
</p>
</li></ul>

<p>If fixed_objects is given and contains an element <code>t_max</code>, then this is used
as the cutoff for the simulation used internally. If t_max is not given in
this way the 1-(1/10000) quantile of the survival distribution in the control
or treatment arm is used (which ever is larger).
</p>
<p>assumptions_crossing_hazards generates a default design <code>data.frame</code>
for use with generate_crossing_hazards If print is <code>TRUE</code> code to produce
the template is also printed for copying, pasting and editing by the user.
(This is the default when run in an interactive session.)
</p>
<p><code>hr_after_crossing_from_PH_effect_size</code> calculates the hazard ratio
after crossing of hazards as follows: First, the hazard ratio needed
to archive the desired power under proportional hazards is calculated by
inverting Schönfeld's sample size formula. Second the median survival times
for both arm under this hazard ratio and proportional hazards are
calculated. Finally the hazard rate of the treatment arm after crossing of
hazards is set such that the median survival time is the same as the one
calculated under proportional hazards.
</p>
<p>This is a heuristic and to some extent arbitrary approach to calculate
hazard ratios that correspond to reasonable and realistic scenarios.
</p>
<p>cen_rate_from_cen_prop_crossing_hazards takes the proportion of
censored patients from the column <code>censoring_prop</code>. This column describes
the proportion of patients who are censored randomly before experiencing an
event, without regard to administrative censoring.
</p>
<p><code>cutoff_stats</code> are the times used to calculate the statistics like average
hazard ratios and RMST, that are only calculated up to a certain point.
</p>


<h3>Value</h3>

<p>For generate_crossing_hazards: A dataset with the columns t (time) and trt
(1=treatment, 0=control), evt (event, currently TRUE for all observations)
</p>
<p>For assumptions_crossing_hazards: a design tibble with default values invisibly
</p>
<p>For hr_after_crossing_from_PH_effect_size: the design data.frame passed as
argument with the additional column hazard_trt.
</p>
<p>for cen_rate_from_cen_prop_crossing_hazards: design data.frame with the
additional column random_withdrawal
</p>
<p>For true_summary_statistics_crossing_hazards: the design data.frame
passed as argument with additional columns,
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>generate_crossing_hazards()</code>: simulates a dataset with crossing
hazards
</p>
</li>
<li> <p><code>assumptions_crossing_hazards()</code>: generate default assumptions <code>data.frame</code>
</p>
</li>
<li> <p><code>hr_after_crossing_from_PH_effect_size()</code>: Calculate hr after crossing of the hazards from PH effect size
</p>
</li>
<li> <p><code>cen_rate_from_cen_prop_crossing_hazards()</code>: calculate censoring rate from censoring proportion
</p>
</li>
<li> <p><code>true_summary_statistics_crossing_hazards()</code>: calculate true summary statistics for crossing hazards
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>one_simulation &lt;- merge(
    assumptions_crossing_hazards(),
    design_fixed_followup(),
    by=NULL
  ) |&gt;
  head(1) |&gt;
  generate_crossing_hazards()
head(one_simulation)
tail(one_simulation)
Design &lt;- assumptions_crossing_hazards()
Design
my_design &lt;- merge(
    assumptions_crossing_hazards(),
    design_fixed_followup(),
    by=NULL
  )

my_design$final_events &lt;- ceiling((my_design$n_trt + my_design$n_ctrl)*0.75)
my_design$hazard_trt &lt;- NA
my_design &lt;- hr_after_crossing_from_PH_effect_size(my_design, target_power_ph=0.9)
my_design
design &lt;- data.frame(
  crossing = c(2, 4, 6),
  hazard_ctrl = c(0.05, 0.05, 0.05),
  hazard_trt_before = c(0.025, 0.025, 0.025),
  hazard_trt_after = c(0.1, 0.1, 0.1),
  censoring_prop = c(0.1, 0.3, 0.2),
  n_trt = c(50, 50, 50),
  n_ctrl = c(50, 50, 50),
  followup = c(200, 200, 200),
  recruitment = c(50, 50, 50)
)
cen_rate_from_cen_prop_crossing_hazards(design)
my_design &lt;- merge(
    assumptions_crossing_hazards(),
    design_fixed_followup(),
    by=NULL
  )
my_design$follwup &lt;- 15
my_design &lt;- true_summary_statistics_crossing_hazards(my_design)
my_design
</code></pre>

<hr>
<h2 id='generate_delayed_effect'>Generate Dataset with delayed effect</h2><span id='topic+generate_delayed_effect'></span><span id='topic+assumptions_delayed_effect'></span><span id='topic+hr_after_onset_from_PH_effect_size'></span><span id='topic+cen_rate_from_cen_prop_delayed_effect'></span><span id='topic+true_summary_statistics_delayed_effect'></span>

<h3>Description</h3>

<p>Generate Dataset with delayed effect
</p>
<p>Create an empty assumtions data.frame for generate_delayed_effect
</p>
<p>Calculate hr after onset of treatment effect
</p>
<p>Calculate true summary statistics for scenarios with delayed treatment effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_delayed_effect(condition, fixed_objects = NULL)

assumptions_delayed_effect(print = interactive())

hr_after_onset_from_PH_effect_size(
  design,
  target_power_ph = NA_real_,
  final_events = NA_real_,
  target_alpha = 0.025
)

cen_rate_from_cen_prop_delayed_effect(design)

true_summary_statistics_delayed_effect(
  Design,
  cutoff_stats = NULL,
  milestones = NULL,
  fixed_objects = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_delayed_effect_+3A_condition">condition</code></td>
<td>
<p>condition row of Design dataset</p>
</td></tr>
<tr><td><code id="generate_delayed_effect_+3A_fixed_objects">fixed_objects</code></td>
<td>
<p>additional settings, see details</p>
</td></tr>
<tr><td><code id="generate_delayed_effect_+3A_print">print</code></td>
<td>
<p>print code to generate parameter set?</p>
</td></tr>
<tr><td><code id="generate_delayed_effect_+3A_design">design</code></td>
<td>
<p>design data.frame</p>
</td></tr>
<tr><td><code id="generate_delayed_effect_+3A_target_power_ph">target_power_ph</code></td>
<td>
<p>target power under proportional hazards</p>
</td></tr>
<tr><td><code id="generate_delayed_effect_+3A_final_events">final_events</code></td>
<td>
<p>target events for inversion of Schönfeld Formula
defaults to <code>condition$final_events</code></p>
</td></tr>
<tr><td><code id="generate_delayed_effect_+3A_target_alpha">target_alpha</code></td>
<td>
<p>target one-sided alpha level for the power calculation</p>
</td></tr>
<tr><td><code id="generate_delayed_effect_+3A_design">Design</code></td>
<td>
<p>Design data.frame for delayed effect</p>
</td></tr>
<tr><td><code id="generate_delayed_effect_+3A_cutoff_stats">cutoff_stats</code></td>
<td>
<p>(optionally named) cutoff times, see details</p>
</td></tr>
<tr><td><code id="generate_delayed_effect_+3A_milestones">milestones</code></td>
<td>
<p>(optionally named) vector of times at which milestone survival should be calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Condidtion has to contain the following columns:
</p>

<ul>
<li><p> n_trt number of paitents in treatment arm
</p>
</li>
<li><p> n_ctrl number of patients in control arm
</p>
</li>
<li><p> delay time until onset of effect
</p>
</li>
<li><p> hazard_ctrl hazard in the control arm = hazard before onset of treatment
effect
</p>
</li>
<li><p> hazard_trt hazard in the treatment arm afert onset of treatment effect
</p>
</li></ul>

<p>If fixed_objects is given and contains an element <code>t_max</code>, then this is used
as the cutoff for the simulation used internally. If t_max is not given in
this way the 1-(1/10000) quantile of the survival distribution in the control
or treatment arm is used (which ever is larger).
</p>
<p>assumptions_delayed_effect generates a default design <code>data.frame</code>
for use with generate_delayed_effect. If print is <code>TRUE</code> code to produce
the template is also printed for copying, pasting and editing by the user.
(This is the default when run in an interactive session.)
</p>
<p><code>hr_after_onset_from_PH_effect_size</code> calculates the hazard ratio
after onset of treatment effect as follows: First, the hazard ratio needed
to archive the desired power under proportional hazards is calculated by
inverting Schönfeld's sample size formula. Second the median survival times
for both arm under this hazard ratio and proportional hazards are
calculated. Finally the hazard rate of the treatment arm after onset of
treatment effect is set such that the median survival time is the same as
the one calculated under proportional hazards.
</p>
<p>This is a heuristic and to some extent arbitrary approach to calculate
hazard ratios that correspond to reasonable and realistic scenarios.
</p>
<p>cen_rate_from_cen_prop_delayed_effect takes the proportion of
censored patients from the column <code>censoring_prop</code>. This column describes
the proportion of patients who are censored randomly before experiencing an
event, without regard to administrative censoring.
</p>
<p><code>cutoff_stats</code> are the times used to calculate the statistics like average
hazard ratios and RMST, that are only calculated up to a certain point.
</p>


<h3>Value</h3>

<p>For generate_delayed_effect: A dataset with the columns t (time) and trt
(1=treatment, 0=control), evt (event, currently TRUE for all observations)
</p>
<p>For assumptions_delayed_effect: a design tibble with default values invisibly
</p>
<p>For hr_after_onset_from_PH_effect_size: the design data.frame passed as
argument with the additional column hazard_trt.
</p>
<p>for cen_rate_from_cen_prop_delayed_effect: design data.frame with the
additional column random_withdrawal
</p>
<p>For true_summary_statistics_delayed_effect: the design data.frame
passed as argument with additional columns
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>generate_delayed_effect()</code>: simulates a dataset with delayed
treatment effect
</p>
</li>
<li> <p><code>assumptions_delayed_effect()</code>: generate default assumptions <code>data.frame</code>
</p>
</li>
<li> <p><code>hr_after_onset_from_PH_effect_size()</code>: Calculate hr after onset of treatment effect of the hazards from PH effect size
</p>
</li>
<li> <p><code>cen_rate_from_cen_prop_delayed_effect()</code>: calculate censoring rate from censoring proportion
</p>
</li>
<li> <p><code>true_summary_statistics_delayed_effect()</code>: calculate true summary statistics for delayed effect
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>one_simulation &lt;- merge(
    assumptions_delayed_effect(),
    design_fixed_followup(),
    by=NULL
  ) |&gt;
  head(1) |&gt;
  generate_delayed_effect()
head(one_simulation)
tail(one_simulation)
Design &lt;- assumptions_delayed_effect()
Design
my_design &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by=NULL
)

my_design$hazard_ctrl &lt;- 0.05
my_design$final_events &lt;- ceiling((my_design$n_trt + my_design$n_ctrl)*0.75)
my_design$hazard_trt &lt;- NA
my_design &lt;- hr_after_onset_from_PH_effect_size(my_design, target_power_ph=0.9)
my_design
design &lt;- expand.grid(
  delay=seq(0, 10, by=5),            # delay of 0, 1, ..., 10 days
  hazard_ctrl=0.2,                   # hazard under control and before treatment effect
  hazard_trt=0.02,                   # hazard after onset of treatment effect
  censoring_prop=c(0.1, 0.25, 0.01), # 10%, 25%, 1% random censoring
  followup=100,                      # followup of 100 days
  n_trt=50,                          # 50 patients treatment
  n_ctrl=50                          # 50 patients control
)
cen_rate_from_cen_prop_delayed_effect(design)
my_design &lt;- merge(
    assumptions_delayed_effect(),
    design_fixed_followup(),
    by=NULL
  )
my_design &lt;- true_summary_statistics_delayed_effect(my_design)
my_design
</code></pre>

<hr>
<h2 id='generate_subgroup'>Generate Dataset with different treatment effect in subgroup</h2><span id='topic+generate_subgroup'></span><span id='topic+assumptions_subgroup'></span><span id='topic+true_summary_statistics_subgroup'></span><span id='topic+hazard_subgroup_from_PH_effect_size'></span><span id='topic+cen_rate_from_cen_prop_subgroup'></span>

<h3>Description</h3>

<p>Generate Dataset with different treatment effect in subgroup
</p>
<p>Create an empty assumtions data.frame for generate_subgroup
</p>
<p>Calculate true summary statistics for scenarios with differential treatment effect in subgroup
</p>
<p>Calculate hazards in treatment arm in subgroup and compliment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_subgroup(condition, fixed_objects = NULL)

assumptions_subgroup(print = interactive())

true_summary_statistics_subgroup(
  Design,
  cutoff_stats = NULL,
  milestones = NULL,
  fixed_objects = NULL
)

hazard_subgroup_from_PH_effect_size(
  design,
  target_power_ph = NA_real_,
  final_events = NA_real_,
  target_alpha = 0.025
)

cen_rate_from_cen_prop_subgroup(design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_subgroup_+3A_condition">condition</code></td>
<td>
<p>condition row of Design dataset</p>
</td></tr>
<tr><td><code id="generate_subgroup_+3A_fixed_objects">fixed_objects</code></td>
<td>
<p>additional settings, see details</p>
</td></tr>
<tr><td><code id="generate_subgroup_+3A_print">print</code></td>
<td>
<p>print code to generate parameter set?</p>
</td></tr>
<tr><td><code id="generate_subgroup_+3A_design">Design</code></td>
<td>
<p>Design data.frame for subgroup</p>
</td></tr>
<tr><td><code id="generate_subgroup_+3A_cutoff_stats">cutoff_stats</code></td>
<td>
<p>(optionally named) cutoff times, see details</p>
</td></tr>
<tr><td><code id="generate_subgroup_+3A_milestones">milestones</code></td>
<td>
<p>(optionally named) vector of times at which milestone survival should be calculated</p>
</td></tr>
<tr><td><code id="generate_subgroup_+3A_design">design</code></td>
<td>
<p>design data.frame</p>
</td></tr>
<tr><td><code id="generate_subgroup_+3A_target_power_ph">target_power_ph</code></td>
<td>
<p>target power under proportional hazards</p>
</td></tr>
<tr><td><code id="generate_subgroup_+3A_final_events">final_events</code></td>
<td>
<p>target events for inversion of Schönfeld Formula, defaults to <code>condition$final_events</code></p>
</td></tr>
<tr><td><code id="generate_subgroup_+3A_target_alpha">target_alpha</code></td>
<td>
<p>target one-sided alpha level for the power calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Condidtion has to contain the following columns:
</p>

<ul>
<li><p> n_trt number of paitents in treatment arm
</p>
</li>
<li><p> n_ctrl number of patients in control arm
</p>
</li>
<li><p> hazard_ctrl hazard in the control arm
</p>
</li>
<li><p> hazard_trt hazard in the treatment arm for not cured patients
</p>
</li>
<li><p> hazard_subgroup hazard in the subgroup in the treatment arm
</p>
</li>
<li><p> prevalence proportion of cured patients
</p>
</li></ul>

<p>assumptions_subgroup generates a default design <code>data.frame</code> for use
with generate_subgroup If print is <code>TRUE</code> code to produce the template is
also printed for copying, pasting and editing by the user. (This is the
default when run in an interactive session.)
</p>
<p><code>cutoff_stats</code> are the times used to calculate the statistics like average
hazard ratios and RMST, that are only calculated up to a certain point.
</p>
<p><code>hazard_subgroup_from_PH_effect_size</code> calculates the hazard rate in
the subgroup and the compliment of the subgroup in the treatment arm as
follows: First, the hazard ratio needed to archive the desired power under
proportional hazards is calculated by inverting Schönfeld's sample size
formula. Second the median survival times for both arms under this hazard
ratio and proportional hazards are calculated. Finally the hazard rate of
the treatment arm in the subgroup and its complement are set such that the
median survival time is the same as the one calculated under proportional
hazards.
</p>
<p>This is a heuristic and to some extent arbitrary approach to calculate
hazard ratios that correspond to reasonable and realistic scenarios.
</p>
<p>cen_rate_from_cen_prop_subgroup takes the proportion of
censored patients from the column <code>censoring_prop</code>. This column describes
the proportion of patients who are censored randomly before experiencing an
event, without regard to administrative censoring.
</p>


<h3>Value</h3>

<p>For generate_subgroup: A dataset with the columns t (time) and trt
(1=treatment, 0=control), evt (event, currently TRUE for all observations)
</p>
<p>For assumptions_subgroup: a design tibble with default values invisibly
</p>
<p>For true_summary_statistics_subgroup: the design data.frame
passed as argument with the additional columns
</p>
<p>For hazard_subgroup_from_PH_effect_size: the design data.frame passed as
argument with the additional columns hazard_trt and hazard_subgroup.
</p>
<p>for cen_rate_from_cen_prop_subgroup: design data.frame with the
additional column random_withdrawal
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>generate_subgroup()</code>: simulates a dataset with a mixture of cured
patients
</p>
</li>
<li> <p><code>assumptions_subgroup()</code>: generate default assumptions <code>data.frame</code>
</p>
</li>
<li> <p><code>true_summary_statistics_subgroup()</code>: calculate true summary statistics for subgroup
</p>
</li>
<li> <p><code>hazard_subgroup_from_PH_effect_size()</code>: Calculate hazards in treatement arm
</p>
</li>
<li> <p><code>cen_rate_from_cen_prop_subgroup()</code>: calculate censoring rate from censoring proportion
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>one_simulation &lt;- merge(
    assumptions_subgroup(),
    design_fixed_followup(),
    by=NULL
  ) |&gt;
  head(1) |&gt;
  generate_subgroup()
head(one_simulation)
tail(one_simulation)
Design &lt;- assumptions_subgroup()
Design
my_design &lt;- merge(
    assumptions_subgroup(),
    design_fixed_followup(),
    by=NULL
  )
my_design &lt;- true_summary_statistics_subgroup(my_design)
my_design

my_design &lt;- merge(
  assumptions_subgroup(),
  design_fixed_followup(),
  by=NULL
)

my_design$hazard_trt &lt;- NA
my_design$hazard_subgroup &lt;- NA
my_design$hr_subgroup_relative &lt;- 0.9
my_design$final_events &lt;- ceiling((my_design$n_ctrl + my_design$n_trt) * 0.75)
my_design &lt;- hazard_subgroup_from_PH_effect_size(my_design, target_power_ph=0.9)
my_design
design &lt;- expand.grid(
  hazard_ctrl=0.2,                   # hazard under control and before treatment effect
  hazard_trt=0.02,                   # hazard after onset of treatment effect
  hazard_subgroup=0.01,              # hazard in the subgroup in treatment
  prevalence = c(0.2, 0.5),           # subgroup prevalence
  censoring_prop=c(0.1, 0.25, 0.01), # 10%, 25%, 1% random censoring
  followup=100,                      # followup of 100 days
  n_trt=50,                          # 50 patients treatment
  n_ctrl=50                          # 50 patients control
)
cen_rate_from_cen_prop_subgroup(design)
</code></pre>

<hr>
<h2 id='labs_from_labels'>Add ggplot axis labels from labels attribute</h2><span id='topic+labs_from_labels'></span>

<h3>Description</h3>

<p>Add ggplot axis labels from labels attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labs_from_labels(gg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labs_from_labels_+3A_gg">gg</code></td>
<td>
<p>a ggplot object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("ggplot2")
test &lt;- mtcars
# add a label attribute
attr(test$cyl, "label") &lt;- "cylinders"

# plot witht the variable names as axis titles
gg1 &lt;- ggplot(test, aes(x=wt, y=cyl)) +
  geom_point()
gg1

# add labels where defined in the attribute
gg2 &lt;- ggplot(test, aes(x=wt, y=cyl)) +
  geom_point()

gg2 &lt;- labs_from_labels(gg2)
gg2

</code></pre>

<hr>
<h2 id='mixture_haz_fun'>Fast implementation of hazard, cumulative hazard, ... for mixtures of subpopulations</h2><span id='topic+mixture_haz_fun'></span><span id='topic+mixture_cumhaz_fun'></span><span id='topic+mixture_cdf_fun'></span><span id='topic+mixture_pdf_fun'></span><span id='topic+mixture_surv_fun'></span><span id='topic+mixture_quant_fun'></span><span id='topic+mixture_rng_fun'></span>

<h3>Description</h3>

<p>Fast implementation of hazard, cumulative hazard, ... for mixtures of subpopulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture_haz_fun(p, pdfs, survs)

mixture_cumhaz_fun(p, survs)

mixture_cdf_fun(p, cdfs)

mixture_pdf_fun(p, pdfs)

mixture_surv_fun(p, survs)

mixture_quant_fun(p, cdfs, quants)

mixture_rng_fun(p, rngs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixture_haz_fun_+3A_p">p</code></td>
<td>
<p>vector of probabilities of the mixture</p>
</td></tr>
<tr><td><code id="mixture_haz_fun_+3A_pdfs">pdfs</code></td>
<td>
<p>list of probability density functions of the mixture components</p>
</td></tr>
<tr><td><code id="mixture_haz_fun_+3A_survs">survs</code></td>
<td>
<p>list of survuval functions of the mixture components</p>
</td></tr>
<tr><td><code id="mixture_haz_fun_+3A_cdfs">cdfs</code></td>
<td>
<p>list of cumulative density functions of the mixture components</p>
</td></tr>
<tr><td><code id="mixture_haz_fun_+3A_quants">quants</code></td>
<td>
<p>list of quantile functions of the mixture components</p>
</td></tr>
<tr><td><code id="mixture_haz_fun_+3A_rngs">rngs</code></td>
<td>
<p>random number generating functions of the components</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the last time interval extends to +Inf
</p>
<p>mixture_quant_fun relies on numeric root finding and is therefore
not as fast as miniPCH::qpch_fun.
</p>
<p>mixture_rng samples the counts from the respective mixtures from
a multinomial distribution with parameter <code>p</code> and then samples from the
components and shuffles the result.
</p>


<h3>Value</h3>

<p>A function with one parameter, a vector of times/probabilities where the function should be evaluated.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mixture_haz_fun()</code>: hazard function of mixture
</p>
</li>
<li> <p><code>mixture_cumhaz_fun()</code>: cumulative hazard function of mixture
</p>
</li>
<li> <p><code>mixture_cdf_fun()</code>: cumulative density function of mixture
</p>
</li>
<li> <p><code>mixture_pdf_fun()</code>: probability density function of mixture
</p>
</li>
<li> <p><code>mixture_surv_fun()</code>: survival function of mixture
</p>
</li>
<li> <p><code>mixture_quant_fun()</code>: quantile function of mixture
</p>
</li>
<li> <p><code>mixture_rng_fun()</code>: quantile function of mixture
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>haz &lt;- mixture_haz_fun(
  p = c(0.3, 0.7),
  pdfs = list(
    miniPCH::dpch_fun(0, 0.1),
    miniPCH::dpch_fun(c(0,5), c(0.1, 0.12))
  ),
  survs = list(
    miniPCH::spch_fun(0, 0.1),
    miniPCH::spch_fun(c(0,5), c(0.1, 0.12))
  )
)
plot(haz(seq(0, 30, by=0.15)), ylim=c(0, 0.2), type="l")
abline(h=0)
cumhaz &lt;- mixture_cumhaz_fun(
  p = c(0.3, 0.7),
  survs = list(
    miniPCH::spch_fun(0, 0.1),
    miniPCH::spch_fun(c(0,5), c(0.1, 0.12))
  )
)
plot(cumhaz(seq(0, 30, by=0.15)), type="l")
cdf &lt;- mixture_cdf_fun(
  p = c(0.3, 0.7),
  cdfs = list(
    miniPCH::ppch_fun(0, 0.1),
    miniPCH::ppch_fun(c(0,5), c(0.1, 0.12))
  )
)
plot(cdf(seq(0, 30, by=0.15)), type="l")
pdf &lt;- mixture_pdf_fun(
  p = c(0.3, 0.7),
  pdfs = list(
    miniPCH::dpch_fun(0, 0.1),
    miniPCH::dpch_fun(c(0,5), c(0.1, 0.12))
  )
)
plot(pdf(seq(0, 30, by=0.15)), type="l")
surv &lt;- mixture_surv_fun(
  p = c(0.3, 0.7),
  survs = list(
    miniPCH::spch_fun(0, 0.1),
    miniPCH::spch_fun(c(0,5), c(0.1, 0.12))
  )
)
plot(surv(seq(0, 30, by=0.15)), type="l")

quant &lt;- mixture_quant_fun(
  p = c(0.3, 0.7),
  cdfs = list(
    miniPCH::ppch_fun(0, 0.1),
    miniPCH::ppch_fun(c(0,5), c(0.1, 0.12))
  ),
  quants = list(
    miniPCH::qpch_fun(0, 0.1),
    miniPCH::qpch_fun(c(0,5), c(0.1, 0.12))
  )
)

x &lt;- seq(0, 1, by=0.015)
plot(x, quant(x), type="l")
rng &lt;- mixture_rng_fun(
  p = c(0.3, 0.7),
  rngs = list(
    miniPCH::rpch_fun(0, 0.1, discrete = TRUE),
    miniPCH::rpch_fun(c(0,5), c(0.1, 0.12), discrete = TRUE)
  )
)
hist(rng(100))
</code></pre>

<hr>
<h2 id='progression_cdf_fun'>Fast implementation of cumulative density function, survival function, ... for scenarios with progression</h2><span id='topic+progression_cdf_fun'></span><span id='topic+progression_surv_fun'></span><span id='topic+progression_pdf_fun'></span><span id='topic+progression_haz_fun'></span><span id='topic+progression_quant_fun'></span>

<h3>Description</h3>

<p>Fast implementation of cumulative density function, survival function, ... for scenarios with progression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progression_cdf_fun(hazard_before, prog_rate, hazard_after)

progression_surv_fun(hazard_before, prog_rate, hazard_after)

progression_pdf_fun(hazard_before, prog_rate, hazard_after)

progression_haz_fun(hazard_before, prog_rate, hazard_after)

progression_quant_fun(hazard_before, prog_rate, hazard_after)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="progression_cdf_fun_+3A_hazard_before">hazard_before</code></td>
<td>
<p>hazard for death before progression</p>
</td></tr>
<tr><td><code id="progression_cdf_fun_+3A_prog_rate">prog_rate</code></td>
<td>
<p>hazard rate for progression</p>
</td></tr>
<tr><td><code id="progression_cdf_fun_+3A_hazard_after">hazard_after</code></td>
<td>
<p>hazard for death after progression</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations are done by viewing the disease process as a three state
(non-progressed disease, progressed disease, death) continuous time markov
chain. Calculations can then easily be done using the matrix exponential
function and Q-matrices.
</p>


<h3>Value</h3>

<p>A function with one parameter, a vector of times/probabilities where the function should be evaluated.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>progression_cdf_fun()</code>: cumulative density function for progression scenario
</p>
</li>
<li> <p><code>progression_surv_fun()</code>: survival function for progression scenario
</p>
</li>
<li> <p><code>progression_pdf_fun()</code>: probability density function for progression scenario
</p>
</li>
<li> <p><code>progression_haz_fun()</code>: hazard function for progression scenario
</p>
</li>
<li> <p><code>progression_quant_fun()</code>: quantile function for progression scenario
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>cdf &lt;- progression_cdf_fun(
  hazard_before = m2r(48),
  prog_rate = m2r(18),
  hazard_after = m2r(6)
)
t &lt;- 0:1000
plot(t, cdf(t), type="l")
surv &lt;- progression_surv_fun(
  hazard_before = m2r(48),
  prog_rate = m2r(18),
  hazard_after = m2r(6)
)
t &lt;- 0:1000
plot(t, surv(t), type="l")
pdf &lt;- progression_pdf_fun(
  hazard_before = m2r(48),
  prog_rate = m2r(18),
  hazard_after = m2r(6)
)
t &lt;- 0:1000
plot(t, pdf(t), type="l")
haz &lt;- progression_haz_fun(
  hazard_before = m2r(48),
  prog_rate = m2r(18),
  hazard_after = m2r(6)
)
t &lt;- 0:1000
plot(t, haz(t), type="l")
quant &lt;- progression_quant_fun(
  hazard_before = m2r(48),
  prog_rate = m2r(18),
  hazard_after = m2r(6)
)
p &lt;- seq(0,0.99, by=.01)
plot(p, quant(p), type="l")
</code></pre>

<hr>
<h2 id='r2m'>Functions to Convert Between Days and Months and Medians and Rates</h2><span id='topic+r2m'></span><span id='topic+m2r'></span><span id='topic+m2d'></span><span id='topic+d2m'></span>

<h3>Description</h3>

<p>Some functions to convert between days and months and rates and medians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2m(lambda)

m2r(med)

m2d(mon)

d2m(day)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r2m_+3A_lambda">lambda</code></td>
<td>
<p>hazard rate</p>
</td></tr>
<tr><td><code id="r2m_+3A_med">med</code></td>
<td>
<p>median in months</p>
</td></tr>
<tr><td><code id="r2m_+3A_mon">mon</code></td>
<td>
<p>time in months</p>
</td></tr>
<tr><td><code id="r2m_+3A_day">day</code></td>
<td>
<p>time in days</p>
</td></tr>
</table>


<h3>Value</h3>

<p>median survival time in months (<code>r2m</code>)
</p>
<p>hazard rate per day (<code>m2r</code>)
</p>
<p>time in days (<code>m2d</code>)
</p>
<p>time in months (<code>d2m</code>)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>r2m()</code>: daily rate to median in months
</p>
</li>
<li> <p><code>m2r()</code>: median to months to daily rate
</p>
</li>
<li> <p><code>m2d()</code>: months to days
</p>
</li>
<li> <p><code>d2m()</code>: days to months
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>r2m(0.002)
m2r(12)
m2d(1)
d2m(31)
</code></pre>

<hr>
<h2 id='random_censoring_exp'>Apply Random Exponentially Distributed Censoring</h2><span id='topic+random_censoring_exp'></span>

<h3>Description</h3>

<p>Apply Random Exponentially Distributed Censoring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_censoring_exp(dat, rate, discrete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_censoring_exp_+3A_dat">dat</code></td>
<td>
<p>the dataset to apply the random censoring to</p>
</td></tr>
<tr><td><code id="random_censoring_exp_+3A_rate">rate</code></td>
<td>
<p>time of end of enrollment</p>
</td></tr>
<tr><td><code id="random_censoring_exp_+3A_discrete">discrete</code></td>
<td>
<p>should the censoring times be rounded to whole days?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Function with one argument <code>dat</code> that modifies a dataset generated
by the generate functions by censoring the times and setting the event
indicator to <code>FALSE</code> for censored observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
one_simulation &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by=NULL
) |&gt;
  head(1) |&gt;
  generate_delayed_effect()

# apply censoring to dataset
censored_sim &lt;- random_censoring_exp(one_simulation, 0.01)

# plot
# uncensored (blue) observations are the same for original and modified
# dataset
# censored (red) observations are smaller than the uncensored ones
plot(
  one_simulation$t,
  censored_sim$t,
  col=ifelse(censored_sim$evt, "blue", "red"),
  xlab = "uncensored times",
  ylab = "censored times"
)
abline(0,1)
</code></pre>

<hr>
<h2 id='recruitment_uniform'>Add recruitment time to Dataset</h2><span id='topic+recruitment_uniform'></span><span id='topic+admin_censoring_time'></span><span id='topic+admin_censoring_events'></span>

<h3>Description</h3>

<p>Add recruitment time to Dataset
</p>
<p>Apply Administrative Censoring After Fixed Time
</p>
<p>Apply Administrative Censoring After Fixed Number of Events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recruitment_uniform(
  dat,
  recruitment_until,
  recruitment_from = 0,
  discrete = TRUE
)

admin_censoring_time(dat, followup, keep_non_recruited = FALSE)

admin_censoring_events(
  dat,
  events,
  keep_non_recruited = FALSE,
  on_incomplete = "ignore"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recruitment_uniform_+3A_dat">dat</code></td>
<td>
<p>a simulated dataset</p>
</td></tr>
<tr><td><code id="recruitment_uniform_+3A_recruitment_until">recruitment_until</code></td>
<td>
<p>time of end of recruitment</p>
</td></tr>
<tr><td><code id="recruitment_uniform_+3A_recruitment_from">recruitment_from</code></td>
<td>
<p>time of start of recruitment (defaults to 0)</p>
</td></tr>
<tr><td><code id="recruitment_uniform_+3A_discrete">discrete</code></td>
<td>
<p>should the recruitment time be rounded to full days?</p>
</td></tr>
<tr><td><code id="recruitment_uniform_+3A_followup">followup</code></td>
<td>
<p>followup time</p>
</td></tr>
<tr><td><code id="recruitment_uniform_+3A_keep_non_recruited">keep_non_recruited</code></td>
<td>
<p>should patients recruited after end of study be kept</p>
</td></tr>
<tr><td><code id="recruitment_uniform_+3A_events">events</code></td>
<td>
<p>number of events after which the dataset is analyzed</p>
</td></tr>
<tr><td><code id="recruitment_uniform_+3A_on_incomplete">on_incomplete</code></td>
<td>
<p>what to do if there are fewer events than planned &quot;ignore&quot;,&quot;warn&quot;,&quot;stop&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dataset hast to include a column <code>rec_time</code> containing the recruitment
time as well as the columns with the event times <code>t</code> and a column with the
event indicator <code>evt</code>.
</p>
<p>Times and event indicaotrs for patients recruited after followup are set to
<code>NA</code>.
</p>
<p>The Dataset hast to include a column <code>rec_time</code> containing the recruitment
time as well as the columns with the event times <code>t</code> and a column with the
event indicator <code>evt</code>.
</p>
<p>Times and event indicaotrs for patients recruited after followup are set to
<code>NA</code>.
</p>
<p>If there are less events than planned for study end <code>on_incomplete</code> defines
what should be done. &quot;ignore&quot; simply returns the dataset with the maximum of
the observed times as followup. &quot;warn&quot; does the same but gives a warning.
&quot;stop&quot; stopps with an error.
</p>


<h3>Value</h3>

<p>Returns the dataset with added recruitment times.
</p>
<p>Returns the dataset with administrative censoring after <code>follwup</code>, adds the
attribute <code>followup</code> with the followup time to the dataset.
</p>
<p>Returns the dataset with administrative censoring after <code>events</code> events, adds
the attribute <code>followup</code> with the followup time to the dataset.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>recruitment_uniform()</code>: add recruitment time
</p>
</li>
<li> <p><code>admin_censoring_time()</code>: apply administrative censoring after fixed time
</p>
</li>
<li> <p><code>admin_censoring_events()</code>: apply administrative censoring after fixed number of events
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(t=c(0, 1, 2), trt=c(FALSE, FALSE, TRUE))
recruitment_uniform(dat, 7, 0)
dat &lt;- data.frame(
  t = 1:10,
  rec_time = rep(1:5, each=2),
  trt = rep(c(TRUE, FALSE), times=5),
  evt = rep(TRUE, times=10)
)
dat

admin_censoring_time(dat, 4)
admin_censoring_time(dat, 4, keep_non_recruited = TRUE)

dat_censored &lt;- admin_censoring_time(dat, 5)
attr(dat_censored, "followup")
dat &lt;- data.frame(
  t = 1:10,
  rec_time = rep(2*(1:5), each=2),
  trt = rep(c(TRUE, FALSE), times=5),
  evt = rep(TRUE, times=10)
)
dat

admin_censoring_events(dat, 4)
admin_censoring_events(dat, 4, keep_non_recruited = TRUE)

dat_censored &lt;- admin_censoring_events(dat, 4)
attr(dat_censored, "followup")
</code></pre>

<hr>
<h2 id='rename_results_column'>Rename Columns in Simulation Results and Update Attributes</h2><span id='topic+rename_results_column'></span><span id='topic+rename_results_column_pattern'></span>

<h3>Description</h3>

<p>Rename Columns in Simulation Results and Update Attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_results_column(results, rename)

rename_results_column_pattern(results, pattern, replacement)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_results_column_+3A_results">results</code></td>
<td>
<p><code>SimDesign</code> object</p>
</td></tr>
<tr><td><code id="rename_results_column_+3A_rename">rename</code></td>
<td>
<p>named vector of new names</p>
</td></tr>
<tr><td><code id="rename_results_column_+3A_pattern">pattern</code></td>
<td>
<p>regexp pattern as understood by <code>stringr::str_replace_all</code></p>
</td></tr>
<tr><td><code id="rename_results_column_+3A_replacement">replacement</code></td>
<td>
<p>replacement as understood by <code>stringr::str_replace_all</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SimDesign</code> object with updated column names
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rename_results_column()</code>: Rename Columns in Simulation Results
</p>
</li>
<li> <p><code>rename_results_column_pattern()</code>: Rename Columns in Simulation Results by Pattern
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
condition &lt;- merge(
assumptions_delayed_effect(),
design_fixed_followup(),
by=NULL
) |&gt;
  tail(4) |&gt;
  true_summary_statistics_delayed_effect(cutoff_stats = 15)

sim_results &lt;- runSimulation(
  design=condition,
  replications=10,
  generate=generate_delayed_effect,
  analyse=list(
    logrank  = analyse_logrank(alternative = "one.sided"),
    mwlrt = analyse_modelstly_weighted(t_star = m2d(24))
  ),
  summarise = create_summarise_function(
    logrank = summarise_test(0.025),
    mwlrt = summarise_test(0.025)
  )
)

names(sim_results)
attr(sim_results, "design_names")

sim_results &lt;- sim_results |&gt;
  rename_results_column(c("delay"="onset"))

names(sim_results)
attr(sim_results, "design_names")


  condition &lt;- merge(
    assumptions_delayed_effect(),
    design_fixed_followup(),
    by=NULL
  ) |&gt;
    tail(4) |&gt;
    true_summary_statistics_delayed_effect(cutoff_stats = 15)

  sim_results &lt;- runSimulation(
    design=condition,
    replications=10,
    generate=generate_delayed_effect,
    analyse=list(
      logrank  = analyse_logrank(alternative = "one.sided"),
      mwlrt = analyse_modelstly_weighted(t_star = m2d(24))
    ),
    summarise = create_summarise_function(
      logrank = summarise_test(0.025),
      mwlrt = summarise_test(0.025)
    )
  )

  names(sim_results)
  attr(sim_results, "design_names")

  sim_results &lt;- sim_results |&gt;
    rename_results_column_pattern(pattern = "_0.025", replacement = "")

  names(sim_results)
  attr(sim_results, "design_names")

</code></pre>

<hr>
<h2 id='results_pivot_longer'>Functions for Plotting and Reporting Results</h2><span id='topic+results_pivot_longer'></span><span id='topic+combined_plot'></span>

<h3>Description</h3>

<p>Functions for Plotting and Reporting Results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>results_pivot_longer(data, exclude_from_methods = c("descriptive"))

combined_plot(
  data,
  methods,
  xvars,
  yvar,
  facet_x_vars = c(),
  facet_y_vars = c(),
  split_var = 1,
  heights_plots = c(3, 1),
  scale_stairs = NULL,
  grid_level = 2,
  scales = "fixed",
  hlines = numeric(0),
  use_colours = NULL,
  use_shapes = NULL,
  expand_x_axis = c(0.05, 0, 0.05, 0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="results_pivot_longer_+3A_data">data</code></td>
<td>
<p>for results_pivot_longer: simulation result as retured by SimDesign, for combined_plot: simulation results in long format, as returned by <code>results_pivot_longer</code>.</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_exclude_from_methods">exclude_from_methods</code></td>
<td>
<p>&quot;methods&quot; that should not be pivoted into long format</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_methods">methods</code></td>
<td>
<p>methods to include in the plot</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_xvars">xvars</code></td>
<td>
<p>orderd vector of variable names to display on the x axis</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_yvar">yvar</code></td>
<td>
<p>variable name of the variable to be displayed on the y axis (metric)</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_facet_x_vars">facet_x_vars</code></td>
<td>
<p>vector of variable names to create columns of facets</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_facet_y_vars">facet_y_vars</code></td>
<td>
<p>vector of variable names to create rows of facets</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_split_var">split_var</code></td>
<td>
<p>where should the lines be split, see details</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_heights_plots">heights_plots</code></td>
<td>
<p>relative heights of the main plot and the stairs on the bottom</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_scale_stairs">scale_stairs</code></td>
<td>
<p>this argument is deprecated and will be ignored</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_grid_level">grid_level</code></td>
<td>
<p>depth of loops for which the grid-lines are drawn</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_scales">scales</code></td>
<td>
<p>passed on to facet_grid</p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_hlines">hlines</code></td>
<td>
<p>position of horizontal lines, passed as <code>yintercept</code> to
<code>geom_hline</code></p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_use_colours">use_colours</code></td>
<td>
<p>optional named vector of colours used in <code>scale_colour_manual</code></p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_use_shapes">use_shapes</code></td>
<td>
<p>optional named vector of shapes used in <code>scale_shape_manual</code></p>
</td></tr>
<tr><td><code id="results_pivot_longer_+3A_expand_x_axis">expand_x_axis</code></td>
<td>
<p>axis expansion factor, passed to <code>scale_x_continuous</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>exclude_from_methods</code> descriptive statistics or results of
reference methods can be kept as own columns and used like the columns of
the simulation parameters.
</p>
<p><code>use_colours</code> and <code>use_shapes</code> both use the <code>method</code> variable in their respective aesthetics.
</p>
<p><code>split_var</code> break the lines after the 1st, 2nd, ... variable in <code>xvars</code>. Use 0 for one continuous line per method.
</p>


<h3>Value</h3>

<p>dataset in long format with one row per method and scenario and one
column per metric
</p>
<p>a ggplot/patchwork object containing the plots
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>results_pivot_longer()</code>: pivot simulation results into long format
</p>
</li>
<li> <p><code>combined_plot()</code>: Nested Loop Plot with optional Facets
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
data("combination_tests_delayed")

combination_tests_delayed |&gt;
  results_pivot_longer() |&gt;
  head()


library("ggplot2")
library("patchwork")
data("combination_tests_delayed")

results_long &lt;- results_pivot_longer(combination_tests_delayed)

# plot the rejection rate of two methods
combined_plot(
  results_long,
  c("logrank", "mwlrt", "maxcombo"),
  c("hr", "n_pat_design", "delay", "hazard_ctrl", "recruitment"),
  "rejection_0.025",
  grid_level=2
)

# use custom colour and shape scales
# this can be used to group methods by shape or colour
# this is also helpful if methods should have the same aesthetics across plots
my_colours &lt;- c(
  logrank="black",
  mwlrt="blue",
  maxcombo="green"
)

my_shapes &lt;- c(
  logrank=1,
  mwlrt=2,
  maxcombo=2
)

combined_plot(
  results_long,
  c("logrank", "mwlrt", "maxcombo"),
  c("hr", "n_pat_design", "delay", "hazard_ctrl", "recruitment"),
  "rejection_0.025",
  grid_level=2,
  use_colours = my_colours,
  use_shapes = my_shapes
)

# if one has a dataset of metadata with categories of methods
# one could uses those two definitions
# colours for methods, same shapes for methods of same category
metadata &lt;- data.frame(
  method = c("logrank", "mwlrt", "maxcombo"),
  method_name = c("logrank test", "modestly weighed logrank test", "maxcombo test"),
  category = c("logrank test", "combination test", "combination test")
)

my_colours &lt;- ggplot2::scale_colour_discrete()$palette(n=nrow(metadata)) |&gt;
  sample() |&gt;
  setNames(metadata$method)

my_shapes &lt;- metadata$category |&gt;
  as.factor() |&gt;
  as.integer() |&gt;
  setNames(metadata$method)

combined_plot(
  results_long,
  c("logrank", "mwlrt", "maxcombo"),
  c("hr", "n_pat_design", "delay", "hazard_ctrl", "recruitment"),
  "rejection_0.025",
  grid_level=2,
  use_colours = my_colours,
  use_shapes = my_shapes
)

</code></pre>

<hr>
<h2 id='shhr_gg'>Plot of survival, hazard and hazard ratio of two groups as a function of time using ggplot and patchwork</h2><span id='topic+shhr_gg'></span>

<h3>Description</h3>

<p>Plot of survival, hazard and hazard ratio of two groups as a function of time using ggplot and patchwork
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shhr_gg(
  A,
  B,
  main = NULL,
  sub = NULL,
  group_names = c("control", "treatment"),
  lab_time = "Days",
  lab_group = "Group",
  trafo_time = identity,
  colours = palette()[c(1, 3)],
  linetypes = c(1, 3),
  linewidths = c(1.3, 1.3),
  as_list = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shhr_gg_+3A_a">A</code></td>
<td>
<p>mixpch object for group 1 (reference)</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_b">B</code></td>
<td>
<p>mixpch object for group 2</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_main">main</code></td>
<td>
<p>Title for the overall plot</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_sub">sub</code></td>
<td>
<p>Subtitle for the overall plot</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_group_names">group_names</code></td>
<td>
<p>Group Names</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_lab_time">lab_time</code></td>
<td>
<p>Title for the time axis</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_lab_group">lab_group</code></td>
<td>
<p>Title group legend</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_trafo_time">trafo_time</code></td>
<td>
<p>Function to transform time</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_colours">colours</code></td>
<td>
<p>vector of two colours</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_linetypes">linetypes</code></td>
<td>
<p>vector of two linetypes</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_linewidths">linewidths</code></td>
<td>
<p>vector of two linewidths</p>
</td></tr>
<tr><td><code id="shhr_gg_+3A_as_list">as_list</code></td>
<td>
<p>return a list of ggplot objects instead of a patchwork object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>patchwork</code> object as defined in the patchwork package or a list of
ggplot objects if <code>as_list=TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
library(patchwork)
library(nph)
B &lt;- pchaz(c(0, 10, 100), c(0.1, 0.05))
A &lt;- pchaz(c(0, 100), c(0.1))
shhr_gg(A, B)
shhr_gg(A, B, lab_time="Months", trafo_time=d2m)

</code></pre>

<hr>
<h2 id='summarise_estimator'>Generic Summarise function for esitmators</h2><span id='topic+summarise_estimator'></span>

<h3>Description</h3>

<p>Generic Summarise function for esitmators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_estimator(
  est,
  real,
  lower = NULL,
  upper = NULL,
  null = NULL,
  est_sd = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_estimator_+3A_est">est</code></td>
<td>
<p>estimator, expression evaluated in results</p>
</td></tr>
<tr><td><code id="summarise_estimator_+3A_real">real</code></td>
<td>
<p>real summary statistic, expression evaluated in condition</p>
</td></tr>
<tr><td><code id="summarise_estimator_+3A_lower">lower</code></td>
<td>
<p>lower CI, expression evaluated in results</p>
</td></tr>
<tr><td><code id="summarise_estimator_+3A_upper">upper</code></td>
<td>
<p>upper CI, expression evaluated in results</p>
</td></tr>
<tr><td><code id="summarise_estimator_+3A_null">null</code></td>
<td>
<p>parameter value under the null hypothesis</p>
</td></tr>
<tr><td><code id="summarise_estimator_+3A_est_sd">est_sd</code></td>
<td>
<p>standard deviation estimated by the method, evaluated in results</p>
</td></tr>
<tr><td><code id="summarise_estimator_+3A_name">name</code></td>
<td>
<p>name for the summarise function,
appended to the name of the analysis method in the final results</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different parameters are evaluated in different envionments, <code>est</code>,
<code>lower</code>, <code>upper</code>, <code>est_sd</code> refer to output of the method and are evaluated in
the results dataset. <code>real</code> refers to a real value of a summary statistic in
this scenario and is therefore evaluated in the condition dataset. <code>null</code> and
<code>name</code> are constants and directly evaluated when the function is defined.
The argument <code>null</code>, the parameter value under the null hypothesis is used to
output the rejection rate based on the confidence intervall. Which is output
in the column <code>null_cover</code>
</p>


<h3>Value</h3>

<p>A function that can be used in Summarise that returns a data frame with
summary statistics of the performance measures in the columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate the design matrix and append the true summary statistics
condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by=NULL
) |&gt;
  tail(4) |&gt;
  head(1) |&gt;
  true_summary_statistics_delayed_effect(cutoff_stats = 15)

# create some summarise functions
summarise_all &lt;- create_summarise_function(
  coxph=summarise_estimator(hr, gAHR_15, hr_lower, hr_upper, name="gAHR"),
  coxph=summarise_estimator(hr, hazard_trt/hazard_ctrl, hr_lower, hr_upper, name="HR"),
  coxph=summarise_estimator(hr, NA_real_, name="NA")
)

# runs simulations
sim_results &lt;- runSimulation(
  design=condition,
  replications=10,
  generate=generate_delayed_effect,
  analyse=list(
    coxph=analyse_coxph()
  ),
  summarise = summarise_all
)

# mse is missing for the summarise function in which the real value was NA
sim_results[, names(sim_results) |&gt; grepl(pattern="\\.mse$")]
# but the standard deviation can be estimated in all cases
sim_results[, names(sim_results) |&gt; grepl(pattern="\\.sd_est$")]

</code></pre>

<hr>
<h2 id='summarise_test'>Generic summarise function for tests</h2><span id='topic+summarise_test'></span>

<h3>Description</h3>

<p>Generic summarise function for tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_test(alpha, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_test_+3A_alpha">alpha</code></td>
<td>
<p>the significance level(s)</p>
</td></tr>
<tr><td><code id="summarise_test_+3A_name">name</code></td>
<td>
<p>name for the summarise function,
appended to the name of the analysis method in the final results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that can be used in Summarise that returns a data frame with the columns
</p>

<ul>
<li><p> rejection_X
</p>
</li>
<li><p> rejection_Y
</p>
</li>
<li><p> ...
</p>
</li></ul>

<p>Where X, Y, ... are the alpha levels given in the argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by=NULL
) |&gt;
  tail(4) |&gt;
  head(1)

summarise_all &lt;- create_summarise_function(
  logrank=summarise_test(alpha=c(0.5, 0.9, 0.95, 0.99))
)

# runs simulations
sim_results &lt;- runSimulation(
  design=condition,
  replications=100,
  generate=generate_delayed_effect,
  analyse=list(
    logrank=analyse_logrank()
  ),
  summarise = summarise_all
)

sim_results[, grepl("rejection", names(sim_results))]

</code></pre>

<hr>
<h2 id='upsert_merge'>Merge results from additional or updated simulations</h2><span id='topic+upsert_merge'></span><span id='topic+merge_additional_results'></span>

<h3>Description</h3>

<p>Merge results from additional or updated simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upsert_merge(x, y, by)

merge_additional_results(
  old,
  new,
  design_names = NULL,
  descriptive_regex = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upsert_merge_+3A_x">x</code></td>
<td>
<p>left data.frame</p>
</td></tr>
<tr><td><code id="upsert_merge_+3A_y">y</code></td>
<td>
<p>right data.frame</p>
</td></tr>
<tr><td><code id="upsert_merge_+3A_by">by</code></td>
<td>
<p>columns to match by</p>
</td></tr>
<tr><td><code id="upsert_merge_+3A_old">old</code></td>
<td>
<p>old results</p>
</td></tr>
<tr><td><code id="upsert_merge_+3A_new">new</code></td>
<td>
<p>new/additional results</p>
</td></tr>
<tr><td><code id="upsert_merge_+3A_design_names">design_names</code></td>
<td>
<p>names of the paramterst</p>
</td></tr>
<tr><td><code id="upsert_merge_+3A_descriptive_regex">descriptive_regex</code></td>
<td>
<p>regular expression for columns of descriptive statistics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>updates columns in x with values from matched rows in y and add
joins columns from y not present in x. Calls <code>rows_upsert</code> and then
<code>full_join</code>.
</p>
<p>if <code>design_names</code> is omitted its value is taken from the
<code>design_names</code> attribute of the simulation results.
</p>
<p>If <code>descriptive_regex</code> is given, columns matching the regular expression in
both datasets are compared, a warning is given, if the values of those
columns do not match. This is intended to compare descriptive statistics or
results of unchanged analysis methods to ensure, that both results stem
from an exact replication of the simulation results.
</p>


<h3>Value</h3>

<p>a data.frame
</p>
<p>a data.frame of the merged simulation results
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>upsert_merge()</code>: Update or add Rows and Columns
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- data.frame(x=5:2, y=5:2, a=5:2)
b &lt;- data.frame(x=1:4, y=1:4+10, b=1:4*10)
upsert_merge(a, b, by="x")

condition &lt;- merge(
  assumptions_delayed_effect(),
  design_fixed_followup(),
  by=NULL
) |&gt;
  tail(4) |&gt;
  true_summary_statistics_delayed_effect(cutoff_stats = 15)

condition_1 &lt;- condition[1:2, ]
condition_2 &lt;- condition[3:4, ]

# runs simulations
sim_results_1 &lt;- runSimulation(
  design=condition_1,
  replications=100,
  generate=generate_delayed_effect,
  analyse=list(
    logrank  = analyse_logrank(alternative = "one.sided"),
    maxcombo = analyse_logrank(alternative = "one.sided")
  ),
  summarise = create_summarise_function(
    logrank = summarise_test(0.025),
    maxcombo = summarise_test(0.025)
  )
)

sim_results_2 &lt;- runSimulation(
  design=condition_2,
  replications=100,
  generate=generate_delayed_effect,
  analyse=list(
    logrank  = analyse_logrank(alternative = "one.sided"),
    maxcombo = analyse_logrank(alternative = "one.sided")
  ),
  summarise = create_summarise_function(
    logrank = summarise_test(0.025),
    maxcombo = summarise_test(0.025)
  )
)

sim_results_3 &lt;- runSimulation(
  design=condition,
  replications=100,
  generate=generate_delayed_effect,
  analyse=list(
    mwlrt = analyse_modelstly_weighted(t_star = m2d(24))
  ),
  summarise = create_summarise_function(
    mwlrt = summarise_test(0.025)
  )
)

all_results &lt;- sim_results_1 |&gt;
  merge_additional_results(sim_results_2) |&gt;
  merge_additional_results(sim_results_3)

all_results |&gt;
  subset(select=c(delay, logrank.rejection_0.025, maxcombo.rejection_0.025, mwlrt.rejection_0.025))


</code></pre>

<hr>
<h2 id='wrap_all_in_trycatch'>Wrappers around Analyse Functions</h2><span id='topic+wrap_all_in_trycatch'></span><span id='topic+wrap_all_in_preserve_seed'></span>

<h3>Description</h3>

<p>Wrappers around Analyse Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_all_in_trycatch(
  list_of_functions,
  error = function(e) {
     warning(e$message)
     NA
 }
)

wrap_all_in_preserve_seed(list_of_functions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap_all_in_trycatch_+3A_list_of_functions">list_of_functions</code></td>
<td>
<p>the list of functions to be wrapped</p>
</td></tr>
<tr><td><code id="wrap_all_in_trycatch_+3A_error">error</code></td>
<td>
<p>the error function in the tryCatch call</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SimDesign redraws data if one analysis function fails. This is not
only highly inefficient for large studies, but failure of a method is
informative and might be of interest. Moreover redrawing of data might
introduce bias if the failure of the method is not independent of the
parameter value, which would be a strong assumption.
</p>
<p>To avoid redrawing data, we can catch all errors the analysis methods could
throw and return <code>NA</code> instead.
</p>
<p>This is handled well by the summarise functions generated with
<code>create_summarise_function</code> other summarise functions might throw errors
when trying to <code>rbind</code> a data.frame to a scalar <code>NA</code> value. In this case
add another <code>error</code> argument. For example <code style="white-space: pre;">&#8288;\(e){NULL}&#8288;</code> could work in some
cases, in other cases you'll have to give a function that returns a
data.frame with the same columns as the analyse functions and only NA
values.
</p>
<p>Analysis functions might use random numbers. If simulations should
be replicated this can interfere with the RNG state of other analysis
functions. To avoid this you can wrap all analysis function in a
<code>withr::with_preserve_seed</code> call, so that the RNG state is reset after each
analysis function is called. This way adding, removing or changing one
analysis function has no effect on the other analysis functions, even if
the analysis functions use random numbers.
</p>


<h3>Value</h3>

<p>a list of functions
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>wrap_all_in_trycatch()</code>: Wrap all functions in a list in tryCatch calls
</p>
</li>
<li> <p><code>wrap_all_in_preserve_seed()</code>: wrap all functions in <code>withr::with_preserve_seed</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>funs1 &lt;- list(\(){stop("test")}, \(){1})
funs2 &lt;- wrap_all_in_trycatch(funs1)
try(lapply(funs1, \(f){f()}))
try(lapply(funs2, \(f){f()}))

funs1 &lt;- list(\(){rnorm(1)})
funs2 &lt;- list(\(){runif(1)}, \(){rnorm(1)})
funs3 &lt;- funs2 |&gt; wrap_all_in_preserve_seed()
set.seed(1)
lapply(funs1, \(f){f()})
set.seed(1)
lapply(funs2, \(f){f()})
set.seed(1)
lapply(funs3, \(f){f()})
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
