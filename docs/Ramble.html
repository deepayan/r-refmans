<!DOCTYPE html><html><head><title>Help for package Ramble</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Ramble}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%alt%'><p><code>%alt%</code> is the infix notation for the <code>alt</code> function.</p></a></li>
<li><a href='#%then%'><p><code>%then%</code> is the infix operator for the then combinator.</p></a></li>
<li><a href='#%thentree%'><p><code>%thentree%</code> is the infix operator for the then combinator, and it is</p>
the preferred way to use the <code>thentree</code> operator.</a></li>
<li><a href='#%using%'><p><code>%using%</code> is the infix operator for using</p></a></li>
<li><a href='#Alpha'><p>Alpha checks for single alphabet character</p></a></li>
<li><a href='#AlphaNum'><p>AlphaNum checks for a single alphanumeric character</p></a></li>
<li><a href='#alt'><p><code>alt</code> combinator is similar to alternation in BNF. the parser</p>
<code>(alt(p1, p2))</code> recognises anything that <code>p1</code> or <code>p2</code> would.
The approach taken in this parser follows (Fairbairn86), in which either is
interpretted in a sequential (or exclusive) manner, returning the result of
the first parser to succeed, and failure if neither does.</a></li>
<li><a href='#Digit'><p>Digit checks for single digit</p></a></li>
<li><a href='#ident'><p><code>ident</code> is a parser which matches zero or more alphanumeric</p>
characters.</a></li>
<li><a href='#identifier'><p><code>identifier</code> creates an identifier</p></a></li>
<li><a href='#item'><p><code>item</code> is a parser that consumes the first character of the string and</p>
returns the rest. If it cannot consume a single character from the string, it
will emit the empty list, indicating the parser has failed.</a></li>
<li><a href='#literal'><p><code>literal</code> is a parser for single symbols. It will attempt to match the</p>
single symbol with the first character in the string.</a></li>
<li><a href='#Lower'><p>Lower checks for single lower case character</p></a></li>
<li><a href='#many'><p><code>many</code> matches 0 or more of pattern <code>p</code>. In BNF notation,</p>
repetition occurs often enough to merit its own abbreviation. When zero or
more repetitions of a phrase <code>p</code> are admissible, we simply write
<code>p*</code>. The <code>many</code> combinator corresponds directly to this operator,
and is defined in much the same way.</a></li>
<li><a href='#maybe'><p><code>maybe</code> matches 0 or 1 of pattern <code>p</code>.  In EBNF notation, this</p>
corresponds to a question mark ('?').</a></li>
<li><a href='#nat'><p><code>nat</code> is a parser which matches one or more numeric characters.</p></a></li>
<li><a href='#natural'><p><code>natural</code> creates a token parser for natural numbers</p></a></li>
<li><a href='#Ramble'><p>Ramble is a parser generator using combinatory parsers.</p></a></li>
<li><a href='#satisfy'><p><code>satisfy</code> is a function which allows us to make parsers that recognise single symbols.</p></a></li>
<li><a href='#some'><p><code>some</code> matches 1 or more of pattern <code>p</code>. in BNF notation, repetition occurs often enough to merit its own abbreviation. When zero or</p>
more repetitions of a phrase <code>p</code> are admissible, we simply write
<code>p+</code>. The <code>some</code> combinator corresponds directly to this operator,
and is defined in much the same way.</a></li>
<li><a href='#space'><p><code>space</code> matches zero or more space characters.</p></a></li>
<li><a href='#SpaceCheck'><p>SpaceCheck checks for a single space character</p></a></li>
<li><a href='#String'><p><code>String</code> is a combinator which allows us to build parsers which</p>
recognise strings of symbols, rather than just single symbols</a></li>
<li><a href='#succeed'><p><code>succeed</code> is based on the empty string symbol in the BNF notation The</p>
<code>succeed</code> parser always succeeds, without actually consuming any input
string. Since the outcome of succeed does not depend on its input, its result
value must be pre-detemined, so it is included as an extra parameter.</a></li>
<li><a href='#symbol'><p><code>symbol</code> creates a token for a symbol</p></a></li>
<li><a href='#then'><p><code>then</code> combinator corresponds to sequencing in BNF. The parser</p>
<code>(then(p1, p2))</code> recognises anything that <code>p1</code> and <code>p2</code> would
if placed in succession.</a></li>
<li><a href='#thentree'><p><code>thentree</code> keeps the full tree representation of the results of parsing.</p>
Otherwise, it is identical to <code>then</code>.</a></li>
<li><a href='#token'><p><code>token</code> is a new primitive that ignores any space before and after</p>
applying a parser to a token.</a></li>
<li><a href='#Unlist'><p>Unlist is the same as unlist, but doesn't recurse all the way to</p>
preserve the type. This function is not well optimised.</a></li>
<li><a href='#Upper'><p>Upper checks for a single upper case character</p></a></li>
<li><a href='#using'><p><code>using</code> combinator allows us to manipulate results from a parser, for</p>
example building a parse tree. The parser <code>(p %using% f)</code> has the same
behaviour as the parser <code>p</code>, except that the function <code>f</code> is
applied to each of its result values.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parser Combinator for R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-10-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Chapman Siu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chapman Siu &lt;chpmn.siu@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Parser generator for R using combinatory parsers. It
    is inspired by combinatory parsers developed in Haskell.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/chappers/Ramble">https://github.com/chappers/Ramble</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-10-28 23:40:08 UTC; chapm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-10-29 10:48:13</td>
</tr>
</table>
<hr>
<h2 id='+25alt+25'><code>%alt%</code> is the infix notation for the <code>alt</code> function.</h2><span id='topic++25alt+25'></span>

<h3>Description</h3>

<p><code>%alt%</code> is the infix notation for the <code>alt</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p1 %alt% p2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25alt+2B25_+3A_p1">p1</code></td>
<td>
<p>the first parser</p>
</td></tr>
<tr><td><code id="+2B25alt+2B25_+3A_p2">p2</code></td>
<td>
<p>the second parser</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the first parser if it suceeds otherwise the second parser
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(item() %alt% succeed("2")) ("abcdef")
</code></pre>

<hr>
<h2 id='+25then+25'><code>%then%</code> is the infix operator for the then combinator.</h2><span id='topic++25then+25'></span>

<h3>Description</h3>

<p><code>%then%</code> is the infix operator for the then combinator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p1 %then% p2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25then+2B25_+3A_p1">p1</code></td>
<td>
<p>the first parser</p>
</td></tr>
<tr><td><code id="+2B25then+2B25_+3A_p2">p2</code></td>
<td>
<p>the second parser</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recognises anything that <code>p1</code> and <code>p2</code> would if placed in succession.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(item() %then% succeed("123")) ("abc")
</code></pre>

<hr>
<h2 id='+25thentree+25'><code>%thentree%</code> is the infix operator for the then combinator, and it is
the preferred way to use the <code>thentree</code> operator.</h2><span id='topic++25thentree+25'></span>

<h3>Description</h3>

<p><code>%thentree%</code> is the infix operator for the then combinator, and it is
the preferred way to use the <code>thentree</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p1 %thentree% p2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25thentree+2B25_+3A_p1">p1</code></td>
<td>
<p>the first parser</p>
</td></tr>
<tr><td><code id="+2B25thentree+2B25_+3A_p2">p2</code></td>
<td>
<p>the second parser</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recognises anything that <code>p1</code> and <code>p2</code> would if placed in 
succession.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alt">alt</a></code>, <code><a href="#topic+thentree">thentree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(item() %thentree% succeed("123")) ("abc")
</code></pre>

<hr>
<h2 id='+25using+25'><code>%using%</code> is the infix operator for using</h2><span id='topic++25using+25'></span>

<h3>Description</h3>

<p><code>%using%</code> is the infix operator for using
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p %using% f
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25using+2B25_+3A_p">p</code></td>
<td>
<p>is the parser to be applied</p>
</td></tr>
<tr><td><code id="+2B25using+2B25_+3A_f">f</code></td>
<td>
<p>is the function to be applied to each result of <code>p</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>(item() %using% as.numeric) ("1abc")
</code></pre>

<hr>
<h2 id='Alpha'>Alpha checks for single alphabet character</h2><span id='topic+Alpha'></span>

<h3>Description</h3>

<p>Alpha checks for single alphabet character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Alpha(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Alpha_+3A_...">...</code></td>
<td>
<p>additional arguments for the primitives to be parsed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Alpha()("abc")
</code></pre>

<hr>
<h2 id='AlphaNum'>AlphaNum checks for a single alphanumeric character</h2><span id='topic+AlphaNum'></span>

<h3>Description</h3>

<p>AlphaNum checks for a single alphanumeric character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlphaNum(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlphaNum_+3A_...">...</code></td>
<td>
<p>additional arguments for the primitives to be parsed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AlphaNum()("123")
AlphaNum()("abc123")
</code></pre>

<hr>
<h2 id='alt'><code>alt</code> combinator is similar to alternation in BNF. the parser 
<code>(alt(p1, p2))</code> recognises anything that <code>p1</code> or <code>p2</code> would. 
The approach taken in this parser follows (Fairbairn86), in which either is 
interpretted in a sequential (or exclusive) manner, returning the result of
the first parser to succeed, and failure if neither does.</h2><span id='topic+alt'></span>

<h3>Description</h3>

<p><code>%alt%</code> is the infix notation for the <code>alt</code> function, and it is the
preferred way to use the <code>alt</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alt(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alt_+3A_p1">p1</code></td>
<td>
<p>the first parser</p>
</td></tr>
<tr><td><code id="alt_+3A_p2">p2</code></td>
<td>
<p>the second parser</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the first parser if it suceeds otherwise the second parser
</p>


<h3>See Also</h3>

<p><code><a href="#topic+then">then</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(item() %alt% succeed("2")) ("abcdef")
</code></pre>

<hr>
<h2 id='Digit'>Digit checks for single digit</h2><span id='topic+Digit'></span>

<h3>Description</h3>

<p>Digit checks for single digit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Digit(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Digit_+3A_...">...</code></td>
<td>
<p>additional arguments for the primitives to be parsed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Digit()("123")
</code></pre>

<hr>
<h2 id='ident'><code>ident</code> is a parser which matches zero or more alphanumeric
characters.</h2><span id='topic+ident'></span>

<h3>Description</h3>

<p><code>ident</code> is a parser which matches zero or more alphanumeric
characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ident()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ident() ("variable1 = 123")
</code></pre>

<hr>
<h2 id='identifier'><code>identifier</code> creates an identifier</h2><span id='topic+identifier'></span>

<h3>Description</h3>

<p><code>identifier</code> creates an identifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifier(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifier_+3A_...">...</code></td>
<td>
<p>takes in token primitives</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>

<hr>
<h2 id='item'><code>item</code> is a parser that consumes the first character of the string and
returns the rest. If it cannot consume a single character from the string, it
will emit the empty list, indicating the parser has failed.</h2><span id='topic+item'></span>

<h3>Description</h3>

<p><code>item</code> is a parser that consumes the first character of the string and
returns the rest. If it cannot consume a single character from the string, it
will emit the empty list, indicating the parser has failed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>item(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="item_+3A_...">...</code></td>
<td>
<p>additional arguments for the parser</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>item() ("abc")
item() ("")
</code></pre>

<hr>
<h2 id='literal'><code>literal</code> is a parser for single symbols. It will attempt to match the
single symbol with the first character in the string.</h2><span id='topic+literal'></span>

<h3>Description</h3>

<p><code>literal</code> is a parser for single symbols. It will attempt to match the
single symbol with the first character in the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>literal(char)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="literal_+3A_char">char</code></td>
<td>
<p>is the character to be matched</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>literal("a") ("abc")
</code></pre>

<hr>
<h2 id='Lower'>Lower checks for single lower case character</h2><span id='topic+Lower'></span>

<h3>Description</h3>

<p>Lower checks for single lower case character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lower(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lower_+3A_...">...</code></td>
<td>
<p>additional arguments for the primitives to be parsed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lower() ("abc")
</code></pre>

<hr>
<h2 id='many'><code>many</code> matches 0 or more of pattern <code>p</code>. In BNF notation, 
repetition occurs often enough to merit its own abbreviation. When zero or 
more repetitions of a phrase <code>p</code> are admissible, we simply write 
<code>p*</code>. The <code>many</code> combinator corresponds directly to this operator, 
and is defined in much the same way.</h2><span id='topic+many'></span>

<h3>Description</h3>

<p>This implementation of <code>many</code> differs from (Hutton92) due to the nature 
of R's data structures. Since R does not support the concept of a list of
tuples, we must revert to using a list rather than a vector, since all values
in an R vector must be the same datatype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>many(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="many_+3A_p">p</code></td>
<td>
<p>is the parser to match 0 or more times.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+maybe">maybe</a></code>, <code><a href="#topic+some">some</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Digit &lt;- function(...) {satisfy(function(x) {return(!!length(grep("[0-9]", x)))})}
many(Digit()) ("123abc")
many(Digit()) ("abc")
</code></pre>

<hr>
<h2 id='maybe'><code>maybe</code> matches 0 or 1 of pattern <code>p</code>.  In EBNF notation, this
corresponds to a question mark ('?').</h2><span id='topic+maybe'></span>

<h3>Description</h3>

<p><code>maybe</code> matches 0 or 1 of pattern <code>p</code>.  In EBNF notation, this
corresponds to a question mark ('?').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maybe(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maybe_+3A_p">p</code></td>
<td>
<p>is the parser to be matched 0 or 1 times.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+many">many</a></code>, <code><a href="#topic+some">some</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maybe(Digit())("123abc")
maybe(Digit())("abc123")
</code></pre>

<hr>
<h2 id='nat'><code>nat</code> is a parser which matches one or more numeric characters.</h2><span id='topic+nat'></span>

<h3>Description</h3>

<p><code>nat</code> is a parser which matches one or more numeric characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nat()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>,
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nat() ("123 + 456")
</code></pre>

<hr>
<h2 id='natural'><code>natural</code> creates a token parser for natural numbers</h2><span id='topic+natural'></span>

<h3>Description</h3>

<p><code>natural</code> creates a token parser for natural numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>natural(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="natural_+3A_...">...</code></td>
<td>
<p>additional arguments for the parser</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+symbol">symbol</a></code>
</p>

<hr>
<h2 id='Ramble'>Ramble is a parser generator using combinatory parsers.</h2><span id='topic+Ramble'></span><span id='topic+Ramble-package'></span><span id='topic+package-ramble'></span><span id='topic+ramble'></span>

<h3>Description</h3>

<p>Ramble allows you to write parsers in a functional manner, inspired by 
Haskell's Parsec library.
</p>

<hr>
<h2 id='satisfy'><code>satisfy</code> is a function which allows us to make parsers that recognise single symbols.</h2><span id='topic+satisfy'></span>

<h3>Description</h3>

<p><code>satisfy</code> is a function which allows us to make parsers that recognise single symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>satisfy(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="satisfy_+3A_p">p</code></td>
<td>
<p>is the predicate to determine if the arbitrary symbol is a member.</p>
</td></tr>
</table>

<hr>
<h2 id='some'><code>some</code> matches 1 or more of pattern <code>p</code>. in BNF notation, repetition occurs often enough to merit its own abbreviation. When zero or 
more repetitions of a phrase <code>p</code> are admissible, we simply write 
<code>p+</code>. The <code>some</code> combinator corresponds directly to this operator,
and is defined in much the same way.</h2><span id='topic+some'></span>

<h3>Description</h3>

<p><code>some</code> matches 1 or more of pattern <code>p</code>. in BNF notation, repetition occurs often enough to merit its own abbreviation. When zero or 
more repetitions of a phrase <code>p</code> are admissible, we simply write 
<code>p+</code>. The <code>some</code> combinator corresponds directly to this operator,
and is defined in much the same way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>some(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="some_+3A_p">p</code></td>
<td>
<p>is the parser to match 1 or more times.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+maybe">maybe</a></code>, <code><a href="#topic+many">many</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Digit &lt;- function(...) {satisfy(function(x) {return(!!length(grep("[0-9]", x)))})}
some(Digit()) ("123abc")
</code></pre>

<hr>
<h2 id='space'><code>space</code> matches zero or more space characters.</h2><span id='topic+space'></span>

<h3>Description</h3>

<p><code>space</code> matches zero or more space characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>space() ("  abc")
</code></pre>

<hr>
<h2 id='SpaceCheck'>SpaceCheck checks for a single space character</h2><span id='topic+SpaceCheck'></span>

<h3>Description</h3>

<p>SpaceCheck checks for a single space character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpaceCheck(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpaceCheck_+3A_...">...</code></td>
<td>
<p>additional arguments for the primitives to be parsed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>,
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SpaceCheck()(" 123")
</code></pre>

<hr>
<h2 id='String'><code>String</code> is a combinator which allows us to build parsers which
recognise strings of symbols, rather than just single symbols</h2><span id='topic+String'></span>

<h3>Description</h3>

<p><code>String</code> is a combinator which allows us to build parsers which
recognise strings of symbols, rather than just single symbols
</p>


<h3>Usage</h3>

<pre><code class='language-R'>String(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="String_+3A_string">string</code></td>
<td>
<p>is the string to be matched</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>String("123")("123 abc")
</code></pre>

<hr>
<h2 id='succeed'><code>succeed</code> is based on the empty string symbol in the BNF notation The 
<code>succeed</code> parser always succeeds, without actually consuming any input 
string. Since the outcome of succeed does not depend on its input, its result
value must be pre-detemined, so it is included as an extra parameter.</h2><span id='topic+succeed'></span>

<h3>Description</h3>

<p><code>succeed</code> is based on the empty string symbol in the BNF notation The 
<code>succeed</code> parser always succeeds, without actually consuming any input 
string. Since the outcome of succeed does not depend on its input, its result
value must be pre-detemined, so it is included as an extra parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>succeed(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="succeed_+3A_string">string</code></td>
<td>
<p>the result value of succeed parser</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>succeed("1") ("abc")
</code></pre>

<hr>
<h2 id='symbol'><code>symbol</code> creates a token for a symbol</h2><span id='topic+symbol'></span>

<h3>Description</h3>

<p><code>symbol</code> creates a token for a symbol
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbol(xs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbol_+3A_xs">xs</code></td>
<td>
<p>takes in a string to create a token</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symbol("[") ("  [123]")
</code></pre>

<hr>
<h2 id='then'><code>then</code> combinator corresponds to sequencing in BNF. The parser 
<code>(then(p1, p2))</code> recognises anything that <code>p1</code> and <code>p2</code> would 
if placed in succession.</h2><span id='topic+then'></span>

<h3>Description</h3>

<p><code>%then%</code> is the infix operator for the then combinator, and it is the
preferred way to use the <code>then</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>then(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="then_+3A_p1">p1</code></td>
<td>
<p>the first parser</p>
</td></tr>
<tr><td><code id="then_+3A_p2">p2</code></td>
<td>
<p>the second parser</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recognises anything that <code>p1</code> and <code>p2</code> would if placed in 
succession.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alt">alt</a></code>, <code><a href="#topic+thentree">thentree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(item() %then% succeed("123")) ("abc")
</code></pre>

<hr>
<h2 id='thentree'><code>thentree</code> keeps the full tree representation of the results of parsing.
Otherwise, it is identical to <code>then</code>.</h2><span id='topic+thentree'></span>

<h3>Description</h3>

<p><code>thentree</code> keeps the full tree representation of the results of parsing.
Otherwise, it is identical to <code>then</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thentree(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thentree_+3A_p1">p1</code></td>
<td>
<p>the first parser</p>
</td></tr>
<tr><td><code id="thentree_+3A_p2">p2</code></td>
<td>
<p>the second parser</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recognises anything that <code>p1</code> and <code>p2</code> would if placed in 
succession.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alt">alt</a></code>, <code><a href="#topic+thentree">thentree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(item() %thentree% succeed("123")) ("abc")

</code></pre>

<hr>
<h2 id='token'><code>token</code> is a new primitive that ignores any space before and after
applying a parser to a token.</h2><span id='topic+token'></span>

<h3>Description</h3>

<p><code>token</code> is a new primitive that ignores any space before and after
applying a parser to a token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>token(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="token_+3A_p">p</code></td>
<td>
<p>is the parser to have spaces stripped.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, <code><a href="#topic+Upper">Upper</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>token(ident()) ("   variable1   ")
</code></pre>

<hr>
<h2 id='Unlist'>Unlist is the same as unlist, but doesn't recurse all the way to
preserve the type. This function is not well optimised.</h2><span id='topic+Unlist'></span>

<h3>Description</h3>

<p>Unlist is the same as unlist, but doesn't recurse all the way to
preserve the type. This function is not well optimised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Unlist(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Unlist_+3A_obj">obj</code></td>
<td>
<p>is a list to be flatten</p>
</td></tr>
</table>

<hr>
<h2 id='Upper'>Upper checks for a single upper case character</h2><span id='topic+Upper'></span>

<h3>Description</h3>

<p>Upper checks for a single upper case character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Upper(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Upper_+3A_...">...</code></td>
<td>
<p>additional arguments for the primitives to be parsed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Digit">Digit</a></code>, <code><a href="#topic+Lower">Lower</a></code>, 
<code><a href="#topic+Alpha">Alpha</a></code>, <code><a href="#topic+AlphaNum">AlphaNum</a></code>, <code><a href="#topic+SpaceCheck">SpaceCheck</a></code>, 
<code><a href="#topic+String">String</a></code>, <code><a href="#topic+ident">ident</a></code>, <code><a href="#topic+nat">nat</a></code>, 
<code><a href="#topic+space">space</a></code>, <code><a href="#topic+token">token</a></code>, <code><a href="#topic+identifier">identifier</a></code>,
<code><a href="#topic+natural">natural</a></code>, <code><a href="#topic+symbol">symbol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Upper()("Abc")
</code></pre>

<hr>
<h2 id='using'><code>using</code> combinator allows us to manipulate results from a parser, for 
example building a parse tree. The parser <code>(p %using% f)</code> has the same 
behaviour as the parser <code>p</code>, except that the function <code>f</code> is
applied to each of its result values.</h2><span id='topic+using'></span>

<h3>Description</h3>

<p><code>%using%</code> is the infix operator for <code>using</code>, and it is the
preferred way to use the <code>using</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>using(p, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="using_+3A_p">p</code></td>
<td>
<p>is the parser to be applied</p>
</td></tr>
<tr><td><code id="using_+3A_f">f</code></td>
<td>
<p>is the function to be applied to each result of <code>p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parser <code>(p %using% f)</code> has the same behaviour as the
parser <code>p</code>, except that the function <code>f</code> is applied to each of
its result values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(item() %using% as.numeric) ("1abc")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
