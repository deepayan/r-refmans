<!DOCTYPE html><html><head><title>Help for package relSim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {relSim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allPairsLR'><p>Compute the likehood ratio for all pairs of profiles in a database</p></a></li>
<li><a href='#blockSim'><p>Perform relatives simulations using large memory blocks in C</p></a></li>
<li><a href='#breedFst'><p>Breed a population with an approximate level of</p>
<code class="reqn">\theta</code>(<code class="reqn">F_{ST}</code>)</a></li>
<li><a href='#calcFst'><p>Caculate locus-wise and population <code class="reqn">F_{ST}</code> values</p></a></li>
<li><a href='#calcFStats'><p>Calculate locus-wise and population <code class="reqn">\theta = F_{ST}</code>,  <code class="reqn">F = F_{IT}</code>, and <code class="reqn">f = F_{IS}</code> values</p></a></li>
<li><a href='#checkFreqs'><p>Make sure that the frequencies are such</p></a></li>
<li><a href='#errorRate'><p>Returns the false positive or false negative rates for a set of IBS and/or</p>
KI thresholds</a></li>
<li><a href='#exclusionPower'><p>Calculate the exclusion power of a multiplex by locus</p></a></li>
<li><a href='#famSearch'><p>Search a database for siblings or children</p></a></li>
<li><a href='#fbiCaucs'><p>CODIS STR Loci allele frequency data</p></a></li>
<li><a href='#fetchBMdata'><p>Retrieve data from Budowle and Moretti (1999) from the web</p></a></li>
<li><a href='#IBS'><p>Identity by state</p></a></li>
<li><a href='#IS'><p>Use importance sampling to determine the probability of m peaks from n contributors to a mixture</p></a></li>
<li><a href='#locusIBS'><p>Identity by state at a locus</p></a></li>
<li><a href='#lrMix'><p>Calculate locuswise likelihood ratios for two person victim/suspect mixtures</p></a></li>
<li><a href='#lrPC'><p>Likelihood Ratio for Parent-Child / Paternity Index</p></a></li>
<li><a href='#lrSib'><p>Likelihood Ratio / Kinship Index for full-siblings</p></a></li>
<li><a href='#lrSibDebug'><p>Likelihood Ratio / Kinship Index for full-siblings</p></a></li>
<li><a href='#normalizeFreqs'><p>Normalize frequencies to 1</p></a></li>
<li><a href='#print.population'><p>Print summary details of a substructed population</p></a></li>
<li><a href='#print.profile'><p>Print a DNA profile</p></a></li>
<li><a href='#randomChild'><p>Generate a random child from a given DNA profile and a given set of allele</p>
frequencies</a></li>
<li><a href='#randomPCPairs'><p>Generate one or more random parent/child pairs from a given set of allele</p>
frequencies</a></li>
<li><a href='#randomProfile'><p>Generate a random DNA profile from a given set of allele frequencies</p></a></li>
<li><a href='#randomProfilePairs'><p>Generate one or more random DNA profile pairs from a given set of allele</p>
frequencies</a></li>
<li><a href='#randomSample'><p>Generate a random sample of related (or unrelated) pairs of people</p></a></li>
<li><a href='#randomSib'><p>Generate a random sibling from a given DNA profile and a given set of allele</p>
frequencies</a></li>
<li><a href='#randomSibPairs'><p>Generate one or more pairs of random siblings from a given set of allele</p>
frequencies</a></li>
<li><a href='#readFreqs'><p>Read in a file of allele frequencies</p></a></li>
<li><a href='#readProfiles'><p>Read a set of profiles from a file</p></a></li>
<li><a href='#readResults'><p>Read a simulation result set from file</p></a></li>
<li><a href='#relSim-package'><p>relSim: Relative Simulator</p></a></li>
<li><a href='#sim'><p>Perform the relatives simulation</p></a></li>
<li><a href='#simNpersonMixture'><p>Simulate and count unique alleles in N person mixtures</p></a></li>
<li><a href='#toNexus'><p>Export a population with substructure to a Nexus file</p></a></li>
<li><a href='#USCaucs'><p>CODIS STR Loci allele frequency data</p></a></li>
<li><a href='#writeCSV'><p>Saves/writes population frequencies to disk</p></a></li>
<li><a href='#writePop'><p>Saves/writes population profiles to disk</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Relative Simulator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-04</td>
</tr>
<tr>
<td>Author:</td>
<td>James M. Curran</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James M. Curran &lt;j.curran@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools to explore the behaviour statistics used for forensic DNA interpretation when close relatives are involved. The package also offers some useful tools for exploring other forensic DNA situations.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, xtable, multicool, utils, rvest, stringr,
xml2, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-03 23:48:12 UTC; jcur002</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allPairsLR'>Compute the likehood ratio for all pairs of profiles in a database</h2><span id='topic+allPairsLR'></span>

<h3>Description</h3>

<p>This function takes every pair of profiles in a database of profiles and computes
the likelihood ratio (LR) for a specific relationship given by <code>nCode</code>. That means
there will be <code class="reqn">N(N-1)/2</code> LRs computed for N profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allPairsLR(Profiles, listFreqs, nCode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allPairsLR_+3A_profiles">Profiles</code></td>
<td>
<p>an integer vector of stacked profiles representing the database. This vector has <code class="reqn">2NL</code> entries, where N is the number of
profiles and <code class="reqn">L</code> is the number of loci.</p>
</td></tr>
<tr><td><code id="allPairsLR_+3A_listfreqs">listFreqs</code></td>
<td>
<p>is a set of allele frequencies representing a particular multiplex. The function assumes that that loci in the profiles
are in the same order as the loci in this list. The data structure is a <code>List</code> of <code>NumericVector</code>'s.</p>
</td></tr>
<tr><td><code id="allPairsLR_+3A_ncode">nCode</code></td>
<td>
<p>if <code>1</code> then compute the LR for siblings, otherwise computer the LR for parent/child.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NumericVector</code> containing the LRs. They are stored in sequential order so if for example there were three
profiles, then there are 3 possible LRs, and the result vector would contain the LRs for the profile pairs (1, 2),
(1, 3), and (2, 3).
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("USCaucs")
N = 600
profs = relSim:::.randomProfiles(USCaucs$freqs, N)
system.time({lr = relSim:::allPairsLR(profs, USCaucs$freqs, 1)})
plot(density(log10(lr)))
mean(lr &gt; 1) ## estimate the probability that the LR is incorrectly above 1

</code></pre>

<hr>
<h2 id='blockSim'>Perform relatives simulations using large memory blocks in C</h2><span id='topic+blockSim'></span>

<h3>Description</h3>

<p>Generate N pairs with a given relationship, calculate the LR for sibs,
parent-child and the number of matching alleles and count the number of
pairs that meet the threshold criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockSim(
  N,
  Freqs,
  rel = "UN",
  ibsthresh = NULL,
  kithresh = NULL,
  code = 1,
  falseNeg = TRUE,
  BlockSize = N/10,
  showProgress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockSim_+3A_n">N</code></td>
<td>
<p>The number of iterations to carry out</p>
</td></tr>
<tr><td><code id="blockSim_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex.</p>
</td></tr>
<tr><td><code id="blockSim_+3A_rel">rel</code></td>
<td>
<p>generate unrelated (<code>rel = 'UN'</code>), full-sibs (<code>rel =
'FS'</code>), or parent child (<code>rel = 'PC'</code>) pairs</p>
</td></tr>
<tr><td><code id="blockSim_+3A_ibsthresh">ibsthresh</code></td>
<td>
<p>A vector of one or more IBS thresholds</p>
</td></tr>
<tr><td><code id="blockSim_+3A_kithresh">kithresh</code></td>
<td>
<p>A vector of one or more KI/LR thresholds</p>
</td></tr>
<tr><td><code id="blockSim_+3A_code">code</code></td>
<td>
<p>A code from 1 to 6 which dictates the events that will be
counted.  </p>
 <ol>
<li><p> the LR for siblings will be compared to the
values in <code>kithresh</code> and incremented if the LR is greater than the
threshold </p>
</li>
<li><p> the LR for parent/child will be compared to the values in
<code>kithresh</code> and incremented if the LR is greater than the threshold
</p>
</li>
<li><p> the number of matching alleles (IBS) will be compared to the values in
<code>ibsthresh</code> and incremented if the IBS is greater than the threshold
</p>
</li>
<li><p> the LR for siblings and the number of matching alleles will be
compared to the values in <code>kithresh</code> and <code>ibsthresh</code> and
incremented if both the LR and IBS is greater than the thresholds.
<code>ibsthresh</code> and <code>kithresh</code> must be of equal length for this option
to work </p>
</li>
<li><p> the LR for parent/child and the number of matching alleles
will be compared to the values in <code>kithresh</code> and <code>ibsthresh</code> and
incremented if both the LR and IBS is greater than the thresholds.
<code>ibsthresh</code> and <code>kithresh</code> must be of equal length for this option
to work </p>
</li>
<li><p> this option is equivalent to performing code 4 and 5
simulataneously. It is not currently implemented </p>
</li></ol>
</td></tr>
<tr><td><code id="blockSim_+3A_falseneg">falseNeg</code></td>
<td>
<p>if TRUE then the number of results that DO NOT satisfy the
conditions are counted, otherwise the number of results DO satisfy the
conditions are counted</p>
</td></tr>
<tr><td><code id="blockSim_+3A_blocksize">BlockSize</code></td>
<td>
<p>Sets the number of random profiles to be generated in each
iteration. By default the block size is set to 10 percent of the total
sample size. It is unclear whether the procedure is more efficient if a
bigger percentage of the total is used. Users must take care to make sure
that the block size evenly divides <code>N</code> otherwise the procedure will
exit. Users must also make sure that they have enough memory.</p>
</td></tr>
<tr><td><code id="blockSim_+3A_showprogress">showProgress</code></td>
<td>
<p>If <code>TRUE</code> then a progress bar will be displayed in
the console showing the progress of the simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used for fast accurate estimation of false positive and
false negative rates. It achieves part of its speed by block exectution in
C, and part by not saving the LR or IBS results. It can do 1 billion
iterations in about an hour.
</p>


<h3>Value</h3>

<p>A vector containing the number of profile pairs that satisfied the
threshold conditions
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>sim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## not run
## this counts the number of unrelated pairs that are falsely identified
## as siblings using the policy that there are 16 or more matching
## alleles, and the LR/KI is greater than 100,000
## this is a very rare event for the FBI Caucasians with a frequency of
## about 4-5 times in 10 million pairs
## Not run: 
data(fbiCaucs)
N = 1e8
ki = 1e5
ibs = 16
code = 5
BlockSize = 1e6
blockSim(N, fbiCaucs, rel = "UN", ibsthresh = ibs, kithresh = ki,
         code = code, falseNeg = FALSE, BlockSize = BlockSize)

## End(Not run)
</code></pre>

<hr>
<h2 id='breedFst'>Breed a population with an approximate level of
<code class="reqn">\theta</code>(<code class="reqn">F_{ST}</code>)</h2><span id='topic+breedFst'></span>

<h3>Description</h3>

<p>This function simulates a population with an approximate level of population
substructure. This is achieved by subdividing a population into equal sized
subpopulations and allowing them to breed within themselves for </p>
<p style="text-align: center;"><code class="reqn">t =
</code>
</p>
<p style="text-align: center;"><code class="reqn">
\lceil{\frac{\log_e(1-\theta)}{\log\left(1-\frac{1}{2N_s}\right)}}\rceil</code>
</p>
<p> generations, where <code class="reqn">N_s</code> is
the number of individuals in each subpopulation. This will produce a
population with an estimated coancestry coefficient approximately equal to
<code class="reqn">\theta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breedFst(Freqs, theta = 0.01, N = 10000, ns = 10, DNAtools = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breedFst_+3A_freqs">Freqs</code></td>
<td>
<p>A list with an element, <code>freqs</code> which contains a list of
vectors, where each vector is a set of allele frequencies for a locus</p>
</td></tr>
<tr><td><code id="breedFst_+3A_theta">theta</code></td>
<td>
<p>A desired level of inbreeding, where <code class="reqn">0 &lt; \theta &lt; 0.5</code></p>
</td></tr>
<tr><td><code id="breedFst_+3A_n">N</code></td>
<td>
<p>Total population size</p>
</td></tr>
<tr><td><code id="breedFst_+3A_ns">ns</code></td>
<td>
<p>The number of subpopulations. <code class="reqn">N/n_s</code> needs to be
greater than 100</p>
</td></tr>
<tr><td><code id="breedFst_+3A_dnatools">DNAtools</code></td>
<td>
<p>If <code>TRUE</code> then the profiles in the return population
will be formatted as a data frame with an id column and two columns per
locus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'population' which is a list with the following
elements </p>
 <ul>
<li> <p><code>profiles</code> - a vector of profiles where the
level of inbreeding is approximately equal to <code class="reqn">\theta</code> </p>
</li>
<li>
<p><code>nProfiles</code> - the total number of individuals in the population </p>
</li>
<li>
<p><code>nSubpops</code> - the number of sub-populations in the population </p>
</li>
<li>
<p><code>nLoci</code> - the number of loci each individual is typed at </p>
</li>
<li>
<p><code>theta</code> - the desired level of substructure in the population. The
actual value will be near to this.  </p>
</li>
<li> <p><code>Freqs</code> - a Freq object
representing the ancestral frequencies of the population </p>
</li></ul>



<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USCaucs)
pop = breedFst(USCaucs)

</code></pre>

<hr>
<h2 id='calcFst'>Caculate locus-wise and population <code class="reqn">F_{ST}</code> values</h2><span id='topic+calcFst'></span>

<h3>Description</h3>

<p>This procedure uses the method of Weir and Cockerham to estimate
<code class="reqn">\theta</code> (<code class="reqn">F_{ST}</code>) for a population with substructure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcFst(Pop, subPopIdx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcFst_+3A_pop">Pop</code></td>
<td>
<p>An object type 'population'</p>
</td></tr>
<tr><td><code id="calcFst_+3A_subpopidx">subPopIdx</code></td>
<td>
<p>If this vector is not null, then it must consist of
<code class="reqn">N</code> elements with values from 1 to <code class="reqn">n_s</code> representing which
subpopulation each member of <code>Pop$profiles</code> belongs to. If it is null
then it is assumed that the population consists of <code class="reqn">n_s</code>
subpopulations of equal size <code class="reqn">N_s</code> so that <code class="reqn">n_s\times N_s =
N</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code class="reqn">n_{loci}+1</code> with locus-wise
<code class="reqn">\theta</code> values and an overall <code class="reqn">\theta</code> value for the
population
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>Weir, B.S., Genetic Data Analysis II, (1996) p.173&ndash;179,
Sinauer, Sunderland, MA.
</p>


<h3>See Also</h3>

<p>breedFst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USCaucs)
p = breedFst(USCaucs)
fst = calcFst(p)
fst

</code></pre>

<hr>
<h2 id='calcFStats'>Calculate locus-wise and population <code class="reqn">\theta = F_{ST}</code>,  <code class="reqn">F = F_{IT}</code>, and <code class="reqn">f = F_{IS}</code> values</h2><span id='topic+calcFStats'></span>

<h3>Description</h3>

<p>This procedure uses the method of Weir and Cockerham to estimate
<code class="reqn">\theta = F_{ST}</code>,  <code class="reqn">F = F_{IT}</code>, and <code class="reqn">f = F_{IS}</code> for a population with known substructure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcFStats(Pop, subPopIdx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcFStats_+3A_pop">Pop</code></td>
<td>
<p>An object type 'population'</p>
</td></tr>
<tr><td><code id="calcFStats_+3A_subpopidx">subPopIdx</code></td>
<td>
<p>If this vector is not null, then it must consist of
<code class="reqn">N</code> elements with values from 1 to <code class="reqn">n_s</code> representing which
subpopulation each member of <code>Pop$profiles</code> belongs to. If it is null
then it is assumed that the population consists of <code class="reqn">n_s</code>
subpopulations of equal size <code class="reqn">N_s</code> so that <code class="reqn">n_s\times N_s =
N</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code class="reqn">n_{loci}+1</code> with locus-wise
<code class="reqn">\theta</code> values and an overall <code class="reqn">\theta</code> value for the
population
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>Weir, B.S., Genetic Data Analysis II, (1996) p.173&ndash;179,
Sinauer, Sunderland, MA.
</p>


<h3>See Also</h3>

<p>breedFst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USCaucs)
set.seed(123)
p = breedFst(USCaucs)
fstats = calcFStats(p)
fstats

</code></pre>

<hr>
<h2 id='checkFreqs'>Make sure that the frequencies are such</h2><span id='topic+checkFreqs'></span>

<h3>Description</h3>

<p>Checks whether a list of frequencies at a series of genetic loci both sum to
one and lie between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkFreqs(Freqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkFreqs_+3A_freqs">Freqs</code></td>
<td>
<p>A list containg elements <code>loci</code> and <code>freqs</code>.
<code>freqs</code> is a list of vectors containing the frequencies at the given
loci.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a locus fails to sum to one, or there are alleles which fall below zero
or above one, then a warning message will be returned for each item in
error.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>normalizeFreqs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
checkFreqs(fbiCaucs)

## induce an error
fbiCaucs$freqs[[1]] = runif(10)
checkFreqs(fbiCaucs)

</code></pre>

<hr>
<h2 id='errorRate'>Returns the false positive or false negative rates for a set of IBS and/or
KI thresholds</h2><span id='topic+errorRate'></span>

<h3>Description</h3>

<p>This function is used to calcalate the various tables in the work of Ge et
al. and Balding et al. Specifically it can be used to calculate the false
positive rate for unrelated pairs being identified as full-sibs or
parent-child pairs under differing levels of IBS or KI (or both) thresholds.
It can also be used to calculate the false negative rates for full-sib, or
parent-child, pairs being identified as unrelated, again with differing
levels of IBS, KI or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorRate(
  simResults,
  bIBS = TRUE,
  bKI = FALSE,
  rel = "UN",
  IBSthresh = 14:17,
  KIthresh = c(1000, 10000, 1e+05, 1e+06),
  nLoci = 13
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorRate_+3A_simresults">simResults</code></td>
<td>
<p>A data.frame with three columns labelled sib, pc and ibs.
This will usually be obtained from a call to <code>sim</code> or
<code>readResults</code>.</p>
</td></tr>
<tr><td><code id="errorRate_+3A_bibs">bIBS</code></td>
<td>
<p>If <code>TRUE</code> then IBS thresholds are used to generate the
error rates. If both <code>bIBS</code> and <code>bKI</code> are <code>TRUE</code> then both
criteria are used.</p>
</td></tr>
<tr><td><code id="errorRate_+3A_bki">bKI</code></td>
<td>
<p>If <code>TRUE</code> then KI thresholds are used to generate the error
rates. If both <code>bIBS</code> and <code>bKI</code> are <code>TRUE</code> then both criteria
are used.</p>
</td></tr>
<tr><td><code id="errorRate_+3A_rel">rel</code></td>
<td>
<p>The relationship used in the simulation. Must be one of 'UN',
'FS' or 'PC'.</p>
</td></tr>
<tr><td><code id="errorRate_+3A_ibsthresh">IBSthresh</code></td>
<td>
<p>A vector of IBS values that can be used to classify the
results as being related (or not).</p>
</td></tr>
<tr><td><code id="errorRate_+3A_kithresh">KIthresh</code></td>
<td>
<p>A vector of KI threshold values that can be used to classify
the results as being related (or not).</p>
</td></tr>
<tr><td><code id="errorRate_+3A_nloci">nLoci</code></td>
<td>
<p>The number of loci being used in the multiplex. This dictates
the upper bound on the IBS values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (or a two-column matrix) of false negative or false
positive rates. If the relationship is 'UN' then false positive rates are
returned for parent-child and full-sibs, with parent-child being in column 1
and full-sibs in column 2. If the relationship is 'PC' then the false
negative rate is returned for parent-child pairs, and if it is 'FS' then the
false negative rate for full-sibs.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>sim, readResults
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## not run
## Not run: data(fbiCaucs)
unrel = sim(10000)
errorRate(unrel)

## End(Not run)

</code></pre>

<hr>
<h2 id='exclusionPower'>Calculate the exclusion power of a multiplex by locus</h2><span id='topic+exclusionPower'></span><span id='topic+ep'></span>

<h3>Description</h3>

<p>Calculates the exclusion power
</p>
<p style="text-align: center;"><code class="reqn">1-2\left(\sum_{i=1}^{n_l}p_i^2\right)^2-4\sum_{i=1}^{n_l}p_i^4</code>
</p>

<p>at each locus for a set of allele frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclusionPower(Freqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exclusionPower_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two vectors and a list, called loci, counts,
and freqs. The elements of loci are the loci present in the multiplex. The
elements are freqs a vectors of allele frequencies for the locus. The
elements of counts are irrelevant here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The exclusion power for each locus.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>NRC II, Evaluation of Forensic Evidence, (1996), p.96, National
Academy Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USCaucs)
ep(USCaucs)

## get the multiplex wide exclusion power
1 - prod(1-ep(USCaucs))

</code></pre>

<hr>
<h2 id='famSearch'>Search a database for siblings or children</h2><span id='topic+famSearch'></span>

<h3>Description</h3>

<p>This function searches a database of profiles for either a sibling or a child
</p>


<h3>Usage</h3>

<pre><code class='language-R'>famSearch(profiles, siblings, children, listFreqs, step)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="famSearch_+3A_profiles">profiles</code></td>
<td>
<p>an integer vector of stacked profiles representing the database. This vector has <code class="reqn">2NL</code> entries, where N is the number of
profiles and L is the number of loci.</p>
</td></tr>
<tr><td><code id="famSearch_+3A_siblings">siblings</code></td>
<td>
<p>an integer vector of stacked profiles representing the siblings of the profiles in database. 
The first entry is a sibling of the first entry in <code>profiles</code> and so on. This vector has <code class="reqn">2NL</code> entries, where N is the number of
profiles and L is the number of loci.</p>
</td></tr>
<tr><td><code id="famSearch_+3A_children">children</code></td>
<td>
<p>an integer vector of stacked profiles representing the children of the profiles in database. 
The first entry is a child of the first entry in <code>profiles</code> and so on. This vector has <code class="reqn">2NL</code> entries, where N is the number of
profiles and L is the number of loci.</p>
</td></tr>
<tr><td><code id="famSearch_+3A_listfreqs">listFreqs</code></td>
<td>
<p>is a set of allele frequencies representing a particular multiplex. The function assumes that that loci in the profiles
are in the same order as the loci in this list. The data structure is a <code>List</code> of <code>NumericVector</code>'s.</p>
</td></tr>
<tr><td><code id="famSearch_+3A_step">step</code></td>
<td>
<p>A step size for progress reporting, i.e. print out progress every <code>step</code> iterations. If <code>step = -1</code>, then there is no printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>List</code> containing two dataframes, one called <code>sibs</code> and one called <code>children</code>. Each dataframe has results from searching for
either the sibling or the child in the database. For each entry there is a record of which profile gave the highest LR (and its value),
and the position of the actual sibling or parent/child in the database (and its respective LR).
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>

<hr>
<h2 id='fbiCaucs'>CODIS STR Loci allele frequency data</h2><span id='topic+fbiCaucs'></span>

<h3>Description</h3>

<p>This data structure
</p>


<h3>Format</h3>

<p>This data set is a list which has two sub-lists. The lists are named
loci and freqs. loci is a vector of the 13 CODIS STR locus names. freqs is a
list of 13 vectors, each vector contains the allele frequencies published
for US Caucasians in Budowle et al. (2001).
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>Budowle B, Shea B, Niezgoda S, Chakraborty R. (2001),
<em>CODIS STR loci data from 41 sample populations</em>, J. Forensic Sci.
46:453-89.
</p>


<h3>See Also</h3>

<p>USCaucs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
names(fbiCaucs)
fbiCaucs$loci
names(fbiCaucs$freqs)
fbiCaucs$freqs[[1]]
names(fbiCaucs$freqs[[1]])
fbiCaucs$freqs[[1]][1]

</code></pre>

<hr>
<h2 id='fetchBMdata'>Retrieve data from Budowle and Moretti (1999) from the web</h2><span id='topic+fetchBMdata'></span>

<h3>Description</h3>

<p>Retreives the Budowle and Moretti (1999) and compiles the allele frequency
tables needed for the other parts of this package such as <code>sim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetchBMdata(url = NULL, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetchBMdata_+3A_url">url</code></td>
<td>
<p>- the location of the webpage this data is stored on. If
<code>NULL</code> then hardcoded values in the function are used. The argument
allows the user to get the function to work given this values may change.
However, it is unlikely that it will help.</p>
</td></tr>
<tr><td><code id="fetchBMdata_+3A_id">id</code></td>
<td>
<p>- the id of the HTML element where the data is stored on the
webpage. If <code>NULL</code> then a hardcoded value in the function is used. The
argument allows the user to get the function to work given this values may
change. However, it is unlikely that it will help. NOTE: this is super
flakey because of how the FBI web authors have created it. This may change
in which case, the function will more likely change than the id.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first three populations have data on 20 loci, the second three on 13
loci. The missing values (0's in the raw data) have been dropped and are not
used in calculating the frequencies. This function will not work if you are
not connected to the internet, or access to the internet is blocked.
</p>


<h3>Value</h3>

<p>A list consisting of six elements corresponding to the six
populations detailed in the data set. Each of the list elements is a list in
itself with three further elements named <code>loci</code>, <code>profiles</code> and <code>freqs</code>. 
<code>loci</code> is a vector of the 13-20 STR locus names. <code>freqs</code> is a list of 13-20 
vectors, each vector contains the allele frequencies. <code>profiles</code> contains the 
raw profiles that the allele frequency tables were constructed from.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>Budowle, B. and Moretti, T.R. (1999), <em>Genotype Profiles
for Six Population Groups at the 13 CODIS Short Tandem Repeat Core Loci and
Other PCR Based Loci</em>, Forensic Science Communications 1(2).
</p>


<h3>See Also</h3>

<p>fbiCaucs, USCaucs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## not run
## Not run: 
db = fetchBMdata()
names(db)
f = db[["TRINIDADIAN"]]$freqs
dbExpect(f, k = "UN", collapse = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='IBS'>Identity by state</h2><span id='topic+IBS'></span>

<h3>Description</h3>

<p>Calculates the total number of alleles that are shared by two profiles. If
the two profiles in question are indeed relatives then the matching alleles
may be identical by descent, or by random chance alone, hence identity by
state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBS(prof1, prof2, nLoci = length(prof1)/2, bPrint = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBS_+3A_prof1">prof1</code></td>
<td>
<p>A matrix consisting of 2 columns and nLoci rows. Each entry in
the matrix is the (coded) allele held by the individual.</p>
</td></tr>
<tr><td><code id="IBS_+3A_prof2">prof2</code></td>
<td>
<p>See <code>prof1</code></p>
</td></tr>
<tr><td><code id="IBS_+3A_nloci">nLoci</code></td>
<td>
<p>The number of loci in the profiles. Specifying this value
speeds up computation enormously.</p>
</td></tr>
<tr><td><code id="IBS_+3A_bprint">bPrint</code></td>
<td>
<p>If true then the result is printed locus by locus. This
feature exists primarily for debugging purposes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer between 0 and 2*nLoci representing the total number of
alleles that match in the two profiles.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P1 = randomProfile(fbiCaucs)
C1 = randomChild(P1, fbiCaucs)
IBS(P1, C1)
IBS(P1, C1, bPrint = TRUE)

</code></pre>

<hr>
<h2 id='IS'>Use importance sampling to determine the probability of m peaks from n contributors to a mixture</h2><span id='topic+IS'></span>

<h3>Description</h3>

<p>WARNING: This function is experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IS(
  Freqs,
  numContributors = 4,
  maxPeaks = NULL,
  numIterations = 100,
  bTail = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IS_+3A_freqs">Freqs</code></td>
<td>
<p>a set of allele frequencies. The format can be found in <code><a href="#topic+readFreqs">readFreqs</a></code></p>
</td></tr>
<tr><td><code id="IS_+3A_numcontributors">numContributors</code></td>
<td>
<p>the number of contributors to each mixture. Must be &gt;= 1.</p>
</td></tr>
<tr><td><code id="IS_+3A_maxpeaks">maxPeaks</code></td>
<td>
<p>either the number of peaks observed in the mixture or such that
1 &lt;=1 maxPeaks &lt;= min(2 * numContribuors, numAlleles). That is, if used
in this way maxPeaks must be between 1 and the smaller of twice the number of
contributors or the number of possible alleles because you cannot 
see more peaks than there are possible alleles.</p>
</td></tr>
<tr><td><code id="IS_+3A_numiterations">numIterations</code></td>
<td>
<p>the number of iterations to use in the importance sampling scheme.</p>
</td></tr>
<tr><td><code id="IS_+3A_btail">bTail</code></td>
<td>
<p>if <code>TRUE</code> then the tail probability is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with as many elements as loci. If tail probabilities are selected 
then each locus element will be a vector of probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(USCaucs)
IS(USCaucs, numContributors = 4, maxPeaks = 3, numIterations = 1e4)

## End(Not run)

</code></pre>

<hr>
<h2 id='locusIBS'>Identity by state at a locus</h2><span id='topic+locusIBS'></span>

<h3>Description</h3>

<p>Calculates the number of alleles that are shared by two profiles at a single
locus.  If the two profiles in question are indeed relatives then the
matching alleles may be identical by descent, or by random chance alone,
hence identity by state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locusIBS(profMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locusIBS_+3A_profmat">profMat</code></td>
<td>
<p>A matrix consisting of 4 columns and N rows. Each row in the
matrix consists of the genotypes of two individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length N containing values 0, 1, or 2 depending on how
many alleles each pair of profiles share at a locus.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
G = randomSample(1, fbiCaucs, rel = 'FS', N = 1000)
ibs = locusIBS(G)
barplot(tabulate(ibs+1, nbins = 3))

</code></pre>

<hr>
<h2 id='lrMix'>Calculate locuswise likelihood ratios for two person victim/suspect mixtures</h2><span id='topic+lrMix'></span>

<h3>Description</h3>

<p>Calculates the likelihood ratio for pairs of profiles under the propositions
<code class="reqn">H_p:\qquad V+S</code> and <code class="reqn">H_d:\qquad </code><code class="reqn"> V+U</code>, where <code class="reqn">V</code>, <code class="reqn">S</code> and <code class="reqn">U</code> are the victim, the
suspect and someone unrelated to the suspect respectively. The calculation
does not employ <code class="reqn">\theta</code> so there are no assumptions about the
subpopulations of the contributors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrMix(profiles, Freqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrMix_+3A_profiles">profiles</code></td>
<td>
<p>A vector of profile lists, from <code>randomProfilePairs</code>.
<code>randomPCPairs</code> and <code>randomSibPairs</code> also work but should not
really be used as the calculations do not take account of the relationship
between the two individuals.</p>
</td></tr>
<tr><td><code id="lrMix_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing elements <code>freqs</code>, <code>loci</code> and
<code>counts</code>. The element <code>freqs</code> is a list of vectors of allele
frequencies at the loci listed in <code>loci</code>. These frequencies are used to
evaluate the LR</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of LRs calculated at each locus for every pair of profiles.
Note this is the set of <code class="reqn">N</code> profile pairs supplied in
<code>profiles</code>, not a pairwise comparison.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USCaucs)
p = randomProfilePairs(USCaucs, 10000)
log.lrs = log10(lrMix(p, USCaucs))
boxplot(log.lrs, las = 2)

</code></pre>

<hr>
<h2 id='lrPC'>Likelihood Ratio for Parent-Child / Paternity Index</h2><span id='topic+lrPC'></span>

<h3>Description</h3>

<p>Calculates Likelihood Ratio comparing the probability of two profiles if
they are indeed parent-child compared to unrelated. This is the paternity
index or PI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrPC(parent, child, Freqs = NULL, nLoci = length(parent)/2, f = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrPC_+3A_parent">parent</code></td>
<td>
<p>A matrix consisting of 2 columns and nLoci rows. Each entry in
the matrix is the (coded) allele held by the individual. This represents the
alleged parent. The relationship is reflexive so it does not matter which
profile is labelled parent and child.</p>
</td></tr>
<tr><td><code id="lrPC_+3A_child">child</code></td>
<td>
<p>See <code>parent</code></p>
</td></tr>
<tr><td><code id="lrPC_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex. This argument or both f and n must be
specified</p>
</td></tr>
<tr><td><code id="lrPC_+3A_nloci">nLoci</code></td>
<td>
<p>The number of loci in the profiles</p>
</td></tr>
<tr><td><code id="lrPC_+3A_f">f</code></td>
<td>
<p>A concatenated vector of allele frequencies. Specifying this speeds
up computation enormously</p>
</td></tr>
<tr><td><code id="lrPC_+3A_n">n</code></td>
<td>
<p>A vector of length <code>nLoci</code> giving the number of alleles at
each locus. Specifying this in advance enormously speeds up computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value between 0 and infinity representing support (or lack of
support if the value is less than 1) for the hypothesis that the two
profiles are parent and child. There is no mutation built into this
calculation. This means that the LR will be zero if the profiles do not
share at least one allele in common at each locus in the multiplex.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>Buckleton, J, Triggs, C.M., and Walsh, S.J. (2005)<em>Forensic
DNA Evidence Interpretation</em>, CRC Press., Boca Raton, FL. p.410
</p>


<h3>See Also</h3>

<p>lrSib, IBS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P1 = randomProfile(fbiCaucs)
C1 = randomChild(P1, fbiCaucs)
lrPC(P1, C1, fbiCaucs)

</code></pre>

<hr>
<h2 id='lrSib'>Likelihood Ratio / Kinship Index for full-siblings</h2><span id='topic+lrSib'></span>

<h3>Description</h3>

<p>Calculates Likelihood Ratio comparing the probability of two profiles if
they are indeed full-sibs compared to unrelated. This is sometimes called
the kinship index (KI) for full-sibs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrSib(sib1, sib2, Freqs = NULL, nLoci = length(sib1)/2, f = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrSib_+3A_sib1">sib1</code></td>
<td>
<p>A matrix consisting of 2 columns and nLoci rows. Each entry in
the matrix is the (coded) allele held by the individual. This represents the
alleged sibling. The relationship is reflexive so it does not matter which
profile is labelled sib1 and sib2.</p>
</td></tr>
<tr><td><code id="lrSib_+3A_sib2">sib2</code></td>
<td>
<p>See <code>sib1</code></p>
</td></tr>
<tr><td><code id="lrSib_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex. This argument or both f and n must be
specified</p>
</td></tr>
<tr><td><code id="lrSib_+3A_nloci">nLoci</code></td>
<td>
<p>The number of loci in the profiles</p>
</td></tr>
<tr><td><code id="lrSib_+3A_f">f</code></td>
<td>
<p>A concatenated vector of allele frequencies. Specifying this speeds
up computation enormously</p>
</td></tr>
<tr><td><code id="lrSib_+3A_n">n</code></td>
<td>
<p>A vector of length <code>nLoci</code> giving the number of alleles at
each locus. Specifying this in advance enormously speeds up computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value between 0 and infinity representing support (or lack of
support if the value is less than 1) for the hypothesis that the two
profiles are full-siblings. There is no mutation built into this
calculation.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>Buckleton, J, Triggs, C.M., and Walsh, S.J. (2005)<em>Forensic
DNA Evidence Interpretation</em>, CRC Press., Boca Raton, FL. p.411
</p>


<h3>See Also</h3>

<p>lrSibDebug, lrPC, IBS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P1 = randomProfile(fbiCaucs)
S1 = randomSib(P1, fbiCaucs)
P2 = randomProfile(fbiCaucs)
lrSib(P1, S1, fbiCaucs)
lrSib(P1, P2, fbiCaucs)

</code></pre>

<hr>
<h2 id='lrSibDebug'>Likelihood Ratio / Kinship Index for full-siblings</h2><span id='topic+lrSibDebug'></span>

<h3>Description</h3>

<p>Calculates Likelihood Ratio comparing the probability of two profiles if
they are indeed full-sibs compared to unrelated. This is sometimes called
the kinship index (KI) for full-sibs. This function is identical to lrSib
except that the calculation is performed in R, and provides full calculation
detail at each locus. It exists primarily to check that the correct formula
and logic is being applied in the LR calculation so that the result can be
manually verified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrSibDebug(sib1, sib2, Freqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrSibDebug_+3A_sib1">sib1</code></td>
<td>
<p>A matrix consisting of 2 columns and nLoci rows. Each entry in
the matrix is the (coded) allele held by the individual. This represents the
alleged sibling. The relationship is reflexive so it does not matter which
profile is labelled sib1 and sib2.</p>
</td></tr>
<tr><td><code id="lrSibDebug_+3A_sib2">sib2</code></td>
<td>
<p>See <code>sib1</code></p>
</td></tr>
<tr><td><code id="lrSibDebug_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three elements Lines, lr, and Cases. Lines is a
list of strings containing the calculation at each locus so that the result
can be written to file for example. Cases is a numeric code listing which
logical case (1-11) the locus falls into for the profiles in question. lr is
the KI for full-sibs for the two profiles.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>Buckleton, J, Triggs, C.M., and Walsh, S.J. (2005)<em>Forensic
DNA Evidence Interpretation</em>, CRC Press., Boca Raton, FL. p.411
</p>


<h3>See Also</h3>

<p>lrSib, lrPC, IBS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P1 = randomProfile(fbiCaucs)
S1 = randomSib(P1, fbiCaucs)
P2 = randomProfile(fbiCaucs)
cat(paste(lrSibDebug(P1, S1, fbiCaucs)$Lines))
cat(paste(lrSibDebug(P1, P2, fbiCaucs)$Lines))

</code></pre>

<hr>
<h2 id='normalizeFreqs'>Normalize frequencies to 1</h2><span id='topic+normalizeFreqs'></span>

<h3>Description</h3>

<p>Normalize a list of frequencies at a series of genetic loci both sum to one.
Not that this does not deal with the problem of values larger than one or
smaller than zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeFreqs(Freqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeFreqs_+3A_freqs">Freqs</code></td>
<td>
<p>A list containg elements <code>loci</code> and <code>freqs</code>.
<code>freqs</code> is a list of vectors containing the frequencies at the given
loci.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Divides vector in Freqs$freqs by the vector sum.
</p>


<h3>Value</h3>

<p>A list containg elements <code>loci</code> and <code>freqs</code>. <code>freqs</code>
is a list of vectors containing the frequencies at the given loci.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>checkFreqs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)

## induce an error
fbiCaucs$freqs[[1]] = rgamma(10,1,1)
checkFreqs(fbiCaucs)
fbiCaucs = normalizeFreqs(fbiCaucs)
checkFreqs(fbiCaucs)

</code></pre>

<hr>
<h2 id='print.population'>Print summary details of a substructed population</h2><span id='topic+print.population'></span>

<h3>Description</h3>

<p>Nicely prints summary information about a substructured population created
using <code>breedFst</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'population'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.population_+3A_x">x</code></td>
<td>
<p>The population object to be printed</p>
</td></tr>
<tr><td><code id="print.population_+3A_...">...</code></td>
<td>
<p>Ignored - really should be passed to print, but given cat is
actually called they are ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>breedFst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
p = breedFst(fbiCaucs)
print(p)

</code></pre>

<hr>
<h2 id='print.profile'>Print a DNA profile</h2><span id='topic+print.profile'></span>

<h3>Description</h3>

<p>Nicely prints a profile object out in genotype pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile'
print(x, horizontal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.profile_+3A_x">x</code></td>
<td>
<p>The profile object to be printed</p>
</td></tr>
<tr><td><code id="print.profile_+3A_horizontal">horizontal</code></td>
<td>
<p>if <code>TRUE</code> then the profile will print on a single
line instead of multiple lines. Useful for comparing two profiles</p>
</td></tr>
<tr><td><code id="print.profile_+3A_...">...</code></td>
<td>
<p>Ignored - really should be passed to print, but given cat is
actually called they are ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P1 = randomProfile(fbiCaucs)
P2 = randomProfile(fbiCaucs)
P1
print(P1, horizontal = TRUE)
print(P2, horizontal = TRUE)

</code></pre>

<hr>
<h2 id='randomChild'>Generate a random child from a given DNA profile and a given set of allele
frequencies</h2><span id='topic+randomChild'></span>

<h3>Description</h3>

<p>Generates a random child (or parent) from a given DNA profile from a given
set of allele frequencies. At each locus, the child inherits the first
allele of the given profile with one half, or the second allele with
probability one half. The second allele is chosen at random with probability
proportional to the allele frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomChild(profile, Freqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomChild_+3A_profile">profile</code></td>
<td>
<p>A vector of length 2*nLoci. Each entry in the vector is the
(coded) allele held by the individual. This represents the parent. The
relationship is reflexive so it does not matter if the profile is a parent
or a child.</p>
</td></tr>
<tr><td><code id="randomChild_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alleles are simply integers rather than the STR repeat numbers. This
speeds up computation immensely when calculating any of the LRs or IBS.
</p>


<h3>Value</h3>

<p>A vector with 2*nLoci elements. Each pair of elements represents the
genotpe of the random individual at that locus. The genotype alleles are
always ordered so that allele1 &lt;= allele2.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>randomChild, randomSample, randomSib
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P1 = randomProfile(fbiCaucs)
C1 = randomChild(P1,fbiCaucs)
P1
C1

</code></pre>

<hr>
<h2 id='randomPCPairs'>Generate one or more random parent/child pairs from a given set of allele
frequencies</h2><span id='topic+randomPCPairs'></span>

<h3>Description</h3>

<p>Generates one or more pairs random parent/child pairs from a given set of
allele frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomPCPairs(Freqs, BlockSize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomPCPairs_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex.</p>
</td></tr>
<tr><td><code id="randomPCPairs_+3A_blocksize">BlockSize</code></td>
<td>
<p>The number of pairs of profiles to generate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alleles are simply integers rather than the STR repeat numbers. This
speeds up computation immensely when calculating any of the LRs or IBS.
</p>


<h3>Value</h3>

<p>A list of length <code>BlockSize</code>. Each element of the list has a
sublist containing two profiles called <code>parent</code> and <code>child</code>
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>randomSibPairs, randomProfilePairs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P = randomPCPairs(fbiCaucs)
P$parent
P$child

</code></pre>

<hr>
<h2 id='randomProfile'>Generate a random DNA profile from a given set of allele frequencies</h2><span id='topic+randomProfile'></span>

<h3>Description</h3>

<p>Generates a random DNA profile from a given set of allele frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomProfile(Freqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomProfile_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alleles are simply integers rather than the STR repeat numbers. This
speeds up computation immensely when calculating any of the LRs or IBS.
</p>


<h3>Value</h3>

<p>A vector with 2*nLoci elements. Each pair of elements represents the
genotpe of the random individual at that locus. The genotype alleles are
always ordered so that allele1 &lt;= allele2.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>randomChild, randomSample, randomSib
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P1 = randomProfile(fbiCaucs)

</code></pre>

<hr>
<h2 id='randomProfilePairs'>Generate one or more random DNA profile pairs from a given set of allele
frequencies</h2><span id='topic+randomProfilePairs'></span>

<h3>Description</h3>

<p>Generates one or more random DNA profile pairs from a given set of allele
frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomProfilePairs(Freqs, BlockSize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomProfilePairs_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex.</p>
</td></tr>
<tr><td><code id="randomProfilePairs_+3A_blocksize">BlockSize</code></td>
<td>
<p>The number of pairs of profiles to generate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alleles are simply integers rather than the STR repeat numbers. This
speeds up computation immensely when calculating any of the LRs or IBS.
</p>


<h3>Value</h3>

<p>A list of length <code>BlockSize</code>. Each element of the list has a
sublist containing two profiles called <code>prof1</code> and <code>prof2</code>
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>randomPCPairs, randomSibPairs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P = randomProfilePairs(fbiCaucs)
P$prof1
P$prof2

</code></pre>

<hr>
<h2 id='randomSample'>Generate a random sample of related (or unrelated) pairs of people</h2><span id='topic+randomSample'></span>

<h3>Description</h3>

<p>Generate a random sample of unrelated, full-sib, or parent/child pairs of
profiles at a single locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomSample(nLoc, Freqs, rel = "UN", N = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomSample_+3A_nloc">nLoc</code></td>
<td>
<p>The locus number to sample from</p>
</td></tr>
<tr><td><code id="randomSample_+3A_freqs">Freqs</code></td>
<td>
<p>A list containg elements <code>loci</code> and <code>freqs</code>.
<code>freqs</code> is a list of vectors containing the frequencies at the given
loci.</p>
</td></tr>
<tr><td><code id="randomSample_+3A_rel">rel</code></td>
<td>
<p>One of 'UN', 'FS', or 'PC' for unrelated, full-sib, or
parent/child pairs respectively.</p>
</td></tr>
<tr><td><code id="randomSample_+3A_n">N</code></td>
<td>
<p>The sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An N by 4 matrix of random profiles. The first two columns represent
the genotype of person one and the second two columns represent the genotype
of column two. Note that the random profiles do not use the orginal allele
designations.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>randomProfile, randomSib, randomChild
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
G = randomSample(1, fbiCaucs, "FS", 100)

</code></pre>

<hr>
<h2 id='randomSib'>Generate a random sibling from a given DNA profile and a given set of allele
frequencies</h2><span id='topic+randomSib'></span>

<h3>Description</h3>

<p>Generates a random sibling from a given DNA profile from a given set of
allele frequencies. At each locus, the sibling inherits the first allele of
the given profile with one quarter, or the second allele with probability
one quarter, both alleles with probability one quarter, or neither with
probability one quarter. If the sibling inherits zero or one identical
alleles, the missing alleles are chosen at random with probability
proportional to the allele frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomSib(profile, Freqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomSib_+3A_profile">profile</code></td>
<td>
<p>A vector consisting of 2*nLoci elements. Each element in the
vector is the (coded) allele held by the individual. This represents the
sibling.</p>
</td></tr>
<tr><td><code id="randomSib_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alleles are simply integers rather than the STR repeat numbers. This
speeds up computation immensely when calculating any of the LRs or IBS.
</p>


<h3>Value</h3>

<p>A vector with 2*nLoci elements. Each pair of elements represents the
genotpe of the random individual at that locus. The genotype alleles are
always ordered so that allele1 &lt;= allele2.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>randomChild, randomSample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P1 = randomProfile(fbiCaucs)
S1 = randomSib(P1,fbiCaucs)
P1
S1

</code></pre>

<hr>
<h2 id='randomSibPairs'>Generate one or more pairs of random siblings from a given set of allele
frequencies</h2><span id='topic+randomSibPairs'></span>

<h3>Description</h3>

<p>Generates one or more pairs of random siblings from a given set of allele
frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomSibPairs(Freqs, BlockSize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomSibPairs_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex.</p>
</td></tr>
<tr><td><code id="randomSibPairs_+3A_blocksize">BlockSize</code></td>
<td>
<p>The number of pairs of profiles to generate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alleles are simply integers rather than the STR repeat numbers. This
speeds up computation immensely when calculating any of the LRs or IBS.
</p>


<h3>Value</h3>

<p>A list of length <code>BlockSize</code>. Each element of the list has a
sublist containing two profiles called <code>sib1</code> and <code>sib2</code>
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>randomPCPairs, randomProfilePairs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
P = randomSibPairs(fbiCaucs)
P$sib1
P$sib2

</code></pre>

<hr>
<h2 id='readFreqs'>Read in a file of allele frequencies</h2><span id='topic+readFreqs'></span>

<h3>Description</h3>

<p>Reads in a file of alleles in a particular format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFreqs(strPath, FSIGenFormat = TRUE, delim = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFreqs_+3A_strpath">strPath</code></td>
<td>
<p>The file from which to read the frequencies</p>
</td></tr>
<tr><td><code id="readFreqs_+3A_fsigenformat">FSIGenFormat</code></td>
<td>
<p>Tells the function whether the file is either in FSI
Genetics format (see below) or 'Curran' format</p>
</td></tr>
<tr><td><code id="readFreqs_+3A_delim">delim</code></td>
<td>
<p>This argument is used when <code>FSIGenFormat</code> is <code>TRUE</code>,
and is the regular expression used to delimit columns of the table. it is
set to a single comma by default, and multiple delimiters are considered
empty separate fields. There probably should be an additional argument which
specifies the missing or empty cell symbol, but I won't programme this
unless somebody asks for it</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads frequencies in the rectangular allele freqency table
format used by FSI Genetics and other journals.  This file format assumes a
comma separated value file (CSV) (although the column delimeter can be
specified). The first column should be labelled 'Allele' and contain the STR
allele designations that are used in the data set. The remaining columns
will have the locus name as a header, and frequencies that are either blank,
zero, or non-zero.  Blanks or zeros are used to specify that the allele is
not observed (and not used) at the locus. The final row of the file should
start with 'N' or 'n' in the first column and give the number of individuals
typed (or the number of alleles recorded) in assessing the frequency of the
alleles.
</p>
<p>The second format is a very particular 'Curran' text format. The first line
contains the number of loci in the multiplex. The next line will contain the
name of the first locus and the number of alleles, nA, the locus separated
by a comma. The next nA lines contain the allele number (from 1 to nA), the
STR designation of the allele, and the frequency separated by commas. This
pattern is repeated for each locus. In the future this function will read
the rectangular allele freqency table used by FSI Genetics and other
journals.
</p>


<h3>Value</h3>

<p>a list containing two vectors and a list, loci, counts, and freqs.
The vector loci is a vector of the locus names in the frequency file. The
vector counts is a vector of the number of individuals (or sometimes
alleles) typed at each locus. This will null if the 'Curran' format is used.
The list freqs, is a list of vectors with each vector containing the
frequencies of the alleles at the locus. The names of the elements of the
vectors are the STR allele designations.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>

<hr>
<h2 id='readProfiles'>Read a set of profiles from a file</h2><span id='topic+readProfiles'></span>

<h3>Description</h3>

<p>Reads a set of profiles from a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProfiles(
  fileName,
  freqs = NULL,
  sep = "\t",
  header = FALSE,
  id = 1,
  discardMissing = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProfiles_+3A_filename">fileName</code></td>
<td>
<p>a path to the profile file.</p>
</td></tr>
<tr><td><code id="readProfiles_+3A_freqs">freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex. If this is left <code>NULL</code>, then it is calculated from 
the profile file.</p>
</td></tr>
<tr><td><code id="readProfiles_+3A_sep">sep</code></td>
<td>
<p>a character that delimits the fields in the profile file.</p>
</td></tr>
<tr><td><code id="readProfiles_+3A_header">header</code></td>
<td>
<p>a boolean which is <code>TRUE</code> if the profile file has a column header line.</p>
</td></tr>
<tr><td><code id="readProfiles_+3A_id">id</code></td>
<td>
<p>a column number indicating which column the profile id's are stored. If <code>id == -1</code>, then this means there is no id information.</p>
</td></tr>
<tr><td><code id="readProfiles_+3A_discardmissing">discardMissing</code></td>
<td>
<p>if <code>TRUE</code>, then all profiles which have alleles which cannot be matched to the frequency file are ommitted and returned
in the return list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alleles are recorded integers rather than the STR repeat numbers. This
speeds up computation immensely when calculating any of the LRs or IBS.
</p>


<h3>Value</h3>

<p>a list containing a <code>data.frame</code> of profiles where the alleles have been recoded 
to the allele index number, rather than the allele itself, and a set of frequencies in the same
format as you would get from <code><a href="#topic+readFreqs">readFreqs</a></code>. If <code>freqs</code> have been supplied, then this 
will just be the same set of frequencies, if they have not, then this will be calculated
from the profiles. Given that the profiles generally do not have any locus name information
the loci will just be labelled Locus1, Locus2, .... If there are missing values then the raw missing profiles are returned
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>

<hr>
<h2 id='readResults'>Read a simulation result set from file</h2><span id='topic+readResults'></span>

<h3>Description</h3>

<p>This function will read the output from <code>sim</code> that has been saved to
disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readResults(
  N = 0,
  rel = "UN",
  gzip = TRUE,
  strPath = "",
  strVer = "",
  fileName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readResults_+3A_n">N</code></td>
<td>
<p>The number of iterations in the simulation</p>
</td></tr>
<tr><td><code id="readResults_+3A_rel">rel</code></td>
<td>
<p>'UN' = unrelated, 'FS' = full-sib, 'PC' = parent-child</p>
</td></tr>
<tr><td><code id="readResults_+3A_gzip">gzip</code></td>
<td>
<p>If <code>TRUE</code> then it is assumed that the file is compressed</p>
</td></tr>
<tr><td><code id="readResults_+3A_strpath">strPath</code></td>
<td>
<p>Optional location of files. Must terminate with / otherwise
it will not work</p>
</td></tr>
<tr><td><code id="readResults_+3A_strver">strVer</code></td>
<td>
<p>A version string, useful if more than simulation has been run</p>
</td></tr>
<tr><td><code id="readResults_+3A_filename">fileName</code></td>
<td>
<p>This argument allows the user to override the default file
naming conventions of the result file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments to this file are used to generate the input file name. The
format is very rigid, being 'results-sim-rel-N(-strVer).csv(.gz)' That is,
if strVer is something than an empty string then it is included after the
number of interations. Similarly if <code>gzip == TRUE</code> then the filename is
assumed to end with '.gz'
</p>


<h3>Value</h3>

<p>a data frame with three columns labelled sib, pc, and ibs. These
represent the LRs for sibs and parent-child calculated on each simulated
profile pair, and the number of matching alleles (IBS).
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>sim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fbiCaucs)
## not run
## write the results of 100 unrelated profile pairs to
## results-sim-UN-100.csv.gz
## and read it back in
## Not run: 
sim(100, save = T)
unrel = readResults(100)
sim(100, rel = "FS", strVer = "01", save = T)
sibs = readResults(100, rel = "FS", strVer = "01")

## End(Not run)

</code></pre>

<hr>
<h2 id='relSim-package'>relSim: Relative Simulator</h2><span id='topic+relSim'></span><span id='topic+relSim-package'></span>

<h3>Description</h3>

<p>A set of tools to explore the behaviour statistics used for forensic DNA interpretation when close relatives are involved. The package also offers some useful tools for exploring other forensic DNA situations.
</p>

<hr>
<h2 id='sim'>Perform the relatives simulation</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>Generate N pairs with a given relationship and calculate the LR for sibs,
parent-child and the number of matching alleles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(
  N,
  Freqs,
  rel = "UN",
  save = FALSE,
  strPath = "",
  strVer = "",
  BlockSize = N/100,
  fileName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_+3A_n">N</code></td>
<td>
<p>The number of iterations to carry out</p>
</td></tr>
<tr><td><code id="sim_+3A_freqs">Freqs</code></td>
<td>
<p>A list containing two lists labelled loci and freqs. The second
list is a list of vectors containing the allele frequencies of each allele
at each locus in the multiplex.</p>
</td></tr>
<tr><td><code id="sim_+3A_rel">rel</code></td>
<td>
<p>generate unrelated (<code>rel = 'UN'</code>), full-sibs (<code>rel =
'FS'</code>), or parent child (<code>rel = 'PC'</code>) pairs</p>
</td></tr>
<tr><td><code id="sim_+3A_save">save</code></td>
<td>
<p>Write the results to disk if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="sim_+3A_strpath">strPath</code></td>
<td>
<p>Optional prefix to add to the results file path so that the
output location can be specified</p>
</td></tr>
<tr><td><code id="sim_+3A_strver">strVer</code></td>
<td>
<p>Optional suffix for the results file. This is useful when
running multiple instances of R</p>
</td></tr>
<tr><td><code id="sim_+3A_blocksize">BlockSize</code></td>
<td>
<p>Sets the number of random profiles to be generated in each
iteration. By default the block size is set to 1 percent of the total sample
size. It is unclear whether the procedure is more efficient if a bigger
percentage of the total is used. Users must take care to make sure that the
block size evenly divides <code>N</code> otherwise the procedure will exit</p>
</td></tr>
<tr><td><code id="sim_+3A_filename">fileName</code></td>
<td>
<p>This argument lets the user override the default result file
naming scheme</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the function that generates all the data for the results in the
paper. WARNING: this function is not especially fast. To achieve the 100
million iterations used in the paper, 30 instances of R were launched on a
multicore server. Each instance represented one relationship with 10 million
iterations. The compute time for this arrangement was approximately 1 hours,
meaning a full serial run would have taken over 30 hours to achieve the same
result.
</p>


<h3>Value</h3>

<p>a data frame with three columns: sib, pc, ibs containing the LRs for
full-siblings, parent-child, and the number of matching alleles for each
generated pair of profiles.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>readResults, errorRate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## not run
## this replicates Ge et al.'s experiment and takes about 45 minutes
## to run (I think)
## Not run: 
data(fbiCaucs)
N = 1000000
sim(N, fbiCaucs, save = T)
sim(N, fbiCaucs, 'FS', save = T)
sim(N, fbiCaucs, 'PC', save = T)

## End(Not run)

</code></pre>

<hr>
<h2 id='simNpersonMixture'>Simulate and count unique alleles in N person mixtures</h2><span id='topic+simNpersonMixture'></span>

<h3>Description</h3>

<p>This function simulates N persons mixtures using the supplied frequencies and records
the number of times they share 1, 2, ..., 2N alleles locus by locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simNpersonMixture(freqs, numContributors, numIterations = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simNpersonMixture_+3A_freqs">freqs</code></td>
<td>
<p>a set of allele frequencies. The format can be found in <code><a href="#topic+readFreqs">readFreqs</a></code></p>
</td></tr>
<tr><td><code id="simNpersonMixture_+3A_numcontributors">numContributors</code></td>
<td>
<p>the number of contributors to each mixture. Must be &gt;= 2.</p>
</td></tr>
<tr><td><code id="simNpersonMixture_+3A_numiterations">numIterations</code></td>
<td>
<p>the number of N person mixtures to simulate in total.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class npmresult
</p>

<hr>
<h2 id='toNexus'>Export a population with substructure to a Nexus file</h2><span id='topic+toNexus'></span>

<h3>Description</h3>

<p>Exports a population with population substructure to a Nexus formatted file
so that GDA can be used to check the Fst calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toNexus(Pop, fileName = "output.nex")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toNexus_+3A_pop">Pop</code></td>
<td>
<p>An object of type 'population' - see <code>breedFst</code> for a
description of the object</p>
</td></tr>
<tr><td><code id="toNexus_+3A_filename">fileName</code></td>
<td>
<p>The name of the file output file</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>Maddison DR, Swofford DL, Maddison WP (1997), NEXUS: An
extensible file format for systematic information, Systematic Biology 46
(4): 590&ndash;621.
</p>
<p>Zaykin, D. and Lewis, P., GDA - software to accompany Genetic Data Analysis
II, &lt;http://phylogeny.uconn.edu/software/&gt;.
</p>


<h3>See Also</h3>

<p>breedFst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Don't run
## Not run: 
data(USCaucs)
p = breedFst(USCaucs)
toNexus(p)

## End(Not run)

</code></pre>

<hr>
<h2 id='USCaucs'>CODIS STR Loci allele frequency data</h2><span id='topic+USCaucs'></span>

<h3>Description</h3>

<p>This data structure
</p>


<h3>Format</h3>

<p>This data set is a list which has two sub-lists. The lists are named
loci and freqs. loci is a vector of the 13 CODIS STR locus names. freqs is a
list of 13 vectors, each vector contains the allele frequencies published
for US Caucasians in Budowle and Moretti (1999).  The raw data is available
from
<a href="https://www.fbi.gov/about-us/lab/forensic-science-communications/fsc/july1999/dnaloci.txt">https://www.fbi.gov/about-us/lab/forensic-science-communications/fsc/july1999/dnaloci.txt</a>
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>References</h3>

<p>Budowle, B. and Moretti, T.R. (1999), <em>Genotype Profiles
for Six Population Groups at the 13 CODIS Short Tandem Repeat Core Loci and
Other PCR Based Loci</em>, Forensic Science Communications 1(2).
</p>


<h3>See Also</h3>

<p>fbiCaucs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USCaucs)
names(USCaucs)
USCaucs$loci
names(USCaucs$freqs)
USCaucs$freqs[[1]]
names(USCaucs$freqs[[1]])
USCaucs$freqs[[1]][1]
</code></pre>

<hr>
<h2 id='writeCSV'>Saves/writes population frequencies to disk</h2><span id='topic+writeCSV'></span>

<h3>Description</h3>

<p>Writes a population of profiles to disk using the original allele
designations rather than the internal integer representations that are used
for the other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCSV(fileName, pop, n = 100, delim = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeCSV_+3A_filename">fileName</code></td>
<td>
<p>the name and path where the population profiles are to be
saved to.</p>
</td></tr>
<tr><td><code id="writeCSV_+3A_pop">pop</code></td>
<td>
<p>a <code>list</code> containing elements <code>loci</code> and <code>freqs</code>. <code>loci</code>
is a vector with the loci in the data set. <code>freqs</code> is a list of vectors with elements
named after the elements in <code>loci</code>. Each locus in <code>freqs</code> is a vector of allele frequencies
with the allele names given by the named elements.
<code>TRUE</code> then an Amelogenin marker is added to the population, and all
the profiles are set to male XY, although this is coded to 1,2 to keep the
allele designations numeric.</p>
</td></tr>
<tr><td><code id="writeCSV_+3A_n">n</code></td>
<td>
<p>the number of people in the database. This is arbitrarily set to 100 by default.</p>
</td></tr>
<tr><td><code id="writeCSV_+3A_delim">delim</code></td>
<td>
<p>The allele delimiter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix which contains the table written to file.
</p>


<h3>Note</h3>

<p>Rare alleles are recoded to 108.1. This is unlikely to do the right thing
when you have things like &lt;5 or &gt;20 in your allele names. Given it is impossible to 
predict what a user would like to do, I suggest you recode them yourself before using
this function.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>breedFst USCaucs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USCaucs)
## Not run: 
  writeCSV("USCaucs.csv", USCaucs)

## End(Not run)

</code></pre>

<hr>
<h2 id='writePop'>Saves/writes population profiles to disk</h2><span id='topic+writePop'></span>

<h3>Description</h3>

<p>Writes a population of profiles to disk using the original allele
designations rather than the internal integer representations that are used
for the other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writePop(fileName, pop, addAmelo = FALSE, delim = ",", dupLoci = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writePop_+3A_filename">fileName</code></td>
<td>
<p>the name and path where the population profiles are to be
saved to.</p>
</td></tr>
<tr><td><code id="writePop_+3A_pop">pop</code></td>
<td>
<p>an object of class <code>population</code>, most likely produced by
<code>breedFst</code></p>
</td></tr>
<tr><td><code id="writePop_+3A_addamelo">addAmelo</code></td>
<td>
<p>The simulated populations do not have Amelogenin. If
<code>TRUE</code> then an Amelogenin marker is added to the population, and all
the profiles are set to male XY, although this is coded to 1,2 to keep the
allele designations numeric.</p>
</td></tr>
<tr><td><code id="writePop_+3A_delim">delim</code></td>
<td>
<p>The allele delimiter.</p>
</td></tr>
<tr><td><code id="writePop_+3A_duploci">dupLoci</code></td>
<td>
<p>If <code>TRUE</code> the locus names are written twice in the header, otherwise just once.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Rare alleles are recoded to 108.1.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>breedFst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USCaucs)
pop = breedFst(USCaucs)
## Not run: 
  writePop("USCaucs.csv", pop)
  
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
