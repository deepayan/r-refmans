<!DOCTYPE html><html lang="en"><head><title>Help for package pintervals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pintervals}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pintervals-package'><p>pintervals: Model Agnostic Prediction Intervals</p></a></li>
<li><a href='#abs_error'><p>Absolute Error</p></a></li>
<li><a href='#bin_chopper'><p>Bin chopper function for binned bootstrapping</p></a></li>
<li><a href='#bindividual_alpha'><p>Bin-individual alpha function for conformal prediction</p></a></li>
<li><a href='#bootstrap_inner'><p>Bootstrap function for bootstrapping the prediction intervals</p></a></li>
<li><a href='#contiguize_intervals'><p>Contiguize non-contiguous intervals</p></a></li>
<li><a href='#flatten_cp_bin_intervals'><p>Flatten binned conformal prediction intervals to contiguous intervals</p></a></li>
<li><a href='#grid_finder'><p>Grid search for lower and upper bounds of continuous conformal prediction intervals</p></a></li>
<li><a href='#grid_inner'><p>Inner function for grid search</p></a></li>
<li><a href='#minq_to_alpha'><p>Helper for minimum quantile to alpha function</p></a></li>
<li><a href='#pinterval_boot_bins'><p>Bin-conditional bootstrap prediction intervals</p></a></li>
<li><a href='#pinterval_bootstrap'><p>Bootstrap prediction intervals</p></a></li>
<li><a href='#pinterval_cp_bins'><p>Bin-conditional conformal prediction intervals for continuous predictions</p></a></li>
<li><a href='#pinterval_cp_cont'><p>Continuous Conformal Prediction Intervals</p></a></li>
<li><a href='#pinterval_parametric'><p>Parametric prediction intervals for continuous predictions</p></a></li>
<li><a href='#weights_calculator'><p>Weights calculator for weighted conformal prediction</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model Agnostic Prediction Intervals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for estimating model-agnostic prediction intervals using conformal   prediction, bootstrapping, and parametric prediction intervals. The package is designed for ease of use, offering intuitive functions for both binned and full conformal prediction methods, as well as parametric interval estimation with diagnostic checks. Currently only working for continuous predictions. For details on the conformal and bin-conditional conformal prediction methods, see Randahl, Williams, and Hegre (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2410.14507">doi:10.48550/arXiv.2410.14507</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, foreach, tibble</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-03 15:10:43 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Randahl [aut, cre],
  Jonathan P. Wiliams [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Randahl &lt;david.randahl@pcr.uu.se&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-05 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pintervals-package'>pintervals: Model Agnostic Prediction Intervals</h2><span id='topic+pintervals'></span><span id='topic+pintervals-package'></span>

<h3>Description</h3>

<p>Provides tools for estimating model-agnostic prediction intervals using conformal prediction, bootstrapping, and parametric prediction intervals. The package is designed for ease of use, offering intuitive functions for both binned and full conformal prediction methods, as well as parametric interval estimation with diagnostic checks. Currently only working for continuous predictions. For details on the conformal and bin-conditional conformal prediction methods, see Randahl, Williams, and Hegre (2024) <a href="https://doi.org/10.48550/arXiv.2410.14507">doi:10.48550/arXiv.2410.14507</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Randahl <a href="mailto:david.randahl@pcr.uu.se">david.randahl@pcr.uu.se</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Jonathan P. Wiliams [contributor]
</p>
</li></ul>


<hr>
<h2 id='abs_error'>Absolute Error</h2><span id='topic+abs_error'></span>

<h3>Description</h3>

<p>Absolute Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_error(pred, truth)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abs_error_+3A_pred">pred</code></td>
<td>
<p>a numeric vector of predicted values</p>
</td></tr>
<tr><td><code id="abs_error_+3A_truth">truth</code></td>
<td>
<p>a numeric vector of true values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of absolute errors
</p>

<hr>
<h2 id='bin_chopper'>Bin chopper function for binned bootstrapping</h2><span id='topic+bin_chopper'></span>

<h3>Description</h3>

<p>Bin chopper function for binned bootstrapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_chopper(x, nbins, return_breaks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin_chopper_+3A_x">x</code></td>
<td>
<p>vector of values to be binned</p>
</td></tr>
<tr><td><code id="bin_chopper_+3A_nbins">nbins</code></td>
<td>
<p>number of bins</p>
</td></tr>
<tr><td><code id="bin_chopper_+3A_return_breaks">return_breaks</code></td>
<td>
<p>logical indicating whether to return the bin breaks</p>
</td></tr>
</table>

<hr>
<h2 id='bindividual_alpha'>Bin-individual alpha function for conformal prediction</h2><span id='topic+bindividual_alpha'></span>

<h3>Description</h3>

<p>Bin-individual alpha function for conformal prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bindividual_alpha(minqs, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bindividual_alpha_+3A_minqs">minqs</code></td>
<td>
<p>Minimum quantiles</p>
</td></tr>
<tr><td><code id="bindividual_alpha_+3A_alpha">alpha</code></td>
<td>
<p>alpha level</p>
</td></tr>
</table>

<hr>
<h2 id='bootstrap_inner'>Bootstrap function for bootstrapping the prediction intervals</h2><span id='topic+bootstrap_inner'></span>

<h3>Description</h3>

<p>Bootstrap function for bootstrapping the prediction intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_inner(pred, error, nboot, alpha, lower_bound, upper_bound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_inner_+3A_pred">pred</code></td>
<td>
<p>predicted value</p>
</td></tr>
<tr><td><code id="bootstrap_inner_+3A_error">error</code></td>
<td>
<p>vector of errors</p>
</td></tr>
<tr><td><code id="bootstrap_inner_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap samples</p>
</td></tr>
<tr><td><code id="bootstrap_inner_+3A_alpha">alpha</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="bootstrap_inner_+3A_lower_bound">lower_bound</code></td>
<td>
<p>lower bound of the prediction interval</p>
</td></tr>
<tr><td><code id="bootstrap_inner_+3A_upper_bound">upper_bound</code></td>
<td>
<p>upper bound of the prediction interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with the predicted value and the lower and upper bounds of the prediction interval
</p>

<hr>
<h2 id='contiguize_intervals'>Contiguize non-contiguous intervals</h2><span id='topic+contiguize_intervals'></span>

<h3>Description</h3>

<p>Contiguize non-contiguous intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contiguize_intervals(
  pot_lower_bounds,
  pot_upper_bounds,
  empirical_lower_bounds,
  empirical_upper_bounds,
  return_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contiguize_intervals_+3A_pot_lower_bounds">pot_lower_bounds</code></td>
<td>
<p>Potential non-contiguous lower bounds</p>
</td></tr>
<tr><td><code id="contiguize_intervals_+3A_pot_upper_bounds">pot_upper_bounds</code></td>
<td>
<p>Potential non-contiguous upper bounds</p>
</td></tr>
<tr><td><code id="contiguize_intervals_+3A_empirical_lower_bounds">empirical_lower_bounds</code></td>
<td>
<p>Observed lower bounds</p>
</td></tr>
<tr><td><code id="contiguize_intervals_+3A_empirical_upper_bounds">empirical_upper_bounds</code></td>
<td>
<p>Observed upper bounds</p>
</td></tr>
<tr><td><code id="contiguize_intervals_+3A_return_all">return_all</code></td>
<td>
<p>Return all intervals or just contiguous intervals</p>
</td></tr>
</table>

<hr>
<h2 id='flatten_cp_bin_intervals'>Flatten binned conformal prediction intervals to contiguous intervals</h2><span id='topic+flatten_cp_bin_intervals'></span>

<h3>Description</h3>

<p>Flatten binned conformal prediction intervals to contiguous intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_cp_bin_intervals(lst, contiguize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatten_cp_bin_intervals_+3A_lst">lst</code></td>
<td>
<p>list of binned conformal prediction intervals</p>
</td></tr>
<tr><td><code id="flatten_cp_bin_intervals_+3A_contiguize">contiguize</code></td>
<td>
<p>logical indicating whether to contiguize the intervals</p>
</td></tr>
</table>

<hr>
<h2 id='grid_finder'>Grid search for lower and upper bounds of continuous conformal prediction intervals</h2><span id='topic+grid_finder'></span>

<h3>Description</h3>

<p>Grid search for lower and upper bounds of continuous conformal prediction intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_finder(
  y_min,
  y_max,
  ncs,
  ncs_function,
  y_hat,
  alpha,
  min_step = NULL,
  grid_size = NULL,
  return_min_q = FALSE,
  weighted_cp = FALSE,
  calib = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_finder_+3A_y_min">y_min</code></td>
<td>
<p>minimum value to search</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_y_max">y_max</code></td>
<td>
<p>maximum value to search</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_ncs">ncs</code></td>
<td>
<p>vector of non-conformity scores</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_ncs_function">ncs_function</code></td>
<td>
<p>a function that takes a vector of predicted values and a vector of true values and returns a vector of non-conformity scores</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_y_hat">y_hat</code></td>
<td>
<p>vector of predicted values</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_alpha">alpha</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_min_step">min_step</code></td>
<td>
<p>The minimum step size for the grid search</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_grid_size">grid_size</code></td>
<td>
<p>Alternative to min_step, the number of points to use in the grid search between the lower and upper bound</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_return_min_q">return_min_q</code></td>
<td>
<p>logical. If TRUE, the function will return the minimum quantile of the nonconformity scores for each predicted value</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_weighted_cp">weighted_cp</code></td>
<td>
<p>logical. If TRUE, the function will use the weighted conformal prediction method. Default is FALSE</p>
</td></tr>
<tr><td><code id="grid_finder_+3A_calib">calib</code></td>
<td>
<p>a tibble with the predicted values and the true values of the calibration partition. Used when weighted_cp is TRUE. Default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with the predicted values and the lower and upper bounds of the prediction intervals
</p>

<hr>
<h2 id='grid_inner'>Inner function for grid search</h2><span id='topic+grid_inner'></span>

<h3>Description</h3>

<p>Inner function for grid search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_inner(
  hyp_ncs,
  y_hat,
  ncs,
  pos_vals,
  alpha,
  return_min_q = FALSE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_inner_+3A_hyp_ncs">hyp_ncs</code></td>
<td>
<p>vector of hypothetical non-conformity scores</p>
</td></tr>
<tr><td><code id="grid_inner_+3A_y_hat">y_hat</code></td>
<td>
<p>predicted value</p>
</td></tr>
<tr><td><code id="grid_inner_+3A_ncs">ncs</code></td>
<td>
<p>vector of non-conformity scores</p>
</td></tr>
<tr><td><code id="grid_inner_+3A_pos_vals">pos_vals</code></td>
<td>
<p>vector of possible values for the lower and upper bounds of the prediction interval</p>
</td></tr>
<tr><td><code id="grid_inner_+3A_alpha">alpha</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="grid_inner_+3A_return_min_q">return_min_q</code></td>
<td>
<p>logical. If TRUE, the function will return the minimum quantile of the nonconformity scores for each predicted value</p>
</td></tr>
<tr><td><code id="grid_inner_+3A_weights">weights</code></td>
<td>
<p>vector of weights for the weighted conformal prediction method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with the predicted value and the lower and upper bounds of the prediction interval
</p>

<hr>
<h2 id='minq_to_alpha'>Helper for minimum quantile to alpha function</h2><span id='topic+minq_to_alpha'></span>

<h3>Description</h3>

<p>Helper for minimum quantile to alpha function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minq_to_alpha(minq, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minq_to_alpha_+3A_minq">minq</code></td>
<td>
<p>minimum quantile</p>
</td></tr>
<tr><td><code id="minq_to_alpha_+3A_alpha">alpha</code></td>
<td>
<p>alpha level</p>
</td></tr>
</table>

<hr>
<h2 id='pinterval_boot_bins'>Bin-conditional bootstrap prediction intervals</h2><span id='topic+pinterval_boot_bins'></span>

<h3>Description</h3>

<p>This function computes bootstrapped prediction intervals with a confidence level of 1-alpha for a vector of (continuous) predicted values using bin-conditional bootstrapped prediction errors. The prediction errors to bootstrap from are computed using either a calibration set with predicted and true values or a set of pre-computed prediction errors from a calibration dataset or other data which the model was not trained on (e.g. OOB errors from a model using bagging). The function returns a tibble containing the predicted values along with the lower and upper bounds of the prediction intervals.
</p>
<p>Currently not working as intended. May be removed in future versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinterval_boot_bins(
  pred,
  calib,
  calib_truth = NULL,
  calib_bins = NULL,
  breaks = NULL,
  nbins = NULL,
  calib_bin_type = c("prediction", "truth"),
  error_type = c("raw", "absolute"),
  alpha = 0.1,
  n_bootstraps = 1000,
  lower_bound = NULL,
  upper_bound = NULL,
  right = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pinterval_boot_bins_+3A_pred">pred</code></td>
<td>
<p>Vector of predicted values</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_calib">calib</code></td>
<td>
<p>A numeric vector of predicted values in the calibration partition or a 2 column tibble or matrix with the first column being the predicted values and the second column being the truth values</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_calib_truth">calib_truth</code></td>
<td>
<p>A numeric vector of true values in the calibration partition. Only required if calib is a numeric vector</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_calib_bins">calib_bins</code></td>
<td>
<p>A vector of bin identifiers for the calibration set</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_breaks">breaks</code></td>
<td>
<p>A vector of break points for the bins to manually define the bins. If NULL, lower and upper bounds of the bins are calculated as the minimum and maximum values of each bin in the calibration set. Must be provided if calib_bins or nbins are not provided, either as a vector or as the last column of a calib tibble.</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_nbins">nbins</code></td>
<td>
<p>Automatically chop the calibration set into nbins based on the true values with approximately equal number of observations in each bin. Must be provided if calib_bins or breaks are not provided.</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_calib_bin_type">calib_bin_type</code></td>
<td>
<p>A string specicying whether the bins are based on the predicted values ('prediction') or the true values ('truth'). Default is 'prediction'. Ignored if calib_bins is provided.</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_error_type">error_type</code></td>
<td>
<p>The type of error to use for the prediction intervals. Can be 'raw' or 'absolute'. If 'raw', bootstrapping will be done on the raw prediction errors. If 'absolute', bootstrapping will be done on the absolute prediction errors with random signs. Default is 'raw'</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_alpha">alpha</code></td>
<td>
<p>The confidence level for the prediction intervals. Must be a single numeric value between 0 and 1</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_n_bootstraps">n_bootstraps</code></td>
<td>
<p>The number of bootstraps to perform. Default is 1000</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Optional minimum value for the prediction intervals. If not provided, the minimum (true) value of the calibration partition will be used</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Optional maximum value for the prediction intervals. If not provided, the maximum (true) value of the calibration partition will be used</p>
</td></tr>
<tr><td><code id="pinterval_boot_bins_+3A_right">right</code></td>
<td>
<p>Parameter passed to cut function to determine which side of the bin interval is closed. Default is TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='pinterval_bootstrap'>Bootstrap prediction intervals</h2><span id='topic+pinterval_bootstrap'></span>

<h3>Description</h3>

<p>This function computes bootstrapped prediction intervals with a confidence level of 1-alpha for a vector of (continuous) predicted values using bootstrapped prediction errors. The prediction errors to bootstrap from are computed using either a calibration set with predicted and true values or a set of pre-computed prediction errors from a calibration dataset or other data which the model was not trained on (e.g. OOB errors from a model using bagging). The function returns a tibble containing the predicted values along with the lower and upper bounds of the prediction intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinterval_bootstrap(
  pred,
  calib = NULL,
  calib_truth = NULL,
  error = NULL,
  error_type = c("raw", "absolute"),
  alpha = 0.1,
  n_bootstraps = 1000,
  lower_bound = NULL,
  upper_bound = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pinterval_bootstrap_+3A_pred">pred</code></td>
<td>
<p>Vector of predicted values</p>
</td></tr>
<tr><td><code id="pinterval_bootstrap_+3A_calib">calib</code></td>
<td>
<p>A numeric vector of predicted values in the calibration partition or a 2 column tibble or matrix with the first column being the predicted values and the second column being the truth values</p>
</td></tr>
<tr><td><code id="pinterval_bootstrap_+3A_calib_truth">calib_truth</code></td>
<td>
<p>A numeric vector of true values in the calibration partition. Only required if calib is a numeric vector</p>
</td></tr>
<tr><td><code id="pinterval_bootstrap_+3A_error">error</code></td>
<td>
<p>An optional numeric vector of pre-computed prediction errors from a calibration partition or other test data. If provided, calib will be ignored</p>
</td></tr>
<tr><td><code id="pinterval_bootstrap_+3A_error_type">error_type</code></td>
<td>
<p>The type of error to use for the prediction intervals. Can be 'raw' or 'absolute'. If 'raw', bootstrapping will be done on the raw prediction errors. If 'absolute', bootstrapping will be done on the absolute prediction errors with random signs. Default is 'raw'</p>
</td></tr>
<tr><td><code id="pinterval_bootstrap_+3A_alpha">alpha</code></td>
<td>
<p>The confidence level for the prediction intervals. Must be a single numeric value between 0 and 1</p>
</td></tr>
<tr><td><code id="pinterval_bootstrap_+3A_n_bootstraps">n_bootstraps</code></td>
<td>
<p>The number of bootstraps to perform. Default is 1000</p>
</td></tr>
<tr><td><code id="pinterval_bootstrap_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Optional minimum value for the prediction intervals. If not provided, the minimum (true) value of the calibration partition will be used</p>
</td></tr>
<tr><td><code id="pinterval_bootstrap_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Optional maximum value for the prediction intervals. If not provided, the maximum (true) value of the calibration partition will be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the predicted values, lower bounds, and upper bounds of the prediction intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(tibble)
x1 &lt;- runif(1000)
x2 &lt;- runif(1000)
y &lt;- rlnorm(1000, meanlog = x1 + x2, sdlog = 0.5)
df &lt;- tibble(x1, x2, y)
df_train &lt;- df %&gt;% slice(1:500)
df_cal &lt;- df %&gt;% slice(501:750)
df_test &lt;- df %&gt;% slice(751:1000)
mod &lt;- lm(log(y) ~ x1 + x2, data=df_train)
calib &lt;- exp(predict(mod, newdata=df_cal))
calib_truth &lt;- df_cal$y
pred_test &lt;- exp(predict(mod, newdata=df_test))

pinterval_bootstrap(pred = pred_test,
calib = calib,
calib_truth = calib_truth,
error_type = 'raw',
alpha = 0.1,
lower_bound = 0)
</code></pre>

<hr>
<h2 id='pinterval_cp_bins'>Bin-conditional conformal prediction intervals for continuous predictions</h2><span id='topic+pinterval_cp_bins'></span>

<h3>Description</h3>

<p>This function calculates bin-conditional conformal prediction intervals with a confidence level of 1-alpha for a vector of (continuous) predicted values using inductive conformal prediction on a bin-by-bin basis. The intervals are computed using either a calibration set with predicted and true values or a set of pre-computed non-conformity scores from the calibration set. In addition the function requires either a set of breaks or a vector of bin identifiers for the calibrations set, either as a standalone vector or as the third column of the calibration dataset if the calibration data is provided as a tibble. The function returns a tibble containing the predicted values along with the lower and upper bounds of the prediction intervals. Bin-conditional conformal prediction intervals are useful when the prediction error is not constant across the range of predicted values and ensures that the coverage is (approximately) correct for each bin under the assumption that the non-conformity scores are exchangeable within each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinterval_cp_bins(
  pred,
  calib = NULL,
  calib_truth = NULL,
  calib_bins = NULL,
  breaks = NULL,
  nbins = NULL,
  alpha = 0.1,
  ncs_function = "absolute_error",
  ncs = NULL,
  min_step = 0.01,
  grid_size = NULL,
  right = TRUE,
  weighted_cp = FALSE,
  contiguize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pinterval_cp_bins_+3A_pred">pred</code></td>
<td>
<p>Vector of predicted values</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_calib">calib</code></td>
<td>
<p>A numeric vector of predicted values in the calibration partition or a 2 or 3 column tibble or matrix with the first column being the predicted values and the second column being the truth values and (optionally) the third column being the bin values if bins are not provided as a standalone vector or if breaks are not provided</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_calib_truth">calib_truth</code></td>
<td>
<p>A numeric vector of true values in the calibration partition</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_calib_bins">calib_bins</code></td>
<td>
<p>A vector of bin identifiers for the calibration set</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_breaks">breaks</code></td>
<td>
<p>A vector of break points for the bins to manually define the bins. If NULL, lower and upper bounds of the bins are calculated as the minimum and maximum values of each bin in the calibration set. Must be provided if calib_bins or nbins are not provided, either as a vector or as the last column of a calib tibble.</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_nbins">nbins</code></td>
<td>
<p>Automatically chop the calibration set into nbins based on the true values with approximately equal number of observations in each bin. Must be provided if calib_bins or breaks are not provided.</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_alpha">alpha</code></td>
<td>
<p>The confidence level for the prediction intervals. Must be a single numeric value between 0 and 1</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_ncs_function">ncs_function</code></td>
<td>
<p>A function or a character string matching a function that takes two arguments, a vector of predicted values and a vector of true values, in that order. The function should return a numeric vector of nonconformity scores. Default is 'absolute_error' which returns the absolute difference between the predicted and true values.</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_ncs">ncs</code></td>
<td>
<p>An optional numeric vector of pre-computed nonconformity scores from a calibration partition. If provided, calib will be ignored. If provided, bins must be provided in calib_bins and breaks as well.</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_min_step">min_step</code></td>
<td>
<p>The minimum step size for the grid search. Default is 0.01. Useful to change if predictions are made on a discrete grid or if the resolution of the interval is too coarse or too fine.</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_grid_size">grid_size</code></td>
<td>
<p>Alternative to min_step, the number of points to use in the grid search between the lower and upper bound. If provided, min_step will be ignored.</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_right">right</code></td>
<td>
<p>Logical, if TRUE the bins are right-closed (a,b] and if FALSE the bins are left-closed '[ a,b)'. Only used if breaks or nbins are provided.</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_weighted_cp">weighted_cp</code></td>
<td>
<p>Logical, if TRUE the prediction intervals are created by bootstrapping the ncs scores giving a higher weight to the ncs scores that are closer to the predicted value. Default is FALSE. Experimental, so use with caution.</p>
</td></tr>
<tr><td><code id="pinterval_cp_bins_+3A_contiguize">contiguize</code></td>
<td>
<p>logical indicating whether to contiguize the intervals. TRUE will consider all bins for each prediction using the lower and upper endpoints as interval limits to avoid non-contiguous intervals. FALSE will allows for non-contiguous intervals. TRUE guarantees at least appropriate coverage in each bin, but may suffer from over-coverage in certain bins. FALSE will have appropriate coverage in each bin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the predicted values, the lower and upper bounds of the prediction intervals. If treat_noncontiguous is 'non_contiguous', the lower and upper bounds are set in a list variable called 'intervals' where all non-contiguous intervals are stored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)
x1 &lt;- runif(1000)
x2 &lt;- runif(1000)
y &lt;- rlnorm(1000, meanlog = x1 + x2, sdlog = 0.5)
	bin &lt;- cut(y, breaks = quantile(y, probs = seq(0, 1, 1/4)),
	include.lowest = TRUE, labels =FALSE)
df &lt;- tibble(x1, x2, y, bin)
df_train &lt;- df %&gt;% slice(1:500)
df_cal &lt;- df %&gt;% slice(501:750)
df_test &lt;- df %&gt;% slice(751:1000)
mod &lt;- lm(log(y) ~ x1 + x2, data=df_train)
calib &lt;- exp(predict(mod, newdata=df_cal))
calib_truth &lt;- df_cal$y
calib_bins &lt;- df_cal$bin
pred_test &lt;- exp(predict(mod, newdata=df_test))

pinterval_cp_bins(pred = pred_test,
calib = calib,
calib_truth = calib_truth,
calib_bins = calib_bins,
alpha = 0.1,
grid_size = 10000)

</code></pre>

<hr>
<h2 id='pinterval_cp_cont'>Continuous Conformal Prediction Intervals</h2><span id='topic+pinterval_cp_cont'></span>

<h3>Description</h3>

<p>This function calculates conformal prediction intervals with a confidence level of 1-alpha for a vector of (continuous) predicted values using inductive conformal prediction. The intervals are computed using either a calibration set with predicted and true values or a set of pre-computed non-conformity scores from the calibration set. The function returns a tibble containing the predicted values along with the lower and upper bounds of the prediction intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinterval_cp_cont(
  pred,
  calib = NULL,
  calib_truth = NULL,
  alpha = 0.1,
  ncs_function = "absolute_error",
  weighted_cp = FALSE,
  ncs = NULL,
  lower_bound = NULL,
  upper_bound = NULL,
  min_step = 0.01,
  grid_size = NULL,
  return_min_q = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pinterval_cp_cont_+3A_pred">pred</code></td>
<td>
<p>Vector of predicted values</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_calib">calib</code></td>
<td>
<p>A numeric vector of predicted values in the calibration partition or a 2 column tibble or matrix with the first column being the predicted values and the second column being the truth values</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_calib_truth">calib_truth</code></td>
<td>
<p>A numeric vector of true values in the calibration partition. Only required if calib is a numeric vector</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_alpha">alpha</code></td>
<td>
<p>The confidence level for the prediction intervals. Must be a single numeric value between 0 and 1</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_ncs_function">ncs_function</code></td>
<td>
<p>A function or a character string matching a function that takes two arguments, a vector of predicted values and a vector of true values, in that order. The function should return a numeric vector of nonconformity scores. Default is 'absolute_error' which returns the absolute difference between the predicted and true values.</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_weighted_cp">weighted_cp</code></td>
<td>
<p>Logical. If TRUE, the function will use weighted conformal prediction. Default is FALSE. Experimental.</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_ncs">ncs</code></td>
<td>
<p>A numeric vector of pre-computed nonconformity scores from a calibration partition. If provided, calib will be ignored</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Optional minimum value for the prediction intervals. If not provided, the minimum (true) value of the calibration partition will be used</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Optional maximum value for the prediction intervals. If not provided, the maximum (true) value of the calibration partition will be used</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_min_step">min_step</code></td>
<td>
<p>The minimum step size for the grid search. Default is 0.01. Useful to change if predictions are made on a discrete grid or if the resolution of the interval is too coarse or too fine.</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_grid_size">grid_size</code></td>
<td>
<p>Alternative to min_step, the number of points to use in the grid search between the lower and upper bound. If provided, min_step will be ignored.</p>
</td></tr>
<tr><td><code id="pinterval_cp_cont_+3A_return_min_q">return_min_q</code></td>
<td>
<p>Logical. If TRUE, the function will return the minimum quantile of the nonconformity scores for each predicted value. Default is FALSE. Primarily used for debugging purposes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the predicted values and the lower and upper bounds of the prediction intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)
x1 &lt;- runif(1000)
x2 &lt;- runif(1000)
y &lt;- rlnorm(1000, meanlog = x1 + x2, sdlog = 0.5)
df &lt;- tibble(x1, x2, y)
df_train &lt;- df %&gt;% slice(1:500)
df_cal &lt;- df %&gt;% slice(501:750)
df_test &lt;- df %&gt;% slice(751:1000)
mod &lt;- lm(log(y) ~ x1 + x2, data=df_train)
calib &lt;- exp(predict(mod, newdata=df_cal))
calib_truth &lt;- df_cal$y
pred_test &lt;- exp(predict(mod, newdata=df_test))

pinterval_cp_cont(pred_test,
calib = calib,
calib_truth = calib_truth,
alpha = 0.1,
lower_bound = 0,
grid_size = 10000)

</code></pre>

<hr>
<h2 id='pinterval_parametric'>Parametric prediction intervals for continuous predictions</h2><span id='topic+pinterval_parametric'></span>

<h3>Description</h3>

<p>This function computes parametric prediction intervals with a confidence level of 1-alpha for a vector of (continuous) predicted values using a user specified parametric distribution and parameters. The distribution can be any distribution available in R or a user defined distribution as long as a quantile function is available. The parameters should be estimated on calibration data. The prediction intervals are calculated as the quantiles of the distribution at the specified confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinterval_parametric(
  pred,
  dist = c("norm", "lnorm", "pois", "nbinom", "gamma", "logis", "beta"),
  pars = list(),
  alpha = 0.1,
  lower_bound = NULL,
  upper_bound = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pinterval_parametric_+3A_pred">pred</code></td>
<td>
<p>Vector of predicted values</p>
</td></tr>
<tr><td><code id="pinterval_parametric_+3A_dist">dist</code></td>
<td>
<p>Distribution to use for the prediction intervals. Can be a character string matching any available distribution in R or a function representing a distribution. If a function is provided, it must be a quantile function (e.g. qnorm, qgamma, etc.)</p>
</td></tr>
<tr><td><code id="pinterval_parametric_+3A_pars">pars</code></td>
<td>
<p>List of named parameters for the distribution for each prediction. See details for more information.</p>
</td></tr>
<tr><td><code id="pinterval_parametric_+3A_alpha">alpha</code></td>
<td>
<p>The confidence level for the prediction intervals. Must be a single numeric value between 0 and 1</p>
</td></tr>
<tr><td><code id="pinterval_parametric_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Optional minimum value for the prediction intervals. If not provided, the minimum (true) value of the calibration partition will be used</p>
</td></tr>
<tr><td><code id="pinterval_parametric_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Optional maximum value for the prediction intervals. If not provided, the maximum (true) value of the calibration partition will be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distributions are not limited to the standard distributions available in R. Any distribution can be used as long as a quantile function is available. Users may create their own distribution functions and plug in the resulting quantile function or create compositie or mixture distributions using for instance the package 'mistr' and plug in the resulting quantile function.
</p>
<p>The list of parameters should be constructed such that when the distribution function is called with the parameters, it returns a vector of the same length as the predictions. In most cases the parameters should ensure that the predicted value corresponds to the mean, median, or mode of the resulting distribution. Parameters relating to the prediction error should be estimated on calibration data. For example, if normal prediction intervals are desired, the mean parameter should be the predicted value and the standard deviation parameter should be the estimated standard deviation of the prediction errors in the calibration set. If the distribution is a negative binomial distribution with a fixed size parameter, the size parameter should be estimated on the calibration data and the mu parameter should be the predicted value.
</p>


<h3>Value</h3>

<p>A tibble with the predicted values and the lower and upper bounds of the prediction intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)
x1 &lt;- runif(1000)
x2 &lt;- runif(1000)
y &lt;- rlnorm(1000, meanlog = x1 + x2, sdlog = 0.5)
df &lt;- tibble(x1, x2, y)
df_train &lt;- df %&gt;% slice(1:500)
df_cal &lt;- df %&gt;% slice(501:750)
df_test &lt;- df %&gt;% slice(751:1000)
mod &lt;- lm(log(y) ~ x1 + x2, data=df_train)
calib &lt;- exp(predict(mod, newdata=df_cal))
calib_truth &lt;- df_cal$y
pred_test &lt;- exp(predict(mod, newdata=df_test))

# Normal prediction intervals
pinterval_parametric(pred = pred_test,
dist = 'norm',
pars = list(mean = pred_test,
						sd = sqrt(mean((calib - calib_truth)^2))))

# Log-normal prediction intervals
pinterval_parametric(pred = pred_test,
dist = 'lnorm',
pars = list(meanlog = pred_test,
					sdlog = sqrt(mean((log(calib) - log(calib_truth))^2))))

</code></pre>

<hr>
<h2 id='weights_calculator'>Weights calculator for weighted conformal prediction</h2><span id='topic+weights_calculator'></span>

<h3>Description</h3>

<p>Weights calculator for weighted conformal prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_calculator(y_hat, calib)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_calculator_+3A_y_hat">y_hat</code></td>
<td>
<p>Predicted value</p>
</td></tr>
<tr><td><code id="weights_calculator_+3A_calib">calib</code></td>
<td>
<p>a vector of true values of the calibration partition</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
