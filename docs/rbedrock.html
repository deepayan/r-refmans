<!DOCTYPE html><html><head><title>Help for package rbedrock</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rbedrock}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rbedrock-package'><p>rbedrock: Analysis and Manipulation of Data from Minecraft Bedrock Edition</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#ActorDigest'><p>Read and write Actor Digest Data</p></a></li>
<li><a href='#Actors'><p>Read and write Actor data</p></a></li>
<li><a href='#bedrock_leveldb_open'><p>Open a LevelDB Database</p></a></li>
<li><a href='#bedrock_random'><p>Random Number Generation for Minecraft</p></a></li>
<li><a href='#bedrock_random_create_seed'><p>Random Number Seeds for Minecraft</p></a></li>
<li><a href='#bedrockdb'><p>Open a Bedrock Edition world for reading and writing.</p></a></li>
<li><a href='#Biomes'><p>Read and write biomes data.</p></a></li>
<li><a href='#BlockEntity'><p>Load and store BlockEntity NBT data</p></a></li>
<li><a href='#Checksums'><p>Load and store Checksums data</p></a></li>
<li><a href='#chrkeys_to_rawkeys'><p>Convert between key types.</p></a></li>
<li><a href='#chunk_keys'><p>Read and manipulate chunk keys</p></a></li>
<li><a href='#chunk_origin'><p>Get or set the coordinates of the origin of a chunk</p></a></li>
<li><a href='#ChunkVersion'><p>Read and write chunk version data</p></a></li>
<li><a href='#compact_world'><p>Compact a world database.</p></a></li>
<li><a href='#Data2D'><p>Read and write Data2D data</p></a></li>
<li><a href='#Data3D'><p>Read and write Data3D data</p></a></li>
<li><a href='#delete_values'><p>Remove values from a bedrockdb.</p></a></li>
<li><a href='#Entity'><p>Load and store Entity NBT data</p></a></li>
<li><a href='#FinalizedState'><p>Load and store FinalizedState data</p></a></li>
<li><a href='#from_rnbt'><p>Raw Named Binary Tag Format</p></a></li>
<li><a href='#get_chunk_blocks_data'><p>Load block data from one or more chunks</p></a></li>
<li><a href='#get_keys'><p>Get a list of keys stored in a bedrockdb.</p></a></li>
<li><a href='#get_nbt_data'><p>Read and Write NBT Data</p></a></li>
<li><a href='#get_subchunk_layers_data'><p>Load and store SubchunkBlocks layers</p></a></li>
<li><a href='#get_values'><p>Read values stored in a bedrockdb.</p></a></li>
<li><a href='#HSA'><p>Read and write HardcodedSpawnArea (HSA) data</p></a></li>
<li><a href='#list_biomes'><p>List Minecraft Bedrock Edition biomes.</p></a></li>
<li><a href='#locate_blocks'><p>Locate the coordinates of blocks in a chunk</p></a></li>
<li><a href='#minecraft_worlds'><p>Utilities for working with Minecraft world folders.</p></a></li>
<li><a href='#nbt_byte'><p>Create an NBT value</p></a></li>
<li><a href='#new_nbt'><p>Create an NBT value</p></a></li>
<li><a href='#PendingTicks'><p>Load and store PendingTicks NBT data</p></a></li>
<li><a href='#put_values'><p>Write values to a bedrockdb.</p></a></li>
<li><a href='#RandomTicks'><p>Load and store RandomTicks NBT data</p></a></li>
<li><a href='#rbedrock_example'><p>Get path to rbedrock example</p></a></li>
<li><a href='#read_leveldat'><p>Read and write data from a world's level.dat file.</p></a></li>
<li><a href='#repair_world'><p>Try to repair a world database.</p></a></li>
<li><a href='#simulation_area'><p>Calculate a player-based simulation area</p></a></li>
<li><a href='#spawning_area'><p>Calculate a player-based spawning area</p></a></li>
<li><a href='#SubchunkBlocks'><p>Load and store SubchunkBlocks data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis and Manipulation of Data from Minecraft Bedrock Edition</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an interface to Minecraft (Bedrock Edition) worlds. Supports the analysis and management of these worlds and game saves.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>cmake, zlib, GNU make, Solaris: g++ is a
requirement</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tibble, R6, stringr, bit64, rappdirs, rlang, dplyr, purrr,
magrittr, readr, utils, digest, vctrs, tidyr, fs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>zip, testthat, jsonlite, covr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/reedacartwright/rbedrock">https://github.com/reedacartwright/rbedrock</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/reedacartwright/rbedrock/issues">https://github.com/reedacartwright/rbedrock/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-02 00:32:16 UTC; reed</td>
</tr>
<tr>
<td>Author:</td>
<td>Reed Cartwright <a href="https://orcid.org/0000-0002-0837-9380"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rich FitzJohn [ctb],
  Christian Stigen Larsen [ctb],
  The LevelDB Authors [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Reed Cartwright &lt;racartwright@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-02 00:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rbedrock-package'>rbedrock: Analysis and Manipulation of Data from Minecraft Bedrock Edition</h2><span id='topic+rbedrock'></span><span id='topic+rbedrock-package'></span>

<h3>Description</h3>

<p>Implements an interface to Minecraft (Bedrock Edition) worlds. Supports the analysis and management of these worlds and game saves.
</p>


<h3>Details</h3>

<p>rbedrock is currently under development.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Reed Cartwright <a href="mailto:racartwright@gmail.com">racartwright@gmail.com</a> (<a href="https://orcid.org/0000-0002-0837-9380">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Rich FitzJohn <a href="mailto:rich.fitzjohn@gmail.com">rich.fitzjohn@gmail.com</a> [contributor]
</p>
</li>
<li><p> Christian Stigen Larsen [contributor]
</p>
</li>
<li><p> The LevelDB Authors [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/reedacartwright/rbedrock">https://github.com/reedacartwright/rbedrock</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/reedacartwright/rbedrock/issues">https://github.com/reedacartwright/rbedrock/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='ActorDigest'>Read and write Actor Digest Data</h2><span id='topic+ActorDigest'></span><span id='topic+get_acdig_data'></span><span id='topic+get_acdig_value'></span><span id='topic+put_acdig_data'></span><span id='topic+put_acdig_value'></span><span id='topic+read_acdig_value'></span><span id='topic+write_acdig_value'></span><span id='topic+create_acdig_keys'></span>

<h3>Description</h3>

<p>Actor digests store a list of all entities in a chunk; however
they are not chunk data and use their own prefix. The key format
for actor digest data is acdig:x:z:dimension.
</p>
<p><code>get_acdig_data()</code> and <code>get_acdig_value()</code> load ActorDigest
data from <code>db</code>.  <code>get_acdig_value()</code> supports loading
only a single value.
</p>
<p><code>put_acdig_data()</code> and <code>put_acdig_value()</code> store ActorDigest data into <code>db</code>.
</p>
<p><code>read_acdig_value()</code> and <code>write_acdig_value()</code> decode and encode
ActorDigest data respectively.
</p>
<p><code>create_acdig_keys()</code> creates keys for ActorDigest data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_acdig_data(x, z, dimension, db)

get_acdig_value(x, z, dimension, db)

put_acdig_data(values, x, z, dimension, db)

put_acdig_value(value, x, z, dimension, db)

read_acdig_value(rawdata)

write_acdig_value(value)

create_acdig_keys(x, z, dimension)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ActorDigest_+3A_x">x</code>, <code id="ActorDigest_+3A_z">z</code>, <code id="ActorDigest_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="ActorDigest_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="ActorDigest_+3A_values">values</code></td>
<td>
<p>A list of character vectors.
If <code>x</code> is missing, the names of <code>values</code> will be taken as the keys.</p>
</td></tr>
<tr><td><code id="ActorDigest_+3A_value">value</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="ActorDigest_+3A_rawdata">rawdata</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_acdig_values()</code> returns a vector of actor keys.
<code>get_acdig_data()</code> returns a named list of the of the values
returned by <code>get_acdig_value()</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+Actors">Actors</a>, <a href="#topic+Entity">Entity</a>
</p>

<hr>
<h2 id='Actors'>Read and write Actor data</h2><span id='topic+Actors'></span><span id='topic+get_actors_data'></span><span id='topic+get_actors_value'></span><span id='topic+put_actors_data'></span><span id='topic+put_actors_value'></span>

<h3>Description</h3>

<p>After 1.18.30, the nbt data of each actor is saved independently in the
database, using a key with a prefix and a 16-character storage key:
'actor:0123456789abcdef'. The keys of all actors in a chunk are saved in an
<a href="#topic+ActorDigest">ActorDigest</a> record, with format acdig:x:z:dimension'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_actors_data(x, z, dimension, db)

get_actors_value(x, z, dimension, db)

put_actors_data(values, x, z, dimension, db)

put_actors_value(value, x, z, dimension, db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Actors_+3A_x">x</code>, <code id="Actors_+3A_z">z</code>, <code id="Actors_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="Actors_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="Actors_+3A_values">values</code></td>
<td>
<p>A list of character vectors.
If <code>x</code> is missing, the names of <code>values</code> will be taken as the keys.</p>
</td></tr>
<tr><td><code id="Actors_+3A_value">value</code></td>
<td>
<p>A list of nbt actors data</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_actors_value()</code> loads Actors data for a single chunk in <code>db</code>.
<code>get_actors_data()</code> loads Actors data from multiple chunks in <code>db</code>.
</p>
<p><code>put_actors_value()</code> and <code>put_actors_data()</code> store one/multiple chunks
Actors data into <code>db</code> and update the chunks' ActorDigests.
When storing Actors data, an actor's storage key will be recalculated from
the actor's <code>UniqueID</code>. The actor's position and dimension are not verified
to be in the chunk it is assigned to.
</p>


<h3>See Also</h3>

<p><a href="#topic+ActorDigest">ActorDigest</a>, <a href="#topic+Entity">Entity</a>
</p>

<hr>
<h2 id='bedrock_leveldb_open'>Open a LevelDB Database</h2><span id='topic+bedrock_leveldb_open'></span>

<h3>Description</h3>

<p>Create a <code>leveldb</code> object, to interact with a LevelDB
database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedrock_leveldb_open(
  path,
  create_if_missing = NULL,
  error_if_exists = NULL,
  paranoid_checks = NULL,
  write_buffer_size = NULL,
  max_open_files = NULL,
  block_size = NULL,
  cache_capacity = NULL,
  bloom_filter_bits_per_key = NULL,
  compression_level = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bedrock_leveldb_open_+3A_path">path</code></td>
<td>
<p>The path to the database, as stored on the filesystem.
This will create a <em>directory</em> at this path if one does not
exist (and if <code>create_if_missing</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bedrock_leveldb_open_+3A_create_if_missing">create_if_missing</code></td>
<td>
<p>Create the database if one does not
already exist at <code>path</code> (this defaults to <code>TRUE</code>,
which differs from the LevelDB default of <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="bedrock_leveldb_open_+3A_error_if_exists">error_if_exists</code></td>
<td>
<p>Throw an error if the database already
exists at <code>path</code>  (LevelDB default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="bedrock_leveldb_open_+3A_paranoid_checks">paranoid_checks</code></td>
<td>
<p>If <code>TRUE</code>, LevelDB will do aggressive
checking of the data it is processing and will stop early if it
detects any errors.  This may have unforeseen ramifications: for
example, a corruption of one DB entry may cause a large number
of entries to become unreadable or for the entire DB to become
unopenable.  (LevelDB default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="bedrock_leveldb_open_+3A_write_buffer_size">write_buffer_size</code></td>
<td>
<p>Amount of data (in bytes) to build up in
memory (backed by an unsorted log on disk) before converting to
a sorted on-disk file.  Larger values increase performance,
especially during bulk loads.  Up to two write buffers may be
held in memory at the same time, so you may wish to adjust this
parameter to control memory usage.  Also, a larger write buffer
will result in a longer recovery time the next time the database
is opened.</p>
</td></tr>
<tr><td><code id="bedrock_leveldb_open_+3A_max_open_files">max_open_files</code></td>
<td>
<p>Number of files that can be used by the
database.  You may need to increase this if your database has a
large working set (budget one open file per 2MB of working set).
(LevelDB default: 1000).</p>
</td></tr>
<tr><td><code id="bedrock_leveldb_open_+3A_block_size">block_size</code></td>
<td>
<p>The approximate size of user data packed per
block (user data is stored in a set of blocks, and a block is
the unit of reading from disk).  The block size here corresponds
to uncompressed data; the actual size of the unit read from disk
may be smaller if compression is enabled (LevelDB default: 4K)</p>
</td></tr>
<tr><td><code id="bedrock_leveldb_open_+3A_cache_capacity">cache_capacity</code></td>
<td>
<p>The size of the cache to use.  If
non-<code>NULL</code> this must be a non-negative integer, indicating
the size of the cache in bytes.  If <code>NULL</code> (the default)
then LevelDB will create an 8MB internal cache.</p>
</td></tr>
<tr><td><code id="bedrock_leveldb_open_+3A_bloom_filter_bits_per_key">bloom_filter_bits_per_key</code></td>
<td>
<p>If non-NULL, this sets up a
'filter policy' to reduce disk reads.  A good value for
bits_per_key is 10, which yields a filter with ~ 1% false
positive rate.  Further information from the LevelDB headers
(filter_policy.h) &quot;This object is responsible for
creating a small filter from a set of keys.  These filters are
stored in leveldb and are consulted automatically by leveldb to
decide whether or not to read some information from disk. In
many cases, a filter can cut down the number of disk seeks form
a handful to a single disk seek per <code>DB::Get()</code> call&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all optional arguments (i.e., all but <code>path</code>) a value of
<code>NULL</code> means that we use the <code>LevelDB</code> default; the
LevelDB default of each argument is indicated in the argument
documentation.
</p>
<p>This function returns an 'R6' class with a number of methods.
</p>


<h3>Author(s)</h3>

<p>Rich FitzJohn
</p>

<hr>
<h2 id='bedrock_random'>Random Number Generation for Minecraft</h2><span id='topic+bedrock_random'></span><span id='topic+bedrock_random_seed'></span><span id='topic+bedrock_random_state'></span><span id='topic+bedrock_random_get_uint'></span><span id='topic+bedrock_random_get_int'></span><span id='topic+bedrock_random_get_float'></span><span id='topic+bedrock_random_get_double'></span>

<h3>Description</h3>

<p>Bedrock Edition's central random number algorithm is MT19937. However, R's
MT19937 code is not compatible with Bedrock's. These routines provide an API
that is compatible with Bedrock's.
</p>
<p><code>bedrock_random_seed()</code> seeds the random number generator.
</p>
<p><code>bedrock_random_state()</code> returns the current state of the random number
generator as a raw vector.
</p>
<p><code>bedrock_random_get_uint()</code> returns a 32-bit random integer.
Default range is <code style="white-space: pre;">&#8288;[0, 2^32-1]&#8288;</code>.
</p>
<p><code>bedrock_random_get_int()</code> returns a 31-bit random integer.
Default range is <code style="white-space: pre;">&#8288;[0, 2^31-1]&#8288;</code>.
</p>
<p><code>bedrock_random_get_float()</code> returns a random real number.
Default range is <code style="white-space: pre;">&#8288;[0.0, 1.0)&#8288;</code>.
</p>
<p><code>bedrock_random_get_double()</code> returns a random real number
Default range is <code style="white-space: pre;">&#8288;[0.0, 1.0)&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedrock_random_seed(value)

bedrock_random_state(new_state = NULL)

bedrock_random_get_uint(n, max)

bedrock_random_get_int(n, min, max)

bedrock_random_get_float(n, min, max)

bedrock_random_get_double(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bedrock_random_+3A_value">value</code></td>
<td>
<p>a scalar integer</p>
</td></tr>
<tr><td><code id="bedrock_random_+3A_new_state">new_state</code></td>
<td>
<p>a raw vector</p>
</td></tr>
<tr><td><code id="bedrock_random_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="bedrock_random_+3A_min">min</code>, <code id="bedrock_random_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution. Must be finite.
If only one is specified, it is taken as <code>max</code>. If neither is specified,
the default range is used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># seed the global random number generator
bedrock_random_seed(5490L)

# save and restore rng state
saved_state &lt;- bedrock_random_state()
bedrock_random_get_uint(10)
bedrock_random_state(saved_state)
bedrock_random_get_uint(10)
</code></pre>

<hr>
<h2 id='bedrock_random_create_seed'>Random Number Seeds for Minecraft</h2><span id='topic+bedrock_random_create_seed'></span>

<h3>Description</h3>

<p><code>bedrock_random_create_seed()</code> constructs a seed using the formulas
type 1: <code>x*a ^ z*b ^ salt</code>, type 2: <code>x*a + z*b + salt</code>, and type 3:
<code>x*a + z*b ^ salt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedrock_random_create_seed(x, z, a, b, salt, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bedrock_random_create_seed_+3A_x">x</code>, <code id="bedrock_random_create_seed_+3A_z">z</code></td>
<td>
<p>chunk coordinates</p>
</td></tr>
<tr><td><code id="bedrock_random_create_seed_+3A_a">a</code>, <code id="bedrock_random_create_seed_+3A_b">b</code></td>
<td>
<p>seed parameters</p>
</td></tr>
<tr><td><code id="bedrock_random_create_seed_+3A_salt">salt</code></td>
<td>
<p>seed parameter</p>
</td></tr>
<tr><td><code id="bedrock_random_create_seed_+3A_type">type</code></td>
<td>
<p>which seed type to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minecraft uses several different kind of seeds during world generation and
gameplay.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># identify slime chunks
g &lt;- tidyr::expand_grid(x=1:10, z=1:10)
is_slime_chunk &lt;- purrr::pmap_lgl(g, function(x,z) {
  seed &lt;- bedrock_random_create_seed(x,z,0x1f1f1f1f,1,0,type=1)
  bedrock_random_seed(seed)
  bedrock_random_get_uint(1,10) == 0
})
</code></pre>

<hr>
<h2 id='bedrockdb'>Open a Bedrock Edition world for reading and writing.</h2><span id='topic+bedrockdb'></span><span id='topic+close.bedrockdb'></span><span id='topic+is_bedrockdb'></span>

<h3>Description</h3>

<p><code>bedrockdb</code> opens a handle to a leveldb database that contains
save-game data for a Bedrock Edition world. On success, it returns
an R6 class of type 'bedrockdb' that can be used directly for
low-level reading and writing access to the db or can be passed to
higher-level functions. The handle to the database can be closed
by passing it to <code>close</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedrockdb(
  path,
  create_if_missing = FALSE,
  error_if_exists = NULL,
  paranoid_checks = NULL,
  write_buffer_size = 4194304L,
  max_open_files = NULL,
  block_size = 163840L,
  cache_capacity = 83886080L,
  bloom_filter_bits_per_key = 10L,
  compression_level = -1L
)

## S3 method for class 'bedrockdb'
close(con, compact = FALSE, ...)

is_bedrockdb(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bedrockdb_+3A_path">path</code></td>
<td>
<p>The path to a world folder. If the path does not exist, it is
assumed to be the base name of a world folder in the local minecraftWorlds
directory.</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_create_if_missing">create_if_missing</code></td>
<td>
<p>Create world database if it doesn't exist.</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_error_if_exists">error_if_exists</code></td>
<td>
<p>Raise an error if the world database already exists.</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_paranoid_checks">paranoid_checks</code></td>
<td>
<p>Internal leveldb option</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_write_buffer_size">write_buffer_size</code></td>
<td>
<p>Internal leveldb option</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_max_open_files">max_open_files</code></td>
<td>
<p>Internal leveldb option</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_block_size">block_size</code></td>
<td>
<p>Internal leveldb option</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_cache_capacity">cache_capacity</code></td>
<td>
<p>Internal leveldb option</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_bloom_filter_bits_per_key">bloom_filter_bits_per_key</code></td>
<td>
<p>Internal leveldb option</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_compression_level">compression_level</code></td>
<td>
<p>Internal leveldb option</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_con">con</code></td>
<td>
<p>An database object created by bedrockdb.</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_compact">compact</code></td>
<td>
<p>Compact database before closing.</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="bedrockdb_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>On success, <code>bedrockdb</code> returns an R6 class of type 'bedrockdb'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># open an example works and get all keys
dbpath &lt;- rbedrock_example_world("example1.mcworld")
db &lt;- bedrockdb(dbpath)
keys &lt;- get_keys(db)
close(db)

## Not run: 

# open a world in the minecraftWorlds folder using a world id.
db &lt;- bedrockdb("lrkkYFpUABA=")
# do something with db ...
close(db)

# open a world using absolute path
db &lt;- bedrockdb("C:\\\\minecraftWorlds\\\\my_world")
# do something with db ...
close(db)

## End(Not run)
</code></pre>

<hr>
<h2 id='Biomes'>Read and write biomes data.</h2><span id='topic+Biomes'></span><span id='topic+get_biomes_data'></span><span id='topic+get_biomes_values'></span><span id='topic+get_biomes_value'></span><span id='topic+put_biomes_data'></span><span id='topic+put_biomes_values'></span><span id='topic+put_biomes_value'></span><span id='topic+get_legacy_biomes_data'></span><span id='topic+get_legacy_biomes_values'></span><span id='topic+get_legacy_biomes_value'></span><span id='topic+put_legacy_biomes_data'></span><span id='topic+put_legacy_biomes_values'></span><span id='topic+put_legacy_biomes_value'></span>

<h3>Description</h3>

<p>Biomes data is stored as the second map in Data3D data (tag 43).
Legacy Biomes data is stored as the second map in the Data2D data (tag 45).
</p>
<p><code>get_biomes_data()</code> and <code>get_biomes_value()</code> load Biomes
data from <code>db</code>. <code>get_biomes_data()</code> will silently drop keys not
representing Data3D data. <code>get_biomes_value()</code> supports loading
only a single value. <code>get_biomes_values()</code> is a synonym for
<code>get_biomes_data()</code>.
</p>
<p><code>put_biomes_data()</code> <code>put_biomes_values()</code>, and <code>put_biomes_value()</code> update
the biome information of chunks. They preserve any existing height data.
</p>
<p><code style="white-space: pre;">&#8288;get_legacy_biomes_*()&#8288;</code> and <code style="white-space: pre;">&#8288;put_legacy_biomes_*()&#8288;</code> behave similar to
the equivalent non-legacy functions. They get or put 2d biome data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_biomes_data(db, x, z, dimension, return_names = TRUE)

get_biomes_values(db, x, z, dimension, return_names = TRUE)

get_biomes_value(db, x, z, dimension, return_names = TRUE)

put_biomes_data(db, data, missing_height = -64L)

put_biomes_values(db, x, z, dimension, values, missing_height = -64L)

put_biomes_value(db, x, z, dimension, value, missing_height = -64L)

get_legacy_biomes_data(db, x, z, dimension, return_names = TRUE)

get_legacy_biomes_values(db, x, z, dimension, return_names = TRUE)

get_legacy_biomes_value(db, x, z, dimension, return_names = TRUE)

put_legacy_biomes_data(db, data, missing_height = 0L)

put_legacy_biomes_values(db, x, z, dimension, values, missing_height = 0L)

put_legacy_biomes_value(db, x, z, dimension, value, missing_height = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Biomes_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="Biomes_+3A_x">x</code>, <code id="Biomes_+3A_z">z</code>, <code id="Biomes_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="Biomes_+3A_return_names">return_names</code></td>
<td>
<p>return biome names instead of biome ids.</p>
</td></tr>
<tr><td><code id="Biomes_+3A_data">data</code></td>
<td>
<p>A list of character or integer vectors.</p>
</td></tr>
<tr><td><code id="Biomes_+3A_missing_height">missing_height</code></td>
<td>
<p>if there is no existing height data, use this value
for the chunk.</p>
</td></tr>
<tr><td><code id="Biomes_+3A_values">values</code></td>
<td>
<p>a list of arrays containing biome names or ids.</p>
</td></tr>
<tr><td><code id="Biomes_+3A_value">value</code></td>
<td>
<p>an array containing biome names or ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_biomes_value()</code> returns an array with 3 dimensions.
<code>get_biomes_data()</code> returns a list of the of the values returned by
<code>get_biomes_value()</code>.
</p>

<hr>
<h2 id='BlockEntity'>Load and store BlockEntity NBT data</h2><span id='topic+BlockEntity'></span><span id='topic+get_block_entity_data'></span><span id='topic+get_block_entity_values'></span><span id='topic+get_block_entity_value'></span><span id='topic+put_block_entity_values'></span><span id='topic+put_block_entity_value'></span><span id='topic+put_block_entity_data'></span>

<h3>Description</h3>

<p>BlockEntity data (tag 49) holds a list of NBT values for
entity data associated with specific blocks.
</p>
<p><code>get_block_entity_data()</code> and <code>get_block_entity_value()</code> load BlockEntity
data from <code>db</code>. <code>get_block_entity_data()</code> will silently drop and keys not
representing BlockEntity data. <code>get_block_entity_value()</code> supports loading
only a single value. <code>get_block_entity_values()</code> is a synonym for
<code>get_block_entity_data()</code>.
</p>
<p><code>put_block_entity_values()</code>, <code>put_block_entity_value()</code>, and
<code>put_block_entity_data()</code> store BlockEntity data into <code>db</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_block_entity_data(db, x, z, dimension)

get_block_entity_values(db, x, z, dimension)

get_block_entity_value(db, x, z, dimension)

put_block_entity_values(db, x, z, dimension, values)

put_block_entity_value(db, x, z, dimension, value)

put_block_entity_data(db, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BlockEntity_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="BlockEntity_+3A_x">x</code>, <code id="BlockEntity_+3A_z">z</code>, <code id="BlockEntity_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="BlockEntity_+3A_values">values</code></td>
<td>
<p>A list of nbt objects</p>
</td></tr>
<tr><td><code id="BlockEntity_+3A_value">value</code></td>
<td>
<p>An nbt object.</p>
</td></tr>
<tr><td><code id="BlockEntity_+3A_data">data</code></td>
<td>
<p>A named-list specifying key-value pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_block_entity_data()</code> returns a named-list of nbt data.
<code>get_block_entity_values()</code> returns a single nbt value.
</p>

<hr>
<h2 id='Checksums'>Load and store Checksums data</h2><span id='topic+Checksums'></span><span id='topic+get_checksums_data'></span><span id='topic+get_checksums_values'></span><span id='topic+get_checksums_value'></span><span id='topic+update_checksums_data'></span><span id='topic+read_checksums_value'></span><span id='topic+write_checksums_value'></span>

<h3>Description</h3>

<p>Checksums data (tag 59) holds checksums for several chunk records.
These records are 2DMaps (tag 45), SubchunkBlocks (tag 47),
BlockEntities (tag 49), and Entities (tag 50).
</p>
<p><code>get_checksums_data()</code> loads Checksums data from a <code>bedrockdb</code>.
It will silently drop and keys not representing Checksums data.
<code>get_checksums_values()</code> is a synonym for <code>get_checksums_data()</code>.
</p>
<p><code>get_checksums_value()</code> loads Checksums data from a <code>bedrockdb</code>.
It only supports loading a single value.
</p>
<p><code>update_checksums_data()</code> recalculates Checksums data.
It calculates checksums for the specified chunks'
SubchunkBlocks, 2DMaps, BlockEntities, and Entities
records in <code>db</code> and updates the Checksums record to match.
</p>
<p><code>read_checksums_value()</code> parses a binary Checksums record
into a list of checksums.
</p>
<p><code>write_checksums_value()</code> converts Checksums from a named list into
binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_checksums_data(db, x, z, dimension)

get_checksums_values(db, x, z, dimension)

get_checksums_value(db, x, z, dimension)

update_checksums_data(db, x, z, dimension)

read_checksums_value(rawdata)

write_checksums_value(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Checksums_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="Checksums_+3A_x">x</code>, <code id="Checksums_+3A_z">z</code>, <code id="Checksums_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="Checksums_+3A_rawdata">rawdata</code></td>
<td>
<p>a raw vector holding binary Checksums data</p>
</td></tr>
<tr><td><code id="Checksums_+3A_object">object</code></td>
<td>
<p>a named character vector in the same format as returned by
<code>read_checksums_value()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_checksums_data()</code> returns a named-list of the values returned
by <code>get_checksums_value()</code>.
</p>
<p><code>get_checksums_value()</code> and <code>read_checksums_value()</code>
return a character vector.
The names of the character vector indicate which
chunk record (tag and subtag) the checksum is for.
</p>
<p><code>write_checksums_value()</code> returns a raw vector.
</p>

<hr>
<h2 id='chrkeys_to_rawkeys'>Convert between key types.</h2><span id='topic+chrkeys_to_rawkeys'></span><span id='topic+rawkeys_to_chrkeys'></span>

<h3>Description</h3>

<p>rbedrock represents database keys two different ways. <code>chrkeys</code> are a
human-readable format understood by most functions. <code>rawkeys</code> are used
internally, by the methods of <code>bedrockdb</code> objects and <code style="white-space: pre;">&#8288;bedrock_leveldb_*&#8288;</code>
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chrkeys_to_rawkeys(keys)

rawkeys_to_chrkeys(keys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chrkeys_to_rawkeys_+3A_keys">keys</code></td>
<td>
<p>a character vector of chrkeys or a list or rawkeys</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>chrkeys_to_rawkeys()</code> returns a list of raw vectors.
</p>
<div class="sourceCode"><pre>    `rawkeys_to_chrkeys()` returns a character vector.
</pre></div>

<hr>
<h2 id='chunk_keys'>Read and manipulate chunk keys</h2><span id='topic+chunk_keys'></span><span id='topic+parse_chunk_keys'></span><span id='topic+create_chunk_keys'></span><span id='topic+chunk_positions'></span><span id='topic+chunk_origins'></span><span id='topic+chunk_tag_str'></span><span id='topic+chunk_tag_int'></span>

<h3>Description</h3>

<p>Chunk keys are keys to chunk data. A chunk key has a format which indicates
the chunk it holds data for and the type of data it holds. This format is
either <code>chunk:x:z:d:t</code> or <code>chunk:x:z:d:t:s</code>, where <code>x</code> and <code>z</code> indicates the
coordinates of the chunk in chunk space, <code>d</code> indicates the dimension of
the chunk, and <code>t</code> and <code>s</code> indicate the tag and subtag of the chunk.
</p>
<p><code>parse_chunk_keys()</code> splits chunk keys into their individual elements and
returns a table with the results. Keys that do not contain chunk data are
silently dropped.
</p>
<p><code>create_chunk_keys()</code> returns a vector of chunk keys formed from its
arguments.
</p>
<p><code>chunk_positions()</code> returns a matrix containing the chunk coordinates of
keys.
</p>
<p><code>chunk_origins()</code> returns a matrix containing the block coordinate of the NW
corner of keys.
</p>
<p><code>chunk_tag_str()</code> and <code>chunk_tag_int()</code> convert between integer and character
representations of chunk tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_chunk_keys(keys)

create_chunk_keys(x, z, dimension, tag, subtag)

chunk_positions(keys)

chunk_origins(keys)

chunk_tag_str(tags)

chunk_tag_int(tags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk_keys_+3A_keys">keys</code></td>
<td>
<p>A character vector of database keys.</p>
</td></tr>
<tr><td><code id="chunk_keys_+3A_x">x</code></td>
<td>
<p>Chunk x-coordinate.</p>
</td></tr>
<tr><td><code id="chunk_keys_+3A_z">z</code></td>
<td>
<p>Chunk z-coordinate.</p>
</td></tr>
<tr><td><code id="chunk_keys_+3A_dimension">dimension</code></td>
<td>
<p>Dimension.</p>
</td></tr>
<tr><td><code id="chunk_keys_+3A_tag">tag</code></td>
<td>
<p>The type of chunk data.</p>
</td></tr>
<tr><td><code id="chunk_keys_+3A_subtag">subtag</code></td>
<td>
<p>The subchunk the key refers to (Only used for tag 47).</p>
</td></tr>
<tr><td><code id="chunk_keys_+3A_tags">tags</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>parse_chunk_keys("chunk:0:0:0:44")
parse_chunk_keys("chunk:0:0:0:47:1")
create_chunk_keys(0, 0, 0, 47, 1)

</code></pre>

<hr>
<h2 id='chunk_origin'>Get or set the coordinates of the origin of a chunk</h2><span id='topic+chunk_origin'></span><span id='topic+chunk_origin+3C-'></span>

<h3>Description</h3>

<p>Get or set the coordinates of the origin of a chunk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk_origin(x)

chunk_origin(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk_origin_+3A_x">x</code></td>
<td>
<p>an array of block data</p>
</td></tr>
<tr><td><code id="chunk_origin_+3A_value">value</code></td>
<td>
<p>an integer vector</p>
</td></tr>
</table>

<hr>
<h2 id='ChunkVersion'>Read and write chunk version data</h2><span id='topic+ChunkVersion'></span><span id='topic+get_chunk_version_data'></span><span id='topic+get_chunk_version_values'></span><span id='topic+get_chunk_version_value'></span><span id='topic+put_chunk_version_data'></span><span id='topic+put_chunk_version_values'></span><span id='topic+put_chunk_version_value'></span><span id='topic+read_chunk_version_value'></span><span id='topic+write_chunk_version_value'></span>

<h3>Description</h3>

<p>Version data (tag 44) and LegacyVersion data (tag 118)
store the version number of a chunk. In Minecraft version 1.16.100,
chunk version data was moved from tag 118 to tag 44.
</p>
<p><code>get_chunk_version_data()</code> and <code>get_chunk_version_value()</code> load Version
data from <code>db</code>. <code>get_chunk_version_data()</code> will silently drop and keys not
representing Version data. <code>get_chunk_version_value()</code> supports loading
only a single value. <code>get_chunk_version_values()</code> is a synonym for
<code>get_chunk_version_data()</code>.
</p>
<p><code>put_chunk_version_data()</code>, <code>put_chunk_version_values()</code>, and
<code>put_chunk_version_value()</code> store Version data into a <code>bedrockdb</code>.
</p>
<p><code>read_chunk_version_value()</code> decodes Version data.
</p>
<p><code>write_chunk_version_value()</code> encodes Version data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_chunk_version_data(db, x, z, dimension)

get_chunk_version_values(db, x, z, dimension)

get_chunk_version_value(db, x, z, dimension)

put_chunk_version_data(db, data)

put_chunk_version_values(db, x, z, dimension, values)

put_chunk_version_value(db, x, z, dimension, value)

read_chunk_version_value(rawdata)

write_chunk_version_value(num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ChunkVersion_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="ChunkVersion_+3A_x">x</code>, <code id="ChunkVersion_+3A_z">z</code>, <code id="ChunkVersion_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract version data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="ChunkVersion_+3A_data">data</code></td>
<td>
<p>A named-vector of key-value pairs for Version data.</p>
</td></tr>
<tr><td><code id="ChunkVersion_+3A_values">values</code></td>
<td>
<p>An integer vector</p>
</td></tr>
<tr><td><code id="ChunkVersion_+3A_value">value</code></td>
<td>
<p>A scalar integer vector</p>
</td></tr>
<tr><td><code id="ChunkVersion_+3A_rawdata">rawdata</code></td>
<td>
<p>A scalar raw.</p>
</td></tr>
<tr><td><code id="ChunkVersion_+3A_num">num</code></td>
<td>
<p>A scalar integer.</p>
</td></tr>
</table>

<hr>
<h2 id='compact_world'>Compact a world database.</h2><span id='topic+compact_world'></span>

<h3>Description</h3>

<p>Compact a world database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact_world(db)
</code></pre>

<hr>
<h2 id='Data2D'>Read and write Data2D data</h2><span id='topic+Data2D'></span><span id='topic+get_data2d_data'></span><span id='topic+get_data2d_values'></span><span id='topic+get_data2d_value'></span><span id='topic+read_data2d_value'></span><span id='topic+put_data2d_data'></span><span id='topic+put_data2d_values'></span><span id='topic+put_data2d_value'></span><span id='topic+write_data2d_value'></span>

<h3>Description</h3>

<p>Data2D data (tag 45) stores information about surface heights and biomes in a
chunk. Data2D data is 768 bytes long and consists of a 256 int16s (heights)
followed by 256 uint8s (biomes).
</p>
<p><code>get_data2d_data()</code> loads Data2D data from a <code>bedrockdb</code>.
It will silently drop and keys not representing Data2D data.
</p>
<p><code>get_data2d_value()</code> loads Data2D data from a <code>bedrockdb</code>.
It only supports loading a single value.
</p>
<p><code>read_data2d_value</code> decodes binary Data2D data.
</p>
<p><code>put_data2d_data()</code>, <code>put_data2d_values()</code>, and
<code>put_data2d_value()</code> store Data2D data into a <code>bedrockdb</code>.
</p>
<p><code>write_data2d_value</code> encodes Data2D data into a raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data2d_data(db, x, z, dimension)

get_data2d_values(db, x, z, dimension)

get_data2d_value(db, x, z, dimension)

read_data2d_value(rawdata)

put_data2d_data(db, data)

put_data2d_values(db, x, z, dimension, height_maps, biome_maps)

put_data2d_value(db, x, z, dimension, height_map, biome_map)

write_data2d_value(height_map, biome_map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Data2D_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="Data2D_+3A_x">x</code>, <code id="Data2D_+3A_z">z</code>, <code id="Data2D_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="Data2D_+3A_rawdata">rawdata</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
<tr><td><code id="Data2D_+3A_data">data</code></td>
<td>
<p>A named-vector of key-value pairs for Data2D data.</p>
</td></tr>
<tr><td><code id="Data2D_+3A_height_maps">height_maps</code>, <code id="Data2D_+3A_biome_maps">biome_maps</code></td>
<td>
<p>Lists of height and biome data.
Values will be recycled if necessary to match the number of keys
to be written to. If <code>biome_maps</code> is missing, <code>height_maps</code> should
be in the same format as returned by <code>get_data2d_data()</code>.</p>
</td></tr>
<tr><td><code id="Data2D_+3A_height_map">height_map</code>, <code id="Data2D_+3A_biome_map">biome_map</code></td>
<td>
<p>16x16 arrays containing height and biome data.
Values will be recycled if necessary. If <code>biome_map</code> is missing, <code>height-map</code>
should be a list a <code>list()</code> with both &quot;height_map&quot; and &quot;biome_map&quot; elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_data2d_data()</code> returns a list of the of the values returned by
<code>get_data2d_value()</code>.
</p>
<p><code>get_data2d_value()</code> returns a list with components &quot;height_map&quot;
and &quot;biome_map&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>heights &lt;- matrix(63,16,16)
biomes &lt;- matrix(1,16,16)
# Pass heights and biomes as separate parameters
dat &lt;- write_data2d_value(heights, biomes)
# Pass them as a list.
obj &lt;- list(height_map = heights, biome_map = biomes)
dat &lt;- write_data2d_value(obj)
# Pass them as scalars
dat &lt;- write_data2d_value(63, 1)
</code></pre>

<hr>
<h2 id='Data3D'>Read and write Data3D data</h2><span id='topic+Data3D'></span><span id='topic+get_data3d_data'></span><span id='topic+get_data3d_values'></span><span id='topic+get_data3d_value'></span><span id='topic+put_data3d_data'></span><span id='topic+put_data3d_values'></span><span id='topic+put_data3d_value'></span><span id='topic+read_data3d_value'></span><span id='topic+write_data3d_value'></span>

<h3>Description</h3>

<p>Data3D data (tag 43) stores information about surface heights and biomes in a
chunk.
</p>
<p><code>get_data3d_data()</code> loads Data3D data from <code>db</code>.
It will silently drop keys not representing Data3D data.
</p>
<p><code>get_data3d_value()</code> loads Data3D data from <code>db</code>.
It only supports loading a single value.
</p>
<p><code>put_data3d_data()</code>, <code>put_data3d_values()</code>, and
<code>put_data3d_value()</code> store Data3D data into <code>db</code>.
</p>
<p><code>read_data3d_value()</code> decodes binary Data3D data.
</p>
<p><code>write_data3d_value</code> encodes Data3D data into a raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data3d_data(db, x, z, dimension)

get_data3d_values(db, x, z, dimension)

get_data3d_value(db, x, z, dimension)

put_data3d_data(db, data)

put_data3d_values(db, x, z, dimension, height_maps, biome_maps)

put_data3d_value(db, x, z, dimension, height_map, biome_map)

read_data3d_value(rawdata)

write_data3d_value(height_map, biome_map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Data3D_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="Data3D_+3A_x">x</code>, <code id="Data3D_+3A_z">z</code>, <code id="Data3D_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="Data3D_+3A_data">data</code></td>
<td>
<p>A named-vector of key-value pairs for Data3D data.</p>
</td></tr>
<tr><td><code id="Data3D_+3A_height_maps">height_maps</code>, <code id="Data3D_+3A_biome_maps">biome_maps</code></td>
<td>
<p>Lists of height and biome data.
Values will be recycled if necessary to match the number of keys
to be written to. If <code>biome_maps</code> is missing, <code>height_maps</code> should
be in the same format as returned by <code>get_data3d_data()</code>.</p>
</td></tr>
<tr><td><code id="Data3D_+3A_height_map">height_map</code></td>
<td>
<p>16x16 array containing height data.
Values will be recycled if necessary. If <code>biome_map</code> is missing, <code>height-map</code>
should be a list a <code>list()</code> with both &quot;height_map&quot; and &quot;biome_map&quot; elements.</p>
</td></tr>
<tr><td><code id="Data3D_+3A_biome_map">biome_map</code></td>
<td>
<p>16xNx16 array containing biome data.</p>
</td></tr>
<tr><td><code id="Data3D_+3A_rawdata">rawdata</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_data3d_data()</code> returns a list of the of the values returned by
<code>get_data3d_value()</code>.
</p>
<p><code>get_data3d_value()</code> returns a list with components &quot;height_map&quot;
and &quot;biome_map&quot;.
</p>

<hr>
<h2 id='delete_values'>Remove values from a bedrockdb.</h2><span id='topic+delete_values'></span>

<h3>Description</h3>

<p>Remove values from a bedrockdb.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_values(
  db,
  keys,
  report = FALSE,
  readoptions = NULL,
  writeoptions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_values_+3A_db">db</code></td>
<td>
<p>A <code>bedrockdb</code> object</p>
</td></tr>
<tr><td><code id="delete_values_+3A_keys">keys</code></td>
<td>
<p>A character vector of keys.</p>
</td></tr>
<tr><td><code id="delete_values_+3A_report">report</code></td>
<td>
<p>A logical indicating whether to generate a report on deleted
keys</p>
</td></tr>
<tr><td><code id="delete_values_+3A_readoptions">readoptions</code></td>
<td>
<p>A <code>bedrock_leveldb_readoptions</code> object</p>
</td></tr>
<tr><td><code id="delete_values_+3A_writeoptions">writeoptions</code></td>
<td>
<p>A <code>bedrock_leveldb_writeoptions</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>report == TRUE</code>, a logical vector indicating which keys were
deleted.
</p>

<hr>
<h2 id='Entity'>Load and store Entity NBT data</h2><span id='topic+Entity'></span><span id='topic+get_entity_data'></span><span id='topic+get_entity_values'></span><span id='topic+get_entity_value'></span><span id='topic+put_entity_values'></span><span id='topic+put_entity_value'></span><span id='topic+put_entity_data'></span>

<h3>Description</h3>

<p>Entity data (tag 50) holds a list of NBT values for mobs and other entities
in the game. After 1.18.30, entity data was migrated to a new actor digest
format and no longer saved with chunk data.
</p>
<p><code>get_entity_data()</code> and <code>get_entity_value()</code> load Entity
data from <code>db</code>. <code>get_entity_data()</code> will silently drop and keys not
representing Entity data. <code>get_entity_value()</code> supports loading
only a single value. <code>get_entity_values()</code> is a synonym for
<code>get_entity_data()</code>.
</p>
<p><code>put_entity_values()</code>, <code>put_entity_value()</code>, and
<code>put_entity_data()</code> store BlockEntity data into <code>db</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_entity_data(db, x, z, dimension)

get_entity_values(db, x, z, dimension)

get_entity_value(db, x, z, dimension)

put_entity_values(db, x, z, dimension, values)

put_entity_value(db, x, z, dimension, value)

put_entity_data(db, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Entity_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="Entity_+3A_x">x</code>, <code id="Entity_+3A_z">z</code>, <code id="Entity_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="Entity_+3A_values">values</code></td>
<td>
<p>A list of nbt objects</p>
</td></tr>
<tr><td><code id="Entity_+3A_value">value</code></td>
<td>
<p>An nbt object.</p>
</td></tr>
<tr><td><code id="Entity_+3A_data">data</code></td>
<td>
<p>A named-list specifying key-value pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_entity_data()</code> returns a named-list of nbt data.
<code>get_entity_values()</code> returns a single nbt value.
</p>

<hr>
<h2 id='FinalizedState'>Load and store FinalizedState data</h2><span id='topic+FinalizedState'></span><span id='topic+get_finalized_state_data'></span><span id='topic+get_finalized_state_values'></span><span id='topic+get_finalized_state_value'></span><span id='topic+put_finalized_state_data'></span><span id='topic+put_finalized_state_values'></span><span id='topic+put_finalized_state_value'></span><span id='topic+read_finalized_state_value'></span><span id='topic+write_finalized_state_value'></span>

<h3>Description</h3>

<p>FinalizedState data (tag 54) holds a number which
indicates a chunk's state of generation.
</p>
<p><code>get_finalized_state_data()</code> and <code>get_finalized_state_value()</code> load
FinalizedState data from <code>db</code>. <code>get_finalized_state_data()</code> will silently
drop and keys not representing FinalizedState data.
<code>get_finalized_state_value()</code> supports loading only a single value.
<code>get_finalized_state_values()</code> is a synonym for <code>get_finalized_state_data()</code>.
</p>
<p><code>put_finalized_state_data()</code>, <code>put_finalized_state_values()</code>, and
<code>put_finalized_state_value()</code> store FinalizedState data into a <code>bedrockdb</code>.
</p>
<p><code>read_finalized_state_value()</code> parses a binary FinalizedState record.
</p>
<p><code>write_finalized_state_value()</code> converts a FinalizedState value
to a raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_finalized_state_data(db, x, z, dimension)

get_finalized_state_values(db, x, z, dimension)

get_finalized_state_value(db, x, z, dimension)

put_finalized_state_data(db, data)

put_finalized_state_values(db, x, z, dimension, values)

put_finalized_state_value(db, x, z, dimension, value)

read_finalized_state_value(rawdata)

write_finalized_state_value(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FinalizedState_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="FinalizedState_+3A_x">x</code>, <code id="FinalizedState_+3A_z">z</code>, <code id="FinalizedState_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="FinalizedState_+3A_data">data</code></td>
<td>
<p>A named-vector of key-value pairs for FinalizedState data.</p>
</td></tr>
<tr><td><code id="FinalizedState_+3A_values">values</code></td>
<td>
<p>An integer vector</p>
</td></tr>
<tr><td><code id="FinalizedState_+3A_value">value</code></td>
<td>
<p>a scalar integer</p>
</td></tr>
<tr><td><code id="FinalizedState_+3A_rawdata">rawdata</code></td>
<td>
<p>a raw vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FinalizedState data contains the following information.</p>

<table>
<tr>
 <td style="text-align: left;">
   Value </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> NeedsInstaticking </td><td style="text-align: left;"> Chunk needs to be ticked </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> NeedsPopulation </td><td style="text-align: left;"> Chunk needs to be populated with mobs </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> Done </td><td style="text-align: left;"> Chunk generation is fully complete </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p><code>get_finalized_state_data()</code> returns a named integer vector
of the values returned by <code>get_finalized_state_value()</code>.
</p>

<hr>
<h2 id='from_rnbt'>Raw Named Binary Tag Format</h2><span id='topic+from_rnbt'></span><span id='topic+to_rnbt'></span><span id='topic+from_rnbt_payload'></span><span id='topic+to_rnbt_payload'></span><span id='topic+read_rnbt'></span><span id='topic+write_rnbt'></span>

<h3>Description</h3>

<p><code>from_rnbt()</code> converts <code>rnbt</code> data to <code>nbt</code> data.
<code>to_rnbt()</code> converts <code>nbt</code> data to <code>rnbt</code> data.
<code>read_rnbt()</code> converts a <code>raw</code> vector to <code>rnbt</code> data.
<code>write_rnbt()</code> converts <code>rnbt</code> data to a <code>raw</code> vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_rnbt(x)

to_rnbt(x)

from_rnbt_payload(x, tag)

to_rnbt_payload(x)

read_rnbt(rawdata)

write_rnbt(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_rnbt_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="from_rnbt_+3A_rawdata">rawdata</code></td>
<td>
<p>A <code>raw</code> vector</p>
</td></tr>
<tr><td><code id="from_rnbt_+3A_object">object</code></td>
<td>
<p>An nbt object or a list of nbt objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rnbt</code> is a recursive, intermediate data structure that closely
resembles how NBT data is encoded.
</p>

<hr>
<h2 id='get_chunk_blocks_data'>Load block data from one or more chunks</h2><span id='topic+get_chunk_blocks_data'></span><span id='topic+get_chunk_blocks_values'></span><span id='topic+get_chunk_blocks_value'></span><span id='topic+put_chunk_blocks_data'></span><span id='topic+put_chunk_blocks_values'></span><span id='topic+put_chunk_blocks_value'></span>

<h3>Description</h3>

<p>These functions return block data as strings containing the
block name and block states. The strings' format is
<code>blockname@state1=value1@state2=value2</code> etc.
Blocks may have 0 or more states.
</p>
<p><code>get_chunk_blocks_value()</code> is an alias for <code>get_chunk_blocks_data()</code>
</p>
<p><code>get_chunk_blocks_value()</code> loads block data from a <code>bedrockdb</code>.
It only supports loading a single value.
</p>
<p><code>put_chunk_blocks_data()</code>, <code>put_chunk_blocks_values()</code>, and
<code>put_chunk_blocks_value()</code> stores block data into a <code>bedrockdb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_chunk_blocks_data(
  db,
  x,
  z,
  dimension,
  names_only = FALSE,
  extra_block = FALSE
)

get_chunk_blocks_values(
  db,
  x,
  z,
  dimension,
  names_only = FALSE,
  extra_block = FALSE
)

get_chunk_blocks_value(
  db,
  x,
  z,
  dimension,
  names_only = FALSE,
  extra_block = FALSE
)

put_chunk_blocks_data(db, data, version = 9L)

put_chunk_blocks_values(db, x, z, dimension, values, version = 9L)

put_chunk_blocks_value(db, x, z, dimension, value, version = 9L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_chunk_blocks_data_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="get_chunk_blocks_data_+3A_x">x</code>, <code id="get_chunk_blocks_data_+3A_z">z</code>, <code id="get_chunk_blocks_data_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="get_chunk_blocks_data_+3A_names_only">names_only</code></td>
<td>
<p>A logical scalar. Return only the names of the blocks,
ignoring block states.</p>
</td></tr>
<tr><td><code id="get_chunk_blocks_data_+3A_extra_block">extra_block</code></td>
<td>
<p>A logical scalar. Append the extra block layer to the
output (separated by &quot;;&quot;). This is mostly useful if you have waterlogged
blocks. If the extra block is air, it will not be appended.</p>
</td></tr>
<tr><td><code id="get_chunk_blocks_data_+3A_data">data</code></td>
<td>
<p>A named list of 16xNx16 character() arrays</p>
</td></tr>
<tr><td><code id="get_chunk_blocks_data_+3A_version">version</code></td>
<td>
<p>Which format of subchunk data to use</p>
</td></tr>
<tr><td><code id="get_chunk_blocks_data_+3A_values">values</code></td>
<td>
<p>A list of 16xNx16 character() arrays</p>
</td></tr>
<tr><td><code id="get_chunk_blocks_data_+3A_value">value</code></td>
<td>
<p>A 16xNx16 character array</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_chunk_blocks_data()</code> returns a list of the of the values
returned by <code>read_chunk_blocks_value()</code>.
</p>
<p><code>get_chunk_blocks_value()</code>
return a 16xNx16 character array. The axes represent the <code>x</code>, <code>y</code>, and <code>z</code>
dimensions in that order. The size of the y-axis is based on the highest
subchunk in the coordinate. Missing subchunks are considered air.
</p>

<hr>
<h2 id='get_keys'>Get a list of keys stored in a bedrockdb.</h2><span id='topic+get_keys'></span>

<h3>Description</h3>

<p>Get a list of keys stored in a bedrockdb.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_keys(db, starts_with = NULL, readoptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_keys_+3A_db">db</code></td>
<td>
<p>A <code>bedrockdb</code> object</p>
</td></tr>
<tr><td><code id="get_keys_+3A_starts_with">starts_with</code></td>
<td>
<p>A string specifying chunk prefix or string prefix.</p>
</td></tr>
<tr><td><code id="get_keys_+3A_readoptions">readoptions</code></td>
<td>
<p>A <code>bedrock_leveldb_readoptions</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing all the keys found in the bedrockdb.
</p>
<p>If <code>starts_with</code> is specified, this vector will be filtered for
based on the specified prefix.
</p>

<hr>
<h2 id='get_nbt_data'>Read and Write NBT Data</h2><span id='topic+get_nbt_data'></span><span id='topic+get_nbt_value'></span><span id='topic+get_nbt_values'></span><span id='topic+put_nbt_values'></span><span id='topic+put_nbt_value'></span><span id='topic+put_nbt_data'></span><span id='topic+read_nbt'></span><span id='topic+read_nbt_data'></span><span id='topic+write_nbt'></span><span id='topic+write_nbt_data'></span>

<h3>Description</h3>

<p><code>get_nbt_data()</code> and <code>get_nbt_value()</code> load nbt-formatted data from <code>db</code>
and parses it. <code>get_nbt_values()</code> is a synonym for <code>get_nbt_data()</code>.
</p>
<p><code>put_nbt_values()</code>, <code>put_nbt_value()</code>, and <code>put_nbt_data()</code> store nbt data
into <code>db</code> in binary form.
</p>
<p><code>read_nbt</code> reads NBT data from a <code>raw</code> vector.
</p>
<p><code>read_nbt_data</code> calls <code>read_nbt</code> on each element of a list.
</p>
<p><code>write_nbt</code> encodes NBT data into a <code>raw</code> vector.
</p>
<p><code>write_nbt_data</code> calls <code>write_nbt</code> on each element of a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nbt_data(db, keys, readoptions = NULL, simplify = TRUE)

get_nbt_value(db, key, readoptions = NULL, simplify = TRUE)

get_nbt_values(db, keys, readoptions = NULL, simplify = TRUE)

put_nbt_values(db, keys, values, writeoptions = NULL)

put_nbt_value(db, key, value, writeoptions = NULL)

put_nbt_data(db, data, writeoptions = NULL)

read_nbt(rawdata, simplify = TRUE)

read_nbt_data(data, simplify = TRUE)

write_nbt(object)

write_nbt_data(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nbt_data_+3A_db">db</code></td>
<td>
<p>A <code>bedrockdb</code> object</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_keys">keys</code></td>
<td>
<p>A character vector of keys.</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_readoptions">readoptions</code></td>
<td>
<p>A <code>bedrock_leveldb_readoptions</code> object</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE, simplifies a list containing a single unnamed
<code>nbtnode</code>.</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_key">key</code></td>
<td>
<p>A single key.</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_values">values</code></td>
<td>
<p>A list of nbt objects</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_writeoptions">writeoptions</code></td>
<td>
<p>A <code>bedrock_leveldb_writeoptions</code> object</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_value">value</code></td>
<td>
<p>An nbt object.</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_data">data</code></td>
<td>
<p>A named-list specifying key-value pairs.</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_rawdata">rawdata</code></td>
<td>
<p>A <code>raw</code> vector</p>
</td></tr>
<tr><td><code id="get_nbt_data_+3A_object">object</code></td>
<td>
<p>An nbt object or a list of nbt objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Named Binary Tag (NBT) format is used by Minecraft for various data
types.
</p>

<hr>
<h2 id='get_subchunk_layers_data'>Load and store SubchunkBlocks layers</h2><span id='topic+get_subchunk_layers_data'></span><span id='topic+get_subchunk_layers_values'></span><span id='topic+get_subchunk_layers_value'></span><span id='topic+get_subchunk_layers_from_chunk'></span><span id='topic+put_subchunk_layers_data'></span><span id='topic+put_subchunk_layers_values'></span><span id='topic+put_subchunk_layers_value'></span><span id='topic+read_subchunk_layers_value'></span><span id='topic+write_subchunk_layers_value'></span>

<h3>Description</h3>

<p><code>get_subchunk_layers_data()</code> loads SubchunkBlocks data from a <code>bedrockdb</code>.
It will silently drop and keys not representing SubchunkBlocks data.
<code>get_subchunk_layers_values()</code> is a synonym for <code>get_subchunk_layers_data()</code>.
</p>
<p><code>get_subchunk_layers_value()</code> loads SubchunkBlocks data from a <code>bedrockdb</code>.
It only supports loading a single value.
</p>
<p><code>get_subchunk_layers_value()</code> loads SubchunkBlocks data from a <code>bedrockdb</code>.
It supports efficiently loading subchunk block data from a single chunk.
</p>
<p><code>put_subchunk_layers_data()</code>, <code>put_subchunk_layers_values()</code>, and
<code>put_subchunk_layers_value()</code> store SubchunkBlocks data into a <code>bedrockdb</code>.
</p>
<p><code>read_subchunk_layers_value()</code> decodes binary SubchunkBlock data
into index-mapped arrays and associated block palettes.
</p>
<p><code>write_subchunk_layers_value()</code> encode SubchunkBlock data
into binary form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subchunk_layers_data(db, x, z, dimension, subchunk)

get_subchunk_layers_values(db, x, z, dimension, subchunk)

get_subchunk_layers_value(db, x, z, dimension, subchunk)

get_subchunk_layers_from_chunk(db, x, z, dimension)

put_subchunk_layers_data(db, data, ...)

put_subchunk_layers_values(db, x, z, dimension, subchunk, values, ...)

put_subchunk_layers_value(db, x, z, dimension, subchunk, value, ...)

read_subchunk_layers_value(rawdata)

write_subchunk_layers_value(object, version = 9L, missing_offset = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subchunk_layers_data_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="get_subchunk_layers_data_+3A_x">x</code>, <code id="get_subchunk_layers_data_+3A_z">z</code>, <code id="get_subchunk_layers_data_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="get_subchunk_layers_data_+3A_subchunk">subchunk</code></td>
<td>
<p>Subchunk indexes to extract data from.</p>
</td></tr>
<tr><td><code id="get_subchunk_layers_data_+3A_data">data</code></td>
<td>
<p>A named-vector of key-value pairs for SubchunkBlocks data.</p>
</td></tr>
<tr><td><code id="get_subchunk_layers_data_+3A_values">values</code></td>
<td>
<p>A list of lists of 16x16x16 integer indexes with associated
block_palettes.</p>
</td></tr>
<tr><td><code id="get_subchunk_layers_data_+3A_value">value</code></td>
<td>
<p>A list of 16x16x16 integer indexes with associated
block_palettes.</p>
</td></tr>
<tr><td><code id="get_subchunk_layers_data_+3A_missing_offset">missing_offset</code></td>
<td>
<p>subchunk offset to use if one is not found in <code>rawdata</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_subchunk_layers_data()</code> returns a list of the of the values
returned by <code>read_subchunk_layers_value()</code>.
</p>
<p><code>get_subchunk_layers_value()</code> and <code>read_subchunk_layers_value()</code>
return a list of block layers. Each block layer is a 16x16x16 array of
integers associated with a block palette. The block palette is stored in the
&quot;palette&quot; attribute of the array.
</p>
<p><code>get_subchunk_layers_value()</code> returns a list of the of the values
returned by <code>read_subchunk_layers_value()</code>.
</p>

<hr>
<h2 id='get_values'>Read values stored in a bedrockdb.</h2><span id='topic+get_values'></span><span id='topic+get_data'></span><span id='topic+get_value'></span><span id='topic+has_values'></span>

<h3>Description</h3>

<p><code>get_values()</code> and <code>get_data()</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_values(db, keys, starts_with, readoptions = NULL)

get_data(db, keys, starts_with, readoptions = NULL)

get_value(db, key, readoptions = NULL)

has_values(db, keys, readoptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_values_+3A_db">db</code></td>
<td>
<p>A <code>bedrockdb</code> object</p>
</td></tr>
<tr><td><code id="get_values_+3A_keys">keys</code></td>
<td>
<p>A character vector of keys.</p>
</td></tr>
<tr><td><code id="get_values_+3A_starts_with">starts_with</code></td>
<td>
<p>A string specifying chunk prefix or string prefix.</p>
</td></tr>
<tr><td><code id="get_values_+3A_readoptions">readoptions</code></td>
<td>
<p>A <code>bedrock_leveldb_readoptions</code> object</p>
</td></tr>
<tr><td><code id="get_values_+3A_key">key</code></td>
<td>
<p>A single key.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_values()</code> returns a named-list of raw vectors.
</p>
<p><code>get_value()</code> returns a raw vector.
</p>
<p><code>has_values()</code> returns a logical vector.
</p>

<hr>
<h2 id='HSA'>Read and write HardcodedSpawnArea (HSA) data</h2><span id='topic+HSA'></span><span id='topic+get_hsa_data'></span><span id='topic+get_hsa_values'></span><span id='topic+get_hsa_value'></span><span id='topic+read_hsa_value'></span><span id='topic+put_hsa_data'></span><span id='topic+put_hsa_values'></span><span id='topic+put_hsa_value'></span><span id='topic+write_hsa_value'></span>

<h3>Description</h3>

<p>HardcodedSpawnArea (HSA) data (tag 57) stores information
about any structure spawning locations in a chunk.
An HSA is defined by a bounding box that specifies
the location of an HSA in a chunk and a tag that
specifies the type: 1 = NetherFortress, 2 = SwampHut,
3 = OceanMonument, and 5 = PillagerOutpost.
</p>
<p><code>get_hsa_data()</code> loads HardcodedSpawnArea data from a <code>bedrockdb</code>.
It will silently drop and keys not representing HSA data.
<code>get_hsa_values()</code> is a synonym for <code>get_hsa_data()</code>.
</p>
<p><code>get_hsa_value()</code> loads HSA data from a <code>bedrockdb</code>.
It only supports loading a single value.
</p>
<p><code>read_hsa_value()</code> decodes HSA data.
</p>
<p><code>put_hsa_data()</code> puts HSA data into a <code>bedrockdb</code>.
HSA bounding boxes will be split across chunks and
</p>
<p><code>put_hsa_values()</code> and <code>put_hsa_value()</code> store HSA data
into a <code>bedrockdb</code>.
</p>
<p><code>write_hsa_value()</code> encodes HSA data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hsa_data(db, x, z, dimension)

get_hsa_values(db, x, z, dimension)

get_hsa_value(db, x, z, dimension)

read_hsa_value(rawdata)

put_hsa_data(db, data, merge = TRUE)

put_hsa_values(db, x, z, dimension, values)

put_hsa_value(db, x, z, dimension, value)

write_hsa_value(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HSA_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="HSA_+3A_x">x</code>, <code id="HSA_+3A_z">z</code>, <code id="HSA_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="HSA_+3A_rawdata">rawdata</code></td>
<td>
<p>A scalar raw.</p>
</td></tr>
<tr><td><code id="HSA_+3A_data">data</code></td>
<td>
<p>A table containing HSA coordinates.</p>
</td></tr>
<tr><td><code id="HSA_+3A_merge">merge</code></td>
<td>
<p>Merge the new HSAs with existing HSAs.</p>
</td></tr>
<tr><td><code id="HSA_+3A_values">values</code></td>
<td>
<p>A list of tables containing HSA coordinates and tags.</p>
</td></tr>
<tr><td><code id="HSA_+3A_value">value</code></td>
<td>
<p>A table containing HSA coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_hsa_data()</code> returns a table in the same format
as <code>get_hsa_value()</code>.
</p>
<p><code>get_hsa_value()</code> and <code>read_hsa_value()</code>
return a table with columns indicating the
coordinates of the HSA bounding box and the
location of the HSS at the center of the bounding
box. <code>get_hsa_value()</code> also records the dimension
of the bounding box.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dbpath &lt;- rbedrock_example_world("example1.mcworld")
db &lt;- bedrockdb(dbpath)
# view all HSA in a world
hsa &lt;- get_hsa_data(db, get_keys(db))
hsa
# add an HSA to a world
dat &lt;- data.frame(x1 = 0, x2 = 15, z1 = 0, z2 = 15,
                  y1 = 40, y2 = 60, tag = "SwampHut")
put_hsa_data(db, dat, merge = TRUE)
close(db)
</code></pre>

<hr>
<h2 id='list_biomes'>List Minecraft Bedrock Edition biomes.</h2><span id='topic+list_biomes'></span><span id='topic+biome_id'></span>

<h3>Description</h3>

<p>List Minecraft Bedrock Edition biomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_biomes()

biome_id(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_biomes_+3A_x">x</code></td>
<td>
<p>A character vector containing biome name.</p>
</td></tr>
</table>

<hr>
<h2 id='locate_blocks'>Locate the coordinates of blocks in a chunk</h2><span id='topic+locate_blocks'></span>

<h3>Description</h3>

<p>Locate the coordinates of blocks in a chunk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_blocks(blocks, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locate_blocks_+3A_blocks">blocks</code></td>
<td>
<p>A character array containing block data.</p>
</td></tr>
<tr><td><code id="locate_blocks_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to look for. Passed to <code>stringr::str_detect</code>.</p>
</td></tr>
<tr><td><code id="locate_blocks_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, return non-matching elements.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dbpath &lt;- rbedrock_example_world("example1.mcworld")
db &lt;- bedrockdb(dbpath)
blocks &lt;- get_chunk_blocks_value(db, x=37, z=10, dimension=0)
locate_blocks(blocks, "ore")
close(db)

</code></pre>

<hr>
<h2 id='minecraft_worlds'>Utilities for working with Minecraft world folders.</h2><span id='topic+minecraft_worlds'></span><span id='topic+worlds_dir_path'></span><span id='topic+list_worlds'></span><span id='topic+create_world'></span><span id='topic+export_world'></span><span id='topic+import_world'></span><span id='topic+get_world_path'></span>

<h3>Description</h3>

<p><code>world_dir_path()</code> returns the path to the <code>minecraftWorlds</code> directory. Use
<code>options(rbedrock.worlds_dir_path = "custom/path")</code> to customize the path
as needed.
</p>
<p><code>list_worlds()</code> returns a <code>data.frame()</code> containing information about
Minecraft saved games.
</p>
<p><code>create_world()</code> creates a new Minecraft world.
</p>
<p><code>export_world()</code> exports a world to an archive file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worlds_dir_path(force_default = FALSE)

list_worlds(worlds_dir = worlds_dir_path())

create_world(id = NULL, ..., worlds_dir = worlds_dir_path())

export_world(id, file, worlds_dir = worlds_dir_path(), replace = FALSE)

import_world(file, id = NULL, ..., worlds_dir = worlds_dir_path())

get_world_path(id, worlds_dir = worlds_dir_path())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minecraft_worlds_+3A_force_default">force_default</code></td>
<td>
<p>If <code>TRUE</code>, return most likely world path on the system.</p>
</td></tr>
<tr><td><code id="minecraft_worlds_+3A_worlds_dir">worlds_dir</code></td>
<td>
<p>The path of a <code>minecraftWorlds</code> directory.</p>
</td></tr>
<tr><td><code id="minecraft_worlds_+3A_id">id</code></td>
<td>
<p>The path to a world folder. If the path is not absolute or does not
exist, it is assumed to be the base name of a world folder in <code>worlds_dir</code>.
For <code>import_world()</code>, if <code>id</code> is <code>NULL</code> a unique world id will be
generated. How it is generated is controlled by the
<code>rbedrock.rand_world_id</code> global options. Possible values are &quot;pretty&quot; and
&quot;mcpe&quot;.</p>
</td></tr>
<tr><td><code id="minecraft_worlds_+3A_...">...</code></td>
<td>
<p>Arguments to customize <code>level.dat</code> settings.
Supports dynamic dots via <code>rlang::list2()</code>.</p>
</td></tr>
<tr><td><code id="minecraft_worlds_+3A_file">file</code></td>
<td>
<p>The path to an mcworld file. If exporting, it will be created.
If importing, it will be extracted.</p>
</td></tr>
<tr><td><code id="minecraft_worlds_+3A_replace">replace</code></td>
<td>
<p>If <code>TRUE</code>, overwrite an existing file if necessary.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

create_world(LevelName = "My World", RandomSeed = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='nbt_byte'>Create an NBT value</h2><span id='topic+nbt_byte'></span><span id='topic+nbt_short'></span><span id='topic+nbt_int'></span><span id='topic+nbt_long'></span><span id='topic+nbt_float'></span><span id='topic+nbt_double'></span><span id='topic+nbt_byte_array'></span><span id='topic+nbt_string'></span><span id='topic+nbt_raw_string'></span><span id='topic+nbt_int_array'></span><span id='topic+nbt_long_array'></span><span id='topic+nbt_compound'></span><span id='topic+nbt_list'></span><span id='topic+is_nbt'></span><span id='topic+payload'></span><span id='topic+unnbt'></span><span id='topic+get_nbt_tag'></span>

<h3>Description</h3>

<p>The Named Binary Tag (NBT) format is used by Minecraft for various data
types. An NBT value holds a 'payload' of data and a 'tag' indicating the type
of data held.
</p>
<p><code style="white-space: pre;">&#8288;nbt_*()&#8288;</code> family of functions create nbt data types.
<code>unnbt()</code> recursively strips NBT metadata from an NBT value.
</p>
<p><code>payload()</code> reads an nbt value's payload.
</p>
<p><code>get_nbt_tag()</code> returns the NBT tag corresponding to and NBT value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbt_byte(x)

nbt_short(x)

nbt_int(x)

nbt_long(x)

nbt_float(x)

nbt_double(x)

nbt_byte_array(x)

nbt_string(x)

nbt_raw_string(x)

nbt_int_array(x)

nbt_long_array(x)

nbt_compound(...)

nbt_list(...)

is_nbt(x)

payload(x)

unnbt(x)

get_nbt_tag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbt_byte_+3A_x">x</code></td>
<td>
<p>An nbt value</p>
</td></tr>
<tr><td><code id="nbt_byte_+3A_...">...</code></td>
<td>
<p>Arguments to collect into an NBT compound or NBT list value.
Supports dynamic dots via <code>rlang::list2()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='new_nbt'>Create an NBT value</h2><span id='topic+new_nbt'></span><span id='topic+new_nbt_byte'></span><span id='topic+new_nbt_short'></span><span id='topic+new_nbt_int'></span><span id='topic+new_nbt_long'></span><span id='topic+new_nbt_float'></span><span id='topic+new_nbt_double'></span><span id='topic+new_nbt_byte_array'></span><span id='topic+new_nbt_string'></span><span id='topic+new_nbt_raw_string'></span><span id='topic+new_nbt_int_array'></span><span id='topic+new_nbt_long_array'></span><span id='topic+new_nbt_compound'></span><span id='topic+new_nbt_list'></span>

<h3>Description</h3>

<p>Create an NBT value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_nbt(x, tag)

new_nbt_byte(x)

new_nbt_short(x)

new_nbt_int(x)

new_nbt_long(x)

new_nbt_float(x)

new_nbt_double(x)

new_nbt_byte_array(x)

new_nbt_string(x)

new_nbt_raw_string(x)

new_nbt_int_array(x)

new_nbt_long_array(x)

new_nbt_compound(x)

new_nbt_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_nbt_+3A_x">x</code></td>
<td>
<p>An nbt payload.</p>
</td></tr>
<tr><td><code id="new_nbt_+3A_tag">tag</code></td>
<td>
<p>An integer specifying the tag of the data.</p>
</td></tr>
</table>

<hr>
<h2 id='PendingTicks'>Load and store PendingTicks NBT data</h2><span id='topic+PendingTicks'></span><span id='topic+get_pending_ticks_data'></span><span id='topic+get_pending_ticks_values'></span><span id='topic+get_pending_ticks_value'></span><span id='topic+put_pending_ticks_values'></span><span id='topic+put_pending_ticks_value'></span><span id='topic+put_pending_ticks_data'></span>

<h3>Description</h3>

<p>PendingTicks data (tag 51) holds a list of NBT values for
pending ticks.
</p>
<p><code>get_pending_ticks_data()</code> and <code>get_pending_ticks_value()</code> load PendingTicks
data from <code>db</code>. <code>get_pending_ticks_data()</code> will silently drop and keys not
representing PendingTicks data. <code>get_pending_ticks_value()</code> supports loading
only a single value. <code>get_pending_ticks_values()</code> is a synonym for
<code>get_pending_ticks_data()</code>.
</p>
<p><code>put_pending_ticks_values()</code>, <code>put_pending_ticks_value()</code>, and
<code>put_pending_ticks_data()</code> store PendingTicks data into <code>db</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pending_ticks_data(db, x, z, dimension)

get_pending_ticks_values(db, x, z, dimension)

get_pending_ticks_value(db, x, z, dimension)

put_pending_ticks_values(db, x, z, dimension, values)

put_pending_ticks_value(db, x, z, dimension, value)

put_pending_ticks_data(db, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PendingTicks_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="PendingTicks_+3A_x">x</code>, <code id="PendingTicks_+3A_z">z</code>, <code id="PendingTicks_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="PendingTicks_+3A_values">values</code></td>
<td>
<p>A list of nbt objects</p>
</td></tr>
<tr><td><code id="PendingTicks_+3A_value">value</code></td>
<td>
<p>An nbt object.</p>
</td></tr>
<tr><td><code id="PendingTicks_+3A_data">data</code></td>
<td>
<p>A named-list specifying key-value pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_pending_ticks_data()</code> returns a named-list of nbt data.
<code>get_pending_ticks_values()</code> returns a single nbt value.
</p>

<hr>
<h2 id='put_values'>Write values to a bedrockdb.</h2><span id='topic+put_values'></span><span id='topic+put_value'></span><span id='topic+put_data'></span>

<h3>Description</h3>

<p>Write values to a bedrockdb.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>put_values(db, keys, values, writeoptions = NULL)

put_value(db, key, value, writeoptions = NULL)

put_data(db, data, writeoptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="put_values_+3A_db">db</code></td>
<td>
<p>A <code>bedrockdb</code> object</p>
</td></tr>
<tr><td><code id="put_values_+3A_keys">keys</code></td>
<td>
<p>A character vector of keys.</p>
</td></tr>
<tr><td><code id="put_values_+3A_values">values</code></td>
<td>
<p>A list of raw values.</p>
</td></tr>
<tr><td><code id="put_values_+3A_writeoptions">writeoptions</code></td>
<td>
<p>A <code>bedrock_leveldb_writeoptions</code> object</p>
</td></tr>
<tr><td><code id="put_values_+3A_key">key</code></td>
<td>
<p>A key that will be used to store data.</p>
</td></tr>
<tr><td><code id="put_values_+3A_value">value</code></td>
<td>
<p>A raw vector that contains the information to be written.</p>
</td></tr>
<tr><td><code id="put_values_+3A_data">data</code></td>
<td>
<p>A named-list of raw values, specifying key-value pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible copy of <code>db</code>.
</p>

<hr>
<h2 id='RandomTicks'>Load and store RandomTicks NBT data</h2><span id='topic+RandomTicks'></span><span id='topic+get_random_ticks_data'></span><span id='topic+get_random_ticks_values'></span><span id='topic+get_random_ticks_value'></span><span id='topic+put_random_ticks_values'></span><span id='topic+put_random_ticks_value'></span><span id='topic+put_random_ticks_data'></span>

<h3>Description</h3>

<p>RandomTicks data (tag 59) holds a list of NBT values for
random ticks.
</p>
<p><code>get_random_ticks_data()</code> and <code>get_random_ticks_value()</code> load RandomTicks
data from <code>db</code>. <code>get_random_ticks_data()</code> will silently drop and keys not
representing RandomTicks data. <code>get_random_ticks_value()</code> supports loading
only a single value. <code>get_random_ticks_values()</code> is a synonym for
<code>get_random_ticks_data()</code>.
</p>
<p><code>put_random_ticks_values()</code>, <code>put_random_ticks_value()</code>, and
<code>put_random_ticks_data()</code> store RandomTicks data into <code>db</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_random_ticks_data(db, x, z, dimension)

get_random_ticks_values(db, x, z, dimension)

get_random_ticks_value(db, x, z, dimension)

put_random_ticks_values(db, x, z, dimension, values)

put_random_ticks_value(db, x, z, dimension, value)

put_random_ticks_data(db, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RandomTicks_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="RandomTicks_+3A_x">x</code>, <code id="RandomTicks_+3A_z">z</code>, <code id="RandomTicks_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="RandomTicks_+3A_values">values</code></td>
<td>
<p>A list of nbt objects</p>
</td></tr>
<tr><td><code id="RandomTicks_+3A_value">value</code></td>
<td>
<p>An nbt object.</p>
</td></tr>
<tr><td><code id="RandomTicks_+3A_data">data</code></td>
<td>
<p>A named-list specifying key-value pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_random_ticks_data()</code> returns a named-list of nbt data.
<code>get_random_ticks_values()</code> returns a single nbt value.
</p>

<hr>
<h2 id='rbedrock_example'>Get path to rbedrock example</h2><span id='topic+rbedrock_example'></span><span id='topic+rbedrock_example_world'></span>

<h3>Description</h3>

<p>rbedrock comes bundled with a number of sample files in its <code>inst/extdata</code>
directory. This function make them easy to access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbedrock_example(path = NULL)

rbedrock_example_world(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbedrock_example_+3A_path">path</code></td>
<td>
<p>Name of file or directory. If <code>NULL</code>, the examples will be
listed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rbedrock_example()
rbedrock_example("example1.mcworld")
rbedrock_example_world("example1.mcworld")
</code></pre>

<hr>
<h2 id='read_leveldat'>Read and write data from a world's level.dat file.</h2><span id='topic+read_leveldat'></span><span id='topic+write_leveldat'></span>

<h3>Description</h3>

<p>Read and write data from a world's level.dat file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_leveldat(path, old = FALSE)

write_leveldat(object, path, old = FALSE, version = 8L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_leveldat_+3A_path">path</code></td>
<td>
<p>The path to a world folder. If the path does not exist, it is
assumed to be the base name of a world folder in the local minecraftWorlds
directory.</p>
</td></tr>
<tr><td><code id="read_leveldat_+3A_old">old</code></td>
<td>
<p>Read/write to 'level.dat_old' instead.</p>
</td></tr>
<tr><td><code id="read_leveldat_+3A_object">object</code></td>
<td>
<p>NBT data to be written to level.dat.</p>
</td></tr>
<tr><td><code id="read_leveldat_+3A_version">version</code></td>
<td>
<p>The level.dat format version for the file header.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read_leveldat</code> returns nbt data.
</p>
<p><code>write_leveldat</code> returns a copy of the data written.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fix level.dat after opening a world in creative.
dbpath &lt;- rbedrock_example_world("example1.mcworld")
dat &lt;- read_leveldat(dbpath)
dat$hasBeenLoadedInCreative &lt;- FALSE
write_leveldat(dat, dbpath)

</code></pre>

<hr>
<h2 id='repair_world'>Try to repair a world database.</h2><span id='topic+repair_world'></span>

<h3>Description</h3>

<p>Try to repair a world database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repair_world(id)
</code></pre>

<hr>
<h2 id='simulation_area'>Calculate a player-based simulation area</h2><span id='topic+simulation_area'></span>

<h3>Description</h3>

<p>Calculate a player-based simulation area
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation_area(sim_distance, x = 0, z = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulation_area_+3A_sim_distance">sim_distance</code></td>
<td>
<p>A sim distance setting</p>
</td></tr>
<tr><td><code id="simulation_area_+3A_x">x</code>, <code id="simulation_area_+3A_z">z</code></td>
<td>
<p>Chunk coordinates where a player is standing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the chunk coordinates in the simulation
area.
</p>

<hr>
<h2 id='spawning_area'>Calculate a player-based spawning area</h2><span id='topic+spawning_area'></span>

<h3>Description</h3>

<p>Calculate a player-based spawning area
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spawning_area(sim_distance, x = 0, z = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spawning_area_+3A_sim_distance">sim_distance</code></td>
<td>
<p>A sim distance setting</p>
</td></tr>
<tr><td><code id="spawning_area_+3A_x">x</code>, <code id="spawning_area_+3A_z">z</code></td>
<td>
<p>Chunk coordinates where a player is standing (can be fractional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the chunk coordinates in the spawning area.
</p>

<hr>
<h2 id='SubchunkBlocks'>Load and store SubchunkBlocks data</h2><span id='topic+SubchunkBlocks'></span><span id='topic+get_subchunk_blocks_data'></span><span id='topic+get_subchunk_blocks_values'></span><span id='topic+get_subchunk_blocks_value'></span><span id='topic+get_subchunk_blocks_from_chunk'></span><span id='topic+put_subchunk_blocks_data'></span><span id='topic+put_subchunk_blocks_values'></span><span id='topic+put_subchunk_blocks_value'></span><span id='topic+read_subchunk_blocks_value'></span><span id='topic+write_subchunk_blocks_value'></span><span id='topic+subchunk_origins'></span><span id='topic+subchunk_coords'></span>

<h3>Description</h3>

<p>SubchunkBlocks data (tag 47) holds information about the blocks in a
subchunks. Each chunk is divided into multiple 16x16x16 subchunks, and each
subchunk is stored separately and indicated by the use of the subtag.
Blocks are stored in a palette-based format. Subchunks can have two layers
of blocks, and the extra layer is most-often used to store water for
water-logged blocks.
</p>
<p>These functions return block data as strings containing the
block name and block states. The strings' format is
<code>blockname@state1=value1@state2=value2</code> etc.
Blocks may have 0 or more states.
</p>
<p><code>get_subchunk_blocks_data()</code> loads SubchunkBlocks data from a <code>bedrockdb</code>.
It will silently drop and keys not representing SubchunkBlocks data.
<code>get_subchunk_blocks_values()</code> is a synonym for <code>get_subchunk_blocks_data()</code>.
</p>
<p><code>get_subchunk_blocks_value()</code> loads SubchunkBlocks data from a <code>bedrockdb</code>.
It only supports loading a single value.
</p>
<p><code>get_subchunk_blocks_from_chunk()</code> loads SubchunkBlocks data from a
<code>bedrockdb</code>. It supports efficiently loading subchunk block data from a
single chunk.
</p>
<p><code>put_subchunk_blocks_data()</code>, <code>put_subchunk_blocks_values()</code>, and
<code>put_subchunk_blocks_value()</code> store SubchunkBlocks data into a <code>bedrockdb</code>.
</p>
<p><code>read_subchunk_blocks_value()</code> decodes binary SubchunkBlock data.
</p>
<p><code>subchunk_origins()</code> returns a matrix containing the block coordinate of the
lower NW corner of subchunk keys
</p>
<p><code>subchunk_coords()</code> determines the block coordinates of blocks based on their
array indexes and their subchunk origins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subchunk_blocks_data(
  db,
  x,
  z,
  dimension,
  subchunk,
  names_only = FALSE,
  extra_block = FALSE
)

get_subchunk_blocks_values(
  db,
  x,
  z,
  dimension,
  subchunk,
  names_only = FALSE,
  extra_block = FALSE
)

get_subchunk_blocks_value(
  db,
  x,
  z,
  dimension,
  subchunk,
  names_only = FALSE,
  extra_block = FALSE
)

get_subchunk_blocks_from_chunk(
  db,
  x,
  z,
  dimension,
  names_only = FALSE,
  extra_block = FALSE
)

put_subchunk_blocks_data(db, data, version = 9L)

put_subchunk_blocks_values(db, x, z, dimension, subchunk, values, version = 9L)

put_subchunk_blocks_value(db, x, z, dimension, subchunk, value, version = 9L)

read_subchunk_blocks_value(
  rawdata,
  missing_offset = NA,
  names_only = FALSE,
  extra_block = FALSE
)

write_subchunk_blocks_value(object, version = 9L, missing_offset = NA_integer_)

subchunk_origins(keys)

subchunk_coords(ind, origins = subchunk_origins(names(ind)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SubchunkBlocks_+3A_db">db</code></td>
<td>
<p>A bedrockdb object.</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_x">x</code>, <code id="SubchunkBlocks_+3A_z">z</code>, <code id="SubchunkBlocks_+3A_dimension">dimension</code></td>
<td>
<p>Chunk coordinates to extract data from.
<code>x</code> can also be a character vector of db keys.</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_subchunk">subchunk</code></td>
<td>
<p>Subchunk indexes to extract data from.</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_names_only">names_only</code></td>
<td>
<p>A logical scalar. Return only the names of the blocks,
ignoring block states.</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_extra_block">extra_block</code></td>
<td>
<p>A logical scalar. Append the extra block layer to the
output (separated by &quot;;&quot;). This is mostly useful if you have waterlogged
blocks. If the extra block is air, it will not be appended.</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_data">data</code></td>
<td>
<p>A named list of 16x16x16 character() arrays</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_version">version</code></td>
<td>
<p>Which format of subchunk data to use</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_values">values</code></td>
<td>
<p>A list of 16x16x16 character() arrays</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_value">value</code></td>
<td>
<p>A 16x16x16 character array</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_rawdata">rawdata</code></td>
<td>
<p>a raw vector holding binary SubchunkBlock data</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_missing_offset">missing_offset</code></td>
<td>
<p>subchunk offset to use if one is not found in <code>rawdata</code></p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_object">object</code></td>
<td>
<p>A 16x16x16 character array.</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_keys">keys</code></td>
<td>
<p>A character vector of database keys.</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_ind">ind</code></td>
<td>
<p>Numeric vector or a named list of numeric vectors containing
indexes for blocks in a subchunk.</p>
</td></tr>
<tr><td><code id="SubchunkBlocks_+3A_origins">origins</code></td>
<td>
<p>A matrix of subchunk origins.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a subchunk contains only air it will not be stored in the database, and
missing subchunks are considered air.
</p>


<h3>Value</h3>

<p><code>get_subchunk_blocks_data()</code> returns a list of the of the values
returned by <code>read_subchunk_blocks_value()</code>.
</p>
<p><code>get_subchunk_blocks_value()</code> and <code>read_subchunk_blocks_value()</code>
return a 16x16x16 character array. The axes represent the <code>x</code>, <code>y</code>, and <code>z</code>
dimensions in that order.
</p>
<p><code>get_subchunk_blocks_from_chunk()</code> returns a list of the of the
values returned by <code>read_subchunk_blocks_value()</code>.
</p>
<p><code>read_subchunk_blocks_value()</code> returns a 16x16x16 character array.
The axes represent the <code>x</code>, <code>y</code>, and <code>z</code> dimensions in that order.
</p>
<p><code>subchunk_coords()</code> returns a 3-column matrix of block coordinates.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
