<!DOCTYPE html><html><head><title>Help for package SqlRender</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SqlRender}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#camelCaseToSnakeCase'><p>Convert a camel case string to snake case</p></a></li>
<li><a href='#camelCaseToSnakeCaseNames'><p>Convert the names of an object from camel case to snake case</p></a></li>
<li><a href='#camelCaseToTitleCase'><p>Convert a camel case string to title case</p></a></li>
<li><a href='#createRWrapperForSql'><p>Create an R wrapper for SQL</p></a></li>
<li><a href='#getTempTablePrefix'><p>Get the prefix used for emulated temp tables for DBMSs that do not support temp tables (e.g. Oracle,</p>
BigQuery).</a></li>
<li><a href='#launchSqlRenderDeveloper'><p>Launch the SqlRender Developer Shiny app</p></a></li>
<li><a href='#listSupportedDialects'><p>List the supported target dialects</p></a></li>
<li><a href='#loadRenderTranslateSql'><p>Load, render, and translate a SQL file in a package</p></a></li>
<li><a href='#readSql'><p>Reads a SQL file</p></a></li>
<li><a href='#render'><p>Render SQL code based on parameterized SQL and parameter values</p></a></li>
<li><a href='#renderSql'><p>Deprecated: Render SQL code based on parameterized SQL and parameter values</p></a></li>
<li><a href='#renderSqlFile'><p>Render a SQL file</p></a></li>
<li><a href='#snakeCaseToCamelCase'><p>Convert a snake case string to camel case</p></a></li>
<li><a href='#snakeCaseToCamelCaseNames'><p>Convert the names of an object from snake case to camel case</p></a></li>
<li><a href='#sparkHandleInsert'><p>Handles Spark Inserts</p></a></li>
<li><a href='#splitSql'><p>Split a single SQL string into one or more SQL statements</p></a></li>
<li><a href='#SqlRender-package'><p>SqlRender: Rendering Parameterized SQL and Translation to Dialects</p></a></li>
<li><a href='#supportsJava8'><p>Determine if Java virtual machine supports Java</p></a></li>
<li><a href='#translate'><p>Translates SQL from one dialect to another</p></a></li>
<li><a href='#translateSingleStatement'><p>Translates a single SQL statement from one dialect to another</p></a></li>
<li><a href='#translateSql'><p>Deprecated: Translates SQL from one dialect to another</p></a></li>
<li><a href='#translateSqlFile'><p>Translate a SQL file</p></a></li>
<li><a href='#writeSql'><p>Write SQL to a SQL (text) file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Rendering Parameterized SQL and Translation to Dialects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.17.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martijn Schuemie &lt;schuemie@ohdsi.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A rendering tool for parameterized SQL that also translates into
  different SQL dialects.  These dialects include 'Microsoft SQL Server', 'Oracle', 
  'PostgreSql', 'Amazon RedShift', 'Apache Impala', 'IBM Netezza', 'Google BigQuery', 'Microsoft PDW', 'Snowflake', 
  'Azure Synapse Analytics Dedicated', 'Apache Spark', and 'SQLite'.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 8)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ohdsi.github.io/SqlRender/">https://ohdsi.github.io/SqlRender/</a>,
<a href="https://github.com/OHDSI/SqlRender">https://github.com/OHDSI/SqlRender</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OHDSI/SqlRender/issues">https://github.com/OHDSI/SqlRender/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>rJava, rlang, checkmate</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, shiny, shinydashboard</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 13:37:47 UTC; schuemie</td>
</tr>
<tr>
<td>Author:</td>
<td>Martijn Schuemie [aut, cre],
  Marc Suchard [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 16:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='camelCaseToSnakeCase'>Convert a camel case string to snake case</h2><span id='topic+camelCaseToSnakeCase'></span>

<h3>Description</h3>

<p>Convert a camel case string to snake case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>camelCaseToSnakeCase(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="camelCaseToSnakeCase_+3A_string">string</code></td>
<td>
<p>The string to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>camelCaseToSnakeCase("exposureConceptId1")

</code></pre>

<hr>
<h2 id='camelCaseToSnakeCaseNames'>Convert the names of an object from camel case to snake case</h2><span id='topic+camelCaseToSnakeCaseNames'></span>

<h3>Description</h3>

<p>Convert the names of an object from camel case to snake case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>camelCaseToSnakeCaseNames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="camelCaseToSnakeCaseNames_+3A_object">object</code></td>
<td>
<p>The object of which the names should be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same object, but with converted names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(conceptId = 1, conceptName = "b")
camelCaseToSnakeCaseNames(x)

</code></pre>

<hr>
<h2 id='camelCaseToTitleCase'>Convert a camel case string to title case</h2><span id='topic+camelCaseToTitleCase'></span>

<h3>Description</h3>

<p>Convert a camel case string to title case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>camelCaseToTitleCase(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="camelCaseToTitleCase_+3A_string">string</code></td>
<td>
<p>The string to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>camelCaseToTitleCase("exposureConceptId1")

</code></pre>

<hr>
<h2 id='createRWrapperForSql'>Create an R wrapper for SQL</h2><span id='topic+createRWrapperForSql'></span>

<h3>Description</h3>

<p><code>createRWrapperForSql</code> creates an R wrapper for a parameterized SQL file. The created R script
file will contain a single function, that executes the SQL, and accepts the same parameters as
specified in the SQL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRWrapperForSql(
  sqlFilename,
  rFilename,
  packageName,
  createRoxygenTemplate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRWrapperForSql_+3A_sqlfilename">sqlFilename</code></td>
<td>
<p>The SQL file.</p>
</td></tr>
<tr><td><code id="createRWrapperForSql_+3A_rfilename">rFilename</code></td>
<td>
<p>The name of the R file to be generated. Defaults to the name of the
SQL file with the extension reset to R.</p>
</td></tr>
<tr><td><code id="createRWrapperForSql_+3A_packagename">packageName</code></td>
<td>
<p>The name of the package that will contains the SQL file.</p>
</td></tr>
<tr><td><code id="createRWrapperForSql_+3A_createroxygentemplate">createRoxygenTemplate</code></td>
<td>
<p>If true, a template of Roxygen comments will be added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads the declarations of defaults in the parameterized SQL file, and creates an R
function that exposes the parameters. It uses the <code>loadRenderTranslateSql</code> function, and
assumes the SQL will be used inside a package. To use inside a package, the SQL file should be
placed in the inst/sql/sql_server folder of the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This will create a file called CohortMethod.R:
createRWrapperForSql("CohortMethod.sql", packageName = "CohortMethod")

## End(Not run)
</code></pre>

<hr>
<h2 id='getTempTablePrefix'>Get the prefix used for emulated temp tables for DBMSs that do not support temp tables (e.g. Oracle,
BigQuery).</h2><span id='topic+getTempTablePrefix'></span>

<h3>Description</h3>

<p>Get the prefix used for emulated temp tables for DBMSs that do not support temp tables (e.g. Oracle,
BigQuery).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTempTablePrefix()
</code></pre>


<h3>Value</h3>

<p>The prefix string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getTempTablePrefix()
</code></pre>

<hr>
<h2 id='launchSqlRenderDeveloper'>Launch the SqlRender Developer Shiny app</h2><span id='topic+launchSqlRenderDeveloper'></span>

<h3>Description</h3>

<p>Launch the SqlRender Developer Shiny app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launchSqlRenderDeveloper(launch.browser = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launchSqlRenderDeveloper_+3A_launch.browser">launch.browser</code></td>
<td>
<p>Should the app be launched in your default browser, or in a Shiny window.
Note: copying to clipboard will not work in a Shiny window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Launches a Shiny app that allows the user to develop SQL and see how it translates to the supported
dialects.
</p>

<hr>
<h2 id='listSupportedDialects'>List the supported target dialects</h2><span id='topic+listSupportedDialects'></span>

<h3>Description</h3>

<p>List the target dialects supported by the <code><a href="#topic+translate">translate</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listSupportedDialects()
</code></pre>


<h3>Value</h3>

<p>A data frame with two columns. The 'dialect' column contains the abbreviation used in SqlRender, and the
'description' column contains a more human-readable description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>listSupportedDialects()
</code></pre>

<hr>
<h2 id='loadRenderTranslateSql'>Load, render, and translate a SQL file in a package</h2><span id='topic+loadRenderTranslateSql'></span>

<h3>Description</h3>

<p><code>loadRenderTranslateSql</code> Loads a SQL file contained in a package, renders it and translates it
to the specified dialect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadRenderTranslateSql(
  sqlFilename,
  packageName,
  dbms = "sql server",
  ...,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  oracleTempSchema = NULL,
  warnOnMissingParameters = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadRenderTranslateSql_+3A_sqlfilename">sqlFilename</code></td>
<td>
<p>The source SQL file</p>
</td></tr>
<tr><td><code id="loadRenderTranslateSql_+3A_packagename">packageName</code></td>
<td>
<p>The name of the package that contains the SQL file</p>
</td></tr>
<tr><td><code id="loadRenderTranslateSql_+3A_dbms">dbms</code></td>
<td>
<p>The target dialect. Currently 'sql server', 'oracle', 'postgres',
and 'redshift' are supported</p>
</td></tr>
<tr><td><code id="loadRenderTranslateSql_+3A_...">...</code></td>
<td>
<p>Parameter values used for <code>render</code></p>
</td></tr>
<tr><td><code id="loadRenderTranslateSql_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="loadRenderTranslateSql_+3A_oracletempschema">oracleTempSchema</code></td>
<td>
<p>DEPRECATED: use <code>tempEmulationSchema</code> instead.</p>
</td></tr>
<tr><td><code id="loadRenderTranslateSql_+3A_warnonmissingparameters">warnOnMissingParameters</code></td>
<td>
<p>Should a warning be raised when parameters provided to this
function do not appear in the parameterized SQL that is being
rendered? By default, this is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function looks for a SQL file with the specified name in the inst/sql/&lt;dbms&gt; folder of the
specified package. If it doesn't find it in that folder, it will try and load the file from the
inst/sql or inst/sql/sql_server folder and use the <code>translate</code> function to translate it to the 
requested dialect. It will subsequently call the <code>render</code> function with any of the additional 
specified parameters.
</p>


<h3>Value</h3>

<p>Returns a string containing the rendered SQL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
renderedSql &lt;- loadRenderTranslateSql("CohortMethod.sql",
  packageName = "CohortMethod",
  dbms = connectionDetails$dbms,
  CDM_schema = "cdmSchema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='readSql'>Reads a SQL file</h2><span id='topic+readSql'></span>

<h3>Description</h3>

<p><code>readSql</code> loads SQL from a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSql(sourceFile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSql_+3A_sourcefile">sourceFile</code></td>
<td>
<p>The source SQL file</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readSql</code> loads SQL from a file
</p>


<h3>Value</h3>

<p>Returns a string containing the SQL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
readSql("myParamStatement.sql")

## End(Not run)
</code></pre>

<hr>
<h2 id='render'>Render SQL code based on parameterized SQL and parameter values</h2><span id='topic+render'></span>

<h3>Description</h3>

<p><code>render</code> Renders SQL code based on parameterized SQL and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render(sql, warnOnMissingParameters = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_+3A_sql">sql</code></td>
<td>
<p>The parameterized SQL</p>
</td></tr>
<tr><td><code id="render_+3A_warnonmissingparameters">warnOnMissingParameters</code></td>
<td>
<p>Should a warning be raised when parameters provided to this
function do not appear in the parameterized SQL that is being
rendered? By default, this is TRUE.</p>
</td></tr>
<tr><td><code id="render_+3A_...">...</code></td>
<td>
<p>Parameter values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes parameterized SQL and a list of parameter values and renders the SQL that can
be send to the server. Parameterization syntax: </p>
 <dl>
<dt>@parameterName</dt><dd><p>Parameters are
indicated using a @ prefix, and are replaced with the actual values provided in the render call.</p>
</dd>
<dt>{DEFAULT @parameterName = parameterValue}</dt><dd><p>Default values for parameters can be defined
using curly and the DEFAULT keyword.</p>
</dd> <dt>{if}?{then}:{else}</dt><dd><p>The if-then-else pattern is
used to turn on or off blocks of SQL code.</p>
</dd> </dl>



<h3>Value</h3>

<p>A character string containing the rendered SQL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>render("SELECT * FROM @a;", a = "myTable")
render("SELECT * FROM @a {@b}?{WHERE x = 1};", a = "myTable", b = "true")
render("SELECT * FROM @a {@b == ''}?{WHERE x = 1}:{ORDER BY x};", a = "myTable", b = "true")
render("SELECT * FROM @a {@b != ''}?{WHERE @b = 1};", a = "myTable", b = "y")
render("SELECT * FROM @a {1 IN (@c)}?{WHERE @b = 1};",
  a = "myTable",
  b = "y",
  c = c(1, 2, 3, 4)
)
render("{DEFAULT @b = \"someField\"}SELECT * FROM @a {@b != ''}?{WHERE @b = 1};",
  a = "myTable"
)
render("SELECT * FROM @a {@a == 'myTable' &amp; @b != 'x'}?{WHERE @b = 1};",
  a = "myTable",
  b = "y"
)
render(
  sql = "SELECT * FROM @a;",
  warnOnMissingParameters = FALSE,
  a = "myTable",
  b = "missingParameter"
)
</code></pre>

<hr>
<h2 id='renderSql'>Deprecated: Render SQL code based on parameterized SQL and parameter values</h2><span id='topic+renderSql'></span>

<h3>Description</h3>

<p>This function has been deprecated. Use <code><a href="#topic+render">render</a></code> instead. This new function returns a
character vector instead of a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renderSql(sql = "", warnOnMissingParameters = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renderSql_+3A_sql">sql</code></td>
<td>
<p>The parameterized SQL</p>
</td></tr>
<tr><td><code id="renderSql_+3A_warnonmissingparameters">warnOnMissingParameters</code></td>
<td>
<p>Should a warning be raised when parameters provided to this
function do not appear in the parameterized SQL that is being
rendered? By default, this is TRUE.</p>
</td></tr>
<tr><td><code id="renderSql_+3A_...">...</code></td>
<td>
<p>Parameter values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>
 <dl>
<dt>parameterizedSql</dt><dd><p>The original
parameterized SQL code</p>
</dd> <dt>sql</dt><dd><p>The rendered sql</p>
</dd> </dl>


<hr>
<h2 id='renderSqlFile'>Render a SQL file</h2><span id='topic+renderSqlFile'></span>

<h3>Description</h3>

<p><code>renderSqlFile</code> Renders SQL code in a file based on parameterized SQL and parameter values,
and writes it to another file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renderSqlFile(sourceFile, targetFile, warnOnMissingParameters = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renderSqlFile_+3A_sourcefile">sourceFile</code></td>
<td>
<p>The source SQL file</p>
</td></tr>
<tr><td><code id="renderSqlFile_+3A_targetfile">targetFile</code></td>
<td>
<p>The target SQL file</p>
</td></tr>
<tr><td><code id="renderSqlFile_+3A_warnonmissingparameters">warnOnMissingParameters</code></td>
<td>
<p>Should a warning be raised when parameters provided to this
function do not appear in the parameterized SQL that is being
rendered? By default, this is TRUE.</p>
</td></tr>
<tr><td><code id="renderSqlFile_+3A_...">...</code></td>
<td>
<p>Parameter values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes parameterized SQL and a list of parameter values and renders the SQL that can
be send to the server. Parameterization syntax: </p>
 <dl>
<dt>@parameterName</dt><dd><p>Parameters are
indicated using a @ prefix, and are replaced with the actual values provided in the render call.</p>
</dd>
<dt>{DEFAULT @parameterName = parameterValue}</dt><dd><p>Default values for parameters can be defined
using curly and the DEFAULT keyword.</p>
</dd> <dt>{if}?{then}:{else}</dt><dd><p>The if-then-else pattern is
used to turn on or off blocks of SQL code.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
renderSqlFile("myParamStatement.sql", "myRenderedStatement.sql", a = "myTable")

## End(Not run)
</code></pre>

<hr>
<h2 id='snakeCaseToCamelCase'>Convert a snake case string to camel case</h2><span id='topic+snakeCaseToCamelCase'></span>

<h3>Description</h3>

<p>Convert a snake case string to camel case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snakeCaseToCamelCase(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snakeCaseToCamelCase_+3A_string">string</code></td>
<td>
<p>The string to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snakeCaseToCamelCase("exposure_concept_id_1")

</code></pre>

<hr>
<h2 id='snakeCaseToCamelCaseNames'>Convert the names of an object from snake case to camel case</h2><span id='topic+snakeCaseToCamelCaseNames'></span>

<h3>Description</h3>

<p>Convert the names of an object from snake case to camel case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snakeCaseToCamelCaseNames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snakeCaseToCamelCaseNames_+3A_object">object</code></td>
<td>
<p>The object of which the names should be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same object, but with converted names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(concept_id = 1, concept_name = "b")
snakeCaseToCamelCaseNames(x)

</code></pre>

<hr>
<h2 id='sparkHandleInsert'>Handles Spark Inserts</h2><span id='topic+sparkHandleInsert'></span>

<h3>Description</h3>

<p>This function is for Spark connections only,
it handles insert commands, as Spark cannot handle inserts with aliased or subset columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparkHandleInsert(sql, connection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparkHandleInsert_+3A_sql">sql</code></td>
<td>
<p>The SQL to be translated.</p>
</td></tr>
<tr><td><code id="sparkHandleInsert_+3A_connection">connection</code></td>
<td>
<p>The connection to the database server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sql string with INSERT command modified to contain the full column list, padded with NULLS as needed.
</p>

<hr>
<h2 id='splitSql'>Split a single SQL string into one or more SQL statements</h2><span id='topic+splitSql'></span>

<h3>Description</h3>

<p><code>splitSql</code> splits a string containing multiple SQL statements into a vector of SQL statements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitSql(sql)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitSql_+3A_sql">sql</code></td>
<td>
<p>The SQL string to split into separate statements</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is needed because some DBMSs (like ORACLE) do not accepts multiple SQL statements
being sent as one execution.
</p>


<h3>Value</h3>

<p>A vector of strings, one for each SQL statement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splitSql("SELECT * INTO a FROM b; USE x; DROP TABLE c;")
</code></pre>

<hr>
<h2 id='SqlRender-package'>SqlRender: Rendering Parameterized SQL and Translation to Dialects</h2><span id='topic+SqlRender'></span><span id='topic+SqlRender-package'></span>

<h3>Description</h3>

<p>A rendering tool for parameterized SQL that also translates into different SQL dialects. These dialects include 'Microsoft SQL Server', 'Oracle', 'PostgreSql', 'Amazon RedShift', 'Apache Impala', 'IBM Netezza', 'Google BigQuery', 'Microsoft PDW', 'Snowflake', 'Azure Synapse Analytics Dedicated', 'Apache Spark', and 'SQLite'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martijn Schuemie <a href="mailto:schuemie@ohdsi.org">schuemie@ohdsi.org</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Marc Suchard
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ohdsi.github.io/SqlRender/">https://ohdsi.github.io/SqlRender/</a>
</p>
</li>
<li> <p><a href="https://github.com/OHDSI/SqlRender">https://github.com/OHDSI/SqlRender</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/OHDSI/SqlRender/issues">https://github.com/OHDSI/SqlRender/issues</a>
</p>
</li></ul>


<hr>
<h2 id='supportsJava8'>Determine if Java virtual machine supports Java</h2><span id='topic+supportsJava8'></span>

<h3>Description</h3>

<p>Tests Java virtual machine (JVM) java.version system property to check if version &gt;= 8.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supportsJava8()
</code></pre>


<h3>Value</h3>

<p>Returns TRUE if JVM supports Java &gt;= 8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>supportsJava8()
</code></pre>

<hr>
<h2 id='translate'>Translates SQL from one dialect to another</h2><span id='topic+translate'></span>

<h3>Description</h3>

<p><code>translate</code> translates SQL from one dialect to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate(
  sql,
  targetDialect,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  oracleTempSchema = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_+3A_sql">sql</code></td>
<td>
<p>The SQL to be translated</p>
</td></tr>
<tr><td><code id="translate_+3A_targetdialect">targetDialect</code></td>
<td>
<p>The target dialect. Currently &quot;oracle&quot;, &quot;postgresql&quot;, &quot;pdw&quot;, &quot;impala&quot;,
&quot;sqlite&quot;, &quot;sqlite extended&quot;, &quot;netezza&quot;, &quot;bigquery&quot;, &quot;snowflake&quot;, &quot;synapse&quot;, &quot;spark&quot;, and &quot;redshift&quot; are supported.
Use <code><a href="#topic+listSupportedDialects">listSupportedDialects</a></code> to get the list of supported dialects.</p>
</td></tr>
<tr><td><code id="translate_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="translate_+3A_oracletempschema">oracleTempSchema</code></td>
<td>
<p>DEPRECATED: use <code>tempEmulationSchema</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes SQL in one dialect and translates it into another. It uses simple pattern
replacement, so its functionality is limited. Note that trailing semicolons are not removed for
Oracle, which is required before sending a statement through JDBC. This will be done by
<code><a href="#topic+splitSql">splitSql</a></code>.
</p>


<h3>Value</h3>

<p>A character string containing the translated SQL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>translate("USE my_schema;", targetDialect = "oracle")
</code></pre>

<hr>
<h2 id='translateSingleStatement'>Translates a single SQL statement from one dialect to another</h2><span id='topic+translateSingleStatement'></span>

<h3>Description</h3>

<p><code>translateSingleStatement</code> translates a single SQL statement from one dialect to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translateSingleStatement(
  sql = "",
  targetDialect,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  oracleTempSchema = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translateSingleStatement_+3A_sql">sql</code></td>
<td>
<p>The SQL to be translated</p>
</td></tr>
<tr><td><code id="translateSingleStatement_+3A_targetdialect">targetDialect</code></td>
<td>
<p>The target dialect. Currently &quot;oracle&quot;, &quot;postgresql&quot;, &quot;pdw&quot;, &quot;impala&quot;,
&quot;sqlite&quot;, &quot;sqlite extended&quot;, &quot;netezza&quot;, &quot;bigquery&quot;, &quot;snowflake&quot;, &quot;synapse&quot;, &quot;spark&quot;, and &quot;redshift&quot; are supported.</p>
</td></tr>
<tr><td><code id="translateSingleStatement_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="translateSingleStatement_+3A_oracletempschema">oracleTempSchema</code></td>
<td>
<p>DEPRECATED: use <code>tempEmulationSchema</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes SQL in one dialect and translates it into another. It uses simple pattern
replacement, so its functionality is limited. This removes any trailing semicolon as required by
Oracle when sending through JDBC. An error is thrown if more than one statement is encountered in
the SQL.
</p>


<h3>Value</h3>

<p>A character vector with the translated SQL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>translateSingleStatement("USE my_schema;", targetDialect = "oracle")
</code></pre>

<hr>
<h2 id='translateSql'>Deprecated: Translates SQL from one dialect to another</h2><span id='topic+translateSql'></span>

<h3>Description</h3>

<p>This function has been deprecated. Use <code><a href="#topic+translate">translate</a></code> instead. This new function returns a
character vector instead of a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translateSql(sql = "", targetDialect, oracleTempSchema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translateSql_+3A_sql">sql</code></td>
<td>
<p>The SQL to be translated</p>
</td></tr>
<tr><td><code id="translateSql_+3A_targetdialect">targetDialect</code></td>
<td>
<p>The target dialect. Currently &quot;oracle&quot;, &quot;postgresql&quot;, &quot;pdw&quot;, &quot;impala&quot;,
&quot;netezza&quot;, &quot;bigquery&quot;, &quot;snowflake&quot;, &quot;synapse&quot;, &quot;spark&quot;, and &quot;redshift&quot; are supported</p>
</td></tr>
<tr><td><code id="translateSql_+3A_oracletempschema">oracleTempSchema</code></td>
<td>
<p>A schema that can be used to create temp tables in when using Oracle or
Impala.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>
 <dl>
<dt>originalSql</dt><dd><p>The original parameterized
SQL code</p>
</dd> <dt>sql</dt><dd><p>The translated SQL</p>
</dd> </dl>


<hr>
<h2 id='translateSqlFile'>Translate a SQL file</h2><span id='topic+translateSqlFile'></span>

<h3>Description</h3>

<p>This function takes SQL and translates it to a different dialect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translateSqlFile(
  sourceFile,
  targetFile,
  targetDialect,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  oracleTempSchema = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translateSqlFile_+3A_sourcefile">sourceFile</code></td>
<td>
<p>The source SQL file</p>
</td></tr>
<tr><td><code id="translateSqlFile_+3A_targetfile">targetFile</code></td>
<td>
<p>The target SQL file</p>
</td></tr>
<tr><td><code id="translateSqlFile_+3A_targetdialect">targetDialect</code></td>
<td>
<p>The target dialect. Currently &quot;oracle&quot;, &quot;postgresql&quot;, &quot;pdw&quot;, &quot;impala&quot;,
&quot;sqlite&quot;, &quot;netezza&quot;, &quot;bigquery&quot;, &quot;snowflake&quot;, &quot;synapse&quot;, &quot;spark&quot;, and &quot;redshift&quot; are supported.</p>
</td></tr>
<tr><td><code id="translateSqlFile_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="translateSqlFile_+3A_oracletempschema">oracleTempSchema</code></td>
<td>
<p>DEPRECATED: use <code>tempEmulationSchema</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes SQL and translates it to a different dialect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
translateSqlFile("myRenderedStatement.sql",
  "myTranslatedStatement.sql",
  targetDialect = "postgresql"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='writeSql'>Write SQL to a SQL (text) file</h2><span id='topic+writeSql'></span>

<h3>Description</h3>

<p><code>writeSql</code> writes SQL to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeSql(sql, targetFile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeSql_+3A_sql">sql</code></td>
<td>
<p>A string containing the sql</p>
</td></tr>
<tr><td><code id="writeSql_+3A_targetfile">targetFile</code></td>
<td>
<p>The target SQL file</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>writeSql</code> writes SQL to a file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sql &lt;- "SELECT * FROM @table_name"
writeSql(sql, "myParamStatement.sql")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
