<!DOCTYPE html><html lang="en"><head><title>Help for package fMRIscrub</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fMRIscrub}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#artifact_images'><p>Artifact images</p></a></li>
<li><a href='#Dat1'><p>First Example Time Series from the ABIDE</p></a></li>
<li><a href='#Dat2'><p>Second Example Time Series from the ABIDE</p></a></li>
<li><a href='#data_CompCor_Params'><p>fMRI data for <code>scrub</code> and <code>CompCor</code></p></a></li>
<li><a href='#DVARS'><p>DVARS</p></a></li>
<li><a href='#emprule_rob'><p>Robust empirical rule</p></a></li>
<li><a href='#FD'><p>Framewise Displacement</p></a></li>
<li><a href='#flags_to_nuis_spikes'><p>Flags to nuisance spikes</p></a></li>
<li><a href='#fMRIscrub'><p>fMRIscrub: fMRI scrubbing and other data cleaning routines</p></a></li>
<li><a href='#high_kurtosis'><p>Which components have high kurtosis?</p></a></li>
<li><a href='#leverage'><p>Leverage</p></a></li>
<li><a href='#noise_Params'><p>noise parameters for CompCor</p></a></li>
<li><a href='#plot_scrub_wrapper'><p>Plot scrubbing results</p></a></li>
<li><a href='#plot.scrub_DVARS'><p>Plot a <code>"scrub_DVARS"</code> object</p></a></li>
<li><a href='#plot.scrub_FD'><p>Plot a <code>"scrub_FD"</code> object</p></a></li>
<li><a href='#plot.scrub_projection'><p>Plot a <code>"scrub_projection"</code> object</p></a></li>
<li><a href='#plot.scrub_projection_multi'><p>Plot a <code>"scrub_projection_multi"</code> object</p></a></li>
<li><a href='#projection_name'><p>Get internal name of this projection</p></a></li>
<li><a href='#pscrub'><p>Projection scrubbing</p></a></li>
<li><a href='#pscrub_from_multi'><p>Convert <code>"pscrub_multi"</code> to <code>"pscrub"</code></p></a></li>
<li><a href='#pscrub_multi'><p>Compare projection scrubbing measures with <code>pscrub_multi</code></p></a></li>
<li><a href='#pscrub_Params'><p>pscrub</p></a></li>
<li><a href='#RD_impData'><p>Impute outliers for robust distance</p></a></li>
<li><a href='#RD_meas'><p>Robust distance calculation</p></a></li>
<li><a href='#RD_univOut'><p>Univariate outlier detection for robust distance</p></a></li>
<li><a href='#rob_stabilize'><p>Stabilize the center and scale of a timeseries robustly</p></a></li>
<li><a href='#rob_trend'><p>Robust linear model on DCT bases</p></a></li>
<li><a href='#robdist'><p>Robust distance scrubbing</p></a></li>
<li><a href='#scrub'><p>Data-driven scrubbing</p></a></li>
<li><a href='#scrub_plot'><p><code>"scrub"</code> plot sub-function</p></a></li>
<li><a href='#scrub_xifti'><p>Scrub fMRI data in CIFTI format</p></a></li>
<li><a href='#sd_hIQR'><p>Estimate SD robustly using the half IQR</p></a></li>
<li><a href='#SHASH_out'><p>Robust outlier detection based on SHASH distribution</p></a></li>
<li><a href='#SHASH_to_normal'><p>SHASH to normal data transformation</p></a></li>
<li><a href='#summary.scrub_DVARS'><p>Summarize a <code>"scrub_DVARS"</code> object</p></a></li>
<li><a href='#summary.scrub_FD'><p>Summarize a <code>"scrub_FD"</code> object</p></a></li>
<li><a href='#summary.scrub_projection'><p>Summarize a <code>"scrub_projection"</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scrubbing and Other Data Cleaning Routines for fMRI</td>
</tr>
<tr>
<td>Version:</td>
<td>0.14.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amanda Mejia &lt;mandy.mejia@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Data-driven fMRI denoising with projection scrubbing (Pham et al 
    (2022) &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2023.119972">doi:10.1016/j.neuroimage.2023.119972</a>&gt;). Also includes routines for 
    DVARS (Derivatives VARianceS) (Afyouni and Nichols (2018) 
    &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2017.12.098">doi:10.1016/j.neuroimage.2017.12.098</a>&gt;), motion scrubbing (Power et al 
    (2012) &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2011.10.018">doi:10.1016/j.neuroimage.2011.10.018</a>&gt;), aCompCor (anatomical 
    Components Correction) (Muschelli et al (2014)
    &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2014.03.028">doi:10.1016/j.neuroimage.2014.03.028</a>&gt;), detrending, and nuisance
    regression. Projection scrubbing is also applicable to other
    outlier detection tasks involving high-dimensional data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, cellWise, e1071, fMRItools (&ge; 0.2.2), pesel,
robustbase, stats, expm, utils, gamlss</td>
</tr>
<tr>
<td>Suggests:</td>
<td>corpcor, cowplot, ciftiTools, gifti, knitr, rmarkdown,
RNifti, ggplot2, fastICA, oro.nifti, testthat (&ge; 3.0.0), covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mandymejia/fMRIscrub">https://github.com/mandymejia/fMRIscrub</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mandymejia/fMRIscrub/issues">https://github.com/mandymejia/fMRIscrub/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-24 21:50:22 UTC; ddpham</td>
</tr>
<tr>
<td>Author:</td>
<td>Amanda Mejia [aut, cre],
  John Muschelli <a href="https://orcid.org/0000-0001-6469-1750"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Damon Pham <a href="https://orcid.org/0000-0001-7563-4727"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Daniel McDonald [ctb],
  Fatma Parlak [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-25 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='artifact_images'>Artifact images</h2><span id='topic+artifact_images'></span>

<h3>Description</h3>

<p>Visualize artifact patterns from the results of <code><a href="#topic+pscrub">pscrub</a></code>.
Requires <code>pscrub(..., get_dirs=TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artifact_images(psx, idx = NULL, use_dt = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="artifact_images_+3A_psx">psx</code></td>
<td>
<p>A <code>"scrub_projection"</code> object containing projection scrubbing
results.</p>
</td></tr>
<tr><td><code id="artifact_images_+3A_idx">idx</code></td>
<td>
<p>The timepoints or column indexes for which to compute artifact
images. If <code>NULL</code> (default), use the outlying timepoints.</p>
</td></tr>
<tr><td><code id="artifact_images_+3A_use_dt">use_dt</code></td>
<td>
<p>If detrended components are available (the &quot;U&quot; matrix of PCA
or &quot;M&quot; matrix of ICA), should they be used to compute the artifact images?
Otherwise, use the non-detrended components. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes two types: &quot;mean&quot; artifact images based on a weighted sum of the
projection directions, with weights determined by the scores for each
component at the flagged timepoint, and &quot;top&quot; artifact images based on the
projection direction with the greatest score at the flagged timepoint.
</p>


<h3>Value</h3>

<p>A list of three: <code>idx</code>, the timepoints for which the artifact images
were computed; <code>mean</code>, the &quot;mean&quot; artifact images; and <code>top</code>, the
&quot;top&quot; artifact images. The row names of the <code>top</code> artifact images
matrix give the index of the top component (&quot;V&quot; in PCA and &quot;S&quot; in ICA) at
each timepoint.
</p>

<hr>
<h2 id='Dat1'>First Example Time Series from the ABIDE</h2><span id='topic+Dat1'></span>

<h3>Description</h3>

<p>A sagittal slice from the fMRI time series for subject 0050048. The scan was
obtained at the University of Pittsburgh School of Medicine. The scan has
been pre-processed with slice time correction, rigid body realignment
estimation, spatial normalization to MNI space, and linear detrending.
Subject 0050048 was a typically-developing 11-year-old male. The scan has
many artifacts. A mask was applied to vectorize the spatial
dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dat1
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of 193 time points by 4675 voxels
</p>


<h3>Details</h3>

<p>Source: http://fcon_1000.projects.nitrc.org/indi/abide/abide_I.html
</p>


<h3>References</h3>


<ul>
<li><p>1.Di Martino, A. et al. The autism brain imaging data exchange: towards a large-scale evaluation of the intrinsic brain architecture in autism. Mol Psychiatry 19, 659–667 (2014).
</p>
</li></ul>


<hr>
<h2 id='Dat2'>Second Example Time Series from the ABIDE</h2><span id='topic+Dat2'></span>

<h3>Description</h3>

<p>A sagittal slice from the fMRI time series for subject 0051479. The scan was
obtained at the California Institute of Technology. The scan has
been pre-processed with slice time correction, rigid body realignment
estimation, spatial normalization to MNI space, and linear detrending.
Subject 0051479 was a typically-developing 20-year-old female. The scan has
few visible artifacts. A mask was applied to vectorize the spatial
dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dat2
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of 145 time points by 4679 voxels
</p>


<h3>Details</h3>

<p>Source: http://fcon_1000.projects.nitrc.org/indi/abide/abide_I.html
</p>


<h3>References</h3>


<ul>
<li><p>1.Di Martino, A. et al. The autism brain imaging data exchange: towards a large-scale evaluation of the intrinsic brain architecture in autism. Mol Psychiatry 19, 659–667 (2014).
</p>
</li></ul>


<hr>
<h2 id='data_CompCor_Params'>fMRI data for <code>scrub</code> and <code>CompCor</code></h2><span id='topic+data_CompCor_Params'></span>

<h3>Description</h3>

<p>fMRI data for <code>scrub</code> and <code>CompCor</code>
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_CompCor_Params_+3A_x">X</code></td>
<td>
<p>Wide numeric data matrix (<code class="reqn">T observations</code> by <code class="reqn">V variables</code>, <code class="reqn">T &lt;&lt; V</code>).
For example, if <code>X</code> represents an fMRI run, <code class="reqn">T</code> should be the number
of timepoints and <code class="reqn">V</code> should be the number of brainordinate vertices/voxels.
</p>
<p>Or, a 4D array or NIFTI or file path to a NIFTI (<code class="reqn">I</code> by <code class="reqn">J</code> by <code class="reqn">K</code> by <code class="reqn">T</code>
observations), in which case <code>ROI_data</code> must be provided.
(The vectorized data will be <code class="reqn">T timepoints</code> by <code class="reqn">V_{in-mask} voxels</code>)
</p>
<p>Or, a <code>ciftiTools</code> <code>"xifti"</code> object or a file path to a CIFTI
(The vectorized data will be <code class="reqn">T timepoints</code> by <code class="reqn">V_{left+right+sub} grayordinates</code>).</p>
</td></tr>
<tr><td><code id="data_CompCor_Params_+3A_roi_data">ROI_data</code></td>
<td>
<p>Indicates the data ROI. Allowed arguments depend on <code>X</code>:
</p>
<p>If <code>X</code> is a matrix, this must be a length <code class="reqn">V</code> logical vector, where
the data ROI is indicated by <code>TRUE</code> values. If <code>"infer"</code> (default), all
columns of <code>X</code> will be included in the data ROI (<code>rep(TRUE, V)</code>).
</p>
<p>If <code>X</code> is an array or NIFTI, this must be either a vector of values
to expect for out-of-mask voxels in <code>X</code>, or a (file path to a) 3D NIFTI.
In the latter case, each of the volume dimensions should match the first
three dimensions of <code>X</code>. Voxels in the data ROI should be indicated by
<code>TRUE</code> and all other voxels by <code>FALSE</code>. If <code>"infer"</code> (default),
will be set to <code>c(0, NA, NaN)</code> (include all voxels which are not constant
<code>0</code>, <code>NA</code>, or <code>NaN</code>).
</p>
<p>If <code>X</code> is a <code>"xifti"</code> this must be the <code>brainstructures</code>
argument to <code><a href="ciftiTools.html#topic+read_cifti">read_cifti</a></code>. If <code>"infer"</code> (default),
<code>brainstructures</code> will be set to <code>"all"</code> (use both left and right
cortex vertices, and subcortical voxels).
</p>
<p>If <code>NULL</code>, the data ROI will be empty. This is useful for obtaining just
the noise ROI, if the data and noise are located in separate files.</p>
</td></tr>
<tr><td><code id="data_CompCor_Params_+3A_roi_noise">ROI_noise</code></td>
<td>
<p>Indicates the noise ROIs for aCompCor. Should be a list where
each entry corresponds to a distinct noise ROI. The names of the list should
be the ROI names, e.g. <code>"white_matter"</code> and <code>"csf"</code>. The expected
formats of the list entries depends on <code>X</code>:
</p>
<p>For all types of <code>X</code>, <code>ROI_noise</code> entries can be a matrix of noise
ROI data. The matrix should have <code class="reqn">T</code> rows, with each column being a
data location's timeseries.
</p>
<p>If <code>X</code> is a matrix, entries can also indicate a noise ROI within <code>X</code>.
These entries must be a length <code class="reqn">V</code> logical vector with <code>TRUE</code> values
indicating locations in <code>X</code> within that noise ROI. Since the ROIs must
not overlap, the masks must be mutually exclusive with each other, and with
<code>ROI_data</code>.
</p>
<p>If <code>X</code> is an array or NIFTI, entries can also indicate a noise ROI within <code>X</code>.
These entries must be a logical array or (file path to) a 3D NIFTI with the
same spatial dimensions as <code>X</code>, and with <code>TRUE</code> values indicating
voxels inside the noise ROI. Since the ROIs must not overlap, the masks must
be mutually exclusive with each other, and with <code>ROI_data</code>.
</p>
<p>(If <code>X</code> is a <code>"xifti"</code>, entries must be data matrices, since no
grayordinate locations in <code>X</code> are appropriate noise ROIs).</p>
</td></tr>
</table>

<hr>
<h2 id='DVARS'>DVARS</h2><span id='topic+DVARS'></span>

<h3>Description</h3>

<p>Computes the DSE decomposition and DVARS-related statistics. Based on code
from github.com/asoroosh/DVARS .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DVARS(
  X,
  normalize = TRUE,
  cutoff_DPD = 5,
  cutoff_ZD = qnorm(1 - 0.05/nrow(as.matrix_ifti(X))),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DVARS_+3A_x">X</code></td>
<td>
<p>a <code class="reqn">T</code> by <code class="reqn">N</code> numeric matrix representing an fMRI run. There should
not be any missing data (<code>NA</code> or <code>NaN</code>).</p>
</td></tr>
<tr><td><code id="DVARS_+3A_normalize">normalize</code></td>
<td>
<p>Normalize the data? Default: <code>TRUE</code>. Normalization removes
constant-zero voxels, scales by 100 / the median of the mean image, and
then centers each voxel on its mean.
</p>
<p>To replicate Afyouni and Nichols' procedure for the HCP MPP data, since the
HCP scans are already normalized to 10,000, just divide the data by 100 and
center the voxels on their means:
</p>
<p><code>Y &lt;- Y/100; DVARS(t(Y - apply(Y, 1, mean)))</code> where <code>Y</code> is the
<code class="reqn">V</code> by <code class="reqn">T</code> data matrix.
</p>
<p>Note that while voxel centering doesn't affect DVARS, it does affect
DPD and ZD.</p>
</td></tr>
<tr><td><code id="DVARS_+3A_cutoff_dpd">cutoff_DPD</code>, <code id="DVARS_+3A_cutoff_zd">cutoff_ZD</code></td>
<td>
<p>Numeric outlier cutoffs. Timepoints
exceeding these cutoffs will be flagged as outliers.</p>
</td></tr>
<tr><td><code id="DVARS_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<dl>
<dt>measure</dt><dd><p>A data.frame with <code class="reqn">T</code> rows, each column being a different variant of DVARS.</p>
</dd>
<dt>measure_info</dt><dd><p>&quot;DVARS&quot;</p>
</dd>
<dt>outlier_cutoff</dt><dd><p>The outlier cutoff value(s).</p>
</dd>
<dt>outlier_flag</dt><dd><p>A logical data.frame with <code class="reqn">T</code> rows, where <code>TRUE</code> indicates suspected outlier presence.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p>Afyouni, S. &amp; Nichols, T. E. Insight and inference for DVARS. NeuroImage 172, 291-312 (2018).
</p>
</li></ul>


<hr>
<h2 id='emprule_rob'>Robust empirical rule</h2><span id='topic+emprule_rob'></span>

<h3>Description</h3>

<p>Robust empirical rule outlier detection applicable to approximately Normal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emprule_rob(x, thr = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emprule_rob_+3A_x">x</code></td>
<td>
<p>The data</p>
</td></tr>
<tr><td><code id="emprule_rob_+3A_thr">thr</code></td>
<td>
<p>MAD threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector indicating whether each element in <code>x</code> is an
outlier (<code>TRUE</code> if an outlier).
</p>

<hr>
<h2 id='FD'>Framewise Displacement</h2><span id='topic+FD'></span>

<h3>Description</h3>

<p>Calculate Framewise Displacement (FD)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FD(
  X,
  trans_units = c("mm", "cm", "in"),
  rot_units = c("deg", "rad", "mm", "cm", "in"),
  brain_radius = NULL,
  detrend = FALSE,
  lag = 1,
  cutoff = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FD_+3A_x">X</code></td>
<td>
<p>An <code class="reqn">N</code> by <code class="reqn">6</code> matrix in which the first three columns represent the
translational RPs (<code>trans_units</code>), and the second three columns represent
the rotational RPs (<code>rot_units</code>). If <code>rot_units</code> measures an angle,
it will be converted to <code>trans_units</code> by measuring displacement on a
sphere of radius <code>brain_radius</code> <code>trans_units</code>.
</p>
<p>Alternatively, this can be the file path to an <code class="reqn">N</code> by <code class="reqn">6</code> matrix which can be
read with <code><a href="utils.html#topic+read.table">read.table</a></code> (fields separated by white-space; no
header).</p>
</td></tr>
<tr><td><code id="FD_+3A_trans_units">trans_units</code></td>
<td>
<p><code>"mm"</code> for millimeters (default), <code>"cm"</code>
for centimeters, or <code>"in"</code> for inches.</p>
</td></tr>
<tr><td><code id="FD_+3A_rot_units">rot_units</code></td>
<td>
<p><code>"deg"</code> for degrees (default), <code>"rad"</code> for radians,
or one of the <code>trans_units</code> options.</p>
</td></tr>
<tr><td><code id="FD_+3A_brain_radius">brain_radius</code></td>
<td>
<p>If <code>rot_units</code> measures an angle, the rotational RPs
are transformed to a spatial measurement representing the displacement on a
sphere of radius <code>brain_radius</code> <code>trans_units</code>.
</p>
<p>If <code>brain_radius</code> is <code>NULL</code> (default), it will be set to
50 mm.</p>
</td></tr>
<tr><td><code id="FD_+3A_detrend">detrend</code></td>
<td>
<p>Detrend each RP with the DCT before computing FD?
Default: <code>FALSE</code>. Can be a number of DCT bases to use, or <code>TRUE</code>
to use 4.</p>
</td></tr>
<tr><td><code id="FD_+3A_lag">lag</code></td>
<td>
<p>The difference of indices between which to calculate change in
position. Default: <code>1</code> (the previous timepoint). Changing this
argument sets <code class="reqn">\Delta x_i = x_{i-lag} - x_i</code> (and similarly for the
other RPs).</p>
</td></tr>
<tr><td><code id="FD_+3A_cutoff">cutoff</code></td>
<td>
<p>FD values higher than this will be flagged. Default: <code>.3</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FD formula is taken from Power et. al. (2012):
</p>
<p style="text-align: center;"><code class="reqn">FD_i = | \Delta x_i | + | \Delta y_i | + | \Delta z_i | + | \Delta \alpha_i | + | \Delta \beta_i | + | \Delta \gamma_i |</code>
</p>

<p>where <code class="reqn">i</code> is the timepoint; <code class="reqn">x</code>, <code class="reqn">y</code> and <code class="reqn">z</code> are the
translational realignment parameters (RPs);
<code class="reqn">\alpha</code>, <code class="reqn">\beta</code> and <code class="reqn">\gamma</code> are the rotational RPs;
and <code class="reqn">\Delta x_i = x_{i-1} - x_i</code> (and similarly for the other RPs).
</p>


<h3>Value</h3>

<p>A list with components
</p>

<dl>
<dt>measure</dt><dd><p>A length <code class="reqn">N</code> vector of FD values in <code>trans_units</code>.</p>
</dd>
<dt>measure_info</dt><dd><p>&quot;FD&quot;</p>
</dd>
<dt>outlier_cutoff</dt><dd><p><code>cutoff</code></p>
</dd>
<dt>outlier_flag</dt><dd><p>A length-N logical vector, where <code>TRUE</code> indicates suspected outlier presence.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p>Power, J. D., Barnes, K. A., Snyder, A. Z., Schlaggar, B. L. &amp; Petersen, S. E. Spurious but systematic correlations in functional connectivity MRI networks arise from subject motion. Neuroimage 59, 2142-2154 (2012).
</p>
</li></ul>


<hr>
<h2 id='flags_to_nuis_spikes'>Flags to nuisance spikes</h2><span id='topic+flags_to_nuis_spikes'></span>

<h3>Description</h3>

<p>Convert flagged volumes to corresponding one-hot encoded vectors
which can be used for nuisance regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flags_to_nuis_spikes(flags, n_time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flags_to_nuis_spikes_+3A_flags">flags</code></td>
<td>
<p>Numeric vector of integers indicating the indices of
the flagged volumes. Or, a logical vector of length <code>n_time</code> where
<code>TRUE</code> values indicate the flagged volumes.</p>
</td></tr>
<tr><td><code id="flags_to_nuis_spikes_+3A_n_time">n_time</code></td>
<td>
<p>The length of the vectors to obtain. For nuisance regression,
this is the length of the BOLD data. The highest index in <code>flags</code>
should not exceed <code>n_time</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of ones and zeroes. The number of rows will be
<code>n_time</code> and the number of columns will be the number of flags. Each
column will have a <code>1</code> at the flag index, and <code>0</code> elsewhere.
</p>

<hr>
<h2 id='fMRIscrub'>fMRIscrub: fMRI scrubbing and other data cleaning routines</h2><span id='topic+fMRIscrub'></span>

<h3>Description</h3>

<p>See <code>help(package="fMRIscrub")</code> for a list of functions.
</p>

<hr>
<h2 id='high_kurtosis'>Which components have high kurtosis?</h2><span id='topic+high_kurtosis'></span>

<h3>Description</h3>

<p>The kurtosis cutoff is a high quantile (default 0.99) of the sampling distribution
of kurtosis for Normal iid data of the same length as the components; it is
estimated by simulation or calculated from the theoretical asymptotic
distribution if the components are long enough.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>high_kurtosis(Comps, kurt_quantile = 0.99, n_sim = 5000, min_1 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="high_kurtosis_+3A_comps">Comps</code></td>
<td>
<p>A matrix; each column is a component. For PCA, this is the U
matrix. For ICA, this is the M matrix.</p>
</td></tr>
<tr><td><code id="high_kurtosis_+3A_kurt_quantile">kurt_quantile</code></td>
<td>
<p>components with kurtosis of at least this quantile are kept.</p>
</td></tr>
<tr><td><code id="high_kurtosis_+3A_n_sim">n_sim</code></td>
<td>
<p>The number of simulation data to use for estimating the sampling
distribution of kurtosis. Only used if a new simulation is performed. (If
<code class="reqn">n&lt;1000</code> and the quantile is 90%, a pre-computed value is used instead.
If <code class="reqn">n&gt;1000</code>, the theoretical asymptotic distribution is used instead.)</p>
</td></tr>
<tr><td><code id="high_kurtosis_+3A_min_1">min_1</code></td>
<td>
<p>Require at least one component to be selected? In other words, if
no components meet the quantile cutoff, should the component with the highest
kurtosis be returned? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components should not have any strong low-frequency trends, because trends
can affect kurtosis in unpredictable ways unrelated to outlier presence.
</p>


<h3>Value</h3>

<p>A logical vector indicating whether each component has high kurtosis.
</p>

<hr>
<h2 id='leverage'>Leverage</h2><span id='topic+leverage'></span>

<h3>Description</h3>

<p>Computes the leverage of each observation in the PC score (U) or
IC mixing (M) matrix for projection scrubbing. Can threshold to
flag potential outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leverage(Comps, are_norm = FALSE, median_cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leverage_+3A_comps">Comps</code></td>
<td>
<p>The <code class="reqn">n</code> by <code class="reqn">Q</code> PC score matrix/IC mixing matrix.</p>
</td></tr>
<tr><td><code id="leverage_+3A_are_norm">are_norm</code></td>
<td>
<p>Assume the columns of <code>Comps</code> are orthogonal
and have 2-norms equal to 1? Speeds up the computation.</p>
</td></tr>
<tr><td><code id="leverage_+3A_median_cutoff">median_cutoff</code></td>
<td>
<p>The outlier cutoff, in multiples of the median leverage.
Default: <code>NULL</code> (do not compute outliers).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries <code>"meas"</code> (the leverage values),
<code>"cut"</code> (the leverage cutoff value) and
<code>"flag"</code> (logical vector indicating the outliers). If
<code>!is.null(median_cutoff)</code>, <code>"cut"</code> and <code>"flag"</code> are omitted.
</p>

<hr>
<h2 id='noise_Params'>noise parameters for CompCor</h2><span id='topic+noise_Params'></span>

<h3>Description</h3>

<p>noise parameters for CompCor
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise_Params_+3A_noise_npc">noise_nPC</code></td>
<td>
<p>The number of principal components to compute for each noise
ROI. Alternatively, values between 0 and 1, in which case they will
represent the minimum proportion of variance explained by the PCs used for
each noise ROI. The smallest number of PCs will be used to achieve this
proportion of variance explained.
</p>
<p>Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>5</code> (compute the top 5 PCs for
each noise ROI).</p>
</td></tr>
<tr><td><code id="noise_Params_+3A_noise_erosion">noise_erosion</code></td>
<td>
<p>The number of voxel layers to erode the noise ROIs by.
Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>NULL</code>, which will use a value of
0 (do not erode the noise ROIs). Note that noise erosion can only be
performed if the noise ROIs are volumetric.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_scrub_wrapper'>Plot scrubbing results</h2><span id='topic+plot_scrub_wrapper'></span>

<h3>Description</h3>

<p>Plot a leverage, DVARS, or FD timeseries from a <code>"scrub_projection"</code>,
<code>"scrub_DVARS"</code>, or <code>"scrub_FD"</code> object, respectively. Highlight
volumes flagged for outlier presence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scrub_wrapper(x, title = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_scrub_wrapper_+3A_x">x</code></td>
<td>
<p>The <code>"scrub_*"</code> object.</p>
</td></tr>
<tr><td><code id="plot_scrub_wrapper_+3A_title">title</code></td>
<td>
<p>(Optional) If provided, will add a title to the plot.</p>
</td></tr>
<tr><td><code id="plot_scrub_wrapper_+3A_...">...</code></td>
<td>
<p>Additional arguments to ggplot, e.g. <code>main</code>, <code>sub</code>,
<code>xlab</code>, <code>ylab</code>, <code>legend.position</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>

<hr>
<h2 id='plot.scrub_DVARS'>Plot a <code>"scrub_DVARS"</code> object</h2><span id='topic+plot.scrub_DVARS'></span>

<h3>Description</h3>

<p>Plot a <code>"scrub_DVARS"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scrub_DVARS'
plot(x, title = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scrub_DVARS_+3A_x">x</code></td>
<td>
<p>The <code>"scrub_DVARS"</code> object</p>
</td></tr>
<tr><td><code id="plot.scrub_DVARS_+3A_title">title</code></td>
<td>
<p>(Optional) If provided, will add a title to the plot.</p>
</td></tr>
<tr><td><code id="plot.scrub_DVARS_+3A_...">...</code></td>
<td>
<p>Additional arguments to ggplot, e.g. <code>main</code>, <code>sub</code>,
<code>xlab</code>, <code>ylab</code>, <code>legend.position</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>

<hr>
<h2 id='plot.scrub_FD'>Plot a <code>"scrub_FD"</code> object</h2><span id='topic+plot.scrub_FD'></span>

<h3>Description</h3>

<p>Plot a <code>"scrub_FD"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scrub_FD'
plot(x, title = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scrub_FD_+3A_x">x</code></td>
<td>
<p>The <code>"scrub_FD"</code> object</p>
</td></tr>
<tr><td><code id="plot.scrub_FD_+3A_title">title</code></td>
<td>
<p>(Optional) If provided, will add a title to the plot.</p>
</td></tr>
<tr><td><code id="plot.scrub_FD_+3A_...">...</code></td>
<td>
<p>Additional arguments to ggplot, e.g. <code>main</code>, <code>sub</code>,
<code>xlab</code>, <code>ylab</code>, <code>legend.position</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>

<hr>
<h2 id='plot.scrub_projection'>Plot a <code>"scrub_projection"</code> object</h2><span id='topic+plot.scrub_projection'></span>

<h3>Description</h3>

<p>Plot a <code>"scrub_projection"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scrub_projection'
plot(x, title = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scrub_projection_+3A_x">x</code></td>
<td>
<p>The <code>"scrub_projection"</code> object</p>
</td></tr>
<tr><td><code id="plot.scrub_projection_+3A_title">title</code></td>
<td>
<p>(Optional) If provided, will add a title to the plot.</p>
</td></tr>
<tr><td><code id="plot.scrub_projection_+3A_...">...</code></td>
<td>
<p>Additional arguments to ggplot, e.g. <code>main</code>, <code>sub</code>,
<code>xlab</code>, <code>ylab</code>, <code>legend.position</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>

<hr>
<h2 id='plot.scrub_projection_multi'>Plot a <code>"scrub_projection_multi"</code> object</h2><span id='topic+plot.scrub_projection_multi'></span>

<h3>Description</h3>

<p>Plot a <code>"scrub_projection_multi"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scrub_projection_multi'
plot(x, title = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scrub_projection_multi_+3A_x">x</code></td>
<td>
<p>The <code>"scrub_projection_multi"</code> object.</p>
</td></tr>
<tr><td><code id="plot.scrub_projection_multi_+3A_title">title</code></td>
<td>
<p>(Optional) If provided, will add a title to the plot.</p>
</td></tr>
<tr><td><code id="plot.scrub_projection_multi_+3A_...">...</code></td>
<td>
<p>Additional arguments to ggplot, e.g. <code>main</code>, <code>sub</code>,
<code>xlab</code>, <code>ylab</code>, <code>legend.position</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>

<hr>
<h2 id='projection_name'>Get internal name of this projection</h2><span id='topic+projection_name'></span>

<h3>Description</h3>

<p>Get name of projection given PESEL &amp; kurtosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection_name(projection, PESEL, kurt_quantile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projection_name_+3A_projection">projection</code>, <code id="projection_name_+3A_pesel">PESEL</code>, <code id="projection_name_+3A_kurt_quantile">kurt_quantile</code></td>
<td>
<p>See <code><a href="#topic+pscrub">pscrub</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the projection
</p>

<hr>
<h2 id='pscrub'>Projection scrubbing</h2><span id='topic+pscrub'></span>

<h3>Description</h3>

<p>Projection scrubbing is a data-driven method for identifying artifact-contaminated
volumes in fMRI. It works by identifying component
directions in the data likely to represent patterns of burst noise, and then computing a
composite measure of outlyingness based on leverage within these directions,
at each volume. The projection can be PCA, ICA, or &quot;fused PCA.&quot;
Projection scrubbing can also be used for other outlier detection tasks involving
high-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pscrub(
  X,
  projection = c("ICA", "PCA"),
  nuisance = "DCT4",
  center = TRUE,
  scale = TRUE,
  comps_mean_dt = FALSE,
  comps_var_dt = FALSE,
  PESEL = TRUE,
  kurt_quantile = 0.99,
  get_dirs = FALSE,
  full_PCA = FALSE,
  get_outliers = TRUE,
  cutoff = 4,
  seed = 0,
  ICA_method = c("C", "R"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pscrub_+3A_x">X</code></td>
<td>
<p>Wide numeric data matrix (<code class="reqn">T</code> observations by <code class="reqn">V</code> variables,
<code class="reqn">T &lt;&lt; V</code>). If <code>X</code> represents an fMRI run, <code class="reqn">T</code> should be the
number of timepoints and <code class="reqn">V</code> should be the number of vertices/voxels.
Projection scrubbing will measure the outlyingness of each row in <code>X</code>.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_projection">projection</code></td>
<td>
<p>One of the following: <code>"ICA"</code> (default) or <code>"PCA"</code>.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_nuisance">nuisance</code></td>
<td>
<p>Nuisance signals to regress from each column of <code>X</code>.
Should be specified as a design matrix: a <code class="reqn">T</code> by <code class="reqn">N</code> numeric matrix
where <code class="reqn">N</code> represents the number of nuisance signals. Or can be &quot;DCT4&quot;
(default), which will create a matrix with a constant column (the intercept
term) and four DCT bases. This default nuisance regression will have the
effect of demeaning and detrending the data by removing low-frequency
components. To not perform any nuisance regression set this argument to
<code>NULL</code>, <code>0</code>, or <code>FALSE</code>.
</p>
<p>Detrending is highly recommended for time-series data, especially if there
are many time points or evolving circumstances affecting the data. Additionally,
if kurtosis is being used to select the projection directions, trends can
induce positive or negative kurtosis, contaminating the connection between
high kurtosis and outlier presence. Detrending should not be used with
non-time-series data because the observations are not temporally related.
</p>
<p>Additional nuisance regressors can be specified like so:
<code>cbind(1, fMRItools::dct_bases(nrow(x), 4), more_nuisance)</code>.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_center">center</code>, <code id="pscrub_+3A_scale">scale</code></td>
<td>
<p>Center the columns of the data by their medians, and scale the
columns of the data by their median absolute deviations (MADs)? Default: <code>TRUE</code>.
Centering is necessary for computing the projections, so if <code>center</code> is
<code>FALSE</code>, the data must already be centered.
</p>
<p>Note that centering and scaling occur after nuisance regression, so even if
<code>center</code> is <code>FALSE</code>, the data will be centered on the means if
the nuisance regression included an intercept term, as it does by default.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_comps_mean_dt">comps_mean_dt</code>, <code id="pscrub_+3A_comps_var_dt">comps_var_dt</code></td>
<td>
<p>Stabilize the mean and variance of each
projection component's timecourse prior to computing kurtosis and leverage?
These arguments should be <code>TRUE</code>, <code>FALSE</code> (default), or the number
of DCT bases to use for detrending (<code>TRUE</code> will use 4).
Note that these arguments affect the projection components and not the data
itself. Also, if variance-stabilizing but not mean-stabilizing,
the components must already be expected to be mean-stabilized, for example
if the data was rigorously detrended; otherwise, the results will be invalid.
</p>
<p>Slow-moving mean and variance patterns in the components will interfere with
the roles of kurtosis and leverage in identifying outliers. While
<code>nuisance</code> can be used to detrend the data, this nuisance regression is
estimated <em>non-robustly</em>, since a robust model takes too long to estimate
at each data location. On the other hand, <code>comps_mean_dt</code> and
<code>comps_var_dt</code> can be used to apply a <em>robust</em> nuisance regression at each
component, since there are much fewer components than original data locations.
Thus, even if the data has been detrended with <code>nuisance</code> it may be
helpful to detrend the components with <code>comps_mean_dt</code>; furthermore,
the data nuisance regression does not address the potential existence of variance
patterns in the components.
</p>
<p>Overall, for fMRI we recommend enabling <code>comps_mean_dt</code> and <code>comps_var_dt</code>
unless the data has been cleaned not only with a low-pass filter like
DCT nuisance regression, but also with anatomical CompCor, ICA-FIX, or
a similar data-driven strategy that takes into account common sources of
artifactual mean and variance trends such as motion and physiological cycles.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_pesel">PESEL</code></td>
<td>
<p>Use <code><a href="pesel.html#topic+pesel">pesel</a></code> to select the number of
components? Default: <code>TRUE</code>. Otherwise, use the number of principal
components with above-average variance.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_kurt_quantile">kurt_quantile</code></td>
<td>
<p>What quantile cutoff should be used to select the
components? Default: <code>0.99</code>. Use <code>0</code> to select all high-variance
components regardless of kurtosis value.
</p>
<p>We model each component as a length <code class="reqn">T</code> vector of Normal iid random variables,
for which the distribution of kurtosis values can be approximated. The
quantile is estimated based on this distribution.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_get_dirs">get_dirs</code></td>
<td>
<p>Should the projection directions be returned? This is the
<code class="reqn">V</code> matrix in PCA and <code class="reqn">S</code> matrix in ICA. The default is <code>FALSE</code>
to save memory. However, <code>get_dirs==TRUE</code> is required for <code><a href="#topic+artifact_images">artifact_images</a></code>.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_full_pca">full_PCA</code></td>
<td>
<p>Only applies to the PCA projection. Return the full SVD?
Default: <code>FALSE</code> (return only the high-variance components).</p>
</td></tr>
<tr><td><code id="pscrub_+3A_get_outliers">get_outliers</code></td>
<td>
<p>Should outliers be flagged based on <code>cutoff</code>? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_cutoff">cutoff</code></td>
<td>
<p>Median leverage cutoff value. Default: <code>4</code>.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_seed">seed</code></td>
<td>
<p>Set a seed right before the call to <code>pesel::pesel</code> or
<code>ica::icaimax</code>? If <code>NULL</code>, do not set a seed. If numeric (default:
<code>0</code>), will use as the seed.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_ica_method">ICA_method</code></td>
<td>
<p>The <code>method</code> argument to <code>fastICA</code>: <code>"C"</code> to
use C code with BLAS (default), or <code>"R"</code> to use R code.</p>
</td></tr>
<tr><td><code id="pscrub_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to the projection scrubbing vignette for a demonstration and an
outline of the algorithm: <code>vignette("projection_scrubbing", package="fMRIscrub")</code>
</p>


<h3>Value</h3>

<p>A <code>"pscrub"</code> object, i.e. a list with components
</p>

<dl>
<dt>measure</dt><dd><p>A numeric vector of leverage values.</p>
</dd>
<dt>outlier_cutoff</dt><dd><p>The numeric outlier cutoff value (<code>cutoff</code> times the median leverage).</p>
</dd>
<dt>outlier_flag</dt><dd><p>A logical vector where <code>TRUE</code> indicates where leverage exceeds the cutoff, signaling suspected outlier presence.</p>
</dd>
<dt>mask</dt><dd>
<p>A length <code class="reqn">P</code> numeric vector corresponding to the data locations in <code>X</code>. Each value indicates whether the location was masked:
</p>

<dl>
<dt>0</dt><dd><p>The data location was not masked out.</p>
</dd>
<dt>-1</dt><dd><p>The data location was masked out, because it had at least one <code>NA</code> or <code>NaN</code> value.</p>
</dd>
<dt>-2</dt><dd><p>The data location was masked out, because it was constant.</p>
</dd>
</dl>

</dd>
<dt>PCA</dt><dd>
<p>This will be a list with components:
</p>

<dl>
<dt>U</dt><dd><p>The <code class="reqn">T</code> by <code class="reqn">Q</code> PC score matrix.</p>
</dd>
<dt>D</dt><dd><p>The standard deviation of each PC.</p>
</dd>
<dt>V</dt><dd><p>The <code class="reqn">P</code> by <code class="reqn">Q</code> PC directions matrix. Included only if <code>get_dirs</code>.</p>
</dd>
<dt>highkurt</dt><dd><p>The length <code>Q</code> logical vector indicating scores of high kurtosis.</p>
</dd>
<dt>U_dt</dt><dd><p>Detrended components of <code>U</code>. Included only if components were mean- or variance-detrended.</p>
</dd>
<dt>highkurt</dt><dd><p>The length <code>Q</code> logical vector indicating detrended scores of high kurtosis.</p>
</dd>
<dt>nPCs_PESEL</dt><dd><p>The number of PCs selected by PESEL.</p>
</dd>
<dt>nPCs_avgvar</dt><dd><p>The number of above-average variance PCs.</p>
</dd>
</dl>

<p>where <code>Q</code> is the number of PCs selected by PESEL or of above-average variance (or the greater of the two if both were used).
If PCA was not used, all entries except <code>nPCs_PESEL</code> and/or <code>nPCs_avgvar</code> will not be included, depending on which
method(s) was used to select the number of PCs.
</p>
</dd>
<dt>ICA</dt><dd>
<p>If ICA was used, this will be a list with components:
</p>

<dl>
<dt>S</dt><dd><p>The <code class="reqn">P</code> by <code class="reqn">Q</code> source signals matrix. Included only if <code>get_dirs</code></p>
</dd>
<dt>M</dt><dd><p>The <code class="reqn">T</code> by <code class="reqn">Q</code> mixing matrix.</p>
</dd>
<dt>highkurt</dt><dd><p>The length <code>Q</code> logical vector indicating mixing scores of high kurtosis.</p>
</dd>
<dt>M_dt</dt><dd><p>Detrended components of <code>M</code>. Included only if components were mean- or variance-detrended.</p>
</dd>
<dt>highkurt</dt><dd><p>The length <code>Q</code> logical vector indicating detrended mixing scores of high kurtosis. Included only if components were mean- or variance-detrended.</p>
</dd>
</dl>

</dd>
</dl>



<h3>References</h3>


<ul>
<li><p>Mejia, A. F., Nebel, M. B., Eloyan, A., Caffo, B. &amp; Lindquist, M. A. PCA leverage: outlier detection for high-dimensional functional magnetic resonance imaging data. Biostatistics 18, 521-536 (2017).
</p>
</li>
<li><p>Pham, D., McDonald, D., Ding, L., Nebel, M. B. &amp; Mejia, A. Less is more: balancing noise reduction and data retention in fMRI with projection scrubbing. (2022).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(fastICA)
psx = pscrub(Dat1[seq(70),seq(800,950)], ICA_method="R")
</code></pre>

<hr>
<h2 id='pscrub_from_multi'>Convert <code>"pscrub_multi"</code> to <code>"pscrub"</code></h2><span id='topic+pscrub_from_multi'></span>

<h3>Description</h3>

<p>Convert <code>"pscrub_multi"</code> to <code>"pscrub"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pscrub_from_multi(psx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pscrub_from_multi_+3A_psx">psx</code></td>
<td>
<p>The <code>"pscrub_multi"</code> object to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting <code>"pscrub"</code> object
</p>

<hr>
<h2 id='pscrub_multi'>Compare projection scrubbing measures with <code>pscrub_multi</code></h2><span id='topic+pscrub_multi'></span>

<h3>Description</h3>

<p>Calculates leverage to identify outliers in high-dimensional data.
Can get results using multiple kinds of projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pscrub_multi(
  X,
  projection = "ICA_kurt",
  nuisance = "DCT4",
  center = TRUE,
  scale = TRUE,
  comps_mean_dt = FALSE,
  comps_var_dt = FALSE,
  kurt_quantile = 0.99,
  get_dirs = FALSE,
  full_PCA = FALSE,
  get_outliers = TRUE,
  cutoff = 4,
  seed = 0,
  ICA_method = c("C", "R"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pscrub_multi_+3A_x">X</code></td>
<td>
<p>Wide numeric data matrix (<code class="reqn">T</code> observations by <code class="reqn">V</code> variables,
<code class="reqn">T &lt;&lt; V</code>). If <code>X</code> represents an fMRI run, <code class="reqn">T</code> should be the
number of timepoints and <code class="reqn">V</code> should be the number of vertices/voxels.
Projection scrubbing will measure the outlyingness of each row in <code>X</code>.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_projection">projection</code></td>
<td>
<p>Projection scrubbing projects the data onto directions
likely to contain outlier information. Choose at least one of the following:
</p>

<dl>
<dt><code>"PCA"</code></dt><dd><p>PCA using the top <code class="reqn">k</code> PCs.</p>
</dd>
<dt><code>"PCA_kurt"</code></dt><dd><p>PCA using the high-kurtosis PCs among the top <code class="reqn">k</code>.</p>
</dd>
<dt><code>"PCA2"</code></dt><dd><p>PCA using the top <code class="reqn">k2</code> PCs.</p>
</dd>
<dt><code>"PCA2_kurt"</code></dt><dd><p>PCA using the high-kurtosis PCs among the top <code class="reqn">k2</code>.</p>
</dd>
<dt><code>"ICA"</code></dt><dd><p>ICA using the top <code class="reqn">k</code> ICs.</p>
</dd>
<dt><code>"ICA_kurt"</code></dt><dd><p>ICA using the high-kurtosis ICs among the top <code class="reqn">k</code>.</p>
</dd>
<dt><code>"ICA2"</code></dt><dd><p>ICA using the top <code class="reqn">k2</code> ICs.</p>
</dd>
<dt><code>"ICA2_kurt"</code></dt><dd><p>ICA using the high-kurtosis ICs among the top <code class="reqn">k2</code>.</p>
</dd>
</dl>

<p>where <code class="reqn">k</code> is the number of components determined by PESEL, and <code class="reqn">k2</code>
is the number of principal components with above-average variance.
</p>
<p>Use <code>"all"</code> to use all projection methods. Default: <code>"ICA_kurt"</code>.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_nuisance">nuisance</code></td>
<td>
<p>Nuisance signals to regress from each column of <code>X</code>.
Should be specified as a design matrix: a <code class="reqn">T</code> by <code class="reqn">N</code> numeric matrix
where <code class="reqn">N</code> represents the number of nuisance signals. Or can be &quot;DCT4&quot;
(default), which will create a matrix with a constant column (the intercept
term) and four DCT bases. This default nuisance regression will have the
effect of demeaning and detrending the data by removing low-frequency
components. To not perform any nuisance regression set this argument to
<code>NULL</code>, <code>0</code>, or <code>FALSE</code>.
</p>
<p>Detrending is highly recommended for time-series data, especially if there
are many time points or evolving circumstances affecting the data. Additionally,
if kurtosis is being used to select the projection directions, trends can
induce positive or negative kurtosis, contaminating the connection between
high kurtosis and outlier presence. Detrending should not be used with
non-time-series data because the observations are not temporally related.
</p>
<p>Additional nuisance regressors can be specified like so:
<code>cbind(1, fMRItools::dct_bases(nrow(x), 4), more_nuisance)</code>.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_center">center</code>, <code id="pscrub_multi_+3A_scale">scale</code></td>
<td>
<p>Center the columns of the data by their medians, and scale the
columns of the data by their median absolute deviations (MADs)? Default: <code>TRUE</code>.
Centering is necessary for computing the projections, so if <code>center</code> is
<code>FALSE</code>, the data must already be centered.
</p>
<p>Note that centering and scaling occur after nuisance regression, so even if
<code>center</code> is <code>FALSE</code>, the data will be centered on the means if
the nuisance regression included an intercept term, as it does by default.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_comps_mean_dt">comps_mean_dt</code>, <code id="pscrub_multi_+3A_comps_var_dt">comps_var_dt</code></td>
<td>
<p>Stabilize the mean and variance of each
projection component's timecourse prior to computing kurtosis and leverage?
These arguments should be <code>TRUE</code>, <code>FALSE</code> (default), or the number
of DCT bases to use for detrending (<code>TRUE</code> will use 4).
Note that these arguments affect the projection components and not the data
itself. Also, if variance-stabilizing but not mean-stabilizing,
the components must already be expected to be mean-stabilized, for example
if the data was rigorously detrended; otherwise, the results will be invalid.
</p>
<p>Slow-moving mean and variance patterns in the components will interfere with
the roles of kurtosis and leverage in identifying outliers. While
<code>nuisance</code> can be used to detrend the data, this nuisance regression is
estimated <em>non-robustly</em>, since a robust model takes too long to estimate
at each data location. On the other hand, <code>comps_mean_dt</code> and
<code>comps_var_dt</code> can be used to apply a <em>robust</em> nuisance regression at each
component, since there are much fewer components than original data locations.
Thus, even if the data has been detrended with <code>nuisance</code> it may be
helpful to detrend the components with <code>comps_mean_dt</code>; furthermore,
the data nuisance regression does not address the potential existence of variance
patterns in the components.
</p>
<p>Overall, for fMRI we recommend enabling <code>comps_mean_dt</code> and <code>comps_var_dt</code>
unless the data has been cleaned not only with a low-pass filter like
DCT nuisance regression, but also with anatomical CompCor, ICA-FIX, or
a similar data-driven strategy that takes into account common sources of
artifactual mean and variance trends such as motion and physiological cycles.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_kurt_quantile">kurt_quantile</code></td>
<td>
<p>What quantile cutoff should be used to select the
components? Default: <code>0.99</code>. Use <code>0</code> to select all high-variance
components regardless of kurtosis value.
</p>
<p>We model each component as a length <code class="reqn">T</code> vector of Normal iid random variables,
for which the distribution of kurtosis values can be approximated. The
quantile is estimated based on this distribution.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_get_dirs">get_dirs</code></td>
<td>
<p>Should the projection directions be returned? This is the
<code class="reqn">V</code> matrix in PCA and <code class="reqn">S</code> matrix in ICA. The default is <code>FALSE</code>
to save memory. However, <code>get_dirs==TRUE</code> is required for <code><a href="#topic+artifact_images">artifact_images</a></code>.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_full_pca">full_PCA</code></td>
<td>
<p>Only applies to the PCA projection. Return the full SVD?
Default: <code>FALSE</code> (return only the high-variance components).</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_get_outliers">get_outliers</code></td>
<td>
<p>Should outliers be flagged based on <code>cutoff</code>? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_cutoff">cutoff</code></td>
<td>
<p>Median leverage cutoff value. Default: <code>4</code>.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_seed">seed</code></td>
<td>
<p>Set a seed right before the call to <code>pesel::pesel</code> or
<code>ica::icaimax</code>? If <code>NULL</code>, do not set a seed. If numeric (default:
<code>0</code>), will use as the seed.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_ica_method">ICA_method</code></td>
<td>
<p>The <code>method</code> argument to <code>fastICA</code>: <code>"C"</code> to
use C code with BLAS (default), or <code>"R"</code> to use R code.</p>
</td></tr>
<tr><td><code id="pscrub_multi_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"pscrub_multi"</code> object, i.e. a list with components
</p>

<dl>
<dt>measure</dt><dd><p>A <code class="reqn">T</code> by <code class="reqn">P</code> data.frame of numeric leverage values, each column being the leverage values for a projection method in <code>projection</code>.</p>
</dd>
<dt>measure_info</dt><dd><p>A data.frame with <code class="reqn">P</code> rows listing information about each projection used.</p>
</dd>
<dt>outlier_cutoff</dt><dd><p>A <code class="reqn">1</code> by <code class="reqn">P</code> data.frame of numeric outlier cutoff values for each projection (<code>cutoff</code> times the median leverage).</p>
</dd>
<dt>outlier_flag</dt><dd><p>A <code class="reqn">T</code> by <code class="reqn">P</code> data.frame of logical values where <code>TRUE</code> indicates where leverage exceeds the cutoff, signaling suspected outlier presence.</p>
</dd>
<dt>mask</dt><dd>
<p>A length <code class="reqn">P</code> numeric vector corresponding to the data locations in <code>X</code>. Each value indicates whether the location was masked:
</p>

<dl>
<dt>1</dt><dd><p>The data location was not masked out.</p>
</dd>
<dt>-1</dt><dd><p>The data location was masked out, because it had at least one <code>NA</code> or <code>NaN</code> value.</p>
</dd>
<dt>-2</dt><dd><p>The data location was masked out, because it was constant.</p>
</dd>
</dl>

</dd>
<dt>PCA</dt><dd>
<p>This will be a list with components:
</p>

<dl>
<dt>U</dt><dd><p>The <code class="reqn">T</code> by <code class="reqn">Q</code> PC score matrix.</p>
</dd>
<dt>D</dt><dd><p>The standard deviation of each PC.</p>
</dd>
<dt>V</dt><dd><p>The <code class="reqn">P</code> by <code class="reqn">Q</code> PC directions matrix. Included only if <code>get_dirs</code>.</p>
</dd>
<dt>highkurt</dt><dd><p>The length <code>Q</code> logical vector indicating scores of high kurtosis.</p>
</dd>
<dt>U_dt</dt><dd><p>Detrended components of <code>U</code>. Included only if components were mean- or variance-detrended.</p>
</dd>
<dt>highkurt</dt><dd><p>The length <code>Q</code> logical vector indicating detrended scores of high kurtosis.</p>
</dd>
<dt>nPCs_PESEL</dt><dd><p>The number of PCs selected by PESEL.</p>
</dd>
<dt>nPCs_avgvar</dt><dd><p>The number of above-average variance PCs.</p>
</dd>
</dl>

<p>where <code>Q</code> is the number of PCs selected by PESEL or of above-average variance (or the greater of the two if both were used).
If PCA was not used, all entries except <code>nPCs_PESEL</code> and/or <code>nPCs_avgvar</code> will not be included, depending on which
method(s) was used to select the number of PCs.
</p>
</dd>
<dt>ICA</dt><dd>
<p>If ICA was used, this will be a list with components:
</p>

<dl>
<dt>S</dt><dd><p>The <code class="reqn">P</code> by <code class="reqn">Q</code> source signals matrix. Included only if <code>get_dirs</code></p>
</dd>
<dt>M</dt><dd><p>The <code class="reqn">T</code> by <code class="reqn">Q</code> mixing matrix.</p>
</dd>
<dt>highkurt</dt><dd><p>The length <code>Q</code> logical vector indicating mixing scores of high kurtosis.</p>
</dd>
<dt>M_dt</dt><dd><p>Detrended components of <code>M</code>. Included only if components were mean- or variance-detrended.</p>
</dd>
<dt>highkurt</dt><dd><p>The length <code>Q</code> logical vector indicating detrended mixing scores of high kurtosis. Included only if components were mean- or variance-detrended.</p>
</dd>
</dl>

</dd>
</dl>


<hr>
<h2 id='pscrub_Params'>pscrub</h2><span id='topic+pscrub_Params'></span>

<h3>Description</h3>

<p>pscrub
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pscrub_Params_+3A_x">X</code></td>
<td>
<p>Wide numeric data matrix (<code class="reqn">T</code> observations by <code class="reqn">V</code> variables,
<code class="reqn">T &lt;&lt; V</code>). If <code>X</code> represents an fMRI run, <code class="reqn">T</code> should be the
number of timepoints and <code class="reqn">V</code> should be the number of vertices/voxels.
Projection scrubbing will measure the outlyingness of each row in <code>X</code>.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_nuisance">nuisance</code></td>
<td>
<p>Nuisance signals to regress from each column of <code>X</code>.
Should be specified as a design matrix: a <code class="reqn">T</code> by <code class="reqn">N</code> numeric matrix
where <code class="reqn">N</code> represents the number of nuisance signals. Or can be &quot;DCT4&quot;
(default), which will create a matrix with a constant column (the intercept
term) and four DCT bases. This default nuisance regression will have the
effect of demeaning and detrending the data by removing low-frequency
components. To not perform any nuisance regression set this argument to
<code>NULL</code>, <code>0</code>, or <code>FALSE</code>.
</p>
<p>Detrending is highly recommended for time-series data, especially if there
are many time points or evolving circumstances affecting the data. Additionally,
if kurtosis is being used to select the projection directions, trends can
induce positive or negative kurtosis, contaminating the connection between
high kurtosis and outlier presence. Detrending should not be used with
non-time-series data because the observations are not temporally related.
</p>
<p>Additional nuisance regressors can be specified like so:
<code>cbind(1, fMRItools::dct_bases(nrow(x), 4), more_nuisance)</code>.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_center">center</code>, <code id="pscrub_Params_+3A_scale">scale</code></td>
<td>
<p>Center the columns of the data by their medians, and scale the
columns of the data by their median absolute deviations (MADs)? Default: <code>TRUE</code>.
Centering is necessary for computing the projections, so if <code>center</code> is
<code>FALSE</code>, the data must already be centered.
</p>
<p>Note that centering and scaling occur after nuisance regression, so even if
<code>center</code> is <code>FALSE</code>, the data will be centered on the means if
the nuisance regression included an intercept term, as it does by default.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_comps_mean_dt">comps_mean_dt</code>, <code id="pscrub_Params_+3A_comps_var_dt">comps_var_dt</code></td>
<td>
<p>Stabilize the mean and variance of each
projection component's timecourse prior to computing kurtosis and leverage?
These arguments should be <code>TRUE</code>, <code>FALSE</code> (default), or the number
of DCT bases to use for detrending (<code>TRUE</code> will use 4).
Note that these arguments affect the projection components and not the data
itself. Also, if variance-stabilizing but not mean-stabilizing,
the components must already be expected to be mean-stabilized, for example
if the data was rigorously detrended; otherwise, the results will be invalid.
</p>
<p>Slow-moving mean and variance patterns in the components will interfere with
the roles of kurtosis and leverage in identifying outliers. While
<code>nuisance</code> can be used to detrend the data, this nuisance regression is
estimated <em>non-robustly</em>, since a robust model takes too long to estimate
at each data location. On the other hand, <code>comps_mean_dt</code> and
<code>comps_var_dt</code> can be used to apply a <em>robust</em> nuisance regression at each
component, since there are much fewer components than original data locations.
Thus, even if the data has been detrended with <code>nuisance</code> it may be
helpful to detrend the components with <code>comps_mean_dt</code>; furthermore,
the data nuisance regression does not address the potential existence of variance
patterns in the components.
</p>
<p>Overall, for fMRI we recommend enabling <code>comps_mean_dt</code> and <code>comps_var_dt</code>
unless the data has been cleaned not only with a low-pass filter like
DCT nuisance regression, but also with anatomical CompCor, ICA-FIX, or
a similar data-driven strategy that takes into account common sources of
artifactual mean and variance trends such as motion and physiological cycles.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_kurt_quantile">kurt_quantile</code></td>
<td>
<p>What quantile cutoff should be used to select the
components? Default: <code>0.99</code>. Use <code>0</code> to select all high-variance
components regardless of kurtosis value.
</p>
<p>We model each component as a length <code class="reqn">T</code> vector of Normal iid random variables,
for which the distribution of kurtosis values can be approximated. The
quantile is estimated based on this distribution.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_get_dirs">get_dirs</code></td>
<td>
<p>Should the projection directions be returned? This is the
<code class="reqn">V</code> matrix in PCA and <code class="reqn">S</code> matrix in ICA. The default is <code>FALSE</code>
to save memory. However, <code>get_dirs==TRUE</code> is required for <code><a href="#topic+artifact_images">artifact_images</a></code>.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_full_pca">full_PCA</code></td>
<td>
<p>Only applies to the PCA projection. Return the full SVD?
Default: <code>FALSE</code> (return only the high-variance components).</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_get_outliers">get_outliers</code></td>
<td>
<p>Should outliers be flagged based on <code>cutoff</code>? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_cutoff">cutoff</code></td>
<td>
<p>Median leverage cutoff value. Default: <code>4</code>.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_seed">seed</code></td>
<td>
<p>Set a seed right before the call to <code>pesel::pesel</code> or
<code>ica::icaimax</code>? If <code>NULL</code>, do not set a seed. If numeric (default:
<code>0</code>), will use as the seed.</p>
</td></tr>
<tr><td><code id="pscrub_Params_+3A_ica_method">ICA_method</code></td>
<td>
<p>The <code>method</code> argument to <code>fastICA</code>: <code>"C"</code> to
use C code with BLAS (default), or <code>"R"</code> to use R code.</p>
</td></tr>
</table>

<hr>
<h2 id='RD_impData'>Impute outliers for robust distance</h2><span id='topic+RD_impData'></span>

<h3>Description</h3>

<p>Impute the outliers for robust distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RD_impData(data, univOut)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RD_impData_+3A_data">data</code></td>
<td>
<p>The data</p>
</td></tr>
<tr><td><code id="RD_impData_+3A_univout">univOut</code></td>
<td>
<p>The univariate outliers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data with imputed outliers.
</p>

<hr>
<h2 id='RD_meas'>Robust distance calculation</h2><span id='topic+RD_meas'></span>

<h3>Description</h3>

<p>Compute robust distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RD_meas(data, ind_incld, dist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RD_meas_+3A_data">data</code></td>
<td>
<p>The dimension reduced and selected data.</p>
</td></tr>
<tr><td><code id="RD_meas_+3A_ind_incld">ind_incld</code></td>
<td>
<p>Indices of the included subset of <code>data</code>.</p>
</td></tr>
<tr><td><code id="RD_meas_+3A_dist">dist</code></td>
<td>
<p>Compute the robust distances? Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with parameters and optionally the robust distances.
</p>

<hr>
<h2 id='RD_univOut'>Univariate outlier detection for robust distance</h2><span id='topic+RD_univOut'></span>

<h3>Description</h3>

<p>Identify the univariate outliers with robust distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RD_univOut(data, cutoff = 4, trans = c("none", "robust-YJ", "SHASH"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RD_univOut_+3A_data">data</code></td>
<td>
<p>The data</p>
</td></tr>
<tr><td><code id="RD_univOut_+3A_cutoff">cutoff</code></td>
<td>
<p>Default: <code>4</code>.</p>
</td></tr>
<tr><td><code id="RD_univOut_+3A_trans">trans</code></td>
<td>
<p>Transform the data? Default: <code>"none"</code>. The other choice is
<code>"robust-YJ"</code>. The <code>"SHASH"</code> method has not been implemented yet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The univariate outliers.
</p>

<hr>
<h2 id='rob_stabilize'>Stabilize the center and scale of a timeseries robustly</h2><span id='topic+rob_stabilize'></span>

<h3>Description</h3>

<p>Stabilize the center and scale of a timeseries using robust regression of
DCT bases on the first and second moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob_stabilize(
  x,
  center = TRUE,
  scale = TRUE,
  lmrob_method = "MM",
  rescale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rob_stabilize_+3A_x">x</code></td>
<td>
<p>The timeseries to stabilize.</p>
</td></tr>
<tr><td><code id="rob_stabilize_+3A_center">center</code>, <code id="rob_stabilize_+3A_scale">scale</code></td>
<td>
<p>Center and scale? Default: <code>TRUE</code> for both. If
scaling but not centering, the data must already be centered; otherwise,
the results will be invalid. Can also be the number of DCT bases to use for
robust stabilization of center/scale; <code>TRUE</code> will use <code>4</code>.</p>
</td></tr>
<tr><td><code id="rob_stabilize_+3A_lmrob_method">lmrob_method</code></td>
<td>
<p>The <code>lmrob_method</code> argument to <code>robustbase::lmrob</code>.</p>
</td></tr>
<tr><td><code id="rob_stabilize_+3A_rescale">rescale</code></td>
<td>
<p>After stabilizing <code>x</code>, re-center and re-scale
to the original mean and variance? Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the timeseries with its center and scale stabilized
</p>

<hr>
<h2 id='rob_trend'>Robust linear model on DCT bases</h2><span id='topic+rob_trend'></span>

<h3>Description</h3>

<p>Fit a linear model regressing an input vector on DCT bases, robustly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob_trend(x, nDCT = 4, lmrob_method = "MM", seed = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rob_trend_+3A_x">x</code></td>
<td>
<p>The input vector to regress on DCT bases</p>
</td></tr>
<tr><td><code id="rob_trend_+3A_ndct">nDCT</code></td>
<td>
<p>The number of DCT bases to use. Default: <code>4</code></p>
</td></tr>
<tr><td><code id="rob_trend_+3A_lmrob_method">lmrob_method</code></td>
<td>
<p>The <code>lmrob_method</code> argument to <code>robustbase::lmrob</code>.</p>
</td></tr>
<tr><td><code id="rob_trend_+3A_seed">seed</code></td>
<td>
<p>Set a seed right before the call to <code>robustbase::lmrob</code>?
If <code>NULL</code>, do not set a seed. If numeric (default: <code>0</code>), will use
as the seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of <code>robustbase::lmrob</code>
</p>

<hr>
<h2 id='robdist'>Robust distance scrubbing</h2><span id='topic+robdist'></span>

<h3>Description</h3>

<p>Scrubbing with robust distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robdist(
  X,
  RD_cutoff = 4,
  RD_quantile = 0.99,
  trans = c("none", "robust-YJ", "SHASH"),
  bootstrap_n = 1000,
  bootstrap_alpha = 0.01,
  projection = c("ICA", "PCA"),
  nuisance = "DCT4",
  center = TRUE,
  scale = TRUE,
  comps_mean_dt = FALSE,
  comps_var_dt = FALSE,
  PESEL = TRUE,
  kurt_quantile = 0.99,
  get_dirs = FALSE,
  full_PCA = FALSE,
  get_outliers = TRUE,
  cutoff = 4,
  seed = 0,
  ICA_method = c("C", "R"),
  skip_dimred = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robdist_+3A_x">X</code></td>
<td>
<p>Wide numeric data matrix (<code class="reqn">T</code> observations by <code class="reqn">V</code> variables,
<code class="reqn">T &lt;&lt; V</code>). If <code>X</code> represents an fMRI run, <code class="reqn">T</code> should be the
number of timepoints and <code class="reqn">V</code> should be the number of vertices/voxels.
Projection scrubbing will measure the outlyingness of each row in <code>X</code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_rd_cutoff">RD_cutoff</code></td>
<td>
<p>Default: <code>4</code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_rd_quantile">RD_quantile</code></td>
<td>
<p>Quantile cutoff...?</p>
</td></tr>
<tr><td><code id="robdist_+3A_trans">trans</code></td>
<td>
<p>Apply a transformation prior to univariate outlier detection?
Three options: <code>"none"</code> (default), <code>"robust-YJ"</code>, and
<code>"SHASH"</code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_bootstrap_n">bootstrap_n</code></td>
<td>
<p>Use bootstrapping to estimate the robust distance null
distribution? If so, set this to the number of bootstraps. Default:
<code>100</code>. Use <code>0</code> (or <code>FALSE</code>), to use an empirical quantile
instead.</p>
</td></tr>
<tr><td><code id="robdist_+3A_bootstrap_alpha">bootstrap_alpha</code></td>
<td>
<p>If using bootstrap (<code>bootstrap &gt; 0</code>), this is the
level of the bootstrap CI. Default: <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_projection">projection</code></td>
<td>
<p>One of the following: <code>"ICA"</code> (default) or <code>"PCA"</code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_nuisance">nuisance</code></td>
<td>
<p>Nuisance signals to regress from each column of <code>X</code>.
Should be specified as a design matrix: a <code class="reqn">T</code> by <code class="reqn">N</code> numeric matrix
where <code class="reqn">N</code> represents the number of nuisance signals. Or can be &quot;DCT4&quot;
(default), which will create a matrix with a constant column (the intercept
term) and four DCT bases. This default nuisance regression will have the
effect of demeaning and detrending the data by removing low-frequency
components. To not perform any nuisance regression set this argument to
<code>NULL</code>, <code>0</code>, or <code>FALSE</code>.
</p>
<p>Detrending is highly recommended for time-series data, especially if there
are many time points or evolving circumstances affecting the data. Additionally,
if kurtosis is being used to select the projection directions, trends can
induce positive or negative kurtosis, contaminating the connection between
high kurtosis and outlier presence. Detrending should not be used with
non-time-series data because the observations are not temporally related.
</p>
<p>Additional nuisance regressors can be specified like so:
<code>cbind(1, fMRItools::dct_bases(nrow(x), 4), more_nuisance)</code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_center">center</code>, <code id="robdist_+3A_scale">scale</code></td>
<td>
<p>Center the columns of the data by their medians, and scale the
columns of the data by their median absolute deviations (MADs)? Default: <code>TRUE</code>.
Centering is necessary for computing the projections, so if <code>center</code> is
<code>FALSE</code>, the data must already be centered.
</p>
<p>Note that centering and scaling occur after nuisance regression, so even if
<code>center</code> is <code>FALSE</code>, the data will be centered on the means if
the nuisance regression included an intercept term, as it does by default.</p>
</td></tr>
<tr><td><code id="robdist_+3A_comps_mean_dt">comps_mean_dt</code>, <code id="robdist_+3A_comps_var_dt">comps_var_dt</code></td>
<td>
<p>Stabilize the mean and variance of each
projection component's timecourse prior to computing kurtosis and leverage?
These arguments should be <code>TRUE</code>, <code>FALSE</code> (default), or the number
of DCT bases to use for detrending (<code>TRUE</code> will use 4).
Note that these arguments affect the projection components and not the data
itself. Also, if variance-stabilizing but not mean-stabilizing,
the components must already be expected to be mean-stabilized, for example
if the data was rigorously detrended; otherwise, the results will be invalid.
</p>
<p>Slow-moving mean and variance patterns in the components will interfere with
the roles of kurtosis and leverage in identifying outliers. While
<code>nuisance</code> can be used to detrend the data, this nuisance regression is
estimated <em>non-robustly</em>, since a robust model takes too long to estimate
at each data location. On the other hand, <code>comps_mean_dt</code> and
<code>comps_var_dt</code> can be used to apply a <em>robust</em> nuisance regression at each
component, since there are much fewer components than original data locations.
Thus, even if the data has been detrended with <code>nuisance</code> it may be
helpful to detrend the components with <code>comps_mean_dt</code>; furthermore,
the data nuisance regression does not address the potential existence of variance
patterns in the components.
</p>
<p>Overall, for fMRI we recommend enabling <code>comps_mean_dt</code> and <code>comps_var_dt</code>
unless the data has been cleaned not only with a low-pass filter like
DCT nuisance regression, but also with anatomical CompCor, ICA-FIX, or
a similar data-driven strategy that takes into account common sources of
artifactual mean and variance trends such as motion and physiological cycles.</p>
</td></tr>
<tr><td><code id="robdist_+3A_pesel">PESEL</code></td>
<td>
<p>Use <code><a href="pesel.html#topic+pesel">pesel</a></code> to select the number of
components? Default: <code>TRUE</code>. Otherwise, use the number of principal
components with above-average variance.</p>
</td></tr>
<tr><td><code id="robdist_+3A_kurt_quantile">kurt_quantile</code></td>
<td>
<p>What quantile cutoff should be used to select the
components? Default: <code>0.99</code>. Use <code>0</code> to select all high-variance
components regardless of kurtosis value.
</p>
<p>We model each component as a length <code class="reqn">T</code> vector of Normal iid random variables,
for which the distribution of kurtosis values can be approximated. The
quantile is estimated based on this distribution.</p>
</td></tr>
<tr><td><code id="robdist_+3A_get_dirs">get_dirs</code></td>
<td>
<p>Should the projection directions be returned? This is the
<code class="reqn">V</code> matrix in PCA and <code class="reqn">S</code> matrix in ICA. The default is <code>FALSE</code>
to save memory. However, <code>get_dirs==TRUE</code> is required for <code><a href="#topic+artifact_images">artifact_images</a></code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_full_pca">full_PCA</code></td>
<td>
<p>Only applies to the PCA projection. Return the full SVD?
Default: <code>FALSE</code> (return only the high-variance components).</p>
</td></tr>
<tr><td><code id="robdist_+3A_get_outliers">get_outliers</code></td>
<td>
<p>Should outliers be flagged based on <code>cutoff</code>? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_cutoff">cutoff</code></td>
<td>
<p>Median leverage cutoff value. Default: <code>4</code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_seed">seed</code></td>
<td>
<p>Set a seed right before the call to <code>pesel::pesel</code> or
<code>ica::icaimax</code>? If <code>NULL</code>, do not set a seed. If numeric (default:
<code>0</code>), will use as the seed.</p>
</td></tr>
<tr><td><code id="robdist_+3A_ica_method">ICA_method</code></td>
<td>
<p>The <code>method</code> argument to <code>fastICA</code>: <code>"C"</code> to
use C code with BLAS (default), or <code>"R"</code> to use R code.</p>
</td></tr>
<tr><td><code id="robdist_+3A_skip_dimred">skip_dimred</code></td>
<td>
<p>Skip dimension reduction? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="robdist_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"robdist"</code> object, i.e. a list with components
</p>

<dl>
<dt>lwr_50</dt><dd><p>...</p>
</dd>
<dt>lwr_80</dt><dd><p>...</p>
</dd>
<dt>B_quant</dt><dd><p>...</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(fastICA)
rdx = robdist(Dat1[seq(70),seq(800,950)])
</code></pre>

<hr>
<h2 id='scrub'>Data-driven scrubbing</h2><span id='topic+scrub'></span>

<h3>Description</h3>

<p>Performs projection scrubbing or DVARS scrubbing, and optionally thresholds
to identify artifactual time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrub(X, method = c("projection", "DVARS"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scrub_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">T</code> by <code class="reqn">V</code> numeric matrix representing an fMRI run. There should
not be any missing data (<code>NA</code> or <code>NaN</code>).</p>
</td></tr>
<tr><td><code id="scrub_+3A_method">method</code></td>
<td>
<p><code>"projection"</code> (default) or <code>"DVARS"</code></p>
</td></tr>
<tr><td><code id="scrub_+3A_...">...</code></td>
<td>
<p>Additional arguments to the specific scrubbing function: see
<code><a href="#topic+pscrub">pscrub</a></code> or <code><a href="#topic+DVARS">DVARS</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<dl>
<dt>measure</dt><dd><p>A length <code class="reqn">T</code> vector or data.frame with <code class="reqn">T</code> rows, giving the outlyingness measure(s)</p>
</dd>
<dt>measure_info</dt><dd><p>Describes the outlyingness measure(s)</p>
</dd>
<dt>outlier_cutoff</dt><dd><p>The outlier cutoff value(s).</p>
</dd>
<dt>outlier_flag</dt><dd><p>A length <code class="reqn">T</code> vector or data.frame with <code class="reqn">T</code> rows,  where <code>TRUE</code> indicates suspected outlier presence.</p>
</dd>
</dl>


<hr>
<h2 id='scrub_plot'><code>"scrub"</code> plot sub-function</h2><span id='topic+scrub_plot'></span>

<h3>Description</h3>

<p>Plot outlyingness measure(s) with the corresponding threshold(s). Requires
the <code>cowplot</code> and <code>ggplot2</code> packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrub_plot(
  meas,
  cut = NULL,
  flag_intersect = FALSE,
  colors = NULL,
  log_y = FALSE,
  geom = "point",
  ylim_min = 0,
  ylim_max = max(meas$measure),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scrub_plot_+3A_meas">meas</code></td>
<td>
<p>A <code class="reqn">T</code> by <code>m</code> numeric data.frame with each column being the timecourse for an
outlyingness measure. The names of the columns will be used to label the plot.</p>
</td></tr>
<tr><td><code id="scrub_plot_+3A_cut">cut</code></td>
<td>
<p>A length <code class="reqn">m</code> numeric vector with each value being the cutoff for an
outlyingness measure (each column in <code>meas</code>).</p>
</td></tr>
<tr><td><code id="scrub_plot_+3A_flag_intersect">flag_intersect</code></td>
<td>
<p>Only flag timepoints at which all measures are outliers?
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scrub_plot_+3A_colors">colors</code></td>
<td>
<p>A length <code class="reqn">m</code> character vector giving the colors of each
measure (each column in <code>meas</code>)</p>
</td></tr>
<tr><td><code id="scrub_plot_+3A_log_y">log_y</code></td>
<td>
<p>Use log scale for y-axis? Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="scrub_plot_+3A_geom">geom</code></td>
<td>
<p>&quot;point&quot; (default) or &quot;line&quot;</p>
</td></tr>
<tr><td><code id="scrub_plot_+3A_ylim_min">ylim_min</code>, <code id="scrub_plot_+3A_ylim_max">ylim_max</code></td>
<td>
<p>The range of the y-axis.</p>
</td></tr>
<tr><td><code id="scrub_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments to ggplot: main, sub, xlab, ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>

<hr>
<h2 id='scrub_xifti'>Scrub fMRI data in CIFTI format</h2><span id='topic+scrub_xifti'></span>

<h3>Description</h3>

<p>Performs projection scrubbing or DVARS scrubbing, and optionally thresholds
to identify artifactual time points. Requires <code>ciftiTools</code> and the
Connectome Workbench.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrub_xifti(
  X,
  method = c("projection", "DVARS"),
  brainstructures = c("left", "right"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scrub_xifti_+3A_x">X</code></td>
<td>
<p>Path to a CIFTI file, or a <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="scrub_xifti_+3A_method">method</code></td>
<td>
<p><code>"projection"</code> or <code>"DVARS"</code></p>
</td></tr>
<tr><td><code id="scrub_xifti_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
to use: <code>"left"</code> (left cortical surface), <code>"right"</code> (right
cortical surface) and/or <code>"subcortical"</code> (subcortical and cerebellar
gray matter). Can also be <code>"all"</code> (obtain all three brain structures).
Default: <code>c("left", "right")</code> (excludes the subcortex).</p>
</td></tr>
<tr><td><code id="scrub_xifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to each specific scrubbing function:
<code><a href="#topic+pscrub">pscrub</a></code> or <code><a href="#topic+DVARS">DVARS</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<dl>
<dt>measure</dt><dd><p>A length <code class="reqn">T</code> vector or data.frame with <code class="reqn">T</code> rows, giving the outlyingness measure(s)</p>
</dd>
<dt>measure_info</dt><dd><p>Describes the outlyingness measure(s)</p>
</dd>
<dt>outlier_cutoff</dt><dd><p>The outlier cutoff value(s).</p>
</dd>
<dt>outlier_flag</dt><dd><p>A length <code class="reqn">T</code> vector or data.frame with <code class="reqn">T</code> rows,  where <code>TRUE</code> indicates suspected outlier presence.</p>
</dd>
</dl>


<hr>
<h2 id='sd_hIQR'>Estimate SD robustly using the half IQR</h2><span id='topic+sd_hIQR'></span>

<h3>Description</h3>

<p>Estimates standard deviation robustly using the half IQR (and power trans.).
Used to measure DVARS in Afyouni and Nichols, 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_hIQR(x, d = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd_hIQR_+3A_x">x</code></td>
<td>
<p>Numeric vector of data to estimate standard deviation for.</p>
</td></tr>
<tr><td><code id="sd_hIQR_+3A_d">d</code></td>
<td>
<p>The scalar power transformation parameter. <code class="reqn">w = x^{1/d}</code> is
computed to obtain <code class="reqn">w \sim N(\mu_w, \sigma_w^2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar for the robust estimate of standard deviation.
</p>

<hr>
<h2 id='SHASH_out'>Robust outlier detection based on SHASH distribution</h2><span id='topic+SHASH_out'></span>

<h3>Description</h3>

<p>A robust outlier detection based on modeling the data as coming from a SHASH
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SHASH_out(x, maxit = 20, out_lim = 3, weight_init = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SHASH_out_+3A_x">x</code></td>
<td>
<p>The numeric vector in which to detect outliers.</p>
</td></tr>
<tr><td><code id="SHASH_out_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations. Default: <code>10</code>.</p>
</td></tr>
<tr><td><code id="SHASH_out_+3A_out_lim">out_lim</code></td>
<td>
<p>SD threshold for outlier flagging. Default: <code>4</code>.</p>
</td></tr>
<tr><td><code id="SHASH_out_+3A_weight_init">weight_init</code></td>
<td>
<p>Initial weights. Default: <code>NULL</code> (no pre-determined outliers).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"SHASH_out"</code> object, i.e. a list with components
</p>

<dl>
<dt>out_idx</dt><dd><p>Indices of the detected outliers.</p>
</dd>
<dt>x_norm</dt><dd><p>The normalized data.</p>
</dd>
<dt>SHASH_coef</dt><dd><p>Coefficients for the SHASH-to-normal transformation.</p>
</dd>
<dt>indx_iters</dt><dd><p>TRUE for the detected outliers for each itertation.</p>
</dd>
<dt>last_iter</dt><dd><p>Last iteration number.</p>
</dd>
<dt>converged</dt><dd><p>Logical indicating whether the convergence criteria was satisfied or not.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100) + (seq(100)/200)
x[77] &lt;- 13
SHASH_out(x)

</code></pre>

<hr>
<h2 id='SHASH_to_normal'>SHASH to normal data transformation</h2><span id='topic+SHASH_to_normal'></span>

<h3>Description</h3>

<p>Transform SHASH-distributed data to normal-distributed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SHASH_to_normal(x, mu, sigma, nu, tau, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SHASH_to_normal_+3A_x">x</code></td>
<td>
<p>Numeric vector of data to transform.</p>
</td></tr>
<tr><td><code id="SHASH_to_normal_+3A_mu">mu</code></td>
<td>
<p>Parameter that modulates the mean of <code>x</code>.</p>
</td></tr>
<tr><td><code id="SHASH_to_normal_+3A_sigma">sigma</code></td>
<td>
<p>Parameter that modulates the variance of <code>x</code>.
Must be greater than zero. This parameter is on the logarithm scale.</p>
</td></tr>
<tr><td><code id="SHASH_to_normal_+3A_nu">nu</code></td>
<td>
<p>Parameter that modulates the skewness of <code>x</code>.</p>
</td></tr>
<tr><td><code id="SHASH_to_normal_+3A_tau">tau</code></td>
<td>
<p>Parameter that modulates the tailweight of <code>x</code>.
Must be greater than zero. This parameter is on the logarithm scale.</p>
</td></tr>
<tr><td><code id="SHASH_to_normal_+3A_inverse">inverse</code></td>
<td>
<p>Transform normal data to SHASH instead? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed data.
</p>

<hr>
<h2 id='summary.scrub_DVARS'>Summarize a <code>"scrub_DVARS"</code> object</h2><span id='topic+summary.scrub_DVARS'></span><span id='topic+print.summary.scrub_DVARS'></span><span id='topic+print.scrub_DVARS'></span>

<h3>Description</h3>

<p>Summary method for class <code>"scrub_DVARS"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scrub_DVARS'
summary(object, ...)

## S3 method for class 'summary.scrub_DVARS'
print(x, ...)

## S3 method for class 'scrub_DVARS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scrub_DVARS_+3A_object">object</code></td>
<td>
<p>Object of class <code>"scrub_DVARS"</code>.</p>
</td></tr>
<tr><td><code id="summary.scrub_DVARS_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.scrub_DVARS_+3A_x">x</code></td>
<td>
<p>Object of class <code>"scrub_DVARS"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the scrubbing results
</p>

<hr>
<h2 id='summary.scrub_FD'>Summarize a <code>"scrub_FD"</code> object</h2><span id='topic+summary.scrub_FD'></span><span id='topic+print.summary.scrub_FD'></span><span id='topic+print.scrub_FD'></span>

<h3>Description</h3>

<p>Summary method for class <code>"scrub_FD"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scrub_FD'
summary(object, ...)

## S3 method for class 'summary.scrub_FD'
print(x, ...)

## S3 method for class 'scrub_FD'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scrub_FD_+3A_object">object</code></td>
<td>
<p>Object of class <code>"scrub_FD"</code>.</p>
</td></tr>
<tr><td><code id="summary.scrub_FD_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.scrub_FD_+3A_x">x</code></td>
<td>
<p>Object of class <code>"scrub_FD"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the scrubbing results
</p>

<hr>
<h2 id='summary.scrub_projection'>Summarize a <code>"scrub_projection"</code> object</h2><span id='topic+summary.scrub_projection'></span><span id='topic+print.summary.scrub_projection'></span><span id='topic+print.scrub_projection'></span>

<h3>Description</h3>

<p>Summary method for class <code>"scrub_projection"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scrub_projection'
summary(object, ...)

## S3 method for class 'summary.scrub_projection'
print(x, ...)

## S3 method for class 'scrub_projection'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scrub_projection_+3A_object">object</code></td>
<td>
<p>Object of class <code>"scrub_projection"</code>.</p>
</td></tr>
<tr><td><code id="summary.scrub_projection_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.scrub_projection_+3A_x">x</code></td>
<td>
<p>Object of class <code>"scrub_projection"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the scrubbing results
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
