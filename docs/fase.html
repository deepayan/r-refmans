<!DOCTYPE html><html><head><title>Help for package fase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fase'><p>Functional adjacency spectral embedding</p></a></li>
<li><a href='#fase_seq'><p>Functional adjacency spectral embedding (sequential algorithm)</p></a></li>
<li><a href='#gaussian_snapshot_bs'><p>Simulate Gaussian edge networks with B-spline latent processes</p></a></li>
<li><a href='#gaussian_snapshot_ss'><p>Simulate Gaussian edge networks with nonparametric latent processes</p></a></li>
<li><a href='#proc_align'><p>Procrustes alignment</p></a></li>
<li><a href='#proc_align_slicewise3'><p>Slicewise Procrustes alignment for 3-mode tensors</p></a></li>
<li><a href='#proc_align3'><p>Procrustes alignment for 3-mode tensors</p></a></li>
<li><a href='#rdpg_snapshot_bs'><p>Simulate binary edge networks with B-spline latent processes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functional Adjacency Spectral Embedding</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Latent process embedding for functional network data with the Functional Adjacency Spectral Embedding. Fits smooth latent processes based on cubic spline bases. Also generates functional network data from three models, and evaluates a network generalized cross-validation criterion for dimension selection. For more information, see MacDonald, Zhu and Levina (2022+) &lt;<a href="https://arxiv.org/abs/2210.07491">arXiv:2210.07491</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/peterwmacd/fase">https://github.com/peterwmacd/fase</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/peterwmacd/fase/issues">https://github.com/peterwmacd/fase/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>RSpectra (&ge; 0.16.1), rTensor (&ge; 1.4.8), splines2 (&ge; 0.4.7)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 20:14:00 UTC; petermacdonald</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter W. MacDonald
    <a href="https://orcid.org/0000-0001-7024-7242"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter W. MacDonald &lt;pwmacdon@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 19:33:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='fase'>Functional adjacency spectral embedding</h2><span id='topic+fase'></span>

<h3>Description</h3>

<p><code>fase</code> fits a functional adjacency spectral embedding to snapshots
of (undirected) functional network data. The latent processes are fit
in a spline basis specified by the user, with additional options for
ridge penalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fase(A,d,self_loops,spline_design,lambda,optim_options,output_options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fase_+3A_a">A</code></td>
<td>
<p>An <code class="reqn">n \times n \times m</code> array containing
the snapshots of the functional network.</p>
</td></tr>
<tr><td><code id="fase_+3A_d">d</code></td>
<td>
<p>A positive integer, the number of latent space dimensions of the
functional embedding.</p>
</td></tr>
<tr><td><code id="fase_+3A_self_loops">self_loops</code></td>
<td>
<p>A Boolean, if <code>FALSE</code>, all diagonal entries are ignored in
optimization. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fase_+3A_spline_design">spline_design</code></td>
<td>
<p>A list, containing the spline design information.
For fitting with a <code class="reqn">B</code>-spline design (the default):
</p>

<dl>
<dt>type</dt><dd><p>The string <code>'bs'</code>.</p>
</dd>
<dt>q</dt><dd><p>A positive integer, the dimension of the <code class="reqn">B</code>-spline basis.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.
Defaults to an equally spaced vector of length <code class="reqn">m</code> from <code>0</code>
to <code>1</code>.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space. Defaults to
<code>max(spline_design$x_vec)</code>.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space. Defaults to
<code>min(spline_design$x_vec)</code>.</p>
</dd>
<dt>spline_matrix</dt><dd><p>An <code class="reqn">m \times q</code> matrix, the B-spline basis
evaluated at the snapshot indices. If not specified, it will be
calculated internally.</p>
</dd>
<dt>ridge_mat</dt><dd><p>The <code class="reqn">m \times m</code> matrix for the generalized
ridge penalty. If <code>lambda</code><code class="reqn">&gt; 0</code>,
defaults to <code>diag(m)</code>.</p>
</dd>
</dl>

<p>For fitting with a smoothing spline design:
</p>

<dl>
<dt>type</dt><dd><p>The string <code>'ss'</code>.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.
Defaults to an equally spaced vector of length <code class="reqn">m</code> from <code>0</code>
to <code>1</code>.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space. Defaults to
<code>max(spline_design$x_vec)</code>.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space. Defaults to
<code>min(spline_design$x_vec)</code>.</p>
</dd>
<dt>spline_matrix</dt><dd><p>An <code class="reqn">m \times m</code> matrix, the
natural cubic spline basis
evaluated at the snapshot indices. If not specified, it will be
calculated internally.</p>
</dd>
<dt>ridge_mat</dt><dd><p>The <code class="reqn">m \times m</code> matrix for the generalized
ridge penalty. Defaults to the second derivatives of the natural cubic spline
basis evaluated at the snapshot indices.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fase_+3A_lambda">lambda</code></td>
<td>
<p>A positive scalar, the scale factor for the generalized ridge
penalty (see Details). Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="fase_+3A_optim_options">optim_options</code></td>
<td>
<p>A list, containing additional optional arguments controlling
the gradient descent algorithm.
</p>

<dl>
<dt>eps</dt><dd><p>A positive scalar, the convergence threshold for gradient
descent in terms of relative change in objective value.
Defaults to <code>1e-5</code>.</p>
</dd>
<dt>eta</dt><dd><p>A positive scalar, the step size for gradient descent.
Defaults to <code>1/(n*m)</code>.</p>
</dd>
<dt>K_max</dt><dd><p>A positive integer, the maximum iterations for gradient
descent. Defaults to <code>2e3</code>.</p>
</dd>
<dt>verbose</dt><dd><p>A Boolean, if <code>TRUE</code>, console output will provide
updates on the progress of gradient descent. Defaults to
<code>FALSE</code>.</p>
</dd>
<dt>init_W</dt><dd><p>A 3-dimensional array
containing initial basis coordinates for gradient descent. Dimension should be
<code class="reqn">n \times</code><code>spline_design$q</code><code class="reqn"> \times d</code> for <code class="reqn">B</code>-spline designs,
and <code class="reqn">n \times m \times d</code> for smoothing spline designs. If included,
<code>init_M</code>, <code>init_L</code> and <code>init_sigma</code> are ignored.</p>
</dd>
<dt>init_sigma</dt><dd><p>A positive scalar, the estimated edge dispersion parameter to calibrate
initialization. If not provided, it is either estimated using the robust method proposed by
Gavish and Donoho (2014) for weighted edge networks, or set to a default value <code>0.5</code>
for binary edge networks.</p>
</dd>
<dt>init_L</dt><dd><p>A positive integer, the number of contiguous groups used for initialization.
Defaults to the floor of <code class="reqn">(2nm/\texttt{init\_sigma}^2)^{1/3}</code>.</p>
</dd>
<dt>init_M</dt><dd><p>A positive integer, the number of snapshots averaged in each group for
initialization. Defaults use all snapshots.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fase_+3A_output_options">output_options</code></td>
<td>
<p>A list, containing additional optional arguments controlling
the output of <code>fase</code>.
</p>

<dl>
<dt>align_output</dt><dd><p>A Boolean, if <code>TRUE</code>, the returned latent processes
have been aligned according to a Procrustes alignment which minimizes
(in terms of Frobenius norm) the overall discrepancies between consecutive
snapshots. Defaults to <code>TRUE</code>.</p>
</dd>
<dt>return_coords</dt><dd><p>A Boolean, if <code>TRUE</code>, the basis coordinates for
each latent process component are also returned as an array.
Defaults to <code>FALSE</code>.</p>
</dd>
<dt>return_ngcv</dt><dd><p>A Boolean, if <code>TRUE</code> and <code>spline_design$type=='bs'</code>,
the network generalized cross validation criterion is returned.
Defaults to <code>TRUE</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fase</code> finds a functional adjacency spectral embedding of an
<code class="reqn">n \times n \times m</code> array <code class="reqn">A</code> of
symmetric adjacency matrices on a common set of nodes, where
each <code class="reqn">n \times n</code> slice is associated to a scalar index <code class="reqn">x_k</code>
for <code class="reqn">k=1,...,m</code>.
Embedding requires the specification of a latent space dimension
<code class="reqn">d</code> and spline design information (with the argument
<code>spline_design</code>).
</p>
<p><code>fase</code> can fit latent processes using either a cubic <code class="reqn">B</code>-spline
basis with
equally spaced knots, or a natural cubic spline basis with a second
derivative (generalized ridge) smoothing penalty: a smoothing spline.
To fit with a <code class="reqn">B</code>-spline design (<code>spline_design$type = 'bs'</code>),
one must minimally provide a basis
dimension <code class="reqn">q</code> of at least <code>4</code> and at most <code class="reqn">m</code>.
</p>
<p>When fitting with a smoothing spline design, the generalized ridge
penalty is scaled by
<code class="reqn">\lambda/n</code>, where <code class="reqn">\lambda</code> is specified by the argument <code>lambda</code>.
see <a href="https://arxiv.org/abs/2210.07491">MacDonald et al., (2022+)</a>,
Appendix E for more details.
<code>lambda</code> can also be used to introduce a ridge penalty on the
basis coordinates when fitting with <code class="reqn">B</code>-splines.
</p>
<p>Fitting minimizes a least squares loss,
using gradient descent (Algorithm 2) on the basis coordinates <code class="reqn">w_{i,r}</code>
of each component process
</p>
<p style="text-align: center;"><code class="reqn">z_{i,r}(x) = w_{i,r}^{T}B(x).</code>
</p>

<p>Additional options for the fitting algorithm, including initialization,
can be specified by the argument <code>optim_options</code>.
For more details on the fitting and initialization algorithms, see
<a href="https://arxiv.org/abs/2210.07491">MacDonald et al., (2022+)</a>,
Section 3.
</p>
<p>By default, <code>fase</code> will return estimates of the latent processes
evaluated at the snapshot indices as an <code class="reqn">n \times d \times m</code> array, after
performing a Procrustes alignment of the consecutive snapshots.
This extra alignment step can be skipped.
<code>fase</code> will also return the spline design information used to fit the
embedding, convergence information for gradient descent, and (if specified)
the basis coordinates.
</p>
<p>When fitting with <code class="reqn">B</code>-splines, <code>fase</code> can return a
network generalized cross validation criterion, described in
<a href="https://arxiv.org/abs/2210.07491">MacDonald et al., (2022+)</a>,
Section 3.3. This criterion can be minimized to choose appropriate values
for <code class="reqn">q</code> and <code class="reqn">d</code>.
</p>


<h3>Value</h3>

<p>A list is returned with the functional adjacency spectral embedding,
the spline design information, and some additional optimization
output:
</p>
<table>
<tr><td><code>Z</code></td>
<td>
<p>An <code class="reqn">n \times d \times m</code> array containing the latent process embedding
evaluated at the indices in <code>spline_design$x_vec</code>.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>For <code class="reqn">B</code>-spline designs, an <code class="reqn">n \times q \times d</code> array; or for
smoothing spline designs, an <code class="reqn">n \times m \times d</code> array of estimated basis
coordinates. If <code>output_options$return_coords</code> is <code>FALSE</code>,
this is not returned.</p>
</td></tr>
<tr><td><code>spline_design</code></td>
<td>
<p>A list, describing the spline design:
</p>

<dl>
<dt>type</dt><dd><p>A string, either <code>'bs'</code> or <code>'ss'</code>.</p>
</dd>
<dt>q</dt><dd><p>A positive integer, the dimension of the <code class="reqn">B</code>-spline basis.
Only returned for <code class="reqn">B</code>-spline designs.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space.</p>
</dd>
<dt>spline_matrix</dt><dd><p>For <code class="reqn">B</code>-spline designs, an <code class="reqn">m \times q</code> matrix;
or for smoothing spline designs, an <code class="reqn">m \times m</code> matrix, the basis
evaluated at the snapshot indices.</p>
</dd>
<dt>ridge_matrix</dt><dd><p>An <code class="reqn">m \times m</code> matrix used in the generalized
ridge penalty. Only returned for <code>lambda &gt; 0</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>ngcv</code></td>
<td>
<p>A scalar, the network generalized cross validation criterion
(see Details). Only returned for <code class="reqn">B</code>-spline designs and when
<code>output_options$return_ngcv</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>A positive integer, the number of iterations run in
gradient descent.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>An integer convergence code, <code>1</code> if
gradient descent converged in fewer than <code>optim_options$K_max</code> iterations,
<code>0</code> otherwise.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian edge data with sinusoidal latent processes
set.seed(1)
data &lt;- gaussian_snapshot_ss(n=50,d=2,
                             x_vec=seq(0,1,length.out=50),
                             self_loops=FALSE,sigma_edge=4)


# fase fit with B-spline design
fit_bs &lt;- fase(data$A,d=2,self_loops=FALSE,
               spline_design=list(type='bs',q=9,x_vec=data$spline_design$x_vec),
               optim_options=list(eps=1e-4,K_max=40),
               output_options=list(return_coords=TRUE))

# fase fit with smoothing spline design
fit_ss &lt;- fase(data$A,d=2,self_loops=FALSE,
               spline_design=list(type='ss',x_vec=data$spline_design$x_vec),
               lambda=.5,
               optim_options=list(eta=1e-4,K_max=40,verbose=FALSE),
               output_options=list(align_output=FALSE))

#NOTE: both examples fit with small optim_options$K_max=40 for demonstration

</code></pre>

<hr>
<h2 id='fase_seq'>Functional adjacency spectral embedding (sequential algorithm)</h2><span id='topic+fase_seq'></span>

<h3>Description</h3>

<p><code>fase_seq</code> fits a functional adjacency spectral embedding to snapshots
of (undirected) functional network data, with each
of the <code class="reqn">d</code> latent dimensions fit sequentially. The latent processes are fit
in a spline basis specified by the user, with additional options for
ridge penalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fase_seq(A,d,self_loops,spline_design,lambda,optim_options,output_options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fase_seq_+3A_a">A</code></td>
<td>
<p>An <code class="reqn">n \times n \times m</code> array containing
the snapshots of the functional network.</p>
</td></tr>
<tr><td><code id="fase_seq_+3A_d">d</code></td>
<td>
<p>A positive integer, the number of latent space dimensions of the
functional embedding.</p>
</td></tr>
<tr><td><code id="fase_seq_+3A_self_loops">self_loops</code></td>
<td>
<p>A Boolean, if <code>FALSE</code>, all diagonal entries are ignored in
optimization. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fase_seq_+3A_spline_design">spline_design</code></td>
<td>
<p>A list, containing the spline design information.
For fitting with a <code class="reqn">B</code>-spline design (the default):
</p>

<dl>
<dt>type</dt><dd><p>The string <code>'bs'</code>.</p>
</dd>
<dt>q</dt><dd><p>A positive integer, the dimension of the <code class="reqn">B</code>-spline basis.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.
Defaults to an equally spaced vector of length <code class="reqn">m</code> from <code>0</code>
to <code>1</code>.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space. Defaults to
<code>max(spline_design$x_vec)</code>.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space. Defaults to
<code>min(spline_design$x_vec)</code>.</p>
</dd>
<dt>spline_matrix</dt><dd><p>An <code class="reqn">m \times q</code> matrix, the B-spline basis
evaluated at the snapshot indices. If not specified, it will be
calculated internally.</p>
</dd>
<dt>ridge_mat</dt><dd><p>The <code class="reqn">m \times m</code> matrix for the generalized
ridge penalty. If <code>lambda</code><code class="reqn">&gt; 0</code>,
defaults to <code>diag(m)</code>.</p>
</dd>
</dl>

<p>For fitting with a smoothing spline design:
</p>

<dl>
<dt>type</dt><dd><p>The string <code>'ss'</code>.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.
Defaults to an equally spaced vector of length <code class="reqn">m</code> from <code>0</code>
to <code>1</code>.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space. Defaults to
<code>max(spline_design$x_vec)</code>.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space. Defaults to
<code>min(spline_design$x_vec)</code>.</p>
</dd>
<dt>spline_matrix</dt><dd><p>An <code class="reqn">m \times m</code> matrix, the
natural cubic spline basis
evaluated at the snapshot indices. If not specified, it will be
calculated internally.</p>
</dd>
<dt>ridge_mat</dt><dd><p>The <code class="reqn">m \times m</code> matrix for the generalized
ridge penalty. Defaults to the second derivatives of the natural cubic spline
basis evaluated at the snapshot indices.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fase_seq_+3A_lambda">lambda</code></td>
<td>
<p>A positive scalar, the scale factor for the generalized ridge
penalty (see Details). Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="fase_seq_+3A_optim_options">optim_options</code></td>
<td>
<p>A list, containing additional optional arguments controlling
the gradient descent algorithm.
</p>

<dl>
<dt>eps</dt><dd><p>A positive scalar, the convergence threshold for gradient
descent in terms of relative change in objective value.
Defaults to <code>1e-5</code>.</p>
</dd>
<dt>eta</dt><dd><p>A positive scalar, the step size for gradient descent.
Defaults to <code>1/(n*m)</code>.</p>
</dd>
<dt>K_max</dt><dd><p>A positive integer, the maximum iterations for gradient
descent. Defaults to <code>2e3</code>.</p>
</dd>
<dt>verbose</dt><dd><p>A Boolean, if <code>TRUE</code>, console output will provide
updates on the progress of gradient descent. Defaults to
<code>FALSE</code>.</p>
</dd>
<dt>init_W</dt><dd><p>A 3-dimensional array
containing initial basis coordinates for gradient descent. Dimension should be
<code class="reqn">n \times</code><code>spline_design$q</code><code class="reqn"> \times d</code> for <code class="reqn">B</code>-spline designs,
and <code class="reqn">n \times m \times d</code> for smoothing spline designs. If included,
<code>init_M</code>, <code>init_L</code> and <code>init_sigma</code> are ignored.</p>
</dd>
<dt>init_sigma</dt><dd><p>A positive scalar, the estimated edge dispersion parameter to calibrate
initialization. If not provided, it is either estimated using the robust method proposed by
Gavish and Donoho (2014) for weighted edge networks, or set to a default value <code>0.5</code>
for binary edge networks.</p>
</dd>
<dt>init_L</dt><dd><p>A positive integer, the number of contiguous groups used for initialization.
Defaults to the floor of <code class="reqn">(2nm/\texttt{init\_sigma}^2)^{1/3}</code>.</p>
</dd>
<dt>init_M</dt><dd><p>A positive integer, the number of snapshots averaged in each group for
initialization. Defaults use all snapshots.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fase_seq_+3A_output_options">output_options</code></td>
<td>
<p>A list, containing additional optional arguments controlling
the output of <code>fase</code>.
</p>

<dl>
<dt>return_coords</dt><dd><p>A Boolean, if <code>TRUE</code>, the basis coordinates for
each latent process component are also returned as an array.
Defaults to <code>FALSE</code>.</p>
</dd>
<dt>return_ngcv</dt><dd><p>A Boolean, if <code>TRUE</code> and <code>spline_design$type=='bs'</code>,
the network generalized cross validation criterion is returned.
Defaults to <code>TRUE</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>fase_seq</code> is a wrapper for <code>fase</code>. When <code class="reqn">d=1</code>,
<code>fase_seq</code> coincides with <code>fase</code>.
</p>
<p><code>fase_seq</code> finds a functional adjacency spectral embedding of an
<code class="reqn">n \times n \times m</code> array <code class="reqn">A</code> of
symmetric adjacency matrices on a common set of nodes, where
each <code class="reqn">n \times n</code> slice is associated to a scalar index <code class="reqn">x_k</code>
for <code class="reqn">k=1,...,m</code>.
Embedding requires the specification of a latent space dimension
<code class="reqn">d</code> and spline design information (with the argument
<code>spline_design</code>).
</p>
<p><code>fase_seq</code> can fit latent processes using either a cubic <code class="reqn">B</code>-spline
basis with
equally spaced knots, or a natural cubic spline basis with a second
derivative (generalized ridge) smoothing penalty: a smoothing spline.
To fit with a <code class="reqn">B</code>-spline design (<code>spline_design$type = 'bs'</code>),
one must minimally provide a basis
dimension <code class="reqn">q</code> of at least <code>4</code> and at most <code class="reqn">m</code>.
</p>
<p>When fitting with a smoothing spline design, the generalized ridge
penalty is scaled by
<code class="reqn">\lambda/n</code>, where <code class="reqn">\lambda</code> is specified by the argument <code>lambda</code>.
see <a href="https://arxiv.org/abs/2210.07491">MacDonald et al., (2022+)</a>,
Appendix E for more details.
<code>lambda</code> can also be used to introduce a ridge penalty on the
basis coordinates when fitting with <code class="reqn">B</code>-splines.
</p>
<p>Fitting minimizes a least squares loss,
using gradient descent (Algorithm 1) on the basis coordinates <code class="reqn">w_{i,r}</code>
of each component process
</p>
<p style="text-align: center;"><code class="reqn">z_{i,r}(x) = w_{i,r}^{T}B(x).</code>
</p>

<p>Additional options for the fitting algorithm, including initialization,
can be specified by the argument <code>optim_options</code>.
For more details on the fitting and initialization algorithms, see
<a href="https://arxiv.org/abs/2210.07491">MacDonald et al., (2022+)</a>,
Section 3.
</p>
<p>By default, <code>fase_seq</code> will return estimates of the latent processes
evaluated at the snapshot indices as an <code class="reqn">n \times d \times m</code> array, after
performing a Procrustes alignment of the consecutive snapshots.
This extra alignment step can be skipped.
<code>fase_seq</code> will also return the spline design information used to fit the
embedding, convergence information for gradient descent, and (if specified)
the basis coordinates.
</p>
<p>When fitting with <code class="reqn">B</code>-splines, <code>fase_seq</code> can return a
network generalized cross validation criterion, described in
<a href="https://arxiv.org/abs/2210.07491">MacDonald et al., (2022+)</a>,
Section 3.3. This criterion can be minimized to choose appropriate values
for <code class="reqn">q</code> and <code class="reqn">d</code>.
</p>


<h3>Value</h3>

<p>A list is returned with the functional adjacency spectral embedding,
the spline design information, and some additional optimization
output:
</p>
<table>
<tr><td><code>Z</code></td>
<td>
<p>An <code class="reqn">n \times d \times m</code> array containing the latent process embedding
evaluated at the indices in <code>spline_design$x_vec</code>.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>For <code class="reqn">B</code>-spline designs, an <code class="reqn">n \times q \times d</code> array; or for
smoothing spline designs, an <code class="reqn">n \times m \times d</code> array of estimated basis
coordinates. If <code>output_options$return_coords</code> is <code>FALSE</code>,
this is not returned.</p>
</td></tr>
<tr><td><code>spline_design</code></td>
<td>
<p>A list, describing the spline design:
</p>

<dl>
<dt>type</dt><dd><p>A string, either <code>'bs'</code> or <code>'ss'</code>.</p>
</dd>
<dt>q</dt><dd><p>A positive integer, the dimension of the <code class="reqn">B</code>-spline basis.
Only returned for <code class="reqn">B</code>-spline designs.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space.</p>
</dd>
<dt>spline_matrix</dt><dd><p>For <code class="reqn">B</code>-spline designs, an <code class="reqn">m \times q</code> matrix;
or for smoothing spline designs, an <code class="reqn">m \times m</code> matrix, the basis
evaluated at the snapshot indices.</p>
</dd>
<dt>ridge_matrix</dt><dd><p>An <code class="reqn">m \times m</code> matrix used in the generalized
ridge penalty. Only returned for <code>lambda &gt; 0</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>ngcv</code></td>
<td>
<p>A scalar, the network generalized cross validation criterion
(see Details). Only returned for <code class="reqn">B</code>-spline designs and when
<code>output_options$return_ngcv</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>A positive integer, the number of iterations run in
gradient descent.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>An integer convergence code, <code>1</code> if
gradient descent converged in fewer than <code>optim_options$K_max</code> iterations,
<code>0</code> otherwise.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian edge data with sinusoidal latent processes
set.seed(1)
data &lt;- gaussian_snapshot_ss(n=50,d=2,
                             x_vec=seq(0,1,length.out=50),
                             self_loops=FALSE,sigma_edge=4)


# fase fit with B-spline design
fit_bs &lt;- fase_seq(data$A,d=2,self_loops=FALSE,
                   spline_design=list(type='bs',q=9,x_vec=data$spline_design$x_vec),
                   optim_options=list(eps=1e-4,K_max=40),
                   output_options=list(return_coords=TRUE))

# fase fit with smoothing spline design
fit_ss &lt;- fase_seq(data$A,d=2,self_loops=FALSE,
                   spline_design=list(type='ss',x_vec=data$spline_design$x_vec),
                   lambda=.5,
                   optim_options=list(eta=1e-4,K_max=40,verbose=FALSE))

#NOTE: both models fit with small optim_options$K_max=40 for demonstration

</code></pre>

<hr>
<h2 id='gaussian_snapshot_bs'>Simulate Gaussian edge networks with B-spline latent processes</h2><span id='topic+gaussian_snapshot_bs'></span>

<h3>Description</h3>

<p><code>gaussian_snapshot_bs</code> simulates a realization of a functional network
with Gaussian edges, according to an inner product latent process model.
The latent processes are generated from a <code class="reqn">B</code>-spline basis with equally
spaced knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_snapshot_bs(n,d,m,self_loops=TRUE,
                     spline_design,sigma_edge=1,
                     process_options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_snapshot_bs_+3A_n">n</code></td>
<td>
<p>A positive integer, the number of nodes.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_bs_+3A_d">d</code></td>
<td>
<p>A positive integer, the number of latent space dimensions.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_bs_+3A_m">m</code></td>
<td>
<p>A positive integer, the number of snapshots.
If this argument is not specified, it
is determined from the snapshot index vector <code>spline_design$x_vec</code>.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_bs_+3A_self_loops">self_loops</code></td>
<td>
<p>A Boolean, if <code>FALSE</code>, all diagonal adjacency matrix
entries are set to zero. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_bs_+3A_spline_design">spline_design</code></td>
<td>
<p>A list, describing the <code class="reqn">B</code>-spline design:
</p>

<dl>
<dt>q</dt><dd><p>A positive integer, the dimension of the <code class="reqn">B</code>-spline basis.
Must be at least <code>4</code> and at most <code>m</code>.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.
Defaults to an equally spaced sequence of length
<code>m</code> from <code>0</code> to <code>1</code>.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space.
Defaults to <code>max(spline_design$x_vec)</code>.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space.
Defaults to <code>min(spline_design$x_vec)</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="gaussian_snapshot_bs_+3A_sigma_edge">sigma_edge</code></td>
<td>
<p>A positive scalar,
the entry-wise standard deviation for the Gaussian edge variables.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_bs_+3A_process_options">process_options</code></td>
<td>
<p>A list, containing additional optional arguments:
</p>

<dl>
<dt>sigma_coord</dt><dd><p>A positive scalar, or a vector of length <code class="reqn">d</code>.
If it is a vector, the entries correspond to the standard deviation
of the randomly generated basis coordinates for each latent dimension.
If is is a scalar, it corresponds to the standard deviation of the
basis coordinates in all dimensions. Defaults to <code>1</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The spline design of the functional network data (snapshot indices,
basis dimension) is generated using the information provided in
<code>spline_design</code>, producing a <code class="reqn">q</code>-dimensional cubic
<code class="reqn">B</code>-spline basis with equally spaced knots.
</p>
<p>The latent process basis coordinates are generated as iid
Gaussian random variables with standard deviation
<code>process_options$sigma_coord</code>. Each latent process is given by
</p>
<p style="text-align: center;"><code class="reqn">z_{i,r}(x) = w_{i,r}^{T}B(x).</code>
</p>

<p>Then, the <code class="reqn">n \times n</code> symmetric adjacency matrix for
snapshot <code class="reqn">k=1,...,m</code> has independent Gaussian entries
with standard deviation <code>sigma_edge</code> and mean
</p>
<p style="text-align: center;"><code class="reqn">E([A_k]_{ij}) = z_i(x_k)^{T}z_j(x_k)</code>
</p>

<p>for <code class="reqn">i \leq j</code> (or <code class="reqn">i &lt; j</code> with no self loops).
</p>


<h3>Value</h3>

<p>A list is returned with the realizations of the basis coordinates,
spline design, and the multiplex network snapshots:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>An array of dimension <code class="reqn">n \times n \times m</code>, the realized
functional network data.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>An array of dimension <code class="reqn">n \times q \times d</code>,
the realized basis coordinates.</p>
</td></tr>
<tr><td><code>spline_design</code></td>
<td>
<p>A list, describing the <code class="reqn">B</code>-spline design:
</p>

<dl>
<dt>type</dt><dd><p>The string <code>'bs'</code>.</p>
</dd>
<dt>q</dt><dd><p>A positive integer, the dimension of the <code class="reqn">B</code>-spline basis.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space.</p>
</dd>
<dt>spline_matrix</dt><dd><p>An <code class="reqn">m \times q</code> matrix, the B-spline basis
evaluated at the snapshot indices.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Gaussian edge data with B-spline latent processes, Gaussian coordinates
# NOTE: x_vec is automatically populated given m

data &lt;- gaussian_snapshot_bs(n=100,d=4,m=100,
                             self_loops=FALSE,
                             spline_design=list(q=12),
                             sigma_edge=3,
                             process_options=list(sigma_coord=.75))

</code></pre>

<hr>
<h2 id='gaussian_snapshot_ss'>Simulate Gaussian edge networks with nonparametric latent processes</h2><span id='topic+gaussian_snapshot_ss'></span>

<h3>Description</h3>

<p><code>gaussian_snapshot_ss</code> simulates a realization of a functional network
with Gaussian edges, according to an inner product latent process model.
The latent processes are randomly generated sinusoidal functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_snapshot_ss(n,d,m,x_vec,self_loops=TRUE,
                     sigma_edge=1,process_options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_snapshot_ss_+3A_n">n</code></td>
<td>
<p>A positive integer, the number of nodes.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_ss_+3A_d">d</code></td>
<td>
<p>A positive integer, the number of latent space dimensions.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_ss_+3A_m">m</code></td>
<td>
<p>A positive integer, the number of snapshots.
If this argument is not specified, it
is determined from the snapshot index vector <code>x_vec</code>.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_ss_+3A_x_vec">x_vec</code></td>
<td>
<p>A vector, the snapshot evaluation indices for the data.
Defaults to an equally spaced sequence of length
<code>m</code> from <code>0</code> to <code>1</code>.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_ss_+3A_self_loops">self_loops</code></td>
<td>
<p>A Boolean, if <code>FALSE</code>, all diagonal adjacency matrix
entries are set to zero. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_ss_+3A_sigma_edge">sigma_edge</code></td>
<td>
<p>A positive scalar,
the entry-wise standard deviation for the Gaussian edge variables.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="gaussian_snapshot_ss_+3A_process_options">process_options</code></td>
<td>
<p>A list, containing additional optional arguments:
</p>

<dl>
<dt>amplitude</dt><dd><p>A positive scalar, the maximum amplitude of the
randomly generated latent processes. Defaults to <code>3</code>.</p>
</dd>
<dt>frequency</dt><dd><p>A positive scalar, frequency of the randomly
generated latent processes. Defaults to <code>2</code>.</p>
</dd>
<dt>sigma_int</dt><dd><p>A positive scalar, or a vector of length <code class="reqn">d</code>.
If it is a vector, the entries correspond to the standard deviation
of the random intercepts of the node processes for each latent dimension.
If is is a scalar, it corresponds to the standard deviation of the
random intercepts in all dimensions. Defaults to <code>0.5</code>.</p>
</dd>
<dt>return_fn</dt><dd><p>A Boolean, if <code>TRUE</code>, then the latent processes
are returned as a function which
takes a vector of indices and returns the corresponding evaluations of
the latent process matrices. Otherwise, the latent processes are returned
as an <code class="reqn">n \times d \times m</code> array evaluated at the prespecified
snapshot indices. Defaults to <code>FALSE</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The the latent process for node <code class="reqn">i</code> in latent dimension <code class="reqn">r</code> is given independently by
</p>
<p style="text-align: center;"><code class="reqn">z_{i,r}(x) = \frac{a \sin [2f\pi(x - U) / (x_{max} - x_{min})]}{1 + (2a-1)[x + B(x_{max} - 2x)]} + G</code>
</p>

<p>Where <code class="reqn">G</code> is Gaussian with mean <code>0</code> and standard deviation
<code class="reqn">\sigma_{int,r}</code>, <code class="reqn">B</code> is Bernoulli with mean <code>1/2</code>, and <code class="reqn">U</code> is uniform
with minimum <code>spline_design$x_min</code> and maximum <code>spline_design$x_max</code>.
<code class="reqn">f</code> is a frequency parameter specified with
<code>process_options$frequency</code>, and <code class="reqn">a</code> is a maximum amplitude parameter
specified with <code>process_options$amplitude</code>.
Roughly, each process is a randomly shifted sine function which goes through
<code>f</code> cycles on the index set, with amplitude either increasing or
decreasing between <code class="reqn">1/2</code> and <code class="reqn">a</code>.
</p>
<p>Then, the <code class="reqn">n \times n</code> symmetric adjacency matrix for
snapshot <code class="reqn">k=1,...,m</code> has independent Gaussian entries
with standard deviation <code>sigma_edge</code> and mean
</p>
<p style="text-align: center;"><code class="reqn">E([A_k]_{ij}) = z_i(x_k)^{T}z_j(x_k)</code>
</p>

<p>for <code class="reqn">i \leq j</code> (or <code class="reqn">i &lt; j</code> with no self loops).
</p>
<p>This function may return the latent processes as an <code class="reqn">n \times d \times m</code>
array evaluated at the prespecified snapshot indices, or as a function which
takes a vector of indices and returns the corresponding evaluations of
the latent process matrices.
It also returns the spline design information required to
fit a FASE embedding to this data with a natural cubic spline.
</p>


<h3>Value</h3>

<p>A list is returned with the realizations of the basis coordinates,
spline design, and the multiplex network snapshots:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>An array of dimension <code class="reqn">n \times n \times m</code>, the realized
functional network data.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>If <code>process_options$return_fn</code> is <code>TRUE</code>, a function,
which takes a vector of indices and returns the corresponding evaluations of
the latent process matrices. Otherwise, an array of dimension <code class="reqn">n \times d \times m</code>,
the latent processes evaluated at the prespecified
snapshot indices.</p>
</td></tr>
<tr><td><code>spline_design</code></td>
<td>
<p>A list, describing the <code class="reqn">B</code>-spline design:
</p>

<dl>
<dt>type</dt><dd><p>The string <code>'ss'</code>.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Gaussian edge data with sinusoidal latent processes
# NOTE: latent processes are returned as a function

data &lt;- gaussian_snapshot_ss(n=100,d=2,
                             x_vec=seq(0,3,length.out=80),
                             self_loops=TRUE,
                             sigma_edge=4,
                             process_options=list(amplitude=4,
                                                  frequency=3,
                                                  return_fn=TRUE))

</code></pre>

<hr>
<h2 id='proc_align'>Procrustes alignment</h2><span id='topic+proc_align'></span>

<h3>Description</h3>

<p><code>proc_align</code> orthogonally transforms the columns of a matrix <code class="reqn">A</code> to
find the best approximation (in terms of Frobenius norm) to a
second matrix <code class="reqn">B</code>. Optionally, it may also return the optimal transformation
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc_align(A,B,return_orth=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proc_align_+3A_a">A</code></td>
<td>
<p>An <code class="reqn">n \times d</code> matrix.</p>
</td></tr>
<tr><td><code id="proc_align_+3A_b">B</code></td>
<td>
<p>An <code class="reqn">n \times d</code> matrix.</p>
</td></tr>
<tr><td><code id="proc_align_+3A_return_orth">return_orth</code></td>
<td>
<p>A Boolean which specifies whether to return the
orthogonal transformation.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_orth</code> is <code>FALSE</code>, returns the <code class="reqn">n \times d</code>
matrix resulting from applying the optimal aligning transformation to
the columns of <code>A</code>.
Otherwise, returns a list with two entries:
</p>
<table>
<tr><td><code>Ao</code></td>
<td>
<p>The <code class="reqn">n \times d</code>
matrix resulting from applying the optimal aligning transformation to the
columns of <code>A</code>.</p>
</td></tr>
<tr><td><code>orth</code></td>
<td>
<p>The <code class="reqn">d \times d</code> optimal aligning orthogonal transformation
matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='proc_align_slicewise3'>Slicewise Procrustes alignment for 3-mode tensors</h2><span id='topic+proc_align_slicewise3'></span>

<h3>Description</h3>

<p><code>proc_align_slicewise3</code> applies an orthogonal transformation
to the columns of each of the <code class="reqn">n \times d</code> slices of an
<code class="reqn">n \times d \times m</code> array <code class="reqn">A</code> to
find the best approximation (in terms of matrix Frobenius norm) to
the corresponding <code class="reqn">n \times d</code> slice of a
second <code class="reqn">n \times d \times m</code> array <code class="reqn">B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc_align_slicewise3(A,B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proc_align_slicewise3_+3A_a">A</code></td>
<td>
<p>An <code class="reqn">n \times d \times m</code> array.</p>
</td></tr>
<tr><td><code id="proc_align_slicewise3_+3A_b">B</code></td>
<td>
<p>An <code class="reqn">n \times d \times m</code> array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">n \times d \times m</code>
array resulting from applying the optimal aligning transformations to
the columns of the <code class="reqn">n \times d</code> slices of <code>A</code>.
</p>

<hr>
<h2 id='proc_align3'>Procrustes alignment for 3-mode tensors</h2><span id='topic+proc_align3'></span>

<h3>Description</h3>

<p><code>proc_align3</code> applies one orthogonal transformation
to the columns of each of the <code class="reqn">n \times d</code> slices of an
<code class="reqn">n \times d \times m</code> array <code class="reqn">A</code> to
find the best approximation (in terms of matrix Frobenius norm, averaged
over the  <code class="reqn">n \times d</code> slices) to a
second <code class="reqn">n \times d \times m</code> array <code class="reqn">B</code>.
Optionally, it may also return the optimal transformation
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc_align3(A,B,return_orth=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proc_align3_+3A_a">A</code></td>
<td>
<p>An <code class="reqn">n \times d \times m</code> array.</p>
</td></tr>
<tr><td><code id="proc_align3_+3A_b">B</code></td>
<td>
<p>An <code class="reqn">n \times d \times m</code> array.</p>
</td></tr>
<tr><td><code id="proc_align3_+3A_return_orth">return_orth</code></td>
<td>
<p>A Boolean which specifies whether to return the
orthogonal transformation.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_orth</code> is <code>FALSE</code>, returns the <code class="reqn">n \times d \times m</code>
array resulting from applying the optimal aligning transformation to
the columns of the <code class="reqn">n \times d</code> slices of <code>A</code>.
Otherwise, returns a list with two entries:
</p>
<table>
<tr><td><code>Ao</code></td>
<td>
<p>The <code class="reqn">n \times d</code>
matrix resulting from applying the optimal aligning transformation to the
columns of the <code class="reqn">n \times d</code> slices of <code>A</code>.</p>
</td></tr>
<tr><td><code>orth</code></td>
<td>
<p>The <code class="reqn">d \times d</code> optimal aligning orthogonal transformation matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='rdpg_snapshot_bs'>Simulate binary edge networks with B-spline latent processes</h2><span id='topic+rdpg_snapshot_bs'></span>

<h3>Description</h3>

<p><code>rdpg_snapshot_bs</code> simulates a realization of a functional network
with Bernoulli edges, according to an inner product latent process model.
The latent processes are generated from a <code class="reqn">B</code>-spline basis with equally
spaced knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdpg_snapshot_bs(n,d,m,self_loops=TRUE,
                 spline_design,process_options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdpg_snapshot_bs_+3A_n">n</code></td>
<td>
<p>A positive integer, the number of nodes.</p>
</td></tr>
<tr><td><code id="rdpg_snapshot_bs_+3A_d">d</code></td>
<td>
<p>A positive integer, the number of latent space dimensions.</p>
</td></tr>
<tr><td><code id="rdpg_snapshot_bs_+3A_m">m</code></td>
<td>
<p>A positive integer, the number of snapshots.
If this argument is not specified, it
is determined from the snapshot index vector <code>spline_design$x_vec</code>.</p>
</td></tr>
<tr><td><code id="rdpg_snapshot_bs_+3A_self_loops">self_loops</code></td>
<td>
<p>A Boolean, if <code>FALSE</code>, all diagonal adjacency matrix
entries are set to zero. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rdpg_snapshot_bs_+3A_spline_design">spline_design</code></td>
<td>
<p>A list, describing the <code class="reqn">B</code>-spline design:
</p>

<dl>
<dt>q</dt><dd><p>A positive integer, the dimension of the <code class="reqn">B</code>-spline basis.
Must be at least <code>4</code> and at most <code>m</code>.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.
Defaults to an equally spaced sequence of length
<code>m</code> from <code>0</code> to <code>1</code>.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space.
Defaults to <code>max(spline_design$x_vec)</code>.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space.
Defaults to <code>min(spline_design$x_vec)</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="rdpg_snapshot_bs_+3A_process_options">process_options</code></td>
<td>
<p>A list, containing additional optional arguments:
</p>

<dl>
<dt>alpha_coord</dt><dd><p>A positive scalar, or a vector of length <code class="reqn">d</code>.
If it is a vector, it corresponds to the Dirichlet parameter of the
basis coordinates.
If is is a scalar, the basis coordinates have Dirichlet parameter
<code>rep(alpha_coord,d)</code>. Defaults to <code>0.1</code>.</p>
</dd>
<dt>density</dt><dd><p>A scalar between <code>0</code> and <code>1</code>, which controls the
approximate overall edge density of the resulting multiplex matrix.
Defaults to <code>1/d</code>. If specified larger than <code>1/d</code>, this
argument is reset to <code>1/d</code> and a warning is given.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The spline design of the functional network data (snapshot indices,
basis dimension) is generated using the information provided in
<code>spline_design</code>, producing a <code class="reqn">q</code>-dimensional cubic
<code class="reqn">B</code>-spline basis with equally spaced knots.
</p>
<p>The (<code class="reqn">q \times d</code>) latent process basis coordinates <code class="reqn">W_i</code>
for each node are generated as <code class="reqn">q</code> iid Dirichlet
random variables with <code class="reqn">d</code>-dimensional parameter
<code>process_options$alpha_coord</code> or
<code>rep(process_options$alpha_coord,d)</code> depending on the dimension
of <code>process_options$alpha_coord</code>.
Roughly, smaller values of <code>process_options$alpha_coord</code> will
tend to generate latent positions closer to the corners of the simplex.
</p>
<p><code class="reqn">W_i</code> is then rescaled so the overall network density is approximately
<code>process_options$density</code>, and the Euclidean norm of <code class="reqn">z_i(x)</code>
never exceeds <code>1</code>.
If the density requested is too high, it will revert to the maximum density
under this model (<code class="reqn">1/d</code>).
Then each latent process is given by
</p>
<p style="text-align: center;"><code class="reqn">z_{i}(x) = W_i^{T}B(x).</code>
</p>

<p>The <code class="reqn">n \times n</code> symmetric adjacency matrix for
snapshot <code class="reqn">k=1,...,m</code> has independent Bernoulli entries
with mean
</p>
<p style="text-align: center;"><code class="reqn">E([A_k]_{ij}) = z_i(x_k)^{T}z_j(x_k)</code>
</p>

<p>for <code class="reqn">i \leq j</code> (or <code class="reqn">i &lt; j</code> with no self loops).
</p>


<h3>Value</h3>

<p>A list is returned with the realizations of the basis coordinates,
spline design, and the multiplex network snapshots:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>An array of dimension <code class="reqn">n \times n \times m</code>, the realized
functional network data.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>An array of dimension <code class="reqn">n \times q \times d</code>,
the realized basis coordinates.</p>
</td></tr>
<tr><td><code>spline_design</code></td>
<td>
<p>A list, describing the <code class="reqn">B</code>-spline design:
</p>

<dl>
<dt>type</dt><dd><p>The string <code>'bs'</code>.</p>
</dd>
<dt>q</dt><dd><p>A positive integer, the dimension of the <code class="reqn">B</code>-spline basis.</p>
</dd>
<dt>x_vec</dt><dd><p>A vector, the snapshot evaluation indices for the data.</p>
</dd>
<dt>x_max</dt><dd><p>A scalar, the maximum of the index space.</p>
</dd>
<dt>x_min</dt><dd><p>A scalar, the minimum of the index space.</p>
</dd>
<dt>spline_matrix</dt><dd><p>An <code class="reqn">m \times q</code> matrix, the B-spline basis
evaluated at the snapshot indices.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Bernoulli edge data with B-spline latent processes, Dirichlet coordinates
# NOTE: for B-splines, x_max and x_min do not need to coincide with the
# max and min snapshot times.

data &lt;- rdpg_snapshot_bs(n=100,d=10,
                         self_loops=FALSE,
                         spline_design=list(q=8,
                                            x_vec=seq(-1,1,length.out=50),
                                            x_min=-1.1,x_max=1.1),
                         process_options=list(alpha_coord=.2,
                         density=1/10))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
