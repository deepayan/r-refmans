<!DOCTYPE html><html><head><title>Help for package LTFHPlus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LTFHPlus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LTFHPlus-package'><p>LTFHPlus: Implementation of LT-FH++</p></a></li>
<li><a href='#construct_covmat'><p>Constructing a covariance matrix for a variable number of</p>
phenotypes</a></li>
<li><a href='#construct_covmat_multi'><p>Constructing a covariance matrix for multiple phenotypes</p></a></li>
<li><a href='#construct_covmat_single'><p>Constructing a covariance matrix for a single phenotype</p></a></li>
<li><a href='#convert_age_to_cir'><p>Convert age to cumulative incidence rate</p></a></li>
<li><a href='#convert_age_to_thresh'><p>Convert age to threshold</p></a></li>
<li><a href='#convert_cir_to_age'><p>Convert cumulative incidence rate to age</p></a></li>
<li><a href='#convert_format'><p>Attempts to convert the list entry input format to a long format</p></a></li>
<li><a href='#convert_liability_to_aoo'><p>Convert liability to age of onset</p></a></li>
<li><a href='#convert_observed_to_liability_scale'><p>Convert the heritability on the observed scale to that on the liability scale</p></a></li>
<li><a href='#correct_positive_definite'><p>Positive definite matrices</p></a></li>
<li><a href='#estimate_gen_liability_ltfh'><p>Estimate genetic liability similar to LT-FH</p></a></li>
<li><a href='#estimate_liability'><p>Estimating the genetic or full liability for a variable number of</p>
phenotypes</a></li>
<li><a href='#estimate_liability_multi'><p>Estimating the genetic or full liability for multiple phenotypes</p></a></li>
<li><a href='#estimate_liability_single'><p>Estimating the genetic or full liability</p></a></li>
<li><a href='#get_all_combs'><p>construct all combinations of input vector</p></a></li>
<li><a href='#get_kinship'><p>Construct kinship matrix from graph</p></a></li>
<li><a href='#get_relatedness'><p>Relatedness between a pair of family members</p></a></li>
<li><a href='#graph_based_covariance_construction'><p>Constructing covariance matrix from local family graph</p></a></li>
<li><a href='#graph_based_covariance_construction_multi'><p>Constructing covariance matrix from local family graph for multi trait analysis</p></a></li>
<li><a href='#prepare_graph'><p>Construct graph from register information</p></a></li>
<li><a href='#prepare_LTFHPlus_input'><p>Prepares input for <code>estimate_liability</code></p></a></li>
<li><a href='#rtmvnorm.gibbs'><p>Gibbs Sampler for the truncated multivariate normal distribution</p></a></li>
<li><a href='#simulate_under_LTM'><p>Simulate under the liability threshold model.</p></a></li>
<li><a href='#simulate_under_LTM_multi'><p>Simulate under the liability threshold model (multiple phenotypes).</p></a></li>
<li><a href='#simulate_under_LTM_single'><p>Simulate under the liability threshold model (single phenotype).</p></a></li>
<li><a href='#truncated_normal_cdf'><p>CDF for truncated normal distribution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Implementation of LT-FH++</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of LT-FH++, an extension of
    the liability threshold family history (LT-FH) model.
    LT-FH++ uses a Gibbs sampler for sampling from the truncated 
    multivariate normal distribution and allows for 
    flexible family structures. LT-FH++ was first described in 
    Pedersen, Emil M., et al. (2022) 
    <a href="https://pure.au.dk/ws/portalfiles/portal/353346245/">https://pure.au.dk/ws/portalfiles/portal/353346245/</a> 
    as an extension to LT-FH with more flexible family structures, 
    and again as the age-dependent liability threshold (ADuLT) model
    Pedersen, Emil M., et al. (2023) 
    <a href="https://www.nature.com/articles/s41467-023-41210-z">https://www.nature.com/articles/s41467-023-41210-z</a> 
    as an alternative to traditional time-to-event genome-wide
    association studies, where family history was not considered.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>batchmeans, dplyr, future.apply, future, purrr, Rcpp, rlang,
stats, stringr, tibble, tmvtnorm, tidyselect, igraph, xgboost,
tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>"en-GB"</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/EmilMiP/LTFHPlus">https://github.com/EmilMiP/LTFHPlus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EmilMiP/LTFHPlus/issues">https://github.com/EmilMiP/LTFHPlus/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 09:39:32 UTC; au610027</td>
</tr>
<tr>
<td>Author:</td>
<td>Emil Michael Pedersen [aut, cre],
  Florian Privé [aut, ths],
  Bjarni Jóhann Vilhjálmsson [ths],
  Esben Agerbo [ths],
  Jette Steinbach [aut],
  Lucas Rasmussen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emil Michael Pedersen &lt;emp@ph.au.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 16:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='LTFHPlus-package'>LTFHPlus: Implementation of LT-FH++</h2><span id='topic+LTFHPlus'></span><span id='topic+LTFHPlus-package'></span>

<h3>Description</h3>

<p>Implementation of LT-FH++, an extension of the liability threshold family history (LT-FH) model. LT-FH++ uses a Gibbs sampler for sampling from the truncated multivariate normal distribution and allows for flexible family structures. LT-FH++ was first described in Pedersen, Emil M., et al. (2022) <a href="https://pure.au.dk/ws/portalfiles/portal/353346245/">https://pure.au.dk/ws/portalfiles/portal/353346245/</a> as an extension to LT-FH with more flexible family structures, and again as the age-dependent liability threshold (ADuLT) model Pedersen, Emil M., et al. (2023) <a href="https://www.nature.com/articles/s41467-023-41210-z">https://www.nature.com/articles/s41467-023-41210-z</a> as an alternative to traditional time-to-event genome-wide association studies, where family history was not considered.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emil Michael Pedersen <a href="mailto:emp@ph.au.dk">emp@ph.au.dk</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Florian Privé <a href="mailto:florian.prive.21@gmail.com">florian.prive.21@gmail.com</a> [thesis advisor]
</p>
</li>
<li><p> Jette Steinbach <a href="mailto:jst@econ.au.dk">jst@econ.au.dk</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Bjarni Jóhann Vilhjálmsson <a href="mailto:bjv@econ.au.dk">bjv@econ.au.dk</a> [thesis advisor]
</p>
</li>
<li><p> Esben Agerbo <a href="mailto:ea@econ.au.dk">ea@econ.au.dk</a> [thesis advisor]
</p>
</li>
<li><p> Lucas Rasmussen <a href="mailto:lar.ncrr@au.dk">lar.ncrr@au.dk</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/EmilMiP/LTFHPlus">https://github.com/EmilMiP/LTFHPlus</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/EmilMiP/LTFHPlus/issues">https://github.com/EmilMiP/LTFHPlus/issues</a>
</p>
</li></ul>


<hr>
<h2 id='construct_covmat'>Constructing a covariance matrix for a variable number of
phenotypes</h2><span id='topic+construct_covmat'></span>

<h3>Description</h3>

<p><code>construct_covmat</code> returns the covariance matrix for an
underlying target individual and a variable number of its family members
for a variable number of phenotypes. It is a wrapper around
<code><a href="#topic+construct_covmat_single">construct_covmat_single</a></code> and <code><a href="#topic+construct_covmat_multi">construct_covmat_multi</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_covmat(
  fam_vec = c("m", "f", "s1", "mgm", "mgf", "pgm", "pgf"),
  n_fam = NULL,
  add_ind = TRUE,
  h2 = 0.5,
  genetic_corrmat = NULL,
  full_corrmat = NULL,
  phen_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_covmat_+3A_fam_vec">fam_vec</code></td>
<td>
<p>A vector of strings holding the different
family members. All family members must be represented by strings from the
following list:
</p>

<ul>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to c(&quot;m&quot;,&quot;f&quot;,&quot;s1&quot;,&quot;mgm&quot;,&quot;mgf&quot;,&quot;pgm&quot;,&quot;pgf&quot;).
</p>
</li></ul>
</td></tr>
<tr><td><code id="construct_covmat_+3A_n_fam">n_fam</code></td>
<td>
<p>A named vector holding the desired number of family members.
See <code><a href="stats.html#topic+setNames">setNames</a></code>.
All names must be picked from the list mentioned above. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="construct_covmat_+3A_add_ind">add_ind</code></td>
<td>
<p>A logical scalar indicating whether the genetic
component of the full liability as well as the full
liability for the underlying individual should be included in
the covariance matrix. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="construct_covmat_+3A_h2">h2</code></td>
<td>
<p>Either a number representing the heritability
on liability scale for one single phenotype or a numeric vector representing
the liability-scale heritabilities for a positive number of phenotypes.
All entries in h2 must be non-negative and at most 1.</p>
</td></tr>
<tr><td><code id="construct_covmat_+3A_genetic_corrmat">genetic_corrmat</code></td>
<td>
<p>Either <code>NULL</code> or a numeric matrix holding the genetic correlations between the desired
phenotypes. All diagonal entries must be equal to one, while all off-diagonal entries
must be between -1 and 1. In addition, the matrix must be symmetric.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="construct_covmat_+3A_full_corrmat">full_corrmat</code></td>
<td>
<p>Either <code>NULL</code> or a  numeric matrix holding the full correlations between the desired
phenotypes. All diagonal entries must be equal to one, while all off-diagonal entries
must be between -1 and 1. In addition, the matrix must be symmetric.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="construct_covmat_+3A_phen_names">phen_names</code></td>
<td>
<p>Either <code>NULL</code> or a character vector holding the phenotype names. These names
will be used to create the row and column names for the covariance matrix.
If it is not specified, the names will default to phenotype1, phenotype2, etc.
Defaults to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to construct a covariance matrix for
a given number of family members. If <code>h2</code> is a number,
each entry in this covariance matrix equals the percentage
of shared DNA between the corresponding individuals times
the liability-scale heritability </p>
<p style="text-align: center;"><code class="reqn">h^2</code>
</p>
<p>. However, if <code>h2</code> is a numeric vector,
and genetic_corrmat and full_corrmat are two symmetric correlation matrices,
each entry equals either the percentage of shared DNA between the corresponding
individuals times the liability-scale heritability </p>
<p style="text-align: center;"><code class="reqn">h^2</code>
</p>
<p> or the
percentage of shared DNA between the corresponding individuals times
the correlation between the corresponding phenotypes. The family members
can be specified using one of two possible formats.
</p>


<h3>Value</h3>

<p>If either <code>fam_vec</code> or <code>n_fam</code> is used as the argument, if it is of
the required format, if <code>add_ind</code> is a logical scalar and <code>h2</code> is a
number satisfying </p>
<p style="text-align: center;"><code class="reqn">0 \leq h2 \leq 1</code>
</p>
<p>, then the function <code>construct_covmat</code>
will return a named covariance matrix, which row- and column-number
corresponds to the length of <code>fam_vec</code> or <code>n_fam</code> (+ 2 if <code>add_ind=TRUE</code>).
However, if <code>h2</code> is a numeric vector satisfying
</p>
<p style="text-align: center;"><code class="reqn">0 \leq h2_i \leq 1</code>
</p>
<p> for all </p>
<p style="text-align: center;"><code class="reqn">i \in \{1,...,n_pheno\}</code>
</p>
<p> and if
<code>genetic_corrmat</code> and <code>full_corrmat</code> are two numeric and symmetric matrices
satisfying that all diagonal entries are one and that all off-diagonal
entries are between -1 and 1, then <code>construct_covmat</code> will return
a named covariance matrix, which number of rows and columns corresponds to the number
of phenotypes times the length of <code>fam_vec</code> or <code>n_fam</code> (+ 2 if <code>add_ind=TRUE</code>).
If both <code>fam_vec</code> and <code>n_fam</code> are equal to <code>c()</code> or <code>NULL</code>,
the function returns either a <code class="reqn">2 \times 2</code> matrix holding only the correlation
between the genetic component of the full liability and the full liability for the
individual under consideration, or a </p>
<p style="text-align: center;"><code class="reqn">(2 \times n_pheno) \times (2\times n_pheno)</code>
</p>

<p>matrix holding the correlation between the genetic component of the full
liability and the full liability for the underlying individual for all
phenotypes.
If both <code>fam_vec</code> and <code>n_fam</code> are specified, the user is asked to
decide on which of the two vectors to use.
Note that the returned object has different attributes, such as
<code>fam_vec</code>, <code>n_fam</code>, <code>add_ind</code> and <code>h2</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_relatedness">get_relatedness</a></code>, <code><a href="#topic+construct_covmat_single">construct_covmat_single</a></code>,
<code><a href="#topic+construct_covmat_multi">construct_covmat_multi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct_covmat()
construct_covmat(fam_vec = c("m","mgm","mgf","mhs1","mhs2","mau1"), 
                 n_fam = NULL, 
                 add_ind = TRUE, 
                 h2 = 0.5)
construct_covmat(fam_vec = NULL, 
                 n_fam = stats::setNames(c(1,1,1,2,2), c("m","mgm","mgf","s","mhs")), 
                 add_ind = FALSE,
                 h2 = 0.3)
construct_covmat(h2 = c(0.5,0.5), genetic_corrmat = matrix(c(1,0.4,0.4,1), nrow = 2),
                 full_corrmat = matrix(c(1,0.6,0.6,1), nrow = 2))

</code></pre>

<hr>
<h2 id='construct_covmat_multi'>Constructing a covariance matrix for multiple phenotypes</h2><span id='topic+construct_covmat_multi'></span>

<h3>Description</h3>

<p><code>construct_covmat_multi</code> returns the covariance matrix for an
underlying target individual and a variable number of its family members
for multiple phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_covmat_multi(
  fam_vec = c("m", "f", "s1", "mgm", "mgf", "pgm", "pgf"),
  n_fam = NULL,
  add_ind = TRUE,
  genetic_corrmat,
  full_corrmat,
  h2_vec,
  phen_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_covmat_multi_+3A_fam_vec">fam_vec</code></td>
<td>
<p>A vector of strings holding the different
family members. All family members must be represented by strings from the
following list:
</p>

<ul>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to c(&quot;m&quot;,&quot;f&quot;,&quot;s1&quot;,&quot;mgm&quot;,&quot;mgf&quot;,&quot;pgm&quot;,&quot;pgf&quot;).
</p>
</li></ul>
</td></tr>
<tr><td><code id="construct_covmat_multi_+3A_n_fam">n_fam</code></td>
<td>
<p>A named vector holding the desired number of family members.
See <code><a href="stats.html#topic+setNames">setNames</a></code>.
All names must be picked from the list mentioned above. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="construct_covmat_multi_+3A_add_ind">add_ind</code></td>
<td>
<p>A logical scalar indicating whether the genetic
component of the full liability as well as the full
liability for the underlying individual should be included in
the covariance matrix. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="construct_covmat_multi_+3A_genetic_corrmat">genetic_corrmat</code></td>
<td>
<p>A numeric matrix holding the genetic correlations between the desired
phenotypes. All diagonal entries must be equal to one, while all off-diagonal entries
must be between -1 and 1. In addition, the matrix must be symmetric.</p>
</td></tr>
<tr><td><code id="construct_covmat_multi_+3A_full_corrmat">full_corrmat</code></td>
<td>
<p>A numeric matrix holding the full correlations between the desired
phenotypes. All diagonal entries must be equal to one, while all off-diagonal entries
must be between -1 and 1. In addition, the matrix must be symmetric.</p>
</td></tr>
<tr><td><code id="construct_covmat_multi_+3A_h2_vec">h2_vec</code></td>
<td>
<p>A numeric vector representing the liability-scale heritabilities
for all phenotypes. All entries in h2_vec must be non-negative and at most 1.</p>
</td></tr>
<tr><td><code id="construct_covmat_multi_+3A_phen_names">phen_names</code></td>
<td>
<p>A character vector holding the phenotype names. These names
will be used to create the row and column names for the covariance matrix.
If it is not specified, the names will default to phenotype1, phenotype2, etc.
Defaults to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to construct a covariance matrix for
a given number of family members. Each entry in this covariance
matrix equals either the percentage of shared DNA between the corresponding
individuals times the liability-scale heritability <code class="reqn">h^2</code> or the
percentage of shared DNA between the corresponding individuals times
the correlation between the corresponding phenotypes.
That is, for the same phenotype, the covariance between all
combinations of the genetic component of the full liability
and the full liability is given by
</p>
<p style="text-align: center;"><code class="reqn">\text{Cov}\left( l_g, l_g \right) = h^2,</code>
</p>

<p style="text-align: center;"><code class="reqn">\text{Cov}\left( l_g, l_o \right) = h^2,</code>
</p>

<p style="text-align: center;"><code class="reqn">\text{Cov}\left( l_o, l_g \right) = h^2</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\text{Cov}\left( l_o, l_o \right) = 1.</code>
</p>

<p>For two different phenotypes, the covariance is given by
</p>
<p style="text-align: center;"><code class="reqn">\text{Cov}\left( l_g^1, l_g^2 \right) = \rho_g^{1,2},</code>
</p>

<p style="text-align: center;"><code class="reqn">\text{Cov}\left( l_g^1, l_o^2 \right) = \rho_g^{1,2},</code>
</p>

<p style="text-align: center;"><code class="reqn">\text{Cov}\left( l_o^1, l_g^2 \right) = \rho_g^{1,2}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\text{Cov}\left( l_o^1, l_o^2 \right) = \rho_g^{1,2} + \rho_e^{1,2},</code>
</p>

<p>where <code class="reqn">l_g^i</code> and <code class="reqn">l_o^i</code> are the genetic component
of the full liability and the full liability for phenotype <code class="reqn">i</code>,
respectively, <code class="reqn">\rho_g^{i,j}</code> is the genetic correlation between
phenotype <code class="reqn">i</code> and <code class="reqn">j</code> and <code class="reqn">\rho_e^{1,2}</code> is the
environmental correlation between phenotype <code class="reqn">i</code> and <code class="reqn">j</code>.
The family members can be specified using one of two possible formats.
</p>


<h3>Value</h3>

<p>If either <code>fam_vec</code> or <code>n_fam</code> is used as the argument and if it is of the
required format, if <code>genetic_corrmat</code> and <code>full_corrmat</code> are two numeric and symmetric matrices
satisfying that all diagonal entries are one and that all off-diagonal
entries are between -1 and 1, and if <code>h2_vec</code> is a numeric vector satisfying
<code class="reqn">0 \leq h2_i \leq 1</code> for all <code class="reqn">i \in \{1,...,n_pheno\}</code>,
then the output will be a named covariance matrix.
The number of rows and columns corresponds to the number of phenotypes times
the length of <code>fam_vec</code> or <code>n_fam</code> (+ 2 if <code>add_ind=TRUE</code>).
If both <code>fam_vec</code> and <code>n_fam</code> are equal to <code>c()</code> or <code>NULL</code>,
the function returns a <code class="reqn">(2 \times n_pheno) \times (2\times n_pheno)</code>
matrix holding only the correlation between the genetic component of the full
liability and the full liability for the underlying individual for all
phenotypes. If both <code>fam_vec</code> and <code>n_fam</code> are specified, the user is asked to
decide on which of the two vectors to use.
Note that the returned object has a number different attributes,namely
<code>fam_vec</code>, <code>n_fam</code>, <code>add_ind</code>, <code>genetic_corrmat</code>, <code>full_corrmat</code>,
<code>h2</code> and <code>phenotype_names</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_relatedness">get_relatedness</a></code>, <code><a href="#topic+construct_covmat_single">construct_covmat_single</a></code> and
<code><a href="#topic+construct_covmat">construct_covmat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct_covmat_multi(fam_vec = NULL, 
                       genetic_corrmat = matrix(c(1, 0.5, 0.5, 1), nrow = 2),
                       full_corrmat = matrix(c(1, 0.55, 0.55, 1), nrow = 2),
                       h2_vec = c(0.37,0.44),
                       phen_names = c("p1","p2"))
construct_covmat_multi(fam_vec = c("m","mgm","mgf","mhs1","mhs2","mau1"), 
                       n_fam = NULL, 
                       add_ind = TRUE,
                       genetic_corrmat = diag(3),
                       full_corrmat = diag(3),
                       h2_vec = c(0.8, 0.65))
construct_covmat_multi(fam_vec = NULL, 
                       n_fam = stats::setNames(c(1,1,1,2,2), c("m","mgm","mgf","s","mhs")), 
                       add_ind = FALSE,
                       genetic_corrmat = diag(2),
                       full_corrmat = diag(2),
                       h2_vec = c(0.75,0.85))

</code></pre>

<hr>
<h2 id='construct_covmat_single'>Constructing a covariance matrix for a single phenotype</h2><span id='topic+construct_covmat_single'></span>

<h3>Description</h3>

<p><code>construct_covmatc_single</code> returns the covariance matrix for an
underlying target individual and a variable number of its family members
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_covmat_single(
  fam_vec = c("m", "f", "s1", "mgm", "mgf", "pgm", "pgf"),
  n_fam = NULL,
  add_ind = TRUE,
  h2 = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_covmat_single_+3A_fam_vec">fam_vec</code></td>
<td>
<p>A vector of strings holding the different
family members. All family members must be represented by strings from the
following list:
</p>

<ul>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
</p>
</li></ul>
</td></tr>
<tr><td><code id="construct_covmat_single_+3A_n_fam">n_fam</code></td>
<td>
<p>A named vector holding the desired number of family members.
See <code><a href="stats.html#topic+setNames">setNames</a></code>.
All names must be picked from the list mentioned above. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="construct_covmat_single_+3A_add_ind">add_ind</code></td>
<td>
<p>A logical scalar indicating whether the genetic
component of the full liability as well as the full
liability for the underlying individual should be included in
the covariance matrix. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="construct_covmat_single_+3A_h2">h2</code></td>
<td>
<p>A number representing the squared heritability on liability scale
for a single phenotype. Must be non-negative and at most 1.
Defaults to 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to construct a covariance matrix for
a given number of family members. Each entry in this covariance
matrix equals the percentage of shared DNA between the corresponding
individuals times the liability-scale heritability <code class="reqn">h^2</code>. The family members
can be specified using one of two possible formats.
</p>


<h3>Value</h3>

<p>If either <code>fam_vec</code> or <code>n_fam</code> is used as the argument, if it
is of the required format and <code>h2</code> is a number satisfying
<code class="reqn">0 \leq h2 \leq 1</code>, then the output will be a named covariance matrix.
The number of rows and columns corresponds to the length of <code>fam_vec</code>
or <code>n_fam</code> (+ 2 if <code>add_ind=TRUE</code>).
If both <code>fam_vec = c()/NULL</code> and <code>n_fam = c()/NULL</code>, the
function returns a <code class="reqn">2 \times 2</code> matrix holding only the correlation
between the genetic component of the full liability and
the full liability for the individual. If both <code>fam_vec</code> and
<code>n_fam</code> are given, the user is asked to decide on which
of the two vectors to use.
Note that the returned object has different attributes, such as
<code>fam_vec</code>, <code>n_fam</code>, <code>add_ind</code> and <code>h2</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_relatedness">get_relatedness</a></code>, <code><a href="#topic+construct_covmat_multi">construct_covmat_multi</a></code>,
<code><a href="#topic+construct_covmat">construct_covmat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct_covmat_single()
construct_covmat_single(fam_vec = c("m","mgm","mgf","mhs1","mhs2","mau1"), 
n_fam = NULL, add_ind = TRUE, h2 = 0.5)
construct_covmat_single(fam_vec = NULL, n_fam = stats::setNames(c(1,1,1,2,2), 
c("m","mgm","mgf","s","mhs")), add_ind = FALSE, h2 = 0.3)

</code></pre>

<hr>
<h2 id='convert_age_to_cir'>Convert age to cumulative incidence rate</h2><span id='topic+convert_age_to_cir'></span>

<h3>Description</h3>

<p><code>convert_age_to_cir</code> computes the cumulative incidence
rate from a person's age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_age_to_cir(age, pop_prev = 0.1, mid_point = 60, slope = 1/8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_age_to_cir_+3A_age">age</code></td>
<td>
<p>A non-negative number representing the individual's age.</p>
</td></tr>
<tr><td><code id="convert_age_to_cir_+3A_pop_prev">pop_prev</code></td>
<td>
<p>A positive number representing the overall
population prevalence. Must be at most 1. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="convert_age_to_cir_+3A_mid_point">mid_point</code></td>
<td>
<p>A positive number representing the mid point
logistic function. Defaults to 60.</p>
</td></tr>
<tr><td><code id="convert_age_to_cir_+3A_slope">slope</code></td>
<td>
<p>A number holding the rate of increase.
Defaults to 1/8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a person's age, <code>convert_age_to_cir</code> can be used
to compute the cumulative incidence rate (cir), which is given
by the formula
</p>
<p style="text-align: center;"><code class="reqn">pop\_ prev / (1 + exp((mid\_ point - age) * slope))</code>
</p>



<h3>Value</h3>

<p>If age and mid_point are positive numbers, if pop_prev
is a positive number between 0 and 1 and if slope is a valid number,
then <code>convert_age_to_cir</code> returns a number, which is equal to
the cumulative incidence rate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(sapply(age, convert_age_to_cir), from = 10, to = 110, xname = "age")
</code></pre>

<hr>
<h2 id='convert_age_to_thresh'>Convert age to threshold</h2><span id='topic+convert_age_to_thresh'></span>

<h3>Description</h3>

<p><code>convert_age_to_thresh</code> computes the threshold
from a person's age using either the logistic function
or the truncated normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_age_to_thresh(
  age,
  dist = "logistic",
  pop_prev = 0.1,
  mid_point = 60,
  slope = 1/8,
  min_age = 10,
  max_age = 90,
  lower = stats::qnorm(0.05, lower.tail = FALSE),
  upper = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_age_to_thresh_+3A_age">age</code></td>
<td>
<p>A non-negative number representing the individual's age.</p>
</td></tr>
<tr><td><code id="convert_age_to_thresh_+3A_dist">dist</code></td>
<td>
<p>A string indicating which distribution to use.
If dist = &quot;logistic&quot;, the logistic function will be used to
compute the age of onset.
If dist = &quot;normal&quot;, the truncated normal distribution will be used instead.
Defaults to &quot;logistic&quot;.</p>
</td></tr>
<tr><td><code id="convert_age_to_thresh_+3A_pop_prev">pop_prev</code></td>
<td>
<p>Only necessary if dist = &quot;logistic&quot;. A positive number representing the overall
population prevalence. Must be at most 1. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="convert_age_to_thresh_+3A_mid_point">mid_point</code></td>
<td>
<p>Only necessary if dist = &quot;logistic&quot;. A positive number representing the mid point
logistic function. Defaults to 60.</p>
</td></tr>
<tr><td><code id="convert_age_to_thresh_+3A_slope">slope</code></td>
<td>
<p>Only necessary if dist = &quot;logistic&quot;. A number holding the rate of increase.
Defaults to 1/8.</p>
</td></tr>
<tr><td><code id="convert_age_to_thresh_+3A_min_age">min_age</code></td>
<td>
<p>Only necessary if dist = &quot;normal&quot;. A positive number representing the individual's earliest age.
Defaults to 10.</p>
</td></tr>
<tr><td><code id="convert_age_to_thresh_+3A_max_age">max_age</code></td>
<td>
<p>Only necessary if dist = &quot;normal&quot;. A positive number representing the individual's latest age.
Must be greater than min_aoo. Defaults to 90.</p>
</td></tr>
<tr><td><code id="convert_age_to_thresh_+3A_lower">lower</code></td>
<td>
<p>Only necessary if dist = &quot;normal&quot;. A number representing the lower cutoff point for the
truncated normal distribution. Defaults to 1.645
(stats::qnorm(0.05, lower.tail = FALSE)).</p>
</td></tr>
<tr><td><code id="convert_age_to_thresh_+3A_upper">upper</code></td>
<td>
<p>Only necessary if dist = &quot;normal&quot;. A number representing the upper cutoff point of the
truncated normal distribution. Must be greater or equal to lower.
Defaults to Inf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a person's age, <code>convert_age_to_thresh</code> can be used
to first compute the cumulative incidence rate (cir), which is
then used to compute the threshold using either the
logistic function or the truncated normal distribution.
Under the logistic function, the formula used to compute
the threshold from an individual's age is given by
</p>
<p style="text-align: center;"><code class="reqn">qnorm(pop\_ prev / (1 + exp((mid\_ point - age) * slope)), lower.tail = F)</code>
</p>
<p>,
while it is given by
</p>
<p style="text-align: center;"><code class="reqn">qnorm((1 - (age-min\_ age)/max\_ age) * (pnorm(upper) - pnorm(lower)) + pnorm(lower))</code>
</p>

<p>under the truncated normal distribution.
</p>


<h3>Value</h3>

<p>If age is a positive number and all other necessary arguments are valid,
then <code>convert_age_to_thresh</code> returns a number, which is equal to
the threshold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(sapply(age, convert_age_to_thresh), from = 10, to = 110, xname = "age")
</code></pre>

<hr>
<h2 id='convert_cir_to_age'>Convert cumulative incidence rate to age</h2><span id='topic+convert_cir_to_age'></span>

<h3>Description</h3>

<p><code>convert_cir_to_age</code> computes the age
from a person's cumulative incidence rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_cir_to_age(cir, pop_prev = 0.1, mid_point = 60, slope = 1/8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_cir_to_age_+3A_cir">cir</code></td>
<td>
<p>A positive number representing the individual's cumulative
incidence rate.</p>
</td></tr>
<tr><td><code id="convert_cir_to_age_+3A_pop_prev">pop_prev</code></td>
<td>
<p>A positive number representing the overall
population prevalence. Must be at most 1 and must be larger than
cir. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="convert_cir_to_age_+3A_mid_point">mid_point</code></td>
<td>
<p>A positive number representing the mid point
logistic function. Defaults to 60.</p>
</td></tr>
<tr><td><code id="convert_cir_to_age_+3A_slope">slope</code></td>
<td>
<p>A number holding the rate of increase.
Defaults to 1/8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a person's cumulative incidence rate (cir), <code>convert_cir_to_age</code>
can be used to compute the corresponding age, which is given by
</p>
<p style="text-align: center;"><code class="reqn">mid\_ point - \log(pop\_ prev/cir - 1) * 1/slope</code>
</p>



<h3>Value</h3>

<p>If cir and mid_point are positive numbers, if pop_prev
is a positive number between 0 and 1 and if slope is a valid number,
then <code>convert_cir_to_age</code> returns a number, which is equal to
the current age.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(sapply(cir, convert_cir_to_age), from = 0.001, to = 0.099, xname = "cir") 
</code></pre>

<hr>
<h2 id='convert_format'>Attempts to convert the list entry input format to a long format</h2><span id='topic+convert_format'></span>

<h3>Description</h3>

<p>Attempts to convert the list entry input format to a long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_format(family, threshs, personal_id_col = "pid", role_col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_format_+3A_family">family</code></td>
<td>
<p>a tibble with two entries, family id and personal id. personal id should end in &quot;_role&quot;, if a role column is not present.</p>
</td></tr>
<tr><td><code id="convert_format_+3A_threshs">threshs</code></td>
<td>
<p>thresholds, with a personal id (without role) as well as the lower and upper thresholds</p>
</td></tr>
<tr><td><code id="convert_format_+3A_personal_id_col">personal_id_col</code></td>
<td>
<p>column name that holds the personal id</p>
</td></tr>
<tr><td><code id="convert_format_+3A_role_col">role_col</code></td>
<td>
<p>column name that holds the role</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a format similar to <code>prepare_LTFHPlus_input</code>, which is used by <code>estimate_liability</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>family &lt;- data.frame(
fam_id = c(1, 1, 1, 1),
pid = c(1, 2, 3, 4),
role = c("o", "m", "f", "pgf")
)

threshs &lt;- data.frame(
  pid = c(1, 2, 3, 4),
  lower = c(-Inf, -Inf, 0.8, 0.7),
  upper = c(0.8, 0.8, 0.8, 0.7)
)

convert_format(family, threshs)

</code></pre>

<hr>
<h2 id='convert_liability_to_aoo'>Convert liability to age of onset</h2><span id='topic+convert_liability_to_aoo'></span>

<h3>Description</h3>

<p><code>convert_liability_to_aoo</code> computes the age
of onset from an individual's true underlying liability using
either the logistic function or the truncated normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_liability_to_aoo(
  liability,
  dist = "logistic",
  pop_prev = 0.1,
  mid_point = 60,
  slope = 1/8,
  min_aoo = 10,
  max_aoo = 90,
  lower = stats::qnorm(0.05, lower.tail = FALSE),
  upper = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_liability_to_aoo_+3A_liability">liability</code></td>
<td>
<p>A number representing the individual's
true underlying liability.</p>
</td></tr>
<tr><td><code id="convert_liability_to_aoo_+3A_dist">dist</code></td>
<td>
<p>A string indicating which distribution to use.
If dist = &quot;logistic&quot;, the logistic function will be used to
compute the age of onset.
If dist = &quot;normal&quot;, the truncated normal distribution will be used instead.
Defaults to &quot;logistic&quot;.</p>
</td></tr>
<tr><td><code id="convert_liability_to_aoo_+3A_pop_prev">pop_prev</code></td>
<td>
<p>Only necessary if dist = &quot;logistic&quot;. A positive number representing the overall
population prevalence. Must be at most 1. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="convert_liability_to_aoo_+3A_mid_point">mid_point</code></td>
<td>
<p>Only necessary if dist = &quot;logistic&quot;. A positive number representing the mid point
logistic function. Defaults to 60.</p>
</td></tr>
<tr><td><code id="convert_liability_to_aoo_+3A_slope">slope</code></td>
<td>
<p>Only necessary if dist = &quot;logistic&quot;. A number holding the rate of increase.
Defaults to 1/8.</p>
</td></tr>
<tr><td><code id="convert_liability_to_aoo_+3A_min_aoo">min_aoo</code></td>
<td>
<p>Only necessary if dist = &quot;normal&quot;. A positive number representing the individual's earliest age of onset.
Defaults to 10.</p>
</td></tr>
<tr><td><code id="convert_liability_to_aoo_+3A_max_aoo">max_aoo</code></td>
<td>
<p>Only necessary if dist = &quot;normal&quot;. A positive number representing the individual's latest age of onset.
Must be greater than min_aoo. Defaults to 90.</p>
</td></tr>
<tr><td><code id="convert_liability_to_aoo_+3A_lower">lower</code></td>
<td>
<p>Only necessary if dist = &quot;normal&quot;. A number representing the lower cutoff point for the
truncated normal distribution. Defaults to 1.645
(stats::qnorm(0.05, lower.tail = FALSE)).</p>
</td></tr>
<tr><td><code id="convert_liability_to_aoo_+3A_upper">upper</code></td>
<td>
<p>Only necessary if dist = &quot;normal&quot;. A number representing the upper cutoff point of the
truncated normal distribution. Must be greater or equal to lower.
Defaults to Inf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a person's cumulative incidence rate (cir), <code>convert_liability_to_aoo</code>
can be used to compute the corresponding age. Under the logistic function,
the age is given by
</p>
<p style="text-align: center;"><code class="reqn">mid\_ point - log(pop\_ prev/cir - 1) * 1/slope</code>
</p>
<p>,
while it is given by
</p>
<p style="text-align: center;"><code class="reqn">(1 - truncated\_ normal\_ cdf(liability = liability, lower = lower , upper = upper)) * max\_ aoo + min\_ aoo</code>
</p>

<p>under the truncated normal distribution.
</p>


<h3>Value</h3>

<p>If liability is a number and all other necessary arguments are valid,
then <code>convert_liability_to_aoo</code> returns a positive number, which is equal to
the age of onset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(sapply(liability, convert_liability_to_aoo), from = 1.3, to = 3.5, xname = "liability") 
curve(sapply(liability, convert_liability_to_aoo, dist = "normal"),
 from = qnorm(0.05, lower.tail = FALSE), to = 3.5, xname = "liability") 

</code></pre>

<hr>
<h2 id='convert_observed_to_liability_scale'>Convert the heritability on the observed scale to that on the liability scale</h2><span id='topic+convert_observed_to_liability_scale'></span>

<h3>Description</h3>

<p><code>convert_observed_to_liability_scale</code> transforms the heritability on the
observed scale to the heritability on the liability scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_observed_to_liability_scale(
  obs_h2 = 0.5,
  pop_prev = 0.05,
  prop_cases = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_observed_to_liability_scale_+3A_obs_h2">obs_h2</code></td>
<td>
<p>A number or numeric vector representing the liability-scale
heritability(ies)on the observed scale. Must be non-negative and at most 1.
Defaults to 0.5</p>
</td></tr>
<tr><td><code id="convert_observed_to_liability_scale_+3A_pop_prev">pop_prev</code></td>
<td>
<p>A number or numeric vector representing the population prevalence(s). All
entries must be non-negative and at most one.
If it is a vector, it must have the same length as obs_h2. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="convert_observed_to_liability_scale_+3A_prop_cases">prop_cases</code></td>
<td>
<p>Either NULL or a number or a numeric vector representing the proportion
of cases in the sample. All entries must be non-negative and at most one.
If it is a vector, it must have the same length as obs_h2. Defaults to 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to transform the heritability on the observed
scale to that on the liability scale. <code>convert_observed_to_liability_scale</code>
uses either Equation 17 (if prop_cases = NULL) or Equation 23 from
Sang Hong Lee, Naomi R. Wray, Michael E. Goddard and Peter M. Visscher, &quot;Estimating
Missing Heritability for Diseases from Genome-wide Association Studies&quot;,
The American Journal of Human Genetics, Volume 88, Issue 3, 2011, pp. 294-305,
<a href="https://doi.org/10.1016/j.ajhg.2011.02.002">doi:10.1016/j.ajhg.2011.02.002</a> to transform the heritability on the observed
scale to the heritability on the liability scale.
</p>


<h3>Value</h3>

<p>If <code>obs_h2</code>, <code>pop_prev</code> and <code>prop_cases</code> are non-negative numbers
that are at most one, the function returns the heritability on the liability
scale using Equation 23 from
Sang Hong Lee, Naomi R. Wray, Michael E. Goddard and Peter M. Visscher, &quot;Estimating
Missing Heritability for Diseases from Genome-wide Association Studies&quot;,
The American Journal of Human Genetics, Volume 88, Issue 3, 2011, pp. 294-305,
<a href="https://doi.org/10.1016/j.ajhg.2011.02.002">doi:10.1016/j.ajhg.2011.02.002</a>.
If <code>obs_h2</code>, <code>pop_prev</code> and <code>prop_cases</code> are non-negative numeric
vectors where all entries are at most one, the function returns a vector of the same
length as obs_h2. Each entry holds to the heritability on the liability
scale which was obtained from the corresponding entry in obs_h2 using Equation 23.
If <code>obs_h2</code> and <code>pop_prev</code> are non-negative numbers that are at most
one and <code>prop_cases</code> is <code>NULL</code>, the function returns the heritability
on the liability scale using Equation 17 from
Sang Hong Lee, Naomi R. Wray, Michael E. Goddard and Peter M. Visscher, &quot;Estimating
Missing Heritability for Diseases from Genome-wide Association Studies&quot;,
The American Journal of Human Genetics, Volume 88, Issue 3, 2011, pp. 294-305,
<a href="https://doi.org/10.1016/j.ajhg.2011.02.002">doi:10.1016/j.ajhg.2011.02.002</a>.
If <code>obs_h2</code> and <code>pop_prev</code> are non-negative numeric vectors such that
all entries are at most one, while <code>prop_cases</code> is <code>NULL</code>,
<code>convert_observed_to_liability_scale</code> returns a vector of the same
length as obq_h2. Each entry holds to the liability-scale heritability that
was obtained from the corresponding entry in obs_h2 using Equation 17.
</p>


<h3>References</h3>

<p>Sang Hong Lee, Naomi R. Wray, Michael E. Goddard, Peter M. Visscher (2011, March). Estimating
Missing Heritability for Diseases from Genome-wide Association Studies. In The American Journal
of Human Genetics (Vol. 88, Issue 3, pp. 294-305). <a href="https://doi.org/10.1016/j.ajhg.2011.02.002">doi:10.1016/j.ajhg.2011.02.002</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert_observed_to_liability_scale()
convert_observed_to_liability_scale(prop_cases=NULL)
convert_observed_to_liability_scale(obs_h2 = 0.8, pop_prev = 1/44, 
                                    prop_cases = NULL)
convert_observed_to_liability_scale(obs_h2 = c(0.5,0.8), 
                                    pop_prev = c(0.05, 1/44), 
                                    prop_cases = NULL)

</code></pre>

<hr>
<h2 id='correct_positive_definite'>Positive definite matrices</h2><span id='topic+correct_positive_definite'></span>

<h3>Description</h3>

<p><code>correct_positive_definite</code> verifies that a given covariance matrix
is indeed positive definite by checking that all eigenvalues are positive.
If the given covariance matrix is not positive definite,
<code>correct_positive_definite</code> tries to modify the underlying correlation matrices
genetic_corrmat and full_corrmat in order to obtain a positive definite
covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_positive_definite(
  covmat,
  correction_val = 0.99,
  correction_limit = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct_positive_definite_+3A_covmat">covmat</code></td>
<td>
<p>A symmetric and numeric matrix. If the covariance matrix
should be corrected, it must have a number of attributes, such as
<code>attr(covmat,"fam_vec")</code>, <code>attr(covmat,"n_fam")</code>,
<code>attr(covmat,"add_ind")</code>, <code>attr(covmat,"h2")</code>,
<code>attr(covmat,"genetic_corrmat")</code>, <code>attr(covmat,"full_corrmat")</code>
and <code>attr(covmat,"phenotype_names")</code>. Any covariance matrix
obtained by <code><a href="#topic+construct_covmat">construct_covmat</a></code>, <code><a href="#topic+construct_covmat_single">construct_covmat_single</a></code>
or <code><a href="#topic+construct_covmat_multi">construct_covmat_multi</a></code> will have these attributes by default.</p>
</td></tr>
<tr><td><code id="correct_positive_definite_+3A_correction_val">correction_val</code></td>
<td>
<p>A positive number representing the amount by which
<code>genetic_corrmat</code> and <code>full_corrmat</code> will be changed, if some
eigenvalues are non-positive. That is, correction_val is the number that will be
multiplied to all off_diagonal entries in <code>genetic_corrmat</code> and <code>full_corrmat</code>.
Defaults to 0.99.</p>
</td></tr>
<tr><td><code id="correct_positive_definite_+3A_correction_limit">correction_limit</code></td>
<td>
<p>A positive integer representing the upper limit for the correction
procedure. Defaults to 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to verify that a given covariance matrix
is positive definite. It calculates all eigenvalues in order to
investigate whether they are all positive. This property is necessary
for the covariance matrix to be used as a Gaussian covariance matrix.
It is especially useful to check whether any covariance matrix obtained
by <code><a href="#topic+construct_covmat_multi">construct_covmat_multi</a></code> is positive definite.
If the given covariance matrix is not positive definite, <code>correct_positive_definite</code>
tries to modify the underlying correlation matrices (called <code>genetic_corrmat</code> and
<code>full_corrmat</code> in <code><a href="#topic+construct_covmat">construct_covmat</a></code> or <code><a href="#topic+construct_covmat_multi">construct_covmat_multi</a></code>) by
multiplying all off-diagonal entries in the correlation matrices by a given number.
</p>


<h3>Value</h3>

<p>If <code>covmat</code> is a symmetric and numeric matrix and all eigenvalues are
positive, <code>correct_positive_definite</code> simply returns <code>covmat</code>. If some
eigenvalues are not positive and <code>correction_val</code> is a positive number,
<code>correct_positive_definite</code> tries to convert <code>covmat</code> into a positive definite
matrix. If <code>covmat</code> has attributes <code>add_ind</code>, <code>h2</code>,
<code>genetic_corrmat</code>, <code>full_corrmat</code> and <code>phenotype_names</code>,
<code>correct_positive_definite</code> computes a new covariance matrix using slightly
modified correlation matrices <code>genetic_corrmat</code> and <code>full_corrmat</code>.
If the correction is performed successfully, i.e. if the new covariance matrix
is positive definite,the new covariance matrix is returned.
Otherwise, <code>correct_positive_definite</code> returns the original covariance matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+construct_covmat">construct_covmat</a></code>, <code><a href="#topic+construct_covmat_single">construct_covmat_single</a></code> and
<code><a href="#topic+construct_covmat_multi">construct_covmat_multi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ntrait &lt;- 2
genetic_corrmat &lt;- matrix(0.6, ncol = ntrait, nrow = ntrait)
diag(genetic_corrmat) &lt;- 1
full_corrmat &lt;- matrix(-0.25, ncol = ntrait, nrow = ntrait)
diag(full_corrmat) &lt;- 1
h2_vec &lt;- rep(0.6, ntrait)
cov &lt;- construct_covmat(fam_vec = c("m", "f"),
  genetic_corrmat = genetic_corrmat,
  h2 = h2_vec,
  full_corrmat = full_corrmat)
cov
correct_positive_definite(cov)

</code></pre>

<hr>
<h2 id='estimate_gen_liability_ltfh'>Estimate genetic liability similar to LT-FH</h2><span id='topic+estimate_gen_liability_ltfh'></span>

<h3>Description</h3>

<p>Estimate genetic liability similar to LT-FH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_gen_liability_ltfh(
  h2,
  phen,
  child_threshold,
  parent_threshold,
  status_col_offspring = "CHILD_STATUS",
  status_col_father = "P1_STATUS",
  status_col_mother = "P2_STATUS",
  status_col_siblings = "SIB_STATUS",
  number_of_siblings_col = "NUM_SIBS",
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_h2">h2</code></td>
<td>
<p>Liability scale heritability of the trait being analysed.</p>
</td></tr>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_phen">phen</code></td>
<td>
<p>tibble or data.frame with status of the genotyped individual, parents and siblings.</p>
</td></tr>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_child_threshold">child_threshold</code></td>
<td>
<p>single numeric value that is used as threshold for the offspring and siblings.</p>
</td></tr>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_parent_threshold">parent_threshold</code></td>
<td>
<p>single numeric value that is used as threshold for both parents</p>
</td></tr>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_status_col_offspring">status_col_offspring</code></td>
<td>
<p>Column name of status for the offspring</p>
</td></tr>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_status_col_father">status_col_father</code></td>
<td>
<p>Column name of status for the father</p>
</td></tr>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_status_col_mother">status_col_mother</code></td>
<td>
<p>Column name of status for the mother</p>
</td></tr>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_status_col_siblings">status_col_siblings</code></td>
<td>
<p>Column name of status for the siblings</p>
</td></tr>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_number_of_siblings_col">number_of_siblings_col</code></td>
<td>
<p>Column name for the number of siblings for a given individual</p>
</td></tr>
<tr><td><code id="estimate_gen_liability_ltfh_+3A_tol">tol</code></td>
<td>
<p>Convergence criteria of the Gibbs sampler. Default is 0.01, meaning a standard error of the mean below 0.01</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the estimated genetic liabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phen &lt;- data.frame(
CHILD_STATUS = c(0,0),
P1_STATUS = c(1,1),
P2_STATUS = c(0,1),
SIB_STATUS = c(1,0),
NUM_SIBS = c(2,0))

h2 &lt;- 0.5
child_threshold &lt;- 0.7
parent_threshold &lt;- 0.8

estimate_gen_liability_ltfh(h2, phen, child_threshold, parent_threshold)

</code></pre>

<hr>
<h2 id='estimate_liability'>Estimating the genetic or full liability for a variable number of
phenotypes</h2><span id='topic+estimate_liability'></span>

<h3>Description</h3>

<p><code>estimate_liability</code> estimates the genetic component of the full
liability and/or the full liability for a number of individuals based
on their family history for one or more phenotypes.  It is a wrapper around
<code><a href="#topic+estimate_liability_single">estimate_liability_single</a></code> and <code><a href="#topic+estimate_liability_multi">estimate_liability_multi</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_liability(
  .tbl = NULL,
  family_graphs = NULL,
  h2 = 0.5,
  pid = "PID",
  fam_id = "fam_ID",
  role = "role",
  family_graphs_col = "fam_graph",
  out = c(1),
  tol = 0.01,
  genetic_corrmat = NULL,
  full_corrmat = NULL,
  phen_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_liability_+3A_.tbl">.tbl</code></td>
<td>
<p>A matrix, list or data frame that can be converted into a tibble.
Must have at least five columns that hold the family identifier, the personal
identifier, the role and the lower and upper thresholds for all phenotypes
of interest. Note that the role must be one of the following abbreviations
</p>

<ul>
<li> <p><code>g</code> (Genetic component of full liability)
</p>
</li>
<li> <p><code>o</code> (Full liability)
</p>
</li>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to <code>NULL</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_liability_+3A_family_graphs">family_graphs</code></td>
<td>
<p>A tibble with columns pid and family_graph_col.
See prepare_graph for construction of the graphs. The family graphs Defaults to NULL.</p>
</td></tr>
<tr><td><code id="estimate_liability_+3A_h2">h2</code></td>
<td>
<p>Either a number representing the heritability on liability scale for a
single phenotype, or a numeric vector representing the liability-scale heritabilities
for all phenotypes. All entries in h2 must be non-negative and at most 1.</p>
</td></tr>
<tr><td><code id="estimate_liability_+3A_pid">pid</code></td>
<td>
<p>A string holding the name of the column in <code>family</code> and
<code>threshs</code> that hold the personal identifier(s). Defaults to <code>"PID"</code>.</p>
</td></tr>
<tr><td><code id="estimate_liability_+3A_fam_id">fam_id</code></td>
<td>
<p>A string holding the name of the column in <code>family</code> that
holds the family identifier. Defaults to <code>"fam_ID"</code>.</p>
</td></tr>
<tr><td><code id="estimate_liability_+3A_role">role</code></td>
<td>
<p>A string holding the name of the column in <code>.tbl</code> that
holds the role.Each role must be chosen from the following list of abbreviations
</p>

<ul>
<li> <p><code>g</code> (Genetic component of full liability)
</p>
</li>
<li> <p><code>o</code> (Full liability)
</p>
</li>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to &quot;role&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_liability_+3A_family_graphs_col">family_graphs_col</code></td>
<td>
<p>Name of column with family graphs in family_graphs. Defaults to &quot;fam_graph&quot;.</p>
</td></tr>
<tr><td><code id="estimate_liability_+3A_out">out</code></td>
<td>
<p>A character or numeric vector indicating whether the genetic component
of the full liability, the full liability or both should be returned. If <code>out = c(1)</code> or
<code>out = c("genetic")</code>, the genetic liability is estimated and returned. If <code>out = c(2)</code> or
<code>out = c("full")</code>, the full liability is estimated and returned. If <code>out = c(1,2)</code> or
<code>out = c("genetic", "full")</code>, both components are estimated and returned.
Defaults to <code>c(1)</code>.</p>
</td></tr>
<tr><td><code id="estimate_liability_+3A_tol">tol</code></td>
<td>
<p>A number that is used as the convergence criterion for the Gibbs sampler.
Equals the standard error of the mean. That is, a tolerance of 0.2 means that the
standard error of the mean is below 0.2. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="estimate_liability_+3A_genetic_corrmat">genetic_corrmat</code></td>
<td>
<p>Either <code>NULL</code> (if <code>h2</code> is a number) or a numeric
matrix (if <code>h2</code> is a vector of length &gt; 1) holding the genetic correlations
between the desired phenotypes. All diagonal entries must be equal to one, while
all off-diagonal entries must be between -1 and 1. In addition, the matrix must
be symmetric. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="estimate_liability_+3A_full_corrmat">full_corrmat</code></td>
<td>
<p>Either <code>NULL</code> (if <code>h2</code> is a number) or a numeric
matrix (if <code>h2</code> is a vector of length &gt; 1) holding the full correlations
between the desired phenotypes. All diagonal entries must be equal to one, while
all off-diagonal entries must be between -1 and 1. In addition, the matrix must
be symmetric. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="estimate_liability_+3A_phen_names">phen_names</code></td>
<td>
<p>Either <code>NULL</code> or a character vector holding the phenotype
names. These names will be used to create the row and column names for the
covariance matrix. If it is not specified, the names will default to
phenotype1, phenotype2, etc. Defaults to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to estimate either the genetic component of the
full liability, the full liability or both for a variable number of traits.
</p>


<h3>Value</h3>

<p>If <code>family</code> and <code>threshs</code> are two matrices, lists or
data frames that can be converted into tibbles, if <code>family</code> has two
columns named like the strings represented in <code>pid</code> and <code>fam_id</code>, if
<code>threshs</code> has a column named like the string given in <code>pid</code> as
well as a column named &quot;lower&quot; and a column named &quot;upper&quot; and if the
liability-scale heritability <code>h2</code> is a number (<code>length(h2)=1</code>),
and <code>out</code>, <code>tol</code> and
<code>always_add</code> are of the required form, then the function returns a
tibble with either four or six columns (depending on the length of out).
The first two columns correspond to the columns <code>fam_id</code> and <code>pid</code> '
present in <code>family</code>.
If <code>out</code> is equal to <code>c(1)</code> or <code>c("genetic")</code>, the third
and fourth column hold the estimated genetic liability as well as the
corresponding standard error, respectively.
If <code>out</code> equals <code>c(2)</code> or <code>c("full")</code>, the third and
fourth column hold the estimated full liability as well as the
corresponding standard error, respectively.
If <code>out</code> is equal to <code>c(1,2)</code> or <code>c("genetic","full")</code>,
the third and fourth column hold the estimated genetic liability as
well as the corresponding standard error, respectively, while the fifth and
sixth column hold the estimated full liability as well as the corresponding
standard error, respectively.
If <code>h2</code> is a numeric vector of length greater than 1 and if
<code>genetic_corrmat</code>, <code>full_corrmat</code>, <code>out</code> and <code>tol</code> are of the
required form, then the function returns a tibble with at least six columns (depending
on the length of out).
The first two columns correspond to the columns <code>fam_id</code> and <code>pid</code> present in
the tibble <code>family</code>.
If <code>out</code> is equal to <code>c(1)</code> or <code>c("genetic")</code>, the third and fourth columns
hold the estimated genetic liability as well as the corresponding standard error for the
first phenotype, respectively.
If <code>out</code> equals <code>c(2)</code> or <code>c("full")</code>, the third and fourth columns hold
the estimated full liability as well as the corresponding standard error for the first
phenotype, respectively.
If <code>out</code> is equal to <code>c(1,2)</code> or <code>c("genetic","full")</code>, the third and
fourth columns hold the estimated genetic liability as well as the corresponding standard
error for the first phenotype, respectively, while the fifth and sixth columns hold the
estimated full liability as well as the corresponding standard error for the first
phenotype, respectively.
The remaining columns hold the estimated genetic liabilities and/or the estimated full
liabilities as well as the corresponding standard errors for the remaining phenotypes.
</p>


<h3>See Also</h3>

<p><code><a href="future.apply.html#topic+future_apply">future_apply</a></code>, <code><a href="#topic+estimate_liability_single">estimate_liability_single</a></code>,
<code><a href="#topic+estimate_liability_multi">estimate_liability_multi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_corrmat &lt;- matrix(0.4, 3, 3)
diag(genetic_corrmat) &lt;- 1
full_corrmat &lt;- matrix(0.6, 3, 3)
diag(full_corrmat) &lt;- 1
#
sims &lt;- simulate_under_LTM(fam_vec = c("m","f"), n_fam = NULL, add_ind = TRUE, 
genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, h2 = rep(.5,3), 
n_sim = 1, pop_prev = rep(.1,3))
estimate_liability(.tbl = sims$thresholds, h2 = rep(.5,3), 
genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat,
pid = "indiv_ID", fam_id = "fam_ID", role = "role", out = c(1), 
phen_names = paste0("phenotype", 1:3), tol = 0.01)

</code></pre>

<hr>
<h2 id='estimate_liability_multi'>Estimating the genetic or full liability for multiple phenotypes</h2><span id='topic+estimate_liability_multi'></span>

<h3>Description</h3>

<p><code>estimate_liability_multi</code> estimates the genetic component of the full
liability and/or the full liability for a number of individuals based
on their family history for a variable number of phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_liability_multi(
  .tbl = NULL,
  family_graphs = NULL,
  h2_vec,
  genetic_corrmat,
  full_corrmat,
  phen_names = NULL,
  pid = "PID",
  fam_id = "fam_ID",
  role = "role",
  family_graphs_col = "fam_graph",
  out = c(1),
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_liability_multi_+3A_.tbl">.tbl</code></td>
<td>
<p>A matrix, list or data frame that can be converted into a tibble.
Must have at least seven columns that hold the family identifier, the personal
identifier, the role and the lower and upper thresholds for all phenotypes
of interest. Note that the role must be one of the following abbreviations
</p>

<ul>
<li> <p><code>g</code> (Genetic component of full liability)
</p>
</li>
<li> <p><code>o</code> (Full liability)
</p>
</li>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to <code>NULL</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_family_graphs">family_graphs</code></td>
<td>
<p>A tibble with columns pid and family_graph_col.
See prepare_graph for construction of the graphs. The family graphs Defaults to NULL.</p>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_h2_vec">h2_vec</code></td>
<td>
<p>A numeric vector representing the liability-scale heritabilities
for all phenotypes. All entries in h2_vec must be non-negative and at most 1.</p>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_genetic_corrmat">genetic_corrmat</code></td>
<td>
<p>A numeric matrix holding the genetic correlations between the desired
phenotypes. All diagonal entries must be equal to one, while all off-diagonal entries
must be between -1 and 1. In addition, the matrix must be symmetric.</p>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_full_corrmat">full_corrmat</code></td>
<td>
<p>A numeric matrix holding the full correlations between the desired
phenotypes. All diagonal entries must be equal to one, while all off-diagonal entries
must be between -1 and 1. In addition, the matrix must be symmetric.</p>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_phen_names">phen_names</code></td>
<td>
<p>A character vector holding the phenotype names. These names
will be used to create the row and column names for the covariance matrix.
If it is not specified, the names will default to phenotype1, phenotype2, etc.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_pid">pid</code></td>
<td>
<p>A string holding the name of the column in <code>family</code> and
<code>threshs</code> that hold the personal identifier(s). Defaults to &quot;PID&quot;.</p>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_fam_id">fam_id</code></td>
<td>
<p>A string holding the name of the column in <code>family</code> that
holds the family identifier. Defaults to &quot;fam_ID&quot;.</p>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_role">role</code></td>
<td>
<p>A string holding the name of the column in <code>.tbl</code> that
holds the role.Each role must be chosen from the following list of abbreviations
</p>

<ul>
<li> <p><code>g</code> (Genetic component of full liability)
</p>
</li>
<li> <p><code>o</code> (Full liability)
</p>
</li>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to &quot;role&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_family_graphs_col">family_graphs_col</code></td>
<td>
<p>Name of column with family graphs in family_graphs. Defaults to &quot;fam_graph&quot;.</p>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_out">out</code></td>
<td>
<p>A character or numeric vector indicating whether the genetic component
of the full liability, the full liability or both should be returned. If <code>out = c(1)</code> or
<code>out = c("genetic")</code>, the genetic liability is estimated and returned. If <code>out = c(2)</code> or
<code>out = c("full")</code>, the full liability is estimated and returned. If <code>out = c(1,2)</code> or
<code>out = c("genetic", "full")</code>, both components are estimated and returned.
Defaults to <code>c(1)</code>.</p>
</td></tr>
<tr><td><code id="estimate_liability_multi_+3A_tol">tol</code></td>
<td>
<p>A number that is used as the convergence criterion for the Gibbs sampler.
Equals the standard error of the mean. That is, a tolerance of 0.2 means that the
standard error of the mean is below 0.2. Defaults to 0.01.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to estimate either the genetic component of the
full liability, the full liability or both for a variable number of traits.
</p>


<h3>Value</h3>

<p>If <code>family</code> and <code>threshs</code> are two matrices, lists or data frames
that can be converted into tibbles, if <code>family</code> has two columns named like
the strings represented in <code>pid</code> and <code>fam_id</code>, if <code>threshs</code> has a
column named like the string given in <code>pid</code> as well as a column named <code>"lower"</code>
and a column named <code>"upper"</code> and if the liability-scale heritabilities in <code>h2_vec</code>,
<code>genetic_corrmat</code>, <code>full_corrmat</code>, <code>out</code> and <code>tol</code> are of the
required form, then the function returns a tibble with at least six columns (depending
on the length of out).
The first two columns correspond to the columns <code>fam_id</code> and <code>pid</code> present in
the tibble <code>family</code>.
If <code>out</code> is equal to <code>c(1)</code> or <code>c("genetic")</code>, the third and fourth columns
hold the estimated genetic liability as well as the corresponding standard error for the
first phenotype, respectively.
If <code>out</code> equals <code>c(2)</code> or <code>c("full")</code>, the third and fourth columns hold
the estimated full liability as well as the corresponding standard error for the first
phenotype, respectively.
If <code>out</code> is equal to <code>c(1,2)</code> or <code>c("genetic","full")</code>, the third and
fourth columns hold the estimated genetic liability as well as the corresponding standard
error for the first phenotype, respectively, while the fifth and sixth columns hold the
estimated full liability as well as the corresponding standard error for the first
phenotype, respectively.
The remaining columns hold the estimated genetic liabilities and/or the estimated full
liabilities as well as the corresponding standard errors for the remaining phenotypes.
</p>


<h3>See Also</h3>

<p><code><a href="future.apply.html#topic+future_apply">future_apply</a></code>, <code><a href="#topic+estimate_liability_single">estimate_liability_single</a></code>,
<code><a href="#topic+estimate_liability">estimate_liability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_corrmat &lt;- matrix(0.4, 3, 3)
diag(genetic_corrmat) &lt;- 1
full_corrmat &lt;- matrix(0.6, 3, 3)
diag(full_corrmat) &lt;- 1
#
sims &lt;- simulate_under_LTM(fam_vec = c("m","f"), n_fam = NULL, add_ind = TRUE, 
genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, h2 = rep(.5,3), 
n_sim = 1, pop_prev = rep(.1,3))
estimate_liability_multi(.tbl = sims$thresholds, h2_vec = rep(.5,3), 
genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat,
pid = "indiv_ID", fam_id = "fam_ID", role = "role", out = c(1), 
phen_names = paste0("phenotype", 1:3), tol = 0.01)


</code></pre>

<hr>
<h2 id='estimate_liability_single'>Estimating the genetic or full liability</h2><span id='topic+estimate_liability_single'></span>

<h3>Description</h3>

<p><code>estimate_liability_single</code> estimates the genetic component of the full
liability and/or the full liability for a number of individuals based
on their family history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_liability_single(
  .tbl = NULL,
  family_graphs = NULL,
  h2 = 0.5,
  pid = "PID",
  fam_id = "fam_ID",
  family_graphs_col = "fam_graph",
  role = NULL,
  out = c(1),
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_liability_single_+3A_.tbl">.tbl</code></td>
<td>
<p>A matrix, list or data frame that can be converted into a tibble.
Must have at least five columns that hold the family identifier, the personal
identifier, the role and the lower and upper thresholds. Note that the
role must be one of the following abbreviations
</p>

<ul>
<li> <p><code>g</code> (Genetic component of full liability)
</p>
</li>
<li> <p><code>o</code> (Full liability)
</p>
</li>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to <code>NULL</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_liability_single_+3A_family_graphs">family_graphs</code></td>
<td>
<p>A tibble with columns pid and family_graph_col.
See prepare_graph for construction of the graphs. The family graphs Defaults to NULL.</p>
</td></tr>
<tr><td><code id="estimate_liability_single_+3A_h2">h2</code></td>
<td>
<p>A number representing the heritability on liability scale
for a single phenotype. Must be non-negative. Note that under the liability threshold model,
the heritability must also be at most 1.
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="estimate_liability_single_+3A_pid">pid</code></td>
<td>
<p>A string holding the name of the column in <code>.tbl</code> (or <code>family</code> and
<code>threshs</code>) that hold the personal identifier(s). Defaults to &quot;PID&quot;.</p>
</td></tr>
<tr><td><code id="estimate_liability_single_+3A_fam_id">fam_id</code></td>
<td>
<p>A string holding the name of the column in <code>.tbl</code> or <code>family</code> that
holds the family identifier. Defaults to &quot;fam_ID&quot;.</p>
</td></tr>
<tr><td><code id="estimate_liability_single_+3A_family_graphs_col">family_graphs_col</code></td>
<td>
<p>Name of column with family graphs in family_graphs. Defaults to &quot;fam_graph&quot;.</p>
</td></tr>
<tr><td><code id="estimate_liability_single_+3A_role">role</code></td>
<td>
<p>A string holding the name of the column in <code>.tbl</code> that
holds the role. Each role must be chosen from the following list of abbreviations
</p>

<ul>
<li> <p><code>g</code> (Genetic component of full liability)
</p>
</li>
<li> <p><code>o</code> (Full liability)
</p>
</li>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to &quot;role&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_liability_single_+3A_out">out</code></td>
<td>
<p>A character or numeric vector indicating whether the genetic component
of the full liability, the full liability or both should be returned. If <code>out = c(1)</code> or
<code>out = c("genetic")</code>, the genetic liability is estimated and returned. If <code>out = c(2)</code> or
<code>out = c("full")</code>, the full liability is estimated and returned. If <code>out = c(1,2)</code> or
<code>out = c("genetic", "full")</code>, both components are estimated and returned.
Defaults to <code>c(1)</code>.</p>
</td></tr>
<tr><td><code id="estimate_liability_single_+3A_tol">tol</code></td>
<td>
<p>A number that is used as the convergence criterion for the Gibbs sampler.
Equals the standard error of the mean. That is, a tolerance of 0.2 means that the
standard error of the mean is below 0.2. Defaults to 0.01.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to estimate either the genetic component of the
full liability, the full liability or both. It is possible to input either
</p>


<h3>Value</h3>

<p>If <code>family</code> and <code>threshs</code> are two matrices, lists or
data frames that can be converted into tibbles, if <code>family</code> has two
columns named like the strings represented in <code>pid</code> and <code>fam_id</code>, if
<code>threshs</code> has a column named like the string given in <code>pid</code> as
well as a column named &quot;lower&quot; and a column named &quot;upper&quot; and if the
liability-scale heritability <code>h2</code>, <code>out</code>, <code>tol</code> and
<code>always_add</code> are of the required form, then the function returns a
tibble with either four or six columns (depending on the length of out).
The first two columns correspond to the columns <code>fam_id</code> and <code>pid</code> '
present in <code>family</code>.
If <code>out</code> is equal to <code>c(1)</code> or <code>c("genetic")</code>, the third
and fourth column hold the estimated genetic liability as well as the
corresponding standard error, respectively.
If <code>out</code> equals <code>c(2)</code> or <code>c("full")</code>, the third and
fourth column hold the estimated full liability as well as the
corresponding standard error, respectively.
If <code>out</code> is equal to <code>c(1,2)</code> or <code>c("genetic","full")</code>,
the third and fourth column hold the estimated genetic liability as
well as the corresponding standard error, respectively, while the fifth and
sixth column hold the estimated full liability as well as the corresponding
standard error, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="future.apply.html#topic+future_apply">future_apply</a></code>, <code><a href="#topic+estimate_liability_multi">estimate_liability_multi</a></code>,
<code><a href="#topic+estimate_liability">estimate_liability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sims &lt;- simulate_under_LTM(fam_vec = c("m","f","s1"), n_fam = NULL, 
add_ind = TRUE, h2 = 0.5, n_sim=10, pop_prev = .05)
#
estimate_liability_single(.tbl = sims$thresholds, 
h2 = 0.5, pid = "indiv_ID", fam_id = "fam_ID", role = "role", out = c(1), 
tol = 0.01)
# 
sims &lt;- simulate_under_LTM(fam_vec = c(), n_fam = NULL, add_ind = TRUE, 
h2 = 0.5, n_sim=10, pop_prev = .05)
#
estimate_liability_single(.tbl = sims$thresholds, 
h2 = 0.5, pid = "indiv_ID", fam_id = "fam_ID", role = "role",
out = c("genetic"), tol = 0.01)

</code></pre>

<hr>
<h2 id='get_all_combs'>construct all combinations of input vector</h2><span id='topic+get_all_combs'></span>

<h3>Description</h3>

<p>pastes together all combinations of input vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_combs(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_combs_+3A_vec">vec</code></td>
<td>
<p>vector of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of strings is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_all_combs(letters[1:3])

</code></pre>

<hr>
<h2 id='get_kinship'>Construct kinship matrix from graph</h2><span id='topic+get_kinship'></span>

<h3>Description</h3>

<p>construct the kinship matrix from a graph representation of a family, centered on an index person (proband).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_kinship(fam_graph, h2, index_id = NA, add_ind = TRUE, fix_diag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_kinship_+3A_fam_graph">fam_graph</code></td>
<td>
<p>graph.</p>
</td></tr>
<tr><td><code id="get_kinship_+3A_h2">h2</code></td>
<td>
<p>heritability.</p>
</td></tr>
<tr><td><code id="get_kinship_+3A_index_id">index_id</code></td>
<td>
<p>proband id. Only used in conjuction with add_ind = TRUE.</p>
</td></tr>
<tr><td><code id="get_kinship_+3A_add_ind">add_ind</code></td>
<td>
<p>add genetic liability to the kinship matrix. Defaults to true.</p>
</td></tr>
<tr><td><code id="get_kinship_+3A_fix_diag">fix_diag</code></td>
<td>
<p>Whether to set diagonal to 1 for all entries except for the
genetic liability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A kinship matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fam &lt;- data.frame(
i = c(1, 2, 3, 4),
f = c(3, 0, 4, 0),
m = c(2, 0, 0, 0)
)

thresholds &lt;- data.frame(
  i = c(1, 2, 3, 4),
  lower = c(-Inf, -Inf, 0.8, 0.7),
  upper = c(0.8, 0.8, 0.8, 0.7)
)

graph &lt;- prepare_graph(fam, icol = "i", fcol = "f", mcol = "m", thresholds = thresholds)

get_kinship(graph, h2 = 0.5, index_id = "1")

</code></pre>

<hr>
<h2 id='get_relatedness'>Relatedness between a pair of family members</h2><span id='topic+get_relatedness'></span>

<h3>Description</h3>

<p><code>get_relatedness</code> returns the relatedness times the
liability-scale heritability for a pair of family members
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_relatedness(s1, s2, h2 = 0.5, from_covmat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_relatedness_+3A_s1">s1</code>, <code id="get_relatedness_+3A_s2">s2</code></td>
<td>
<p>Strings representing the two family members.
The strings must be chosen from the following list of strings:
</p>

<ul>
<li> <p><code>g</code> (Genetic component of full liability)
</p>
</li>
<li> <p><code>o</code> (Full liability)
</p>
</li>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_relatedness_+3A_h2">h2</code></td>
<td>
<p>A number representing the squared heritability on liability scale.
Must be non-negative and at most 1. Defaults to 0.5</p>
</td></tr>
<tr><td><code id="get_relatedness_+3A_from_covmat">from_covmat</code></td>
<td>
<p>logical variable. Only used internally. allows for skip of negative check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to get the percentage of shared
DNA times the liability-scale heritability <code class="reqn">h^2</code> for two family members.
</p>


<h3>Value</h3>

<p>If both <code>s1</code> and <code>s2</code> are strings chosen from the mentioned
list of strings and <code>h2</code> is a number satisfying <code class="reqn">0 \leq h2 \leq 1</code>,
then the output will be a number that equals the percentage of shared
DNA between <code>s1</code> and <code>s2</code> times the squared heritability <code>h2</code>.
</p>


<h3>Note</h3>

<p>If you are only interested in the percentage of shared DNA, set <code>h2 = 1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_relatedness("g","o")
get_relatedness("g","f", h2 = 1)
get_relatedness("o","s", h2 = 0.3)


# This will result in errors:
try(get_relatedness("a","b"))
try(get_relatedness(m, mhs))

</code></pre>

<hr>
<h2 id='graph_based_covariance_construction'>Constructing covariance matrix from local family graph</h2><span id='topic+graph_based_covariance_construction'></span>

<h3>Description</h3>

<p>Function that constructs the genetic covariance matrix given a graph around a proband
and extracts the threshold information from the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_based_covariance_construction(
  pid,
  cur_proband_id,
  cur_family_graph,
  h2,
  add_ind = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_based_covariance_construction_+3A_pid">pid</code></td>
<td>
<p>Name of column of personal ID</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_+3A_cur_proband_id">cur_proband_id</code></td>
<td>
<p>id of proband</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_+3A_cur_family_graph">cur_family_graph</code></td>
<td>
<p>local graph of current proband</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_+3A_h2">h2</code></td>
<td>
<p>liability scale heritability</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_+3A_add_ind">add_ind</code></td>
<td>
<p>whether to add genetic liability of the proband or not. Defaults to true.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two elements. The first element is temp_tbl, which contains the id of
the current proband, the family ID and the lower and upper thresholds. The second element,
cov, is the covariance matrix of the local graph centered on the current proband.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fam &lt;- data.frame(
  id = c("pid", "mom", "dad", "pgf"),
  dadcol = c("dad", 0, "pgf", 0),
  momcol = c("mom", 0, 0, 0))

thresholds &lt;- data.frame(
  id = c("pid", "mom", "dad", "pgf"),
  lower = c(-Inf, -Inf, 0.8, 0.7),
  upper = c(0.8, 0.8, 0.8, 0.7))

graph &lt;- prepare_graph(fam, icol = "id", fcol = "dadcol", mcol = "momcol", thresholds = thresholds)

graph_based_covariance_construction(pid = "id",
                                    cur_proband_id = "pid",
                                    cur_family_graph = graph,
                                    h2 = 0.5)

</code></pre>

<hr>
<h2 id='graph_based_covariance_construction_multi'>Constructing covariance matrix from local family graph for multi trait analysis</h2><span id='topic+graph_based_covariance_construction_multi'></span>

<h3>Description</h3>

<p>Function that constructs the genetic covariance matrix given a graph around a proband
and extracts the threshold information from the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_based_covariance_construction_multi(
  fam_id,
  pid,
  cur_proband_id,
  cur_family_graph,
  h2_vec,
  genetic_corrmat,
  phen_names,
  add_ind = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_based_covariance_construction_multi_+3A_fam_id">fam_id</code></td>
<td>
<p>Name of column with the family ID</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_multi_+3A_pid">pid</code></td>
<td>
<p>Name of column of personal ID</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_multi_+3A_cur_proband_id">cur_proband_id</code></td>
<td>
<p>id of proband</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_multi_+3A_cur_family_graph">cur_family_graph</code></td>
<td>
<p>local graph of current proband</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_multi_+3A_h2_vec">h2_vec</code></td>
<td>
<p>vector of liability scale heritabilities</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_multi_+3A_genetic_corrmat">genetic_corrmat</code></td>
<td>
<p>matrix with genetic correlations between considered phenotypes. Must have same order as h2_vec.</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_multi_+3A_phen_names">phen_names</code></td>
<td>
<p>Names of the phenotypes, as given in cur_family_graph.</p>
</td></tr>
<tr><td><code id="graph_based_covariance_construction_multi_+3A_add_ind">add_ind</code></td>
<td>
<p>whether to add genetic liability of the proband or not. Defaults to true.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with three elements. The first element is temp_tbl, which contains the id of
the current proband, the family ID and the lower and upper thresholds for all phenotypes. The second element,
cov, is the covariance matrix of the local graph centred on the current proband. The third element is newOrder,
which is the order of ids from pid and phen_names pasted together, such that order can be enforced elsewhere too.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fam &lt;- data.frame(
fam = c(1, 1, 1,1),
id = c("pid", "mom", "dad", "pgf"),
dadcol = c("dad", 0, "pgf", 0),
momcol = c("mom", 0, 0, 0))

thresholds &lt;- data.frame(
  id = c("pid", "mom", "dad", "pgf"),
  lower_1 = c(-Inf, -Inf, 0.8, 0.7),
  upper_1 = c(0.8, 0.8, 0.8, 0.7),
  lower_2 = c(-Inf, 0.3, -Inf, 0.2),
  upper_2 = c(0.3, 0.3, 0.3, 0.2))

graph &lt;- prepare_graph(fam, icol = "id", fcol = "dadcol", mcol = "momcol", thresholds = thresholds)

ntrait &lt;- 2
genetic_corrmat &lt;- matrix(0.2, ncol = ntrait, nrow = ntrait)
diag(genetic_corrmat) &lt;- 1
full_corrmat &lt;- matrix(0.3, ncol = ntrait, nrow = ntrait)
diag(full_corrmat) &lt;- 1
h2_vec &lt;- rep(0.6, ntrait)

graph_based_covariance_construction_multi(fam_id = "fam",
                                          pid = "id",
                                          cur_proband_id = "pid",
                                          cur_family_graph = graph,
                                          h2_vec = h2_vec,
                                          genetic_corrmat = genetic_corrmat,
                                          phen_names = c("1", "2"))

</code></pre>

<hr>
<h2 id='prepare_graph'>Construct graph from register information</h2><span id='topic+prepare_graph'></span>

<h3>Description</h3>

<p><code>prepare_graph</code> constructs a graph based on mother, father, and offspring links.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_graph(
  .tbl,
  icol,
  fcol,
  mcol,
  thresholds,
  lower_col = "lower",
  upper_col = "upper",
  missingID_patterns = "^0$"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_graph_+3A_.tbl">.tbl</code></td>
<td>
<p>tibble with columns icol, fcol, mcol. Additional columns will be attributes in the constructed graph.</p>
</td></tr>
<tr><td><code id="prepare_graph_+3A_icol">icol</code></td>
<td>
<p>column name of column with proband ids.</p>
</td></tr>
<tr><td><code id="prepare_graph_+3A_fcol">fcol</code></td>
<td>
<p>column name of column with father ids.</p>
</td></tr>
<tr><td><code id="prepare_graph_+3A_mcol">mcol</code></td>
<td>
<p>column name of column with mother ids.</p>
</td></tr>
<tr><td><code id="prepare_graph_+3A_thresholds">thresholds</code></td>
<td>
<p>tibble with icol, lower_col and upper_col. Used to assign lower and upper thresholds to individuals in the graph as attributes.</p>
</td></tr>
<tr><td><code id="prepare_graph_+3A_lower_col">lower_col</code></td>
<td>
<p>Column name of column with proband's lower threshold.</p>
</td></tr>
<tr><td><code id="prepare_graph_+3A_upper_col">upper_col</code></td>
<td>
<p>Column name of column with proband's upper threshold.</p>
</td></tr>
<tr><td><code id="prepare_graph_+3A_missingid_patterns">missingID_patterns</code></td>
<td>
<p>string of missing values in the ID columns. Multiple values can be used, but must be separated by &quot;|&quot;. Defaults to &quot;^0$&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object. A (directed) graph object based on the links provided in .tbl with the lower and upper thresholds stored as attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fam &lt;- data.frame(
  id = c("pid", "mom", "dad", "pgf"),
  dadcol = c("dad", 0, "pgf", 0),
  momcol = c("mom", 0, 0, 0))

thresholds &lt;- data.frame(
  id = c("pid", "mom", "dad", "pgf"),
  lower = c(-Inf, -Inf, 0.8, 0.7),
  upper = c(0.8, 0.8, 0.8, 0.7))

prepare_graph(fam, icol = "id", fcol = "dadcol", mcol = "momcol", thresholds = thresholds)

</code></pre>

<hr>
<h2 id='prepare_LTFHPlus_input'>Prepares input for <code>estimate_liability</code></h2><span id='topic+prepare_LTFHPlus_input'></span>

<h3>Description</h3>

<p>Prepares input for <code>estimate_liability</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_LTFHPlus_input(
  .tbl,
  CIP,
  age_col,
  aoo_col,
  CIP_merge_columns = c("sex", "birth_year", "age"),
  CIP_cip_col = "cip",
  status_col = "status",
  use_fixed_case_thr = FALSE,
  fam_id_col = "fam_id",
  personal_id_col = "pid",
  interpolation = NULL,
  bst.params = list(max_depth = 10, base_score = 0, nthread = 4, min_child_weight = 10),
  min_CIP_value = 1e-05,
  xgboost_itr = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_LTFHPlus_input_+3A_.tbl">.tbl</code></td>
<td>
<p>contains family and personal ids and role with a family.</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_cip">CIP</code></td>
<td>
<p>tibble with population representative cumulative incidence proportions. CIP values should be merged by <code>CIP_columns</code>.</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_age_col">age_col</code></td>
<td>
<p>name of column with age</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_aoo_col">aoo_col</code></td>
<td>
<p>name of column with age of onset</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_cip_merge_columns">CIP_merge_columns</code></td>
<td>
<p>The columns the CIPs are subset by, e.g. CIPs by birth_year, sex.</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_cip_cip_col">CIP_cip_col</code></td>
<td>
<p>name of column with CIP values</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_status_col">status_col</code></td>
<td>
<p>Column that contains the status of each family member</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_use_fixed_case_thr">use_fixed_case_thr</code></td>
<td>
<p>Should the threshold be fixed for cases? Can be used if CIPs are detailed, e.g. stratified by birth_year and sex.</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_fam_id_col">fam_id_col</code></td>
<td>
<p>Column that contains the family ID</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_personal_id_col">personal_id_col</code></td>
<td>
<p>Column that contains the personal ID</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_interpolation">interpolation</code></td>
<td>
<p>type of interpolation, defaults to NULL.</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_bst.params">bst.params</code></td>
<td>
<p>list of parameters to pass on to xgboost</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_min_cip_value">min_CIP_value</code></td>
<td>
<p>minimum cip value to allow, too low values may lead to numerical instabilities.</p>
</td></tr>
<tr><td><code id="prepare_LTFHPlus_input_+3A_xgboost_itr">xgboost_itr</code></td>
<td>
<p>Number of iterations to run xgboost for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble formatted for <code>estimate_liability</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tbl = data.frame(
  fam_id = c(1, 1, 1, 1),
  pid = c(1, 2, 3, 4),
  role = c("o", "m", "f", "pgf"),
  sex = c(1, 0, 1, 1),
  status = c(0, 0, 1, 1),
  age = c(22, 42, 48, 78),
  birth_year = 2023 - c(22, 42, 48, 78),
  aoo = c(NA, NA, 43, 45))

cip = data.frame(
  age = c(22, 42, 43, 45, 48, 78),
  birth_year = c(2001, 1981, 1975, 1945, 1975, 1945),
  sex = c(1, 0, 1, 1, 1, 1),
  cip = c(0.1, 0.2, 0.3, 0.3, 0.3, 0.4))

prepare_LTFHPlus_input(.tbl = tbl,
                       CIP = cip, 
                       age_col = "age",
                       aoo_col = "aoo",
                       interpolation = NA)

</code></pre>

<hr>
<h2 id='rtmvnorm.gibbs'>Gibbs Sampler for the truncated multivariate normal distribution</h2><span id='topic+rtmvnorm.gibbs'></span>

<h3>Description</h3>

<p><code>rtmvnorm.gibbs</code> implements Gibbs sampler for the truncated
multivariate normal distribution with covariance matrix <code>covmat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtmvnorm.gibbs(
  n_sim = 1e+05,
  covmat,
  lower = -Inf,
  upper,
  fixed = (lower == upper),
  out = c(1),
  burn_in = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtmvnorm.gibbs_+3A_n_sim">n_sim</code></td>
<td>
<p>A positive number representing the number of draws from the
Gibbs sampler after burn-in.. Defaults to <code>1e+05</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm.gibbs_+3A_covmat">covmat</code></td>
<td>
<p>A symmetric and numeric matrix representing the covariance
matrix for the multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="rtmvnorm.gibbs_+3A_lower">lower</code></td>
<td>
<p>A number or numeric vector representing the lower cutoff point(s) for the
truncated normal distribution. The length of lower must be 1 or equal
to the dimension of the multivariable normal distribution.
Defaults to <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm.gibbs_+3A_upper">upper</code></td>
<td>
<p>A number or numeric vector representing the upper cutoff point(s) for the
truncated normal distribution. Must be greater or equal to lower.
In addition the length of upper must be 1 or equal to the dimension
of the multivariable normal distribution.
Defaults to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm.gibbs_+3A_fixed">fixed</code></td>
<td>
<p>A logical scalar or a logical vector indicating which
variables to fix. If <code>fixed</code> is a vector, it must have the same length as
lower and upper. Defaults to <code>TRUE</code> when <code>lower</code> is equal to
<code>upper</code> and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="rtmvnorm.gibbs_+3A_out">out</code></td>
<td>
<p>An integer or numeric vector indicating which variables should be returned
from the Gibbs sampler. If <code>out = c(1)</code>, the first variable (usually the genetic
component of the full liability of the first phenotype) is estimated and returned.
If <code>out = c(2)</code>, the second variable (usually full liability) is estimated and returned.
If <code>out = c(1,2)</code>, both the first and the second variable are estimated and returned.
Defaults to <code>c(1)</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm.gibbs_+3A_burn_in">burn_in</code></td>
<td>
<p>A number of iterations that count as burn in for the Gibbs sampler.
Must be non-negative. Defaults to <code>1000</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a covariance matrix <code>covmat</code> and lower and upper cutoff points,
the function <code>rtmvnorm.gibbs()</code> can be used to perform Gibbs sampler on a truncated
multivariable normal distribution. It is possible to specify which variables
to return from the Gibbs sampler, making it convenient to use when estimating
only the full liability or the genetic component of the full liability.
</p>


<h3>Value</h3>

<p>If <code>covmat</code> is a symmetric and numeric matrix, if <code>n_sim</code> and
<code>burn_in</code> are positive/non-negative numbers, if <code>out</code> is a numeric vector and
<code>lower</code>, <code>upper</code> and <code>fixed</code> are numbers or vectors of the same length
and the required format, <code>rtmvnorm.gibbs</code> returns the sampling values
from the Gibbs sampler for all variables specified in <code>out</code>.
</p>


<h3>References</h3>

<p>Kotecha, J. H., &amp; Djuric, P. M. (1999, March). Gibbs sampling approach for
generation of truncated multivariate gaussian random variables. In 1999 IEEE
International Conference on Acoustics, Speech, and Signal Processing.
Proceedings. ICASSP99 (Cat. No. 99CH36258) (Vol. 3, pp. 1757-1760). IEEE.
<a href="https://doi.org/10.1109/ICASSP.1999.756335">doi:10.1109/ICASSP.1999.756335</a>
</p>
<p>Wilhelm, S., &amp; Manjunath, B. G. (2010). tmvtnorm: A package for the truncated
multivariate normal distribution. The R Journal. <a href="https://doi.org/10.32614/RJ-2010-005">doi:10.32614/RJ-2010-005</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samp &lt;- rtmvnorm.gibbs(10e3, covmat = matrix(c(1, 0.2, 0.2, 0.5), 2),
                       lower = c(-Inf, 0), upper = c(0, Inf), out = 1:2)
</code></pre>

<hr>
<h2 id='simulate_under_LTM'>Simulate under the liability threshold model.</h2><span id='topic+simulate_under_LTM'></span>

<h3>Description</h3>

<p><code>simulate_under_LTM</code> simulates families and thresholds under
the liability threshold model for a given family structure and a
variable number of phenotypes.Please note that it is not possible
to simulate different family structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_under_LTM(
  fam_vec = c("m", "f", "s1", "mgm", "mgf", "pgm", "pgf"),
  n_fam = NULL,
  add_ind = TRUE,
  h2 = 0.5,
  genetic_corrmat = NULL,
  full_corrmat = NULL,
  phen_names = NULL,
  n_sim = 1000,
  pop_prev = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_under_LTM_+3A_fam_vec">fam_vec</code></td>
<td>
<p>A vector of strings holding the different
family members. All family members must be represented by strings from the
following list:
</p>

<ul>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to <code>c("m","f","s1","mgm","mgf","pgm","pgf")</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_under_LTM_+3A_n_fam">n_fam</code></td>
<td>
<p>A named vector holding the desired number of family members.
See  <code><a href="stats.html#topic+setNames">setNames</a></code>.
All names must be picked from the list mentioned above. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_+3A_add_ind">add_ind</code></td>
<td>
<p>A logical scalar indicating whether the genetic
component of the full liability as well as the full
liability for the underlying target individual should be included in
the covariance matrix. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_+3A_h2">h2</code></td>
<td>
<p>Either a number or a numeric vector holding the liability-scale
heritability(ies) for one or more phenotypes. All entries in <code>h2</code> must
be non-negative. Note that under the liability threshold model, the
heritabilities must also be at most 1. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_+3A_genetic_corrmat">genetic_corrmat</code></td>
<td>
<p>Either <code>NULL</code> or a numeric matrix holding the
genetic correlations between the desired phenotypes. Must be specified, if
<code>length(h2)</code><code class="reqn">&gt;0</code>, and will be ignored if <code>h2</code> is a number.
All diagonal entries in <code>genetic_corrmat</code> must be equal to one,
while all off-diagonal entries must be between -1 and 1. In addition,
the matrix must be symmetric.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_+3A_full_corrmat">full_corrmat</code></td>
<td>
<p>Either <code>NULL</code> or a numeric matrix holding the
full correlations between the desired phenotypes. Must be specified, if
<code>length(h2)</code><code class="reqn">&gt;0</code>, and will be ignored if <code>h2</code> is a number.
All diagonal entries in <code>full_corrmat</code> must be equal to one, while
all off-diagonal entries must be between -1 and 1. In addition, the
matrix must be symmetric.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_+3A_phen_names">phen_names</code></td>
<td>
<p>Either <code>NULL</code> or character vector holding the
phenotype names. These names will be used to create the row and column
names for the covariance matrix. Must be specified, if <code>length(h2)</code>
<code class="reqn">&gt; 0</code>, and will be ignored if <code>h2</code> is a number.
If it is not specified, the names will default to phenotype1, phenotype2, etc.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_+3A_n_sim">n_sim</code></td>
<td>
<p>A positive number representing the number of simulations. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_+3A_pop_prev">pop_prev</code></td>
<td>
<p>Either a number or a numeric vector holding the population
prevalence(s), i.e. the overall prevalence(s) in the population.
All entries in <code>pop_prev</code> must be positive
and smaller than 1. Defaults to 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to simulate the case-control status, the current
age and age-of-onset as well as the lower and upper thresholds for
a variable number of phenotypes for all family members in each of
the <code>n_sim</code> families.
If <code>h2</code> is a number, <code>simulate_under_LTM</code> simulates the case-
control status, the current age and age-of-onset as well as thresholds
for a single phenotype.
However, if <code>h2</code> is a numeric vector, if <code>genetic_corrmat</code> and
<code>full_corrmat</code> are two symmetric correlation matrices, and if
<code>phen_names</code> and <code>pop_prev</code> are to numeric vectors holding
the phenotype names and the population prevalences, respectively, then
<code>simulate_under_LTM</code> simulates the case-control status, the current
age and age-of-onset as well as thresholds for two or more (correlated)
phenotypes.
The family members can be specified using one of two possible formats.
</p>


<h3>Value</h3>

<p>If either <code>fam_vec</code> or <code>n_fam</code> is used as the argument,
if it is of the required format, if the liability-scale heritability <code>h2</code>
is a number satisfying <code class="reqn">0 \leq h^2</code>, <code>n_sim</code> is a strictly positive number,
and <code>pop_prev</code> is a positive number that is at most one,
then the output will be a list containing two tibbles.
The first tibble, <code>sim_obs</code>, holds the simulated liabilities, the disease
status and the current age/age-of-onset for all family members in each of the
<code>n_sim</code> families.
The second tibble, <code>thresholds</code>, holds the family identifier, the personal
identifier, the role (specified in fam_vec or n_fam) as well as the lower and
upper thresholds for all individuals in all families. Note that this tibble has
the format required in <code><a href="#topic+estimate_liability">estimate_liability</a></code>.
If either <code>fam_vec</code> or <code>n_fam</code> is used as the argument and if it is of the
required format, if <code>genetic_corrmat</code> and <code>full_corrmat</code> are two numeric
and symmetric matrices satisfying that all diagonal entries are one and that all
off-diagonal entries are between -1 and 1, if the liability-scale heritabilities in
<code>h2_vec</code> are numbers satisfying <code class="reqn">0 \leq h^2_i</code> for all <code class="reqn">i \in \{1,...,n_pheno\}</code>,
<code>n_sim</code> is a strictly positive number, and <code>pop_prev</code> is a positive numeric
vector such that all entries are at most one, then the output will be a list containing
the following lists.
The first outer list, which is named after the first phenotype in <code>phen_names</code>,
holds the tibble <code>sim_obs</code>, which holds the simulated liabilities, the
disease status and the current age/age-of-onset for all family members in each of
the <code>n_sim</code> families for the first phenotype.
As the first outer list, the second outer list, which is named after the second
phenotype in <code>phen_names</code>, holds the tibble <code>sim_obs</code>, which holds
the  simulated liabilities, the disease status and the current age/age-of-onset
for all family members in each of the <code>n_sim</code> families for the second phenotype.
There is a list containing <code>sim_obs</code> for each phenotype in <code>phen_names</code>.
The last list entry, <code>thresholds</code>, holds the family identifier, the personal
identifier, the role (specified in fam_vec or n_fam) as well as the lower and
upper thresholds for all individuals in all families and all phenotypes.
Note that this tibble has the format required in <code><a href="#topic+estimate_liability">estimate_liability</a></code>.
Finally, note that if neither <code>fam_vec</code> nor <code>n_fam</code> are specified, the function
returns the disease status, the current age/age-of-onset, the lower and upper
thresholds, as well as the personal identifier for a single individual, namely
the individual under consideration (called <code>o</code>).
If both <code>fam_vec</code> and <code>n_fam</code> are defined, the user is asked to '
decide on which of the two vectors to use.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+construct_covmat">construct_covmat</a></code> <code><a href="#topic+simulate_under_LTM_single">simulate_under_LTM_single</a></code>
<code><a href="#topic+simulate_under_LTM_multi">simulate_under_LTM_multi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulate_under_LTM()

genetic_corrmat &lt;- matrix(0.4, 3, 3)
diag(genetic_corrmat) &lt;- 1
full_corrmat &lt;- matrix(0.6, 3, 3)
diag(full_corrmat) &lt;- 1

simulate_under_LTM(fam_vec = NULL, n_fam = stats::setNames(c(1,1,1,2,2), 
c("m","mgm","mgf","s","mhs")))

simulate_under_LTM(fam_vec = c("m","f","s1"), n_fam = NULL, add_ind = FALSE, 
genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, n_sim = 200)

simulate_under_LTM(fam_vec = c(), n_fam = NULL, add_ind = TRUE, h2 = 0.5, 
n_sim = 200, pop_prev = 0.05)

</code></pre>

<hr>
<h2 id='simulate_under_LTM_multi'>Simulate under the liability threshold model (multiple phenotypes).</h2><span id='topic+simulate_under_LTM_multi'></span>

<h3>Description</h3>

<p><code>simulate_under_LTM_multi</code> simulates families and thresholds under
the liability threshold model for a given family structure and multiple
phenotypes. Please note that it is not possible to simulate different
family structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_under_LTM_multi(
  fam_vec = c("m", "f", "s1", "mgm", "mgf", "pgm", "pgf"),
  n_fam = NULL,
  add_ind = TRUE,
  genetic_corrmat = diag(3),
  full_corrmat = diag(3),
  h2_vec = rep(0.5, 3),
  phen_names = NULL,
  n_sim = 1000,
  pop_prev = rep(0.1, 3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_under_LTM_multi_+3A_fam_vec">fam_vec</code></td>
<td>
<p>A vector of strings holding the different
family members. All family members must be represented by strings from the
following list:
</p>

<ul>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to <code>c("m","f","s1","mgm","mgf","pgm","pgf")</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_under_LTM_multi_+3A_n_fam">n_fam</code></td>
<td>
<p>A named vector holding the desired number of family members.
See  <code><a href="stats.html#topic+setNames">setNames</a></code>.
All names must be picked from the list mentioned above. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_multi_+3A_add_ind">add_ind</code></td>
<td>
<p>A logical scalar indicating whether the genetic
component of the full liability as well as the full
liability for the underlying target individual should be included in
the covariance matrix. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_multi_+3A_genetic_corrmat">genetic_corrmat</code></td>
<td>
<p>A numeric matrix holding the genetic correlations
between the desired phenotypes. All diagonal entries must be equal to one,
while all off-diagonal entries must be between -1 and 1. In addition,
the matrix must be symmetric.
Defaults to <code>diag(3)</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_multi_+3A_full_corrmat">full_corrmat</code></td>
<td>
<p>A numeric matrix holding the full correlations
between the desired phenotypes. All diagonal entries must be equal to
one, while all off-diagonal entries must be between -1 and 1. In addition,
the matrix must be symmetric.
Defaults to <code>diag(3)</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_multi_+3A_h2_vec">h2_vec</code></td>
<td>
<p>A numeric vector holding the liability-scale heritabilities
for a number of phenotype. All entries must be non-negative. Note that under
the liability threshold model, the heritabilities must also be at most 1.
Defaults to <code>rep(0.5,3)</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_multi_+3A_phen_names">phen_names</code></td>
<td>
<p>A character vector holding the phenotype names. These names
will be used to create the row and column names for the covariance matrix.
If it is not specified, the names will default to phenotype1, phenotype2, etc.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_multi_+3A_n_sim">n_sim</code></td>
<td>
<p>A positive number representing the number of simulations. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_multi_+3A_pop_prev">pop_prev</code></td>
<td>
<p>A numeric vector holding the population prevalences, i.e. the
overall prevalences in the population. All entries in <code>pop_prev</code> must be positive
and smaller than 1. Defaults to <code>rep(.1,3)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If either <code>fam_vec</code> or <code>n_fam</code> is used as the argument and if it is of the
required format, if <code>genetic_corrmat</code> and <code>full_corrmat</code> are two numeric
and symmetric matrices satisfying that all diagonal entries are one and that all
off-diagonal entries are between -1 and 1, if the liability-scale heritabilities in
<code>h2_vec</code> are numbers satisfying <code class="reqn">0 \leq h^2_i</code> for all <code class="reqn">i \in \{1,...,n_pheno\}</code>,
<code>n_sim</code> is a strictly positive number, and <code>pop_prev</code> is a positive numeric
vector such that all entries are at most one,
then the output will be a list containing lists for each phenotype.
The first outer list, which is named after the first phenotype in <code>phen_names</code>,
holds the tibble <code>sim_obs</code>, which holds the simulated liabilities, the
disease status and the current age/age-of-onset for all family members in each of
the <code>n_sim</code> families for the first phenotype.
As the first outer list, the second outer list, which is named after the second
phenotype in <code>phen_names</code>, holds the tibble <code>sim_obs</code>, which holds
the  simulated liabilities, the disease status and the current age/age-of-onset
for all family members in each of the <code>n_sim</code> families for the second phenotype.
There is a list containing <code>sim_obs</code> for each phenotype in <code>phen_names</code>.
The last list entry, <code>thresholds</code>, holds the family identifier, the personal
identifier, the role (specified in fam_vec or n_fam) as well as the lower and
upper thresholds for all individuals in all families and all phenotypes.
Note that this tibble has the format required in <code><a href="#topic+estimate_liability">estimate_liability</a></code>.
Finally, note that if neither <code>fam_vec</code> nor <code>n_fam</code> are specified, the function
returns the disease status, the current age/age-of-onset, the lower and upper
thresholds, as well as the personal identifier for a single individual, namely
the individual under consideration (called <code>o</code>).
If both <code>fam_vec</code> and <code>n_fam</code> are defined, the user is asked to '
decide on which of the two vectors to use.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+construct_covmat">construct_covmat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulate_under_LTM_multi()

genetic_corrmat &lt;- matrix(0.4, 3, 3)
diag(genetic_corrmat) &lt;- 1
full_corrmat &lt;- matrix(0.6, 3, 3)
diag(full_corrmat) &lt;- 1

simulate_under_LTM_multi(fam_vec = NULL, n_fam = stats::setNames(c(1,1,1,2,2), 
c("m","mgm","mgf","s","mhs")))

simulate_under_LTM_multi(fam_vec = c("m","f","s1"), add_ind = FALSE, 
genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, n_sim = 100)

simulate_under_LTM_multi(fam_vec = c(), n_fam = NULL, add_ind = TRUE, n_sim = 150)

</code></pre>

<hr>
<h2 id='simulate_under_LTM_single'>Simulate under the liability threshold model (single phenotype).</h2><span id='topic+simulate_under_LTM_single'></span>

<h3>Description</h3>

<p><code>simulate_under_LTM_single</code> simulates families and thresholds under
the liability threshold model for a given family structure and a single
phenotype. Please note that it is not possible to simulate different
family structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_under_LTM_single(
  fam_vec = c("m", "f", "s1", "mgm", "mgf", "pgm", "pgf"),
  n_fam = NULL,
  add_ind = TRUE,
  h2 = 0.5,
  n_sim = 1000,
  pop_prev = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_under_LTM_single_+3A_fam_vec">fam_vec</code></td>
<td>
<p>A vector of strings holding the different
family members. All family members must be represented by strings from the
following list:
</p>

<ul>
<li> <p><code>m</code> (Mother)
</p>
</li>
<li> <p><code>f</code> (Father)
</p>
</li>
<li> <p><code>c[0-9]*.[0-9]*</code> (Children)
</p>
</li>
<li> <p><code>mgm</code> (Maternal grandmother)
</p>
</li>
<li> <p><code>mgf</code> (Maternal grandfather)
</p>
</li>
<li> <p><code>pgm</code> (Paternal grandmother)
</p>
</li>
<li> <p><code>pgf</code> (Paternal grandfather)
</p>
</li>
<li> <p><code>s[0-9]*</code> (Full siblings)
</p>
</li>
<li> <p><code>mhs[0-9]*</code> (Half-siblings - maternal side)
</p>
</li>
<li> <p><code>phs[0-9]*</code> (Half-siblings - paternal side)
</p>
</li>
<li> <p><code>mau[0-9]*</code> (Aunts/Uncles - maternal side)
</p>
</li>
<li> <p><code>pau[0-9]*</code> (Aunts/Uncles - paternal side).
Defaults to <code>c("m","f","s1","mgm","mgf","pgm","pgf")</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_under_LTM_single_+3A_n_fam">n_fam</code></td>
<td>
<p>A named vector holding the desired number of family members.
See  <code><a href="stats.html#topic+setNames">setNames</a></code>.
All names must be picked from the list mentioned above. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_single_+3A_add_ind">add_ind</code></td>
<td>
<p>A logical scalar indicating whether the genetic
component of the full liability as well as the full
liability for the underlying target individual should be included in
the covariance matrix. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_single_+3A_h2">h2</code></td>
<td>
<p>A number representing the liability-scale heritability
for a single phenotype. Must be non-negative. Note that under
the liability threshold model, the heritability must also be at most 1.
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_single_+3A_n_sim">n_sim</code></td>
<td>
<p>A positive number representing the number of simulations. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="simulate_under_LTM_single_+3A_pop_prev">pop_prev</code></td>
<td>
<p>A positive number representing the population prevalence, i.e. the
overall prevalence in the population. Must be smaller than 1. Defaults to 0.1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If either <code>fam_vec</code> or <code>n_fam</code> is used as the argument,
if it is of the required format, if the liability-scale heritability <code>h2</code>
is a number satisfying <code class="reqn">0 \leq h^2</code>, <code>n_sim</code> is a strictly positive number,
and <code>pop_prev</code> is a positive number that is at most one,
then the output will be a list holding two tibbles.
The first tibble, <code>sim_obs</code>, holds the simulated liabilities, the disease
status and the current age/age-of-onset for all family members in each of the
<code>n_sim</code> families.
The second tibble, <code>thresholds</code>, holds the family identifier, the personal
identifier, the role (specified in fam_vec or n_fam) as well as
the lower and upper thresholds for all individuals in all families.
Note that this tibble has the format required in <code><a href="#topic+estimate_liability">estimate_liability</a></code>.
In addition, note that if neither <code>fam_vec</code> nor <code>n_fam</code> are specified, the function
returns the disease status, the current age/age-of-onset, the lower and upper
thresholds, as well as the personal identifier for a single individual, namely
the individual under consideration (called <code>o</code>).
If both <code>fam_vec</code> and <code>n_fam</code> are defined, the user is asked to '
decide on which of the two vectors to use.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+construct_covmat">construct_covmat</a></code>, <code><a href="#topic+simulate_under_LTM_multi">simulate_under_LTM_multi</a></code>, <code><a href="#topic+simulate_under_LTM">simulate_under_LTM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulate_under_LTM_single()
simulate_under_LTM_single(fam_vec = NULL, n_fam = stats::setNames(c(1,1,1,2), 
c("m","mgm","mgf","mhs")))
simulate_under_LTM_single(fam_vec = c("m","f","s1"), n_fam = NULL, add_ind = FALSE, 
h2 = 0.5, n_sim = 500, pop_prev = .05)
simulate_under_LTM_single(fam_vec = c(), n_fam = NULL, add_ind = TRUE, h2 = 0.5, 
n_sim = 200, pop_prev = 0.05)

</code></pre>

<hr>
<h2 id='truncated_normal_cdf'>CDF for truncated normal distribution.</h2><span id='topic+truncated_normal_cdf'></span>

<h3>Description</h3>

<p><code>truncated_normal_cdf</code> computes the cumulative density
function for a truncated normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncated_normal_cdf(
  liability,
  lower = stats::qnorm(0.05, lower.tail = FALSE),
  upper = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncated_normal_cdf_+3A_liability">liability</code></td>
<td>
<p>A number representing the individual's
true underlying liability.</p>
</td></tr>
<tr><td><code id="truncated_normal_cdf_+3A_lower">lower</code></td>
<td>
<p>A number representing the lower cutoff point for the
truncated normal distribution. Defaults to 1.645
(stats::qnorm(0.05, lower.tail = FALSE)).</p>
</td></tr>
<tr><td><code id="truncated_normal_cdf_+3A_upper">upper</code></td>
<td>
<p>A number representing the upper cutoff point of the
truncated normal distribution. Must be greater or equal to lower.
Defaults to Inf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to compute the value of the cumulative
density function for a truncated normal distribution given an
individual's true underlying liability.
</p>


<h3>Value</h3>

<p>If liability is a number and the lower and upper cutoff points
are numbers satisfying lower &lt;= upper, then <code>truncated_normal_cdf</code>
returns the probability that the liability will take on a value less than
or equal to <code>liability</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(sapply(liability, truncated_normal_cdf), from = qnorm(0.05, lower.tail = FALSE), to = 3.5,
 xname = "liability")
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
