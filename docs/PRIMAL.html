<!DOCTYPE html><html><head><title>Help for package PRIMAL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PRIMAL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PRIMAL-package'><p>Parametric Simplex Method for Sparse Learning</p></a></li>
<li><a href='#coef.primal'><p>Coef function for S3 class &quot;primal&quot;</p></a></li>
<li><a href='#CompressedSensing_solver'><p>Solve given compressed sensing problem in parametric simplex method</p></a></li>
<li><a href='#Dantzig_solver'><p>Solve given Dantzig selector problem in parametric simplex method</p></a></li>
<li><a href='#plot.primal'><p>Plot function for S3 class &quot;primal&quot;</p></a></li>
<li><a href='#print.primal'><p>Print function for S3 class &quot;primal&quot;</p></a></li>
<li><a href='#PSM_solver'><p>Solve given problem in parametric simplex method</p></a></li>
<li><a href='#QuantileRegression_solver'><p>Solve given quantile regression problem in parametric simplex method</p></a></li>
<li><a href='#SparseSVM_solver'><p>Solve given Sparse SVM problem in parametric simplex method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parametric Simplex Method for Sparse Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Zichong Li, Qianli Shen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zichong Li &lt;zichongli5@gmail.com&gt;</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a unified framework of parametric simplex method for a variety of sparse learning problems (e.g., Dantzig selector (for linear regression), sparse quantile regression, sparse support vector machines, and compressive sensing) combined with efficient hyper-parameter selection strategies. The core algorithm is implemented in C++ with Eigen3 support for portable high performance linear algebra. For more details about parametric simplex method, see Haotian Pang (2017) <a href="https://papers.nips.cc/paper/6623-parametric-simplex-method-for-sparse-learning.pdf">https://papers.nips.cc/paper/6623-parametric-simplex-method-for-sparse-learning.pdf</a>.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-22 09:22:31 UTC; lizichong</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-22 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PRIMAL-package'>Parametric Simplex Method for Sparse Learning</h2><span id='topic+PRIMAL-package'></span><span id='topic+_PACKAGE'></span><span id='topic+primal-package'></span>

<h3>Description</h3>

<p>A package for parametric simplex method for sparse learning
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> PRIMAL</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 1.0.0</td>
</tr>
<tr>
 <td style="text-align: left;">
  Date: </td><td style="text-align: left;"> 2019-08-15</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package &quot;PRIMAL&quot; provides 5 main functions:<br />
(1) The dantzig selector solver applying simplex method. Please refer to <code><a href="#topic+Dantzig_solver">Dantzig_solver</a></code>.<br />
(2) The sparse SVM solver applying simplex method. Please refer to <code><a href="#topic+SparseSVM_solver">SparseSVM_solver</a></code>.<br />
(3) The compressed sensing solver. Please refer to <code><a href="#topic+CompressedSensing_solver">CompressedSensing_solver</a></code>.<br />
(4) The quantile regression solver. Please refer to <code><a href="#topic+QuantileRegression_solver">QuantileRegression_solver</a></code>.<br />
(5) The solver for standard formulation of parametric simplex method. Please refer to <code><a href="#topic+PSM_solver">PSM_solver</a></code>.<br />
</p>


<h3>Author(s)</h3>

<p>Qianli Shen, Zichong Li <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.primal">plot.primal</a></code>, <code><a href="#topic+print.primal">print.primal</a></code>, <code><a href="#topic+coef.primal">coef.primal</a></code>
</p>

<hr>
<h2 id='coef.primal'>Coef function for S3 class &quot;primal&quot;</h2><span id='topic+coef.primal'></span>

<h3>Description</h3>

<p>Print the estimated solution correspond to a specific parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'primal'
coef(object, n = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.primal_+3A_object">object</code></td>
<td>
<p>An object with S3 class <code>"primal"</code>.</p>
</td></tr>
<tr><td><code id="coef.primal_+3A_n">n</code></td>
<td>
<p>The index of the wanted parameter.</p>
</td></tr>
<tr><td><code id="coef.primal_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Dantzig_solver">Dantzig_solver</a></code>, <code><a href="#topic+SparseSVM_solver">SparseSVM_solver</a></code>
</p>

<hr>
<h2 id='CompressedSensing_solver'>Solve given compressed sensing problem in parametric simplex method</h2><span id='topic+CompressedSensing_solver'></span>

<h3>Description</h3>

<p>Solve given compressed sensing problem in parametric simplex method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompressedSensing_solver(X, y, max_it = 50, lambda_threshold = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompressedSensing_solver_+3A_x">X</code></td>
<td>
<p><code>x</code> is an <code>n</code> by <code>d</code> data matrix</p>
</td></tr>
<tr><td><code id="CompressedSensing_solver_+3A_y">y</code></td>
<td>
<p><code>y</code> is a length <code>n</code> response vector</p>
</td></tr>
<tr><td><code id="CompressedSensing_solver_+3A_max_it">max_it</code></td>
<td>
<p>This is the number of the maximum path length one would like to achieve. The default length is <code>50</code>.</p>
</td></tr>
<tr><td><code id="CompressedSensing_solver_+3A_lambda_threshold">lambda_threshold</code></td>
<td>
<p>The parametric simplex method will stop when the calculated parameter is smaller than lambda. The default value is <code>0.01</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"primal"</code> is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> data matrix from the input
</p>
</td></tr>
<tr><td><code>response</code></td>
<td>

<p>The length <code>n</code> response vector from the input
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>A matrix of regression estimates whose columns correspond to regularization parameters for parametric simplex method.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freedom (number of nonzero coefficients) along the solution path.
</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>The sequence of optimal value of the object function corresponded to the sequence of lambda.
</p>
</td></tr>
<tr><td><code>iterN</code></td>
<td>

<p>The number of iteration in the program.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The sequence of regularization parameters <code>lambda</code> obtained in the program.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>

<p>The type of the problem, such as <code>Dantzig</code> and <code>SparseSVM</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+primal-package">primal-package</a></code>, <code><a href="#topic+Dantzig_solver">Dantzig_solver</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compressed Sensing
## We set X to be standard normal random matrix and generate Y using gaussian noise.
## Generate the design matrix and coefficient vector
n = 100 # sample number
d = 250 # sample dimension
c = 0.5 # correlation parameter
s = 20  # support size of coefficient
set.seed(1024)
X = scale(matrix(rnorm(n*d),n,d)+c*rnorm(n))/sqrt(n-1)*sqrt(n)
beta = c(rnorm(s), rep(0, d-s))
## Generate response using Gaussian noise, and solve the solution path
noise = rnorm(n)
Y = X%*%beta + noise
## Compressed Sensing solved with parametric simplex method
fit.compressed = CompressedSensing_solver(X, Y, max_it = 100, lambda_threshold = 0.01)
###lambdas used
print(fit.compressed$lambda)
## number of nonzero coefficients for each lambda
print(fit.compressed$df)
## Visualize the solution path
plot(fit.compressed)
</code></pre>

<hr>
<h2 id='Dantzig_solver'>Solve given Dantzig selector problem in parametric simplex method</h2><span id='topic+Dantzig_solver'></span>

<h3>Description</h3>

<p>Solve given Dantzig selector problem in parametric simplex method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dantzig_solver(X, y, max_it = 50, lambda_threshold = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dantzig_solver_+3A_x">X</code></td>
<td>
<p><code>x</code> is an <code>n</code> by <code>d</code> data matrix</p>
</td></tr>
<tr><td><code id="Dantzig_solver_+3A_y">y</code></td>
<td>
<p><code>y</code> is a length <code>n</code> response vector</p>
</td></tr>
<tr><td><code id="Dantzig_solver_+3A_max_it">max_it</code></td>
<td>
<p>This is the number of the maximum path length one would like to achieve. The default length is <code>50</code>.</p>
</td></tr>
<tr><td><code id="Dantzig_solver_+3A_lambda_threshold">lambda_threshold</code></td>
<td>
<p>The parametric simplex method will stop when the calculated parameter is smaller than lambda. The default value is <code>0.01</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"primal"</code> is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> data matrix from the input
</p>
</td></tr>
<tr><td><code>response</code></td>
<td>

<p>The length <code>n</code> response vector from the input
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>A matrix of regression estimates whose columns correspond to regularization parameters for parametric simplex method.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freedom (number of nonzero coefficients) along the solution path.
</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>The sequence of optimal value of the object function corresponded to the sequence of lambda.
</p>
</td></tr>
<tr><td><code>iterN</code></td>
<td>

<p>The number of iteration in the program.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The sequence of regularization parameters <code>lambda</code> obtained in the program.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>

<p>The type of the problem, such as <code>Dantzig</code> and <code>SparseSVM</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+primal-package">primal-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Dantzig
## We set X to be standard normal random matrix and generate Y using gaussian noise.
## Generate the design matrix and coefficient vector
n = 100 # sample number
d = 250 # sample dimension
c = 0.5 # correlation parameter
s = 20  # support size of coefficient
set.seed(1024)
X = scale(matrix(rnorm(n*d),n,d)+c*rnorm(n))/sqrt(n-1)*sqrt(n)
beta = c(rnorm(s), rep(0, d-s))
## Generate response using Gaussian noise, and solve the solution path
noise = rnorm(n)
Y = X%*%beta + noise
## Dantzig selection solved with parametric simplex method
fit.dantzig = Dantzig_solver(X, Y, max_it = 100, lambda_threshold = 0.01)
###lambdas used
print(fit.dantzig$lambda)
## number of nonzero coefficients for each lambda
print(fit.dantzig$df)
## Visualize the solution path
plot(fit.dantzig)
</code></pre>

<hr>
<h2 id='plot.primal'>Plot function for S3 class &quot;primal&quot;</h2><span id='topic+plot.primal'></span>

<h3>Description</h3>

<p>Plot regularization path and parameter obtained from the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'primal'
plot(x, n = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.primal_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"primal"</code></p>
</td></tr>
<tr><td><code id="plot.primal_+3A_n">n</code></td>
<td>
<p>If <code>n = NULL</code>, three graph will be shown together. If <code>n</code> is a number, then the corresponding graph will be shown.</p>
</td></tr>
<tr><td><code id="plot.primal_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Dantzig_solver">Dantzig_solver</a></code>, <code><a href="#topic+SparseSVM_solver">SparseSVM_solver</a></code>
</p>

<hr>
<h2 id='print.primal'>Print function for S3 class &quot;primal&quot;</h2><span id='topic+print.primal'></span>

<h3>Description</h3>

<p>Print the information about the model usage, the parameter path, degree of freedom of the solution path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'primal'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.primal_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"primal"</code>.</p>
</td></tr>
<tr><td><code id="print.primal_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Dantzig_solver">Dantzig_solver</a></code>, <code><a href="#topic+SparseSVM_solver">SparseSVM_solver</a></code>
</p>

<hr>
<h2 id='PSM_solver'>Solve given problem in parametric simplex method</h2><span id='topic+PSM_solver'></span>

<h3>Description</h3>

<p>Solve given problem in parametric simplex method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSM_solver(A, b, b_bar, c, c_bar, B_init = NULL, max_it = 50,
  lambda_threshold = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSM_solver_+3A_a">A</code></td>
<td>
<p><code>A</code> is an <code>n</code> by <code>d</code> data matrix</p>
</td></tr>
<tr><td><code id="PSM_solver_+3A_b">b</code></td>
<td>
<p><code>b</code> is a length <code>n</code> response vector</p>
</td></tr>
<tr><td><code id="PSM_solver_+3A_b_bar">b_bar</code></td>
<td>
<p><code>b_bar</code> is a length <code>n</code> vector time to parameter in constraints.</p>
</td></tr>
<tr><td><code id="PSM_solver_+3A_c">c</code></td>
<td>
<p><code>c</code> is a length <code>d</code> vector in target function.</p>
</td></tr>
<tr><td><code id="PSM_solver_+3A_c_bar">c_bar</code></td>
<td>
<p><code>c_bar</code> is a length <code>d</code> vector time to parameter in target function</p>
</td></tr>
<tr><td><code id="PSM_solver_+3A_b_init">B_init</code></td>
<td>
<p><code>B_init</code> is the index of initial basic colume.</p>
</td></tr>
<tr><td><code id="PSM_solver_+3A_max_it">max_it</code></td>
<td>
<p>This is the number of the maximum path length one would like to achieve. The default length is <code>50</code>.</p>
</td></tr>
<tr><td><code id="PSM_solver_+3A_lambda_threshold">lambda_threshold</code></td>
<td>
<p>The parametric simplex method will stop when the calculated parameter is smaller than lambda. The default value is <code>0.01</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"primal"</code> is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> data matrix from the input
</p>
</td></tr>
<tr><td><code>response</code></td>
<td>

<p>The length <code>n</code> response vector from the input
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>A matrix of regression estimates whose columns correspond to regularization parameters for parametric simplex method.
</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>

<p>A vector of regression estimates whose index correspond to regularization parameters for parametric simplex method.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freecom (number of nonzero coefficients) along the solution path.
</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>The sequence of optimal value of the object function corresponded to the sequence of lambda.
</p>
</td></tr>
<tr><td><code>iterN</code></td>
<td>

<p>The number of iteration in the program.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The sequence of regularization parameters <code>lambda</code> obtained in the program.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>

<p>The type of the problem, such as <code>Dantzig</code> and <code>SparseSVM</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+primal-package">primal-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example show how to use PSM_solver() to solve dantzig problem.
## Generate the design matrix and coefficient vector
n = 100 # sample number
d = 250 # sample dimension
c = 0.5 # correlation parameter
s = 20  # support size of coefficient
set.seed(1024)
X = scale(matrix(rnorm(n*d),n,d)+c*rnorm(n))/sqrt(n-1)*sqrt(n)
beta = c(rnorm(s), rep(0, d-s))
## Generate response using Gaussian noise, and solve the solution path
noise = rnorm(n)
Y = X%*%beta + noise
## Define parameters for dantzig problem
XtX = t(X)%*%X
A = cbind(cbind(rbind(XtX,-XtX),-rbind(XtX,-XtX)),diag(rep(1,2*d)))
b = rbind(t(X)%*%Y,-t(X)%*%Y)
c = c(rep(-1,2*d),rep(0,2*d))
c_bar = rep(0,4*d)
b_bar = rep(1,2*d)
B_init = seq(2*d,4*d-1)
## Dantzig selection solved with parametric simplex method
fit.dantzig = PSM_solver(A, b, b_bar, c, c_bar, B_init, max_it = 50, lambda_threshold = 0.01)
###lambdas used
print(fit.dantzig$lambda)
## number of nonzero coefficients for each lambda
print(fit.dantzig$df)
## Visualize the solution path
plot(fit.dantzig)
</code></pre>

<hr>
<h2 id='QuantileRegression_solver'>Solve given quantile regression problem in parametric simplex method</h2><span id='topic+QuantileRegression_solver'></span>

<h3>Description</h3>

<p>Solve given quantile regression problem in parametric simplex method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuantileRegression_solver(X, y, max_it = 50, lambda_threshold = 0.01,
  tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuantileRegression_solver_+3A_x">X</code></td>
<td>
<p><code>x</code> is an <code>n</code> by <code>d</code> data matrix</p>
</td></tr>
<tr><td><code id="QuantileRegression_solver_+3A_y">y</code></td>
<td>
<p><code>y</code> is a length <code>n</code> response vector</p>
</td></tr>
<tr><td><code id="QuantileRegression_solver_+3A_max_it">max_it</code></td>
<td>
<p>This is the number of the maximum path length one would like to achieve. The default length is <code>50</code>.</p>
</td></tr>
<tr><td><code id="QuantileRegression_solver_+3A_lambda_threshold">lambda_threshold</code></td>
<td>
<p>The parametric simplex method will stop when the calculated parameter is smaller than lambda. The default value is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="QuantileRegression_solver_+3A_tau">tau</code></td>
<td>
<p>The quantile number you want. The default quantile is <code>0.5</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"primal"</code> is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> data matrix from the input
</p>
</td></tr>
<tr><td><code>response</code></td>
<td>

<p>The length <code>n</code> response vector from the input
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>A matrix of regression estimates whose columns correspond to regularization parameters for parametric simplex method.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freedom (number of nonzero coefficients) along the solution path.
</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>The sequence of optimal value of the object function corresponded to the sequence of lambda.
</p>
</td></tr>
<tr><td><code>iterN</code></td>
<td>

<p>The number of iteration in the program.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The sequence of regularization parameters <code>lambda</code> obtained in the program.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>

<p>The type of the problem, such as <code>Dantzig</code> and <code>SparseSVM</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+primal-package">primal-package</a></code>, <code><a href="#topic+Dantzig_solver">Dantzig_solver</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Quantile Regression
## We set X to be standard normal random matrix and generate Y using gaussian noise
## with default quantile number to be 0.5.
## Generate the design matrix and coefficient vector
n = 100 # sample number
d = 250 # sample dimension
c = 0.5 # correlation parameter
s = 20  # support size of coefficient
set.seed(1024)
X = scale(matrix(rnorm(n*d),n,d)+c*rnorm(n))/sqrt(n-1)*sqrt(n)
beta = c(rnorm(s), rep(0, d-s))
## Generate response using Gaussian noise, and solve the solution path
noise = rnorm(n)
Y = X%*%beta + noise
## Quantile Regression problem solved with parametric simplex method
fit.quantile = QuantileRegression_solver(X, Y, max_it = 100, lambda_threshold = 0.01)
###lambdas used
print(fit.quantile$lambda)
## number of nonzero coefficients for each lambda
print(fit.quantile$df)
## Visualize the solution path
plot(fit.quantile)
</code></pre>

<hr>
<h2 id='SparseSVM_solver'>Solve given Sparse SVM problem in parametric simplex method</h2><span id='topic+SparseSVM_solver'></span>

<h3>Description</h3>

<p>Solve given Sparse SVM problem in parametric simplex method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseSVM_solver(X, y, max_it = 50, lambda_threshold = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseSVM_solver_+3A_x">X</code></td>
<td>
<p><code>x</code> is an <code>n</code> by <code>d</code> data matrix</p>
</td></tr>
<tr><td><code id="SparseSVM_solver_+3A_y">y</code></td>
<td>
<p><code>y</code> is a length <code>n</code> response vector</p>
</td></tr>
<tr><td><code id="SparseSVM_solver_+3A_max_it">max_it</code></td>
<td>
<p>This is the number of the maximum path length one would like to achieve. The default length is <code>50</code>.</p>
</td></tr>
<tr><td><code id="SparseSVM_solver_+3A_lambda_threshold">lambda_threshold</code></td>
<td>
<p>The parametric simplex method will stop when the calculated parameter is smaller than lambda. The default value is <code>0.01</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"primal"</code> is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> data matrix from the input
</p>
</td></tr>
<tr><td><code>response</code></td>
<td>

<p>The length <code>n</code> response vector from the input
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>A matrix of regression estimates whose columns correspond to regularization parameters for parametric simplex method.
</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>

<p>A vector of regression estimates whose index correspond to regularization parameters for parametric simplex method.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freecom (number of nonzero coefficients) along the solution path.
</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>The sequence of optimal value of the object function corresponded to the sequence of lambda.
</p>
</td></tr>
<tr><td><code>iterN</code></td>
<td>

<p>The number of iteration in the program.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The sequence of regularization parameters <code>lambda</code> obtained in the program.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>

<p>The type of the problem, such as <code>Dantzig</code> and <code>SparseSVM</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+primal-package">primal-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SparseSVM
## We set the X matrix to be normal random matrix and Y is a vector consists of -1 and 1
## with the number of iteration to be 1000.
## Generate the design matrix and coefficient vector
n = 200 # sample number
d = 100 # sample dimension
c = 0.5 # correlation parameter
s = 20  # support size of coefficient
set.seed(1024)
X = matrix(rnorm(n*d),n,d)+c*rnorm(n)
## Generate response and solve the solution path
Y &lt;- sample(c(-1,1),n,replace = TRUE)
## Sparse SVM solved with parametric simplex method
fit.SVM = SparseSVM_solver(X, Y, max_it = 1000, lambda_threshold = 0.01)
## lambdas used
print(fit.SVM$lambda)
## Visualize the solution path
plot(fit.SVM)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
