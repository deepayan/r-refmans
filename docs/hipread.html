<!DOCTYPE html><html><head><title>Help for package hipread</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hipread}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#callback'><p>Callback classes</p></a></li>
<li><a href='#hip_fwf_positions'><p>Specify column-specific options for hipread</p></a></li>
<li><a href='#hip_rt'><p>Create a record type information object</p></a></li>
<li><a href='#hipread_example'><p>Get path to hipread's example datasets</p></a></li>
<li><a href='#hipread_freqs'><p>Calculate frequencies from fixed width file without loading into memory</p></a></li>
<li><a href='#hipread_long'><p>Read a hierarchical fixed width data file</p></a></li>
<li><a href='#hipread_long_chunked'><p>Read a hierarchical fixed width data file, in chunks</p></a></li>
<li><a href='#hipread_long_yield'><p>Read a hierarchical fixed width data file, in yields</p></a></li>
<li><a href='#hipread-package'><p>hipread: Read Hierarchical Fixed Width Files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read Hierarchical Fixed Width Files</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Contact:</td>
<td>ipums@umn.edu</td>
</tr>
<tr>
<td>Description:</td>
<td>Read hierarchical fixed width files like those commonly used by 
    many census data providers. Also allows for reading of data in chunks,
    and reading 'gzipped' files without storing the full file in memory.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, R6, rlang, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, readr, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 15:17:31 UTC; Derek</td>
</tr>
<tr>
<td>Author:</td>
<td>Greg Freedman Ellis [aut],
  Derek Burk [aut, cre],
  Joe Grover [ctb],
  Mark Padgham [ctb],
  Hadley Wickham [ctb] (Code adapted from readr),
  Jim Hester [ctb] (Code adapted from readr),
  Romain Francois [ctb] (Code adapted from readr),
  R Core Team [ctb] (Code adapted from readr),
  RStudio [cph, fnd] (Code adapted from readr),
  Jukka Jylänki [ctb, cph] (Code adapted from readr),
  Mikkel Jørgensen [ctb, cph] (Code adapted from readr),
  University of Minnesota [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Derek Burk &lt;ipums+cran@umn.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='callback'>Callback classes</h2><span id='topic+callback'></span><span id='topic+ChunkCallback'></span><span id='topic+HipChunkCallback'></span><span id='topic+HipSideEffectChunkCallback'></span><span id='topic+HipListCallback'></span><span id='topic+HipDataFrameCallback'></span>

<h3>Description</h3>

<p>These classes are used to define callback behaviors, and are based
on readr's <code><a href="readr.html#topic+callback">readr::callback</a></code> functions.
</p>


<h3>Details</h3>


<ul>
<li><p> The callbacks <code>HipChunkCallback</code>, <code>HipListCallback</code> and
<code>HipSideEffectChunkCallback</code> should be identical to their readr
counterparts, but have been copied into hipread to ensure that they
work even if readr changes.
</p>
</li>
<li><p> The callback <code>HipDataFrameCallback</code> is similar to
readr::DataFrameCallback() except that it uses <code>dplyr::bind_rows()</code>
instead of <code>rbind()</code> so that it is faster.
</p>
</li></ul>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ChunkCallback-new"><code>ChunkCallback$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-receive"><code>ChunkCallback$receive()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-continue"><code>ChunkCallback$continue()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-result"><code>ChunkCallback$result()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-finally"><code>ChunkCallback$finally()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-clone"><code>ChunkCallback$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ChunkCallback-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$new(callback)</pre></div>


<hr>
<a id="method-ChunkCallback-receive"></a>



<h4>Method <code>receive()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$receive(data, index)</pre></div>


<hr>
<a id="method-ChunkCallback-continue"></a>



<h4>Method <code>continue()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$continue()</pre></div>


<hr>
<a id="method-ChunkCallback-result"></a>



<h4>Method <code>result()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$result()</pre></div>


<hr>
<a id="method-ChunkCallback-finally"></a>



<h4>Method <code>finally()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$finally()</pre></div>


<hr>
<a id="method-ChunkCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super class</h3>

<p><code><a href="#topic+ChunkCallback">hipread::ChunkCallback</a></code> -&gt; <code>HipChunkCallback</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HipChunkCallback-clone"><code>HipChunkCallback$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="hipread" data-topic="ChunkCallback" data-id="continue"><a href='../../hipread/html/ChunkCallback.html#method-ChunkCallback-continue'><code>hipread::ChunkCallback$continue()</code></a></span></li>
<li><span class="pkg-link" data-pkg="hipread" data-topic="ChunkCallback" data-id="finally"><a href='../../hipread/html/ChunkCallback.html#method-ChunkCallback-finally'><code>hipread::ChunkCallback$finally()</code></a></span></li>
<li><span class="pkg-link" data-pkg="hipread" data-topic="ChunkCallback" data-id="initialize"><a href='../../hipread/html/ChunkCallback.html#method-ChunkCallback-initialize'><code>hipread::ChunkCallback$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="hipread" data-topic="ChunkCallback" data-id="receive"><a href='../../hipread/html/ChunkCallback.html#method-ChunkCallback-receive'><code>hipread::ChunkCallback$receive()</code></a></span></li>
<li><span class="pkg-link" data-pkg="hipread" data-topic="ChunkCallback" data-id="result"><a href='../../hipread/html/ChunkCallback.html#method-ChunkCallback-result'><code>hipread::ChunkCallback$result()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-HipChunkCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HipChunkCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+ChunkCallback">hipread::ChunkCallback</a></code> -&gt; <code><a href="#topic+HipChunkCallback">hipread::HipChunkCallback</a></code> -&gt; <code>HipSideEffectChunkCallback</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HipSideEffectChunkCallback-new"><code>HipSideEffectChunkCallback$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HipSideEffectChunkCallback-receive"><code>HipSideEffectChunkCallback$receive()</code></a>
</p>
</li>
<li> <p><a href="#method-HipSideEffectChunkCallback-continue"><code>HipSideEffectChunkCallback$continue()</code></a>
</p>
</li>
<li> <p><a href="#method-HipSideEffectChunkCallback-clone"><code>HipSideEffectChunkCallback$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="hipread" data-topic="ChunkCallback" data-id="finally"><a href='../../hipread/html/ChunkCallback.html#method-ChunkCallback-finally'><code>hipread::ChunkCallback$finally()</code></a></span></li>
<li><span class="pkg-link" data-pkg="hipread" data-topic="ChunkCallback" data-id="result"><a href='../../hipread/html/ChunkCallback.html#method-ChunkCallback-result'><code>hipread::ChunkCallback$result()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-HipSideEffectChunkCallback-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipSideEffectChunkCallback$new(callback)</pre></div>


<hr>
<a id="method-HipSideEffectChunkCallback-receive"></a>



<h4>Method <code>receive()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipSideEffectChunkCallback$receive(data, index)</pre></div>


<hr>
<a id="method-HipSideEffectChunkCallback-continue"></a>



<h4>Method <code>continue()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipSideEffectChunkCallback$continue()</pre></div>


<hr>
<a id="method-HipSideEffectChunkCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HipSideEffectChunkCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+ChunkCallback">hipread::ChunkCallback</a></code> -&gt; <code><a href="#topic+HipChunkCallback">hipread::HipChunkCallback</a></code> -&gt; <code>HipListCallback</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HipListCallback-new"><code>HipListCallback$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HipListCallback-receive"><code>HipListCallback$receive()</code></a>
</p>
</li>
<li> <p><a href="#method-HipListCallback-result"><code>HipListCallback$result()</code></a>
</p>
</li>
<li> <p><a href="#method-HipListCallback-finally"><code>HipListCallback$finally()</code></a>
</p>
</li>
<li> <p><a href="#method-HipListCallback-clone"><code>HipListCallback$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="hipread" data-topic="ChunkCallback" data-id="continue"><a href='../../hipread/html/ChunkCallback.html#method-ChunkCallback-continue'><code>hipread::ChunkCallback$continue()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-HipListCallback-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipListCallback$new(callback)</pre></div>


<hr>
<a id="method-HipListCallback-receive"></a>



<h4>Method <code>receive()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipListCallback$receive(data, index)</pre></div>


<hr>
<a id="method-HipListCallback-result"></a>



<h4>Method <code>result()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipListCallback$result()</pre></div>


<hr>
<a id="method-HipListCallback-finally"></a>



<h4>Method <code>finally()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipListCallback$finally()</pre></div>


<hr>
<a id="method-HipListCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HipListCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+ChunkCallback">hipread::ChunkCallback</a></code> -&gt; <code><a href="#topic+HipChunkCallback">hipread::HipChunkCallback</a></code> -&gt; <code>HipDataFrameCallback</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HipDataFrameCallback-new"><code>HipDataFrameCallback$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HipDataFrameCallback-receive"><code>HipDataFrameCallback$receive()</code></a>
</p>
</li>
<li> <p><a href="#method-HipDataFrameCallback-result"><code>HipDataFrameCallback$result()</code></a>
</p>
</li>
<li> <p><a href="#method-HipDataFrameCallback-finally"><code>HipDataFrameCallback$finally()</code></a>
</p>
</li>
<li> <p><a href="#method-HipDataFrameCallback-clone"><code>HipDataFrameCallback$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="hipread" data-topic="ChunkCallback" data-id="continue"><a href='../../hipread/html/ChunkCallback.html#method-ChunkCallback-continue'><code>hipread::ChunkCallback$continue()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-HipDataFrameCallback-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipDataFrameCallback$new(callback)</pre></div>


<hr>
<a id="method-HipDataFrameCallback-receive"></a>



<h4>Method <code>receive()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipDataFrameCallback$receive(data, index)</pre></div>


<hr>
<a id="method-HipDataFrameCallback-result"></a>



<h4>Method <code>result()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipDataFrameCallback$result()</pre></div>


<hr>
<a id="method-HipDataFrameCallback-finally"></a>



<h4>Method <code>finally()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipDataFrameCallback$finally()</pre></div>


<hr>
<a id="method-HipDataFrameCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HipDataFrameCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='hip_fwf_positions'>Specify column-specific options for hipread</h2><span id='topic+hip_fwf_positions'></span><span id='topic+hip_fwf_widths'></span>

<h3>Description</h3>

<p>Specify column specifications analogous to <code>readr::fwf_positions()</code>.
However, unlike in readr, the column type information is specified
alongside the column positions and there are two extra options that
can be specified (<code>trim_ws</code> gives control over trimming whitespace
in character columns, and <code>imp_dec</code> allows for implicit decimals in
double columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hip_fwf_positions(
  start,
  end,
  col_names,
  col_types,
  trim_ws = TRUE,
  imp_dec = 0
)

hip_fwf_widths(widths, col_names, col_types, trim_ws = TRUE, imp_dec = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hip_fwf_positions_+3A_start">start</code>, <code id="hip_fwf_positions_+3A_end">end</code></td>
<td>
<p>A vector integers describing the start and end positions
of each field</p>
</td></tr>
<tr><td><code id="hip_fwf_positions_+3A_col_names">col_names</code></td>
<td>
<p>A character vector of variable names</p>
</td></tr>
<tr><td><code id="hip_fwf_positions_+3A_col_types">col_types</code></td>
<td>
<p>A vector of column types (specified as either
&quot;c&quot; or &quot;character&quot; for character, &quot;d&quot; or &quot;double&quot; for double and
&quot;i&quot; or &quot;integer&quot; for integer).</p>
</td></tr>
<tr><td><code id="hip_fwf_positions_+3A_trim_ws">trim_ws</code></td>
<td>
<p>A logical vector, indicating whether to trim whitespace
on both sides of character columns (Defaults to <code>TRUE</code>, ignored on
non-character columns).</p>
</td></tr>
<tr><td><code id="hip_fwf_positions_+3A_imp_dec">imp_dec</code></td>
<td>
<p>An integer vector, indicating the number of implicit decimals
on a double variable (Defaults to 0, ignored on non-double columns).</p>
</td></tr>
<tr><td><code id="hip_fwf_positions_+3A_widths">widths</code></td>
<td>
<p>A vector of integer widths for each field (assumes that
columns are consecutive - that there is no overlap or gap between fields)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the column specifications
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 3 Columns, specified by position
hip_fwf_positions(
  c(1, 3, 7),
  c(2, 6, 10),
  c("Var1", "Var2", "Var3"),
  c("c", "i", "d")
)

# The same 3 columns, specified by width
hip_fwf_widths(
  c(2, 4, 4),
  c("Var1", "Var2", "Var3"),
  c("c", "i", "d")
)

</code></pre>

<hr>
<h2 id='hip_rt'>Create a record type information object</h2><span id='topic+hip_rt'></span>

<h3>Description</h3>

<p>Create a record type information object for hipread to use
when reading hierarchical files. A width of 0 indicates that
the file is rectangular (eg a standard fixed width file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hip_rt(start, width, warn_on_missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hip_rt_+3A_start">start</code></td>
<td>
<p>Start position of the record type variable</p>
</td></tr>
<tr><td><code id="hip_rt_+3A_width">width</code></td>
<td>
<p>The width of the record type variable</p>
</td></tr>
<tr><td><code id="hip_rt_+3A_warn_on_missing">warn_on_missing</code></td>
<td>
<p>Whether to warn when encountering a
record type that is not specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, really only intended to be used internally by hipread
</p>

<hr>
<h2 id='hipread_example'>Get path to hipread's example datasets</h2><span id='topic+hipread_example'></span>

<h3>Description</h3>

<p>Get access to example extracts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipread_example(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hipread_example_+3A_path">path</code></td>
<td>
<p>Name of file. If <code>NULL</code>, the example files will be listed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filepath to an example file, or if path is empty, a vector of all
available files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hipread_example() # Lists all available examples
hipread_example("test-basic.dat") # Gives filepath for a basic example
</code></pre>

<hr>
<h2 id='hipread_freqs'>Calculate frequencies from fixed width file without loading into memory</h2><span id='topic+hipread_freqs'></span>

<h3>Description</h3>

<p>Calculate the frequency of values in all variables in a fixed width file.
Does so without holding the whole data in memory or creating a full
R data.frame and calling R code on interim pieces. (Probably only
useful inside IPUMS HQ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipread_freqs(
  file,
  var_info,
  rt_info = hip_rt(1, 0),
  compression = NULL,
  progress = show_progress()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hipread_freqs_+3A_file">file</code></td>
<td>
<p>A filename</p>
</td></tr>
<tr><td><code id="hipread_freqs_+3A_var_info">var_info</code></td>
<td>
<p>Variable information, specified by either <code><a href="#topic+hip_fwf_positions">hip_fwf_positions()</a></code>
or <code>hip_fwf_widths()</code>. For hierarchical data files, there should be a named list,
where the name is the value indicated by the record type variable and there is
one variable information per record type.</p>
</td></tr>
<tr><td><code id="hipread_freqs_+3A_rt_info">rt_info</code></td>
<td>
<p>A record type information object, created by <code><a href="#topic+hip_rt">hip_rt()</a></code>, which
contains information about the location of the record type variable that
defines the record type for each observation. The default contains width
0, which indicates that there the data is rectangular and does not have
a record type variable.</p>
</td></tr>
<tr><td><code id="hipread_freqs_+3A_compression">compression</code></td>
<td>
<p>If <code>NULL</code>, guesses the compression from the
file extension (if extension is &quot;gz&quot; uses gzip, otherwise
treats as plain text), can specify it with a string (&quot;txt&quot;
indicates plain text and &quot;gz&quot; for gzip).</p>
</td></tr>
<tr><td><code id="hipread_freqs_+3A_progress">progress</code></td>
<td>
<p>A logical indicating whether progress should be
displayed on the screen, defaults to showing progress unless
the current context is non-interactive or in a knitr document or
if the user has turned off readr's progress by default using
the option <code>options("readr.show_progress")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of frequencies
</p>

<hr>
<h2 id='hipread_long'>Read a hierarchical fixed width data file</h2><span id='topic+hipread_long'></span><span id='topic+hipread_list'></span>

<h3>Description</h3>

<p>Analogous to <code><a href="readr.html#topic+read_fwf">readr::read_fwf()</a></code> but allowing for
hierarchical fixed width data files (where the data file has rows of
different record types, each with their own variables and column
specifications). <code>hipread_long()</code> reads hierarchical data into &quot;long&quot;
format, meaning that there is one row per observation, and variables
that don't apply to the current observation receive missing values.
Alternatively, <code>hipread_list()</code> reads hierarchical data into &quot;list&quot;
format, which returns a list that has one data.frame per record type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipread_long(
  file,
  var_info,
  rt_info = hip_rt(1, 0),
  compression = NULL,
  skip = 0,
  n_max = -1,
  encoding = "UTF-8",
  progress = show_progress()
)

hipread_list(
  file,
  var_info,
  rt_info = hip_rt(1, 0),
  compression = NULL,
  skip = 0,
  n_max = -1,
  encoding = "UTF-8",
  progress = show_progress()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hipread_long_+3A_file">file</code></td>
<td>
<p>A filename</p>
</td></tr>
<tr><td><code id="hipread_long_+3A_var_info">var_info</code></td>
<td>
<p>Variable information, specified by either <code><a href="#topic+hip_fwf_positions">hip_fwf_positions()</a></code>
or <code>hip_fwf_widths()</code>. For hierarchical data files, there should be a named list,
where the name is the value indicated by the record type variable and there is
one variable information per record type.</p>
</td></tr>
<tr><td><code id="hipread_long_+3A_rt_info">rt_info</code></td>
<td>
<p>A record type information object, created by <code><a href="#topic+hip_rt">hip_rt()</a></code>, which
contains information about the location of the record type variable that
defines the record type for each observation. The default contains width
0, which indicates that there the data is rectangular and does not have
a record type variable.</p>
</td></tr>
<tr><td><code id="hipread_long_+3A_compression">compression</code></td>
<td>
<p>If <code>NULL</code>, guesses the compression from the
file extension (if extension is &quot;gz&quot; uses gzip, otherwise
treats as plain text), can specify it with a string (&quot;txt&quot;
indicates plain text and &quot;gz&quot; for gzip).</p>
</td></tr>
<tr><td><code id="hipread_long_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip at the start of the data (defaults to 0).</p>
</td></tr>
<tr><td><code id="hipread_long_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read. Negative numbers (the default)
reads all lines.</p>
</td></tr>
<tr><td><code id="hipread_long_+3A_encoding">encoding</code></td>
<td>
<p>(Defaults to UTF-8) A string indicating what encoding to use
when reading the data, but like readr, the data will always be converted to
UTF-8 once it is imported. Note that UTF-16 and UTF-32 are not supported for
non-character columns.</p>
</td></tr>
<tr><td><code id="hipread_long_+3A_progress">progress</code></td>
<td>
<p>A logical indicating whether progress should be
displayed on the screen, defaults to showing progress unless
the current context is non-interactive or in a knitr document or
if the user has turned off readr's progress by default using
the option <code>options("readr.show_progress")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tbl_df</code> data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read an example hierarchical data.frame into long format
data &lt;- hipread_long(
  hipread_example("test-basic.dat"),
  list(
    H = hip_fwf_positions(
      c(1, 2, 5, 8),
      c(1, 4, 7, 10),
      c("rt", "hhnum", "hh_char", "hh_dbl"),
      c("c", "i", "c", "d")
    ),
    P = hip_fwf_widths(
      c(1, 3, 1, 3, 1),
      c("rt", "hhnum",  "pernum", "per_dbl", "per_mix"),
      c("c", "i", "i", "d", "c")
    )
  ),
  hip_rt(1, 1)
)

# Read an example hierarchical data.frame into list format
data &lt;- hipread_list(
  hipread_example("test-basic.dat"),
  list(
    H = hip_fwf_positions(
      c(1, 2, 5, 8),
      c(1, 4, 7, 10),
      c("rt", "hhnum", "hh_char", "hh_dbl"),
      c("c", "i", "c", "d")
    ),
    P = hip_fwf_widths(
      c(1, 3, 1, 3, 1),
      c("rt", "hhnum",  "pernum", "per_dbl", "per_mix"),
      c("c", "i", "i", "d", "c")
    )
  ),
  hip_rt(1, 1)
)

# Read a rectangular data.frame
data_rect &lt;- hipread_long(
  hipread_example("test-basic.dat"),
  hip_fwf_positions(
    c(1, 2),
    c(1, 4),
    c("rt", "hhnum"),
    c("c", "i")
  )
)
</code></pre>

<hr>
<h2 id='hipread_long_chunked'>Read a hierarchical fixed width data file, in chunks</h2><span id='topic+hipread_long_chunked'></span><span id='topic+hipread_list_chunked'></span>

<h3>Description</h3>

<p>Analogous to <code><a href="readr.html#topic+read_fwf">readr::read_fwf()</a></code>, but with chunks, and allowing for
hierarchical fixed width data files (where the data file has rows of
different record types, each with their own variables and column
specifications). <code>hipread_long_chunked()</code> reads hierarchical data into &quot;long&quot;
format, meaning that there is one row per observation, and variables
that don't apply to the current observation receive missing values.
Alternatively, <code>hipread_list_chunked()</code> reads hierarchical data into &quot;list&quot;
format, which returns a list that has one data.frame per record type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipread_long_chunked(
  file,
  callback,
  chunk_size,
  var_info,
  rt_info = hip_rt(1, 0),
  compression = NULL,
  skip = 0,
  encoding = "UTF-8",
  progress = show_progress()
)

hipread_list_chunked(
  file,
  callback,
  chunk_size,
  var_info,
  rt_info = hip_rt(1, 0),
  compression = NULL,
  skip = 0,
  encoding = "UTF-8",
  progress = show_progress()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hipread_long_chunked_+3A_file">file</code></td>
<td>
<p>A filename</p>
</td></tr>
<tr><td><code id="hipread_long_chunked_+3A_callback">callback</code></td>
<td>
<p>A <code><a href="#topic+callback">callback</a></code> function, allowing you to perform a
function on each chunk.</p>
</td></tr>
<tr><td><code id="hipread_long_chunked_+3A_chunk_size">chunk_size</code></td>
<td>
<p>The size of the chunks that will be read as a
single unit (defaults to 10000)</p>
</td></tr>
<tr><td><code id="hipread_long_chunked_+3A_var_info">var_info</code></td>
<td>
<p>Variable information, specified by either <code><a href="#topic+hip_fwf_positions">hip_fwf_positions()</a></code>
or <code>hip_fwf_widths()</code>. For hierarchical data files, there should be a named list,
where the name is the value indicated by the record type variable and there is
one variable information per record type.</p>
</td></tr>
<tr><td><code id="hipread_long_chunked_+3A_rt_info">rt_info</code></td>
<td>
<p>A record type information object, created by <code><a href="#topic+hip_rt">hip_rt()</a></code>, which
contains information about the location of the record type variable that
defines the record type for each observation. The default contains width
0, which indicates that there the data is rectangular and does not have
a record type variable.</p>
</td></tr>
<tr><td><code id="hipread_long_chunked_+3A_compression">compression</code></td>
<td>
<p>If <code>NULL</code>, guesses the compression from the
file extension (if extension is &quot;gz&quot; uses gzip, otherwise
treats as plain text), can specify it with a string (&quot;txt&quot;
indicates plain text and &quot;gz&quot; for gzip).</p>
</td></tr>
<tr><td><code id="hipread_long_chunked_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip at the start of the data (defaults to 0).</p>
</td></tr>
<tr><td><code id="hipread_long_chunked_+3A_encoding">encoding</code></td>
<td>
<p>(Defaults to UTF-8) A string indicating what encoding to use
when reading the data, but like readr, the data will always be converted to
UTF-8 once it is imported. Note that UTF-16 and UTF-32 are not supported for
non-character columns.</p>
</td></tr>
<tr><td><code id="hipread_long_chunked_+3A_progress">progress</code></td>
<td>
<p>A logical indicating whether progress should be
displayed on the screen, defaults to showing progress unless
the current context is non-interactive or in a knitr document or
if the user has turned off readr's progress by default using
the option <code>options("readr.show_progress")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the type of <code><a href="#topic+callback">callback</a></code> function you use
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read in a data, filtering out hhnum == "002"
data &lt;- hipread_long_chunked(
  hipread_example("test-basic.dat"),
  HipDataFrameCallback$new(function(x, pos) x[x$hhnum != 2, ]),
  4,
  list(
    H = hip_fwf_positions(
      c(1, 2, 5, 8),
      c(1, 4, 7, 10),
      c("rt", "hhnum", "hh_char", "hh_dbl"),
      c("c", "i", "c", "d")
    ),
    P = hip_fwf_widths(
      c(1, 3, 1, 3, 1),
      c("rt", "hhnum",  "pernum", "per_dbl", "per_mix"),
      c("c", "i", "i", "d", "c")
    )
  ),
  hip_rt(1, 1)
)
</code></pre>

<hr>
<h2 id='hipread_long_yield'>Read a hierarchical fixed width data file, in yields</h2><span id='topic+hipread_long_yield'></span><span id='topic+hipread_list_yield'></span><span id='topic+HipYield'></span><span id='topic+HipLongYield'></span><span id='topic+HipListYield'></span>

<h3>Description</h3>

<p>Enhances <code>hipread_long()</code> or <code>hipread_list()</code> to allow you to read
hierarchical data in pieces (called 'yields') and allow your code to
have full control between reading pieces, allowing for more freedom
than the 'callback' method introduced in the chunk functions (like
<code><a href="#topic+hipread_long_chunked">hipread_long_chunked()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipread_long_yield(
  file,
  var_info,
  rt_info = hip_rt(1, 0),
  compression = NULL,
  skip = 0,
  encoding = "UTF-8"
)

hipread_list_yield(
  file,
  var_info,
  rt_info = hip_rt(1, 0),
  compression = NULL,
  skip = 0,
  encoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hipread_long_yield_+3A_file">file</code></td>
<td>
<p>A filename</p>
</td></tr>
<tr><td><code id="hipread_long_yield_+3A_var_info">var_info</code></td>
<td>
<p>Variable information, specified by either <code><a href="#topic+hip_fwf_positions">hip_fwf_positions()</a></code>
or <code>hip_fwf_widths()</code>. For hierarchical data files, there should be a named list,
where the name is the value indicated by the record type variable and there is
one variable information per record type.</p>
</td></tr>
<tr><td><code id="hipread_long_yield_+3A_rt_info">rt_info</code></td>
<td>
<p>A record type information object, created by <code><a href="#topic+hip_rt">hip_rt()</a></code>, which
contains information about the location of the record type variable that
defines the record type for each observation. The default contains width
0, which indicates that there the data is rectangular and does not have
a record type variable.</p>
</td></tr>
<tr><td><code id="hipread_long_yield_+3A_compression">compression</code></td>
<td>
<p>If <code>NULL</code>, guesses the compression from the
file extension (if extension is &quot;gz&quot; uses gzip, otherwise
treats as plain text), can specify it with a string (&quot;txt&quot;
indicates plain text and &quot;gz&quot; for gzip).</p>
</td></tr>
<tr><td><code id="hipread_long_yield_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip at the start of the data (defaults to 0).</p>
</td></tr>
<tr><td><code id="hipread_long_yield_+3A_encoding">encoding</code></td>
<td>
<p>(Defaults to UTF-8) A string indicating what encoding to use
when reading the data, but like readr, the data will always be converted to
UTF-8 once it is imported. Note that UTF-16 and UTF-32 are not supported for
non-character columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return a HipYield R6 object which have the following
methods:
</p>

<ul>
<li> <p><code>yield(n = 10000)</code> A function to read the next 'yield' from the data,
returns a <code>tbl_df</code> (or list of <code>tbl_df</code> for <code>hipread_list_yield()</code>)
with up to n rows (it will return NULL if no rows are left, or all
available ones if less than n are available).
</p>
</li>
<li> <p><code>reset()</code> A function to reset the data so that the next yield will
read data from the start.
</p>
</li>
<li> <p><code>is_done()</code> A function that returns whether the file has been completely
read yet or not.
</p>
</li>
<li> <p><code>cur_pos</code> A property that contains the next row number that will be
read (1-indexed).
</p>
</li></ul>



<h3>Value</h3>

<p>A HipYield R6 object (See 'Details' for more information)
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HipYield-new"><code>HipYield$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HipYield-yield"><code>HipYield$yield()</code></a>
</p>
</li>
<li> <p><a href="#method-HipYield-reset"><code>HipYield$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-HipYield-is_done"><code>HipYield$is_done()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HipYield-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipYield$new(
  file,
  var_info,
  rt_info = hip_rt(0, 1),
  compression = NULL,
  skip = 0,
  encoding = NULL
)</pre></div>


<hr>
<a id="method-HipYield-yield"></a>



<h4>Method <code>yield()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipYield$yield(n = 10000)</pre></div>


<hr>
<a id="method-HipYield-reset"></a>



<h4>Method <code>reset()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipYield$reset()</pre></div>


<hr>
<a id="method-HipYield-is_done"></a>



<h4>Method <code>is_done()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipYield$is_done()</pre></div>




<h3>Super class</h3>

<p><code><a href="#topic+HipYield">hipread::HipYield</a></code> -&gt; <code>HipLongYield</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HipLongYield-new"><code>HipLongYield$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HipLongYield-yield"><code>HipLongYield$yield()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="hipread" data-topic="HipYield" data-id="is_done"><a href='../../hipread/html/HipYield.html#method-HipYield-is_done'><code>hipread::HipYield$is_done()</code></a></span></li>
<li><span class="pkg-link" data-pkg="hipread" data-topic="HipYield" data-id="reset"><a href='../../hipread/html/HipYield.html#method-HipYield-reset'><code>hipread::HipYield$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-HipLongYield-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipLongYield$new(
  file,
  var_info,
  rt_info = hip_rt(0, 1),
  compression = NULL,
  skip = 0,
  encoding = NULL
)</pre></div>


<hr>
<a id="method-HipLongYield-yield"></a>



<h4>Method <code>yield()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipLongYield$yield(n = 10000)</pre></div>




<h3>Super class</h3>

<p><code><a href="#topic+HipYield">hipread::HipYield</a></code> -&gt; <code>HipListYield</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HipListYield-new"><code>HipListYield$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HipListYield-yield"><code>HipListYield$yield()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="hipread" data-topic="HipYield" data-id="is_done"><a href='../../hipread/html/HipYield.html#method-HipYield-is_done'><code>hipread::HipYield$is_done()</code></a></span></li>
<li><span class="pkg-link" data-pkg="hipread" data-topic="HipYield" data-id="reset"><a href='../../hipread/html/HipYield.html#method-HipYield-reset'><code>hipread::HipYield$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-HipListYield-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipListYield$new(
  file,
  var_info,
  rt_info = hip_rt(0, 1),
  compression = NULL,
  skip = 0,
  encoding = NULL
)</pre></div>


<hr>
<a id="method-HipListYield-yield"></a>



<h4>Method <code>yield()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>HipListYield$yield(n = 10000)</pre></div>




<h3>Examples</h3>

<pre><code class='language-R'>library(hipread)
data &lt;- hipread_long_yield(
  hipread_example("test-basic.dat"),
  list(
    H = hip_fwf_positions(
      c(1, 2, 5, 8),
      c(1, 4, 7, 10),
      c("rt", "hhnum", "hh_char", "hh_dbl"),
      c("c", "i", "c", "d")
    ),
    P = hip_fwf_widths(
      c(1, 3, 1, 3, 1),
      c("rt", "hhnum",  "pernum", "per_dbl", "per_mix"),
      c("c", "i", "i", "d", "c")
    )
  ),
  hip_rt(1, 1)
)
# Read the first 4 rows
data$yield(4)

# Read the next 2 rows
data$yield(2)

# Reset and then read the first 4 rows again
data$reset()
data$yield(4)
</code></pre>

<hr>
<h2 id='hipread-package'>hipread: Read Hierarchical Fixed Width Files</h2><span id='topic+hipread'></span><span id='topic+hipread-package'></span>

<h3>Description</h3>

<p>Read hierarchical fixed width files like those commonly used by many census data providers. Also allows for reading of data in chunks, and reading 'gzipped' files without storing the full file in memory.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Derek Burk <a href="mailto:ipums+cran@umn.edu">ipums+cran@umn.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Greg Freedman Ellis
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Joe Grover [contributor]
</p>
</li>
<li><p> Mark Padgham [contributor]
</p>
</li>
<li><p> Hadley Wickham <a href="mailto:hadley@rstudio.com">hadley@rstudio.com</a> (Code adapted from readr) [contributor]
</p>
</li>
<li><p> Jim Hester <a href="mailto:james.hester@rstudio.com">james.hester@rstudio.com</a> (Code adapted from readr) [contributor]
</p>
</li>
<li><p> Romain Francois (Code adapted from readr) [contributor]
</p>
</li>
<li><p> R Core Team (Code adapted from readr) [contributor]
</p>
</li>
<li><p> RStudio (Code adapted from readr) [copyright holder, funder]
</p>
</li>
<li><p> Jukka Jylänki (Code adapted from readr) [contributor, copyright holder]
</p>
</li>
<li><p> Mikkel Jørgensen (Code adapted from readr) [contributor, copyright holder]
</p>
</li>
<li><p> University of Minnesota [copyright holder]
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
