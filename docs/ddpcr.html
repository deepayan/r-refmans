<!DOCTYPE html><html><head><title>Help for package ddpcr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ddpcr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ddpcr-package'><p>ddpcr: Analysis and Visualization of Droplet Digital PCR in R and on the Web</p></a></li>
<li><a href='#%&gt;%'><p>magrittr forward-pipe operator</p></a></li>
<li><a href='#%btwn%'><p>Determine if a numeric value is within a range</p></a></li>
<li><a href='#analysis_complete'><p>Is the analysis complete?</p></a></li>
<li><a href='#analyze'><p>Run analysis on a ddPCR plate</p></a></li>
<li><a href='#bind_df_ends'><p>Helper function for move_front and move_back</p></a></li>
<li><a href='#calc_negative_freq_simple'><p>Calculate negative frequency based on number of drops</p></a></li>
<li><a href='#calculate_concentration'><p>Calculate template concentration</p></a></li>
<li><a href='#calculate_concentration_single'><p>Calculate concentration in a single well</p></a></li>
<li><a href='#calculate_neg_freq_single'><p>Calculate negative frequency of a single well</p></a></li>
<li><a href='#calculate_negative_freqs'><p>Calculate negative frequencies in whole plate</p></a></li>
<li><a href='#capitalize'><p>Capitalize the first letter of a string</p></a></li>
<li><a href='#cat0'><p>Concatenate strings with no space between them</p></a></li>
<li><a href='#check_step'><p>Ensure the plate's status is at the right step</p></a></li>
<li><a href='#classify_droplets'><p>Analysis step: Classify droplets</p></a></li>
<li><a href='#classify_droplets_single'><p>Classify droplets in a well</p></a></li>
<li><a href='#classify_droplets_single.pnpp_experiment'><p>Classify droplets in a well</p></a></li>
<li><a href='#classify_droplets.pnpp_experiment'><p>Analysis step: Classify droplets</p></a></li>
<li><a href='#classify_thresholds'><p>Analysis step: Classify droplets</p></a></li>
<li><a href='#cluster'><p>Get cluster ID by name</p></a></li>
<li><a href='#cluster_name'><p>Get cluster name by ID</p></a></li>
<li><a href='#clusters'><p>Potential droplet clusters for a plate type</p></a></li>
<li><a href='#col_to_num'><p>Convert a plate column to a number</p></a></li>
<li><a href='#custom_thresholds'><p>Plate type: custom thresholds</p></a></li>
<li><a href='#ddpcr_plate'><p>Plate type: ddPCR plate</p></a></li>
<li><a href='#define_clusters'><p>Define droplet clusters</p></a></li>
<li><a href='#define_clusters.custom_thresholds'><p>Define droplet clusters for custom thresholds plates</p></a></li>
<li><a href='#define_clusters.ddpcr_plate'><p>Define droplet clusters for default plates</p></a></li>
<li><a href='#define_clusters.pnpp_experiment'><p>Define droplet clusters for PNPP experiments</p></a></li>
<li><a href='#define_params'><p>Define plate type parameters</p></a></li>
<li><a href='#define_params.custom_thresholds'><p>Define plate type parameters for custom thresholds plates</p></a></li>
<li><a href='#define_params.ddpcr_plate'><p>Define plate type parameters for default plates</p></a></li>
<li><a href='#define_params.fam_positive_pnpp'><p>Define plate type parameters for FAM-positive PNPP</p></a></li>
<li><a href='#define_params.hex_positive_pnpp'><p>Define plate type parameters for HEX-positive PNPP</p></a></li>
<li><a href='#define_params.pnpp_experiment'><p>Define plate type parameters for PNPP experiments</p></a></li>
<li><a href='#define_params.wildtype_mutant_pnpp'><p>Define plate type parameters for wildtype/mutant PNPP</p></a></li>
<li><a href='#define_steps'><p>Define analysis steps</p></a></li>
<li><a href='#define_steps.custom_thresholds'><p>Define analysis steps for custom thresholds plates</p></a></li>
<li><a href='#define_steps.ddpcr_plate'><p>Define analysis steps for default plates</p></a></li>
<li><a href='#define_steps.pnpp_experiment'><p>Define analysis steps for PNPP experiments</p></a></li>
<li><a href='#diff.point2d'><p>Euclidean distance between two points</p></a></li>
<li><a href='#err_msg'><p>Show an error message</p></a></li>
<li><a href='#fam_positive_pnpp'><p>Plate type: FAM-positive PNPP</p></a></li>
<li><a href='#get_col'><p>Get column from well ID</p></a></li>
<li><a href='#get_empty_cutoff'><p>Get the cutoff for empty droplets in a well</p></a></li>
<li><a href='#get_empty_cutoff.ddpcr_plate'><p>Get the cutoff for empty droplets in a well</p></a></li>
<li><a href='#get_empty_cutoff.pnpp_experiment'><p>Get the cutoff for empty droplets in a well</p></a></li>
<li><a href='#get_filled_border'><p>Get border of filled droplets in PNPP experiment</p></a></li>
<li><a href='#get_filled_drops'><p>Get filled droplets in PNPP experiment</p></a></li>
<li><a href='#get_outlier_cutoff'><p>Get the cutoff for outliers</p></a></li>
<li><a href='#get_outlier_cutoff.ddpcr_plate'><p>Get the cutoff for outliers</p></a></li>
<li><a href='#get_row'><p>Get row from well ID</p></a></li>
<li><a href='#get_single_well'><p>Get droplet data from a well</p></a></li>
<li><a href='#get_wells_btwn'><p>Get all wells between two wells (assume a rectangle layout)</p></a></li>
<li><a href='#has_signif_negative_cluster'><p>Does a well have a statistically significant number of negative droplets?</p></a></li>
<li><a href='#has_step'><p>Does a ddPCR plate have a step with this name?</p></a></li>
<li><a href='#hex_positive_pnpp'><p>Plate type: HEX-positive PNPP</p></a></li>
<li><a href='#is_dir'><p>Determine if a given path is a valid directory</p></a></li>
<li><a href='#is_dirty'><p>Is the plate object dirty (ie has changed since the analysis was run)?</p></a></li>
<li><a href='#is_empty_plate'><p>Is a plate empty?</p></a></li>
<li><a href='#is_file'><p>Determine if a given path is a valid file</p></a></li>
<li><a href='#is_range'><p>Is the given parameter a range?</p></a></li>
<li><a href='#is_well_success'><p>Determine if a well had a successful ddPCR run</p></a></li>
<li><a href='#is_well_success.ddpcr_plate'><p>Determine if a well had a successful ddPCR run</p></a></li>
<li><a href='#is_well_success.pnpp_experiment'><p>Determine if a well had a successful ddPCR run</p></a></li>
<li><a href='#launch'><p>Run the interactive analysis tool (Shiny app) in a web browser</p></a></li>
<li><a href='#load_plate'><p>Load a previously saved ddPCR plate</p></a></li>
<li><a href='#local_maxima'><p>Get the indices of the local maxima in a list of numbers</p></a></li>
<li><a href='#local_minima'><p>Get the indices of the local minima in a list of numbers</p></a></li>
<li><a href='#lol_to_df'><p>Convert a list of lists returned from vapply to a dataframe</p></a></li>
<li><a href='#mark_clusters'><p>Mark the clusters of droplets only in certain wells to their assigned cluster</p></a></li>
<li><a href='#merge_dfs_overwrite_col'><p>Overwrite a column in a data.frame based on a matching column in another df</p></a></li>
<li><a href='#meta_var_name'><p>Name of variable in PNPP experiment metadata</p></a></li>
<li><a href='#move_back'><p>Move columns to the back of a data.frame</p></a></li>
<li><a href='#move_front'><p>Move columns to the front of a data.frame</p></a></li>
<li><a href='#msg'><p>Write a message to the user if the 'ddpcr.verbose' option is on</p></a></li>
<li><a href='#name'><p>Plate name</p></a></li>
<li><a href='#named_vec_to_df'><p>Convert a named vector returned from vapply to a dataframe</p></a></li>
<li><a href='#new_plate'><p>Create a new ddPCR plate</p></a></li>
<li><a href='#next_step'><p>Run the next step in an analysis</p></a></li>
<li><a href='#normalize_to_rds'><p>Normalize a file name to .rds suffix</p></a></li>
<li><a href='#num_to_col'><p>Convert a number to plate column</p></a></li>
<li><a href='#num_to_row'><p>Convert a number to plate row</p></a></li>
<li><a href='#other_dim'><p>Given an axis (X or Y), return the other</p></a></li>
<li><a href='#params'><p>Plate parameters</p></a></li>
<li><a href='#parent_plate_type'><p>Parent plate type</p></a></li>
<li><a href='#parent_plate_type.ddpcr_plate'><p>Parent plate type of default plates</p></a></li>
<li><a href='#parent_plate_type.default'><p>Parent plate type of any plate</p></a></li>
<li><a href='#parent_plate_type.fam_positive_pnpp'><p>Parent plate type of FAM-positive PNPP</p></a></li>
<li><a href='#parent_plate_type.hex_positive_pnpp'><p>Parent plate type of HEX-positive PNPP</p></a></li>
<li><a href='#parent_plate_type.wildtype_mutant_pnpp'><p>Parent plate type of wildtype/mutant PNPP</p></a></li>
<li><a href='#plate_data'><p>Plate data (droplets data)</p></a></li>
<li><a href='#plate_data&lt;-'><p>Overwrite the plate data</p></a></li>
<li><a href='#plate_meta'><p>Plate metadata</p></a></li>
<li><a href='#plate_meta&lt;-'><p>Overwrite the plate metadata</p></a></li>
<li><a href='#plate_types'><p>Supported plate types</p></a></li>
<li><a href='#plot.custom_thresholds'><p>Plot a ddPCR plate of type custom thresholds</p></a></li>
<li><a href='#plot.ddpcr_plate'><p>Plot a ddPCR plate</p></a></li>
<li><a href='#plot.pnpp_experiment'><p>Plot a ddPCR plate of type PNPP experiment</p></a></li>
<li><a href='#plot.wildtype_mutant_pnpp'><p>Plot a ddPCR plate of type wildtype/mutant PNPP</p></a></li>
<li><a href='#pnpp_experiment'><p>Plate type: PNPP experiment</p></a></li>
<li><a href='#point2d'><p>Representation of a 2D point</p></a></li>
<li><a href='#positive_dim'><p>Positive dimension in a PNPP experiment</p></a></li>
<li><a href='#positive_dim_var'><p>Name of dye in positive dimension in PNPP experiment</p></a></li>
<li><a href='#positive_name'><p>Name identifier for positive and negative droplets</p></a></li>
<li><a href='#print.ddpcr_plate'><p>Print info about a ddPCR plate</p></a></li>
<li><a href='#quiet'><p>Suppress all output from an expression. Works cross-platform.</p></a></li>
<li><a href='#range_list_to_vec'><p>Convert a list of ranges to a vector of its individual components</p></a></li>
<li><a href='#range_to_endpoints'><p>Extract the two endpoints of a range</p></a></li>
<li><a href='#range_to_seq'><p>Convert a range to a vector of all elements between the endpoints</p></a></li>
<li><a href='#reclassify_droplets'><p>Analysis step: Reclassify droplets</p></a></li>
<li><a href='#reclassify_droplets_single'><p>Reclassify droplets in a well</p></a></li>
<li><a href='#reclassify_droplets_single.pnpp_experiment'><p>Reclassify droplets in a well</p></a></li>
<li><a href='#reclassify_droplets.pnpp_experiment'><p>Analysis step: Reclassify droplets</p></a></li>
<li><a href='#remove_empty'><p>Analysis step: Remove empty droplets</p></a></li>
<li><a href='#remove_empty.ddpcr_plate'><p>Analysis step: Remove empty droplets</p></a></li>
<li><a href='#remove_empty.pnpp_experiment'><p>Analysis step: Remove empty droplets</p></a></li>
<li><a href='#remove_failures'><p>Analysis step: Remove failed wells</p></a></li>
<li><a href='#remove_failures.ddpcr_plate'><p>Analysis step: Remove failed wells</p></a></li>
<li><a href='#remove_outliers'><p>Analysis Step: Remove outlier droplets</p></a></li>
<li><a href='#remove_outliers.ddpcr_plate'><p>Analysis Step: Remove outlier droplets</p></a></li>
<li><a href='#reset'><p>Reset a plate</p></a></li>
<li><a href='#row_to_num'><p>Convert a plate row to a number</p></a></li>
<li><a href='#sample_data'><p>Get sample data</p></a></li>
<li><a href='#save_plate'><p>Save a ddPCR plate</p></a></li>
<li><a href='#set_default_params'><p>Reset plate parameters to their defaults</p></a></li>
<li><a href='#status'><p>Plate status</p></a></li>
<li><a href='#step'><p>Get step ID by step name</p></a></li>
<li><a href='#step_begin'><p>Inform the user that an analysis step is starting</p></a></li>
<li><a href='#step_end'><p>Inform the user that an analysis step finished</p></a></li>
<li><a href='#step_name'><p>Get step name by ID</p></a></li>
<li><a href='#steps'><p>Analysis steps of a ddPCR plate</p></a></li>
<li><a href='#subset.ddpcr_plate'><p>Subsetting a ddPCR plate</p></a></li>
<li><a href='#thresholds'><p>Get/set the thresholds</p></a></li>
<li><a href='#type'><p>Plate type</p></a></li>
<li><a href='#unanalyzed_clusters'><p>Get unanalyzed cluseter IDs</p></a></li>
<li><a href='#variable_dim'><p>Variable dimension in a PNPP experiment</p></a></li>
<li><a href='#variable_dim_var'><p>Name of dye in variable dimension in PNPP experiment</p></a></li>
<li><a href='#warn_msg'><p>Show a warning message</p></a></li>
<li><a href='#WELL_ID_REGEX'><p>regex for a well ID</p></a></li>
<li><a href='#well_info'><p>Get metadata info of a well</p></a></li>
<li><a href='#wells_mutant'><p>Get mutant wells</p></a></li>
<li><a href='#wells_negative'><p>Get negative wells</p></a></li>
<li><a href='#wells_positive'><p>Get positive wells</p></a></li>
<li><a href='#wells_success'><p>Get successful/failed wells</p></a></li>
<li><a href='#wells_used'><p>Get wells used in a ddPCR plate</p></a></li>
<li><a href='#wells_wildtype'><p>Get wildtype wells</p></a></li>
<li><a href='#wildtype_mutant_pnpp'><p>Plate type: wildtype/mutant PNPP</p></a></li>
<li><a href='#x_threshold'><p>Get/set the X threshold</p></a></li>
<li><a href='#x_var'><p>Get/set the X/Y variable (dye name)</p></a></li>
<li><a href='#y_threshold'><p>Get/set the Y threshold</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis and Visualization of Droplet Digital PCR in R and on
the Web</td>
</tr>
<tr>
<td>Version:</td>
<td>1.15.2</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface to explore, analyze, and visualize droplet digital PCR
    (ddPCR) data in R. This is the first non-proprietary software for analyzing
    two-channel ddPCR data. An interactive tool was also created and is available
    online to facilitate this analysis for anyone who is not comfortable with
    using R.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/daattali/ddpcr">https://github.com/daattali/ddpcr</a>,
<a href="https://daattali.com/shiny/ddpcr/">https://daattali.com/shiny/ddpcr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/daattali/ddpcr/issues">https://github.com/daattali/ddpcr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DT (&ge; 0.2), dplyr (&ge; 0.5.0), ggplot2 (&ge; 2.2.0), lazyeval
(&ge; 0.1.10), magrittr (&ge; 1.5), mixtools (&ge; 1.0.2), plyr (&ge;
1.8.1), readr (&ge; 0.1.0), shiny (&ge; 0.11.0), shinydisconnect,
shinyjs (&ge; 0.4.0), tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggExtra (&ge; 0.3.0), graphics, grid (&ge; 3.2.2), gridExtra (&ge;
2.0.0), knitr (&ge; 1.7), rmarkdown, stats, testthat (&ge; 0.11.0),
utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 23:00:34 UTC; Dean-X1C</td>
</tr>
<tr>
<td>Author:</td>
<td>Dean Attali <a href="https://orcid.org/0000-0002-5645-3493"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dean Attali &lt;daattali@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 22:32:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='ddpcr-package'>ddpcr: Analysis and Visualization of Droplet Digital PCR in R and on the Web</h2><span id='topic+ddpcr'></span><span id='topic+ddpcr-package'></span>

<h3>Description</h3>

<p>An interface to explore, analyze, and visualize droplet digital PCR (ddPCR) data in R. This is the first non-proprietary software for analyzing two-channel ddPCR data. An interactive tool was also created and is available online to facilitate this analysis for anyone who is not comfortable with using R.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dean Attali <a href="mailto:daattali@gmail.com">daattali@gmail.com</a> (<a href="https://orcid.org/0000-0002-5645-3493">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/daattali/ddpcr">https://github.com/daattali/ddpcr</a>
</p>
</li>
<li> <p><a href="https://daattali.com/shiny/ddpcr/">https://daattali.com/shiny/ddpcr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/daattali/ddpcr/issues">https://github.com/daattali/ddpcr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>magrittr forward-pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>magrittr forward-pipe operator
</p>

<hr>
<h2 id='+25btwn+25'>Determine if a numeric value is within a range</h2><span id='topic++25btwn+25'></span>

<h3>Description</h3>

<p>Determine if a numeric value is within a range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %btwn% rng
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25btwn+2B25_+3A_x">x</code></td>
<td>
<p>Numeric vector to check whether the values are within <code>rng</code></p>
</td></tr>
<tr><td><code id="+2B25btwn+2B25_+3A_rng">rng</code></td>
<td>
<p>The range to check if numbers in <code>x</code> are within it.</p>
</td></tr>
</table>

<hr>
<h2 id='analysis_complete'>Is the analysis complete?</h2><span id='topic+analysis_complete'></span>

<h3>Description</h3>

<p>Check if a ddPCR plate has been fully analyzed or if there are remaining steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analysis_complete(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analysis_complete_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the plate's analysis has been fully carried out;
<code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+status">status</a></code><br />
<code><a href="#topic+analyze">analyze</a></code>
</p>

<hr>
<h2 id='analyze'>Run analysis on a ddPCR plate</h2><span id='topic+analyze'></span>

<h3>Description</h3>

<p>Every ddPCR plate has a set of defined steps that are taken in order, that
together constitute &quot;analyzing&quot; the plate.  Calling the <code>analyze</code> function
will perform all the analysis steps, which may take several minutes. Running
the analysis will classify the droplets in the plate into clusters (available
via <code><a href="#topic+plate_data">plate_data</a></code>) and will add variables to the plate
metadata (available via <code><a href="#topic+plate_meta">plate_meta</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze(plate, restart = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="analyze_+3A_restart">restart</code></td>
<td>
<p>If <code>TRUE</code>, then run the analysis from the beginning;
othrewise, continue from the last step that was performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will run an analysis to completion. If you want to run each
step one at a time, use <code><a href="#topic+next_step">next_step</a></code>.
</p>


<h3>Value</h3>

<p>The analyzed ddPCR plate
</p>


<h3>Note</h3>

<p>Most analysis steps result in some progress messages being printed to
the screen. You can turn off these messages by disabling the verbose option
with the command <code>options(ddpcr.verbose = FALSE)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+next_step">next_step</a></code><br />
<code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code><br />
<code><a href="#topic+new_plate">new_plate</a></code><br />
<code><a href="#topic+steps">steps</a></code><br />
<code><a href="#topic+plate_data">plate_data</a></code><br />
<code><a href="#topic+plate_meta">plate_meta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
plate &lt;- analyze(plate)

## End(Not run) 
</code></pre>

<hr>
<h2 id='bind_df_ends'>Helper function for move_front and move_back</h2><span id='topic+bind_df_ends'></span>

<h3>Description</h3>

<p>Helper function for move_front and move_back
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_df_ends(df, cols, dir = 1)
</code></pre>

<hr>
<h2 id='calc_negative_freq_simple'>Calculate negative frequency based on number of drops</h2><span id='topic+calc_negative_freq_simple'></span>

<h3>Description</h3>

<p>Calculate negative frequency based on number of drops
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_negative_freq_simple(negative_drops, positive_drops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_negative_freq_simple_+3A_negative_drops">negative_drops</code></td>
<td>
<p>Number of negative drops.</p>
</td></tr>
<tr><td><code id="calc_negative_freq_simple_+3A_positive_drops">positive_drops</code></td>
<td>
<p>Number of positive drops.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fraction of drops that are negative.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calc_negative_freq_simple(5, 45)
</code></pre>

<hr>
<h2 id='calculate_concentration'>Calculate template concentration</h2><span id='topic+calculate_concentration'></span>

<h3>Description</h3>

<p>Calculate template concentration in each wells in a plate using the same formula that
QuantaSoft uses. The concentration information is added to the plate's metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_concentration(plate)
</code></pre>


<h3>Details</h3>

<p>The concentration in a well as number of copies of template per microlitre
of sample, and uses the following equation:
</p>
<p>(-log(drops_empty / drops_total) * drops_total) / (droplet_volume * drops_total)
</p>


<h3>Value</h3>

<p>A ddPCR plate with the metadata containing a new 'concentration' variable.
</p>

<hr>
<h2 id='calculate_concentration_single'>Calculate concentration in a single well</h2><span id='topic+calculate_concentration_single'></span>

<h3>Description</h3>

<p>Calculate concentration in a single well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_concentration_single(plate, well_id)
</code></pre>


<h3>Value</h3>

<p>The concentration (integer) in a well.
</p>

<hr>
<h2 id='calculate_neg_freq_single'>Calculate negative frequency of a single well</h2><span id='topic+calculate_neg_freq_single'></span>

<h3>Description</h3>

<p>Calculate negative frequency of a single well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_neg_freq_single(plate, well_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_neg_freq_single_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="calculate_neg_freq_single_+3A_well_id">well_id</code></td>
<td>
<p>A well ID</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 3 elemnts: number of negative drops, number of positive
drops, and fraction of negative drops.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("sample_data", "small", "analyzed_pnpp.rds", package = "ddpcr")
plate &lt;- load_plate(file)
plate %&gt;% calculate_neg_freq_single("A05")
</code></pre>

<hr>
<h2 id='calculate_negative_freqs'>Calculate negative frequencies in whole plate</h2><span id='topic+calculate_negative_freqs'></span>

<h3>Description</h3>

<p>The resulting plate has the same droplet data but an updated metadata with
the number of negative/positive droplets and the negative frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_negative_freqs(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_negative_freqs_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("sample_data", "small", "analyzed_pnpp.rds", package = "ddpcr")
plate &lt;- load_plate(file)
plate %&gt;% calculate_negative_freqs %&gt;%
  well_info(wells_success(plate), "negative_freq")
</code></pre>

<hr>
<h2 id='capitalize'>Capitalize the first letter of a string</h2><span id='topic+capitalize'></span>

<h3>Description</h3>

<p>Capitalize the first letter of a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capitalize(x)
</code></pre>

<hr>
<h2 id='cat0'>Concatenate strings with no space between them</h2><span id='topic+cat0'></span>

<h3>Description</h3>

<p>Concatenate strings with no space between them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat0(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat0_+3A_...">...</code></td>
<td>
<p>Strings to concatenate</p>
</td></tr>
</table>

<hr>
<h2 id='check_step'>Ensure the plate's status is at the right step</h2><span id='topic+check_step'></span>

<h3>Description</h3>

<p>Before beginning a step, you can check to make sure the plate is currently
at most one step behind the current step. If the plate is more than one step
behind, an error will be thrown, so that the user will know they need to
run the previous steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_step(plate, step)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dir &lt;- sample_data_dir()
plate &lt;- new_plate(dir)
status(plate) # current step
check_step(plate, 2) # are we ready to start step 2?
check_step(plate, 3) # are we ready to start step 3?
plate &lt;- next_step(plate)
status(plate)
check_step(plate, 3) # now are we ready to start step 3?

## End(Not run)
</code></pre>

<hr>
<h2 id='classify_droplets'>Analysis step: Classify droplets</h2><span id='topic+classify_droplets'></span>

<h3>Description</h3>

<p>The main analysis step for ddPCR plates of type <code>pnpp_experiment</code>.
Classify each droplet as either rain, ++, or +-. Also calculate the frequency
of negative droplets, and attempt to detemine if each well has a statistically
significant number of such droplets.<br /><br />
<a href="https://github.com/daattali/ddpcr#advanced-topic-2-algorithms-used-in-each-step">See the README</a> for
more information about the algorithm used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_droplets(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_droplets_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is recommended to be run as part of an analysis pipeline (ie.
within the <code><a href="#topic+analyze">analyze</a></code> function) rather than being called
directly.
</p>


<h3>Value</h3>

<p>A ddPCR plate with all droplets assigned to a cluster. The plate's
metadata will have several new variables.
</p>


<h3>Note</h3>

<p>This is an S3 generic, which means that different ddPCR plate types can
implement this function differently.
<a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on how to implement custom ddPCR plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+classify_droplets_single">classify_droplets_single</a></code><br />
<code><a href="#topic+mark_clusters">mark_clusters</a></code><br />
<code><a href="#topic+has_signif_negative_cluster">has_signif_negative_cluster</a></code>
</p>

<hr>
<h2 id='classify_droplets_single'>Classify droplets in a well</h2><span id='topic+classify_droplets_single'></span>

<h3>Description</h3>

<p>This function runs the actual algorithm for classifying droplets in a single
well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_droplets_single(plate, well_id, ...)
</code></pre>

<hr>
<h2 id='classify_droplets_single.pnpp_experiment'>Classify droplets in a well</h2><span id='topic+classify_droplets_single.pnpp_experiment'></span>

<h3>Description</h3>

<p>If you want to see details about how a well was classified, you can set
<code>plot = TRUE</code> to plot the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
classify_droplets_single(plate, well_id, ..., plot = FALSE)
</code></pre>

<hr>
<h2 id='classify_droplets.pnpp_experiment'>Analysis step: Classify droplets</h2><span id='topic+classify_droplets.pnpp_experiment'></span>

<h3>Description</h3>

<p>Analysis step: Classify droplets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
classify_droplets(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_droplets.pnpp_experiment_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>

<hr>
<h2 id='classify_thresholds'>Analysis step: Classify droplets</h2><span id='topic+classify_thresholds'></span>

<h3>Description</h3>

<p>The main analysis step for ddPCR plates of type <code>custom_thresholds</code>.
Assign each droplet into one of four quadrants based on the thresholds.<br /><br />
<a href="https://github.com/daattali/ddpcr#advanced-topic-2-algorithms-used-in-each-step">See the README</a> for
more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_thresholds(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_thresholds_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is recommended to be run as part of an analysis pipeline (ie.
within the <code><a href="#topic+analyze">analyze</a></code> function) rather than being called
directly.
</p>


<h3>Value</h3>

<p>A ddPCR plate with all the droplets assigned to a quadrant. The plate's
metadata will have a few new variables relating to the number of droplets
in each quadrant.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom_thresholds">custom_thresholds</a></code><br />
<code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+thresholds">thresholds</a></code>
</p>

<hr>
<h2 id='cluster'>Get cluster ID by name</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>Get cluster ID by name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(plate, cluster)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
# see what cluster names exist and their order
clusters(plate)
cluster(plate, 'FAILED')
cluster(plate, 'EMPTY')

## End(Not run)
</code></pre>

<hr>
<h2 id='cluster_name'>Get cluster name by ID</h2><span id='topic+cluster_name'></span>

<h3>Description</h3>

<p>Get cluster name by ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_name(plate, cluster)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
# see what cluster names exist and their order
clusters(plate)
cluster_name(plate, 2)
cluster_name(plate, 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='clusters'>Potential droplet clusters for a plate type</h2><span id='topic+clusters'></span>

<h3>Description</h3>

<p>Each ddPCR plate type has a specific set of potential clusters the droplets
can be assigned to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusters(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusters_+3A_plate">plate</code></td>
<td>
<p>a ddPCR plate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on plate types.
</p>


<h3>Value</h3>

<p>A character vector with the names of the clusters supported by the
plate type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dir &lt;- sample_data_dir()
new_plate(dir) %&gt;% clusters
new_plate(dir, plate_types$fam_positive_pnpp) %&gt;% clusters

## End(Not run)
</code></pre>

<hr>
<h2 id='col_to_num'>Convert a plate column to a number</h2><span id='topic+col_to_num'></span>

<h3>Description</h3>

<p>Convert a plate column to a number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_to_num(col)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>col_to_num("05")  # 5L
</code></pre>

<hr>
<h2 id='custom_thresholds'>Plate type: custom thresholds</h2><span id='topic+custom_thresholds'></span>

<h3>Description</h3>

<p>The <code>custom_thresholds</code> plate type is used when you want to gate ddPCR
droplet data into four quadrants according to HEX and FAM values that you
manually set. All wells in the plate will use the same threshold values.
</p>


<h3>Details</h3>

<p>Plates with this type have only three analysis steps: <code>INITIALIZE</code>,
<code>REMOVE_OUTLIERS</code>, and <code>CLASSIFY</code> (according to the custom thresholds).
</p>
<p>Plates with this type have the following droplet clusters:
<code>UNDEFINED</code>, <code>OUTLIER</code>, <code>EMPTY</code> (bottom-left quadrant),
<code>X_POSITIVE</code> (bottom-right quadrant), <code>Y_POSITIVE</code> (top-left quadrant),
<code>BOTH_POSITIVE</code> (top-right quadrant).
</p>
<p><a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_types">plate_types</a></code><br />
<code><a href="#topic+x_threshold">x_threshold</a></code><br />
<code><a href="#topic+y_threshold">y_threshold</a></code><br />
<code><a href="#topic+thresholds">thresholds</a></code><br />
<code><a href="#topic+analyze">analyze</a></code> <br />
<code><a href="#topic+remove_outliers">remove_outliers</a></code><br />
<code><a href="#topic+classify_thresholds">classify_thresholds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
type(plate)
plate %&gt;% analyze %&gt;% plot

## End(Not run)
</code></pre>

<hr>
<h2 id='ddpcr_plate'>Plate type: ddPCR plate</h2><span id='topic+ddpcr_plate'></span>

<h3>Description</h3>

<p>The default plate type that all other plates inherit from. If you initialize
a ddPCR plate without specifying a plate type, <code>ddpcr_plate</code> will be the
plate's type.
</p>


<h3>Details</h3>

<p>Plates with this type have the following analysis steps: <code>INITIALIZE</code>,
<code>REMOVE_FAILURES</code>, <code>REMOVE_OUTLIERS</code>, <code>REMOVE_EMPTY</code>.
</p>
<p>Plates with this type have the following droplet clusters: <code>UNDEFINED</code>,
<code>FAILED</code>, <code>OUTLIER</code>, <code>EMPTY</code>.
</p>
<p><a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_types">plate_types</a></code><br />
<code><a href="#topic+remove_failures">remove_failures</a></code><br />
<code><a href="#topic+remove_outliers">remove_outliers</a></code><br />
<code><a href="#topic+remove_empty">remove_empty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$ddpcr_plate)
type(plate)
plate %&gt;% analyze %&gt;% plot

## End(Not run)
</code></pre>

<hr>
<h2 id='define_clusters'>Define droplet clusters</h2><span id='topic+define_clusters'></span>

<h3>Description</h3>

<p>Every ddPCR plate type has a set of potential clusters the droplets can be
assigned to. When creating a custom plate type, if your plate type uses a
different set of clusters than its parent type, you must define this function
to return the cluster names. When defining this function, you can use
<code>NextMethod("define_clusters")</code> to get a list of the clusters available
in the parent type if you want to simply add new clusters without defining
all of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_clusters(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_clusters_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of potential droplet clusters for the plate type.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusters">clusters</a></code>
</p>
<p><code><a href="#topic+clusters">clusters</a></code><br />
<code><a href="#topic+parent_plate_type">parent_plate_type</a></code><br />
<code><a href="#topic+define_params">define_params</a></code><br />
<code><a href="#topic+define_steps">define_steps</a></code>
</p>

<hr>
<h2 id='define_clusters.custom_thresholds'>Define droplet clusters for custom thresholds plates</h2><span id='topic+define_clusters.custom_thresholds'></span>

<h3>Description</h3>

<p>Define droplet clusters for custom thresholds plates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'custom_thresholds'
define_clusters(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_clusters.custom_thresholds_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_clusters.ddpcr_plate'>Define droplet clusters for default plates</h2><span id='topic+define_clusters.ddpcr_plate'></span>

<h3>Description</h3>

<p>Define droplet clusters for default plates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
define_clusters(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_clusters.ddpcr_plate_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_clusters.pnpp_experiment'>Define droplet clusters for PNPP experiments</h2><span id='topic+define_clusters.pnpp_experiment'></span>

<h3>Description</h3>

<p>Define droplet clusters for PNPP experiments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
define_clusters(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_clusters.pnpp_experiment_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_params'>Define plate type parameters</h2><span id='topic+define_params'></span>

<h3>Description</h3>

<p>Every ddPCR plate type has a set of default parameters. When creating a
custom plate type, if your plate type needs a different set of parameters
than its parent type, you must define this function to return the parameters
specific to this plate. When defining this function, you can use
<code>NextMethod("define_params")</code> to get a list of the parameters of the
parent type so that you can simply add to that list rather than redefining
all the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_params(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_params_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of default parameters for the plate type.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params">params</a></code>
</p>
<p><code><a href="#topic+params">params</a></code><br />
<code><a href="#topic+parent_plate_type">parent_plate_type</a></code><br />
<code><a href="#topic+define_clusters">define_clusters</a></code><br />
<code><a href="#topic+define_steps">define_steps</a></code>
</p>

<hr>
<h2 id='define_params.custom_thresholds'>Define plate type parameters for custom thresholds plates</h2><span id='topic+define_params.custom_thresholds'></span>

<h3>Description</h3>

<p>Define plate type parameters for custom thresholds plates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'custom_thresholds'
define_params(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_params.custom_thresholds_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_params.ddpcr_plate'>Define plate type parameters for default plates</h2><span id='topic+define_params.ddpcr_plate'></span>

<h3>Description</h3>

<p>Define plate type parameters for default plates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
define_params(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_params.ddpcr_plate_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_params.fam_positive_pnpp'>Define plate type parameters for FAM-positive PNPP</h2><span id='topic+define_params.fam_positive_pnpp'></span>

<h3>Description</h3>

<p>Define plate type parameters for FAM-positive PNPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fam_positive_pnpp'
define_params(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_params.fam_positive_pnpp_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_params.hex_positive_pnpp'>Define plate type parameters for HEX-positive PNPP</h2><span id='topic+define_params.hex_positive_pnpp'></span>

<h3>Description</h3>

<p>Define plate type parameters for HEX-positive PNPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hex_positive_pnpp'
define_params(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_params.hex_positive_pnpp_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_params.pnpp_experiment'>Define plate type parameters for PNPP experiments</h2><span id='topic+define_params.pnpp_experiment'></span>

<h3>Description</h3>

<p>Define plate type parameters for PNPP experiments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
define_params(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_params.pnpp_experiment_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_params.wildtype_mutant_pnpp'>Define plate type parameters for wildtype/mutant PNPP</h2><span id='topic+define_params.wildtype_mutant_pnpp'></span>

<h3>Description</h3>

<p>Define plate type parameters for wildtype/mutant PNPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wildtype_mutant_pnpp'
define_params(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_params.wildtype_mutant_pnpp_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_steps'>Define analysis steps</h2><span id='topic+define_steps'></span>

<h3>Description</h3>

<p>Every ddPCR plate type has an ordered set of steps that are run to analyze
the data. When creating a new plate type, if your plate type has different
analysis steps than its parent type, you must define this function to return
a named list of the analysis steps. When defining this function, you can use
<code>NextMethod("define_steps")</code> to get a list of the steps available in
the parent type if you want to simply add new steps without defining all of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_steps(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_steps_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of analysis steps in the order they should be run on a dataset.
The name of each item in the list is the human-readable name of the step
and the value of each item is the function to call to perform the step.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steps">steps</a></code><br />
<code><a href="#topic+step_begin">step_begin</a></code><br />
<code><a href="#topic+step_end">step_end</a></code><br />
<code><a href="#topic+parent_plate_type">parent_plate_type</a></code><br />
<code><a href="#topic+define_clusters">define_clusters</a></code><br />
<code><a href="#topic+define_params">define_params</a></code>
</p>

<hr>
<h2 id='define_steps.custom_thresholds'>Define analysis steps for custom thresholds plates</h2><span id='topic+define_steps.custom_thresholds'></span>

<h3>Description</h3>

<p>Define analysis steps for custom thresholds plates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'custom_thresholds'
define_steps(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_steps.custom_thresholds_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_steps.ddpcr_plate'>Define analysis steps for default plates</h2><span id='topic+define_steps.ddpcr_plate'></span>

<h3>Description</h3>

<p>Define analysis steps for default plates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
define_steps(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_steps.ddpcr_plate_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='define_steps.pnpp_experiment'>Define analysis steps for PNPP experiments</h2><span id='topic+define_steps.pnpp_experiment'></span>

<h3>Description</h3>

<p>Define analysis steps for PNPP experiments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
define_steps(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_steps.pnpp_experiment_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='diff.point2d'>Euclidean distance between two points</h2><span id='topic+diff.point2d'></span>

<h3>Description</h3>

<p>Calculate the distance between two points in 2D space. If only one points is
given, then the distance to the origin is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'point2d'
diff(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff.point2d_+3A_x">x</code>, <code id="diff.point2d_+3A_y">y</code></td>
<td>
<p>Points generated with <code>point2d</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+point2d">point2d</a></code>
</p>

<hr>
<h2 id='err_msg'>Show an error message</h2><span id='topic+err_msg'></span>

<h3>Description</h3>

<p>Show an error message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>err_msg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="err_msg_+3A_x">x</code></td>
<td>
<p>The error message text</p>
</td></tr>
</table>

<hr>
<h2 id='fam_positive_pnpp'>Plate type: FAM-positive PNPP</h2><span id='topic+fam_positive_pnpp'></span>

<h3>Description</h3>

<p>A ddPCR plate of type <code>fam_positive_pnpp</code>, which can also be expressed as
(FAM+)/(FAM+HEX+), is a subtype of both <code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code>
and <code><a href="#topic+wildtype_mutant_pnpp">wildtype_mutant_pnpp</a></code>. Use this plate type if your data
has three main clusters of droplets: double-negative (empty droplets),
FAM+HEX+ (wildtype droplets) and FAM+HEX- (mutant droplets).
</p>


<h3>Details</h3>

<p>Plates with this type have the following analysis steps: <code>INITIALIZE</code>,
<code>REMOVE_FAILURES</code>, <code>REMOVE_OUTLIERS</code>, <code>REMOVE_EMPTY</code>,
<code>CLASSIFY</code>, <code>RECLASSIFY</code>.
</p>
<p>Plates with this type have the following droplet clusters:
<code>UNDEFINED</code>, <code>FAILED</code>, <code>OUTLIER</code>, <code>EMPTY</code> (double-negative),
<code>RAIN</code> (not empty but not wildtype nor negative), <code>POSITIVE</code> (wildtype),
<code>NEGATIVE</code> (mutant).
</p>
<p><a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_types">plate_types</a></code><br />
<code><a href="#topic+wildtype_mutant_pnpp">wildtype_mutant_pnpp</a></code><br />
<code><a href="#topic+hex_positive_pnpp">hex_positive_pnpp</a></code><br />
<code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+remove_failures">remove_failures</a></code><br />
<code><a href="#topic+remove_outliers">remove_outliers</a></code><br />
<code><a href="#topic+remove_empty">remove_empty</a></code><br />
<code><a href="#topic+classify_droplets">classify_droplets</a></code><br />
<code><a href="#topic+reclassify_droplets">reclassify_droplets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$fam_positive_pnpp)
type(plate)
plate %&gt;% analyze %&gt;% plot

## End(Not run)
</code></pre>

<hr>
<h2 id='get_col'>Get column from well ID</h2><span id='topic+get_col'></span>

<h3>Description</h3>

<p>Get column from well ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_col(well)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>get_col("C05" )  # "05"
</code></pre>

<hr>
<h2 id='get_empty_cutoff'>Get the cutoff for empty droplets in a well</h2><span id='topic+get_empty_cutoff'></span>

<h3>Description</h3>

<p>Calculate the cutoff thresholds that define which droplets are empty in a well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_empty_cutoff(plate, well_id)
</code></pre>


<h3>Value</h3>

<p>A list with 2 elements named <code>x</code> and <code>y</code> with the values
being the cutoff in the corresponding axis.
</p>

<hr>
<h2 id='get_empty_cutoff.ddpcr_plate'>Get the cutoff for empty droplets in a well</h2><span id='topic+get_empty_cutoff.ddpcr_plate'></span>

<h3>Description</h3>

<p>Get the cutoff for empty droplets in a well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
get_empty_cutoff(plate, well_id)
</code></pre>

<hr>
<h2 id='get_empty_cutoff.pnpp_experiment'>Get the cutoff for empty droplets in a well</h2><span id='topic+get_empty_cutoff.pnpp_experiment'></span>

<h3>Description</h3>

<p>Very similar to the <code>get_empty_cutoff</code> method of the base plate type,
except for this plate type we know that we don't expect any droplets in one
of the corners, so we can save time by only having an empty cutoff in one
dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
get_empty_cutoff(plate, well_id)
</code></pre>

<hr>
<h2 id='get_filled_border'>Get border of filled droplets in PNPP experiment</h2><span id='topic+get_filled_border'></span>

<h3>Description</h3>

<p>In a PNPP experiment, the rain droplets are the non-empty drops that don't have a
high enough intensity in the positive dimension to be considered as filled
with high quality sample DNA. Only droplets considered as filled are
candidates for the <code>negative</code> and <code>positive</code> clusters.
<code>get_filled_border</code> returns the threshold value in the positive
dimension that is used to determine which drops are filled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_filled_border(plate, well_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_filled_border_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="get_filled_border_+3A_well_id">well_id</code></td>
<td>
<p>Get border of filled droplets for this well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Thresholds of filled drops in the positive dimension.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+positive_dim">positive_dim</a></code><br />
<code><a href="#topic+get_filled_drops">get_filled_drops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("sample_data", "small", "analyzed_pnpp.rds", package = "ddpcr")
plate &lt;- load_plate(file)
get_filled_border(plate, "A05")
get_filled_border(plate, "F05")
</code></pre>

<hr>
<h2 id='get_filled_drops'>Get filled droplets in PNPP experiment</h2><span id='topic+get_filled_drops'></span>

<h3>Description</h3>

<p>In a PNPP experiment, the rain droplets are the non-empty drops that don't have a
high enough intensity in the positive dimension to be considered as filled
with high quality sample DNA. Only droplets considered as filled are
candidates for the <code>negative</code> and <code>positive</code> clusters.
<code>get_filled_drops</code> returns the droplets that are considered filled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_filled_drops(plate, well_id, border)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_filled_drops_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="get_filled_drops_+3A_well_id">well_id</code></td>
<td>
<p>Get border of filled droplets for this well.</p>
</td></tr>
<tr><td><code id="get_filled_drops_+3A_border">border</code></td>
<td>
<p>(Optional) The filled droplets border, as calculated by
<code><a href="#topic+get_filled_drops">get_filled_drops</a></code>. If missing, then
<code><a href="#topic+get_filled_drops">get_filled_drops</a></code> is called to calculate the border.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with all filled droplets in the given well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+positive_dim">positive_dim</a></code><br />
<code><a href="#topic+get_filled_drops">get_filled_drops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("sample_data", "small", "analyzed_pnpp.rds", package = "ddpcr")
plate &lt;- load_plate(file)
get_filled_drops(plate, "A05")
get_filled_drops(plate, "A05", get_filled_border(plate, "A05"))
</code></pre>

<hr>
<h2 id='get_outlier_cutoff'>Get the cutoff for outliers</h2><span id='topic+get_outlier_cutoff'></span>

<h3>Description</h3>

<p>Get the cutoff for outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_outlier_cutoff(plate)
</code></pre>


<h3>Value</h3>

<p>A named list with two elements, giving the cutoff for outliers in
each dimension.
</p>

<hr>
<h2 id='get_outlier_cutoff.ddpcr_plate'>Get the cutoff for outliers</h2><span id='topic+get_outlier_cutoff.ddpcr_plate'></span>

<h3>Description</h3>

<p>Get the cutoff for outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
get_outlier_cutoff(plate)
</code></pre>

<hr>
<h2 id='get_row'>Get row from well ID</h2><span id='topic+get_row'></span>

<h3>Description</h3>

<p>Get row from well ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_row(well)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>get_row("C05" )  # "C"
</code></pre>

<hr>
<h2 id='get_single_well'>Get droplet data from a well</h2><span id='topic+get_single_well'></span>

<h3>Description</h3>

<p>Get droplet data from a well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_single_well(
  plate,
  well_id,
  empty = FALSE,
  outliers = FALSE,
  clusters = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_single_well_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="get_single_well_+3A_well_id">well_id</code></td>
<td>
<p>A well ID.</p>
</td></tr>
<tr><td><code id="get_single_well_+3A_empty">empty</code></td>
<td>
<p>Whether or not to include empty droplets.</p>
</td></tr>
<tr><td><code id="get_single_well_+3A_outliers">outliers</code></td>
<td>
<p>Whether or not to include outlier droplets.</p>
</td></tr>
<tr><td><code id="get_single_well_+3A_clusters">clusters</code></td>
<td>
<p>Whether or not to include cluster information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the fluorescence value of all droplets in the given
well.
</p>

<hr>
<h2 id='get_wells_btwn'>Get all wells between two wells (assume a rectangle layout)</h2><span id='topic+get_wells_btwn'></span>

<h3>Description</h3>

<p>Get all wells between two wells (assume a rectangle layout)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wells_btwn(well1, well2)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>get_wells_btwn("C04", "D06")
</code></pre>

<hr>
<h2 id='has_signif_negative_cluster'>Does a well have a statistically significant number of negative droplets?</h2><span id='topic+has_signif_negative_cluster'></span>

<h3>Description</h3>

<p>Classify a well as having a significant negative cluster (eg. a mutant well)
or not using a binomial test.<br /><br />
We can call a well as mutant if it is statistically significantly more than
1
mutant drops, then the mutant frequency is 1.4
significantly more than 1
P(x &gt;= 7)
= 1 - P(x &lt;= 7) + P(x = 7)
= 1 - pbinom(7, 500, .01) + dbinom(7, 500, .01)
= 0.237
&gt; 0.01
So not statistically significantly enough, so we say it's a wildtype well.
But if there are 5000 drops and 70 mutant drops (same 1.4
with higher absolute numbers), then
P(x &gt;= 70) = 1 - pbinom(70, 5000, .01) + dbinom(70, 5000, .01) = 0.004
So this is indeed significant, and this well would be deemed mutant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_signif_negative_cluster(plate, neg, pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_signif_negative_cluster_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="has_signif_negative_cluster_+3A_neg">neg</code></td>
<td>
<p>Number of negative (or mutant) drops</p>
</td></tr>
<tr><td><code id="has_signif_negative_cluster_+3A_pos">pos</code></td>
<td>
<p>Number of positive (or wildtype) drops</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the number of negative drops is statistically
significant, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='has_step'>Does a ddPCR plate have a step with this name?</h2><span id='topic+has_step'></span>

<h3>Description</h3>

<p>Does a ddPCR plate have a step with this name?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_step(plate, step)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_step_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="has_step_+3A_step">step</code></td>
<td>
<p>A step name</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dir &lt;- sample_data_dir()
plate &lt;- new_plate(dir)
steps(plate)
has_step(plate, 'REMOVE_FAILURES')
has_step(plate, 'NO_SUCH_STEP')

## End(Not run)
</code></pre>

<hr>
<h2 id='hex_positive_pnpp'>Plate type: HEX-positive PNPP</h2><span id='topic+hex_positive_pnpp'></span>

<h3>Description</h3>

<p>A ddPCR plate of type <code>hex_positive_pnpp</code>, which can also be expressed as
(HEX+)/(FAM+HEX+), is a subtype of both <code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code>
and <code><a href="#topic+wildtype_mutant_pnpp">wildtype_mutant_pnpp</a></code>. Use this plate type if your data
has three main clusters of droplets: double-negative (empty droplets),
FAM+HEX+ (wildtype droplets) and HEX+FAM- (mutant droplets).
</p>


<h3>Details</h3>

<p>Plates with this type have the following analysis steps: <code>INITIALIZE</code>,
<code>REMOVE_FAILURES</code>, <code>REMOVE_OUTLIERS</code>, <code>REMOVE_EMPTY</code>,
<code>CLASSIFY</code>, <code>RECLASSIFY</code>.
</p>
<p>Plates with this type have the following droplet clusters:
<code>UNDEFINED</code>, <code>FAILED</code>, <code>OUTLIER</code>, <code>EMPTY</code> (double-negative),
<code>RAIN</code> (not empty but not wildtype nor negative), <code>POSITIVE</code> (wildtype),
<code>NEGATIVE</code> (mutant).
</p>
<p><a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_types">plate_types</a></code><br />
<code><a href="#topic+wildtype_mutant_pnpp">wildtype_mutant_pnpp</a></code><br />
<code><a href="#topic+fam_positive_pnpp">fam_positive_pnpp</a></code><br />
<code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+remove_failures">remove_failures</a></code><br />
<code><a href="#topic+remove_outliers">remove_outliers</a></code><br />
<code><a href="#topic+remove_empty">remove_empty</a></code><br />
<code><a href="#topic+classify_droplets">classify_droplets</a></code><br />
<code><a href="#topic+reclassify_droplets">reclassify_droplets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$hex_positive_pnpp)
type(plate)
plate %&gt;% analyze %&gt;% plot

## End(Not run)
</code></pre>

<hr>
<h2 id='is_dir'>Determine if a given path is a valid directory</h2><span id='topic+is_dir'></span>

<h3>Description</h3>

<p>Determine if a given path is a valid directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dir(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dir_+3A_path">path</code></td>
<td>
<p>A file path to test</p>
</td></tr>
</table>

<hr>
<h2 id='is_dirty'>Is the plate object dirty (ie has changed since the analysis was run)?</h2><span id='topic+is_dirty'></span>

<h3>Description</h3>

<p>Is the plate object dirty (ie has changed since the analysis was run)?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dirty(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dirty_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if any plate settings have changed that require the plate
analysis to re-run; <code>FALSE</code> otherwise
</p>

<hr>
<h2 id='is_empty_plate'>Is a plate empty?</h2><span id='topic+is_empty_plate'></span>

<h3>Description</h3>

<p>A plate is considered empty if it has not yet been fully initialized, and thus
its status is 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_empty_plate(plate)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+status">status</a></code>
</p>

<hr>
<h2 id='is_file'>Determine if a given path is a valid file</h2><span id='topic+is_file'></span>

<h3>Description</h3>

<p>Determine if a given path is a valid file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_file(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_file_+3A_path">path</code></td>
<td>
<p>A file path to test</p>
</td></tr>
</table>

<hr>
<h2 id='is_range'>Is the given parameter a range?</h2><span id='topic+is_range'></span>

<h3>Description</h3>

<p>Is the given parameter a range?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_range(x)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>is_range("C05")            # FALSE
is_range(c("C05", "F05"))  # FALSE
is_range("C05")            # FALSE
is_range("C05, F05")       # TRUE
is_range("C05:F05")        # TRUE
is_range("C05.F05")        # FALSE
</code></pre>

<hr>
<h2 id='is_well_success'>Determine if a well had a successful ddPCR run</h2><span id='topic+is_well_success'></span>

<h3>Description</h3>

<p>This function runs the actual algorithm for determining which wells failed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_well_success(plate, well_id)
</code></pre>


<h3>Value</h3>

<p><code>FALSE</code> if there are obvious quality problems with the well that
suggest the ddPCR run failed; <code>TRUE</code> otherwise.
</p>

<hr>
<h2 id='is_well_success.ddpcr_plate'>Determine if a well had a successful ddPCR run</h2><span id='topic+is_well_success.ddpcr_plate'></span>

<h3>Description</h3>

<p>Determine if a well had a successful ddPCR run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
is_well_success(plate, well_id)
</code></pre>

<hr>
<h2 id='is_well_success.pnpp_experiment'>Determine if a well had a successful ddPCR run</h2><span id='topic+is_well_success.pnpp_experiment'></span>

<h3>Description</h3>

<p>Very similar to the <code>is_well_success</code> method of the base plate type,
except for this plate type we know where we expect to see droplets so we 
can save time by using QC metrics more specific to this plate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
is_well_success(plate, well_id)
</code></pre>

<hr>
<h2 id='launch'>Run the interactive analysis tool (Shiny app) in a web browser</h2><span id='topic+launch'></span>

<h3>Description</h3>

<p>In addition to the functions provided in this package, the <code>ddpcr</code> package
also provides an interactive tool that can be used to analyze ddPCR data
more easily. The tool will be launched in a web browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launch()
</code></pre>

<hr>
<h2 id='load_plate'>Load a previously saved ddPCR plate</h2><span id='topic+load_plate'></span>

<h3>Description</h3>

<p>Reloads a plate that has been saved with <code><a href="#topic+save_plate">save_plate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_plate(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_plate_+3A_file">file</code></td>
<td>
<p>Name of the file where the plate was saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plate that was saved in the given file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save_plate">save_plate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate &lt;- new_plate(sample_data_dir())
save_plate(plate, "myplate")
plate2 &lt;- load_plate("myplate")
plate3 &lt;- load_plate("myplate.rds")
identical(plate, plate2)
identical(plate, plate3)
unlink("myplate.rds")
</code></pre>

<hr>
<h2 id='local_maxima'>Get the indices of the local maxima in a list of numbers</h2><span id='topic+local_maxima'></span>

<h3>Description</h3>

<p>Get the indices of the local maxima in a list of numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_maxima(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_maxima_+3A_x">x</code></td>
<td>
<p>Vector of numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the indices of the elements that are local maxima
in the given input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local_maxima(c(1, 5, 3, 2, 4, 3))
</code></pre>

<hr>
<h2 id='local_minima'>Get the indices of the local minima in a list of numbers</h2><span id='topic+local_minima'></span>

<h3>Description</h3>

<p>Get the indices of the local minima in a list of numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_minima(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_minima_+3A_x">x</code></td>
<td>
<p>Vector of numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the indices of the elements that are local minima
in the given input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local_minima(c(1, 5, 3, 2, 4, 3))
</code></pre>

<hr>
<h2 id='lol_to_df'>Convert a list of lists returned from vapply to a dataframe</h2><span id='topic+lol_to_df'></span>

<h3>Description</h3>

<p>When running a <code>vapply</code> function and each element returns a list with
multiple values, the return value is a list of lists.  This function can be
used to convert that return value into a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lol_to_df(lol, name = "well")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lol_to_df_+3A_lol">lol</code></td>
<td>
<p>List of lists that is a result of a vapply</p>
</td></tr>
<tr><td><code id="lol_to_df_+3A_name">name</code></td>
<td>
<p>Column name to use for the name of each list</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+named_vec_to_df">named_vec_to_df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vapply(c("a", "b", "c"),
       function(x) list(low = x, up = toupper(x)),
       list(character(1), character(1))) %&gt;%
  lol_to_df("key")
</code></pre>

<hr>
<h2 id='mark_clusters'>Mark the clusters of droplets only in certain wells to their assigned cluster</h2><span id='topic+mark_clusters'></span>

<h3>Description</h3>

<p>This function simply looks at all droplets of certain wells and marks the
cluster of each droplet according to the gates that are already calculated.
This function is called once after <code><a href="#topic+classify_droplets_single">classify_droplets_single</a></code>
determines the gates for every well, and it's called again when reclassifying
wells gives us more accurate information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_clusters(plate, wells)
</code></pre>

<hr>
<h2 id='merge_dfs_overwrite_col'>Overwrite a column in a data.frame based on a matching column in another df</h2><span id='topic+merge_dfs_overwrite_col'></span>

<h3>Description</h3>

<p>Sometimes you want to merge two dataframes and specify that column X in
one dataframe should overwrite the same column in the other dataframe.
If there is a missing value in the column in the new dataframe, then the value
from the old dataframe is kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_dfs_overwrite_col(olddf, newdf, cols, bycol = "well")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_dfs_overwrite_col_+3A_olddf">olddf</code></td>
<td>
<p>The dataframe whose column will be overwritten.</p>
</td></tr>
<tr><td><code id="merge_dfs_overwrite_col_+3A_newdf">newdf</code></td>
<td>
<p>The dataframe that will use its columns to overwrite.</p>
</td></tr>
<tr><td><code id="merge_dfs_overwrite_col_+3A_cols">cols</code></td>
<td>
<p>The names of the columns that exist in both dataframes that
should be overwritten. If not provided, then all columns that are common
to both dataframes are used.</p>
</td></tr>
<tr><td><code id="merge_dfs_overwrite_col_+3A_bycol">bycol</code></td>
<td>
<p>The names of the columns to use as the key for the merge.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- function(...) data.frame(..., stringsAsFactors = FALSE)

df1 &lt;- df(a = 1:4, b = c("one", NA, "three", "four"))
df2 &lt;- df(a = 1:4, b = c("ONE", "TWO", NA, "FOUR"))
merge_dfs_overwrite_col(df1, df2, "b", "a")
merge_dfs_overwrite_col(df2, df1, "b", "a")

df3 &lt;- df(a = 1:3, b = c("one", NA, "three"))
df4 &lt;- df(a = 2:4, b = c("TWO", NA, "FOUR"))
merge_dfs_overwrite_col(df3, df4, "b", "a")
merge_dfs_overwrite_col(df4, df3, "b", "a")

df5 &lt;- df(a = 1:3, b = c("one", "two", "three"), c = letters[1:3])
df6 &lt;- df(b = c("ONE", "TWO", "THREE"), c = LETTERS[1:3], a = 1:3)
merge_dfs_overwrite_col(df5, df6, "b", "a")
merge_dfs_overwrite_col(df6, df5, "b", "a")

df7 &lt;- df(a = 1:3, b = c("one", "two", "three"))
df8 &lt;- df(a = 1:4)
merge_dfs_overwrite_col(df7, df8, "b", "a")
merge_dfs_overwrite_col(df8, df7, "b", "a")

df9 &lt;- df(a = 1:3, b = c("one", "two", "three"), c = 1:3)
df10 &lt;- df(a = 1:3, b = c("ONE", NA, "THREE"), c = 4:6)
merge_dfs_overwrite_col(df9, df10, c("b", "c"), "a")
merge_dfs_overwrite_col(df10, df9, c("b", "c"), "a")
</code></pre>

<hr>
<h2 id='meta_var_name'>Name of variable in PNPP experiment metadata</h2><span id='topic+meta_var_name'></span>

<h3>Description</h3>

<p>A default PNPP experiment uses the names &quot;positive&quot; and &quot;negative&quot; for its two
non-empty clusters. If they are changed (for example, to &quot;wildtype&quot; and &quot;mutant&quot;),
then any variable in the metadata will be renamed to use these names.
<code>meta_var_name</code> translates a default metadata variable name to the correct one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta_var_name(plate, var)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate &lt;- new_plate(dir = sample_data_dir(), type = plate_types$pnpp_experiment)
negative_name(plate) &lt;- "mutant"
meta_var_name(plate, 'num_negative_drops')
</code></pre>

<hr>
<h2 id='move_back'>Move columns to the back of a data.frame</h2><span id='topic+move_back'></span>

<h3>Description</h3>

<p>This function is taken from daattali/rsalad R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move_back(df, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_back_+3A_df">df</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="move_back_+3A_cols">cols</code></td>
<td>
<p>A vector of column names to move to the back</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(a = character(0), b = character(0), c = character(0), stringsAsFactors = TRUE)
move_back(df, "b")
move_back(df, c("b", "a"))
</code></pre>

<hr>
<h2 id='move_front'>Move columns to the front of a data.frame</h2><span id='topic+move_front'></span>

<h3>Description</h3>

<p>This function is taken from daattali/rsalad R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move_front(df, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_front_+3A_df">df</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="move_front_+3A_cols">cols</code></td>
<td>
<p>A vector of column names to move to the front.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(a = character(0), b = character(0), c = character(0), stringsAsFactors = TRUE)
move_front(df, "b")
move_front(df, c("c", "b"))
</code></pre>

<hr>
<h2 id='msg'>Write a message to the user if the 'ddpcr.verbose' option is on</h2><span id='topic+msg'></span>

<h3>Description</h3>

<p>Running a ddpcr analysis results in many messages being printed to the console.
By default, these messages are on when the user is using R interactively
and off otherwise. You can overwrite this setting with <code>options(ddpcr.verbose = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msg(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msg_+3A_...">...</code></td>
<td>
<p>Parameters to pass to <code>message()</code></p>
</td></tr>
</table>

<hr>
<h2 id='name'>Plate name</h2><span id='topic+name'></span><span id='topic+name+3C-'></span>

<h3>Description</h3>

<p>Get or set the name of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name(plate)

name(plate) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_+3A_plate">plate</code></td>
<td>
<p>A ddpcrPlate</p>
</td></tr>
<tr><td><code id="name_+3A_value">value</code></td>
<td>
<p>New name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plate name
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
name(plate)
name(plate) &lt;- "foo"
name(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='named_vec_to_df'>Convert a named vector returned from vapply to a dataframe</h2><span id='topic+named_vec_to_df'></span>

<h3>Description</h3>

<p>When running a <code>vapply</code> function and each element returns a single value,
the return value is a named vector.  This function can be used to convert
that return value into a data.frame. Similar to <code><a href="#topic+lol_to_df">lol_to_df</a></code>,
but because the output format from <code>vapply</code> is different depending on
whether a single value or multiple values are returned, a different function
needs to be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named_vec_to_df(v, name, rowname = "well")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="named_vec_to_df_+3A_v">v</code></td>
<td>
<p>Named vector that is a result of a vapply</p>
</td></tr>
<tr><td><code id="named_vec_to_df_+3A_name">name</code></td>
<td>
<p>Column name to use for the name of each element</p>
</td></tr>
<tr><td><code id="named_vec_to_df_+3A_rowname">rowname</code></td>
<td>
<p>Column name to use for the values of the rownames</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+lol_to_df">lol_to_df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vapply(c("a", "b", "c"),
       toupper,
       character(1)) %&gt;%
  named_vec_to_df("capital", "letter")
</code></pre>

<hr>
<h2 id='new_plate'>Create a new ddPCR plate</h2><span id='topic+new_plate'></span>

<h3>Description</h3>

<p>Any ddPCR analysis must start by creating a ddPCR plate object. Use this
function to read ddPCR data into R and create a plate object that can then
be analyzed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_plate(dir, type, data_files, meta_file, name, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_plate_+3A_dir">dir</code></td>
<td>
<p>The directory containing the ddPCR droplet data files, and potentially
the plate results file</p>
</td></tr>
<tr><td><code id="new_plate_+3A_type">type</code></td>
<td>
<p>A ddPCR plate type (see <code><a href="#topic+plate_types">plate_types</a></code>)</p>
</td></tr>
<tr><td><code id="new_plate_+3A_data_files">data_files</code></td>
<td>
<p>If <code>dir</code> is not provided, you can provide a vector of
file paths to the ddPCR droplet data files.</p>
</td></tr>
<tr><td><code id="new_plate_+3A_meta_file">meta_file</code></td>
<td>
<p>If <code>dir</code> is not provided, you can provide a file path
to the ddPCR results file.</p>
</td></tr>
<tr><td><code id="new_plate_+3A_name">name</code></td>
<td>
<p>Name of the dataset. If not provided, the name will be guessed
based on the filenames.</p>
</td></tr>
<tr><td><code id="new_plate_+3A_params">params</code></td>
<td>
<p>List of parameters to set for the plate. Only advanced users
should consider using this feature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for more
information on plate types.
</p>


<h3>Value</h3>

<p>A new ddPCR plate object with droplet data loaded that is ready
to be analyzed.
</p>


<h3>Providing ddPCR data</h3>

<p>The first step to using the <code>ddpcr</code> package is to get the ddPCR data into
R. This package uses as input the data files that are exported by QuantaSoft.
For a dataset with 20 wells, QuantaSoft will create 20 well files (each ending
with &quot;_Amplitude.csv&quot;) and one results file. The well files are essential for
analysis since they contain the actual droplet data, and the results file
is optional because the only information used from it is the mapping from
well IDs to sample names.
</p>
<p>The easiest way to use your ddPCR data with this package is to Export the data
from QuantaSoft into some directory, and providing that directory as the 
<code>dir</code> argument.  This way, this package will automatically find all the
data files as well as the results file.  Alternatively, you can provide the
data files (well files) manually as a list of filenames using the <code>data_files</code>
argument. If you use the <code>data_files</code> argument instead of <code>dir</code>, you
can also optionally provide the results file as the <code>meta_file</code> argument.
If no results file is provided then the wells will not be mapped to their sample
names.
</p>


<h3>Plate parameters</h3>

<p>Every plate has a set of default parameters that are used in the analysis.
You can see all the parameters of a plate with the <code><a href="#topic+params">params</a></code>
function. If you want to provide different values for some parameters when
initializing a plate, you can do that with the <code>params</code> argument. This
is considered an advanced feature.
</p>
<p>For example, if you inspect the parameters of any ddPCR plate, you will see that
by defalt the random seed used by default is 8. If you want to create
a new plate that uses a different random seed, you could do so like this:
</p>
<pre>
plate &lt;- new_plate(sample_data_dir(), params = list('GENERAL' = list('RANDOM_SEED' = 10)))
plate 
</pre> 
<p>Most numeric parameters that are used in the algorithms of the analysis steps
can be modified in a similar fashion. This can be used to fine-tune the 
analysis of a plate if you require different parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_types">plate_types</a></code><br />
<code><a href="#topic+type">type</a></code><br />
<code><a href="#topic+reset">reset</a></code><br />
<code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code><br />
<code><a href="#topic+params">params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())

## End(Not run) 
</code></pre>

<hr>
<h2 id='next_step'>Run the next step in an analysis</h2><span id='topic+next_step'></span>

<h3>Description</h3>

<p>Every ddPCR plate has a set of defined steps that are taken in order, that
together constitute &quot;analyzing&quot; the plate.  Calling the <code>next_step</code> function
will run the next step in the analysis, which may take several minutes. If you
want to run all the remaining steps at once, use <code><a href="#topic+analyze">analyze</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_step(plate, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next_step_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="next_step_+3A_n">n</code></td>
<td>
<p>The number of steps to run</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ddPCR plate after running the next step
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code><br />
<code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+steps">steps</a></code><br />
<code><a href="#topic+plate_data">plate_data</a></code><br />
<code><a href="#topic+plate_meta">plate_meta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
plate &lt;- next_step(plate)

## End(Not run) 
</code></pre>

<hr>
<h2 id='normalize_to_rds'>Normalize a file name to .rds suffix</h2><span id='topic+normalize_to_rds'></span>

<h3>Description</h3>

<p>Normalize a file name to .rds suffix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_to_rds(file)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>normalize_to_rds("somefile")       # somefile.rds
normalize_to_rds("somefile.rds")   # somefile.rds
normalize_to_rds("somefile.r")     # somefile.r.rds
</code></pre>

<hr>
<h2 id='num_to_col'>Convert a number to plate column</h2><span id='topic+num_to_col'></span>

<h3>Description</h3>

<p>Convert a number to plate column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_to_col(num)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>num_to_col(5)  # "05"
</code></pre>

<hr>
<h2 id='num_to_row'>Convert a number to plate row</h2><span id='topic+num_to_row'></span>

<h3>Description</h3>

<p>Convert a number to plate row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_to_row(num)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>num_to_row(4)  # "D"
</code></pre>

<hr>
<h2 id='other_dim'>Given an axis (X or Y), return the other</h2><span id='topic+other_dim'></span>

<h3>Description</h3>

<p>Given an axis (X or Y), return the other
</p>


<h3>Usage</h3>

<pre><code class='language-R'>other_dim(dim = c("X", "Y"))
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>other_dim("X")
other_dim("Y")
</code></pre>

<hr>
<h2 id='params'>Plate parameters</h2><span id='topic+params'></span><span id='topic+params+3C-'></span>

<h3>Description</h3>

<p>Every ddPCR plate object has adjustable parameters associated with it.
Each parameter belongs to a category of parameters, and has a unique name.
For example, there are general parameters (category 'GENERAL') that apply to
the plate as a whole, and each analysis step has its own set of parameters
that are used for the algorithm in that step.<br /><br />
You can either view all parameters of a plate by not providing any arguments,
view all parameters in a category by providing the category, or view the value
of a specific parameter by providing both the category and the parameter name.<br /><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params(plate, category, name)

params(plate, category, name) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="params_+3A_category">category</code></td>
<td>
<p>Category of parameters</p>
</td></tr>
<tr><td><code id="params_+3A_name">name</code></td>
<td>
<p>Parameter name</p>
</td></tr>
<tr><td><code id="params_+3A_value">value</code></td>
<td>
<p>New parameter value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting new parameter values should only be done by advanced users.
Note that if you change any parameters, you need to re-run the analysis in order
for the parameter changes to take effect.
</p>
<p>Tip: it can be easier to visually inspect the parameters by wrapping the
return value in a <code>str()</code>.
</p>
<p>Warning: Do not directly set the GENERAL-X_VAR or GENERAL-Y_VAR parameters.
Instead, use <code><a href="#topic+x_var">x_var</a></code> or <code><a href="#topic+y_var">y_var</a></code>.
</p>


<h3>Value</h3>

<p>If no category is provided, return all parameters. If a category is provided,
return all parameters in that category. If both a category and a name are provided,
return the value of the specific parameter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+x_var">x_var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())

# retrieving plate parameters
str(params(plate))
str(params(plate, 'GENERAL'))
params(plate, 'GENERAL', 'RANDOM_SEED')

# setting plate parameters
params(plate, 'GENERAL', 'RANDOM_SEED') &lt;- 10
str(params(plate, 'GENERAL'))

## End(Not run)
</code></pre>

<hr>
<h2 id='parent_plate_type'>Parent plate type</h2><span id='topic+parent_plate_type'></span>

<h3>Description</h3>

<p>Each ddPCR plate has a &quot;parent&quot; plate type from which it inherits all its
properties. When creating a custom plate type, if your plate type inherits from
any plate type other than the base type of <code>ddpcr_plate</code>, you must define
this function to return the parent plate type. Inheriting
from a parent plate means that the same cluster types, analysis steps, and
parameters will be used by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parent_plate_type(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent_plate_type_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for more
information on plate types.
</p>


<h3>Value</h3>

<p>The parent type of the given plate.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type">type</a></code><br />
<code><a href="#topic+define_params">define_params</a></code><br />
<code><a href="#topic+define_clusters">define_clusters</a></code><br />
<code><a href="#topic+define_steps">define_steps</a></code>
</p>

<hr>
<h2 id='parent_plate_type.ddpcr_plate'>Parent plate type of default plates</h2><span id='topic+parent_plate_type.ddpcr_plate'></span>

<h3>Description</h3>

<p>Parent plate type of default plates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
parent_plate_type(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent_plate_type.ddpcr_plate_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='parent_plate_type.default'>Parent plate type of any plate</h2><span id='topic+parent_plate_type.default'></span>

<h3>Description</h3>

<p>Parent plate type of any plate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
parent_plate_type(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent_plate_type.default_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='parent_plate_type.fam_positive_pnpp'>Parent plate type of FAM-positive PNPP</h2><span id='topic+parent_plate_type.fam_positive_pnpp'></span>

<h3>Description</h3>

<p>Parent plate type of FAM-positive PNPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fam_positive_pnpp'
parent_plate_type(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent_plate_type.fam_positive_pnpp_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='parent_plate_type.hex_positive_pnpp'>Parent plate type of HEX-positive PNPP</h2><span id='topic+parent_plate_type.hex_positive_pnpp'></span>

<h3>Description</h3>

<p>Parent plate type of HEX-positive PNPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hex_positive_pnpp'
parent_plate_type(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent_plate_type.hex_positive_pnpp_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='parent_plate_type.wildtype_mutant_pnpp'>Parent plate type of wildtype/mutant PNPP</h2><span id='topic+parent_plate_type.wildtype_mutant_pnpp'></span>

<h3>Description</h3>

<p>Parent plate type of wildtype/mutant PNPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wildtype_mutant_pnpp'
parent_plate_type(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent_plate_type.wildtype_mutant_pnpp_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>

<hr>
<h2 id='plate_data'>Plate data (droplets data)</h2><span id='topic+plate_data'></span>

<h3>Description</h3>

<p>The main piece of information in every ddPCR plate is the droplets data,
which contains the fluorescence intensities for every single droplet in
every well. After a ddPCR plate gets analyzed, this data also includes the
assigned cluster for each droplet. The plate data may be useful programatically,
but it's not very useful to a human, so if you want to visualize the plate data
you should instead plot it using <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_data(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plate_data_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing all the droplets in the plate, along with
the assigned cluster of each droplet.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_meta">plate_meta</a></code><br />
<code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
plate_data(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='plate_data+26lt+3B-'>Overwrite the plate data</h2><span id='topic+plate_data+3C-'></span>

<h3>Description</h3>

<p>When creating custom analysis steps for new plate types, it is often necessary
to set the plate data with new data, especially when assigning new clusters
to the plate droplets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_data(plate) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plate_data+2B26lt+2B3B-_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="plate_data+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>New plate data</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plate_data">plate_data</a></code>
</p>

<hr>
<h2 id='plate_meta'>Plate metadata</h2><span id='topic+plate_meta'></span>

<h3>Description</h3>

<p>The metadata is a collection of variables that describe each well in the plate.
The metadata of an unanalyzed plate only contains basic information about each
well, such as the sample name, whether the well was used, and the number of
droplets in the well. Analyzing a plate adds many more variables to the metadata,
such as the number of empty droplets, the number of outliers, the template
concentration, and more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_meta(plate, only_used = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plate_meta_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="plate_meta_+3A_only_used">only_used</code></td>
<td>
<p>If <code>TRUE</code>, only return metadata for wells that are
used in this plate (wells that have any data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the plate metadata
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_data">plate_data</a></code>
<code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
plate %&gt;% plate_meta(only_used = TRUE)
plate %&gt;% analyze %&gt;% plate_meta(only_used = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plate_meta+26lt+3B-'>Overwrite the plate metadata</h2><span id='topic+plate_meta+3C-'></span>

<h3>Description</h3>

<p>When creating custom analysis steps for new plate types, it is often necessary
to add/change variables in the plate metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_meta(plate) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plate_meta+2B26lt+2B3B-_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="plate_meta+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>New plate metadata</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plate_meta">plate_meta</a></code>
</p>

<hr>
<h2 id='plate_types'>Supported plate types</h2><span id='topic+plate_types'></span>

<h3>Description</h3>

<p>Each ddPCR plate has a plate type which determines what type of analysis to run
on the data. <code>plate_types</code> is a list containing the plate types that are
supported. If no plate type is specified, the default assumed type is
<code>ddpcr_plate</code>.<br /><br />
The most useful built-in plate types are:
<code><a href="#topic+fam_positive_pnpp">fam_positive_pnpp</a></code>,
<code><a href="#topic+hex_positive_pnpp">hex_positive_pnpp</a></code>,
<code><a href="#topic+custom_thresholds">custom_thresholds</a></code>.<br /><br />
For full details on the differences between plate types or to learn how to
add a new plate type, <a href="https://github.com/daattali/ddpcr">see the package README</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_plate">new_plate</a></code><br />
<code><a href="#topic+fam_positive_pnpp">fam_positive_pnpp</a></code><br />
<code><a href="#topic+hex_positive_pnpp">hex_positive_pnpp</a></code><br />
<code><a href="#topic+custom_thresholds">custom_thresholds</a></code><br />
<code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+wildtype_mutant_pnpp">wildtype_mutant_pnpp</a></code><br />
<code><a href="#topic+ddpcr_plate">ddpcr_plate</a></code><br />
<code><a href="#topic+type">type</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dir &lt;- sample_data_dir()
new_plate(dir, type = plate_types$ddpcr_plate)
new_plate(dir, type = plate_types$custom_thresholds)
new_plate(dir, type = plate_types$fam_positive_pnpp)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.custom_thresholds'>Plot a ddPCR plate of type custom thresholds</h2><span id='topic+plot.custom_thresholds'></span>

<h3>Description</h3>

<p>Same plot as <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code> but with a few extra
features that are specific to plates with custom thresholds. Take a look
at <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code> to see all supported parameters
and more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'custom_thresholds'
plot(
  x,
  wells,
  samples,
  ...,
  show_thresholds = TRUE,
  col_thresholds = "black",
  show_drops_empty = TRUE,
  col_drops_x_positive = "green3",
  col_drops_y_positive = "blue",
  col_drops_both_positive = "orange"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.custom_thresholds_+3A_x">x</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="plot.custom_thresholds_+3A_wells">wells</code></td>
<td>
<p>Only plot selected wells. Supports range notation, see
<code><a href="#topic+subset.ddpcr_plate">subset.ddpcr_plate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.custom_thresholds_+3A_samples">samples</code></td>
<td>
<p>Only plot selected samples.</p>
</td></tr>
<tr><td><code id="plot.custom_thresholds_+3A_...">...</code></td>
<td>
<p>Parameters to pass to <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.custom_thresholds_+3A_show_thresholds">show_thresholds</code></td>
<td>
<p>If <code>TRUE</code>, show the thresholds.</p>
</td></tr>
<tr><td><code id="plot.custom_thresholds_+3A_col_thresholds">col_thresholds</code></td>
<td>
<p>The colour of the threshold lines.</p>
</td></tr>
<tr><td><code id="plot.custom_thresholds_+3A_show_drops_empty">show_drops_empty</code></td>
<td>
<p>Whether or not to show the droplets defined as empty.</p>
</td></tr>
<tr><td><code id="plot.custom_thresholds_+3A_col_drops_x_positive">col_drops_x_positive</code></td>
<td>
<p>The colour to use for droplets that are in the
X+Y- quadrant.</p>
</td></tr>
<tr><td><code id="plot.custom_thresholds_+3A_col_drops_y_positive">col_drops_y_positive</code></td>
<td>
<p>The colour to use for droplets that are in the
X-Y+ quadrant.</p>
</td></tr>
<tr><td><code id="plot.custom_thresholds_+3A_col_drops_both_positive">col_drops_both_positive</code></td>
<td>
<p>The colour to use for droplets that are in the
X+Y+ quadrant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code><br />
<code><a href="#topic+custom_thresholds">custom_thresholds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
plate %&gt;% set_thresholds(c(5500, 8000)) %&gt;% analyze %&gt;% plot

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.ddpcr_plate'>Plot a ddPCR plate</h2><span id='topic+plot.ddpcr_plate'></span>

<h3>Description</h3>

<p>Plot the data of a ddPCR plate. A plate can be plotted throughout any stage
of the analysis, and the most up-to-date data will be shown. For example,
a plot performed after initializing a plat will show all the raw data, but
a plot performed after analyzing a plate will show information such as
empty drops and failed wells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
plot(
  x,
  wells,
  samples,
  superimpose = FALSE,
  show_full_plate = FALSE,
  show_drops = TRUE,
  show_drops_empty = FALSE,
  show_drops_outlier = FALSE,
  show_failed_wells = TRUE,
  col_drops = "black",
  col_drops_undefined = col_drops,
  col_drops_failed = col_drops,
  col_drops_empty = col_drops,
  col_drops_outlier = "orange",
  bg_plot = "transparent",
  bg_failed = "#111111",
  bg_unused = "#FFFFFF",
  alpha_drops = 0.2,
  alpha_drops_outlier = 1,
  alpha_bg_failed = 0.7,
  xlab = x_var(plate),
  ylab = y_var(plate),
  title = NULL,
  show_grid = FALSE,
  show_grid_labels = FALSE,
  drops_size = 1,
  text_size_title = 14,
  text_size_row_col = 12,
  text_size_axes_labels = 12,
  text_size_grid_labels = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ddpcr_plate_+3A_x">x</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_wells">wells</code></td>
<td>
<p>Only plot selected wells. Supports range notation, see
<code><a href="#topic+subset.ddpcr_plate">subset.ddpcr_plate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_samples">samples</code></td>
<td>
<p>Only plot selected samples.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_superimpose">superimpose</code></td>
<td>
<p>If <code>TRUE</code>, show all wells superimposed in one plot;
otherwise, show wells in a grid.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_show_full_plate">show_full_plate</code></td>
<td>
<p>If <code>TRUE</code>, show full 96-well plate; otherwise,
show only plate rows and columns that are used.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_show_drops">show_drops</code></td>
<td>
<p>Whether or not to show the droplets. Setting to <code>FALSE</code>
is not useful if the droplets are the only thing shown in the plot, but it
can be useful if there is other information depicated in the plot, such as
any background colours or text that may appear in each well.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_show_drops_empty">show_drops_empty</code></td>
<td>
<p>Whether or not to show the droplets defined as empty.
See 'Droplet visibility options' below.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_show_drops_outlier">show_drops_outlier</code></td>
<td>
<p>Whether or not to show the droplets defined as
outliers. See 'Droplet visibility options' below.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_show_failed_wells">show_failed_wells</code></td>
<td>
<p>Whether or not to include wells that are deemed
as failed ddPCR runs.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_col_drops">col_drops</code></td>
<td>
<p>The default colour to use for any droplet.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_col_drops_undefined">col_drops_undefined</code></td>
<td>
<p>The colour to use for droplets that have not been
analyzed yet. See 'Droplet visibility options' below.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_col_drops_failed">col_drops_failed</code></td>
<td>
<p>The colour to use for droplets in failed wells.
See 'Droplet visibility options' below.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_col_drops_empty">col_drops_empty</code></td>
<td>
<p>The colour to use for empty droplets.
See 'Droplet visibility options' below.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_col_drops_outlier">col_drops_outlier</code></td>
<td>
<p>The colour to use for outlier droplets.
See 'Droplet visibility options' below.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_bg_plot">bg_plot</code></td>
<td>
<p>The background colour for the plot.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_bg_failed">bg_failed</code></td>
<td>
<p>The background colour to use for failed wells.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_bg_unused">bg_unused</code></td>
<td>
<p>The background colour to use for unused wells.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_alpha_drops">alpha_drops</code></td>
<td>
<p>The transparency of droplets.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_alpha_drops_outlier">alpha_drops_outlier</code></td>
<td>
<p>The transparency of outlier droplets.
See 'Droplet visibility options' below.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_alpha_bg_failed">alpha_bg_failed</code></td>
<td>
<p>The transparency of the background of failed wells.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_xlab">xlab</code></td>
<td>
<p>The label on the X axis.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_ylab">ylab</code></td>
<td>
<p>The label on the Y axis.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_title">title</code></td>
<td>
<p>The title for the plot.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_show_grid">show_grid</code></td>
<td>
<p>Whether or not to show grid lines.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_show_grid_labels">show_grid_labels</code></td>
<td>
<p>Whether or not to show numeric labels for the grid
lines along the axes.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_drops_size">drops_size</code></td>
<td>
<p>Size of droplets.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_text_size_title">text_size_title</code></td>
<td>
<p>Text size of the title.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_text_size_row_col">text_size_row_col</code></td>
<td>
<p>Text size of the row and column labels.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_text_size_axes_labels">text_size_axes_labels</code></td>
<td>
<p>Text size of the X/Y axis labels.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_text_size_grid_labels">text_size_grid_labels</code></td>
<td>
<p>Text size of the numeric grid line labels.</p>
</td></tr>
<tr><td><code id="plot.ddpcr_plate_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot object.
</p>


<h3>Droplet visibility options</h3>

<p>To make it easier to support any plate type with any types of droplet
clusters, there are three categories of special parameters that can always
be used:
</p>

<ul>
<li><p><code>show_drops_*</code> Whether or not to show a specific group of
droplets.
</p>
</li>
<li><p><code>col_drops_*</code> What colour to use for a specific group of
droplets.
</p>
</li>
<li><p><code>alpha_drops_*</code> What transparency to use for a specific group
of droplets.
</p>
</li></ul>

<p>The <code>*</code> in the parameter name can be replaced by the name of any
droplet cluster. Use the <code><a href="#topic+clusters">clusters</a></code> function to 
find out what clusters the droplets in a plate can be assigned to.
</p>
<p>For example, the default clusters that exist in a plain <code>ddpcr_plate</code>
are &quot;UNDEFINED&quot;, &quot;FAILED&quot;, &quot;OUTLIER&quot;, and &quot;EMPTY&quot;.  This means that if you
want to hide the empty drops and make the transparency of drops in failed
wells 0.5, you could add the two parameters <code>show_drops_empty = FALSE</code>
and <code>alpha_drops_failed = 0.5</code>. Note that letter case is not important.
If another plate type defines a new clsuter of type &quot;MUTANT&quot; and you want to
show these drops in red, you can add the parameter
<code>col_drops_mutant = "red"</code>.
</p>
<p>Note that some of the more common combinations of these parameters are
defined by default (for example, <code>col_drops_failed</code> is defined in the
list of parameters), but these three parameter categories will work for
any cluster type.
</p>


<h3>Extending ddpcr_plate</h3>

<p>If you create your own plate type, this default plot function might be
enough if there is no extra information you want to display in a plot.
If you do need to provide a more customized plot function, it can be
a good idea to use the output from this plot function as a basis and only
add the code that is necessary to append to the plot.  See
<code><a href="#topic+plot.custom_thresholds">plot.custom_thresholds</a></code> as an example of how to
extend this plot function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
plot(plate)
plate &lt;- plate %&gt;% analyze
plot(plate)
plot(plate, "A01:C05", show_drops_empty = TRUE, col_drops_empty = "red")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.pnpp_experiment'>Plot a ddPCR plate of type PNPP experiment</h2><span id='topic+plot.pnpp_experiment'></span>

<h3>Description</h3>

<p>Same plot as <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code> but with a few extra
features that are specific to PNPP experiments The main additions are that
the negative frequency of each well can be written in each well, and well
background colours can be used to differentiate between wells with a
significant negative cluster vs wells with mostly positive drops. Take a look
at <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code> to see all supported parameters
and more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
plot(
  x,
  wells,
  samples,
  ...,
  col_drops_negative = "purple3",
  col_drops_positive = "green3",
  col_drops_rain = "black",
  show_negative_freq = TRUE,
  text_size_negative_freq = 4,
  alpha_drops_low_negative_freq = 0.5,
  show_low_high_neg_freq = TRUE,
  bg_negative = "purple3",
  bg_positive = "green3",
  alpha_bg_low_high_neg_freq = 0.1,
  superimpose = FALSE,
  show_drops = TRUE,
  drops_size = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pnpp_experiment_+3A_x">x</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_wells">wells</code></td>
<td>
<p>Only plot selected wells. Supports range notation, see
<code><a href="#topic+subset.ddpcr_plate">subset.ddpcr_plate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_samples">samples</code></td>
<td>
<p>Only plot selected samples.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_...">...</code></td>
<td>
<p>Parameters to pass to <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_col_drops_negative">col_drops_negative</code></td>
<td>
<p>The colour to use for negative droplets.
See 'Droplet visibility options' for <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_col_drops_positive">col_drops_positive</code></td>
<td>
<p>The colour to use for positive droplets.
See 'Droplet visibility options' for <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_col_drops_rain">col_drops_rain</code></td>
<td>
<p>The colour to use for rain droplets.
See 'Droplet visibility options' for <code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_show_negative_freq">show_negative_freq</code></td>
<td>
<p>If <code>TRUE</code>, show the negative frequency
as a percentage on each well.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_text_size_negative_freq">text_size_negative_freq</code></td>
<td>
<p>Text size of the printed negative frequencies.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_alpha_drops_low_negative_freq">alpha_drops_low_negative_freq</code></td>
<td>
<p>Transparency of negative droplets
in wells with mostly positive droplets. In wells where there are very few
negative droplets, it might be useful to make them more visible by increasing
their transparency.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_show_low_high_neg_freq">show_low_high_neg_freq</code></td>
<td>
<p>Differentiate between wells with a high vs
low negative frequency by having a different background colour to the well.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_bg_negative">bg_negative</code></td>
<td>
<p>The background colour for wells that have a significant
negative cluster.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_bg_positive">bg_positive</code></td>
<td>
<p>The background colour for wells that have mostly positive
drops.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_alpha_bg_low_high_neg_freq">alpha_bg_low_high_neg_freq</code></td>
<td>
<p>The transparency value for <code>bg_negative</code>
and <code>bg_positive</code>.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_superimpose">superimpose</code></td>
<td>
<p>If <code>TRUE</code>, show all wells superimposed in one plot;
otherwise, show wells in a grid.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_show_drops">show_drops</code></td>
<td>
<p>Whether or not to show the droplets. Setting to <code>FALSE</code>
is not useful if the droplets are the only thing shown in the plot, but it
can be useful if there is other information depicated in the plot, such as
any background colours or text that may appear in each well.</p>
</td></tr>
<tr><td><code id="plot.pnpp_experiment_+3A_drops_size">drops_size</code></td>
<td>
<p>Size of droplets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code><br />
<code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$pnpp_experiment)
positive_dim(plate) &lt;- "Y"
plot(plate)
plate &lt;- plate %&gt;% analyze
plot(plate)
plot(plate, "A01:C05", col_drops_rain = "blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.wildtype_mutant_pnpp'>Plot a ddPCR plate of type wildtype/mutant PNPP</h2><span id='topic+plot.wildtype_mutant_pnpp'></span>

<h3>Description</h3>

<p>Same plot as <code><a href="#topic+plot.pnpp_experiment">plot.pnpp_experiment</a></code> but with a few extra
features that are specific to wildtype/mutant PNPP plates. Take a look
at <code><a href="#topic+plot.pnpp_experiment">plot.pnpp_experiment</a></code> to see all supported parameters
and more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wildtype_mutant_pnpp'
plot(
  x,
  wells,
  samples,
  ...,
  col_drops_mutant = "purple3",
  col_drops_wildtype = "green3",
  col_drops_rain = "black",
  show_mutant_freq = TRUE,
  text_size_mutant_freq = 4,
  alpha_drops_low_mutant_freq = 0.5,
  show_low_high_mut_freq = TRUE,
  bg_mutant = "purple3",
  bg_wildtype = "green3",
  alpha_bg_low_high_mut_freq = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_x">x</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_wells">wells</code></td>
<td>
<p>Only plot selected wells. Supports range notation, see
<code><a href="#topic+subset.ddpcr_plate">subset.ddpcr_plate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_samples">samples</code></td>
<td>
<p>Only plot selected samples.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_...">...</code></td>
<td>
<p>Parameters to pass to <code><a href="#topic+plot.pnpp_experiment">plot.pnpp_experiment</a></code>.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_col_drops_mutant">col_drops_mutant</code></td>
<td>
<p>The colour to use for mutant droplets.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_col_drops_wildtype">col_drops_wildtype</code></td>
<td>
<p>The colour to use for wildtype droplets.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_col_drops_rain">col_drops_rain</code></td>
<td>
<p>The colour to use for rain droplets.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_show_mutant_freq">show_mutant_freq</code></td>
<td>
<p>If <code>TRUE</code>, show the mutant frequency
as a percentage on each well.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_text_size_mutant_freq">text_size_mutant_freq</code></td>
<td>
<p>Text size of the printed mutant frequencies.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_alpha_drops_low_mutant_freq">alpha_drops_low_mutant_freq</code></td>
<td>
<p>Transparency of mutant droplets
in wells with mostly wildtype droplets. In wells where there are very few
mutant droplets, it might be useful to make them more visible by increasing
their transparency.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_show_low_high_mut_freq">show_low_high_mut_freq</code></td>
<td>
<p>Differentiate between wells with a high vs
low mutant frequency by having a different background colour to the well.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_bg_mutant">bg_mutant</code></td>
<td>
<p>The background colour for wells that have a significant
mutant cluster.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_bg_wildtype">bg_wildtype</code></td>
<td>
<p>The background colour for wells that have mostly wildtype
drops.</p>
</td></tr>
<tr><td><code id="plot.wildtype_mutant_pnpp_+3A_alpha_bg_low_high_mut_freq">alpha_bg_low_high_mut_freq</code></td>
<td>
<p>The transparency value for <code>bg_mutant</code>
and <code>bg_wildtype</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ddpcr_plate">plot.ddpcr_plate</a></code><br />
<code><a href="#topic+plot.pnpp_experiment">plot.pnpp_experiment</a></code><br />
<code><a href="#topic+wildtype_mutant_pnpp">wildtype_mutant_pnpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$fam_positive_pnpp) %&gt;% analyze
wells_wildtype(plate)
plot(plate)
plate &lt;- plate %&gt;% analyze
plot(plate)
plot(plate, "A01:C05", col_drops_rain = "blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='pnpp_experiment'>Plate type: PNPP experiment</h2><span id='topic+pnpp_experiment'></span>

<h3>Description</h3>

<p>PNPP stands for &quot;Positive-Negative;Positive-Positive&quot;, which is a reflection
of the clusters of non-empty droplets in the wells. Use this plate type when
your ddPCR data has three main clusters: double-negative (FAM-HEX-; empty droplets),
double-positive (FAM+HEX+; represent the &quot;PP&quot; in PNPP), and singly-positive
(either FAM+HEX- or HEX+FAM-; represent the &quot;NP&quot; in PNPP).
</p>


<h3>Details</h3>

<p>Every <code>pnpp_experiment</code> plate must define which dimension is its <em>positive
dimension</em>.  The positive dimension is defined as the dimension that corresponds
to the dye that has a high fluoresence intensity in all non-empty droplets. The other
dimension is defined as the <em>variable dimension</em>. For example, assuming
the HEX dye is plotted along the X axis and the FAM dye is along the Y axis,
a FAM+/FAM+HEX+ plate will have &quot;Y&quot; as its positive dimension because both
non-empty clusters have FAM+ droplets. Similarly, a HEX+/FAM+HEX+ plate will
have &quot;X&quot; as its positive dimension.
</p>
<p>The positive dimension must be set in order to use a <code>pnpp_experiment</code>.
It is not recommended to use this type directly; instead you should use one
of the subtypes (<code><a href="#topic+fam_positive_pnpp">fam_positive_pnpp</a></code> or
<code><a href="#topic+hex_positive_pnpp">hex_positive_pnpp</a></code>). If you do use this type directly,
you must set the positive dimension with <code><a href="#topic+positive_dim">positive_dim</a></code>.
</p>
<p>Plates with this type have the following analysis steps: <code>INITIALIZE</code>,
<code>REMOVE_FAILURES</code>, <code>REMOVE_OUTLIERS</code>, <code>REMOVE_EMPTY</code>,
<code>CLASSIFY</code>, <code>RECLASSIFY</code>.
</p>
<p>Plates with this type have the following droplet clusters:
<code>UNDEFINED</code>, <code>FAILED</code>, <code>OUTLIER</code>, <code>EMPTY</code> (double-negative),
<code>RAIN</code>, <code>POSITIVE</code>, <code>NEGATIVE</code>.
</p>
<p><a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_types">plate_types</a></code><br />
<code><a href="#topic+fam_positive_pnpp">fam_positive_pnpp</a></code><br />
<code><a href="#topic+hex_positive_pnpp">hex_positive_pnpp</a></code><br />
<code><a href="#topic+wildtype_mutant_pnpp">wildtype_mutant_pnpp</a></code><br />
<code><a href="#topic+positive_dim">positive_dim</a></code><br />
<code><a href="#topic+wells_positive">wells_positive</a></code><br />
<code><a href="#topic+wells_negative">wells_negative</a></code><br />
<code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+remove_failures">remove_failures</a></code><br />
<code><a href="#topic+remove_outliers">remove_outliers</a></code><br />
<code><a href="#topic+remove_empty">remove_empty</a></code><br />
<code><a href="#topic+classify_droplets">classify_droplets</a></code><br />
<code><a href="#topic+reclassify_droplets">reclassify_droplets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$pnpp_experiment)
type(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='point2d'>Representation of a 2D point</h2><span id='topic+point2d'></span>

<h3>Description</h3>

<p>Representation of a 2D point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point2d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point2d_+3A_x">x</code></td>
<td>
<p>A 2-element numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>point2d</code> with the given coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>point2d(c(10, 20))
</code></pre>

<hr>
<h2 id='positive_dim'>Positive dimension in a PNPP experiment</h2><span id='topic+positive_dim'></span><span id='topic+positive_dim+3C-'></span>

<h3>Description</h3>

<p>Get or set the positive dimension (X or Y), which is defined as the dimension
that has a high fluorescence intensity in all non-empty drops in a
<code>pnpp_experiment</code> plate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>positive_dim(plate)

positive_dim(plate) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="positive_dim_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="positive_dim_+3A_value">value</code></td>
<td>
<p>The dimension to set as the positive dimension (&quot;X&quot; or &quot;Y&quot;)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+variable_dim">variable_dim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate &lt;- new_plate(dir = sample_data_dir(), type = plate_types$pnpp_experiment)
positive_dim(plate) &lt;- "Y"
</code></pre>

<hr>
<h2 id='positive_dim_var'>Name of dye in positive dimension in PNPP experiment</h2><span id='topic+positive_dim_var'></span>

<h3>Description</h3>

<p>Get the name of the dye that is along the positive dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>positive_dim_var(plate)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+positive_dim">positive_dim</a></code>
</p>

<hr>
<h2 id='positive_name'>Name identifier for positive and negative droplets</h2><span id='topic+positive_name'></span><span id='topic+positive_name+3C-'></span><span id='topic+negative_name'></span><span id='topic+negative_name+3C-'></span>

<h3>Description</h3>

<p>Name identifier for positive and negative droplets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>positive_name(plate)

positive_name(plate) &lt;- value

negative_name(plate)

negative_name(plate) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="positive_name_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="positive_name_+3A_value">value</code></td>
<td>
<p>The identifier to use for droplets in the positive/negative cluster.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code>
</p>

<hr>
<h2 id='print.ddpcr_plate'>Print info about a ddPCR plate</h2><span id='topic+print.ddpcr_plate'></span>

<h3>Description</h3>

<p>Print info about a ddPCR plate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
print(x, ...)
</code></pre>

<hr>
<h2 id='quiet'>Suppress all output from an expression. Works cross-platform.</h2><span id='topic+quiet'></span>

<h3>Description</h3>

<p>Suppress all output from an expression. Works cross-platform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quiet(expr, all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quiet_+3A_expr">expr</code></td>
<td>
<p>Expression to run.</p>
</td></tr>
<tr><td><code id="quiet_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code> then suppress warnings and messages as well;
otherwise, only suppress printed output (such as from <code>print</code> or
<code>cat</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='range_list_to_vec'>Convert a list of ranges to a vector of its individual components</h2><span id='topic+range_list_to_vec'></span>

<h3>Description</h3>

<p>Convert a list of ranges to a vector of its individual components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_list_to_vec(rangel)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>range_list_to_vec("A01")
range_list_to_vec("A01:A04")
range_list_to_vec("A01, B03")
range_list_to_vec("A01, B02:C04, C07")
</code></pre>

<hr>
<h2 id='range_to_endpoints'>Extract the two endpoints of a range</h2><span id='topic+range_to_endpoints'></span>

<h3>Description</h3>

<p>Extract the two endpoints of a range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_to_endpoints(range)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>range_to_endpoints("B05:G09")   # c("B05", "G09")
range_to_endpoints("B05")       # c("B05", "B05")
</code></pre>

<hr>
<h2 id='range_to_seq'>Convert a range to a vector of all elements between the endpoints</h2><span id='topic+range_to_seq'></span>

<h3>Description</h3>

<p>Convert a range to a vector of all elements between the endpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_to_seq(rng)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>range_to_seq(c(5, 8))   # 5:8
range_to_seq(c(8, 5))   # 5:8
</code></pre>

<hr>
<h2 id='reclassify_droplets'>Analysis step: Reclassify droplets</h2><span id='topic+reclassify_droplets'></span>

<h3>Description</h3>

<p>After classifying droplets into clusters in each well individually, it may
be useful to attempt to reclassify droplets in wells where the gates are
not very clearly defined. This function uses information taken from wells
with a high negative frquency (where the gate is easily defined) to adjust
the gates in the other wells.<br /><br />
<a href="https://github.com/daattali/ddpcr#advanced-topic-2-algorithms-used-in-each-step">See the README</a> for
more information about the algorithm used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclassify_droplets(plate)
</code></pre>


<h3>Details</h3>

<p>This function is recommended to be run as part of an analysis pipeline (ie.
within the <code><a href="#topic+analyze">analyze</a></code> function) rather than being called
directly.
</p>


<h3>Note</h3>

<p>This is an S3 generic, which means that different ddPCR plate types can
implement this function differently. 
<a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on how to implement custom ddPCR plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+reclassify_droplets_single">reclassify_droplets_single</a></code><br />
<code><a href="#topic+mark_clusters">mark_clusters</a></code>
</p>

<hr>
<h2 id='reclassify_droplets_single'>Reclassify droplets in a well</h2><span id='topic+reclassify_droplets_single'></span>

<h3>Description</h3>

<p>Reclassify droplets in a well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclassify_droplets_single(plate, well_id, ...)
</code></pre>

<hr>
<h2 id='reclassify_droplets_single.pnpp_experiment'>Reclassify droplets in a well</h2><span id='topic+reclassify_droplets_single.pnpp_experiment'></span>

<h3>Description</h3>

<p>Reclassify droplets in a well given the ratio of where to place the MT border
over the median WT drops
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
reclassify_droplets_single(plate, well_id, ..., consensus_border_ratio)
</code></pre>

<hr>
<h2 id='reclassify_droplets.pnpp_experiment'>Analysis step: Reclassify droplets</h2><span id='topic+reclassify_droplets.pnpp_experiment'></span>

<h3>Description</h3>

<p>Analysis step: Reclassify droplets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
reclassify_droplets(plate)
</code></pre>

<hr>
<h2 id='remove_empty'>Analysis step: Remove empty droplets</h2><span id='topic+remove_empty'></span>

<h3>Description</h3>

<p>Find the empty droplets (double-negative droplets) in each well in a plate
and assign these droplets to the <em>EMPTY</em> cluster. <br /><br />
<a href="https://github.com/daattali/ddpcr#advanced-topic-2-algorithms-used-in-each-step">See the README</a> for
more information about the algorithm used to find empty droplets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_empty(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_empty_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is recommended to be run as part of an analysis pipeline (ie.
within the <code><a href="#topic+analyze">analyze</a></code> function) rather than being called
directly.
</p>


<h3>Value</h3>

<p>A ddPCR plate with the empty droplets marked as empty. The plate's
metadata will have a few new variables relating to the empty droplets.
</p>


<h3>Note</h3>

<p>This is an S3 generic, which means that different ddPCR plate types can
implement this function differently.
<a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on how to implement custom ddPCR plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+get_empty_cutoff">get_empty_cutoff</a></code>
</p>

<hr>
<h2 id='remove_empty.ddpcr_plate'>Analysis step: Remove empty droplets</h2><span id='topic+remove_empty.ddpcr_plate'></span>

<h3>Description</h3>

<p>Analysis step: Remove empty droplets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
remove_empty(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_empty.ddpcr_plate_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>

<hr>
<h2 id='remove_empty.pnpp_experiment'>Analysis step: Remove empty droplets</h2><span id='topic+remove_empty.pnpp_experiment'></span>

<h3>Description</h3>

<p>Analysis step: Remove empty droplets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pnpp_experiment'
remove_empty(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_empty.pnpp_experiment_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>

<hr>
<h2 id='remove_failures'>Analysis step: Remove failed wells</h2><span id='topic+remove_failures'></span>

<h3>Description</h3>

<p>Check if any wells have failed the ddPCR experiment by checking a series
of quality control metrics.  If any well is deemed as a failure, all the droplets
in that well will be assigned to the <em>FAILED</em> cluster.<br /><br />
<a href="https://github.com/daattali/ddpcr#advanced-topic-2-algorithms-used-in-each-step">See the README</a> for
more information about the algorithm used to find failed wells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_failures(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_failures_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is recommended to be run as part of an analysis pipeline (ie.
within the <code><a href="#topic+analyze">analyze</a></code> function) rather than being called
directly.
</p>


<h3>Value</h3>

<p>A ddPCR plate with the droplets in failed wells marked as failed. The plate's
metadata will have a new variable <code>success</code> which will be <code>FALSE</code>
for any failed well and <code>TRUE</code> for all others.
</p>


<h3>Note</h3>

<p>This is an S3 generic, which means that different ddPCR plate types can
implement this function differently.
<a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on how to implement custom ddPCR plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+is_well_success">is_well_success</a></code>
</p>

<hr>
<h2 id='remove_failures.ddpcr_plate'>Analysis step: Remove failed wells</h2><span id='topic+remove_failures.ddpcr_plate'></span>

<h3>Description</h3>

<p>Analysis step: Remove failed wells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
remove_failures(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_failures.ddpcr_plate_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>

<hr>
<h2 id='remove_outliers'>Analysis Step: Remove outlier droplets</h2><span id='topic+remove_outliers'></span>

<h3>Description</h3>

<p>Identify droplets that have an abnormally high fluorescence intensity as
outliers. Any such droplets will be assigned to the <em>OUTLIER</em> cluster.<br /><br />
<a href="https://github.com/daattali/ddpcr#advanced-topic-2-algorithms-used-in-each-step">See the README</a> for
more information about the algorithm used to find outlier droplets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_outliers(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_outliers_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is recommended to be run as part of an analysis pipeline (ie.
within the <code><a href="#topic+analyze">analyze</a></code> function) rather than being called
directly.
</p>


<h3>Value</h3>

<p>A ddPCR plate with outlier droplets marked as outliers. The plate's
metadata will have a new variable <code>drops_outlier</code> which will count the
number of outlier droplets in each well.
</p>


<h3>Note</h3>

<p>This is an S3 generic, which means that different ddPCR plate types can
implement this function differently. 
<a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on how to implement custom ddPCR plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+get_outlier_cutoff">get_outlier_cutoff</a></code>
</p>

<hr>
<h2 id='remove_outliers.ddpcr_plate'>Analysis Step: Remove outlier droplets</h2><span id='topic+remove_outliers.ddpcr_plate'></span>

<h3>Description</h3>

<p>Analysis Step: Remove outlier droplets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
remove_outliers(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_outliers.ddpcr_plate_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>

<hr>
<h2 id='reset'>Reset a plate</h2><span id='topic+reset'></span>

<h3>Description</h3>

<p>Reset a ddPCR plate object back to its original state. After resetting a plate,
all the analysis progress will be lost, but the original droplet data and
plate metadata will be kept. Two common reasons to reset a plate are either
to restart the analysis, or to re-analyze the plate as a different plate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset(plate, type, params, keep_type = FALSE, keep_params = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="reset_+3A_type">type</code></td>
<td>
<p>A ddPCR plate type (see <code><a href="#topic+plate_types">plate_types</a></code>)</p>
</td></tr>
<tr><td><code id="reset_+3A_params">params</code></td>
<td>
<p>List of parameters to set for the plate. Only advanced users
should consider using this feature. See <code><a href="#topic+new_plate">new_plate</a></code> for usage.</p>
</td></tr>
<tr><td><code id="reset_+3A_keep_type">keep_type</code></td>
<td>
<p>If <code>TRUE</code> then use keep the same plate type as <code>plate</code></p>
</td></tr>
<tr><td><code id="reset_+3A_keep_params">keep_params</code></td>
<td>
<p>If <code>TRUE</code> then keep the same plate parameters of <code>plate</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new unanalyzed ddPCR plate
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_types">plate_types</a></code><br />
<code><a href="#topic+new_plate">new_plate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
plate &lt;- reset(plate, type=plate_types$fam_positive_pnpp)

## End(Not run) 
</code></pre>

<hr>
<h2 id='row_to_num'>Convert a plate row to a number</h2><span id='topic+row_to_num'></span>

<h3>Description</h3>

<p>Convert a plate row to a number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_to_num(row)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>row_to_num("D")  # 4L
</code></pre>

<hr>
<h2 id='sample_data'>Get sample data</h2><span id='topic+sample_data'></span><span id='topic+sample_data_dir'></span><span id='topic+sample_data_file'></span><span id='topic+sample_results_file'></span><span id='topic+sample_plate'></span>

<h3>Description</h3>

<p>These functions return sample data files or folders and can be used to
load ddPCR plates with sample data. They are used primarily in the
documentation examples, but you can also use them for learning purposes.
There are two sample datasetes: a small dataset and a large dataset. The
small dataset contains the full raw data, but the large dataset only
includes the processed data because the raw data would be too large.
<br /><br />
<code>sample_data_dir</code>: get the directory of the small or large sample dataset<br />
<code>sample_data_file</code>: get path to one of the data files in the small sample dataset<br />
<code>sample_results_file</code>: get path to the results file of the small sample dataset<br />
<code>sample_plate</code>: get the ddpcr plate object containing the data of the small or large dataset<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_data_dir()

sample_data_file()

sample_results_file()

sample_plate(size = c("small", "large"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_data_+3A_size">size</code></td>
<td>
<p>The dataset to retrieve, either <code>"small"</code> or <code>"large"</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plate1 &lt;- new_plate(dir = sample_data_dir())
plate2 &lt;- new_plate(data_files = sample_data_file(), meta_file = sample_results_file())
plate3 &lt;- sample_plate()
</code></pre>

<hr>
<h2 id='save_plate'>Save a ddPCR plate</h2><span id='topic+save_plate'></span>

<h3>Description</h3>

<p>Saves a plate to a file, including all its data, parameters, and current
analysis state.  The file can be read back later using 
<code><a href="#topic+load_plate">load_plate</a></code>.  The file is not human-readable - if
you want to save the droplets data or the metadata of a plate, then first
retrieve the data using <code><a href="#topic+plate_data">plate_data</a></code> or
<code><a href="#topic+plate_meta">plate_meta</a></code> and save it with 
<code><a href="utils.html#topic+write.csv">write.csv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_plate(plate, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_plate_+3A_plate">plate</code></td>
<td>
<p>Plate object to save.</p>
</td></tr>
<tr><td><code id="save_plate_+3A_file">file</code></td>
<td>
<p>Name of the file where the plate will be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The given plate, unchanged.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_plate">load_plate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate &lt;- new_plate(sample_data_dir())
save_plate(plate, "myplate")
unlink("myplate.rds")
</code></pre>

<hr>
<h2 id='set_default_params'>Reset plate parameters to their defaults</h2><span id='topic+set_default_params'></span>

<h3>Description</h3>

<p>Use this function to reset a ddPCR plate's parameters back to their default
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_default_params(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_default_params_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plate with the parameters set to the plate type's default values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params">params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
x_var(plate) &lt;- "VIC"
plate &lt;- set_default_params(plate)

## End(Not run) 
</code></pre>

<hr>
<h2 id='status'>Plate status</h2><span id='topic+status'></span><span id='topic+status+3C-'></span>

<h3>Description</h3>

<p>The status of a plate corresponds to the number of analysis steps that have
taken place. A plate that has been initialized but has not yet been analyzed
at all has status 1.<br /><br />
If you add custom analysis steps to a new plate type, you should make sure
to update the status of the plate after each step. You can use
<code><a href="#topic+check_step">check_step</a></code> to ensure that the plate is at an appropriate
status before beginning each step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status(plate)

status(plate) &lt;- value
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+steps">steps</a></code><br />
<code><a href="#topic+check_step">check_step</a></code>
</p>

<hr>
<h2 id='step'>Get step ID by step name</h2><span id='topic+step'></span>

<h3>Description</h3>

<p>Get step ID by step name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step(plate, step)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
# see what step names exist and their order
steps(plate)
step(plate, 'REMOVE_OUTLIERS')

## End(Not run)
</code></pre>

<hr>
<h2 id='step_begin'>Inform the user that an analysis step is starting</h2><span id='topic+step_begin'></span>

<h3>Description</h3>

<p>When an analysis step starts running, it's recommended to call this function
so that the user will know what step is taking place. The time when a step
begins gets recorded so that the user will see exactly how long it took.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_begin(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_begin_+3A_text">text</code></td>
<td>
<p>The text to show the user when this step begins.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+step_end">step_end</a></code>
</p>

<hr>
<h2 id='step_end'>Inform the user that an analysis step finished</h2><span id='topic+step_end'></span>

<h3>Description</h3>

<p>When an analysis step is done, it's recommended to call this function
so that the user will know the step finished. The time when a step
finishes gets recorded so that the user will see exactly how long it took.
An earlier call to <code>step_begin</code> must have taken place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_end()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+step_begin">step_begin</a></code>
</p>

<hr>
<h2 id='step_name'>Get step name by ID</h2><span id='topic+step_name'></span>

<h3>Description</h3>

<p>Get step name by ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_name(plate, step)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
# see what step names exist and their order
steps(plate)
step_name(plate, 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='steps'>Analysis steps of a ddPCR plate</h2><span id='topic+steps'></span>

<h3>Description</h3>

<p>Every ddPCR plate type has an ordered set of steps that are run to analyze
the data. You can run all the steps with <code><a href="#topic+analyze">analyze</a></code> or
run the analysis step by step with <code><a href="#topic+next_step">next_step</a></code>. The order
of the steps in the list is the order in which they are run on the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steps(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steps_+3A_plate">plate</code></td>
<td>
<p>a ddPCR plate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector, where every name is the human-readable
name of an analysis step, and every value is the name of the function
used to perform the step.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+next_step">next_step</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dir &lt;- sample_data_dir()
new_plate(dir) %&gt;% steps
new_plate(dir, plate_types$fam_positive_pnpp) %&gt;% steps

## End(Not run)
</code></pre>

<hr>
<h2 id='subset.ddpcr_plate'>Subsetting a ddPCR plate</h2><span id='topic+subset.ddpcr_plate'></span>

<h3>Description</h3>

<p>Select specific wells or samples from a ddPCR plate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddpcr_plate'
subset(x, wells, samples, targets_ch1, targets_ch2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.ddpcr_plate_+3A_x">x</code></td>
<td>
<p>The ddPCR plate to subset from.</p>
</td></tr>
<tr><td><code id="subset.ddpcr_plate_+3A_wells">wells</code></td>
<td>
<p>Vector or range notation of wells to select (see Range Notation
section for more information).</p>
</td></tr>
<tr><td><code id="subset.ddpcr_plate_+3A_samples">samples</code></td>
<td>
<p>Vector of sample names to select.</p>
</td></tr>
<tr><td><code id="subset.ddpcr_plate_+3A_targets_ch1">targets_ch1</code></td>
<td>
<p>Vector of target names in channel 1 to select.</p>
</td></tr>
<tr><td><code id="subset.ddpcr_plate_+3A_targets_ch2">targets_ch2</code></td>
<td>
<p>Vector of target names in channel 2 to select.</p>
</td></tr>
<tr><td><code id="subset.ddpcr_plate_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Keeps only data from the selected wells. If sample names are provided instead
of well IDs, then any well corresponding to any of the sample names will be
kept. Either well IDs or sample names must be provided, but not both.
</p>


<h3>Value</h3>

<p>Plate with data only from the specified wells/samples.
</p>


<h3>Range notation</h3>

<p>The most basic way to select wells is to provide a vector of wells such as
<code>c("B03", "C12")</code>. When selecting wells, a special range notation is
supported to make it easier to select many wells: use a colon (<code>:</code>) to specify a
range of wells, and use a comma (<code>,</code>) to add another well or range. When
specifying a range, all wells in the rectangular area between the two wells
are selected. For example, <code>B04:D06</code> is equivalent to
<code>B04, B05, A05, C04, C05, C06, D04, D05, D06</code>. You can combine multiple
ranges in one selection; see the Examples section below. Note that this
notation is only supported for the <code>wells</code> parameter, but not for the
<code>samples</code> parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate &lt;- new_plate(sample_data_dir())
plate %&gt;% wells_used
plate %&gt;% subset("C01") %&gt;% wells_used
plate %&gt;% subset(c("C01", "F05")) %&gt;% wells_used
plate %&gt;% subset("C01, F05") %&gt;% wells_used
plate %&gt;% subset("C01:F05") %&gt;% wells_used
plate %&gt;% subset("C01:F05, A01") %&gt;% wells_used
plate %&gt;% subset("A01:C03") %&gt;% wells_used
plate %&gt;% subset("A01:C05") %&gt;% wells_used
plate %&gt;% subset("A01, A05:F05") %&gt;% wells_used
plate %&gt;% subset("A01, A05:C05, F05") %&gt;% wells_used
plate %&gt;% subset("A01:A05, C01:C05, F05") %&gt;% wells_used
plate %&gt;% subset(samples = "Dean") %&gt;% wells_used
plate %&gt;% subset(samples = c("Dean", "Mike")) %&gt;% wells_used
</code></pre>

<hr>
<h2 id='thresholds'>Get/set the thresholds</h2><span id='topic+thresholds'></span><span id='topic+thresholds+3C-'></span><span id='topic+set_thresholds'></span>

<h3>Description</h3>

<p>For ddPCR plates of type <code>custom_thresholds</code>, get or set the thresholds
that divide the four droplet quadrants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresholds(plate)

thresholds(plate) &lt;- value

set_thresholds(plate, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thresholds_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="thresholds_+3A_value">value</code></td>
<td>
<p>The new thresholds as a 2-element numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current thresholds
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom_thresholds">custom_thresholds</a></code><br />
<code><a href="#topic+x_threshold">x_threshold</a></code><br />
<code><a href="#topic+y_threshold">y_threshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
thresholds(plate)
thresholds(plate) &lt;- c(5500, 8000)
set_thresholds(plate, c(5500, 8000))

## End(Not run)
</code></pre>

<hr>
<h2 id='type'>Plate type</h2><span id='topic+type'></span>

<h3>Description</h3>

<p>Get the type of a ddPCR plate.
<a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for more
information on plate types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type(plate, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="type_+3A_all">all</code></td>
<td>
<p>If <code>FALSE</code>, show only the most specific plate type; otherwise,
show all inherited (implicit) types as well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the plate type(s).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_types">plate_types</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$fam_positive_pnpp)
type(plate)
type(plate, TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='unanalyzed_clusters'>Get unanalyzed cluseter IDs</h2><span id='topic+unanalyzed_clusters'></span>

<h3>Description</h3>

<p>Get the clusters that have not been considered yet in the analysis. This means
the UNDEFINED cluster (since all droplets begin as UNDEFINED) and also all
clusters that are defined later than the current cluster. The latter is to
ensure that when re-running an analysis step, droplets that were analyzed
in a later step will still be considered for analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unanalyzed_clusters(plate, current)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unanalyzed_clusters_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="unanalyzed_clusters_+3A_current">current</code></td>
<td>
<p>The current cluster ID, which is used to know what clusters
come after</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All clusters that have not yet been analyzed
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster">cluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
unanalyzed_clusters(plate, 3)
unanalyzed_clusters(plate, cluster(plate, "OUTLIER"))
plate %&gt;% unanalyzed_clusters(cluster(plate, "OUTLIER")) %&gt;% cluster_name(plate, .)

## End(Not run)
</code></pre>

<hr>
<h2 id='variable_dim'>Variable dimension in a PNPP experiment</h2><span id='topic+variable_dim'></span><span id='topic+variable_dim+3C-'></span>

<h3>Description</h3>

<p>Get or set the variable dimension (X or Y), which is defined as the dimension
that can have both high and low fluorescence intensities in the non-empty
drops in a <code>pnpp_experiment</code> plate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_dim(plate)

variable_dim(plate) &lt;- value
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+positive_dim">positive_dim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate &lt;- new_plate(dir = sample_data_dir(), type = plate_types$pnpp_experiment)
variable_dim(plate) &lt;- "Y"
variable_dim(plate)
positive_dim(plate)
</code></pre>

<hr>
<h2 id='variable_dim_var'>Name of dye in variable dimension in PNPP experiment</h2><span id='topic+variable_dim_var'></span>

<h3>Description</h3>

<p>Get the name of the dye that is along the variable dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_dim_var(plate)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+variable_dim">variable_dim</a></code>
</p>

<hr>
<h2 id='warn_msg'>Show a warning message</h2><span id='topic+warn_msg'></span>

<h3>Description</h3>

<p>Show a warning message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn_msg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warn_msg_+3A_x">x</code></td>
<td>
<p>The warning message text</p>
</td></tr>
</table>

<hr>
<h2 id='WELL_ID_REGEX'>regex for a well ID</h2><span id='topic+WELL_ID_REGEX'></span>

<h3>Description</h3>

<p>regex for a well ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WELL_ID_REGEX
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='well_info'>Get metadata info of a well</h2><span id='topic+well_info'></span>

<h3>Description</h3>

<p>Each ddPCR plate has associated metadata that stores infromation for every well.
Use this function to retrieve any metadata information for a single well or
for a list of wells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>well_info(plate, well_ids, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="well_info_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="well_info_+3A_well_ids">well_ids</code></td>
<td>
<p>A character vecotr of well IDs denoting the wells to get information
for</p>
</td></tr>
<tr><td><code id="well_info_+3A_var">var</code></td>
<td>
<p>The metadata variable to get (to see a list of all possible metadata
variables, use <code>names(plate_meta(plate))</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the wanted metadata variable value for each
well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_meta">plate_meta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
well_info(plate, "A01", "drops")

## End(Not run) 
</code></pre>

<hr>
<h2 id='wells_mutant'>Get mutant wells</h2><span id='topic+wells_mutant'></span>

<h3>Description</h3>

<p>After a ddPCR plate of type <code>wildtype_mutant_pnpp</code> has been analyzed,
get the wells that were deemed as mutant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wells_mutant(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wells_mutant_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with well IDs of mutant wells
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wildtype_mutant_pnpp">wildtype_mutant_pnpp</a></code><br />
<code><a href="#topic+wells_wildtype">wells_wildtype</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$fam_positive_pnpp) %&gt;% analyze
wells_mutant(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='wells_negative'>Get negative wells</h2><span id='topic+wells_negative'></span>

<h3>Description</h3>

<p>After a ddPCR plate of type <code>pnpp_experiment</code> has been analyzed,
get the wells that were not deemed as having mostly positive droplets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wells_negative(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wells_negative_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with well IDs of negative wells
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+wells_positive">wells_positive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$pnpp_experiment) %&gt;% analyze
wells_negative(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='wells_positive'>Get positive wells</h2><span id='topic+wells_positive'></span>

<h3>Description</h3>

<p>After a ddPCR plate of type <code>pnpp_experiment</code> has been analyzed,
get the wells that were deemed as having mostly positive droplets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wells_positive(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wells_positive_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with well IDs of positive wells
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+wells_negative">wells_negative</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$pnpp_experiment) %&gt;% analyze
wells_positive(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='wells_success'>Get successful/failed wells</h2><span id='topic+wells_success'></span><span id='topic+wells_failed'></span>

<h3>Description</h3>

<p>Get a list of wells that had successful or failed ddPCR runs. One of the analysis steps
for ddPCR plates includes identifying failed wells, which are wells where
the ddPCR run was not successful and did not produce useful droplet data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wells_success(plate)

wells_failed(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wells_success_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of wells that had a successful/failed ddPCR run.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remove_failures">remove_failures</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dir &lt;- sample_data_dir()
plate &lt;- new_plate(dir) %&gt;% analyze
plate %&gt;% wells_success
plate %&gt;% wells_failed

## End(Not run)
</code></pre>

<hr>
<h2 id='wells_used'>Get wells used in a ddPCR plate</h2><span id='topic+wells_used'></span>

<h3>Description</h3>

<p>Get a list of the wells that have any data in a ddPCR plate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wells_used(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wells_used_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of wells that have any data in the given plate.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset.ddpcr_plate">subset.ddpcr_plate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
wells_used(plate)
plate &lt;- subset(plate, "A01:C05")
wells_used(plate)

## End(Not run) 
</code></pre>

<hr>
<h2 id='wells_wildtype'>Get wildtype wells</h2><span id='topic+wells_wildtype'></span>

<h3>Description</h3>

<p>After a ddPCR plate of type <code>wildtype_mutant_pnpp</code> has been analyzed,
get the wells that were deemed as wildtype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wells_wildtype(plate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wells_wildtype_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with well IDs of wildtype wells
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wildtype_mutant_pnpp">wildtype_mutant_pnpp</a></code><br />
<code><a href="#topic+wells_mutant">wells_mutant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$fam_positive_pnpp) %&gt;% analyze
wells_wildtype(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='wildtype_mutant_pnpp'>Plate type: wildtype/mutant PNPP</h2><span id='topic+wildtype_mutant_pnpp'></span>

<h3>Description</h3>

<p>A plate of type <code>wildtype_mutant_pnpp</code> is a subtype of
<code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code> that assumes the double-positive cluster
denotes wildtype and the other non-empty cluster denotes mutant droplets.
There are two plate types that are subtypes of <code>wildtype_mutant_pnpp</code>:
<code><a href="#topic+fam_positive_pnpp">fam_positive_pnpp</a></code> and <code><a href="#topic+hex_positive_pnpp">hex_positive_pnpp</a></code>.
It is not recommended to use this type directly; instead you should use one
of the subtypes.
</p>


<h3>Details</h3>

<p>Plates with this type have the following analysis steps: <code>INITIALIZE</code>,
<code>REMOVE_FAILURES</code>, <code>REMOVE_OUTLIERS</code>, <code>REMOVE_EMPTY</code>,
<code>CLASSIFY</code>, <code>RECLASSIFY</code>.
</p>
<p>Plates with this type have the following droplet clusters:
<code>UNDEFINED</code>, <code>FAILED</code>, <code>OUTLIER</code>, <code>EMPTY</code> (double-negative),
<code>RAIN</code> (not empty but not wildtype nor negative), <code>POSITIVE</code> (wildtype),
<code>NEGATIVE</code> (mutant).
</p>
<p><a href="https://github.com/daattali/ddpcr#advanced-topic-3-creating-new-plate-types">See the README</a> for
more information on plate types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plate_types">plate_types</a></code><br />
<code><a href="#topic+fam_positive_pnpp">fam_positive_pnpp</a></code><br />
<code><a href="#topic+hex_positive_pnpp">hex_positive_pnpp</a></code><br />
<code><a href="#topic+pnpp_experiment">pnpp_experiment</a></code><br />
<code><a href="#topic+analyze">analyze</a></code><br />
<code><a href="#topic+remove_failures">remove_failures</a></code><br />
<code><a href="#topic+remove_outliers">remove_outliers</a></code><br />
<code><a href="#topic+remove_empty">remove_empty</a></code><br />
<code><a href="#topic+classify_droplets">classify_droplets</a></code><br />
<code><a href="#topic+reclassify_droplets">reclassify_droplets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$wildtype_mutant_pnpp)
type(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='x_threshold'>Get/set the X threshold</h2><span id='topic+x_threshold'></span><span id='topic+x_threshold+3C-'></span>

<h3>Description</h3>

<p>For ddPCR plates of type <code>custom_thresholds</code>, get or set the threshold
along the X axis that divides the droplet quadrants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_threshold(plate)

x_threshold(plate) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_threshold_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="x_threshold_+3A_value">value</code></td>
<td>
<p>The new X threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current X threshold
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom_thresholds">custom_thresholds</a></code><br />
<code><a href="#topic+y_threshold">y_threshold</a></code><br />
<code><a href="#topic+thresholds">thresholds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
x_threshold(plate)
x_threshold(plate) &lt;- 5500
plot(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='x_var'>Get/set the X/Y variable (dye name)</h2><span id='topic+x_var'></span><span id='topic+y_var'></span><span id='topic+x_var+3C-'></span><span id='topic+y_var+3C-'></span>

<h3>Description</h3>

<p>By default, the dye visualized along the X axis is HEX and the dye visualized
along the Y axis is FAM. You can use these functions to get or set these values
if your plate uses different dyes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_var(plate)

y_var(plate)

x_var(plate) &lt;- value

y_var(plate) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_var_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate</p>
</td></tr>
<tr><td><code id="x_var_+3A_value">value</code></td>
<td>
<p>New dye name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The X/Y variables are simply parameters in the plate, which can also be accessed
or changed using <code><a href="#topic+params">params</a></code>. You should use these functions
to change the X/Y variable rather than changing the parameters directly.
</p>


<h3>Value</h3>

<p>Dye name
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params">params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir())
x_var(plate)
x_var(plate) &lt;- "VIC"
x_var(plate)

## End(Not run)
</code></pre>

<hr>
<h2 id='y_threshold'>Get/set the Y threshold</h2><span id='topic+y_threshold'></span><span id='topic+y_threshold+3C-'></span>

<h3>Description</h3>

<p>For ddPCR plates of type <code>custom_thresholds</code>, get or set the threshold
along the Y axis that divides the droplet quadrants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y_threshold(plate)

y_threshold(plate) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="y_threshold_+3A_plate">plate</code></td>
<td>
<p>A ddPCR plate.</p>
</td></tr>
<tr><td><code id="y_threshold_+3A_value">value</code></td>
<td>
<p>The new Y threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current Y threshold
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom_thresholds">custom_thresholds</a></code><br />
<code><a href="#topic+x_threshold">x_threshold</a></code><br />
<code><a href="#topic+thresholds">thresholds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plate &lt;- new_plate(sample_data_dir(), type = plate_types$custom_thresholds)
y_threshold(plate)
y_threshold(plate) &lt;- 8000
plot(plate)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
