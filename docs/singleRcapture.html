<!DOCTYPE html><html><head><title>Help for package singleRcapture</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {singleRcapture}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#carcassubmission'><p>British farm carcass submissions data</p></a></li>
<li><a href='#chao'><p>Family functions in singleRcapture package</p></a></li>
<li><a href='#confint.singleRStaticCountData'><p>Confidence Intervals for Model Parameters</p></a></li>
<li><a href='#controlMethod'><p>Control parameters for regression</p></a></li>
<li><a href='#controlModel'><p>Control parameters specific to some models</p></a></li>
<li><a href='#controlPopVar'><p>Control parameters for population size estimation</p></a></li>
<li><a href='#dfpopsize'><p>Regression diagnostics in <code>singleRcapture</code></p></a></li>
<li><a href='#estfun.singleRStaticCountData'><p>Heteroscedasticity-Consistent Covariance Matrix Estimation for singleRStaticCountData class</p></a></li>
<li><a href='#estimatePopsize'><p>Single source capture-recapture models</p></a></li>
<li><a href='#estimatePopsizeFit'><p>Regression fitting in single source capture-recapture models</p></a></li>
<li><a href='#farmsubmission'><p>British farm submissions data</p></a></li>
<li><a href='#marginalFreq'><p>Observed and fitted marginal Frequencies</p></a></li>
<li><a href='#netherlandsimmigrant'><p>Data on immigration in Netherlands</p></a></li>
<li><a href='#plot.singleRStaticCountData'><p>Diagnostic plots for regression and population size estimation.</p></a></li>
<li><a href='#popSizeEst'><p>Extract population size estimation results.</p></a></li>
<li><a href='#predict.singleRStaticCountData'><p>Predict method for <code>singleRStaticCountData</code> class</p></a></li>
<li><a href='#redoPopEstimation'><p>Updating population size estimation results.</p></a></li>
<li><a href='#simulate'><p>Generating data in singleRcapture</p></a></li>
<li><a href='#stratifyPopsize'><p>Estimate size of sub populations.</p></a></li>
<li><a href='#summary.singleRmargin'><p>Statistical tests of goodness of fit.</p></a></li>
<li><a href='#summary.singleRStaticCountData'><p>Summary statistics for model of singleRStaticCountData class.</p></a></li>
<li><a href='#vcov.singleRStaticCountData'><p>Obtain Covariance Matrix estimation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Single-Source Capture-Recapture Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of single-source capture-recapture methods for population size estimation using zero-truncated, zero-one truncated and zero-truncated one-inflated Poisson, Geometric and Negative Binomial regression as well as Zelterman's and Chao's regression. Package includes point and interval estimators for the population size with variances estimated using analytical or bootstrap method. Details can be found in: van der Heijden et all. (2003) &lt;<a href="https://doi.org/10.1191%2F1471082X03st057oa">doi:10.1191/1471082X03st057oa</a>&gt;, Böhning and van der Heijden (2019) &lt;<a href="https://doi.org/10.1214%2F18-AOAS1232">doi:10.1214/18-AOAS1232</a>&gt;, Böhning et al. (2020) Capture-Recapture Methods for the Social and Medical Sciences or Böhning and Friedl (2021) &lt;<a href="https://doi.org/10.1007%2Fs10260-021-00556-8">doi:10.1007/s10260-021-00556-8</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ncn-foreigners/singleRcapture">https://github.com/ncn-foreigners/singleRcapture</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ncn-foreigners/singleRcapture/issues">https://github.com/ncn-foreigners/singleRcapture/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, lamW, mathjaxr, sandwich, doParallel, foreach, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, tinytest, covr, VGAM</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-22 15:32:07 UTC; piotr</td>
</tr>
<tr>
<td>Author:</td>
<td>Piotr Chlebicki [aut, cre],
  Maciej Beręsewicz <a href="https://orcid.org/0000-0002-8281-4301"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Piotr Chlebicki &lt;piochl@st.amu.edu.pl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-23 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='carcassubmission'>British farm carcass submissions data</h2><span id='topic+carcassubmission'></span>

<h3>Description</h3>

<p>Data on British animal farms submissions to AHVLA. British farms
are able to submit samples to AHVLA if cause of death for an animal
cannot be determined and private veterinary surgeon decides to submit them,
unless there is notifiable disease suspected then such a submission is not
required.
</p>
<p>This data set contains information about such farms.
Only submissions that are included in this data frame
are submissions of carcasses i.e. submissions of blood samples etc.
are excluded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("carcassubmission")
</code></pre>


<h3>Format</h3>

<p>Data frame with 1,858 rows and 4 columns.
</p>

<dl>
<dt><code>TOTAL_SUB</code></dt><dd><p>Number of submissions of animal carcasses.</p>
</dd>
<dt><code>log_size</code></dt><dd><p>Numerical value equal to logarithm of size of farm.</p>
</dd>
<dt><code>log_distance</code></dt><dd><p>Numerical value equal to logarithm of distance to nearest AHVLA center.</p>
</dd>
<dt><code>C_TYPE</code></dt><dd><p>Factor describing type of activity on farm that animals are
used for. Either <code>Dairy</code> or <code>Beef</code></p>
</dd>
</dl>



<h3>References</h3>

<p>This data set and its description was provided in publication:
Böhning, D., Vidal Diez, A., Lerdsuwansri, R., Viwatwongkasem, C., and Arnold, M. (2013). &quot;A generalization of Chao's estimator for covariate information&quot;. <em>Biometrics</em>, 69(4), 1033-1042. doi:10.1111/biom.12082
</p>

<hr>
<h2 id='chao'>Family functions in singleRcapture package</h2><span id='topic+chao'></span><span id='topic+Hurdleztgeom'></span><span id='topic+Hurdleztnegbin'></span><span id='topic+Hurdleztpoisson'></span><span id='topic+singleRmodels'></span><span id='topic+oiztgeom'></span><span id='topic+oiztnegbin'></span><span id='topic+oiztpoisson'></span><span id='topic+zelterman'></span><span id='topic+zotgeom'></span><span id='topic+zotnegbin'></span><span id='topic+zotpoisson'></span><span id='topic+ztHurdlegeom'></span><span id='topic+ztHurdlenegbin'></span><span id='topic+ztHurdlepoisson'></span><span id='topic+ztgeom'></span><span id='topic+ztnegbin'></span><span id='topic+ztoigeom'></span><span id='topic+ztoinegbin'></span><span id='topic+ztoipoisson'></span><span id='topic+ztpoisson'></span>

<h3>Description</h3>

<p>Package <code>singleRcapture</code> utilizes various family type
functions that specify variable parts of population size estimation,
regression, diagnostics and other necessary information that depends
on the model. These functions are used as <code>model</code> argument in
<code>estimatePopsize</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chao(lambdaLink = "loghalf", ...)

Hurdleztgeom(
  lambdaLink = c("log", "neglog"),
  piLink = c("logit", "cloglog", "probit"),
  ...
)

Hurdleztnegbin(
  nSim = 1000,
  epsSim = 1e-08,
  eimStep = 6,
  lambdaLink = c("log", "neglog"),
  alphaLink = c("log", "neglog"),
  piLink = c("logit", "cloglog", "probit"),
  ...
)

Hurdleztpoisson(
  lambdaLink = c("log", "neglog"),
  piLink = c("logit", "cloglog", "probit"),
  ...
)

oiztgeom(
  lambdaLink = c("log", "neglog"),
  omegaLink = c("logit", "cloglog", "probit"),
  ...
)

oiztnegbin(
  nSim = 1000,
  epsSim = 1e-08,
  eimStep = 6,
  lambdaLink = c("log", "neglog"),
  alphaLink = c("log", "neglog"),
  omegaLink = c("logit", "cloglog", "probit"),
  ...
)

oiztpoisson(
  lambdaLink = c("log", "neglog"),
  omegaLink = c("logit", "cloglog", "probit"),
  ...
)

zelterman(lambdaLink = "loghalf", ...)

zotgeom(lambdaLink = c("log", "neglog"), ...)

zotnegbin(
  nSim = 1000,
  epsSim = 1e-08,
  eimStep = 6,
  lambdaLink = c("log", "neglog"),
  alphaLink = c("log", "neglog"),
  ...
)

zotpoisson(lambdaLink = c("log", "neglog"), ...)

ztHurdlegeom(
  lambdaLink = c("log", "neglog"),
  piLink = c("logit", "cloglog", "probit"),
  ...
)

ztHurdlenegbin(
  nSim = 1000,
  epsSim = 1e-08,
  eimStep = 6,
  lambdaLink = c("log", "neglog"),
  alphaLink = c("log", "neglog"),
  piLink = c("logit", "cloglog", "probit"),
  ...
)

ztHurdlepoisson(
  lambdaLink = c("log", "neglog"),
  piLink = c("logit", "cloglog", "probit"),
  ...
)

ztgeom(lambdaLink = c("log", "neglog"), ...)

ztnegbin(
  nSim = 1000,
  epsSim = 1e-08,
  eimStep = 6,
  lambdaLink = c("log", "neglog"),
  alphaLink = c("log", "neglog"),
  ...
)

ztoigeom(
  lambdaLink = c("log", "neglog"),
  omegaLink = c("logit", "cloglog", "probit"),
  ...
)

ztoinegbin(
  nSim = 1000,
  epsSim = 1e-08,
  eimStep = 6,
  lambdaLink = c("log", "neglog"),
  alphaLink = c("log", "neglog"),
  omegaLink = c("logit", "cloglog", "probit"),
  ...
)

ztoipoisson(
  lambdaLink = c("log", "neglog"),
  omegaLink = c("logit", "cloglog", "probit"),
  ...
)

ztpoisson(lambdaLink = c("log", "neglog"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chao_+3A_lambdalink">lambdaLink</code></td>
<td>
<p>link for Poisson parameter, <code>"log"</code>
by default except for zelterman's and chao's models where only
\(\ln\left(\frac{x}{2}\right)\) is possible.</p>
</td></tr>
<tr><td><code id="chao_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used for now.</p>
</td></tr>
<tr><td><code id="chao_+3A_pilink">piLink</code></td>
<td>
<p>link for probability parameter,  <code>"logit"</code> by default</p>
</td></tr>
<tr><td><code id="chao_+3A_nsim">nSim</code>, <code id="chao_+3A_epssim">epsSim</code></td>
<td>
<p>if working weights cannot be computed analytically these
arguments specify maximum number of simulations allowed and
precision level for finding them numerically respectively.</p>
</td></tr>
<tr><td><code id="chao_+3A_eimstep">eimStep</code></td>
<td>
<p>a non negative integer describing
how many values should be used at each step of approximation
of information matrixes when no analytic solution is available
(e.g. <code>"ztnegbin"</code>), default varies depending on a function.
Higher value usually means faster convergence but may potentially cause
issues with convergence.</p>
</td></tr>
<tr><td><code id="chao_+3A_alphalink">alphaLink</code></td>
<td>
<p>link for dispersion parameter, <code>"log"</code> by default</p>
</td></tr>
<tr><td><code id="chao_+3A_omegalink">omegaLink</code></td>
<td>
<p>link for inflation parameter, <code>"logit"</code> by default</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Most of these functions are based on some &quot;base&quot; distribution with
support \(\mathbb{N}_{0}=\mathbb{N}\cup\lbrace 0\rbrace\) that describe
distribution of \(Y\) before truncation. Currently they include:
\[\mathbb{P}(Y=y|\lambda,\alpha)=\left\lbrace
\begin{array}{cc}
\frac{\lambda^{y}e^{-\lambda}}{y!}    & \text{Poisson distribution}  \cr
\frac{\Gamma(y+\alpha^{-1})}{\Gamma(\alpha^{-1})y!} 
\left(\frac{\alpha^{-1}}{\alpha^{-1}+\lambda}\right)^{\alpha^{-1}}
\left(\frac{\lambda}{\alpha^{-1}+\lambda}\right)^{y} & 
\text{negative binomial distribution} \cr
\frac{\lambda^{y}}{(1+\lambda)^{y+1}} & 
\text{geometric distribution}
\end{array}
\right.\]
where \(\lambda\) is the Poisson parameter and
\(\alpha\) is the dispersion parameter. Geometric distribution
is a special case of negative binomial distribution when
\(\alpha=1\) it is included because negative binomial
distribution is quite troublesome numerical regression in fitting.
It is important to know that PMF of negative binomial distribution
approaches the PMF of Poisson distribution when
\(\alpha\rightarrow 0^{+}\).
</p>
<p><strong>Note</strong> in literature on single source capture recapture models
the dispersion parameter which introduces greater variability
in negative binomial distribution compared to Poisson distribution is
generally interpreted as explaining the <em>unobserved</em> heterogeneity
i.e. presence of important unobserved independent variables.
All these methods for estimating population size are tied to Poisson
processes hence we use \(\lambda\) as parameter symbol
instead of \(\mu\) to emphasize this connection.
Also will not be hard to see that <strong>all</strong> estimators derived from
modifying the &quot;base&quot; distribution are unbiased if assumptions
made by respective models are not violated.
</p>
<p>The <strong>zero truncated</strong> models corresponding to &quot;base&quot; distributions are
characterized by relation:
\[\mathbb{P}(Y=y|Y>0)=\left\lbrace
\begin{array}{cc}
\frac{\mathbb{P}(Y=y)}{1-\mathbb{P}(Y=0)} & \text{when }y\neq 0 \cr
0 & \text{when }y=0
\end{array}\right.\]
which allows us to estimate parameter values using only observed part of
population. These models lead to the following estimates, respectively:
\[
\begin{aligned}
\hat{N} &= \sum_{k=1}^{N_{obs}}\frac{1}{1-\exp(-\lambda_{k})} &
\text{ For Poisson distribution} \cr
\hat{N} &= \sum_{k=1}^{N_{obs}}\frac{1}{1-(1+\alpha_{k}\lambda_{k})^{-\alpha_{k}^{-1}}} &
\text{ For negative binomial distribution} \cr
\hat{N} &= \sum_{k=1}^{N_{obs}}\frac{1+\lambda_{k}}{\lambda_{k}} &
\text{ For geometric distribution}
\end{aligned}
\]
</p>
<p>One common way in which assumptions of zero truncated models are violated is
presence of <strong>one inflation</strong> the presence of which is somewhat similar in
single source capture-recapture models to zero inflation in usual count data
analysis. There are two ways in which one inflation may be understood,
they relate to whether \(\mathbb{P}(Y=0)\) is
modified by inflation. The first approach is inflate
(\(\omega\) parameter) zero truncated distribution as:
\[
\mathbb{P}_{new}(Y=y|Y>0) = \left\lbrace\begin{array}{cc}
\omega + (1 - \omega)\mathbb{P}_{old}(Y=1|Y>0)& \text{when: } y = 1 \cr
(1 - \omega) \mathbb{P}_{old}(Y=y|Y>0) & \text{when: } y \neq 1
\end{array}\right.\]
which corresponds to:
\[
\mathbb{P}_{new}(Y=y) = \left\lbrace\begin{array}{cc}
\mathbb{P}_{old}(Y=0) & \text{when: } y = 0 \cr
\omega(1 - \mathbb{P}(Y=0)) + (1 - \omega)\mathbb{P}_{old}(Y=1) & \text{when: } y = 1 \cr
(1 - \omega) \mathbb{P}_{old}(Y=y) & \text{when: } y > 1
\end{array}\right.
\]
before zero truncation. Models that utilize this
approach are commonly referred to as <em>zero truncated one inflated models</em>.
Another way of accommodating one inflation in SSCR is by putting inflation
parameter on base distribution as:
\[
\mathbb{P}_{new}(Y=y) = \left\lbrace\begin{array}{cc}
\omega + (1 - \omega)\mathbb{P}_{old}(Y=1)& \text{when: } y = 1 \cr
(1 - \omega) \mathbb{P}_{old}(Y=y) & \text{when: } y \neq 1
\end{array}\right.
\]
which then becomes:
\[
\mathbb{P}_{new}(Y=y|Y>0) = \left\lbrace\begin{array}{cc}
\frac{\omega}{1 - (1-\omega)\mathbb{P}_{old}(Y=0)} + \frac{(1 - \omega)}{1 - (1-\omega)\mathbb{P}_{old}(Y=0)}\mathbb{P}_{old}(Y=1)& \text{when: } y = 1 \cr
\frac{(1 - \omega)}{1 - (1-\omega)\mathbb{P}_{old}(Y=0)}\mathbb{P}_{old}(Y=y) & \text{when: } y > 1
\end{array}\right.
\]
after truncation.
It was shown by Böhning in 2022 paper that these approaches are equivalent
in terms of maximizing likelihoods if we do not put formula on
\(\omega\). They can however lead to different
population size estimates.
</p>
<p>For <em>zero truncated one inflated models</em> the formula for population size
estimate \(\hat{N}\) does not change since
\(\mathbb{P}(y=0)\) remains the same but estimation of parameters
changes all calculations.
</p>
<p>For <em>one inflated zero truncated models</em> population size estimates are
expressed, respectively by:
\[
\begin{aligned}
\hat{N} &= \sum_{k=1}^{N_{obs}}\frac{1}{1-(1-\omega_{k})\exp(-\lambda_{k})} &\text{ For base Poisson distribution} \cr
\hat{N} &= \sum_{k=1}^{N_{obs}}\frac{1}{1-(1-\omega_{k})(1+\alpha_{k}\lambda_{k})^{-\alpha_{k}^{-1}}} &\text{ For base negative binomial distribution} \cr
\hat{N} &= \sum_{k=1}^{N_{obs}}\frac{1+\lambda_{k}}{\lambda_{k} + \omega_{k}} &\text{ For base geometric distribution}
\end{aligned}
\]
</p>
<p><strong>Zero one truncated</strong> models ignore one counts instead of accommodating
one inflation by utilizing the identity
\[
\ell_{\text{ztoi}}=\boldsymbol{f}_{1}\ln{\frac{\boldsymbol{f}_{1}}{N_{obs}}}
+(N_{obs}-\boldsymbol{f}_{1})\ln{\left(1-\frac{\boldsymbol{f}_{1}}{N_{obs}}
\right)} + \ell_{\text{zot}}
\]
where \(\ell_{\text{zot}}\) is the log likelihood
of zero one truncated distribution characterized by probability mass function:
\[\mathbb{P}(Y=y|Y>1)=\left\lbrace
\begin{array}{cc}
\frac{\mathbb{P}(Y=y)}{1-\mathbb{P}(Y=0)-\mathbb{P}(Y=1)} & \text{when }y > 1 \cr
0 & \text{when }y\in\lbrace 0, 1\rbrace
\end{array}\right.\]
where \(\mathbb{P}(Y)\) is the probability mass function of
the &quot;base&quot; distribution. The identity above justifies use of zero one truncated,
unfortunately it was only proven for intercept only models, however
numerical simulations seem to indicate that even if the theorem cannot be
extended for (non trivial) regression population size estimation is still
possible.
</p>
<p>For <em>zero one truncated models</em> population size estimates are expressed by:
\[
\begin{aligned}
\hat{N} &= \boldsymbol{f}_{1} + \sum_{k=1}^{N_{obs}}
\frac{1-\lambda_{k}\exp(-\lambda_{k})}{1-\exp(-\lambda_{k})-\lambda_{k}\exp(-\lambda_{k})} 
&\text{ For base Poisson distribution} \cr
\hat{N} &= \boldsymbol{f}_{1} + \sum_{k=1}^{N_{obs}}
\frac{1-\lambda_{k}(1+\alpha_{k}\lambda_{k})^{-1-\alpha_{k}^{-1}}}{
1-(1+\alpha_{k}\lambda_{k})^{-\alpha_{k}^{-1}}-\lambda_{k}(1+\alpha_{k}\lambda_{k})^{-1-\alpha_{k}^{-1}}} 
&\text{ For base negative binomial distribution} \cr
\hat{N} &= \boldsymbol{f}_{1} + \sum_{k=1}^{N_{obs}}
\frac{\lambda_{k}^{2}+\lambda_{k}+1}{\lambda_{k}^{2}} 
&\text{ For base geometric distribution}
\end{aligned}
\]
</p>
<p>Pseudo hurdle models are experimental and not yet described in literature.
</p>
<p>Lastly there are <strong>chao</strong> and <strong>zelterman</strong> models which are based on
logistic regression on the dummy variable
\[
Z = \left\lbrace\begin{array}{cc}
0     & \text{if }Y = 1  \cr
1     & \text{if }Y = 2
\end{array}\right.\]
based on the equation:
\[
\text{logit}(p_{k})=
\ln\left(\frac{\lambda_{k}}{2}\right)=
\boldsymbol{\beta}\mathbf{x}_{k}=\eta_{k}\]
where \(\lambda_{k}\) is the Poisson parameter.
</p>
<p>The <em>zelterman</em> estimator of population size is expressed as:
\[\hat{N}=\sum_{k=1}^{N_{obs}}{1-\exp\left(-\lambda_{k}\right)}\]
and <em>chao</em> estimator has the form:
\[
\hat{N}=N_{obs}+\sum_{k=1}^{\boldsymbol{f}_{1}+\boldsymbol{f}_{2}}
\frac{1}{\lambda_{k}+ \frac{\lambda_{k}^{2}}{2}}
\]
</p>


<h3>Value</h3>

<p>A object of class <code>family</code> containing objects:
</p>

<ul>
<li> <p><code>makeMinusLogLike</code> &ndash; A factory function for creating
\(\ell(\boldsymbol{\beta}), \frac{\partial\ell}{\partial\boldsymbol{\beta}},
\frac{\partial^{2}\ell}{\partial\boldsymbol{\beta}^{T}\partial\boldsymbol{\beta}}
\) functions from
\(\boldsymbol{y}\) vector and
\(\boldsymbol{X}_{vlm}\)
(or just \(\boldsymbol{X}\) if applied to model
with single linear predictor) the argument <code>deriv</code> with possible
values in <code>0, 1, 2</code> provides which derivative to return with
<code>0</code> being just the minus log-likelihood.
</p>
</li>
<li> <p><code>links</code> &ndash; List with link functions.
</p>
</li>
<li> <p><code>mu.eta, variance</code> &ndash; Functions of linear predictors that
return expected value and variance. There is a <code>type</code> argument with
2 possible values <code>"trunc"</code> and <code>"nontrunc"</code> that specifies whether
to return \(\mathbb{E}(Y|Y>0), \text{var}(Y|Y>0)\) or
\(\mathbb{E}(Y), \text{var}(Y)\) respectively.
</p>
</li>
<li> <p><code>family</code> &ndash; Character that specifies name of the model.
</p>
</li>
<li> <p><code>valideta, validmu</code> &ndash; For now only returns true. In near future
will be used to check whether applied linear predictors are valid (i.e. are
transformed into some elements of parameter space the subjected to inverse
link function).
</p>
</li>
<li> <p><code>funcZ, Wfun</code> &ndash; Functions that create pseudo residuals and
working weights used in IRLS algorithm.
</p>
</li>
<li> <p><code>devResids</code> &ndash; Function that given the linear predictors
prior weights vector and response vector returns deviance residuals.
Not all family functions have these functions implemented yet.
</p>
</li>
<li> <p><code>pointEst, popVar</code> &ndash; Functions that given prior weights
linear predictors and in the later case also estimation of
\(\text{cov}(\hat{\boldsymbol{\beta}})\) and \(\boldsymbol{X_{vlm}}\)
matrix return point estimate for population size and analytic estimation
of its variance.There is a additional boolean parameter <code>contr</code> in the
former function that if set to true returns contribution of each unit.
</p>
</li>
<li> <p><code>etaNames</code> &ndash; Names of linear predictors.
</p>
</li>
<li> <p><code>densityFunction</code> &ndash; A function that given linear predictors
returns value of PMF at values <code>x</code>. Additional argument <code>type</code>
specifies whether to return \(\mathbb{P}(Y|Y>0)\) or
\(\mathbb{P}(Y)\).
</p>
</li>
<li> <p><code>simulate</code> &ndash; A function that generates values of dependent
vector given linear predictors.
</p>
</li>
<li> <p><code>getStart</code> &ndash; Expression for generating starting points.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Piotr Chlebicki, Maciej Beręsewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimatePopsize">estimatePopsize()</a></code>
</p>

<hr>
<h2 id='confint.singleRStaticCountData'>Confidence Intervals for Model Parameters</h2><span id='topic+confint.singleRStaticCountData'></span>

<h3>Description</h3>

<p>A function that computes studentized confidence intervals
for model coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'singleRStaticCountData'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.singleRStaticCountData_+3A_object">object</code></td>
<td>
<p>object of singleRStaticCountData class.</p>
</td></tr>
<tr><td><code id="confint.singleRStaticCountData_+3A_parm">parm</code></td>
<td>
<p>names of parameters for which confidence intervals are to be
computed, if missing all parameters will be considered.</p>
</td></tr>
<tr><td><code id="confint.singleRStaticCountData_+3A_level">level</code></td>
<td>
<p>confidence level for intervals.</p>
</td></tr>
<tr><td><code id="confint.singleRStaticCountData_+3A_...">...</code></td>
<td>
<p>currently does nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with named columns that include upper and
lower limit of confidence intervals.
</p>

<hr>
<h2 id='controlMethod'>Control parameters for regression</h2><span id='topic+controlMethod'></span>

<h3>Description</h3>

<p><code>controlMethod</code> constructs a list with all necessary
control parameters for regression fitting in
<code>estimatePopsizeFit</code> and <code>estimatePopsize</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>controlMethod(
  epsilon = 1e-08,
  maxiter = 1000,
  verbose = 0,
  printEveryN = 1L,
  coefStart = NULL,
  etaStart = NULL,
  optimMethod = "Nelder-Mead",
  silent = FALSE,
  optimPass = FALSE,
  stepsize = 1,
  checkDiagWeights = TRUE,
  weightsEpsilon = 1e-08,
  momentumFactor = 0,
  saveIRLSlogs = FALSE,
  momentumActivation = 5,
  criterion = c("coef", "abstol", "reltol")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="controlMethod_+3A_epsilon">epsilon</code></td>
<td>
<p>tolerance for fitting algorithms by default <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_verbose">verbose</code></td>
<td>
<p>value indicating whether to trace steps of fitting algorithm for
<code>IRLS</code> fitting method different values of verbose give the following information:
</p>

<ul>
<li><p> 1 &ndash; Returns information on the number of current
iteration and current log-likelihood.
</p>
</li>
<li><p> 2 &ndash; Returns information on vector of regression parameters
at current iteration (and all of the above).
</p>
</li>
<li><p> 3 &ndash; Returns information on reduction of log-likelihood
at current iteration (and all of the above).
</p>
</li>
<li><p> 4 &ndash; Returns information on value of log-likelihood function gradient
at current iteration (and all of the above).
</p>
</li>
<li><p> 5 &ndash; Returns information on convergence criterion and values that are
taken into account when considering convergence (and all of the above).
</p>
</li></ul>

<p>if <code>optim</code> method was chosen verbose will be passed to <code><a href="stats.html#topic+optim">stats::optim()</a></code> as trace.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_printeveryn">printEveryN</code></td>
<td>
<p>integer value indicating how often to print information
specified in <code>verbose</code>, by default set to <code>1</code>.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_coefstart">coefStart</code>, <code id="controlMethod_+3A_etastart">etaStart</code></td>
<td>
<p>initial parameters for regression coefficients
or linear predictors if <code>NULL</code>. For <code>IRLS</code> fitting only <code>etaStart</code>
is needed so if <code>coefStart</code> is provided it will be converted to <code>etaStart</code>,
for <code>optim</code> fitting <code>coefStart</code> is necessary and argument <code>etaStart</code>
will be ignored.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_optimmethod">optimMethod</code></td>
<td>
<p>method of <code><a href="stats.html#topic+optim">stats::optim()</a></code> used  <code>"Nelder-Mead"</code> is the default .</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_silent">silent</code></td>
<td>
<p>logical, indicating whether warnings in <code>IRLS</code> method should be suppressed.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_optimpass">optimPass</code></td>
<td>
<p>optional list of parameters passed to <code>stats::optim(..., control = optimPass)</code>
if FALSE then list of control parameters will be inferred from other parameters.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_stepsize">stepsize</code></td>
<td>
<p>only for <code>IRLS</code>, scaling of updates to <code>beta</code> vector
lower value means slower convergence but more accuracy by default 1.
In general if fitting algorithm fails lowering this value tends to
be most effective at correcting it.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_checkdiagweights">checkDiagWeights</code></td>
<td>
<p>logical value indicating whether to check if diagonal
elements of working weights matrixes in <code>IRLS</code> are sufficiently positive
so that these matrixes are positive defined. By default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_weightsepsilon">weightsEpsilon</code></td>
<td>
<p>small number to ensure positive definedness of weights matrixes.
Only matters if <code>checkDiagWeights</code> is set to <code>TRUE</code>.
By default <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_momentumfactor">momentumFactor</code></td>
<td>
<p>experimental parameter in <code>IRLS</code> only allowing for
taking previous step into account at current step, i.e instead of
updating regression parameters as:
\[\boldsymbol{\beta}_{(a)} = 
\boldsymbol{\beta}_{(a-1)} + \text{stepsize} \cdot \text{step}_{(a)}\]
the update will be made as:
\[
\boldsymbol{\beta}_{(a)} = \boldsymbol{\beta}_{(a-1)} + \text{stepsize} 
\cdot (\text{step}_{(a)} + \text{momentum}\cdot\text{step}_{(a-1)})\]</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_saveirlslogs">saveIRLSlogs</code></td>
<td>
<p>logical value indicating if information specified in
<code>verbose</code> should be saved to output object, by default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_momentumactivation">momentumActivation</code></td>
<td>
<p>the value of log-likelihood reduction bellow
which momentum will apply.</p>
</td></tr>
<tr><td><code id="controlMethod_+3A_criterion">criterion</code></td>
<td>
<p>criterion used to determine convergence in <code>IRLS</code>,
multiple values may be provided. By default <code>c("coef", "abstol")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with selected parameters, it is also possible to call list directly.
</p>


<h3>Author(s)</h3>

<p>Piotr Chlebicki, Maciej Beręsewicz
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimatePopsize">estimatePopsize()</a></code> <code><a href="#topic+estimatePopsizeFit">estimatePopsizeFit()</a></code>
<code><a href="#topic+controlModel">controlModel()</a></code> <code><a href="#topic+controlPopVar">controlPopVar()</a></code>
</p>

<hr>
<h2 id='controlModel'>Control parameters specific to some models</h2><span id='topic+controlModel'></span>

<h3>Description</h3>

<p><code>controlModel</code> constructs a list with all necessary
control parameters in <code>estimatePopsize</code> that are either specific to
selected model or do not fit anywhere else.
</p>
<p>Specifying additional formulas should be done by using only right hand side of
the formula also for now all variables from additional formulas should also be
included in the &quot;main&quot; formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>controlModel(
  weightsAsCounts = FALSE,
  omegaFormula = ~1,
  alphaFormula = ~1,
  piFormula = ~1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="controlModel_+3A_weightsascounts">weightsAsCounts</code></td>
<td>
<p>boolean value indicating whether to treat <code>weights</code>
argument as number of occurrences for each row in the <code>data</code> and adjust
necessary methods and functionalities, like adjustments in bootstrap or
decreasing weights in <code>dfbeta</code> instead or deleting rows from data,
to accommodate this form of model specification.</p>
</td></tr>
<tr><td><code id="controlModel_+3A_omegaformula">omegaFormula</code></td>
<td>
<p>formula for inflation parameter in one inflated zero
truncated and zero truncated one inflated models.</p>
</td></tr>
<tr><td><code id="controlModel_+3A_alphaformula">alphaFormula</code></td>
<td>
<p>formula for dispersion parameter in negative binomial
based models.</p>
</td></tr>
<tr><td><code id="controlModel_+3A_piformula">piFormula</code></td>
<td>
<p>formula for probability parameter in pseudo hurdle zero
truncated and zero truncated pseudo hurdle models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with selected parameters, it is also possible to call list directly.
</p>


<h3>Author(s)</h3>

<p>Piotr Chlebicki, Maciej Beręsewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimatePopsize">estimatePopsize()</a></code> <code><a href="#topic+controlMethod">controlMethod()</a></code> <code><a href="#topic+controlPopVar">controlPopVar()</a></code> <code><a href="#topic+singleRmodels">singleRmodels()</a></code>
</p>

<hr>
<h2 id='controlPopVar'>Control parameters for population size estimation</h2><span id='topic+controlPopVar'></span>

<h3>Description</h3>

<p>Creating control parameters for population size estimation and
respective standard error and variance estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>controlPopVar(
  alpha = 0.05,
  bootType = c("parametric", "semiparametric", "nonparametric"),
  B = 500,
  confType = c("percentilic", "normal", "basic"),
  keepbootStat = TRUE,
  traceBootstrapSize = FALSE,
  bootstrapVisualTrace = FALSE,
  fittingMethod = c("optim", "IRLS"),
  bootstrapFitcontrol = NULL,
  sd = c("sqrtVar", "normalMVUE"),
  covType = c("observedInform", "Fisher"),
  cores = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="controlPopVar_+3A_alpha">alpha</code></td>
<td>
<p>significance level, 0.05 used by default.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_boottype">bootType</code></td>
<td>
<p>bootstrap type. Default is <code>"parametric"</code>,
other possible values are: <code>"semiparametric"</code> and <code>"nonparametric"</code>.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples to be performed (default 500).</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_conftype">confType</code></td>
<td>
<p>type of confidence interval for bootstrap confidence interval,
<code>"percentile"</code> by default.
Other possibilities: <code>"studentized"</code> and <code>"basic"</code>.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_keepbootstat">keepbootStat</code></td>
<td>
<p>boolean value indicating whether to keep a vector of
statistics produced by bootstrap.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_tracebootstrapsize">traceBootstrapSize</code></td>
<td>
<p>boolean value indicating whether to print size of
bootstrapped sample after truncation for semi- and fully parametric bootstraps.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_bootstrapvisualtrace">bootstrapVisualTrace</code></td>
<td>
<p>boolean value indicating whether to plot bootstrap
statistics in real time.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_fittingmethod">fittingMethod</code></td>
<td>
<p>method used for fitting models from bootstrap samples.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_bootstrapfitcontrol">bootstrapFitcontrol</code></td>
<td>
<p>control parameters for each regression works exactly
like <code>controlMethod</code> but for fitting models from bootstrap samples.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_sd">sd</code></td>
<td>
<p>indicates how to compute standard deviation of population
size estimator either as:
\[\hat{\sigma}=\sqrt{\hat{\text{var}}(\hat{N})}\]
for <code>sqrt</code> (which is slightly biased if \(\hat{N}\)
has a normal distribution) or for <code>normalMVUE</code> as the unbiased
minimal variance estimator for normal distribution:
\[\hat{\sigma}=\sqrt{\hat{\text{var}}(\hat{N})}
\frac{\Gamma\left(\frac{N_{obs}-1}{2}\right)}{\Gamma\left(\frac{N_{obs}}{2}\right)}
\sqrt{\frac{N_{obs}}{2}}\]
where the ration involving gamma functions is computed by log gamma function.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_covtype">covType</code></td>
<td>
<p>type of covariance matrix for regression parameters by default
observed information matrix.</p>
</td></tr>
<tr><td><code id="controlPopVar_+3A_cores">cores</code></td>
<td>
<p>For bootstrap only, number of processor cores to be used,
any number greater than 1 activates code designed with <code>doParallel</code>,
<code>foreach</code> and <code>parallel</code> packages. Note that for now using parallel
computing makes tracing impossible so <code>traceBootstrapSize</code> and
<code>bootstrapVisualTrace</code> parameters are ignored in this case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with selected parameters, it is also possible to call list directly.
</p>


<h3>Author(s)</h3>

<p>Piotr Chlebicki, Maciej Beręsewicz
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimatePopsize">estimatePopsize()</a></code> <code><a href="#topic+controlModel">controlModel()</a></code> <code><a href="#topic+controlMethod">controlMethod()</a></code>
</p>

<hr>
<h2 id='dfpopsize'>Regression diagnostics in <code>singleRcapture</code></h2><span id='topic+dfpopsize'></span><span id='topic+hatvalues.singleRStaticCountData'></span><span id='topic+dfbeta.singleRStaticCountData'></span><span id='topic+residuals.singleRStaticCountData'></span><span id='topic+cooks.distance.singleRStaticCountData'></span><span id='topic+dfpopsize.singleRStaticCountData'></span><span id='topic+regDiagSingleR'></span>

<h3>Description</h3>

<p>List of some regression diagnostics implemented for
<code>singleRStaticCountData</code> class. Functions that either require no changes from
<code>glm</code> class or are not relevant to context of <code>singleRcapture</code>
are omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfpopsize(model, ...)

## S3 method for class 'singleRStaticCountData'
hatvalues(model, ...)

## S3 method for class 'singleRStaticCountData'
dfbeta(model, maxitNew = 1, trace = FALSE, cores = 1, ...)

## S3 method for class 'singleRStaticCountData'
residuals(
  object,
  type = c("pearson", "pearsonSTD", "response", "working", "deviance", "all"),
  ...
)

## S3 method for class 'singleRStaticCountData'
cooks.distance(model, ...)

## S3 method for class 'singleRStaticCountData'
dfpopsize(model, dfbeta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfpopsize_+3A_model">model</code>, <code id="dfpopsize_+3A_object">object</code></td>
<td>
<p>object of <code>singleRStaticCountData</code> class.</p>
</td></tr>
<tr><td><code id="dfpopsize_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.
Notably <code>dfpopsize.singleRStaticCountData</code> calls
<code>dfbeta.singleRStaticCountData</code> if no <code>dfbeta</code> argument was
provided and <code>controlMethod</code> is called in <code>dfbeta</code> method.</p>
</td></tr>
<tr><td><code id="dfpopsize_+3A_maxitnew">maxitNew</code></td>
<td>
<p>maximal number of iterations for regressions with starting
points \(\hat{\boldsymbol{\beta}}\) on data
specified at call for <code>model</code> after the removal of k'th row. By default 1.</p>
</td></tr>
<tr><td><code id="dfpopsize_+3A_trace">trace</code></td>
<td>
<p>logical value specifying whether to tracking results.</p>
</td></tr>
<tr><td><code id="dfpopsize_+3A_cores">cores</code></td>
<td>
<p>Number of processor cores to be used,
any number greater than 1 activates code designed with <code>doParallel</code>,
<code>foreach</code> and <code>parallel</code> packages. Note that for now using parallel
computing makes tracing impossible so <code>trace</code> parameter is ignored in this case.</p>
</td></tr>
<tr><td><code id="dfpopsize_+3A_type">type</code></td>
<td>
<p>a type of residual to return.</p>
</td></tr>
<tr><td><code id="dfpopsize_+3A_dfbeta">dfbeta</code></td>
<td>
<p>if <code>dfbeta</code> was already obtained it is possible to pass
them into function so that they need not be computed for the second time.</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p><code>dfpopsize</code> and <code>dfbeta</code> are closely related. <code>dfbeta</code>
fits a regression after removing a specific row from the data and returns the
difference between regression coefficients estimated on full data set and
data set obtained after deletion of that row, and repeats procedure once
for every unit present in the data.<code>dfpopsize</code> does the same for
population size estimation utilizing coefficients computed by <code>dfbeta</code>.
</p>
<p><code>cooks.distance</code> is implemented (for now) only for models with a single
linear predictor and works exactly like the method for <code>glm</code> class.
</p>
<p><code>residuals.singleRStaticCountData</code> (can be abbreviated to <code>resid</code>)
works like <code>residuals.glm</code> with the exception that:
</p>

<ul>
<li> <p><code>"pearson"</code> &ndash; returns non standardized residuals.
</p>
</li>
<li> <p><code>"pearsonSTD"</code> &ndash; is currently defined only for single predictors
models but will be extended to all models in a near future, but for families
with more than one distribution parameter it will be a multivariate residual.
</p>
</li>
<li> <p><code>"response"</code> &ndash; returns both residuals computed with truncated
and non truncated fitted value.
</p>
</li>
<li> <p><code>"working"</code> &ndash; is possibly multivariate if more than one linear
predictor is present.
</p>
</li>
<li> <p><code>"deviance"</code> &ndash; is not yet defined for all families in
<code><a href="#topic+singleRmodels">singleRmodels()</a></code> e.g. negative binomial based methods.
</p>
</li>
<li> <p><code>"all"</code> &ndash; returns all available residual types.
</p>
</li></ul>

<p><code>hatvalues.singleRStaticCountData</code> is method for <code>singleRStaticCountData</code>
class for extracting diagonal elements of projection matrix.
</p>
<p>Since <code>singleRcapture</code> supports not only regular glm's but also vglm's the
<code>hatvalues</code> returns a matrix with number of columns corresponding to number
of linear predictors in a model, where kth column corresponds to elements of
the diagonal of projection matrix associated with kth linear predictor.
For glm's
\[\boldsymbol{W}^{\frac{1}{2}}\boldsymbol{X}
\left(\boldsymbol{X}^{T}\boldsymbol{W}\boldsymbol{X}\right)^{-1}
\boldsymbol{X}^{T}\boldsymbol{W}^{\frac{1}{2}}\]
where: \(\boldsymbol{W}=\mathbb{E}\left(\text{Diag}
\left(\frac{\partial^{2}\ell}{\partial\boldsymbol{\eta}^{T}
\partial\boldsymbol{\eta}}\right)\right)\)
and \(\boldsymbol{X}\) is a model (lm) matrix.
For vglm's present in the package it is instead :
\[\boldsymbol{X}_{vlm}
\left(\boldsymbol{X}_{vlm}^{T}\boldsymbol{W}\boldsymbol{X}_{vlm}\right)^{-1}
\boldsymbol{X}_{vlm}^{T}\boldsymbol{W}\]
where:
\[
\boldsymbol{W} = \mathbb{E}\left(\begin{bmatrix}
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{1}^{T}\partial\eta_{1}}\right) &
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{1}^{T}\partial\eta_{2}}\right) &
\dotso & \text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{1}^{T}\partial\eta_{p}}\right)\cr
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{2}^{T}\partial\eta_{1}}\right) &
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{2}^{T}\partial\eta_{2}}\right) &
\dotso & \text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{2}^{T}\partial\eta_{p}}\right)\cr
\vdots & \vdots & \ddots & \vdots\cr
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{p}^{T}\partial\eta_{1}}\right) &
\text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{p}^{T}\partial\eta_{2}}\right) &
\dotso & \text{Diag}\left(\frac{\partial^{2}\ell}{\partial\eta_{p}^{T}\partial\eta_{p}}\right)
\end{bmatrix}\right)\]
is a block matrix constructed by taking the expected  value from diagonal
matrixes corresponding to second derivatives with respect to each linear
predictor (and mixed derivatives) and
\(\boldsymbol{X}_{vlm}\) is a model (vlm)
matrix constructed using specifications in <code>controlModel</code> and
call to <code>estimatePopsize</code>.
</p>


<h3>Value</h3>


<ul>
<li><p> For <code>hatvalues</code> &ndash; A matrix with n rows and p columns where n is a
number of observations in the data and p is number of regression parameters.
</p>
</li>
<li><p> For <code>dfpopsize</code> &ndash; A vector for which k'th element corresponds
to the difference between point estimate of population size estimation on
full data set and point estimate of population size estimation after the
removal of k'th unit from the data set.
</p>
</li>
<li><p> For <code>dfbeta</code> &ndash; A matrix with n rows and p observations where p
is a number of units in data and p is the number of regression parameters.
K'th row of this matrix corresponds to
\(\hat{\boldsymbol{\beta}}-\hat{\boldsymbol{\beta}}_{-k}\)
where \(\hat{\boldsymbol{\beta}}_{-k}\) is a vector of estimates for
regression parameters after the removal of k'th row from the data.
</p>
</li>
<li> <p><code>cooks.distance</code> &ndash; A matrix with a single columns with
values of cooks distance for every unit in <code>model.matrix</code>
</p>
</li>
<li> <p><code>residuals.singleRStaticCountData</code> &ndash; A <code>data.frame</code>
with chosen residuals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Piotr Chlebicki, Maciej Beręsewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimatePopsize">estimatePopsize()</a></code> <code><a href="stats.html#topic+influence.measures">stats::hatvalues()</a></code> <code><a href="#topic+controlMethod">controlMethod()</a></code> <code><a href="stats.html#topic+influence.measures">stats::dfbeta()</a></code>
<code><a href="stats.html#topic+influence.measures">stats::cooks.distance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For singleRStaticCountData class
# Get simple model
Model &lt;- estimatePopsize(
  formula = capture ~ nation + age + gender, 
  data = netherlandsimmigrant, 
  model = ztpoisson, 
  method = "IRLS"
)
# Get dfbeta
dfb &lt;- dfbeta(Model)
# The dfpopsize results are obtained via (It is also possible to not provide 
# dfbeta then they will be computed manually):
res &lt;- dfpopsize(Model, dfbeta = dfb)
summary(res)
plot(res)
# see vaious types of residuals:
head(resid(Model, "all"))

</code></pre>

<hr>
<h2 id='estfun.singleRStaticCountData'>Heteroscedasticity-Consistent Covariance Matrix Estimation for singleRStaticCountData class</h2><span id='topic+estfun.singleRStaticCountData'></span><span id='topic+bread.singleRStaticCountData'></span><span id='topic+vcovHC.singleRStaticCountData'></span>

<h3>Description</h3>

<p>S3 method for <code>vcovHC</code> to handle <code>singleRStaticCountData</code> class objects.
Works exactly like <code>vcov.default</code> the only difference being that this method handles vector generalised linear models.
Updating the covariance matrix in variance/standard error estimation for population size estimator can be done via <code><a href="#topic+redoPopEstimation">redoPopEstimation()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'singleRStaticCountData'
estfun(x, ...)

## S3 method for class 'singleRStaticCountData'
bread(x, ...)

## S3 method for class 'singleRStaticCountData'
vcovHC(
  x,
  type = c("HC3", "const", "HC", "HC0", "HC1", "HC2", "HC4", "HC4m", "HC5"),
  omega = NULL,
  sandwich = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estfun.singleRStaticCountData_+3A_x">x</code></td>
<td>
<p>a fitted <code>singleRStaticCountData</code> class object.</p>
</td></tr>
<tr><td><code id="estfun.singleRStaticCountData_+3A_...">...</code></td>
<td>
<p>for <code>vcovHC</code> additional optional arguments passed to the following functions:
</p>

<ul>
<li> <p><code>estfun</code> &ndash; for empirical estimating functions.
</p>
</li>
<li> <p><code>hatvalues</code> &ndash; for diagonal elements of projection matrix.
</p>
</li>
<li> <p><code>sandwich</code> &ndash; only if <code>sandwich</code> argument in function call was set to <code>TRUE</code>.
</p>
</li>
<li> <p><code>vcov</code> &ndash; when calling <code>bread</code> internally.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estfun.singleRStaticCountData_+3A_type">type</code></td>
<td>
<p>a character string specifying the estimation type, same as in <code>sandwich::vcovHC.default</code>. HC3 is the default value.</p>
</td></tr>
<tr><td><code id="estfun.singleRStaticCountData_+3A_omega">omega</code></td>
<td>
<p>a vector or a function depending on the arguments residuals (i.e. the derivative of log-likelihood with respect to each linear predictor), diaghat (the diagonal of the corresponding hat matrix) and df (the residual degrees of freedom), same as in <code>sandwich::vcovHC.default</code>.</p>
</td></tr>
<tr><td><code id="estfun.singleRStaticCountData_+3A_sandwich">sandwich</code></td>
<td>
<p>logical. Should the sandwich estimator be computed? If set to FALSE only the meat matrix is returned. Same as in <code><a href="sandwich.html#topic+vcovHC">sandwich::vcovHC()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance-covariance matrix estimation corrected for heteroscedasticity of regression errors.
</p>


<h3>Author(s)</h3>

<p>Piotr Chlebicki, Maciej Beręsewicz
</p>


<h3>See Also</h3>

<p><code><a href="sandwich.html#topic+vcovHC">sandwich::vcovHC()</a></code> <code><a href="#topic+redoPopEstimation">redoPopEstimation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
N &lt;- 10000
gender &lt;- rbinom(N, 1, 0.2)
eta &lt;- -1 + 0.5*gender
counts &lt;- rpois(N, lambda = exp(eta))
df &lt;- data.frame(gender, eta, counts)
df2 &lt;- subset(df, counts &gt; 0)
mod1 &lt;-  estimatePopsize(
  formula = counts ~ 1 + gender, 
  data = df2, 
  model = "ztpoisson", 
  method = "optim", 
  popVar = "analytic"
)
require(sandwich)
HC &lt;- sandwich::vcovHC(mod1, type = "HC4")
Fisher &lt;- vcov(mod1, "Fisher") # variance covariance matrix obtained from 
#Fisher (expected) information matrix
HC
Fisher
# usual results
summary(mod1)
# updated results
summary(mod1, cov = HC,
popSizeEst = redoPopEstimation(mod1, cov = HC))
# estimating equations
mod1_sims &lt;- sandwich::estfun(mod1)
head(mod1_sims)
# bread method
all(vcov(mod1, "Fisher") * nrow(df2) == sandwich::bread(mod1, type = "Fisher"))
</code></pre>

<hr>
<h2 id='estimatePopsize'>Single source capture-recapture models</h2><span id='topic+estimatePopsize'></span><span id='topic+estimatePopsize.default'></span>

<h3>Description</h3>

<p><code>estimatePopsize</code> first fits appropriate (v)glm model and
then estimates full (observed and unobserved) population size.
In this types of models it is assumed that the response vector
(i.e. the dependent variable) corresponds to the number of times a given unit
was observed in the source.
Population size is then usually estimated by Horvitz-Thompson type estimator:
</p>
\[\hat{N} = \sum_{k=1}^{N}\frac{I_{k}}{\mathbb{P}(Y_{k}>0)} = 
\sum_{k=1}^{N_{obs}}\frac{1}{1-\mathbb{P}(Y_{k}=0)}\]
<p>where \(I_{k}=I_{Y_{k} > 0}\) are indicator
variables, with value 1 if kth unit was observed at least once and 0 otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePopsize(formula, ...)

## Default S3 method:
estimatePopsize(
  formula,
  data,
  model = c("ztpoisson", "ztnegbin", "ztgeom", "zotpoisson", "ztoipoisson",
    "oiztpoisson", "ztHurdlepoisson", "Hurdleztpoisson", "zotnegbin", "ztoinegbin",
    "oiztnegbin", "ztHurdlenegbin", "Hurdleztnegbin", "zotgeom", "ztoigeom", "oiztgeom",
    "ztHurdlegeom", "ztHurdlegeom", "zelterman", "chao"),
  ratioReg = FALSE,
  weights = NULL,
  subset = NULL,
  naAction = NULL,
  method = c("optim", "IRLS"),
  popVar = c("analytic", "bootstrap", "noEst"),
  controlMethod = NULL,
  controlModel = NULL,
  controlPopVar = NULL,
  modelFrame = TRUE,
  x = FALSE,
  y = TRUE,
  contrasts = NULL,
  offset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimatePopsize_+3A_formula">formula</code></td>
<td>
<p>formula for the model to be fitted, only applied to the &quot;main&quot;
linear predictor. Only single response models are available.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_...">...</code></td>
<td>
<p>additional optional arguments passed to other methods eg.
<code>estimatePopsizeFit</code>.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_data">data</code></td>
<td>
<p>data frame or object coercible to data.frame class containing
data for the regression and population size estimation.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_model">model</code></td>
<td>
<p>model for regression and population estimate full description in <code><a href="#topic+singleRmodels">singleRmodels()</a></code>.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_ratioreg">ratioReg</code></td>
<td>
<p>Not yet implemented</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_weights">weights</code></td>
<td>
<p>optional object of prior weights used in fitting the model.
Can be used to specify number of occurrences of rows in data see <code><a href="#topic+controlModel">controlModel()</a></code></p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_subset">subset</code></td>
<td>
<p>a logical vector indicating which observations should be used
in regression and population size estimation. It will be evaluated on <code>data</code> argument provided on call.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_naaction">naAction</code></td>
<td>
<p>Not yet implemented.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_method">method</code></td>
<td>
<p>method for fitting values currently supported: iteratively
reweighted least squares (<code>IRLS</code>) and maximum likelihood (<code>optim</code>).</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_popvar">popVar</code></td>
<td>
<p>a method of constructing confidence interval either analytic
or bootstrap. Bootstrap confidence interval type may be specified in
<code>controlPopVar.</code> There is also the third possible value of <code>noEst</code>
which skips the population size estimate all together.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_controlmethod">controlMethod</code></td>
<td>
<p>a list indicating parameters to use in fitting the model
may be constructed with <code>singleRcapture::controlMethod</code> function.
More information included in <code><a href="#topic+controlMethod">controlMethod()</a></code>.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_controlmodel">controlModel</code></td>
<td>
<p>a list indicating additional formulas for regression
(like formula for inflation parameter/dispersion parameter) may be
constructed with <code>singleRcapture::controlModel</code> function.
More information will eventually be included in <code><a href="#topic+controlModel">controlModel()</a></code>.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_controlpopvar">controlPopVar</code></td>
<td>
<p>a list indicating parameters to use in estimating variance
of population size estimation may be constructed with
<code>singleRcapture::controlPopVar</code> function.
More information included in <code><a href="#topic+controlPopVar">controlPopVar()</a></code>.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_modelframe">modelFrame</code>, <code id="estimatePopsize_+3A_x">x</code>, <code id="estimatePopsize_+3A_y">y</code></td>
<td>
<p>logical value indicating whether to return model matrix,
dependent vector and model matrix as a part of output.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_contrasts">contrasts</code></td>
<td>
<p>not yet implemented.</p>
</td></tr>
<tr><td><code id="estimatePopsize_+3A_offset">offset</code></td>
<td>
<p>a matrix of offset values with number of columns matching the
number of distribution parameters providing offset values to each of
linear predictors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized linear model is characterized by equation
\[\boldsymbol{\eta}=\boldsymbol{X}\boldsymbol{\beta}\]
where \(\boldsymbol{X}\) is the (lm) model matrix.
The vector generalized linear model is similarly characterized by equations
\[\boldsymbol{\eta}_{k}=\boldsymbol{X}_{k}\boldsymbol{\beta}_{k}\]
where \(\boldsymbol{X}_{k}\) is a (lm) model
matrix constructed from appropriate formula
(specified in <code>controlModel</code> parameter).
</p>
<p>The \(\boldsymbol{\eta}\) is then a vector constructed as:
</p>
\[\boldsymbol{\eta}=\begin{pmatrix}
\boldsymbol{\eta}_{1} \cr 
\boldsymbol{\eta}_{2} \cr
\dotso \cr
\boldsymbol{\eta}_{p}
\end{pmatrix}^{T}\]
<p>and in cases of models in our package the (vlm) model matrix
is constructed as a block matrix:
</p>
\[\boldsymbol{X}_{vlm}=
\begin{pmatrix}
\boldsymbol{X}_{1} & \boldsymbol{0} &\dotso &\boldsymbol{0}\cr
\boldsymbol{0} & \boldsymbol{X}_{2} &\dotso &\boldsymbol{0}\cr
\vdots & \vdots & \ddots & \vdots\cr
\boldsymbol{0} & \boldsymbol{0} &\dotso &\boldsymbol{X}_{p}
\end{pmatrix}\]
<p>this differs from convention in <code>VGAM</code> package (if we only consider our
special cases of vglm models) but this is just a convention and does not
affect the model, this convention is taken because it makes fitting with
IRLS (explanation of algorithm in <code><a href="#topic+estimatePopsizeFit">estimatePopsizeFit()</a></code>) algorithm easier.
(If <code>constraints</code> matrixes in <code>vglm</code> match the ones we implicitly
use the <code>vglm</code> model matrix differs with respect to order of
<code>kronecker</code> multiplication of <code>X</code> and <code>constraints</code>.)
In this package we use observed likelihood to fit regression models.
</p>
<p>As mentioned above usually the population size estimation is done via:
\[\hat{N} = \sum_{k=1}^{N}\frac{I_{k}}{\mathbb{P}(Y_{k}>0)} = 
\sum_{k=1}^{N_{obs}}\frac{1}{1-\mathbb{P}(Y_{k}=0)}\]
</p>
<p>where \(I_{k}=I_{Y_{k} > 0}\) are indicator variables,
with value 1 if kth unit was observed at least once and 0 otherwise.
The \(\mathbb{P}(Y_{k}>0)\) are estimated by maximum likelihood.
</p>
<p>The following assumptions are usually present when using
the method of estimation described above:
</p>

<ol>
<li><p> The specified regression model is correct. This entails linear
relationship between independent variables and dependent ones and
dependent variable being generated by appropriate distribution.
</p>
</li>
<li><p> No unobserved heterogeneity. If this assumption is broken there
are some possible (admittedly imperfect) workarounds see details in
<code><a href="#topic+singleRmodels">singleRmodels()</a></code>.
</p>
</li>
<li><p> The population size is constant in relevant time frame.
</p>
</li>
<li><p> Depending on confidence interval construction (asymptotic) normality
of \(\hat{N}\) statistic is assumed.
</p>
</li></ol>

<p>There are two ways of estimating variance of estimate \(\hat{N}\),
the first being <code>"analytic"</code> usually done by application of
law of total variance to \(\hat{N}\):
</p>
\[\text{var}(\hat{N})=\mathbb{E}\left(\text{var}
\left(\hat{N}|I_{1},\dots,I_{n}\right)\right)+
\text{var}\left(\mathbb{E}(\hat{N}|I_{1},\dots,I_{n})\right)\]
<p>and then by \(\delta\) method to
\(\hat{N}|I_{1},\dots I_{N}\):
</p>
\[\mathbb{E}\left(\text{var}
\left(\hat{N}|I_{1},\dots,I_{n}\right)\right)=
\left.\left(\frac{\partial(N|I_1,\dots,I_N)}{\partial\boldsymbol{\beta}}\right)^{T}
\text{cov}\left(\boldsymbol{\beta}\right)
\left(\frac{\partial(N|I_1,\dots,I_N)}{\partial\boldsymbol{\beta}}\right)
\right|_{\boldsymbol{\beta}=\hat{\boldsymbol{\beta}}}\]
<p>and the \(\text{var}\left(\mathbb{E}(\hat{N}|I_{1},\dots,I_{n})\right)\)
term may be derived analytically (if we assume independence of
observations) since \(\hat{N}|I_{1},\dots,I_{n}\)
is just a constant.
</p>
<p>In general this gives us:
\[
\begin{aligned}
\text{var}\left(\mathbb{E}(\hat{N}|I_{1},\dots,I_{n})\right)&=
\text{var}\left(\sum_{k=1}^{N}\frac{I_{k}}{\mathbb{P}(Y_{k}>0)}\right)\cr
&=\sum_{k=1}^{N}\text{var}\left(\frac{I_{k}}{\mathbb{P}(Y_{k}>0)}\right)\cr
&=\sum_{k=1}^{N}\frac{1}{\mathbb{P}(Y_{k}>0)^{2}}\text{var}(I_{k})\cr
&=\sum_{k=1}^{N}\frac{1}{\mathbb{P}(Y_{k}>0)^{2}}\mathbb{P}(Y_{k}>0)(1-\mathbb{P}(Y_{k}>0))\cr
&=\sum_{k=1}^{N}\frac{1}{\mathbb{P}(Y_{k}>0)}(1-\mathbb{P}(Y_{k}>0))\cr
&\approx\sum_{k=1}^{N}\frac{I_{k}}{\mathbb{P}(Y_{k}>0)^{2}}(1-\mathbb{P}(Y_{k}>0))\cr
&=\sum_{k=1}^{N_{obs}}\frac{1-\mathbb{P}(Y_{k}>0)}{\mathbb{P}(Y_{k}>0)^{2}}
\end{aligned}
\]
</p>
<p>Where the approximation on 6th line appears because in 5th line we sum over
all units, that includes unobserved units, since \(I_{k}\) are
independent and \(I_{k}\sim b(\mathbb{P}(Y_{k}>0))\) the 6th line
is an unbiased estimator of the 5th line.
</p>
<p>The other method for estimating variance is <code>"bootstrap"</code>, but since
\(N_{obs}=\sum_{k=1}^{N}I_{k}\) is also a random variable bootstrap
will not be as simple as just drawing \(N_{obs}\) units from data
with replacement and just computing \(\hat{N}\).
</p>
<p>Method described above is referred to in literature as <code>"nonparametric"</code>
bootstrap (see <code><a href="#topic+controlPopVar">controlPopVar()</a></code>), due to ignoring variability in observed
sample size it is likely to underestimate variance.
</p>
<p>A more sophisticated bootstrap procedure may be described as follows:
</p>

<ol>
<li><p> Compute the probability distribution as:
\[
\frac{\hat{\boldsymbol{f}}_{0}}{\hat{N}}, 
\frac{\boldsymbol{f}_{1}}{\hat{N}}, 
\dots,
\frac{\boldsymbol{f}_{\max{y}}}{\hat{N}}\]
where \(\boldsymbol{f}_{n}\) denotes observed
marginal frequency of units being observed exactly n times.
</p>
</li>
<li><p> Draw \(\hat{N}\) units from the distribution above
(if \(\hat{N}\) is not an integer than draw
\(\lfloor\hat{N}\rfloor + b(\hat{N}-\lfloor\hat{N}\rfloor)\)),
where \(\lfloor\cdot\rfloor\) is the floor function.
</p>
</li>
<li><p> Truncated units with \(y=0\).
</p>
</li>
<li><p> If there are covariates draw them from original data with replacement from
uniform distribution. For example if unit drawn to new data has
\(y=2\) choose one of covariate vectors from original data that
was associated with unit for which was observed 2 times.
</p>
</li>
<li><p> Regress \(\boldsymbol{y}_{new}\) on \(\boldsymbol{X}_{vlm new}\)
and obtain \(\hat{\boldsymbol{\beta}}_{new}\), with starting point
\(\hat{\boldsymbol{\beta}}\) to make it slightly faster, use them
to compute \(\hat{N}_{new}\).
</p>
</li>
<li><p> Repeat 2-5 unit there are at least <code>B</code> statistics are obtained.
</p>
</li>
<li><p> Compute confidence intervals based on <code>alpha</code> and <code>confType</code>
specified in <code><a href="#topic+controlPopVar">controlPopVar()</a></code>.
</p>
</li></ol>

<p>To do step 1 in procedure above it is convenient to first draw binary vector of length
\(\lfloor\hat{N}\rfloor + b(\hat{N}-\lfloor\hat{N}\rfloor)\) with probability
\(1-\frac{\hat{\boldsymbol{f}}_{0}}{\hat{N}}\), sum elements in that vector to
determine the sample size and then draw sample of this size uniformly from the data.
</p>
<p>This procedure is known in literature as <code>"semiparametric"</code> bootstrap
it is necessary to assume that the have a correct estimate
\(\hat{N}\) in order to use this type of bootstrap.
</p>
<p>Lastly there is <code>"paramteric"</code> bootstrap where we assume that the
probabilistic model used to obtain \(\hat{N}\) is correct the
bootstrap procedure may then be described as:
</p>

<ol>
<li><p> Draw \(\lfloor\hat{N}\rfloor + b(\hat{N}-\lfloor\hat{N}\rfloor)\)
covariate information vectors with replacement from data according to
probability distribution that is proportional to: \(N_{k}\),
where \(N_{k}\) is the contribution of kth unit i.e.
\(\dfrac{1}{\mathbb{P}(Y_{k}>0)}\).
</p>
</li>
<li><p> Determine \(\boldsymbol{\eta}\) matrix using estimate
\(\hat{\boldsymbol{\beta}}\).
</p>
</li>
<li><p> Generate \(\boldsymbol{y}\) (dependent variable)
vector using \(\boldsymbol{\eta}\) and
probability mass function associated with chosen model.
</p>
</li>
<li><p> Truncated units with \(y=0\) and construct
\(\boldsymbol{y}_{new}\) and \(\boldsymbol{X}_{vlm new}\).
</p>
</li>
<li><p> Regress \(\boldsymbol{y}_{new}\) on \(\boldsymbol{X}_{vlm new}\)
and obtain \(\hat{\boldsymbol{\beta}}_{new}\)
use them to compute \(\hat{N}_{new}\).
</p>
</li>
<li><p> Repeat 1-5 unit there are at least <code>B</code> statistics are obtained.
</p>
</li>
<li><p> Compute confidence intervals based on <code>alpha</code> and <code>confType</code>
specified in <code><a href="#topic+controlPopVar">controlPopVar()</a></code>
</p>
</li></ol>

<p>It is also worth noting that in the <code>"analytic"</code> method <code>estimatePopsize</code>
only uses &quot;standard&quot; covariance matrix estimation. It is possible that improper
covariance matrix estimate is the only part of estimation that has its assumptions
violated. In such cases post-hoc procedures are implemented in this package
to address this issue.
</p>
<p>Lastly confidence intervals for \(\hat{N}\) are computed
(in analytic case) either by assuming that it follows a normal distribution
or that variable \(\ln(N-\hat{N})\)
follows a normal distribution.
</p>
<p>These estimates may be found using either <code>summary.singleRStaticCountData</code>
method or <code>popSizeEst.singleRStaticCountData</code> function. They're labelled as
<code>normal</code> and <code>logNormal</code> respectively.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>c("singleRStaticCountData", "singleR", "glm", "lm")</code>
with type <code>list</code> containing:<br />
</p>

<ul>
<li><p><code>y</code> &ndash; Vector of dependent variable if specified at function call.
</p>
</li>
<li><p><code>X</code> &ndash; Model matrix if specified at function call.
</p>
</li>
<li><p><code>formula</code> &ndash; A list with formula provided on call and additional formulas specified in <code>controlModel</code>.
</p>
</li>
<li><p><code>call</code> &ndash; Call matching original input.
</p>
</li>
<li><p><code>coefficients</code> &ndash; A vector of fitted coefficients of regression.
</p>
</li>
<li><p><code>control</code> &ndash; A list of control parameters for <code>controlMethod</code> and <code>controlModel</code>, <code>controlPopVar</code> is included in populationSize.
</p>
</li>
<li><p><code>model</code> &ndash; Model which estimation of population size and regression was built, object of class family.
</p>
</li>
<li><p><code>deviance</code> &ndash; Deviance for the model.
</p>
</li>
<li><p><code>priorWeights</code> &ndash; Prior weight provided on call.
</p>
</li>
<li><p><code>weights</code> &ndash; If <code>IRLS</code> method of estimation was chosen weights returned by <code>IRLS</code>, otherwise same as <code>priorWeights</code>.
</p>
</li>
<li><p><code>residuals</code> &ndash; Vector of raw residuals.
</p>
</li>
<li><p><code>logL</code> &ndash; Logarithm likelihood obtained at final iteration.
</p>
</li>
<li><p><code>iter</code> &ndash; Numbers of iterations performed in fitting or if <code>stats::optim</code> was used number of call to loglikelihood function.
</p>
</li>
<li><p><code>dfResiduals</code> &ndash; Residual degrees of freedom.
</p>
</li>
<li><p><code>dfNull</code> &ndash; Null degrees of freedom.
</p>
</li>
<li><p><code>fittValues</code> &ndash; Data frame of fitted values for both mu (the expected value) and lambda (Poisson parameter).
</p>
</li>
<li><p><code>populationSize</code> &ndash; A list containing information of population size estimate.
</p>
</li>
<li><p><code>modelFrame</code> &ndash; Model frame if specified at call.
</p>
</li>
<li><p><code>linearPredictors</code> &ndash; Vector of fitted linear predictors.
</p>
</li>
<li><p><code>sizeObserved</code> &ndash; Number of observations in original model frame.
</p>
</li>
<li><p><code>terms</code> &ndash; terms attribute of model frame used.
</p>
</li>
<li><p><code>contrasts</code> &ndash; contrasts specified in function call.
</p>
</li>
<li><p><code>naAction</code> &ndash; naAction used.
</p>
</li>
<li><p><code>which</code> &ndash; list indicating which observations were used in regression/population size estimation.
</p>
</li>
<li><p><code>fittingLog</code> &ndash; log of fitting information for <code>"IRLS"</code> fitting if specified in <code>controlMethod</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Piotr Chlebicki, Maciej Beręsewicz
</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>


<h3>References</h3>

<p>General single source capture recapture literature:
</p>
<p>Zelterman, Daniel (1988). ‘Robust estimation in truncated discrete distributions
with application to capture-recapture experiments’. In: Journal of statistical
planning and inference 18.2, pp. 225–237.
</p>
<p>Heijden, Peter GM van der et al. (2003). ‘Point and interval estimation of the
population size using the truncated Poisson regression model’.
In: Statistical Modelling 3.4, pp. 305–322. doi: 10.1191/1471082X03st057oa.
</p>
<p>Cruyff, Maarten J. L. F. and Peter G. M. van der Heijden (2008). ‘Point and
Interval Estimation of the Population Size Using a Zero-Truncated Negative
Binomial Regression Model’. In: Biometrical Journal 50.6, pp. 1035–1050.
doi: 10.1002/bimj.200810455
</p>
<p>Böhning, Dankmar and Peter G. M. van der Heijden (2009). ‘A covariate adjustment
for zero-truncated approaches to estimating the size of hidden and
elusive populations’. In: The Annals of Applied Statistics 3.2, pp. 595–610.
doi: 10.1214/08-AOAS214.
</p>
<p>Böhning, Dankmar, Alberto Vidal-Diez et al. (2013). ‘A Generalization of
Chao’s Estimator for Covariate Information’. In: Biometrics 69.4, pp. 1033–
1042. doi: 10.1111/biom.12082
</p>
<p>Böhning, Dankmar and Peter G. M. van der Heijden (2019). ‘The identity of the
zero-truncated, one-inflated likelihood and the zero-one-truncated likelihood
for general count densities with an application to drink-driving in Britain’.
In: The Annals of Applied Statistics 13.2, pp. 1198–1211.
doi: 10.1214/18-AOAS1232.
</p>
<p>Navaratna WC, Del Rio Vilas VJ, Böhning D. Extending Zelterman's approach for
robust estimation of population size to zero-truncated clustered Data.
Biom J. 2008 Aug;50(4):584-96. doi: 10.1002/bimj.200710441.
</p>
<p>Böhning D. On the equivalence of one-inflated zero-truncated and zero-truncated
one-inflated count data likelihoods. Biom J. 2022 Aug 15. doi: 10.1002/bimj.202100343.
</p>
<p>Böhning, D., Friedl, H. Population size estimation based upon zero-truncated,
one-inflated and sparse count data. Stat Methods Appl 30, 1197–1217 (2021).
doi: 10.1007/s10260-021-00556-8
</p>
<p>Bootstrap:
</p>
<p>Zwane, PGM EN and Van der Heijden, Implementing the parametric bootstrap in capture-recapture
models with continuous covariates 2003 Statistics &amp; probability letters 65.2 pp 121-125
</p>
<p>Norris, James L and Pollock, Kenneth H Including model uncertainty in estimating variances
in multiple capture studies 1996 in Environmental and Ecological Statistics 3.3 pp 235-244
</p>
<p>Vector generalized linear models:
</p>
<p>Yee, T. W. (2015). Vector Generalized Linear and Additive Models:
With an Implementation in R. New York, USA: Springer. ISBN 978-1-4939-2817-0.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">stats::glm()</a></code> &ndash; For more information on generalized linear models.
</p>
<p><code><a href="stats.html#topic+optim">stats::optim()</a></code> &ndash; For more information on <code>optim</code> function used in
<code>optim</code> method of fitting regression.
</p>
<p><code><a href="#topic+controlMethod">controlMethod()</a></code> &ndash; For control parameters related to regression.
</p>
<p><code><a href="#topic+controlPopVar">controlPopVar()</a></code> &ndash; For control parameters related to population size estimation.
</p>
<p><code><a href="#topic+controlModel">controlModel()</a></code> &ndash; For control parameters related to model specification.
</p>
<p><code><a href="#topic+estimatePopsizeFit">estimatePopsizeFit()</a></code> &ndash; For more information on fitting procedure in
<code>esitmate_popsize</code>.
</p>
<p><code><a href="#topic+popSizeEst">popSizeEst()</a></code> <code><a href="#topic+redoPopEstimation">redoPopEstimation()</a></code> &ndash; For extracting population size
estimation results are applying post-hoc procedures.
</p>
<p><code><a href="#topic+summary.singleRStaticCountData">summary.singleRStaticCountData()</a></code> &ndash; For summarizing important information about the
model and population size estimation results.
</p>
<p><code><a href="#topic+marginalFreq">marginalFreq()</a></code> &ndash; For information on marginal frequencies and comparison
between observed and fitted quantities.
</p>
<p><code><a href="VGAM.html#topic+vglm">VGAM::vglm()</a></code> &ndash; For more information on vector generalized linear models.
</p>
<p><code><a href="#topic+singleRmodels">singleRmodels()</a></code> &ndash; For description of various models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Model from 2003 publication 
# Point and interval estimation of the
# population size using the truncated Poisson regression mode
# Heijden, Peter GM van der et al. (2003)
model &lt;- estimatePopsize(
   formula = capture ~ gender + age + nation, 
   data = netherlandsimmigrant, 
   model = ztpoisson
)
summary(model)
# Graphical presentation of model fit
plot(model, "rootogram")
# Statistical test
# see documentation for summary.singleRmargin
summary(marginalFreq(model), df = 1, "group")

# We currently support 2 methods of numerical fitting
# (generalized) IRLS algorithm and via stats::optim
# the latter one is faster when fitting negative binomial models 
# (and only then) due to IRLS having to numerically compute
# (expected) information matrixes, optim is also less reliable when
# using alphaFormula argument in controlModel
modelNegBin &lt;- estimatePopsize(
    formula = TOTAL_SUB ~ ., 
    data = farmsubmission, 
    model = ztnegbin, 
    method = "optim"
)
summary(modelNegBin)
summary(marginalFreq(modelNegBin))

# More advanced call that specifies additional formula and shows
# in depth information about fitting procedure
pseudoHurdleModel &lt;- estimatePopsize(
    formula = capture ~ nation + age,
    data = netherlandsimmigrant,
    model = Hurdleztgeom,
    method = "IRLS",
    controlMethod = controlMethod(verbose = 5),
    controlModel = controlModel(piFormula = ~ gender)
)
summary(pseudoHurdleModel)
# Assessing model fit
plot(pseudoHurdleModel, "rootogram")
summary(marginalFreq(pseudoHurdleModel), "group", df = 1)


# A advanced input with additional information for fitting procedure and
# additional formula specification and different link for inflation parameter.
Model &lt;- estimatePopsize(
 formula = TOTAL_SUB ~ ., 
 data = farmsubmission, 
 model = oiztgeom(omegaLink = "cloglog"), 
 method = "IRLS", 
 controlMethod = controlMethod(
   stepsize = .85, 
   momentumFactor = 1.2,
   epsilon = 1e-10, 
   silent = TRUE
 ),
 controlModel = controlModel(omegaFormula = ~ C_TYPE + log_size)
)
summary(marginalFreq(Model), df = 18 - length(Model$coefficients))
summary(Model)

</code></pre>

<hr>
<h2 id='estimatePopsizeFit'>Regression fitting in single source capture-recapture models</h2><span id='topic+estimatePopsizeFit'></span>

<h3>Description</h3>

<p><code>estimatePopsizeFit</code> does for <code>estimatePopsize</code> what
<code>glm.fit</code> does for <code>glm</code>. It is internally called in
<code>estimatePopsize</code>. Since <code>estimatePopsize</code> does much more than
just regression fitting <code>estimatePopsizeFit</code> is much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePopsizeFit(
  y,
  X,
  family,
  control,
  method,
  priorWeights,
  coefStart,
  etaStart,
  offset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimatePopsizeFit_+3A_y">y</code></td>
<td>
<p>vector of dependent variables.</p>
</td></tr>
<tr><td><code id="estimatePopsizeFit_+3A_x">X</code></td>
<td>
<p>model matrix, the vglm one.</p>
</td></tr>
<tr><td><code id="estimatePopsizeFit_+3A_family">family</code></td>
<td>
<p>same as model in <code>estimatePopsize</code>.</p>
</td></tr>
<tr><td><code id="estimatePopsizeFit_+3A_control">control</code></td>
<td>
<p>control parameters created in <code>controlModel</code>.</p>
</td></tr>
<tr><td><code id="estimatePopsizeFit_+3A_method">method</code></td>
<td>
<p>method of estimation same as in <code>estimatePopsize</code>.</p>
</td></tr>
<tr><td><code id="estimatePopsizeFit_+3A_priorweights">priorWeights</code></td>
<td>
<p>vector of prior weights its the same argument as weights
in <code>estimatePopsize</code>.</p>
</td></tr>
<tr><td><code id="estimatePopsizeFit_+3A_etastart">etaStart</code>, <code id="estimatePopsizeFit_+3A_coefstart">coefStart</code></td>
<td>
<p>initial value of regression parameters or
linear predictors.</p>
</td></tr>
<tr><td><code id="estimatePopsizeFit_+3A_offset">offset</code></td>
<td>
<p>offset passed from by default passed from <code><a href="#topic+estimatePopsize">estimatePopsize()</a></code>.</p>
</td></tr>
<tr><td><code id="estimatePopsizeFit_+3A_...">...</code></td>
<td>
<p>arguments to pass to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>If <code>method</code> argument was set to <code>"optim"</code> the <code>stats::optim</code>
function will be used to fit regression with analytically computed gradient and
(minus) log likelihood functions as <code>gr</code> and <code>fn</code> arguments.
Unfortunately <code>optim</code> does not allow for hessian to be specified.
More information about how to modify <code>optim</code> fitting is included in
<code><a href="#topic+controlMethod">controlMethod()</a></code>.
</p>
<p>If <code>method</code> argument was set to <code>"IRLS"</code> the iteratively reweighted
least squares. The algorithm is well know in generalised linear models.
Thomas W. Yee later extended this algorithm to vector generalised linear models
and in more general terms it can roughly be described as
(this is Yee's description after changing some conventions):
</p>

<ol>
<li><p> Initialize with:
</p>

<ul>
<li> <p><code>converged &lt;- FALSE</code>
</p>
</li>
<li> <p><code>iter &lt;- 1</code>
</p>
</li>
<li> <p>\(\boldsymbol{\beta}\)<code> &lt;- start</code>
</p>
</li>
<li> <p>\(\boldsymbol{W}\)<code> &lt;- prior</code>
</p>
</li>
<li> <p>\(\ell\)<code> &lt;- </code>\(\ell(\boldsymbol{\beta})\)
</p>
</li></ul>

</li>
<li><p> If <code>converged</code> or <code>iter &gt; Maxiter</code> move to step 7.
</p>
</li>
<li><p> Store values from previous algorithm step:
</p>

<ul>
<li> <p>\(\boldsymbol{W}_{-}\)<code> &lt;- </code>
\(\boldsymbol{W}\)
</p>
</li>
<li> <p>\(\ell_{-}\)<code> &lt;- </code>
\(\ell\)
</p>
</li>
<li> <p>\(\boldsymbol{\beta}_{-}\)<code> &lt;- </code>
\(\boldsymbol{\beta}\)
</p>
</li></ul>
<p> and assign values at current step:
</p>

<ul>
<li> <p>\(\boldsymbol{\eta}\)<code> &lt;- </code>
\(\boldsymbol{X}_{vlm}\boldsymbol{\beta}\)
</p>
</li>
<li> <p>\(Z_{i}\)<code> &lt;- </code>
\(
\eta_{i}+\frac{\partial\ell_{i}}{\partial\eta_{i}}
\mathbb{E}\left(\frac{\partial^{2}\ell_{i}}{
\partial\eta_{i}^{T}\partial\eta_{i}}\right)^{-1}\)
</p>
</li>
<li> <p>\(\boldsymbol{W}_{ij}\)<code> &lt;- </code>
\(\mathbb{E}\left(\frac{\partial^{2}\ell}{
\partial\boldsymbol{\eta}_{j}^{T}\partial\boldsymbol{\eta}_{i}}\right)\)
</p>
</li></ul>

<p>where \(\ell_{i}\) is the ith component of log likelihood
function, \(\eta_{i}\) is the vector of linear predictors
associated with ith row and \(\mathbb{E}\left(\frac{\partial^{2}\ell_{i}}{
\partial\eta_{i}^{T}\partial\eta_{i}}\right)\)
corresponds to weights associated with ith row and \(\boldsymbol{W}\)
is a block matrix, made of diagonal matrixes
\(\mathbb{E}\left(\frac{\partial^{2}\ell}{
\partial\boldsymbol{\eta}_{j}^{T}\partial\boldsymbol{\eta}_{i}}\right)\)
</p>
</li>
<li><p> Regress \(\boldsymbol{Z}\) on
\(\boldsymbol{X}_{vlm}\) to obtain
\(\boldsymbol{\beta}\) as:
\[\boldsymbol{\beta}=
\left(\boldsymbol{X}_{vlm}^{T}\boldsymbol{W}\boldsymbol{X}_{vlm}\right)^{-1}
\boldsymbol{X}_{vlm}^{T}\boldsymbol{W}\boldsymbol{Z}\]
</p>
</li>
<li><p> Assign:
</p>

<ul>
<li><p><code>converged &lt;- </code>\(
\ell(\boldsymbol{\beta})-\ell_{-} < \varepsilon\cdot\ell_{-}\)
or
\(
||\boldsymbol{\beta}-\boldsymbol{\beta}_{-}||_{\infty} < \varepsilon\)
</p>
</li>
<li><p><code>iter &lt;- iter + 1</code>
</p>
</li></ul>

<p>where \(\varepsilon\) is the relative tolerance level,
by default <code>1e-8</code>.
</p>
</li>
<li><p> Return to step 2.
</p>
</li>
<li><p> Return \(\boldsymbol{\beta}, \boldsymbol{W}\), <code>iter</code>.
</p>
</li></ol>

<p>In this package we use different conventions for \(\boldsymbol{X}_{vlm}\)
matrix hence slight differences are present in algorithm description but
results are identical.
</p>


<h3>Value</h3>

<p>List with regression parameters, working weights
(if IRLS fitting method) was chosen and number of iterations taken.
</p>


<h3>Author(s)</h3>

<p>Piotr Chlebicki, Maciej Beresewicz
</p>


<h3>References</h3>

<p>Yee, T. W. (2015). Vector Generalized Linear and Additive Models:
With an Implementation in R. New York, USA: Springer. ISBN 978-1-4939-2817-0.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">stats::glm()</a></code> <code><a href="#topic+estimatePopsize">estimatePopsize()</a></code> <code><a href="#topic+controlMethod">controlMethod()</a></code> <code><a href="stats.html#topic+optim">stats::optim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(farmsubmission)

# construct vglm model matrix
X &lt;- matrix(data = 0, nrow = 2 * NROW(farmsubmission), ncol = 7)
X[1:NROW(farmsubmission), 1:4] &lt;- model.matrix(
~ 1 + log_size + log_distance + C_TYPE, 
farmsubmission
)


X[-(1:NROW(farmsubmission)), 5:7] &lt;- X[1:NROW(farmsubmission), c(1, 3, 4)]

# this attribute tells the function which elements of the design matrix 
# correspond to which linear predictor 
attr(X, "hwm") &lt;- c(4, 3)

# get starting points
start &lt;- glm.fit(
y = farmsubmission$TOTAL_SUB, 
x = X[1:NROW(farmsubmission), 1:4], 
family = poisson()
)$coefficients

res &lt;- estimatePopsizeFit(
y = farmsubmission$TOTAL_SUB, 
X = X, 
method = "IRLS", 
priorWeights = 1, 
family = ztoigeom(), 
control = controlMethod(verbose = 5), 
coefStart = c(start, 0, 0, 0),
etaStart = matrix(X %*% c(start, 0, 0, 0), ncol = 2),
offset = cbind(rep(0, NROW(farmsubmission)), rep(0, NROW(farmsubmission)))
)

# extract results

# regression coefficient vector
res$beta

# check likelihood
ll &lt;- ztoigeom()$makeMinusLogLike(y = farmsubmission$TOTAL_SUB, X = X)

-ll(res$beta)

# number of iterations
res$iter

# working weights
head(res$weights)

# Compare with optim call

res2 &lt;- estimatePopsizeFit(
  y = farmsubmission$TOTAL_SUB, 
  X = X, 
  method = "optim", 
  priorWeights = 1, 
  family = ztoigeom(), 
  coefStart = c(start, 0, 0, 0),
  control = controlMethod(verbose = 1, silent = TRUE),
  offset = cbind(rep(0, NROW(farmsubmission)), rep(0, NROW(farmsubmission)))
)
# extract results

# regression coefficient vector
res2$beta


# check likelihood
-ll(res2$beta)

# number of calls to log lik function
# since optim does not return the number of
# iterations
res2$iter

# optim does not calculated working weights
head(res2$weights)

</code></pre>

<hr>
<h2 id='farmsubmission'>British farm submissions data</h2><span id='topic+farmsubmission'></span>

<h3>Description</h3>

<p>Data on British animal farms submissions to AHVLA. British farms
are able to submit samples to AHVLA if cause of death for an animal
cannot be determined and private veterinary surgeon decides to submit them,
unless there is notifiable disease suspected then such a submission is not
required.
</p>
<p>This data set contains information about such farms.
All submissions from farms are included in this data frame
not only carcasses but also blood samples etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("farmsubmission")
</code></pre>


<h3>Format</h3>

<p>Data frame with 12,036 rows and 4 columns.
</p>

<dl>
<dt><code>TOTAL_SUB</code></dt><dd><p>Number of submissions of animal material.</p>
</dd>
<dt><code>log_size</code></dt><dd><p>Numerical value equal to logarithm of size of farm.</p>
</dd>
<dt><code>log_distance</code></dt><dd><p>Numerical value equal to logarithm of distance to nearest AHVLA center.</p>
</dd>
<dt><code>C_TYPE</code></dt><dd><p>Factor describing type of activity on farm that animals are
used for. Either <code>Dairy</code> or <code>Beef</code></p>
</dd>
</dl>



<h3>References</h3>

<p>This data set and its description was provided in publication:
Böhning, D., Vidal Diez, A., Lerdsuwansri, R., Viwatwongkasem, C., and Arnold, M. (2013). &quot;A generalization of Chao's estimator for covariate information&quot;. <em>Biometrics</em>, 69(4), 1033-1042. doi:10.1111/biom.12082
</p>

<hr>
<h2 id='marginalFreq'>Observed and fitted marginal Frequencies</h2><span id='topic+marginalFreq'></span>

<h3>Description</h3>

<p>A function that given a fitted <code>singleR</code> class object
computed marginal frequencies by as sum of probability density functions
for each unit in data at each point i.e. kth element of marginal frequency
table is given by \(\sum_{j=1}^{N_{obs}}\mathbb{P}(Y_{j}=k|\eta_{j})\).
For k=0 only (if specified at call) they are computed as
\(\hat{N}-N_{obs}\) because
\(\boldsymbol{f}_{0}\) is assumed to
the unobserved part of the studied population.
</p>
<p>These frequencies are useful in diagnostics for count data regression, such
as assessment of fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalFreq(
  object,
  includeones = TRUE,
  includezeros = TRUE,
  onecount = NULL,
  range,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalFreq_+3A_object">object</code></td>
<td>
<p>object of <code>singleR</code> class.</p>
</td></tr>
<tr><td><code id="marginalFreq_+3A_includeones">includeones</code></td>
<td>
<p>logical value indicating whether to include the estimated number of zero counts.</p>
</td></tr>
<tr><td><code id="marginalFreq_+3A_includezeros">includezeros</code></td>
<td>
<p>logical value indicating whether to include one counts in the zero-one truncated models.</p>
</td></tr>
<tr><td><code id="marginalFreq_+3A_onecount">onecount</code></td>
<td>
<p>a numeric value indicating number of one counts if null <code>trcount</code> from object will be assumed to be a number one counts.</p>
</td></tr>
<tr><td><code id="marginalFreq_+3A_range">range</code></td>
<td>
<p>optional argument specifying range of selected Y values.</p>
</td></tr>
<tr><td><code id="marginalFreq_+3A_...">...</code></td>
<td>
<p>currently does nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with observed name of the fitted model family degrees of freedom and observed and fitted marginal frequencies.
</p>


<h3>Author(s)</h3>

<p>Piotr Chlebicki
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimatePopsize">estimatePopsize()</a></code> &ndash; where example of usage is provided
</p>

<hr>
<h2 id='netherlandsimmigrant'>Data on immigration in Netherlands</h2><span id='topic+netherlandsimmigrant'></span>

<h3>Description</h3>

<p>This data set contains information about immigrants in four
cities (Amsterdam, Rotterdam, The Hague and Utrecht) in Netherlands that have
been staying in the country illegally in 1995 and have appeared in police
records that year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("netherlandsimmigrant")
</code></pre>


<h3>Format</h3>

<p>Data frame with 1,880 rows and 5 columns.
</p>

<dl>
<dt><code>capture</code></dt><dd><p>Number of times a person has been captured by police.</p>
</dd>
<dt><code>gender</code></dt><dd><p>Factor describing gender of the apprehended person.</p>
</dd>
<dt><code>age</code></dt><dd><p>Factor describing age of apprehended person.
Either bellow or above 40 years old.</p>
</dd>
<dt><code>reason</code></dt><dd><p>Factor describing reason for being apprehended by
police either illegal stay in Netherlands or other reasons.</p>
</dd>
<dt><code>nation</code></dt><dd><p>Factor with nation of origin of the captured person.
There are 6 levels of this variable: <code>"American and Australia",
  "Asia", "North Africa", "Rest of Africa", "Surinam", "Turkey"</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>This data set and its description was provided in publication:
van Der Heijden, P. G., Bustami, R., Cruyff, M. J., Engbersen, G., and Van Houwelingen, H. C. (2003). Point and interval estimation of the population size using the truncated Poisson regression model. <em>Statistical Modelling</em>, 3(4), 305-322. doi:10.1191/1471082X03st057oa
</p>

<hr>
<h2 id='plot.singleRStaticCountData'>Diagnostic plots for regression and population size estimation.</h2><span id='topic+plot.singleRStaticCountData'></span>

<h3>Description</h3>

<p>Simple diagnostic plots for <code>singleRStaticCountData</code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'singleRStaticCountData'
plot(
  x,
  plotType = c("qq", "marginal", "fitresid", "bootHist", "rootogram", "dfpopContr",
    "dfpopBox", "scaleLoc", "cooks", "hatplot", "strata"),
  confIntStrata = c("normal", "logNormal"),
  histKernels = TRUE,
  dfpop,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.singleRStaticCountData_+3A_x">x</code></td>
<td>
<p>object of <code>singleRStaticCountData</code> class.</p>
</td></tr>
<tr><td><code id="plot.singleRStaticCountData_+3A_plottype">plotType</code></td>
<td>
<p>character parameter specifying type of plot to be made.
The following list presents and briefly explains possible type of plots:
</p>

<ul>
<li> <p><code>qq</code> &ndash; The quantile-quantile plot for pearson residuals
(or standardized pearson residuals if these are available for the model) i.e.
empirical quantiles from residuals are plotted against theoretical quantiles
from standard distribution.
</p>
</li>
<li> <p><code>marginal</code> &ndash; A plot made by <code>matplot</code> with fitted and
observed marginal frequencies with labels.
</p>
</li>
<li> <p><code>fitresid</code> &ndash; Plot of fitted linear predictors against
(standardized) pearson residuals.
</p>
</li>
<li> <p><code>bootHist</code> &ndash; Simple histogram for statistics obtained from
bootstrapping (if one was performed and the statistics were saved).
</p>
</li>
<li> <p><code>rootogram</code> &ndash; Rootogram, for full explanation see:
Kleiber and Zeileis Visualizing Count Data Regressions Using Rootograms (2016),
in short it is a <code>barplot</code> where height is the square root of observed marginal
frequencies adjusted by difference between square root of observed and fitted marginal
frequencies connected by line representing fitted marginal frequencies.
The less of a difference there is between the 0 line and beginning of a bar
the more accurate fitt was produced by the model.
</p>
</li>
<li> <p><code>dfpopContr</code> &ndash; Plot of <code>dfpopsize</code> against unit contribution.
On the plot is y = x line i.e. what deletion effect would be if removing the
unit from the model didn't effect regression coefficients. The further away
the observation is from this line the more influential it is.
</p>
</li>
<li> <p><code>dfpopBox</code> &ndash; Boxplot of <code>dfpopsize</code> for getting the general
idea about the distribution of the &quot;influence&quot; of each unit on
population size estimate.
</p>
</li>
<li> <p><code>scaleLoc</code> &ndash; The scale - location plot i.e. square root of
absolute values of (standardized) pearson residuals against linear predictors
for each column of linear predictors.
</p>
</li>
<li> <p><code>cooks</code> &ndash; Plot of cooks distance for detecting influential observations.
</p>
</li>
<li> <p><code>hatplot</code> &ndash; Plot of hat values for each linear predictor for detecting influential observations.
</p>
</li>
<li> <p><code>strata</code> &ndash; Plot of confidence intervals and point estimates for stratas provided in <code>...</code> argument
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.singleRStaticCountData_+3A_confintstrata">confIntStrata</code></td>
<td>
<p>confidence interval type to use for strata plot.
Currently supported values are <code>"normal"</code> and <code>"logNormal"</code>.</p>
</td></tr>
<tr><td><code id="plot.singleRStaticCountData_+3A_histkernels">histKernels</code></td>
<td>
<p>logical value indicating whether to add density lines
to histogram.</p>
</td></tr>
<tr><td><code id="plot.singleRStaticCountData_+3A_dfpop">dfpop</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="plot.singleRStaticCountData_+3A_...">...</code></td>
<td>
<p>additional optional arguments passed to the following functions:
</p>

<ul>
<li><p> For <code>plotType = "bootHist"</code>
</p>

<ul>
<li> <p><code>graphics::hist</code> &ndash; with <code>x, main, xlab, ylab</code> parameters fixed.
</p>
</li></ul>

</li>
<li><p> For <code>plotType = "rootogram"</code>
</p>

<ul>
<li> <p><code>graphics::barplot</code> &ndash; with <code>height, offset, ylab, xlab, ylim</code> parameters fixed.
</p>
</li>
<li> <p><code>graphics::lines</code> &ndash; with <code>x, y, pch, type, lwd, col</code> parameters fixed.
</p>
</li></ul>

</li>
<li><p> For <code>plotType = "dfpopContr"</code>
</p>

<ul>
<li> <p><code>dfpopsize</code> &ndash; with <code>model, observedPop</code> parameters fixed.
</p>
</li>
<li> <p><code>plot.default</code> &ndash; with <code>x, y, xlab, main</code> parameters fixed.
</p>
</li></ul>

</li>
<li><p> For <code>plotType = "dfpopBox"</code>
</p>

<ul>
<li> <p><code>dfpopsize</code> &ndash; with <code>model, observedPop</code> parameters fixed.
</p>
</li>
<li> <p><code>graphics::boxplot</code> &ndash; with <code>x, ylab, main</code> parameters fixed.
</p>
</li></ul>

</li>
<li><p> For <code>plotType = "scaleLoc"</code>
</p>

<ul>
<li> <p><code>plot.default</code> &ndash; with <code>x, y, xlab, ylab, main, sub</code> parameters fixed.
</p>
</li></ul>

</li>
<li><p> For <code>plotType = "fitresid"</code>
</p>

<ul>
<li> <p><code>plot.default</code> &ndash; with <code>x, y, xlab, ylab, main, sub</code> parameters fixed.
</p>
</li></ul>

</li>
<li><p> For <code>plotType = "cooks"</code>
</p>

<ul>
<li> <p><code>plot.default</code> &ndash; with <code>x, xlab, ylab, main</code> parameters fixed.
</p>
</li></ul>

</li>
<li><p> For <code>plotType = "hatplot"</code>
</p>

<ul>
<li> <p><code>hatvalues.singleRStaticCountData</code>
</p>
</li>
<li> <p><code>plot.default</code> &ndash; with <code>x, xlab, ylab, main</code> parameters fixed.
</p>
</li></ul>

</li>
<li><p> For <code>plotType = "strata"</code>
</p>

<ul>
<li> <p><code>stratifyPopsize.singleRStaticCountData</code>
</p>
</li></ul>

</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value only the plot being made.
</p>


<h3>Author(s)</h3>

<p>Piotr Chlebicki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimatePopsize">estimatePopsize()</a></code> <code><a href="#topic+dfpopsize">dfpopsize()</a></code> <code><a href="#topic+marginalFreq">marginalFreq()</a></code> <code><a href="stats.html#topic+plot.lm">stats::plot.lm()</a></code> <code><a href="stats.html#topic+influence.measures">stats::cooks.distance()</a></code> <code><a href="#topic+hatvalues.singleRStaticCountData">hatvalues.singleRStaticCountData()</a></code>
</p>

<hr>
<h2 id='popSizeEst'>Extract population size estimation results.</h2><span id='topic+popSizeEst'></span><span id='topic+popSizeEst.singleRStaticCountData'></span>

<h3>Description</h3>

<p>An extractor function with <code>singleRStaticCountData</code> method for extracting
important information regarding pop size estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popSizeEst(object, ...)

## S3 method for class 'singleRStaticCountData'
popSizeEst(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popSizeEst_+3A_object">object</code></td>
<td>
<p>object with population size estimates.</p>
</td></tr>
<tr><td><code id="popSizeEst_+3A_...">...</code></td>
<td>
<p>additional optional arguments, currently not used in <code>singleRStaticCountData</code> class method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>popSizeEstResults</code> containing population size estimation results.
</p>

<hr>
<h2 id='predict.singleRStaticCountData'>Predict method for <code>singleRStaticCountData</code> class</h2><span id='topic+predict.singleRStaticCountData'></span>

<h3>Description</h3>

<p>A method for <code>predict</code> function, works analogous to <code>predict.glm</code>
but gives the possibility to get standard errors of
mean/distribution parameters and directly get pop size estimates for new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'singleRStaticCountData'
predict(
  object,
  newdata,
  type = c("response", "link", "mean", "popSize", "contr"),
  se.fit = FALSE,
  na.action = NULL,
  weights,
  cov,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.singleRStaticCountData_+3A_object">object</code></td>
<td>
<p>an object of <code>singleRStaticCountData</code> class.</p>
</td></tr>
<tr><td><code id="predict.singleRStaticCountData_+3A_newdata">newdata</code></td>
<td>
<p>an optional <code>data.frame</code> containing new data.</p>
</td></tr>
<tr><td><code id="predict.singleRStaticCountData_+3A_type">type</code></td>
<td>
<p>the type of prediction required, possible values are:
</p>

<ul>
<li> <p><code>"response"</code>&ndash; For matrix containing estimated distributions
parameters.
</p>
</li>
<li> <p><code>"link"</code>    &ndash; For matrix of linear predictors.
</p>
</li>
<li> <p><code>"mean"</code>    &ndash; For fitted values of both \(Y\) and
\(Y|Y>0\).
</p>
</li>
<li> <p><code>"contr"</code>   &ndash; For inverse probability weights (here named for
observation contribution to population size estimate).
</p>
</li>
<li> <p><code>"popSize"</code> &ndash; For population size estimation. Note
this results in a call to <code>redoPopEstimation</code> and it is
usually better to call this function directly.
</p>
</li></ul>
<p> by default set to <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="predict.singleRStaticCountData_+3A_se.fit">se.fit</code></td>
<td>
<p>a logical value indicating whether standard errors should be
computed. Only matters for <code>type</code> in <code>"response", "mean", "link"</code>.</p>
</td></tr>
<tr><td><code id="predict.singleRStaticCountData_+3A_na.action">na.action</code></td>
<td>
<p>does nothing yet.</p>
</td></tr>
<tr><td><code id="predict.singleRStaticCountData_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights for <code>type</code> in <code>"contr", "popSize"</code>.</p>
</td></tr>
<tr><td><code id="predict.singleRStaticCountData_+3A_cov">cov</code></td>
<td>
<p>optional matrix or function or character specifying either
a covariance matrix or a function to compute that covariance matrix.
By default <code>vcov.singleRStaticCountData</code> can be set to e.g. <code>vcovHC</code>.</p>
</td></tr>
<tr><td><code id="predict.singleRStaticCountData_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions, for now this only affects
<code>vcov.singleRStaticCountData</code> method and <code>cov</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Standard errors are computed with assumption of regression
coefficients being asymptotically normally distributed, if this assumption
holds then each of linear predictors i.e. each row of
\(\boldsymbol{\eta}=\boldsymbol{X}_{vlm}\boldsymbol{\beta}\)
is asymptotically normally distributed and their variances are expressed by
well known formula. The mean \(\mu\) and distribution parameters
are then differentiable functions of asymptotically normally distributed
variables and therefore their variances can be computed using (multivariate)
delta method.
</p>


<h3>Value</h3>

<p>Depending on <code>type</code> argument if one of <code>"response", "link", "mean"</code>
a matrix with fitted values and possibly standard errors if <code>se.fit</code>
argument was set to <code>TRUE</code>, if <code>type</code> was set to <code>"contr"</code>
a vector with inverses of probabilities, finally for <code>"popSize"</code>
an object of class <code>popSizeEstResults</code> with its own methods containing
population size estimation results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+redoPopEstimation">redoPopEstimation()</a></code> <code><a href="stats.html#topic+summary.glm">stats::summary.glm()</a></code> <code><a href="#topic+estimatePopsize">estimatePopsize()</a></code>
</p>

<hr>
<h2 id='redoPopEstimation'>Updating population size estimation results.</h2><span id='topic+redoPopEstimation'></span><span id='topic+redoPopEstimation.singleRStaticCountData'></span>

<h3>Description</h3>

<p>A function that applies all post-hoc procedures that were taken
(such as heteroscedastic consistent covariance matrix estimation or bias
reduction) to population size estimation and standard error estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redoPopEstimation(object, newdata, ...)

## S3 method for class 'singleRStaticCountData'
redoPopEstimation(
  object,
  newdata,
  cov,
  weights,
  coef,
  control,
  popVar,
  offset,
  weightsAsCounts,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redoPopEstimation_+3A_object">object</code></td>
<td>
<p>object for which update of population size estimation results will be done.</p>
</td></tr>
<tr><td><code id="redoPopEstimation_+3A_newdata">newdata</code></td>
<td>
<p>optional <code>data.frame</code> with new data for pop size estimation.</p>
</td></tr>
<tr><td><code id="redoPopEstimation_+3A_...">...</code></td>
<td>
<p>additional optional arguments, currently not used in <code>singleRStaticCountData</code> class method.</p>
</td></tr>
<tr><td><code id="redoPopEstimation_+3A_cov">cov</code></td>
<td>
<p>an updated covariance matrix estimate.</p>
</td></tr>
<tr><td><code id="redoPopEstimation_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights to use in population size estimation.</p>
</td></tr>
<tr><td><code id="redoPopEstimation_+3A_coef">coef</code></td>
<td>
<p>optional vector of coefficients of regression on which to base
population size estimation. If missing it is set to <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="redoPopEstimation_+3A_control">control</code></td>
<td>
<p>similar to <code>controlPopVar</code> in <code><a href="#topic+estimatePopsize">estimatePopsize()</a></code>.
If missing set to controls provided on call to <code>object</code>.</p>
</td></tr>
<tr><td><code id="redoPopEstimation_+3A_popvar">popVar</code></td>
<td>
<p>similar to <code>popVar</code> in <code><a href="#topic+estimatePopsize">estimatePopsize()</a></code>.
If missing set to <code>"analytic"</code>.</p>
</td></tr>
<tr><td><code id="redoPopEstimation_+3A_offset">offset</code></td>
<td>
<p>offset argument for new data</p>
</td></tr>
<tr><td><code id="redoPopEstimation_+3A_weightsascounts">weightsAsCounts</code></td>
<td>
<p>for <code>singleRStaticCountData</code> method used to specify
whether weights should be treated as number of occurences for rows in data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>popSizeEstResults</code> containing updated
population size estimation results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create simple model
Model &lt;- estimatePopsize(
  formula = capture ~ nation + gender, 
  data = netherlandsimmigrant, 
  model = ztpoisson, 
  method = "IRLS"
)
# Apply heteroscedasticity consistent covariance matrix estimation
require(sandwich)
cov &lt;- vcovHC(Model, type = "HC3")
summary(Model, cov = cov,
popSizeEst = redoPopEstimation(Model, cov = cov))
# Compare to results with usual covariance matrix estimation
summary(Model)

## get confidence interval with larger significance level
redoPopEstimation(Model, control = controlPopVar(alpha = .000001))
</code></pre>

<hr>
<h2 id='simulate'>Generating data in singleRcapture</h2><span id='topic+simulate'></span><span id='topic+simulate.singleRStaticCountData'></span><span id='topic+simulate.singleRfamily'></span>

<h3>Description</h3>

<p>An S3 method for <code>stats::simulate</code> to handle <code>singleRStaticCountData</code> and
<code>singleRfamily</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'singleRStaticCountData'
simulate(object, nsim = 1, seed = NULL, ...)

## S3 method for class 'singleRfamily'
simulate(object, nsim, seed = NULL, eta, truncated = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>an object representing a fitted model.</p>
</td></tr>
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>
<p>a numeric scalar specifying:
</p>

<ul>
<li><p> number of response vectors to simulate in <code>simulate.singleRStaticCountData</code>, defaults to <code>1L</code>.
</p>
</li>
<li><p> number of units to draw in <code>simulate.singleRfamily</code>, defaults to <code>NROW(eta)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be initialized (‘seeded’).</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>additional optional arguments.</p>
</td></tr>
<tr><td><code id="simulate_+3A_eta">eta</code></td>
<td>
<p>a matrix of linear predictors</p>
</td></tr>
<tr><td><code id="simulate_+3A_truncated">truncated</code></td>
<td>
<p>logical value indicating whether to sample from truncated or
full distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with <code>n</code> rows and <code>nsim</code> columns.
</p>


<h3>Author(s)</h3>

<p>Maciej Beręsewicz, Piotr Chlebicki
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+simulate">stats::simulate()</a></code> <code><a href="#topic+estimatePopsize">estimatePopsize()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 10000
###gender &lt;- rbinom(N, 1, 0.2)
gender &lt;- rep(0:1, c(8042, 1958))
eta &lt;- -1 + 0.5*gender
counts &lt;- simulate(ztpoisson(), eta = cbind(eta), seed = 1)
df &lt;- data.frame(gender, eta, counts)
df2 &lt;- subset(df, counts &gt; 0)
### check coverage with summary
mod1 &lt;-  estimatePopsize(
  formula       = counts ~ 1 + gender, 
  data          = df2, 
  model         = ztpoisson, 
  controlMethod = list(silent = TRUE)
)
mod1_sims &lt;- simulate(mod1, nsim=10, seed = 1)
colMeans(mod1_sims)
mean(df2$counts)
</code></pre>

<hr>
<h2 id='stratifyPopsize'>Estimate size of sub populations.</h2><span id='topic+stratifyPopsize'></span><span id='topic+stratifyPopsize.singleRStaticCountData'></span>

<h3>Description</h3>

<p>A function that estimates sizes of specific sub populations
based on a capture-recapture model for the whole population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratifyPopsize(object, stratas, alpha, ...)

## S3 method for class 'singleRStaticCountData'
stratifyPopsize(object, stratas, alpha, cov = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratifyPopsize_+3A_object">object</code></td>
<td>
<p>an object on which the population size estimates should be based
in <code>singleRcapture</code> package this is a fitter <code>singleRStaticCountData</code> class object.</p>
</td></tr>
<tr><td><code id="stratifyPopsize_+3A_stratas">stratas</code></td>
<td>
<p>a specification of sub populations either by:
</p>

<ul>
<li><p> formula &ndash; a formula to be applied to <code>model.frame</code> extracted from
the object .
</p>
</li>
<li><p> Logical vector with number of entries equal to number of rows in the dataset.
</p>
</li>
<li><p> A (named) list where each element is a logical vector, names of the list
will be used to specify names variable in returned object.
</p>
</li>
<li><p> Vector of names of explanatory variables. For <code>singleRStaticCountData</code> method
for this function this specification of <code>stratas</code> parameter will
result in every level of explanatory variable having its own sub population
for each variable specified.
</p>
</li>
<li><p> If no value was provided the <code>singleRStaticCountData</code> method for this function
will itself create sub populations based on levels of factor variables
in <code>model.frame</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stratifyPopsize_+3A_alpha">alpha</code></td>
<td>
<p>significance level for confidence intervals &ndash;
Either a single numeric value or a vector of length equal to number of
sub populations specified in <code>stratas</code>.
If missing it is set to <code>.05</code> in <code>singleRStaticCountData</code> method.</p>
</td></tr>
<tr><td><code id="stratifyPopsize_+3A_...">...</code></td>
<td>
<p>a vector of arguments to be passed to other functions.
For <code>singleRStaticCountData</code> method for this functions arguments in <code>...</code> are
passed to either <code>cov</code> if argument provided was a function or
<code>vcov</code> if <code>cov</code> argument was missing at call.
</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></td></tr>
<tr><td><code id="stratifyPopsize_+3A_cov">cov</code></td>
<td>
<p>for <code>singleRStaticCountData</code> method an estimate of variance-covariance matrix
for estimate of regression parameters. It is possible to pass a function
such as for example <code>sandwich::vcovHC</code> which will be called as:
<code>foo(object, ...)</code> and a user may specify additional arguments of a
function in <code>...</code> argument. If not provided an estimate for covariance
matrix will be set by calling appropriate <code>vcov</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In single source capture-recapture models the most frequently used
estimate for population size is Horvitz-Thompson type estimate:
</p>
\[\hat{N} = \sum_{k=1}^{N}\frac{I_{k}}{\mathbb{P}(Y_{k}>0)} = 
\sum_{k=1}^{N_{obs}}\frac{1}{1-\mathbb{P}(Y_{k}=0)}\]
<p>where \(I_{k}=I_{Y_{k} > 0}\) are
indicator variables, with value 1 if kth unit was observed at least once
and 0 otherwise and the inverse probabilistic weights weights for
units observed in the data \(\tfrac{1}{\mathbb{P}(Y_{k}>0)}\)
are estimated using fitted linear predictors.
</p>
<p>The estimates for different sub populations are made by changing the
\(I_{k}=I_{Y_{k} > 0}\) indicator variables to
refer not to the population as a whole but to the sub populations that are
being considered i.e. by changing values from 1 to 0 if kth unit is not a
member of sub population that is being considered at the moment.
</p>
<p>The estimation of variance for these estimates and estimation of variance for
estimate of population size for the whole population follow the same relation
as the one described above.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> object with row names being the names of specified
sub populations either provided or inferred.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcov.singleRStaticCountData">vcov.singleRStaticCountData()</a></code> <code><a href="#topic+estimatePopsize">estimatePopsize()</a></code>
</p>

<hr>
<h2 id='summary.singleRmargin'>Statistical tests of goodness of fit.</h2><span id='topic+summary.singleRmargin'></span>

<h3>Description</h3>

<p>Performs two statistical test on observed and fitted
marginal frequencies. For G test the test statistic is computed as:
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
\[G = 2\sum_{k}O_{k}\ln{\left(\frac{O_{k}}{E_{k}}\right)}\]
and for \(\chi^{2}\) the test statistic is computed as:
\[\chi^{2} = \sum_{k}\frac{\left(O_{k}-E_{k}\right)^{2}}{E_{k}}\]
where \(O_{k},E_{k}\) denoted observed and fitted
frequencies respectively. Both of these statistics converge to
\(\chi^2\) distribution asymptotically with the same
degrees of freedom.
</p>
<p>The convergence of \(G, \chi^2\) statistics to
\(\chi^2\) distribution may be violated if expected counts
in cells are too low, say &lt; 5, so it is customary to either censor or
omit these cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'singleRmargin'
summary(object, df, dropl5 = c("drop", "group", "no"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.singleRmargin_+3A_object">object</code></td>
<td>
<p>object of singleRmargin class.</p>
</td></tr>
<tr><td><code id="summary.singleRmargin_+3A_df">df</code></td>
<td>
<p>degrees of freedom if not provided the function will try and manually
but it is not always possible.</p>
</td></tr>
<tr><td><code id="summary.singleRmargin_+3A_dropl5">dropl5</code></td>
<td>
<p>a character indicating treatment of cells with frequencies &lt; 5
either grouping them, dropping or leaving them as is. Defaults to drop.</p>
</td></tr>
<tr><td><code id="summary.singleRmargin_+3A_...">...</code></td>
<td>
<p>currently does nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A chi squared test and G test for comparison between fitted and
observed marginal frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a simple model
Model &lt;- estimatePopsize(
  formula = capture ~ ., 
  data = netherlandsimmigrant, 
  model = ztpoisson, 
  method = "IRLS"
)
plot(Model, "rootogram")
# We see a considerable lack of fit
summary(marginalFreq(Model), df = 1, dropl5 = "group")
</code></pre>

<hr>
<h2 id='summary.singleRStaticCountData'>Summary statistics for model of singleRStaticCountData class.</h2><span id='topic+summary.singleRStaticCountData'></span>

<h3>Description</h3>

<p>A <code>summary</code> method for <code>singleRStaticCountData</code> class, works
analogically to <code>summary.glm</code> but includes population size estimation
results. If any additional statistics, such as confidence intervals for
coefficients or coefficient correlation, are specified they will be printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'singleRStaticCountData'
summary(
  object,
  test = c("t", "z"),
  resType = "pearson",
  correlation = FALSE,
  confint = FALSE,
  cov,
  popSizeEst,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.singleRStaticCountData_+3A_object">object</code></td>
<td>
<p>object of singleRStaticCountData class.</p>
</td></tr>
<tr><td><code id="summary.singleRStaticCountData_+3A_test">test</code></td>
<td>
<p>type of test for significance of parameters <code>"t"</code> for t-test
and <code>"z"</code> for normal approximation of students t distribution, by
default <code>"z"</code> is used if there are more than 30 degrees of freedom
and <code>"t"</code> is used in other cases.</p>
</td></tr>
<tr><td><code id="summary.singleRStaticCountData_+3A_restype">resType</code></td>
<td>
<p>type of residuals to summarize any value that is allowed in
<code>residuals.singleRStaticCountData</code> except for <code>"all"</code> is allowed. By default
pearson residuals are used.</p>
</td></tr>
<tr><td><code id="summary.singleRStaticCountData_+3A_correlation">correlation</code></td>
<td>
<p>logical value indicating whether correlation matrix should
be computed from covariance matrix by default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.singleRStaticCountData_+3A_confint">confint</code></td>
<td>
<p>logical value indicating whether confidence intervals for
regression parameters should be constructed. By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.singleRStaticCountData_+3A_cov">cov</code></td>
<td>
<p>covariance matrix corresponding to regression parameters.
It is possible to give <code>cov</code> argument as a function of <code>object</code>.
If not specified it will be constructed using <code>vcov.singleRStaticCountData</code> method.
(i.e using Cramer-Rao lower bound)</p>
</td></tr>
<tr><td><code id="summary.singleRStaticCountData_+3A_popsizeest">popSizeEst</code></td>
<td>
<p>a <code>popSizeEstResults</code> class object.
If not specified population size estimation results will be drawn from
<code>object</code>. If any post-hoc procedures, such as sandwich covariance matrix
estimation or bias reduction, were taken it is possible to include them in
population size estimation results by calling <code>redoPopEstimation</code>.</p>
</td></tr>
<tr><td><code id="summary.singleRStaticCountData_+3A_...">...</code></td>
<td>
<p>additional optional arguments passed to the following functions:
</p>

<ul>
<li> <p><code>vcov.singleRStaticCountData</code> &ndash; if no <code>cov</code> argument was provided.
</p>
</li>
<li> <p><code>cov</code> &ndash; if <code>cov</code> parameter specified at call was a function.
</p>
</li>
<li> <p><code>confint.singleRStaticCountData</code> &ndash; if <code>confint</code> parameter was set to <code>TRUE</code> at function call.
In particular it is possible to set confidence level in <code>...</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code>summarysingleRStaticCountData</code> class containing:
</p>

<ul>
<li> <p><code>call</code> &ndash; A call which created <code>object</code>.
</p>
</li>
<li> <p><code>coefficients</code> &ndash; A dataframe with estimated regression coefficients
and their summary statistics such as standard error Wald test statistic and
p value for Wald test.
</p>
</li>
<li> <p><code>residuals</code> &ndash; A vector of residuals of type specified at call.
</p>
</li>
<li> <p><code>aic</code> &ndash; Akaike's information criterion.
</p>
</li>
<li> <p><code>bic</code> &ndash; Bayesian (Schwarz's) information criterion.
</p>
</li>
<li> <p><code>iter</code> &ndash; Number of iterations taken in fitting regression.
</p>
</li>
<li> <p><code>logL</code> &ndash; Logarithm of likelihood function evaluated at coefficients.
</p>
</li>
<li> <p><code>deviance</code> &ndash; Residual deviance.
</p>
</li>
<li> <p><code>populationSize</code> &ndash; Object with population size estimation results.
</p>
</li>
<li> <p><code>dfResidual</code> &ndash; Residual degrees of freedom.
</p>
</li>
<li> <p><code>sizeObserved</code> &ndash; Size of observed population.
</p>
</li>
<li> <p><code>correlation</code> &ndash; Correlation matrix if <code>correlation</code> parameter was set to <code>TRUE</code>
</p>
</li>
<li> <p><code>test</code> &ndash; Type of statistical test performed.
</p>
</li>
<li> <p><code>model</code> &ndash; Family class object specified in call for <code>object</code>.
</p>
</li>
<li> <p><code>skew</code> &ndash; If bootstrap sample was saved contains estimate of skewness.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+redoPopEstimation">redoPopEstimation()</a></code> <code><a href="stats.html#topic+summary.glm">stats::summary.glm()</a></code>
</p>

<hr>
<h2 id='vcov.singleRStaticCountData'>Obtain Covariance Matrix estimation.</h2><span id='topic+vcov.singleRStaticCountData'></span>

<h3>Description</h3>

<p>A <code>vcov</code> method for <code>singleRStaticCountData</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'singleRStaticCountData'
vcov(object, type = c("Fisher", "observedInform"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.singleRStaticCountData_+3A_object">object</code></td>
<td>
<p>object of singleRStaticCountData class.</p>
</td></tr>
<tr><td><code id="vcov.singleRStaticCountData_+3A_type">type</code></td>
<td>
<p>type of estimate for covariance matrix for now either
expected (Fisher) information matrix or observed information matrix.</p>
</td></tr>
<tr><td><code id="vcov.singleRStaticCountData_+3A_...">...</code></td>
<td>
<p>additional arguments for method functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a estimated covariance matrix for model coefficients
calculated from analytic hessian or Fisher information matrix usually
utilizing asymptotic effectiveness of maximum likelihood estimates.
Covariance type is taken from control parameter that have been provided
on call that created <code>object</code> if arguments <code>type</code> was not specified.
</p>


<h3>Value</h3>

<p>A covariance matrix for fitted coefficients, rows and columns of which
correspond to parameters returned by <code>coef</code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovHC.singleRStaticCountData">vcovHC.singleRStaticCountData()</a></code> <code><a href="sandwich.html#topic+sandwich">sandwich::sandwich()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
