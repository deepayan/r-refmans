<!DOCTYPE html><html><head><title>Help for package ggraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggraph-package'><p>ggraph: An Implementation of Grammar of Graphics for Graphs and Networks</p></a></li>
<li><a href='#autograph'><p>Quickplot wrapper for networks</p></a></li>
<li><a href='#facet_edges'><p>Create small multiples based on edge attributes</p></a></li>
<li><a href='#facet_graph'><p>Create a grid of small multiples by node and/or edge attributes</p></a></li>
<li><a href='#facet_nodes'><p>Create small multiples based on node attributes</p></a></li>
<li><a href='#flare'><p>The class hierarchy of the flare visualization library</p></a></li>
<li><a href='#geom_axis_hive'><p>Draw rectangular bars and labels on hive axes</p></a></li>
<li><a href='#geom_conn_bundle'><p>Create hierarchical edge bundles between node connections</p></a></li>
<li><a href='#geom_edge_arc'><p>Draw edges as Arcs</p></a></li>
<li><a href='#geom_edge_bend'><p>Draw edges as diagonals</p></a></li>
<li><a href='#geom_edge_bundle_force'><p>Bundle edges using force directed edge bundling</p></a></li>
<li><a href='#geom_edge_bundle_minimal'><p>Bundle edges along the minimal spanning tree</p></a></li>
<li><a href='#geom_edge_bundle_path'><p>Bundle edges using edge path bundling</p></a></li>
<li><a href='#geom_edge_density'><p>Show edges as a density map</p></a></li>
<li><a href='#geom_edge_diagonal'><p>Draw edges as diagonals</p></a></li>
<li><a href='#geom_edge_elbow'><p>Draw edges as elbows</p></a></li>
<li><a href='#geom_edge_fan'><p>Draw edges as curves of different curvature</p></a></li>
<li><a href='#geom_edge_hive'><p>Draw edges in hive plots</p></a></li>
<li><a href='#geom_edge_link'><p>Draw edges as straight lines between nodes</p></a></li>
<li><a href='#geom_edge_loop'><p>Draw edges as diagonals</p></a></li>
<li><a href='#geom_edge_parallel'><p>Draw multi edges as parallel lines</p></a></li>
<li><a href='#geom_edge_point'><p>Draw edges as glyphs</p></a></li>
<li><a href='#geom_edge_sf'><p>Draw edges as LINESTRINGs in geographical space</p></a></li>
<li><a href='#geom_edge_span'><p>Draw edges as vertical spans</p></a></li>
<li><a href='#geom_edge_tile'><p>Draw edges as glyphs</p></a></li>
<li><a href='#geom_node_arc_bar'><p>Show nodes as thick arcs</p></a></li>
<li><a href='#geom_node_circle'><p>Show nodes as circles</p></a></li>
<li><a href='#geom_node_point'><p>Show nodes as points</p></a></li>
<li><a href='#geom_node_range'><p>Show nodes as a line spanning a horizontal range</p></a></li>
<li><a href='#geom_node_sf'><p>Show nodes as POINTs in geographical space</p></a></li>
<li><a href='#geom_node_text'><p>Annotate nodes with text</p></a></li>
<li><a href='#geom_node_tile'><p>Draw the rectangles in a treemap</p></a></li>
<li><a href='#geom_node_voronoi'><p>Show nodes as voronoi tiles</p></a></li>
<li><a href='#geometry'><p>Define simple shapes for line capping</p></a></li>
<li><a href='#get_con'><p>Create a connection extractor function</p></a></li>
<li><a href='#get_edges'><p>Create edge extractor function</p></a></li>
<li><a href='#get_sf_nodes'><p>Create a node extractor function</p></a></li>
<li><a href='#ggraph'><p>Create a ggraph plot</p></a></li>
<li><a href='#guide_edge_colourbar'><p>Colourbar legend for edges</p></a></li>
<li><a href='#guide_edge_coloursteps'><p>Coloursteps legend for edges</p></a></li>
<li><a href='#guide_edge_direction'><p>Edge direction guide</p></a></li>
<li><a href='#highschool'><p>Friendship among high school boys</p></a></li>
<li><a href='#internal_extractors'><p>Internal data extractors</p></a></li>
<li><a href='#layout_tbl_graph_auto'><p>Automatically pick a layout based on graph type</p></a></li>
<li><a href='#layout_tbl_graph_backbone'><p>Place node to emphasize group structure</p></a></li>
<li><a href='#layout_tbl_graph_cactustree'><p>Calculate nodes as fractal circle buds</p></a></li>
<li><a href='#layout_tbl_graph_centrality'><p>Place nodes in circles according to centrality measure</p></a></li>
<li><a href='#layout_tbl_graph_circlepack'><p>Calculate nodes as circles packed within their parent circle</p></a></li>
<li><a href='#layout_tbl_graph_dendrogram'><p>Apply a dendrogram layout to layout_tbl_graph</p></a></li>
<li><a href='#layout_tbl_graph_eigen'><p>Place nodes according to their eigenvalues</p></a></li>
<li><a href='#layout_tbl_graph_fabric'><p>Create a fabric layout</p></a></li>
<li><a href='#layout_tbl_graph_focus'><p>Place nodes in circles based on distance to a specific node</p></a></li>
<li><a href='#layout_tbl_graph_hive'><p>Place nodes in a Hive Plot layout</p></a></li>
<li><a href='#layout_tbl_graph_htree'><p>Layout binary trees in a fractal H formation</p></a></li>
<li><a href='#layout_tbl_graph_igraph'><p>Use igraph layout algorithms for layout_tbl_graph</p></a></li>
<li><a href='#layout_tbl_graph_linear'><p>Place nodes on a line or circle</p></a></li>
<li><a href='#layout_tbl_graph_manual'><p>Manually specify a layout for layout_tbl_graph</p></a></li>
<li><a href='#layout_tbl_graph_matrix'><p>Place nodes on a diagonal</p></a></li>
<li><a href='#layout_tbl_graph_metro'><p>Place nodes according to the standard design of metro maps</p></a></li>
<li><a href='#layout_tbl_graph_partition'><p>Calculate nodes as areas dividing their parent</p></a></li>
<li><a href='#layout_tbl_graph_pmds'><p>Place nodes based on a multidimensional scaling of a set of pivot nodes</p></a></li>
<li><a href='#layout_tbl_graph_sf'><p>Place nodes on their geographical space</p></a></li>
<li><a href='#layout_tbl_graph_stress'><p>Place nodes using stress majorisation</p></a></li>
<li><a href='#layout_tbl_graph_treemap'><p>Calculate nodes as rectangles subdividing that of their parent</p></a></li>
<li><a href='#layout_tbl_graph_unrooted'><p>Create an unrooted layout using equal-angle or equal-daylight</p></a></li>
<li><a href='#layout_to_table'><p>Convert a layout to a table</p></a></li>
<li><a href='#makeContent.cappedpathgrob'><p>Dynamic capping of paths</p></a></li>
<li><a href='#makeContent.textalong'><p>Text angled according to line</p></a></li>
<li><a href='#node_angle'><p>Get the angle of nodes and edges</p></a></li>
<li><a href='#pack_circles'><p>Pack circles together</p></a></li>
<li><a href='#qgraph'><p>Deprecated autograph predecessor</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#scale_edge_alpha'><p>Edge alpha scales</p></a></li>
<li><a href='#scale_edge_colour'><p>Edge colour scales</p></a></li>
<li><a href='#scale_edge_fill'><p>Edge fill scales</p></a></li>
<li><a href='#scale_edge_linetype'><p>Edge linetype scales</p></a></li>
<li><a href='#scale_edge_shape'><p>Edge shape scales</p></a></li>
<li><a href='#scale_edge_size'><p>Edge size scales</p></a></li>
<li><a href='#scale_edge_width'><p>Edge width scales</p></a></li>
<li><a href='#scale_label_size'><p>Edge label size scales</p></a></li>
<li><a href='#scale_type.ggraph_geometry'><p>Define default scale type for geometry</p></a></li>
<li><a href='#StatFilter'><p>ggraph extensions to ggplot2</p></a></li>
<li><a href='#theme_graph'><p>A theme tuned for graph visualizations</p></a></li>
<li><a href='#whigs'><p>Membership network of American Whigs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An Implementation of Grammar of Graphics for Graphs and Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The grammar of graphics as implemented in ggplot2 is a poor fit for
    graph and network visualizations due to its reliance on tabular data input.
    ggraph is an extension of the ggplot2 API tailored to graph visualizations
    and provides the same flexible approach to building up plots layer by layer.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggforce (&ge; 0.3.1), grid, igraph (&ge; 1.0.0), scales,
MASS, ggrepel, utils, stats, viridis, rlang, tidygraph,
graphlayouts (&ge; 1.1.0), withr, cli, vctrs, lifecycle, memoise</td>
</tr>
<tr>
<td>Suggests:</td>
<td>network, knitr, rmarkdown, purrr, tibble, seriation, deldir,
gganimate, covr, sf, sfnetworks</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), ggplot2 (&ge; 3.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ggraph.data-imaginist.com">https://ggraph.data-imaginist.com</a>,
<a href="https://github.com/thomasp85/ggraph">https://github.com/thomasp85/ggraph</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/ggraph/issues">https://github.com/thomasp85/ggraph/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-07 08:24:28 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  RStudio [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggraph-package'>ggraph: An Implementation of Grammar of Graphics for Graphs and Networks</h2><span id='topic+ggraph-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>The grammar of graphics as implemented in ggplot2 is a poor fit for graph and network visualizations due to its reliance on tabular data input. ggraph is an extension of the ggplot2 API tailored to graph visualizations and provides the same flexible approach to building up plots layer by layer.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> RStudio [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ggraph.data-imaginist.com">https://ggraph.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/ggraph">https://github.com/thomasp85/ggraph</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/ggraph/issues">https://github.com/thomasp85/ggraph/issues</a>
</p>
</li></ul>


<hr>
<h2 id='autograph'>Quickplot wrapper for networks</h2><span id='topic+autograph'></span><span id='topic+autograph.default'></span>

<h3>Description</h3>

<p>This function is intended to quickly show an overview of your network data.
While it returns a ggraph object that layers etc can be added to it is
limited in use and should not be used as a foundation for more complicated
plots. It allows colour, labeling and sizing of nodes and edges, and the
exact combination of layout and layers will depend on these as well as the
features of the network. The output of this function may be fine-tuned at any
release and should not be considered stable. If a plot should be reproducible
it should be created manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autograph(graph, ...)

## Default S3 method:
autograph(
  graph,
  ...,
  node_colour = NULL,
  edge_colour = NULL,
  node_size = NULL,
  edge_width = NULL,
  node_label = NULL,
  edge_label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autograph_+3A_graph">graph</code></td>
<td>
<p>An object coercible to a tbl_graph</p>
</td></tr>
<tr><td><code id="autograph_+3A_...">...</code></td>
<td>
<p>arguments passed on to methods</p>
</td></tr>
<tr><td><code id="autograph_+3A_node_colour">node_colour</code>, <code id="autograph_+3A_edge_colour">edge_colour</code></td>
<td>
<p>Colour mapping for nodes and edges</p>
</td></tr>
<tr><td><code id="autograph_+3A_node_size">node_size</code>, <code id="autograph_+3A_edge_width">edge_width</code></td>
<td>
<p>Size/width mapping for nodes and edges</p>
</td></tr>
<tr><td><code id="autograph_+3A_node_label">node_label</code>, <code id="autograph_+3A_edge_label">edge_label</code></td>
<td>
<p>Label mapping for nodes and edges</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidygraph)
gr &lt;- create_notable('herschel') %&gt;%
  mutate(class = sample(letters[1:3], n(), TRUE)) %E&gt;%
  mutate(weight = runif(n()))

# Standard graph
autograph(gr)

# Adding node labels will cap edges
autograph(gr, node_label = class)

# Use tidygraph calls for mapping
autograph(gr, node_size = centrality_pagerank())

# Trees are plotted as dendrograms
iris_tree &lt;- hclust(dist(iris[1:4], method = 'euclidean'), method = 'ward.D2')
autograph(iris_tree)

</code></pre>

<hr>
<h2 id='facet_edges'>Create small multiples based on edge attributes</h2><span id='topic+facet_edges'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> but only
facets edges. Nodes are repeated in every panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_edges(
  facets,
  nrow = NULL,
  ncol = NULL,
  scales = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  as.table = TRUE,
  switch = deprecated(),
  drop = TRUE,
  dir = "h",
  strip.position = "top"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_edges_+3A_facets">facets</code></td>
<td>
<p>A set of variables or expressions quoted by <code><a href="ggplot2.html#topic+vars">vars()</a></code>
and defining faceting groups on the rows or columns dimension.
The variables can be named (the names are passed to <code>labeller</code>).
</p>
<p>For compatibility with the classic interface, can also be a
formula or character vector. Use either a one sided formula, <code>~a + b</code>,
or a character vector, <code>c("a", "b")</code>.</p>
</td></tr>
<tr><td><code id="facet_edges_+3A_nrow">nrow</code>, <code id="facet_edges_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns.</p>
</td></tr>
<tr><td><code id="facet_edges_+3A_scales">scales</code></td>
<td>
<p>Should scales be fixed (<code>"fixed"</code>, the default),
free (<code>"free"</code>), or free in one dimension (<code>"free_x"</code>,
<code>"free_y"</code>)?</p>
</td></tr>
<tr><td><code id="facet_edges_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_edges_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with <code>vars(cyl, am)</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="ggplot2.html#topic+labeller">labeller()</a></code>. You can use different labeling
functions for different kind of labels, for example use <code><a href="ggplot2.html#topic+label_parsed">label_parsed()</a></code> for
formatting facet labels. <code><a href="ggplot2.html#topic+label_value">label_value()</a></code> is used by default,
check it for more details and pointers to other options.</p>
</td></tr>
<tr><td><code id="facet_edges_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the default, the facets are laid out like
a table with highest values at the bottom-right. If <code>FALSE</code>, the
facets are laid out like a plot with the highest value at the top-right.</p>
</td></tr>
<tr><td><code id="facet_edges_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top and
right of the plot. If <code>"x"</code>, the top labels will be
displayed to the bottom. If <code>"y"</code>, the right-hand side
labels will be displayed to the left. Can also be set to
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="facet_edges_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
<tr><td><code id="facet_edges_+3A_dir">dir</code></td>
<td>
<p>Direction: either <code>"h"</code> for horizontal, the default, or <code>"v"</code>,
for vertical.</p>
</td></tr>
<tr><td><code id="facet_edges_+3A_strip.position">strip.position</code></td>
<td>
<p>By default, the labels are displayed on the top of
the plot. Using <code>strip.position</code> it is possible to place the labels on
either of the four sides by setting <code>strip.position = c("top",
  "bottom", "left", "right")</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ggraph-facets: 
<code><a href="#topic+facet_graph">facet_graph</a>()</code>,
<code><a href="#topic+facet_nodes">facet_nodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gr &lt;- tidygraph::as_tbl_graph(highschool)

ggraph(gr) +
  geom_edge_link() +
  geom_node_point() +
  facet_edges(~year)
</code></pre>

<hr>
<h2 id='facet_graph'>Create a grid of small multiples by node and/or edge attributes</h2><span id='topic+facet_graph'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code> in that it
allows for building a grid of small multiples where rows and columns
correspond to a specific data value. While <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
could be used it would lead to unexpected results as it is not possible to
specify whether you are referring to a node or an edge attribute. Furthermore
<code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code> will draw edges in panels even though the
panel does not contain both terminal nodes. <code>facet_graph</code> takes care of
all of these issues, allowing you to define which data type the rows and
columns are referencing as well as filtering the edges based on the nodes in
each panel (even when nodes are not drawn).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_graph(
  facets,
  row_type = "edge",
  col_type = "node",
  margins = FALSE,
  scales = "fixed",
  space = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  as.table = TRUE,
  switch = NULL,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_graph_+3A_facets">facets</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>rows</code>
and <code>cols</code> instead.</p>
</td></tr>
<tr><td><code id="facet_graph_+3A_row_type">row_type</code>, <code id="facet_graph_+3A_col_type">col_type</code></td>
<td>
<p>Either <code>'node'</code> or <code>'edge'</code>. Which data
type is being facetted in the rows and columns. Default is to facet on nodes
column wise and on edges row wise.</p>
</td></tr>
<tr><td><code id="facet_graph_+3A_margins">margins</code></td>
<td>
<p>Either a logical value or a character
vector. Margins are additional facets which contain all the data
for each of the possible values of the faceting variables. If
<code>FALSE</code>, no additional facets are included (the
default). If <code>TRUE</code>, margins are included for all faceting
variables. If specified as a character vector, it is the names of
variables for which margins are to be created.</p>
</td></tr>
<tr><td><code id="facet_graph_+3A_scales">scales</code></td>
<td>
<p>Are scales shared across all facets (the default,
<code>"fixed"</code>), or do they vary across rows (<code>"free_x"</code>),
columns (<code>"free_y"</code>), or both rows and columns (<code>"free"</code>)?</p>
</td></tr>
<tr><td><code id="facet_graph_+3A_space">space</code></td>
<td>
<p>If <code>"fixed"</code>, the default, all panels have the same size.
If <code>"free_y"</code> their height will be proportional to the length of the
y scale; if <code>"free_x"</code> their width will be proportional to the
length of the x scale; or if <code>"free"</code> both height and width will
vary.  This setting has no effect unless the appropriate scales also vary.</p>
</td></tr>
<tr><td><code id="facet_graph_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_graph_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with <code>vars(cyl, am)</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="ggplot2.html#topic+labeller">labeller()</a></code>. You can use different labeling
functions for different kind of labels, for example use <code><a href="ggplot2.html#topic+label_parsed">label_parsed()</a></code> for
formatting facet labels. <code><a href="ggplot2.html#topic+label_value">label_value()</a></code> is used by default,
check it for more details and pointers to other options.</p>
</td></tr>
<tr><td><code id="facet_graph_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the default, the facets are laid out like
a table with highest values at the bottom-right. If <code>FALSE</code>, the
facets are laid out like a plot with the highest value at the top-right.</p>
</td></tr>
<tr><td><code id="facet_graph_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top and
right of the plot. If <code>"x"</code>, the top labels will be
displayed to the bottom. If <code>"y"</code>, the right-hand side
labels will be displayed to the left. Can also be set to
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="facet_graph_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ggraph-facets: 
<code><a href="#topic+facet_edges">facet_edges</a>()</code>,
<code><a href="#topic+facet_nodes">facet_nodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidygraph)
gr &lt;- as_tbl_graph(highschool) %&gt;%
  mutate(popularity = as.character(cut(centrality_degree(mode = 'in'),
    breaks = 3,
    labels = c('low', 'medium', 'high')
  )))
ggraph(gr) +
  geom_edge_link() +
  geom_node_point() +
  facet_graph(year ~ popularity)
</code></pre>

<hr>
<h2 id='facet_nodes'>Create small multiples based on node attributes</h2><span id='topic+facet_nodes'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> but only
facets nodes. Edges are drawn if their terminal nodes are both present in a
panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_nodes(
  facets,
  nrow = NULL,
  ncol = NULL,
  scales = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  as.table = TRUE,
  switch = deprecated(),
  drop = TRUE,
  dir = "h",
  strip.position = "top"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_nodes_+3A_facets">facets</code></td>
<td>
<p>A set of variables or expressions quoted by <code><a href="ggplot2.html#topic+vars">vars()</a></code>
and defining faceting groups on the rows or columns dimension.
The variables can be named (the names are passed to <code>labeller</code>).
</p>
<p>For compatibility with the classic interface, can also be a
formula or character vector. Use either a one sided formula, <code>~a + b</code>,
or a character vector, <code>c("a", "b")</code>.</p>
</td></tr>
<tr><td><code id="facet_nodes_+3A_nrow">nrow</code>, <code id="facet_nodes_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns.</p>
</td></tr>
<tr><td><code id="facet_nodes_+3A_scales">scales</code></td>
<td>
<p>Should scales be fixed (<code>"fixed"</code>, the default),
free (<code>"free"</code>), or free in one dimension (<code>"free_x"</code>,
<code>"free_y"</code>)?</p>
</td></tr>
<tr><td><code id="facet_nodes_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_nodes_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with <code>vars(cyl, am)</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="ggplot2.html#topic+labeller">labeller()</a></code>. You can use different labeling
functions for different kind of labels, for example use <code><a href="ggplot2.html#topic+label_parsed">label_parsed()</a></code> for
formatting facet labels. <code><a href="ggplot2.html#topic+label_value">label_value()</a></code> is used by default,
check it for more details and pointers to other options.</p>
</td></tr>
<tr><td><code id="facet_nodes_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the default, the facets are laid out like
a table with highest values at the bottom-right. If <code>FALSE</code>, the
facets are laid out like a plot with the highest value at the top-right.</p>
</td></tr>
<tr><td><code id="facet_nodes_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top and
right of the plot. If <code>"x"</code>, the top labels will be
displayed to the bottom. If <code>"y"</code>, the right-hand side
labels will be displayed to the left. Can also be set to
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="facet_nodes_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
<tr><td><code id="facet_nodes_+3A_dir">dir</code></td>
<td>
<p>Direction: either <code>"h"</code> for horizontal, the default, or <code>"v"</code>,
for vertical.</p>
</td></tr>
<tr><td><code id="facet_nodes_+3A_strip.position">strip.position</code></td>
<td>
<p>By default, the labels are displayed on the top of
the plot. Using <code>strip.position</code> it is possible to place the labels on
either of the four sides by setting <code>strip.position = c("top",
  "bottom", "left", "right")</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ggraph-facets: 
<code><a href="#topic+facet_edges">facet_edges</a>()</code>,
<code><a href="#topic+facet_graph">facet_graph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidygraph)
gr &lt;- as_tbl_graph(highschool) %&gt;%
  mutate(popularity = as.character(cut(centrality_degree(mode = 'in'),
    breaks = 3,
    labels = c('low', 'medium', 'high')
  )))
ggraph(gr) +
  geom_edge_link() +
  geom_node_point() +
  facet_nodes(~popularity)
</code></pre>

<hr>
<h2 id='flare'>The class hierarchy of the flare visualization library</h2><span id='topic+flare'></span>

<h3>Description</h3>

<p>This dataset contains the graph that describes the class hierarchy for the
<a href="https://blokt.com/tool/prefuse-flare">Flare</a> ActionScript visualization library. It
contains both the class hierarchy as well as the import connections between
classes. This dataset has been used extensively in the D3.js documentation
and examples and are included here to make it easy to redo the examples in
ggraph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flare
</code></pre>


<h3>Format</h3>

<p>A list of three data.frames describing the software structure of
flare:
</p>

<dl>
<dt>edges</dt><dd><p>This data.frame maps the hierarchical structure of the class
hierarchy as an edgelist, with the class in <code>from</code> being the superclass
of the class in <code>to</code>.</p>
</dd>
<dt>vertices</dt><dd><p>This data.frame gives additional information on the classes.
It contains the full name, size and short name of each class.</p>
</dd>
<dt>imports</dt><dd><p>This data.frame contains the class imports for each class
implementation. The <code>from</code> column gives the importing class and the
<code>to</code> column gives the import.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data have been adapted from the JSON downloaded from
<a href="https://gist.github.com/mbostock/1044242#file-readme-flare-imports-json">https://gist.github.com/mbostock/1044242#file-readme-flare-imports-json</a>
courtesy of Mike Bostock. The Flare framework is the work of the
<a href="http://vis.berkeley.edu/">UC Berkeley Visualization Lab</a>.
</p>

<hr>
<h2 id='geom_axis_hive'>Draw rectangular bars and labels on hive axes</h2><span id='topic+geom_axis_hive'></span>

<h3>Description</h3>

<p>This function lets you annotate the axes in a hive plot with labels and
color coded bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_axis_hive(
  mapping = NULL,
  data = NULL,
  position = "identity",
  label = TRUE,
  axis = TRUE,
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_axis_hive_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_axis_hive_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_axis_hive_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_axis_hive_+3A_label">label</code></td>
<td>
<p>Should the axes be labelled. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="geom_axis_hive_+3A_axis">axis</code></td>
<td>
<p>Should a rectangle be drawn along the axis. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="geom_axis_hive_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_axis_hive_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_axis_hive understand the following aesthetics.
</p>

<ul>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>size
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>label_size
</p>
</li>
<li><p>family
</p>
</li>
<li><p>fontface
</p>
</li>
<li><p>lineheight
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the flare import graph as a hive plot
library(tidygraph)
flareGr &lt;- as_tbl_graph(flare$imports) %&gt;%
  mutate(
    type = dplyr::case_when(
      centrality_degree(mode = 'in') == 0 ~ 'Source',
      centrality_degree(mode = 'out') == 0 ~ 'Sink',
      TRUE ~ 'Both'
    )
  ) %&gt;%
  activate(edges) %&gt;%
  mutate(
    type = dplyr::case_when(
      grepl('flare.analytics', paste(.N()$name[from], .N()$name[to])) ~ 'Analytics',
      TRUE ~ 'Other'
    )
  )
ggraph(flareGr, 'hive', axis = type) +
  geom_edge_hive(aes(colour = type), edge_alpha = 0.1) +
  geom_axis_hive(aes(colour = type)) +
  coord_fixed()
</code></pre>

<hr>
<h2 id='geom_conn_bundle'>Create hierarchical edge bundles between node connections</h2><span id='topic+geom_conn_bundle'></span><span id='topic+geom_conn_bundle2'></span><span id='topic+geom_conn_bundle0'></span>

<h3>Description</h3>

<p>Hierarchical edge bundling is a technique to introduce some order into the
hairball structure that can appear when there's a lot of overplotting and
edge crossing in a network plot. The concept requires that the network has
an intrinsic hierarchical structure that defines the layout but is not shown.
Connections between points (that is, not edges) are then drawn so that they
loosely follows the underlying hierarchical structure. This results in a
flow-like structure where lines that partly move in the same direction will
be bundled together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_conn_bundle(
  mapping = NULL,
  data = get_con(),
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  show.legend = NA,
  n = 100,
  tension = 0.8,
  ...
)

geom_conn_bundle2(
  mapping = NULL,
  data = get_con(),
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  show.legend = NA,
  n = 100,
  tension = 0.8,
  ...
)

geom_conn_bundle0(
  mapping = NULL,
  data = get_con(),
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  show.legend = NA,
  tension = 0.8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_conn_bundle_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_conn_bundle_+3A_data">data</code></td>
<td>
<p>The result of a call to <code><a href="#topic+get_con">get_con()</a></code></p>
</td></tr>
<tr><td><code id="geom_conn_bundle_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_conn_bundle_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_conn_bundle_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_conn_bundle_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_conn_bundle_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_conn_bundle_+3A_tension">tension</code></td>
<td>
<p>How &quot;loose&quot; should the bundles be. 1 will give very tight
bundles, while 0 will turn of bundling completely and give straight lines.
Defaults to 0.8</p>
</td></tr>
<tr><td><code id="geom_conn_bundle_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_conn_bundle* understands the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li><p><strong>x</strong>
</p>
</li>
<li><p><strong>y</strong>
</p>
</li>
<li><p><strong>group</strong>
</p>
</li>
<li><p><strong>circular</strong>
</p>
</li>
<li><p>edge_colour
</p>
</li>
<li><p>edge_width
</p>
</li>
<li><p>edge_linetype
</p>
</li>
<li><p>edge_alpha
</p>
</li>
<li><p>filter
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Note</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>References</h3>

<p>Holten, D. (2006). <em>Hierarchical edge bundles: visualization
of adjacency relations in hierarchical data.</em> IEEE Transactions on
Visualization and Computer Graphics, <strong>12</strong>(5), 741-748.
<a href="https://doi.org/10.1109/TVCG.2006.147">doi:10.1109/TVCG.2006.147</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a graph of the flare class system
library(tidygraph)
flareGraph &lt;- tbl_graph(flare$vertices, flare$edges) %&gt;%
  mutate(
    class = map_bfs_chr(node_is_root(), .f = function(node, dist, path, ...) {
      if (dist &lt;= 1) {
        return(shortName[node])
      }
      path$result[[nrow(path)]]
    })
  )
importFrom &lt;- match(flare$imports$from, flare$vertices$name)
importTo &lt;- match(flare$imports$to, flare$vertices$name)

# Use class inheritance for layout but plot class imports as bundles
ggraph(flareGraph, 'dendrogram', circular = TRUE) +
  geom_conn_bundle(aes(colour = after_stat(index)),
    data = get_con(importFrom, importTo),
    edge_alpha = 0.25
  ) +
  geom_node_point(aes(filter = leaf, colour = class)) +
  scale_edge_colour_distiller('', direction = 1, guide = 'edge_direction') +
  coord_fixed() +
  ggforce::theme_no_axes()
</code></pre>

<hr>
<h2 id='geom_edge_arc'>Draw edges as Arcs</h2><span id='topic+geom_edge_arc'></span><span id='topic+geom_edge_arc2'></span><span id='topic+geom_edge_arc0'></span>

<h3>Description</h3>

<p>This geom is mainly intended for arc linear and circular diagrams (i.e. used
together with <code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear()</a></code>), though it can be used
elsewhere. It draws edges as arcs with a height proportional to the distance
between the nodes. Arcs are calculated as beziers. For linear layout the
placement of control points are related to the <code>curvature</code> argument and
the distance between the two nodes. For circular layout the control points
are placed on the same angle as the start and end node at a distance related
to the distance between the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_arc(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  n = 100,
  fold = FALSE,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...,
  curvature
)

geom_edge_arc2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  strength = 1,
  n = 100,
  fold = FALSE,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...,
  curvature
)

geom_edge_arc0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  lineend = "butt",
  show.legend = NA,
  fold = fold,
  ...,
  curvature
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_arc_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_strength">strength</code></td>
<td>
<p>The bend of the curve. 1 approximates a halfcircle while 0
will give a straight line. Negative number will change the direction of the
curve. Only used if <code>circular = FALSE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_fold">fold</code></td>
<td>
<p>Logical. Should arcs appear on the same side of the nodes despite
different directions. Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_edge_arc_+3A_curvature">curvature</code></td>
<td>
<p>Deprecated. Use <code>strength</code> instead.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_arc</code> and <code>geom_edge_arc0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li> <p><strong>circular</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_arc2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li> <p><strong>circular</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_arc</code> and <code>geom_edge_arc2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
# Make a graph with different directions of edges
gr &lt;- create_notable('Meredith') %&gt;%
  convert(to_directed) %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE)) %&gt;%
  activate(edges) %&gt;%
  mutate(
    class = sample(letters[1:3], n(), replace = TRUE),
    switch = sample(c(TRUE, FALSE), n(), replace = TRUE)
  ) %&gt;%
  reroute(from = to, to = from, subset = switch)

ggraph(gr, 'linear') +
  geom_edge_arc(aes(alpha = after_stat(index)))

ggraph(gr, 'linear') +
  geom_edge_arc2(aes(colour = node.class), strength = 0.6)

ggraph(gr, 'linear', circular = TRUE) +
  geom_edge_arc0(aes(colour = class))
</code></pre>

<hr>
<h2 id='geom_edge_bend'>Draw edges as diagonals</h2><span id='topic+geom_edge_bend'></span><span id='topic+geom_edge_bend2'></span><span id='topic+geom_edge_bend0'></span>

<h3>Description</h3>

<p>This geom draws edges as cubic bezier curves with the control points
positioned along the elbow edge. It has the appearance of a softened elbow
edge with the hard angle substituted by a tapered bend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_bend(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  flipped = FALSE,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_bend2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  strength = 1,
  flipped = FALSE,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_bend0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  flipped = FALSE,
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_bend_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_strength">strength</code></td>
<td>
<p>The strength of the curvature of the bend. <code>0</code> will
result in a straight line while <code>1</code> will give a strong arc.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_flipped">flipped</code></td>
<td>
<p>Logical, Has the layout been flipped by reassigning the
mapping of x, y etc?</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_bend_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_bend</code> and <code>geom_edge_bend0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li> <p><strong>circular</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_bend2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li> <p><strong>circular</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_bend</code> and <code>geom_edge_bend2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_tree(20, 4) %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE)) %&gt;%
  activate(edges) %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE))

ggraph(gr, 'tree') +
  geom_edge_bend(aes(alpha = after_stat(index)))

ggraph(gr, 'tree') +
  geom_edge_bend2(aes(colour = node.class))

ggraph(gr, 'tree') +
  geom_edge_bend0(aes(colour = class))
</code></pre>

<hr>
<h2 id='geom_edge_bundle_force'>Bundle edges using force directed edge bundling</h2><span id='topic+geom_edge_bundle_force'></span><span id='topic+geom_edge_bundle_force2'></span><span id='topic+geom_edge_bundle_force0'></span>

<h3>Description</h3>

<p>This geom performs force directed edge bundling to reduce visual clutter.
It uses a self-organizing approach to bundling in which edges are modeled as
flexible springs that can attract each other without the need of a hierarchy.
Be aware that this bundling technique works globally and thus may bundle
edges that is otherwise unrelated together. Care should be taken when
interpreting the resulting visual. An alternative approach to edge bundling
that uses the graph topology is provided by <code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_bundle_force(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  n = 100,
  force = 1,
  n_cycle = 6,
  cuts_start = 1,
  step = 0.04,
  cuts_new = 2,
  n_iter = 50,
  iter_new = 2/3,
  threshold = 0.6,
  eps = 1e-08,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_bundle_force2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  n = 100,
  force = 1,
  n_cycle = 6,
  cuts_start = 1,
  step = 0.04,
  cuts_new = 2,
  n_iter = 50,
  iter_new = 2/3,
  threshold = 0.6,
  eps = 1e-08,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_bundle_force0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  force = 1,
  n_cycle = 6,
  cuts_start = 1,
  step = 0.04,
  cuts_new = 2,
  n_iter = 50,
  iter_new = 2/3,
  threshold = 0.6,
  eps = 1e-08,
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_bundle_force_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_force">force</code></td>
<td>
<p>The spring force during bundling</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_n_cycle">n_cycle</code></td>
<td>
<p>number of iteration cycles</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_cuts_start">cuts_start</code></td>
<td>
<p>initial number of edge divisions</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_step">step</code></td>
<td>
<p>initial step size</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_cuts_new">cuts_new</code></td>
<td>
<p>factor for how many new division points to add after a cycle</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_n_iter">n_iter</code></td>
<td>
<p>number of iteration steps per cycle</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_iter_new">iter_new</code></td>
<td>
<p>factor of how to decrease the number of iterations per cycle</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_threshold">threshold</code></td>
<td>
<p>threshold for considering two edges to be interacting</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_eps">eps</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_force_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_bundle_force</code> and <code>geom_edge_bundle_force0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_bundle_force2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_bundle_force</code> and <code>geom_edge_bundle_force2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Holten, D. and Wijk, J.J.V. (2009). <em>Force‐Directed Edge Bundling for Graph
Visualization.</em> Computer Graphics Forum (Blackwell Publishing Ltd) 28, no. 3:
983-990. https://doi.org/10.1111/j.1467-8659.2009.01450.x
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (not necessarily an insightful use)
ggraph(highschool) +
  geom_edge_bundle_force(n_cycle = 2, threshold = 0.4)

</code></pre>

<hr>
<h2 id='geom_edge_bundle_minimal'>Bundle edges along the minimal spanning tree</h2><span id='topic+geom_edge_bundle_minimal'></span><span id='topic+geom_edge_bundle_minimal2'></span><span id='topic+geom_edge_bundle_minimal0'></span>

<h3>Description</h3>

<p>This geom performs edge bundling by letting edges follow the shortest path
along the minimal spanning tree of the graph. Due to it's simplicity it is
very fast but does enforce a tree-like appearance to the bundling. Adjusting
the <code>max_distortion</code> and <code>tension</code> parameters may alleviate this to some
extend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_bundle_minimal(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  n = 100,
  max_distortion = 2,
  weight_fac = 2,
  tension = 1,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_bundle_minimal2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  n = 100,
  max_distortion = 2,
  weight_fac = 2,
  tension = 1,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_bundle_minimal0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  max_distortion = 2,
  weight_fac = 2,
  tension = 1,
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_bundle_minimal_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_max_distortion">max_distortion</code></td>
<td>
<p>A multiplication factor to determine the maximum
allowed distortion of the path during bundling. If the new edge is longer
than <code>max_distortion</code> times the old length it is rejected.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_weight_fac">weight_fac</code></td>
<td>
<p>The exponent used to assign weights to the graph when
calculating the shortest path. The final weights are given as
<code>edge_length ^ weight_fac</code> meaning that sorter edges are prioritised when
calculating the weights.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_tension">tension</code></td>
<td>
<p>A loosening factor when calculating the b-spline of the edge
based on the shortest path. Will move control points closer and closer to
the direct line as it approaches 0</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_minimal_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_force_minimal</code> and <code>geom_edge_force_minimal0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li> <p><strong>edge_id</strong> (should not be overwritten)
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_force_minimal2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li> <p><strong>edge_id</strong> (should not be overwritten)
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_force_minimal</code> and <code>geom_edge_force_minimal2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggraph(highschool) +
  geom_edge_bundle_minimal()

# Allow more edges to bundle
ggraph(highschool) +
  geom_edge_bundle_minimal(max_distortion = 5, tension = 0.9)

</code></pre>

<hr>
<h2 id='geom_edge_bundle_path'>Bundle edges using edge path bundling</h2><span id='topic+geom_edge_bundle_path'></span><span id='topic+geom_edge_bundle_path2'></span><span id='topic+geom_edge_bundle_path0'></span>

<h3>Description</h3>

<p>This geom performs edge bundling using the edge path algorithm. This approach
uses the underlying graph structure to find shortest paths for each edge in
a graph the is gradually removed of it's edges. Since it is based on the
topology of the graph it should lead to less spurious bundling of unrelated
edges compared to <code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force()</a></code> and also has a simpler parameter
space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_bundle_path(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  n = 100,
  directed = NULL,
  max_distortion = 2,
  weight_fac = 2,
  tension = 1,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_bundle_path2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  n = 100,
  directed = NULL,
  max_distortion = 2,
  weight_fac = 2,
  tension = 1,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_bundle_path0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  directed = NULL,
  max_distortion = 2,
  weight_fac = 2,
  tension = 1,
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_bundle_path_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_directed">directed</code></td>
<td>
<p>Logical. Should the shortest paths be calculated using
direction information of the graph. Setting this to <code>TRUE</code> can help split up
bundles that flows in opposite directions. Ignored for undirected graphs</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_max_distortion">max_distortion</code></td>
<td>
<p>A multiplication factor to determine the maximum
allowed distortion of the path during bundling. If the new edge is longer
than <code>max_distortion</code> times the old length it is rejected.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_weight_fac">weight_fac</code></td>
<td>
<p>The exponent used to assign weights to the graph when
calculating the shortest path. The final weights are given as
<code>edge_length ^ weight_fac</code> meaning that sorter edges are prioritised when
calculating the weights.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_tension">tension</code></td>
<td>
<p>A loosening factor when calculating the b-spline of the edge
based on the shortest path. Will move control points closer and closer to
the direct line as it approaches 0</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_bundle_path_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_force_path</code> and <code>geom_edge_force_path0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li> <p><strong>edge_id</strong> (should not be overwritten)
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_force_path2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li> <p><strong>edge_id</strong> (should not be overwritten)
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_force_path</code> and <code>geom_edge_force_path2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen and David Schoch
</p>


<h3>References</h3>

<p>Wallinger, M., Archambault, D., Auber, D., Nöllenburg, M., and Peltonen, J.
(2022). <em>Edge-Path Bundling: A Less Ambiguous Edge Bundling Approach.</em> IEEE
Transactions on Visualization and Computer Graphics 28(1) 313-323.
https://doi.org/10.1109/TVCG.2021.3114795
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggraph(highschool) +
  geom_edge_bundle_path()

# Use tension to lessen the effect
ggraph(highschool) +
  geom_edge_bundle_path(tension = 0.8)

</code></pre>

<hr>
<h2 id='geom_edge_density'>Show edges as a density map</h2><span id='topic+geom_edge_density'></span>

<h3>Description</h3>

<p>This geom makes it possible to add a layer showing edge presence as a density
map. Each edge is converted to <code>n</code> points along the line and a jitter is
applied. Based on this dataset a two-dimensional kernel density estimation is
applied and plotted as a raster image. The density is mapped to the alpha
level, making it possible to map a variable to the fill.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_density(
  mapping = NULL,
  data = get_edges("short"),
  position = "identity",
  show.legend = NA,
  n = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_density_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_density_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_density_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_density_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_density_+3A_n">n</code></td>
<td>
<p>The number of points to estimate in the x and y direction, i.e. the
resolution of the raster.</p>
</td></tr>
<tr><td><code id="geom_edge_density_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_density</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>
<p><strong>x</strong>
<strong>y</strong>
<strong>xend</strong>
<strong>yend</strong>
edge_fill
filter
</p>


<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The coordinates for each pixel in the raster</p>
</dd>
<dt>density</dt><dd><p>The density associated with the pixel</p>
</dd>
</dl>



<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('bull') %&gt;%
  activate(edges) %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE))

ggraph(gr, 'stress') +
  geom_edge_density(aes(fill = class)) +
  geom_edge_link() + geom_node_point()
</code></pre>

<hr>
<h2 id='geom_edge_diagonal'>Draw edges as diagonals</h2><span id='topic+geom_edge_diagonal'></span><span id='topic+geom_edge_diagonal2'></span><span id='topic+geom_edge_diagonal0'></span>

<h3>Description</h3>

<p>This geom draws edges as diagonal bezier curves. The name comes from D3.js
where this shape was called diagonals until it was renamed to
<a href="https://github.com/d3/d3-shape/blob/v1.3.5/README.md#links">links</a>.
A diagonal in this context is a quadratic bezier with the control points
positioned halfway between the start and end points but on the same axis.
This produces a pleasing fan-in, fan-out line that is mostly relevant for
hierarchical layouts as it implies an overall directionality in the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_diagonal(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  flipped = FALSE,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_diagonal2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  strength = 1,
  flipped = FALSE,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_diagonal0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  flipped = FALSE,
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_diagonal_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_strength">strength</code></td>
<td>
<p>The strength of the curvature of the diagonal. <code>0</code> will
result in a straight line while <code>1</code> will give the familiar S-shape.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_flipped">flipped</code></td>
<td>
<p>Logical, Has the layout been flipped by reassigning the
mapping of x, y etc?</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_diagonal_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_diagonal</code> and <code>geom_edge_diagonal0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li> <p><strong>circular</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_diagonal2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li> <p><strong>circular</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_diagonal</code> and <code>geom_edge_diagonal2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_tree(20, 4) %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE)) %&gt;%
  activate(edges) %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE))

ggraph(gr, 'tree') +
  geom_edge_diagonal(aes(alpha = after_stat(index)))

ggraph(gr, 'tree') +
  geom_edge_diagonal2(aes(colour = node.class))

ggraph(gr, 'tree') +
  geom_edge_diagonal0(aes(colour = class))
</code></pre>

<hr>
<h2 id='geom_edge_elbow'>Draw edges as elbows</h2><span id='topic+geom_edge_elbow'></span><span id='topic+geom_edge_elbow2'></span><span id='topic+geom_edge_elbow0'></span>

<h3>Description</h3>

<p>This geom draws edges as an angle in the same manner as known from classic
dendrogram plots of hierarchical clustering results. In case a circular
transformation has been applied the first line segment will be drawn as an
arc as expected. This geom is only applicable to layouts that return a
direction for the edges (currently <code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram()</a></code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition()</a></code> and
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph()</a></code> with the <code>"tree"</code> algorithm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_elbow(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  flipped = FALSE,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_elbow2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  strength = 1,
  flipped = FALSE,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_elbow0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  flipped = FALSE,
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_elbow_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_strength">strength</code></td>
<td>
<p>How bend the elbow should be. 1 will give a right angle,
while <code>0</code> will give a straight line. Ignored for circular layouts</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_flipped">flipped</code></td>
<td>
<p>Logical, Has the layout been flipped by reassigning the
mapping of x, y etc?</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_elbow_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_elbow</code> and <code>geom_edge_elbow0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li> <p><strong>circular</strong>
</p>
</li>
<li> <p><strong>direction</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_elbow2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li> <p><strong>circular</strong>
</p>
</li>
<li> <p><strong>direction</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_elbow</code> and <code>geom_edge_elbow2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
irisDen &lt;- hclust(dist(iris[1:4], method = 'euclidean'), method = 'ward.D2') %&gt;%
  as_tbl_graph() %&gt;%
  mutate(class = sample(letters[1:3], n(), TRUE)) %&gt;%
  activate(edges) %&gt;%
  mutate(class = sample(letters[1:3], n(), TRUE))

ggraph(irisDen, 'dendrogram', circular = TRUE) +
  geom_edge_elbow(aes(alpha = after_stat(index)))

ggraph(irisDen, 'dendrogram') +
  geom_edge_elbow2(aes(colour = node.class))

ggraph(irisDen, 'dendrogram', height = height) +
  geom_edge_elbow0(aes(colour = class))
</code></pre>

<hr>
<h2 id='geom_edge_fan'>Draw edges as curves of different curvature</h2><span id='topic+geom_edge_fan'></span><span id='topic+geom_edge_fan2'></span><span id='topic+geom_edge_fan0'></span>

<h3>Description</h3>

<p>This geom draws edges as cubic beziers with the control point positioned
half-way between the nodes and at an angle dependent on the presence of
parallel edges. This results in parallel edges being drawn in a
non-overlapping fashion resembling the standard approach used in
<code><a href="igraph.html#topic+plot.igraph">igraph::plot.igraph()</a></code>. Before calculating the curvature the edges
are sorted by direction so that edges going the same way will be adjacent.
This geom is currently the only choice for non-simple graphs if edges should
not be overplotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_fan(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...,
  spread
)

geom_edge_fan2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  strength = 1,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...,
  spread
)

geom_edge_fan0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  lineend = "butt",
  show.legend = NA,
  ...,
  spread
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_fan_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_strength">strength</code></td>
<td>
<p>Modify the width of the fans <code>strength &gt; 1</code> will create
wider fans while the reverse will make them more narrow.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_edge_fan_+3A_spread">spread</code></td>
<td>
<p>Deprecated. Use <code>strength</code> instead.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_fan</code> and <code>geom_edge_fan0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li> <p><strong>from</strong>
</p>
</li>
<li> <p><strong>to</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_fan2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li> <p><strong>from</strong>
</p>
</li>
<li> <p><strong>to</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_fan</code> and <code>geom_edge_fan2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('bull') %&gt;%
  convert(to_directed) %&gt;%
  bind_edges(data.frame(from = c(1, 2, 2, 3), to = c(2, 1, 3, 2))) %E&gt;%
  mutate(class = sample(letters[1:3], 9, TRUE)) %N&gt;%
  mutate(class = sample(c('x', 'y'), 5, TRUE))

ggraph(gr, 'stress') +
  geom_edge_fan(aes(alpha = after_stat(index)))

ggraph(gr, 'stress') +
  geom_edge_fan2(aes(colour = node.class))

ggraph(gr, 'stress') +
  geom_edge_fan0(aes(colour = class))
</code></pre>

<hr>
<h2 id='geom_edge_hive'>Draw edges in hive plots</h2><span id='topic+geom_edge_hive'></span><span id='topic+geom_edge_hive2'></span><span id='topic+geom_edge_hive0'></span>

<h3>Description</h3>

<p>This geom is only intended for use together with the hive layout. It draws
edges between nodes as bezier curves, with the control points positioned at
the same radii as the start or end point, and at a distance defined by the
curvature argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_hive(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...,
  curvature
)

geom_edge_hive2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  strength = 1,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...,
  curvature
)

geom_edge_hive0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  strength = 1,
  lineend = "butt",
  show.legend = NA,
  ...,
  curvature
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_hive_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_strength">strength</code></td>
<td>
<p>The curvature of the bezier. Defines the distance from the
control points to the midpoint between the start and end node. 1 means the
control points are positioned halfway between the nodes and the middle of the
two axes, while 0 means it coincide with the nodes (resulting in straight
lines)</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_edge_hive_+3A_curvature">curvature</code></td>
<td>
<p>Deprecated. Use <code>strength</code> instead.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_hive</code> and <code>geom_edge_hive0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_hive2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_hive</code> and <code>geom_edge_hive2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the flare import graph as a hive plot
library(tidygraph)
flareGr &lt;- as_tbl_graph(flare$imports) %&gt;%
  mutate(
    type = dplyr::case_when(
      centrality_degree(mode = 'in') == 0 ~ 'Source',
      centrality_degree(mode = 'out') == 0 ~ 'Sink',
      TRUE ~ 'Both'
    )
  ) %&gt;%
  activate(edges) %&gt;%
  mutate(
    type = dplyr::case_when(
      grepl('flare.analytics', paste(.N()$name[from], .N()$name[to])) ~ 'Analytics',
      TRUE ~ 'Other'
    )
  )

ggraph(flareGr, 'hive', axis = type) +
  geom_edge_hive(aes(colour = type), edge_alpha = 0.1) +
  coord_fixed()
</code></pre>

<hr>
<h2 id='geom_edge_link'>Draw edges as straight lines between nodes</h2><span id='topic+geom_edge_link'></span><span id='topic+geom_edge_link2'></span><span id='topic+geom_edge_link0'></span>

<h3>Description</h3>

<p>This geom draws edges in the simplest way - as straight lines between the
start and end nodes. Not much more to say about that...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_link(
  mapping = NULL,
  data = get_edges("short"),
  position = "identity",
  arrow = NULL,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_link2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_link0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_link_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_link_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Aesthetics</h3>

<p><code>geom_edge_link</code> and <code>geom_edge_link0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_link2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_link</code> and <code>geom_edge_link2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('bull') %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE)) %&gt;%
  activate(edges) %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE))

ggraph(gr, 'stress') +
  geom_edge_link(aes(alpha = after_stat(index)))

ggraph(gr, 'stress') +
  geom_edge_link2(aes(colour = node.class))

ggraph(gr, 'stress') +
  geom_edge_link0(aes(colour = class))
</code></pre>

<hr>
<h2 id='geom_edge_loop'>Draw edges as diagonals</h2><span id='topic+geom_edge_loop'></span><span id='topic+geom_edge_loop0'></span>

<h3>Description</h3>

<p>This geom draws edge loops (edges starting and ending at the same node).
Loops are drawn as bezier curves starting and ending at the position of the
node and with control points protruding at an angle and in a direction
specified in the call. As the start and end node is always the same no *2
method is provided. Loops can severely clutter up your visualization which is
why they are decoupled from the other edge drawings. Only plot them if they
are of importance. If the graph doesn't contain any loops the geom adds
nothing silently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_loop(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_loop0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_loop_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_loop_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_loop</code> and <code>geom_edge_loop0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>from</strong>
</p>
</li>
<li> <p><strong>to</strong>
</p>
</li>
<li> <p><strong>span</strong> <em>90</em>
</p>
</li>
<li> <p><strong>direction</strong> <em>45</em>
</p>
</li>
<li> <p><strong>strength</strong> <em>1</em>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_loop</code> furthermore takes the following aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- as_tbl_graph(
  data.frame(from = c(1, 1, 2, 2, 3, 3, 3), to = c(1, 2, 2, 3, 3, 1, 2))
)

ggraph(gr, 'stress') +
  geom_edge_loop(aes(alpha = after_stat(index))) +
  geom_edge_fan(aes(alpha = after_stat(index)))

ggraph(gr, 'stress') +
  geom_edge_loop0() +
  geom_edge_fan0()
</code></pre>

<hr>
<h2 id='geom_edge_parallel'>Draw multi edges as parallel lines</h2><span id='topic+geom_edge_parallel'></span><span id='topic+geom_edge_parallel2'></span><span id='topic+geom_edge_parallel0'></span>

<h3>Description</h3>

<p>This geom draws multi edges as parallel lines. The edges are first sorted by
direction and then shifted a fixed amount so that all edges are visible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_parallel(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  sep = unit(2, "mm"),
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_parallel2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  arrow = NULL,
  sep = unit(2, "mm"),
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_parallel0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  arrow = NULL,
  sep = unit(2, "mm"),
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_parallel_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_sep">sep</code></td>
<td>
<p>The separation between parallel edges, given as a <code><a href="grid.html#topic+unit">grid::unit()</a></code></p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_parallel_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_parallel</code> and <code>geom_edge_parallel0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li> <p><strong>from</strong>
</p>
</li>
<li> <p><strong>to</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_parallel2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li> <p><strong>from</strong>
</p>
</li>
<li> <p><strong>to</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_parallel</code> and <code>geom_edge_parallel2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>David Schoch and Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('bull') %&gt;%
  convert(to_directed) %&gt;%
  bind_edges(data.frame(from = c(1, 2, 2, 3), to = c(2, 1, 3, 2))) %E&gt;%
  mutate(class = sample(letters[1:3], 9, TRUE)) %N&gt;%
  mutate(class = sample(c('x', 'y'), 5, TRUE))

ggraph(gr, 'stress') +
  geom_edge_parallel(aes(alpha = after_stat(index)))

ggraph(gr, 'stress') +
  geom_edge_parallel2(aes(colour = node.class))

ggraph(gr, 'stress') +
  geom_edge_parallel0(aes(colour = class))

# Use capping and sep to fine tune the look
ggraph(gr, 'stress') +
  geom_edge_parallel(start_cap = circle(1), end_cap = circle(1),
                     arrow = arrow(length = unit(2, 'mm')), sep = unit(4, 'mm')) +
  geom_node_point(size = 12)

</code></pre>

<hr>
<h2 id='geom_edge_point'>Draw edges as glyphs</h2><span id='topic+geom_edge_point'></span>

<h3>Description</h3>

<p>This geom draws edges as glyphs with their x-position defined by the
x-position of the start node, and the y-position defined by the y-position of
the end node. As such it will result in a matrix layout when used in
conjunction with <code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_point(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  mirror = FALSE,
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_point_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_point_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_point_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_point_+3A_mirror">mirror</code></td>
<td>
<p>Logical. Should edge points be duplicated on both sides of the
diagonal. Intended for undirected graphs. Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="geom_edge_point_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_point_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_point</code> understands the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> edge_shape
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_size
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('zachary') %&gt;%
  mutate(group = group_infomap()) %&gt;%
  morph(to_split, group) %&gt;%
  activate(edges) %&gt;%
  mutate(edge_group = as.character(.N()$group[1])) %&gt;%
  unmorph()

ggraph(gr, 'matrix', sort.by = node_rank_hclust()) +
  geom_edge_point(aes(colour = edge_group), mirror = TRUE, edge_size = 3) +
  scale_y_reverse() +
  coord_fixed() +
  labs(edge_colour = 'Infomap Cluster') +
  ggtitle("Zachary' Karate Club")
</code></pre>

<hr>
<h2 id='geom_edge_sf'>Draw edges as LINESTRINGs in geographical space</h2><span id='topic+geom_edge_sf'></span>

<h3>Description</h3>

<p>This geom is equivalent in functionality to <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> for <code>LINESTRING</code>
geometries and allows for plotting of edges in their geographical space in
different colours, linetypes and widths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_sf(
  mapping = NULL,
  data = get_sf_edges(),
  position = "identity",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_sf_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default geometry is mapped to the geometry in
the edge data.</p>
</td></tr>
<tr><td><code id="geom_edge_sf_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_edge_sf_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_sf_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
</p>
<p>You can also set this to one of &quot;polygon&quot;, &quot;line&quot;, and &quot;point&quot; to
override the default legend.</p>
</td></tr>
<tr><td><code id="geom_edge_sf_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_sf</code> understand the following aesthetics.
</p>

<ul>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Lorena Abad
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("sfnetworks", quietly = TRUE)) {
  gr &lt;- sfnetworks::as_sfnetwork(roxel)
  ggraph(gr, 'sf') + geom_edge_sf()
}

</code></pre>

<hr>
<h2 id='geom_edge_span'>Draw edges as vertical spans</h2><span id='topic+geom_edge_span'></span><span id='topic+geom_edge_span2'></span><span id='topic+geom_edge_span0'></span>

<h3>Description</h3>

<p>This edge geom is mainly intended for use with <a href="#topic+layout_tbl_graph_fabric">fabric</a>
layouts. It draws edges as vertical segments with an optional end shape
adornment. Due to the special nature of fabric layouts where nodes are not
a single point in space but a line, this geom doesn't derive the x position
from the location of the terminal nodes, but defaults to using the <code>edge_x</code>
variable calculated by the fabric layout. If this geom is used with other
layouts <code>x</code>and <code>xend</code> must be given explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_span(
  mapping = NULL,
  data = get_edges("short"),
  position = "identity",
  end_shape = NA,
  arrow = NULL,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_span2(
  mapping = NULL,
  data = get_edges("long"),
  position = "identity",
  end_shape = NA,
  arrow = NULL,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  show.legend = NA,
  ...
)

geom_edge_span0(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  end_shape = NA,
  arrow = NULL,
  lineend = "butt",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_span_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_end_shape">end_shape</code></td>
<td>
<p>The adornment to put at the ends of the span. The naming
follows the conventions of the shape aesthetic in <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code></p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_span_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_span</code> and <code>geom_edge_span0</code> understand the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_span2</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_edge_span</code> and <code>geom_edge_span2</code> furthermore takes the following
aesthetics.
</p>

<ul>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>index</dt><dd><p>The position along the path (not computed for the *0 version)</p>
</dd>
</dl>



<h3>Edge variants</h3>

<p>Many geom_edge_* layers comes in 3 flavors depending on the level of control
needed over the drawing. The default (no numeric postfix) generate a number
of points (<code>n</code>) along the edge and draws it as a path. Each point along
the line has a numeric value associated with it giving the position along the
path, and it is therefore possible to show the direction of the edge by
mapping to this e.g. <code>colour = after_stat(index)</code>. The version postfixed with a
&quot;2&quot; uses the &quot;long&quot; edge format (see <code><a href="#topic+get_edges">get_edges()</a></code>) and makes it
possible to interpolate node parameter between the start and end node along
the edge. It is considerable less performant so should only be used if this
is needed. The version postfixed with a &quot;0&quot; draws the edge in the most
performant way, often directly using an appropriate grob from the grid
package, but does not allow for gradients along the edge.
</p>
<p>Often it is beneficial to stop the drawing of the edge before it reaches the
node, for instance in cases where an arrow should be drawn and the arrowhead
shouldn't lay on top or below the node point. geom_edge_* and geom_edge_*2
supports this through the start_cap and end_cap aesthetics that takes a
<code><a href="#topic+geometry">geometry()</a></code> specification and dynamically caps the termini of the
edges based on the given specifications. This means that if
<code>end_cap = circle(1, 'cm')</code> the edges will end at a distance of 1cm even
during resizing of the plot window.
</p>
<p>All <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> and <code>geom_edge_*2</code> have the ability to draw a
label along the edge. The reason this is not a separate geom is that in order
for the label to know the location of the edge it needs to know the edge type
etc. Labels are drawn by providing a label aesthetic. The label_pos can be
used to specify where along the edge it should be drawn by supplying a number
between 0 and 1. The label_size aesthetic can be used to control the size of
the label. Often it is needed to have the label written along the direction
of the edge, but since the actual angle is dependent on the plot dimensions
this cannot be calculated beforehand. Using the angle_calc argument allows
you to specify whether to use the supplied angle aesthetic or whether to draw
the label along or across the edge.
</p>


<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_tile">geom_edge_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- play_smallworld(n_dim = 3, dim_size = 3, order = 1, p_rewire = 0.6)

# Standard use
ggraph(gr, 'fabric', sort.by = node_rank_fabric()) +
  geom_node_range(colour = 'grey80') +
  geom_edge_span()

# Add end shapes
ggraph(gr, 'fabric', sort.by = node_rank_fabric()) +
  geom_node_range(colour = 'grey80') +
  geom_edge_span(end_shape = 'circle')

# If the layout include shadow edges these can be styled differently
ggraph(gr, 'fabric', sort.by = node_rank_fabric(), shadow.edges = TRUE) +
  geom_node_range(colour = 'grey80') +
  geom_edge_span(aes(colour = shadow_edge), end_shape = 'square') +
  scale_edge_colour_manual(values = c('FALSE' = 'black', 'TRUE' = 'grey'))

</code></pre>

<hr>
<h2 id='geom_edge_tile'>Draw edges as glyphs</h2><span id='topic+geom_edge_tile'></span>

<h3>Description</h3>

<p>This geom draws edges as tiles with their x-position defined by the
x-position of the start node, and the y-position defined by the y-position of
the end node. As such it will result in a matrix layout when used in
conjunction with <code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_tile(
  mapping = NULL,
  data = get_edges(),
  position = "identity",
  mirror = FALSE,
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_tile_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, xend, yend, group and
circular are mapped to x, y, xend, yend, edge.id and circular in the edge
data.</p>
</td></tr>
<tr><td><code id="geom_edge_tile_+3A_data">data</code></td>
<td>
<p>The return of a call to <code>get_edges()</code> or a data.frame
giving edges in correct format (see details for for guidance on the format).
See <code><a href="#topic+get_edges">get_edges()</a></code> for more details on edge extraction.</p>
</td></tr>
<tr><td><code id="geom_edge_tile_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_edge_tile_+3A_mirror">mirror</code></td>
<td>
<p>Logical. Should edge points be duplicated on both sides of the
diagonal. Intended for undirected graphs. Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="geom_edge_tile_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_edge_tile_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_edge_tile</code> understands the following
aesthetics. Bold aesthetics are automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> edge_fill
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_size
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Edge aesthetic name expansion</h3>

<p>In order to avoid excessive typing edge aesthetic names are
automatically expanded. Because of this it is not necessary to write
<code>edge_colour</code> within the <code>aes()</code> call as <code>colour</code> will
automatically be renamed appropriately.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_edge_*: 
<code><a href="#topic+geom_edge_arc">geom_edge_arc</a>()</code>,
<code><a href="#topic+geom_edge_bend">geom_edge_bend</a>()</code>,
<code><a href="#topic+geom_edge_bundle_force">geom_edge_bundle_force</a>()</code>,
<code><a href="#topic+geom_edge_bundle_minimal">geom_edge_bundle_minimal</a>()</code>,
<code><a href="#topic+geom_edge_bundle_path">geom_edge_bundle_path</a>()</code>,
<code><a href="#topic+geom_edge_density">geom_edge_density</a>()</code>,
<code><a href="#topic+geom_edge_diagonal">geom_edge_diagonal</a>()</code>,
<code><a href="#topic+geom_edge_elbow">geom_edge_elbow</a>()</code>,
<code><a href="#topic+geom_edge_fan">geom_edge_fan</a>()</code>,
<code><a href="#topic+geom_edge_hive">geom_edge_hive</a>()</code>,
<code><a href="#topic+geom_edge_link">geom_edge_link</a>()</code>,
<code><a href="#topic+geom_edge_loop">geom_edge_loop</a>()</code>,
<code><a href="#topic+geom_edge_parallel">geom_edge_parallel</a>()</code>,
<code><a href="#topic+geom_edge_point">geom_edge_point</a>()</code>,
<code><a href="#topic+geom_edge_sf">geom_edge_sf</a>()</code>,
<code><a href="#topic+geom_edge_span">geom_edge_span</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('zachary') %&gt;%
  mutate(group = group_infomap()) %&gt;%
  morph(to_split, group) %&gt;%
  activate(edges) %&gt;%
  mutate(edge_group = as.character(.N()$group[1])) %&gt;%
  unmorph()

ggraph(gr, 'matrix', sort.by = node_rank_hclust()) +
  geom_edge_tile(aes(fill = edge_group), mirror = TRUE) +
  scale_y_reverse() +
  coord_fixed() +
  labs(edge_colour = 'Infomap Cluster') +
  ggtitle("Zachary' Karate Club")
</code></pre>

<hr>
<h2 id='geom_node_arc_bar'>Show nodes as thick arcs</h2><span id='topic+geom_node_arc_bar'></span>

<h3>Description</h3>

<p>This geom is equivalent in functionality to <code><a href="ggforce.html#topic+geom_arc_bar">ggforce::geom_arc_bar()</a></code>
and allows for plotting of nodes as arcs with an inner and outer radius
scaled by the coordinate system. Its main use is currently in sunburst plots
as created with circular partition layouts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_arc_bar(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_arc_bar_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x and y are mapped to x0 and y0 in
the node data.</p>
</td></tr>
<tr><td><code id="geom_node_arc_bar_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_node_arc_bar_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_node_arc_bar_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_node_arc_bar_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_node_point</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x0</strong>
</p>
</li>
<li> <p><strong>y0</strong>
</p>
</li>
<li> <p><strong>r0</strong>
</p>
</li>
<li> <p><strong>r</strong>
</p>
</li>
<li> <p><strong>start</strong>
</p>
</li>
<li> <p><strong>end</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> shape
</p>
</li>
<li><p> size
</p>
</li>
<li><p> stroke
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_node_*: 
<code><a href="#topic+geom_node_circle">geom_node_circle</a>()</code>,
<code><a href="#topic+geom_node_point">geom_node_point</a>()</code>,
<code><a href="#topic+geom_node_range">geom_node_range</a>()</code>,
<code><a href="#topic+geom_node_sf">geom_node_sf</a>()</code>,
<code><a href="#topic+geom_node_text">geom_node_text</a>()</code>,
<code><a href="#topic+geom_node_tile">geom_node_tile</a>()</code>,
<code><a href="#topic+geom_node_voronoi">geom_node_voronoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- tbl_graph(flare$vertices, flare$edges)
ggraph(gr, 'partition', circular = TRUE, weight = size) +
  geom_node_arc_bar()
</code></pre>

<hr>
<h2 id='geom_node_circle'>Show nodes as circles</h2><span id='topic+geom_node_circle'></span>

<h3>Description</h3>

<p>This geom is equivalent in functionality to <code><a href="ggforce.html#topic+geom_circle">ggforce::geom_circle()</a></code>
and allows for plotting of nodes as circles with a radius scaled by the
coordinate system. Because of the geoms reliance on the coordinate system
it will only produce true circles when combined with
<code><a href="ggplot2.html#topic+coord_fixed">ggplot2::coord_fixed()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_circle(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_circle_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x and y are mapped to x0 and y0 in
the node data.</p>
</td></tr>
<tr><td><code id="geom_node_circle_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_node_circle_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_node_circle_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_node_circle_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_node_circle</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x0</strong>
</p>
</li>
<li> <p><strong>y0</strong>
</p>
</li>
<li> <p><strong>r</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> shape
</p>
</li>
<li><p> size
</p>
</li>
<li><p> stroke
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_node_*: 
<code><a href="#topic+geom_node_arc_bar">geom_node_arc_bar</a>()</code>,
<code><a href="#topic+geom_node_point">geom_node_point</a>()</code>,
<code><a href="#topic+geom_node_range">geom_node_range</a>()</code>,
<code><a href="#topic+geom_node_sf">geom_node_sf</a>()</code>,
<code><a href="#topic+geom_node_text">geom_node_text</a>()</code>,
<code><a href="#topic+geom_node_tile">geom_node_tile</a>()</code>,
<code><a href="#topic+geom_node_voronoi">geom_node_voronoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- tbl_graph(flare$vertices, flare$edges)
ggraph(gr, 'circlepack', weight = size) +
  geom_node_circle() +
  coord_fixed()
</code></pre>

<hr>
<h2 id='geom_node_point'>Show nodes as points</h2><span id='topic+geom_node_point'></span>

<h3>Description</h3>

<p>This geom is equivalent in functionality to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>
and allows for simple plotting of nodes in different shapes, colours and sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_point(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_point_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x and y are mapped to x and y in
the node data.</p>
</td></tr>
<tr><td><code id="geom_node_point_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_node_point_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_node_point_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_node_point_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_node_point</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> shape
</p>
</li>
<li><p> size
</p>
</li>
<li><p> stroke
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_node_*: 
<code><a href="#topic+geom_node_arc_bar">geom_node_arc_bar</a>()</code>,
<code><a href="#topic+geom_node_circle">geom_node_circle</a>()</code>,
<code><a href="#topic+geom_node_range">geom_node_range</a>()</code>,
<code><a href="#topic+geom_node_sf">geom_node_sf</a>()</code>,
<code><a href="#topic+geom_node_text">geom_node_text</a>()</code>,
<code><a href="#topic+geom_node_tile">geom_node_tile</a>()</code>,
<code><a href="#topic+geom_node_voronoi">geom_node_voronoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('bull') %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE))

ggraph(gr, 'stress') + geom_node_point()
</code></pre>

<hr>
<h2 id='geom_node_range'>Show nodes as a line spanning a horizontal range</h2><span id='topic+geom_node_range'></span>

<h3>Description</h3>

<p>This geom is most useful together with the <a href="#topic+layout_tbl_graph_fabric">fabric</a>
layout for showing the horizontal span of each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_range(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_range_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x is mapped to xmin, xend is mapped to xmax
and y and yend are mapped to y in the node data.</p>
</td></tr>
<tr><td><code id="geom_node_range_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_node_range_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_node_range_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_node_range_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_node_point</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> size
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_node_*: 
<code><a href="#topic+geom_node_arc_bar">geom_node_arc_bar</a>()</code>,
<code><a href="#topic+geom_node_circle">geom_node_circle</a>()</code>,
<code><a href="#topic+geom_node_point">geom_node_point</a>()</code>,
<code><a href="#topic+geom_node_sf">geom_node_sf</a>()</code>,
<code><a href="#topic+geom_node_text">geom_node_text</a>()</code>,
<code><a href="#topic+geom_node_tile">geom_node_tile</a>()</code>,
<code><a href="#topic+geom_node_voronoi">geom_node_voronoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- as_tbl_graph(highschool)

ggraph(gr, layout = 'fabric') +
  geom_node_range()
</code></pre>

<hr>
<h2 id='geom_node_sf'>Show nodes as POINTs in geographical space</h2><span id='topic+geom_node_sf'></span>

<h3>Description</h3>

<p>This geom is equivalent in functionality to <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> for <code>POINT</code>
geometries and allows for plotting of nodes in their geographical space in
different shapes, colours and sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_sf(
  mapping = NULL,
  data = get_sf_nodes(),
  position = "identity",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_sf_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default geometry is mapped to the geometry in
the node data.</p>
</td></tr>
<tr><td><code id="geom_node_sf_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_node_sf_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_node_sf_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
</p>
<p>You can also set this to one of &quot;polygon&quot;, &quot;line&quot;, and &quot;point&quot; to
override the default legend.</p>
</td></tr>
<tr><td><code id="geom_node_sf_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_node_sf</code> understand the following aesthetics.
</p>

<ul>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> shape
</p>
</li>
<li><p> size
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Lorena Abad
</p>


<h3>See Also</h3>

<p>Other geom_node_*: 
<code><a href="#topic+geom_node_arc_bar">geom_node_arc_bar</a>()</code>,
<code><a href="#topic+geom_node_circle">geom_node_circle</a>()</code>,
<code><a href="#topic+geom_node_point">geom_node_point</a>()</code>,
<code><a href="#topic+geom_node_range">geom_node_range</a>()</code>,
<code><a href="#topic+geom_node_text">geom_node_text</a>()</code>,
<code><a href="#topic+geom_node_tile">geom_node_tile</a>()</code>,
<code><a href="#topic+geom_node_voronoi">geom_node_voronoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidygraph)

if (require("sfnetworks", quietly = TRUE)) {
  gr &lt;- sfnetworks::as_sfnetwork(roxel)
  ggraph(gr, 'sf') +
    geom_node_sf(aes(color = centrality_betweenness()))
}

</code></pre>

<hr>
<h2 id='geom_node_text'>Annotate nodes with text</h2><span id='topic+geom_node_text'></span><span id='topic+geom_node_label'></span>

<h3>Description</h3>

<p>These geoms are equivalent in functionality to <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code> and
<code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_label()</a></code> and allows for simple annotation of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_text(
  mapping = NULL,
  data = NULL,
  position = "identity",
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  show.legend = NA,
  repel = FALSE,
  ...
)

geom_node_label(
  mapping = NULL,
  data = NULL,
  position = "identity",
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = unit(0.25, "lines"),
  label.r = unit(0.15, "lines"),
  label.size = 0.25,
  show.legend = NA,
  repel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_text_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x and y are mapped to x and y in
the node data.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function. Cannot be jointly specified with
<code>nudge_x</code> or <code>nudge_y</code>.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_nudge_x">nudge_x</code>, <code id="geom_node_text_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_repel">repel</code></td>
<td>
<p>If <code>TRUE</code>, text labels will be repelled from each other
to avoid overlapping, using the <code>GeomTextRepel</code> geom from the
ggrepel package.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="geom_node_text_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_node_text</code> understands the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten. Italic aesthetics are required but
not set by default
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><em>label</em>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> lineheight
</p>
</li>
<li><p> size
</p>
</li>
<li><p> vjust
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_node_*: 
<code><a href="#topic+geom_node_arc_bar">geom_node_arc_bar</a>()</code>,
<code><a href="#topic+geom_node_circle">geom_node_circle</a>()</code>,
<code><a href="#topic+geom_node_point">geom_node_point</a>()</code>,
<code><a href="#topic+geom_node_range">geom_node_range</a>()</code>,
<code><a href="#topic+geom_node_sf">geom_node_sf</a>()</code>,
<code><a href="#topic+geom_node_tile">geom_node_tile</a>()</code>,
<code><a href="#topic+geom_node_voronoi">geom_node_voronoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('bull') %&gt;%
  mutate(class = sample(letters[1:3], n(), replace = TRUE))

ggraph(gr, 'stress') +
  geom_node_point(aes(label = class))

ggraph(gr, 'stress') +
  geom_node_label(aes(label = class), repel = TRUE)
</code></pre>

<hr>
<h2 id='geom_node_tile'>Draw the rectangles in a treemap</h2><span id='topic+geom_node_tile'></span>

<h3>Description</h3>

<p>A treemap is a space filling layout that recursively divides a rectangle to
the children of the node. Often only the leaf nodes are drawn as nodes higher
up in the hierarchy would obscure what is below. <code>geom_treemap</code> is a
shorthand for <code>geom_node_treemap</code> as node is implicit in the case of
treemap drawing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_tile(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_tile_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x, y, width and height are mapped to
x, y, width and height in the node data.</p>
</td></tr>
<tr><td><code id="geom_node_tile_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_node_tile_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_node_tile_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_node_tile_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_treemap</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>width</strong>
</p>
</li>
<li> <p><strong>height</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> size
</p>
</li>
<li><p> stroke
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_node_*: 
<code><a href="#topic+geom_node_arc_bar">geom_node_arc_bar</a>()</code>,
<code><a href="#topic+geom_node_circle">geom_node_circle</a>()</code>,
<code><a href="#topic+geom_node_point">geom_node_point</a>()</code>,
<code><a href="#topic+geom_node_range">geom_node_range</a>()</code>,
<code><a href="#topic+geom_node_sf">geom_node_sf</a>()</code>,
<code><a href="#topic+geom_node_text">geom_node_text</a>()</code>,
<code><a href="#topic+geom_node_voronoi">geom_node_voronoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a graph of the flare class system
library(tidygraph)
flareGraph &lt;- tbl_graph(flare$vertices, flare$edges) %&gt;%
  mutate(
    class = map_bfs_chr(node_is_root(), .f = function(node, dist, path, ...) {
      if (dist &lt;= 1) {
        return(shortName[node])
      }
      path$result[[nrow(path)]]
    })
  )

ggraph(flareGraph, 'treemap', weight = size) +
  geom_node_tile(aes(fill = class, filter = leaf, alpha = depth), colour = NA) +
  geom_node_tile(aes(linewidth = depth), colour = 'white') +
  scale_alpha(range = c(1, 0.5), guide = 'none') +
  scale_size(range = c(4, 0.2), guide = 'none')
</code></pre>

<hr>
<h2 id='geom_node_voronoi'>Show nodes as voronoi tiles</h2><span id='topic+geom_node_voronoi'></span>

<h3>Description</h3>

<p>This geom is equivalent in functionality to <code><a href="ggforce.html#topic+geom_delvor">ggforce::geom_voronoi_tile()</a></code>
and allows for plotting of nodes as tiles from a voronoi tesselation. As with
<code><a href="ggforce.html#topic+geom_delvor">ggforce::geom_voronoi_tile()</a></code> it is possible to restrict the size of the
tile to a fixed radius, as well as round corners and expand/contract the
tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_voronoi(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  bound = NULL,
  eps = 1e-09,
  max.radius = NULL,
  normalize = FALSE,
  asp.ratio = 1,
  expand = 0,
  radius = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_voronoi_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>
or <code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. By default x and y are mapped to x and y in
the node data and group set to <code>-1</code>.</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_bound">bound</code></td>
<td>
<p>The bounding rectangle for the tesselation or a custom polygon
to clip the tesselation to. Defaults to <code>NULL</code> which creates a rectangle
expanded 10\
vector giving the bounds in the following order: xmin, xmax, ymin, ymax. If
supplied as a polygon it should either be a 2-column matrix or a data.frame
containing an <code>x</code> and <code>y</code> column.</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_eps">eps</code></td>
<td>
<p>A value of epsilon used in testing whether a quantity is zero,
mainly in the context of whether points are collinear. If anomalous errors
arise, it is possible that these may averted by adjusting the value of eps
upward or downward.</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_max.radius">max.radius</code></td>
<td>
<p>The maximum distance a tile can extend from the point of
origin. Will in effect clip each tile to a circle centered at the point with
the given radius. If <code>normalize = TRUE</code> the radius will be given relative to
the normalized values</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_normalize">normalize</code></td>
<td>
<p>Should coordinates be normalized prior to calculations. If
<code>x</code> and <code>y</code> are in wildly different ranges it can lead to
tesselation and triangulation that seems off when plotted without
<code><a href="ggplot2.html#topic+coord_fixed">ggplot2::coord_fixed()</a></code>. Normalization of coordinates solves this.
The coordinates are transformed back after calculations.</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_asp.ratio">asp.ratio</code></td>
<td>
<p>If <code>normalize = TRUE</code> the x values will be multiplied by this
amount after normalization.</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_expand">expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_radius">radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td></tr>
<tr><td><code id="geom_node_voronoi_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_node_voronoi</code> understand the following aesthetics. Bold aesthetics are
automatically set, but can be overwritten.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> shape
</p>
</li>
<li><p> size
</p>
</li>
<li><p> stroke
</p>
</li>
<li><p> filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>See Also</h3>

<p>Other geom_node_*: 
<code><a href="#topic+geom_node_arc_bar">geom_node_arc_bar</a>()</code>,
<code><a href="#topic+geom_node_circle">geom_node_circle</a>()</code>,
<code><a href="#topic+geom_node_point">geom_node_point</a>()</code>,
<code><a href="#topic+geom_node_range">geom_node_range</a>()</code>,
<code><a href="#topic+geom_node_sf">geom_node_sf</a>()</code>,
<code><a href="#topic+geom_node_text">geom_node_text</a>()</code>,
<code><a href="#topic+geom_node_tile">geom_node_tile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('meredith') %&gt;%
  mutate(group = sample(letters[1:4], n(), TRUE))

ggraph(gr) +
  geom_node_voronoi(aes(fill = group, colour = group), alpha = 0.3) +
  geom_edge_link(alpha = 0.3) +
  geom_node_point()

# Use max.radius to make the tesselation more "node"-like
ggraph(gr) +
  geom_node_voronoi(aes(fill = group, colour = group), alpha = 0.3, max.radius = 1) +
  geom_edge_link(alpha = 0.3) +
  geom_node_point()
</code></pre>

<hr>
<h2 id='geometry'>Define simple shapes for line capping</h2><span id='topic+geometry'></span><span id='topic+circle'></span><span id='topic+square'></span><span id='topic+ellipsis'></span><span id='topic+rectangle'></span><span id='topic+label_rect'></span><span id='topic+is.geometry'></span>

<h3>Description</h3>

<p>This set of functions makes it easy to define shapes at the terminal points
of edges that are used to shorten the edges. The shapes themselves are not
drawn, but the edges will end at the boundary of the shape rather than at
the node position. This is especially relevant when drawing arrows at the
edges as the arrows will be partly obscured by the node unless the edge is
shortened. Edge shortening is dynamic and will update as the plot is resized,
making sure that the capping remains at an absolute distance to the end
point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometry(
  type = "circle",
  width = 1,
  height = width,
  width_unit = "cm",
  height_unit = width_unit
)

circle(radius = 1, unit = "cm")

square(length = 1, unit = "cm")

ellipsis(a = 1, b = 1, a_unit = "cm", b_unit = a_unit)

rectangle(width = 1, height = 1, width_unit = "cm", height_unit = width_unit)

label_rect(label, padding = margin(1, 1, 1.5, 1, "mm"), ...)

is.geometry(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geometry_+3A_type">type</code></td>
<td>
<p>The type of geometry to use. Currently <code>'circle'</code> and
<code>'rect'</code> is supported.</p>
</td></tr>
<tr><td><code id="geometry_+3A_width">width</code>, <code id="geometry_+3A_height">height</code>, <code id="geometry_+3A_length">length</code>, <code id="geometry_+3A_radius">radius</code>, <code id="geometry_+3A_a">a</code>, <code id="geometry_+3A_b">b</code></td>
<td>
<p>The dimensions of the shape.</p>
</td></tr>
<tr><td><code id="geometry_+3A_unit">unit</code>, <code id="geometry_+3A_width_unit">width_unit</code>, <code id="geometry_+3A_height_unit">height_unit</code>, <code id="geometry_+3A_a_unit">a_unit</code>, <code id="geometry_+3A_b_unit">b_unit</code></td>
<td>
<p>The unit for the numbers
given.</p>
</td></tr>
<tr><td><code id="geometry_+3A_label">label</code></td>
<td>
<p>The text to be enclosed</p>
</td></tr>
<tr><td><code id="geometry_+3A_padding">padding</code></td>
<td>
<p>extra size to be added around the text using the
<code><a href="ggplot2.html#topic+element">ggplot2::margin()</a></code> function</p>
</td></tr>
<tr><td><code id="geometry_+3A_...">...</code></td>
<td>
<p>Passed on to <code><a href="grid.html#topic+gpar">grid::gpar()</a></code></p>
</td></tr>
<tr><td><code id="geometry_+3A_x">x</code></td>
<td>
<p>An object to test for geometry inheritance</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geometry</code> is the base constructor, while the rest are helpers to save
typing. <code>circle</code> creates circles width a given radius, <code>square</code>
creates squares at a given side length, <code>ellipsis</code> creates ellipses with
given a and b values (width and height radii), and <code>rectangle</code> makes
rectangles of a given width and height. label_rect is a helper that, given
a list of strings and potentially formatting options creates a rectangle that
encloses the string.
</p>


<h3>Value</h3>

<p>A geometry object encoding the specified shape.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geometry(c('circle', 'rect', 'rect'), 1:3, 3:1)

circle(1:4, 'mm')

label_rect(c('some', 'different', 'words'), fontsize = 18)
</code></pre>

<hr>
<h2 id='get_con'>Create a connection extractor function</h2><span id='topic+get_con'></span>

<h3>Description</h3>

<p>Connections within the ggraph terminology are links between nodes that are
not part of the network structure itself. In that sense connections do not
affect the layout calculation in any way and will not be drawn by the
standard <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> functions. A connection does not need to only be
defined by a start and end node, but can include intermediary nodes.
<code>get_con</code> helps in creating connection data by letting you specify start
and end nodes and automatically finds the shortest path within the graph
structure that connects the given points. If this is not what is needed it is
also possible to supply a list of vectors giving node indices that define a
connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_con(
  from = integer(),
  to = integer(),
  paths = NULL,
  ...,
  weight = NULL,
  mode = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_con_+3A_from">from</code>, <code id="get_con_+3A_to">to</code></td>
<td>
<p>The index of the start and end nodes for the connections</p>
</td></tr>
<tr><td><code id="get_con_+3A_paths">paths</code></td>
<td>
<p>A list of integer vectors giving the index of nodes defining
connections</p>
</td></tr>
<tr><td><code id="get_con_+3A_...">...</code></td>
<td>
<p>Additional information to be added to the final data output.
Accepts expressions that will be evaluated on the node data in it's
original order (irrespective of any reordering by the layout)</p>
</td></tr>
<tr><td><code id="get_con_+3A_weight">weight</code></td>
<td>
<p>An expression to be evaluated on the edge data to provide
weights for the shortest path calculations</p>
</td></tr>
<tr><td><code id="get_con_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from
the given vertices should be calculated for directed graphs. If <code>out</code>
then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">&#8288;in&#8288;</code> then <em>to</em>
it will be considered. If <code>all</code>, the default, then the corresponding
undirected graph will be used, i.e. not directed paths are searched. This
argument is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes a layout_ggraph object and returns the given
connections
</p>


<h3>See Also</h3>

<p>Other extractors: 
<code><a href="#topic+get_edges">get_edges</a>()</code>,
<code><a href="#topic+get_sf_nodes">get_sf_nodes</a>()</code>
</p>

<hr>
<h2 id='get_edges'>Create edge extractor function</h2><span id='topic+get_edges'></span><span id='topic+get_sf_edges'></span>

<h3>Description</h3>

<p>This function returns another function that can extract edges from a
ggraph_layout object. The functionality of the returned function is decided
by the arguments to <code>get_edges</code>. The need for <code>get_edges</code> is mainly to
pass to the <code>data</code> argument of the different <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code>
functions in order to present them with the right kind of data. In general
each <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> has the default set correctly so there is only need
to modify the data argument if parallel edges should be collapsed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edges(format = "short", collapse = "none", ...)

get_sf_edges()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_edges_+3A_format">format</code></td>
<td>
<p>Either <code>'short'</code> (the default) or <code>'long'</code>. See
details for a descriptions of the differences</p>
</td></tr>
<tr><td><code id="get_edges_+3A_collapse">collapse</code></td>
<td>
<p>Either <code>'none'</code> (the default), <code>'all'</code> or
<code>'direction'</code>. Specifies whether parallel edges should be merged. See
details for more information</p>
</td></tr>
<tr><td><code id="get_edges_+3A_...">...</code></td>
<td>
<p>Additional data that will be cbind'ed together with the returned
edge data. Accepts expressions that will be evaluated on the edge data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two types of return formats possible for the result of the returned
function:
</p>

<dl>
<dt>short</dt><dd><p>In this format each edge is described in one line in the
format expected for <code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code>, that is, the start
node position is encoded in the <code>x</code> and <code>y</code> column and the end
node position is encoded in the <code>xend</code> and <code>yend</code> column. If node
parameters are added to the edge the name of the parameters will be
prefixed with <code>node1.</code> for the start node and <code>node2.</code> for the
end node.</p>
</dd>
<dt>long</dt><dd><p>In this format each edge consists of two rows with matching
<code>edge.id</code> value. The start and end position are both encoded in the
<code>x</code> and <code>y</code> column. The relative position of the rows determines
which is the start and end node, the first occurring being the start node.
If node parameters are added to the edge data the name of the parameters
will be prefixed with <code>node.</code>.</p>
</dd>
</dl>

<p>Node parameters are automatically added so it is possible to format edge
aesthetics according to start or end node parameters, or interpolate edge
aesthetics between start and end node parameters. Node parameters will be
prefixed to avoid name clash with edge parameters. The prefix depends on the
format (see above).
</p>
<p>If the graph is not simple (it contains at most one edge between each node
pair) it can be collapsed so either all edges between two nodes or all edges
of the same direction between two nodes are merged. The edge parameters are
taken from the first occurring edge, so if some more sophisticated summary is
needed it is suggested that the graph be tidied up before plotting with
ggraph.
</p>


<h3>Value</h3>

<p>A data.frame with columns dependent on format as well as the graph
type. In addition to the columns discussed in the details section,
the data.frame will always contain the columns <code>from</code>, <code>to</code> and
<code>circular</code>, the two former giving the indexes of the start and end node
and the latter if the layout is circular (needed for correct formatting of
some <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code>). The graph dependent information is:
</p>

<dl>
<dt>dendrogram</dt><dd><p>A <code>label</code> column will hold the value of the
<code>edgetext</code> attribute. In addition any value stored in the
<code>edgePar</code> attribute will be added. Lastly a <code>direction</code> column
will hold the relative position between the start and end nodes (needed for
correct formatting of <code><a href="#topic+geom_edge_elbow">geom_edge_elbow()</a></code>).</p>
</dd>
<dt>igraph</dt><dd><p>All edge attributes of the original graph object is added as
columns to the data.frame</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other extractors: 
<code><a href="#topic+get_con">get_con</a>()</code>,
<code><a href="#topic+get_sf_nodes">get_sf_nodes</a>()</code>
</p>

<hr>
<h2 id='get_sf_nodes'>Create a node extractor function</h2><span id='topic+get_sf_nodes'></span><span id='topic+get_nodes'></span>

<h3>Description</h3>

<p>This function returns another function that can extract nodes from a
ggraph_layout object. As a ggraph_layout object is essentially a data.frame
of nodes it might seem useless to provide this function, but since the node
data is not necessarily available until after the <code>ggraph()</code> call it
can be beneficial to be able to add information to the node data on a
per-layer basis. Unlike <code><a href="#topic+get_edges">get_edges()</a></code> the use of <code>get_nodes</code> is not
mandatory and is only required if additional data should be added to selected
node layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sf_nodes()

get_nodes(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sf_nodes_+3A_...">...</code></td>
<td>
<p>Additional data that should be cbind'ed together with the node
data. Accepts expressions that will be evaluated on the node data in it's
original order (irrespective of any reordering by the layout)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the node data as well of any additional data
supplied through <code>...</code>
</p>


<h3>See Also</h3>

<p>Other extractors: 
<code><a href="#topic+get_con">get_con</a>()</code>,
<code><a href="#topic+get_edges">get_edges</a>()</code>
</p>

<hr>
<h2 id='ggraph'>Create a ggraph plot</h2><span id='topic+ggraph'></span><span id='topic+create_layout'></span><span id='topic+layout_ggraph'></span><span id='topic+create_layout.default'></span><span id='topic+create_layout.layout_ggraph'></span><span id='topic+create_layout.tbl_graph'></span><span id='topic+layout_tbl_graph'></span>

<h3>Description</h3>

<p>This function is the equivalent of <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> in ggplot2.
It takes care of setting up the plot object along with creating the layout
for the plot based on the graph and the specification passed in.
Alternatively a layout can be prepared in advance using
<code>create_layout</code> and passed as the data argument. See <em>Details</em> for
a description of all available layouts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggraph(graph, layout = "auto", ...)

create_layout(graph, layout, circular, ...)

## Default S3 method:
create_layout(graph, layout, ...)

## S3 method for class 'layout_ggraph'
create_layout(graph, ...)

## S3 method for class 'tbl_graph'
create_layout(graph, layout, circular = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggraph_+3A_graph">graph</code></td>
<td>
<p>The object containing the graph. See <em>Details</em> for a list
of supported classes. Or a <code>layout_ggraph</code> object as returned from
<code>create_layout</code> in which case all subsequent arguments is ignored.</p>
</td></tr>
<tr><td><code id="ggraph_+3A_layout">layout</code></td>
<td>
<p>The type of layout to create. Either a valid string, a
function, a matrix, or a data.frame (see Details)</p>
</td></tr>
<tr><td><code id="ggraph_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the layout function.</p>
</td></tr>
<tr><td><code id="ggraph_+3A_circular">circular</code></td>
<td>
<p>Should the layout be transformed into a radial
representation. Only possible for some layouts. Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following is a short description of the different layout types available in
ggraph. Each layout is further described in its own help pages. Any type of
regular graph/network data can be represented as a tbl_graph object. Because
of this the different layouts that can be applied to tbl_graph
objects are quite diverse, but not all layouts makes sense to all types of
graphs. It is up to the user to understand their data and choose an
appropriate layout. For standard node-edge diagrams igraph defines a
long range of different layout functions that are all available through the
<code>igraph</code> layout where the specific layout is specified using the
<code>algorithm</code> argument. In order to minimize typing all igraph algorithms
can also be passed directly into the <code>layout</code> argument.
</p>
<p>Any object that has an appropriate <code>as_tbl_graph</code> method can be passed
into <code>ggraph()</code> and will automatically be converted underneath.
</p>

<dl>
<dt><code>auto</code></dt><dd><p>The default layout. See <code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto()</a></code> for further
details</p>
</dd>
<dt><code>igraph</code></dt><dd><p>Use one of the internal igraph layout algorithms.
The algorithm is specified using the <code>algorithm</code> argument. All strings
accepted by the <code>algorithm</code> argument can also be supplied directly
into <code>layout</code>. See <code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph()</a></code> for further
details</p>
</dd>
<dt><code>dendrogram</code></dt><dd><p>Lays out the nodes in a tree-like graph as a
dendrogram with leaves set at 0 and parents 1 unit above its tallest child.
See <code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram()</a></code> for further details</p>
</dd>
<dt><code>manual</code></dt><dd><p>Lets the user manually specify the location of each
node. See <code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual()</a></code> for further details</p>
</dd>
<dt><code>linear</code></dt><dd><p>Arranges the nodes linearly or circularly in order to
make an arc diagram. See <code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear()</a></code> for further
details</p>
</dd>
<dt><code>matrix</code></dt><dd><p>Arranges nodes on a diagonal thus preparing it for use with
<code><a href="#topic+geom_edge_point">geom_edge_point()</a></code> to make a matrix plot. See <code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix()</a></code>
for further details</p>
</dd>
<dt><code>treemap</code></dt><dd><p>Creates a treemap from the graph, that is, a
space-filing subdivision of rectangles showing a weighted hierarchy. See
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap()</a></code> for further details</p>
</dd>
<dt><code>circlepack</code></dt><dd><p>Creates a layout showing a hierarchy as circles
within circles. Conceptually equal to treemaps. See
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack()</a></code> for further details</p>
</dd>
<dt><code>partition</code></dt><dd><p>Create icicle or sunburst charts, where each layer
subdivides the division given by the preceding layer. See
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition()</a></code> for further details</p>
</dd>
<dt><code>hive</code></dt><dd><p>Positions nodes on axes spreading out from the center
based on node attributes. See <code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive()</a></code> for further
details</p>
</dd>
<dt><code>cactustree</code></dt><dd><p>Positions nodes as circles on the periphery of their
parent circle. See <code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree()</a></code> for further
details</p>
</dd>
<dt><code>backbone</code></dt><dd><p>Layout optimised for highly connected small-world graphs
such as social networks. See <code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone()</a></code> for further
details</p>
</dd>
<dt><code>centrality</code></dt><dd><p>Place nodes around origin based on their centrality.
See <code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality()</a></code> for further
details</p>
</dd>
<dt><code>eigen</code></dt><dd><p>Spectral layout based on the eigenvector of a matrix
representation of the graph. See <code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen()</a></code> for further
details</p>
</dd>
<dt><code>fabric</code></dt><dd><p>Draw nodes as horizontal lines and connect them with
vertical lines if an edge exists between them. See
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric()</a></code> for further
details</p>
</dd>
<dt><code>focus</code></dt><dd><p>Place nodes around a focus node based on their distance to
that node. See <code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus()</a></code> for further
details</p>
</dd>
<dt><code>pmds</code></dt><dd><p>Layout based on multidimensional scaling of a set of pivot
nodes, allowing MDS layout to be used on larger graphs. See
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds()</a></code> for further
details</p>
</dd>
<dt><code>stress</code></dt><dd><p>Layout based on stress minimisation with better stability
than Kamada-Kawai layout. See <code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress()</a></code> for further
details</p>
</dd>
<dt><code>unrooted</code></dt><dd><p>Draws unrooted trees based on equal angle with optional
equal daylight modification. See <code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted()</a></code> for further
details</p>
</dd>
<dt><code>htree</code></dt><dd><p>Draws binary trees as a space filling fractal. See
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree()</a></code> for further details</p>
</dd>
</dl>

<p>Alternatively a matrix or a data.frame can be provided to the <code>layout</code>
argument. In the former case the first column will be used as x coordinates
and the second column will by used as y coordinates, further columns are
dropped. In the latter case the data.frame is used as the layout table and
must thus contain a numeric x and y column.
</p>
<p>Lastly a function can be provided to the <code>layout</code> argument. It will be called
with the graph object as its first argument and any additional argument
passed into <code>ggraph()</code>/<code>create_layout()</code>. The function must return either a
data.frame or an object coercible to one and have an <code>x</code> and <code>y</code> column, or
an object coercible to a <code>tbl_graph</code>. In the latter case the node data is
extracted and used as layout (and must thus contain an <code>x</code> and <code>y</code> column)
and the graph will be added as the <code>graph</code> attribute.
</p>


<h3>Value</h3>

<p>For <code>ggraph()</code> an object of class gg onto which layers, scales,
etc. can be added. For <code>create_layout()</code> an object inheriting from
<code>layout_ggraph</code>. <code>layout_ggraph</code> itself inherits from
<code>data.frame</code> and can be considered as such. The data.frame contains
the node positions in the <code>x</code> and <code>y</code> column along with
additional columns generated by the specific layout, as well as node
parameters inherited from the graph. Additional information is stored as
attributes to the data.frame. The original graph object is stored in the
<code>graph</code> attribute and the <code>circular</code> attribute contains a logical
indicating whether the layout has been transformed to a circular
representation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_edges">get_edges()</a></code> for extracting edge information from the
layout and <code><a href="#topic+get_con">get_con()</a></code> for extracting path information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
gr &lt;- create_notable('bull')
layout &lt;- create_layout(gr, layout = 'igraph', algorithm = 'kk')
</code></pre>

<hr>
<h2 id='guide_edge_colourbar'>Colourbar legend for edges</h2><span id='topic+guide_edge_colourbar'></span><span id='topic+guide_edge_colorbar'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="ggplot2.html#topic+guide_colourbar">ggplot2::guide_colourbar()</a></code> but
works for edge aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_edge_colourbar(..., available_aes = c("edge_colour", "edge_fill"))

guide_edge_colorbar(..., available_aes = c("edge_colour", "edge_fill"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_edge_colourbar_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+guide_colourbar">ggplot2::guide_colourbar</a></code>
</p>

<dl>
<dt><code>title</code></dt><dd><p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="ggplot2.html#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="ggplot2.html#topic+labs">labs()</a></code> is used for the title.</p>
</dd>
<dt><code>theme</code></dt><dd><p>A <code><a href="ggplot2.html#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</dd>
<dt><code>nbin</code></dt><dd><p>A numeric specifying the number of bins for drawing the
colourbar. A smoother colourbar results from a larger value.</p>
</dd>
<dt><code>display</code></dt><dd><p>A string indicating a method to display the colourbar. Can be
one of the following:
</p>

<ul>
<li> <p><code>"raster"</code> to display as a bitmap image.
</p>
</li>
<li> <p><code>"rectangles"</code> to display as a series of rectangles.
</p>
</li>
<li> <p><code>"gradient"</code> to display as a linear gradient.
</p>
</li></ul>

<p>Note that not all devices are able to render rasters and gradients.</p>
</dd>
<dt><code>raster</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>  A logical. If <code>TRUE</code> then
the colourbar is rendered as a raster object. If <code>FALSE</code> then the colourbar
is rendered as a set of rectangles. Note that not all graphics devices are
capable of rendering raster image.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric between 0 and 1 setting the colour transparency of
the bar. Use <code>NA</code> to preserve the alpha encoded in the colour itself
(default).</p>
</dd>
<dt><code>draw.ulim</code></dt><dd><p>A logical specifying if the upper limit tick marks should
be visible.</p>
</dd>
<dt><code>draw.llim</code></dt><dd><p>A logical specifying if the lower limit tick marks should
be visible.</p>
</dd>
<dt><code>position</code></dt><dd><p>A character string indicating where the legend should be
placed relative to the plot panels.</p>
</dd>
<dt><code>direction</code></dt><dd><p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</dd>
<dt><code>reverse</code></dt><dd><p>logical. If <code>TRUE</code> the colourbar is reversed. By default,
the highest value is on the top and the lowest value is on the bottom</p>
</dd>
<dt><code>order</code></dt><dd><p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="guide_edge_colourbar_+3A_available_aes">available_aes</code></td>
<td>
<p>A vector of character strings listing the aesthetics
for which a colourbar can be drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A guide object
</p>

<hr>
<h2 id='guide_edge_coloursteps'>Coloursteps legend for edges</h2><span id='topic+guide_edge_coloursteps'></span><span id='topic+guide_edge_colorsteps'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="ggplot2.html#topic+guide_coloursteps">ggplot2::guide_coloursteps()</a></code> but
works for edge aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_edge_coloursteps(
  even.steps = TRUE,
  show.limits = NULL,
  ...,
  available_aes = c("edge_colour", "edge_fill")
)

guide_edge_colorsteps(
  even.steps = TRUE,
  show.limits = NULL,
  ...,
  available_aes = c("edge_colour", "edge_fill")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_edge_coloursteps_+3A_even.steps">even.steps</code></td>
<td>
<p>Should the rendered size of the bins be equal, or should
they be proportional to their length in the data space? Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="guide_edge_coloursteps_+3A_show.limits">show.limits</code></td>
<td>
<p>Logical. Should the limits of the scale be shown with
labels and ticks. Default is <code>NULL</code> meaning it will take the value from the
scale. This argument is ignored if <code>labels</code> is given as a vector of
values. If one or both of the limits is also given in <code>breaks</code> it will be
shown irrespective of the value of <code>show.limits</code>.</p>
</td></tr>
<tr><td><code id="guide_edge_coloursteps_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+guide_colourbar">ggplot2::guide_colourbar</a></code>
</p>

<dl>
<dt><code>title</code></dt><dd><p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="ggplot2.html#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="ggplot2.html#topic+labs">labs()</a></code> is used for the title.</p>
</dd>
<dt><code>theme</code></dt><dd><p>A <code><a href="ggplot2.html#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</dd>
<dt><code>nbin</code></dt><dd><p>A numeric specifying the number of bins for drawing the
colourbar. A smoother colourbar results from a larger value.</p>
</dd>
<dt><code>display</code></dt><dd><p>A string indicating a method to display the colourbar. Can be
one of the following:
</p>

<ul>
<li> <p><code>"raster"</code> to display as a bitmap image.
</p>
</li>
<li> <p><code>"rectangles"</code> to display as a series of rectangles.
</p>
</li>
<li> <p><code>"gradient"</code> to display as a linear gradient.
</p>
</li></ul>

<p>Note that not all devices are able to render rasters and gradients.</p>
</dd>
<dt><code>raster</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>  A logical. If <code>TRUE</code> then
the colourbar is rendered as a raster object. If <code>FALSE</code> then the colourbar
is rendered as a set of rectangles. Note that not all graphics devices are
capable of rendering raster image.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric between 0 and 1 setting the colour transparency of
the bar. Use <code>NA</code> to preserve the alpha encoded in the colour itself
(default).</p>
</dd>
<dt><code>draw.ulim</code></dt><dd><p>A logical specifying if the upper limit tick marks should
be visible.</p>
</dd>
<dt><code>draw.llim</code></dt><dd><p>A logical specifying if the lower limit tick marks should
be visible.</p>
</dd>
<dt><code>position</code></dt><dd><p>A character string indicating where the legend should be
placed relative to the plot panels.</p>
</dd>
<dt><code>direction</code></dt><dd><p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</dd>
<dt><code>reverse</code></dt><dd><p>logical. If <code>TRUE</code> the colourbar is reversed. By default,
the highest value is on the top and the lowest value is on the bottom</p>
</dd>
<dt><code>order</code></dt><dd><p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="guide_edge_coloursteps_+3A_available_aes">available_aes</code></td>
<td>
<p>A vector of character strings listing the aesthetics
for which a colourbar can be drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A guide object
</p>

<hr>
<h2 id='guide_edge_direction'>Edge direction guide</h2><span id='topic+guide_edge_direction'></span>

<h3>Description</h3>

<p>This guide is intended to show the direction of edges based on the aesthetics
mapped to its progression, such as changing width, colour and opacity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_edge_direction(
  title = NULL,
  theme = NULL,
  arrow = NULL,
  labels = NULL,
  nbin = 500,
  position = NULL,
  direction = NULL,
  reverse = FALSE,
  order = 0,
  override.aes = list(),
  ...,
  available_aes = c("edge_colour", "edge_alpha", "edge_width"),
  arrow.position = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_edge_direction_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="ggplot2.html#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="ggplot2.html#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="ggplot2.html#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_arrow">arrow</code></td>
<td>
<p>Logical. Should an arrow be drawn to illustrate the direction.
Defaults to <code>TRUE</code>. The arrow is styled with the <code>legend.axis.line</code> theme
element. If <code>FALSE</code> the direction will be indicated by the text
given in <code>labels</code></p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_labels">labels</code></td>
<td>
<p>A vector with two strings giving the labels to place at the
start and the end of the legend to indicate direction if <code>arrow = FALSE</code></p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_nbin">nbin</code></td>
<td>
<p>A numeric specifying the number of bins for drawing the
colourbar. A smoother colourbar results from a larger value.</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_position">position</code></td>
<td>
<p>A character string indicating where the legend should be
placed relative to the plot panels.</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_reverse">reverse</code></td>
<td>
<p>logical. If <code>TRUE</code> the colourbar is reversed. By default,
the highest value is on the top and the lowest value is on the bottom</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_order">order</code></td>
<td>
<p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_override.aes">override.aes</code></td>
<td>
<p>A list specifying aesthetic parameters of legend key.
See details and examples.</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_available_aes">available_aes</code></td>
<td>
<p>A vector of character strings listing the aesthetics
for which a colourbar can be drawn.</p>
</td></tr>
<tr><td><code id="guide_edge_direction_+3A_arrow.position">arrow.position</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The position of the
arrow relative to the example edge. Use the <code>legend.text.position</code> argument
in <code>theme()</code> instead.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gr &lt;- tidygraph::as_tbl_graph(highschool)
ggraph(gr, layout = 'kk') +
  geom_edge_fan(aes(alpha = after_stat(index))) +
  guides(edge_alpha = guide_edge_direction())

# Use text labels instead of an arrow
ggraph(gr, layout = 'kk') +
  geom_edge_fan(aes(alpha = after_stat(index))) +
  guides(edge_alpha = guide_edge_direction(labels = c('start', 'end')))

# Style the indicator arrow
arrow_style &lt;- element_line(linewidth = 3, arrow = grid::arrow(type = "closed"))
ggraph(gr, layout = 'kk') +
  geom_edge_fan(aes(alpha = after_stat(index))) +
  guides(
    edge_alpha = guide_edge_direction(
      theme = theme(legend.axis.line = arrow_style)
    )
  )

</code></pre>

<hr>
<h2 id='highschool'>Friendship among high school boys</h2><span id='topic+highschool'></span>

<h3>Description</h3>

<p>This dataset shows the friendship among high school boys as assessed by the
question: &quot;What fellows here in school do you go around with most often?&quot;.
The question was posed twice, with one year in between (1957 and 1958) and
shows the evolution in friendship between the two timepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highschool
</code></pre>


<h3>Format</h3>

<p>The graph is stored as an unnamed edgelist with a year attribute.
</p>

<dl>
<dt>from</dt><dd><p>The boy answering the question</p>
</dd>
<dt>to</dt><dd><p>The boy being the answer to the question</p>
</dd>
<dt>year</dt><dd><p>The year the friendship was reported</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coleman, J. S. <em>Introduction to Mathematical Sociology</em>. New York: Free
Press, pp.450-451.
</p>

<hr>
<h2 id='internal_extractors'>Internal data extractors</h2><span id='topic+internal_extractors'></span><span id='topic+collect_connections'></span><span id='topic+collect_edges'></span>

<h3>Description</h3>

<p>These functions exists for supporting different data structures. There is no
need to call these directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_connections(layout, from, to, ...)

collect_edges(layout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal_extractors_+3A_layout">layout</code></td>
<td>
<p>The layout data</p>
</td></tr>
<tr><td><code id="internal_extractors_+3A_from">from</code>, <code id="internal_extractors_+3A_to">to</code></td>
<td>
<p>A numeric vector giving the indexes of the start and end nodes</p>
</td></tr>
<tr><td><code id="internal_extractors_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the specific method</p>
</td></tr>
</table>

<hr>
<h2 id='layout_tbl_graph_auto'>Automatically pick a layout based on graph type</h2><span id='topic+layout_tbl_graph_auto'></span>

<h3>Description</h3>

<p>This function infers the layout from the graph structure and is the default
when calling <code><a href="#topic+ggraph">ggraph()</a></code>. If an <code>x</code> and <code>y</code> argument is passed along, the
manual layout is chosen. Otherwise if the graph is either a rooted tree or a
rooted forest the layout will be <code>dendrogram</code> if the nodes contains a height
variable or <code>tree</code> if not. If the tree is unrooted the <code>unrooted</code> layout will
be used. If the tree is a DAG the <code>sygiyama</code> layout will be used. Otherwise
the <code>stress</code> layout will be used (or <code>sparse_tree</code> if the graph contains more
than 2000 nodes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_auto(graph, circular, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_auto_+3A_graph">graph</code></td>
<td>
<p>A tbl_graph object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_auto_+3A_circular">circular</code></td>
<td>
<p>Logical. Should the layout be transformed to a circular
representation. Defaults to <code>FALSE</code>. Only applicable if the graph is a tree
structure</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_auto_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the chosen layout</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_backbone'>Place node to emphasize group structure</h2><span id='topic+layout_tbl_graph_backbone'></span>

<h3>Description</h3>

<p>This layout is optimised for drawing small-world types of graphs often found
in social networks, where distinct groups are still highly connected to the
remaining graph. Typical layouts struggle with this as they attempt to
minimise the edge length of all edges equally. The backbone layout is based
on weighing edges based on how well they hold together communities. The end
result is that communities tend to stick together despite high
interconnectivity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_backbone(graph, keep = 0.2, circular = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_backbone_+3A_graph">graph</code></td>
<td>
<p>A tbl_graph object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_backbone_+3A_keep">keep</code></td>
<td>
<p>The fraction of edges to use for creating the backbone</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_backbone_+3A_circular">circular</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
Further an edge attribute called <code>backbone</code> is added giving whether the edge
was selected as backbone.
</p>


<h3>Author(s)</h3>

<p>The underlying algorithm is implemented in the graphlayouts package
by David Schoch
</p>


<h3>References</h3>

<p>Nocaj, A., Ortmann, M., &amp; Brandes, U. (2015). <em>Untangling the hairballs of
multi-centered, small-world online social media networks.</em> Journal of Graph
Algorithms and Applications: JGAA, 19(2), 595-618.
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_cactustree'>Calculate nodes as fractal circle buds</h2><span id='topic+layout_tbl_graph_cactustree'></span>

<h3>Description</h3>

<p>The cactustree layout is a hierarchical layout optimised for use with
hierarchical edge bundling (<code><a href="#topic+geom_conn_bundle">geom_conn_bundle()</a></code>). It is a fractal layout
that places node children as circles on the periphery of their parent circle,
each circle scaled by the total weight of their children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_cactustree(
  graph,
  direction = "out",
  weight = NULL,
  scale_factor = 0.75,
  overlap = 0.5,
  upright = FALSE,
  circular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_cactustree_+3A_graph">graph</code></td>
<td>
<p>An <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_cactustree_+3A_direction">direction</code></td>
<td>
<p>The direction of the tree in the graph. <code>'out'</code> (default)
means that parents point towards their children, while <code>'in'</code> means that
children point towards their parent.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_cactustree_+3A_weight">weight</code></td>
<td>
<p>An optional node variable to use as weight. If <code>NULL</code> all leaf
nodes will be assigned a weight of <code>1</code>.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_cactustree_+3A_scale_factor">scale_factor</code></td>
<td>
<p>A scaling factor for the circles in the layout. The
radius will be calculated as <code>total_weight ^ scale_factor</code> with <code>total_weight</code>
being the weight of the node and all it's children.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_cactustree_+3A_overlap">overlap</code></td>
<td>
<p>How much is the center of child nodes offset from the
periphery of their parent as a proportion of their own radius.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_cactustree_+3A_upright">upright</code></td>
<td>
<p>Logical. Should the children of the root only be distributed
around the top half of the root or all the way around.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_cactustree_+3A_circular">circular</code></td>
<td>
<p>Logical. Should the layout be transformed to a circular
representation. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>r</code>, <code>leaf</code>, <code>depth</code>,
<code>circular</code> as well as any information stored as node variables in the
tbl_graph object.
</p>


<h3>Note</h3>

<p>cactustree is a layout intended for trees, that is, graphs where nodes
only have one parent and zero or more children. If the provided graph does
not fit this format an attempt to convert it to such a format will be made.
</p>


<h3>References</h3>

<p>Dang, T., Forbes, A. (2017). <em>CactusTree: A Tree Drawing Approach
for Hierarchical Edge Bundling</em>. 2017 IEEE Pacific Visualization Symposium,
210-214. https://doi.org/10.1109/PACIFICVIS.2017.8031596
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_centrality'>Place nodes in circles according to centrality measure</h2><span id='topic+layout_tbl_graph_centrality'></span>

<h3>Description</h3>

<p>This layout places nodes in circles with the radii relative to a given
centrality measure. Under the hood it use stress majorisation to place nodes
optimally given the radius constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_centrality(
  graph,
  centrality,
  scale = TRUE,
  niter = 500,
  tolerance = 1e-04,
  tseq = seq(0, 1, 0.2),
  group = NULL,
  shrink = 10,
  circular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_centrality_+3A_graph">graph</code></td>
<td>
<p>A tbl_graph object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_centrality_+3A_centrality">centrality</code></td>
<td>
<p>An expression evaluating to a centrality measure for the
nodes. See the different <code style="white-space: pre;">&#8288;centrality_*()&#8288;</code> algorithms in tidygraph for a
selection.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_centrality_+3A_scale">scale</code></td>
<td>
<p>Should the centrality measure be scaled between 0 and 100</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_centrality_+3A_niter">niter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_centrality_+3A_tolerance">tolerance</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_centrality_+3A_tseq">tseq</code></td>
<td>
<p>Transitioning steps</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_centrality_+3A_group">group</code></td>
<td>
<p>An expression evaluating to a grouping of the nodes. If given
the layout will keep grouped nodes within an angle range of the origin</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_centrality_+3A_shrink">shrink</code></td>
<td>
<p>shrink the reserved angle range for a group to increase the
gaps between groups</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_centrality_+3A_circular">circular</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code>, <code>centrality</code> as
well as any information stored as node variables in the tbl_graph object.
</p>


<h3>Author(s)</h3>

<p>The underlying algorithm is implemented in the graphlayouts package
by David Schoch
</p>


<h3>References</h3>

<p>Brandes, U., &amp; Pich, C. (2011). <em>More flexible radial layout.</em> Journal of
Graph Algorithms and Applications, 15(1), 157-173.
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_circlepack'>Calculate nodes as circles packed within their parent circle</h2><span id='topic+layout_tbl_graph_circlepack'></span>

<h3>Description</h3>

<p>The circle packing algorithm is basically a treemap using circles instead of
rectangles. Due to the nature of circles they cannot be packed as efficiently
leading to increased amount of &quot;empty space&quot; as compared to a treemap. This
can be beneficial though, as the added empty space can aid in visually
showing the hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_circlepack(
  graph,
  weight = NULL,
  circular = FALSE,
  sort.by = NULL,
  direction = "out"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_circlepack_+3A_graph">graph</code></td>
<td>
<p>An <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_circlepack_+3A_weight">weight</code></td>
<td>
<p>An optional node variable to use as weight. Will only affect
the weight of leaf nodes as the weight of non-leaf nodes are derived from
their children.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_circlepack_+3A_circular">circular</code></td>
<td>
<p>Logical. Should the layout be transformed to a circular
representation. Ignored.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_circlepack_+3A_sort.by">sort.by</code></td>
<td>
<p>The name of a node variable to sort the nodes by.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_circlepack_+3A_direction">direction</code></td>
<td>
<p>The direction of the tree in the graph. <code>'out'</code> (default)
means that parents point towards their children, while <code>'in'</code> means that
children point towards their parent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The circle packing is based on the algorithm developed by Weixin Wang and
collaborators which tries to find the most dense packing of circles as they
are added, one by one. This makes the algorithm very dependent on the order
in which circles are added and it is possible that layouts could sometimes
be optimized by choosing a different ordering. The algorithm for finding the
enclosing circle is the randomized incremental algorithm proposed by Emo
Welzl. Both of the above algorithms are the same as used in the D3.js
implementation of circle packing and their C++ implementation in ggraph is
inspired by Mike Bostocks JavaScript implementation.
</p>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>r</code>, <code>leaf</code>,
<code>depth</code>, <code>circular</code> as well as any information stored as node
variables in the tbl_graph object.
</p>


<h3>Note</h3>

<p>Circle packing is a layout intended for trees, that is, graphs where nodes
only have one parent and zero or more children. If the provided graph does
not fit this format an attempt to convert it to such a format will be made.
</p>


<h3>References</h3>

<p>Wang, W., Wang, H. H., Dai, G., &amp; Wang, H. (2006). <em>Visualization of
large hierarchical data by circle packing</em>. Chi, 517-520.
</p>
<p>Welzl, E. (1991). <em>Smallest enclosing disks (balls and ellipsoids)</em>. New
Results and New Trends in Computer Science, 359-370.
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_dendrogram'>Apply a dendrogram layout to layout_tbl_graph</h2><span id='topic+layout_tbl_graph_dendrogram'></span>

<h3>Description</h3>

<p>This layout mimics the <code><a href="igraph.html#topic+layout_as_tree">igraph::layout_as_tree()</a></code> algorithm
supplied by igraph, but puts all leaves at 0 and builds it up from there,
instead of starting from the root and building it from there. The height of
branch points are related to the maximum distance to an edge from the branch
node, or read from a node variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_dendrogram(
  graph,
  circular = FALSE,
  offset = pi/2,
  height = NULL,
  length = NULL,
  repel = FALSE,
  ratio = 1,
  direction = "out"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_dendrogram_+3A_graph">graph</code></td>
<td>
<p>A <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_dendrogram_+3A_circular">circular</code></td>
<td>
<p>Logical. Should the layout be transformed to a circular
representation. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_dendrogram_+3A_offset">offset</code></td>
<td>
<p>If <code>circular = TRUE</code>, where should it begin. Defaults to
<code>pi/2</code> which is equivalent to 12 o'clock.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_dendrogram_+3A_height">height</code></td>
<td>
<p>The node variable holding the height of each node in the
dendrogram. If <code>NULL</code> it will be calculated as the maximal distance to a
leaf.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_dendrogram_+3A_length">length</code></td>
<td>
<p>An edge parameter giving the length of each edge. The node
height will be calculated from the maximal length to the root node (ignored
if <code>height</code> does not evaluate to <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_dendrogram_+3A_repel">repel</code></td>
<td>
<p>Should leafs repel each other relative to the height of their
common ancestor. Will emphasize clusters</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_dendrogram_+3A_ratio">ratio</code></td>
<td>
<p>The strength of repulsion if <code>repel = TRUE</code>. Higher values will
give more defined clusters</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_dendrogram_+3A_direction">direction</code></td>
<td>
<p>The direction to the leaves. Defaults to 'out'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code>, <code>depth</code> and
<code>leaf</code> as well as any information stored as node variables on the
tbl_graph
</p>


<h3>Note</h3>

<p>This function is not intended to be used directly but by setting
<code>layout = 'dendrogram'</code> in <code><a href="#topic+create_layout">create_layout()</a></code>
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_eigen'>Place nodes according to their eigenvalues</h2><span id='topic+layout_tbl_graph_eigen'></span>

<h3>Description</h3>

<p>This layout is based on the idea of spectral layouts where node coordinates
are calculated directly by decomposing a matrix representation of the graph
and extracting the eigenvectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_eigen(
  graph,
  type = "laplacian",
  eigenvector = "smallest",
  circular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_eigen_+3A_graph">graph</code></td>
<td>
<p>A tbl_graph object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_eigen_+3A_type">type</code></td>
<td>
<p>The type of matrix to extract the eigenvectors from. Either
<code>'laplacian'</code> or <code>'adjacency'</code></p>
</td></tr>
<tr><td><code id="layout_tbl_graph_eigen_+3A_eigenvector">eigenvector</code></td>
<td>
<p>The eigenvector to use for coordinates. Either <code>'smallest'</code>
or <code>'largest'</code></p>
</td></tr>
<tr><td><code id="layout_tbl_graph_eigen_+3A_circular">circular</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
</p>


<h3>Author(s)</h3>

<p>The underlying algorithm is implemented in the graphlayouts package
by David Schoch
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_fabric'>Create a fabric layout</h2><span id='topic+layout_tbl_graph_fabric'></span><span id='topic+node_rank_fabric'></span>

<h3>Description</h3>

<p>This layout is a bit unusual in that it shows nodes as horizontal line ranges
end edges as evenly spaced vertical spans connecting the nodes. As with the
matrix layout the strength comes from better scalability but its use require
some experience recognising the patterns that different connectivity features
gives rise to. As with matrix layouts the ordering of nodes have huge power
over the look of the plot. The <code>node_rank_fabric()</code> mimics the default
ordering from the original BioFabric implementation, but other ranking
algorithms from tidygraph can be used with the <code>sort.by</code> argument as well.
Fabric layouts tend to become quite wide as the graph grows which is
something that should be handled with care - e.g. by only zooming in on a
specific region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_fabric(
  graph,
  circular = FALSE,
  sort.by = NULL,
  shadow.edges = FALSE
)

node_rank_fabric()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_fabric_+3A_graph">graph</code></td>
<td>
<p>An <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_fabric_+3A_circular">circular</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_fabric_+3A_sort.by">sort.by</code></td>
<td>
<p>An expression providing the sorting of the nodes. If <code>NULL</code>
the nodes will be ordered by their index in the graph.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_fabric_+3A_shadow.edges">shadow.edges</code></td>
<td>
<p>Should shadow edges be shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>xmin</code>, <code>xmax</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
Further, the edges of the graph will gain a <code>edge_x</code> variable giving the
horizontal position of the edge as well as a <code>shadow_edge</code> variable denoting
whether the edge is a shadow edge added by the layout.
</p>


<h3>References</h3>

<p>BioFabric website: <a href="https://biofabric.systemsbiology.net">https://biofabric.systemsbiology.net</a>
</p>
<p>Longabaugh, William J.R. (2012).
<em>Combing the hairball with BioFabric: a new approach for visualization of large networks</em>.
BMC Bioinformatics, 13: 275. <a href="https://doi.org/10.1186/1471-2105-13-275">doi:10.1186/1471-2105-13-275</a>
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_focus'>Place nodes in circles based on distance to a specific node</h2><span id='topic+layout_tbl_graph_focus'></span>

<h3>Description</h3>

<p>This layout constrains node placement to a radius relative to its distance to
a given node. It then uses stress majorisation to find an optimal node
distribution according to this constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_focus(
  graph,
  focus,
  weights = NULL,
  niter = 500,
  tolerance = 1e-04,
  group = NULL,
  shrink = 10,
  circular = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_focus_+3A_graph">graph</code></td>
<td>
<p>a tbl_graph object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_focus_+3A_focus">focus</code></td>
<td>
<p>An expression evaluating to a selected node. Can either be a
single integer or a logical vector with a single <code>TRUE</code> element.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_focus_+3A_weights">weights</code></td>
<td>
<p>An expression evaluated on the edge data to provide edge
weights for the layout. Currently ignored for the sparse version</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_focus_+3A_niter">niter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_focus_+3A_tolerance">tolerance</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_focus_+3A_group">group</code></td>
<td>
<p>An expression evaluating to a grouping of the nodes. If given
the layout will keep grouped nodes within an angle range of the origin</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_focus_+3A_shrink">shrink</code></td>
<td>
<p>shrink the reserved angle range for a group to increase the
gaps between groups</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_focus_+3A_circular">circular</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code>, <code>distance</code> as
well as any information stored as node variables in the tbl_graph object.
</p>


<h3>Author(s)</h3>

<p>The underlying algorithm is implemented in the graphlayouts package
by David Schoch
</p>


<h3>References</h3>

<p>Brandes, U., &amp; Pich, C. (2011). <em>More flexible radial layout.</em> Journal of
Graph Algorithms and Applications, 15(1), 157-173.
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_hive'>Place nodes in a Hive Plot layout</h2><span id='topic+layout_tbl_graph_hive'></span>

<h3>Description</h3>

<p>Hive plots were invented by Martin Krzywinski as a perceptually uniform and
scalable alternative to standard node-edge layouts. In hive plots nodes are
positioned on axes radiating out from a center based on their own information
e.g. membership of a class, size of neighborhood, etc. Edges are then drawn
between nodes as bezier curves. As the placement of nodes is not governed by
convoluted algorithms but directly reflects the qualities of the nodes itself
the resulting plot can be easier to interpret as well as compare to other
graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_hive(
  graph,
  axis,
  axis.pos = NULL,
  sort.by = NULL,
  divide.by = NULL,
  divide.order = NULL,
  normalize = TRUE,
  center.size = 0.1,
  divide.size = 0.05,
  use.numeric = FALSE,
  offset = pi/2,
  split.axes = "none",
  split.angle = pi/6,
  circular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_hive_+3A_graph">graph</code></td>
<td>
<p>An <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_axis">axis</code></td>
<td>
<p>The node attribute to use for assigning nodes to axes</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_axis.pos">axis.pos</code></td>
<td>
<p>The relative distance to the prior axis. Default
(<code>NULL</code>) places axes equidistant.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_sort.by">sort.by</code></td>
<td>
<p>The node attribute to use for placing nodes along their axis.
Defaults (<code>NULL</code>) places nodes sequentially.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_divide.by">divide.by</code></td>
<td>
<p>An optional node attribute to subdivide each axis by.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_divide.order">divide.order</code></td>
<td>
<p>The order the axis subdivisions should appear in</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_normalize">normalize</code></td>
<td>
<p>Logical. Should axis lengths be equal or reflect the number
of nodes in each axis. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_center.size">center.size</code></td>
<td>
<p>The size of the blank center, that is, the start position
of the axes.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_divide.size">divide.size</code></td>
<td>
<p>The distance between subdivided axis segments.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_use.numeric">use.numeric</code></td>
<td>
<p>Logical, If the <code>sort.by</code> attribute is numeric,
should these values be used directly in positioning the nodes along the axes.
Defaults to <code>FALSE</code> which sorts the numeric values and positions them
equidistant from each other.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_offset">offset</code></td>
<td>
<p>Change the overall rotation of the hive plot by changing the
offset of the first axis.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_split.axes">split.axes</code></td>
<td>
<p>Should axes be split to show edges between nodes on the
same axis? One of:
</p>

<dl>
<dt><code>'none'</code></dt><dd><p>Do not split axes and show in-between edges</p>
</dd>
<dt><code>'loops'</code></dt><dd><p>Only split axes that contain in-between edges</p>
</dd>
<dt><code>'all'</code></dt><dd><p>Split all axes</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_split.angle">split.angle</code></td>
<td>
<p>The angular distance between the two axes resulting from a
split.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_hive_+3A_circular">circular</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to be able to draw all edges without edges crossing axes you should
not assign nodes to axes based on a variable with more than three levels.
</p>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>r</code>,
<code>center_size</code>, <code>split</code>, <code>axis</code>, <code>section</code>, <code>angle</code>,
<code>circular</code> as well as any information stored as node variables in the
tbl_graph object.
</p>


<h3>References</h3>

<p>Krzywinski, M., Birol, I., Jones, SJM., and Marra, MA. (2012). <em>Hive
plots-rational approach to visualizing networks</em>. Brief Bioinform 13 (5):
627-644. https://doi.org/10.1093/bib/bbr069
</p>
<p><a href="https://www.hiveplot.net/">https://www.hiveplot.net/</a>
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_htree'>Layout binary trees in a fractal H formation</h2><span id='topic+layout_tbl_graph_htree'></span>

<h3>Description</h3>

<p>This is a spac efficient layout only useful for binary trees. It is fractal
and works by offsetting child nodes from their parent either horizontally or
vertically depending on depth. The offset is decreased at each step by a
factor of the square root of 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_htree(
  graph,
  sort.by = NULL,
  direction = "out",
  circular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_htree_+3A_graph">graph</code></td>
<td>
<p>An <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_htree_+3A_sort.by">sort.by</code></td>
<td>
<p>The name of a node variable to sort the nodes by.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_htree_+3A_direction">direction</code></td>
<td>
<p>The direction of the tree in the graph. <code>'out'</code> (default)
means that parents point towards their children, while <code>'in'</code> means that
children point towards their parent.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_htree_+3A_circular">circular</code></td>
<td>
<p>Logical. Should the layout be transformed to a circular
representation. Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>leaf</code>, <code>depth</code>, <code>circular</code>
as well as any information stored as node variables in the tbl_graph object.
</p>


<h3>Note</h3>

<p>H Tree is a layout intended for trees, that is, graphs where nodes
only have one parent and zero or more children. If the provided graph does
not fit this format an attempt to convert it to such a format will be made.
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_igraph'>Use igraph layout algorithms for layout_tbl_graph</h2><span id='topic+layout_tbl_graph_igraph'></span>

<h3>Description</h3>

<p>This layout function makes it easy to apply one of the layout algorithms
supplied in igraph when plotting with ggraph. Layout names are auto completed
so there is no need to write <code>layout_with_graphopt</code> or
<code>layout_as_tree</code>, just <code>graphopt</code> and <code>tree</code> (though the
former will also work if you want to be super explicit). Circular layout is
only supported for tree-like layout (<code>tree</code> and <code>sugiyama</code>) and
will throw an error when applied to other layouts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_igraph(
  graph,
  algorithm,
  circular,
  offset = pi/2,
  use.dummy = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_igraph_+3A_graph">graph</code></td>
<td>
<p>A <code>tbl_graph</code> object.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_igraph_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of layout algorithm to apply. See <em>Details</em> or
<code><a href="igraph.html#topic+layout_">igraph::layout_()</a></code> for links to the layouts supplied by igraph.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_igraph_+3A_circular">circular</code></td>
<td>
<p>Logical. Should the layout be transformed to a circular
representation. Defaults to <code>FALSE</code>. Only applicable to
<code>algorithm = 'tree'</code> and <code>algorithm = 'sugiyama'</code>.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_igraph_+3A_offset">offset</code></td>
<td>
<p>If <code>circular = TRUE</code>, where should it begin. Defaults to
<code>pi/2</code> which is equivalent to 12 o'clock.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_igraph_+3A_use.dummy">use.dummy</code></td>
<td>
<p>Logical. In the case of <code>algorithm = 'sugiyama'</code> should the
dummy-infused graph be used rather than the original. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_igraph_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the respective layout functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>igraph provides a huge amount of possible layouts. They are all briefly
described below:
</p>
<p><strong>Hierarchical layouts</strong>
</p>

<dl>
<dt><code>tree</code></dt><dd><p>Uses the <em>Reingold-Tilford</em> algorithm to place the
nodes below their parent with the parent centered above its children. See
<code><a href="igraph.html#topic+layout_as_tree">igraph::as_tree()</a></code></p>
</dd>
<dt><code>sugiyama</code></dt><dd><p>Designed for directed acyclic graphs (that is,
hierarchies where multiple parents are allowed) it minimizes the number of
crossing edges. See <code><a href="igraph.html#topic+layout_with_sugiyama">igraph::with_sugiyama()</a></code></p>
</dd>
</dl>

<p><strong>Standard layouts</strong>
</p>

<dl>
<dt><code>bipartite</code></dt><dd><p>Minimize edge-crossings in a simple two-row (or
column) layout for bipartite graphs. See <code><a href="igraph.html#topic+layout_as_bipartite">igraph::as_bipartite()</a></code></p>
</dd>
<dt><code>star</code></dt><dd><p>Place one node in the center and the rest equidistantly
around it. See <code><a href="igraph.html#topic+layout_as_star">igraph::as_star()</a></code></p>
</dd>
<dt><code>circle</code></dt><dd><p>Place nodes in a circle in the order of their index.
Consider using <code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear()</a></code> with <code>circular=TRUE</code>
for more control. See <code><a href="igraph.html#topic+layout_in_circle">igraph::in_circle()</a></code></p>
</dd>
<dt><code>nicely</code></dt><dd><p>Tries to pick an appropriate layout. See
<code><a href="igraph.html#topic+layout_nicely">igraph::nicely()</a></code> for a description of the simple decision tree
it uses</p>
</dd>
<dt><code>dh</code></dt><dd><p>Uses <em>Davidson and Harels</em> simulated annealing
algorithm to place nodes. See <code><a href="igraph.html#topic+layout_with_dh">igraph::with_dh()</a></code></p>
</dd>
<dt><code>gem</code></dt><dd><p>Place nodes on the plane using the GEM force-directed
layout algorithm. See <code><a href="igraph.html#topic+layout_with_gem">igraph::with_gem()</a></code></p>
</dd>
<dt><code>graphopt</code></dt><dd><p>Uses the Graphopt algorithm based on alternating
attraction and repulsion to place nodes. See
<code><a href="igraph.html#topic+layout_with_graphopt">igraph::with_graphopt()</a></code></p>
</dd>
<dt><code>grid</code></dt><dd><p>Place nodes on a rectangular grid. See
<code><a href="igraph.html#topic+layout_on_grid">igraph::on_grid()</a></code></p>
</dd>
<dt><code>mds</code></dt><dd><p>Perform a multidimensional scaling of nodes using either
the shortest path or a user supplied distance. See
<code><a href="igraph.html#topic+layout_with_mds">igraph::with_mds()</a></code></p>
</dd>
<dt><code>sphere</code></dt><dd><p>Place nodes uniformly on a sphere - less relevant for
2D visualizations of networks. See <code><a href="igraph.html#topic+layout_on_sphere">igraph::on_sphere()</a></code></p>
</dd>
<dt><code>randomly</code></dt><dd><p>Places nodes uniformly random. See
<code><a href="igraph.html#topic+layout_randomly">igraph::randomly()</a></code></p>
</dd>
<dt><code>fr</code></dt><dd><p>Places nodes according to the force-directed algorithm of
Fruchterman and Reingold. See <code><a href="igraph.html#topic+layout_with_fr">igraph::with_fr()</a></code></p>
</dd>
<dt><code>kk</code></dt><dd><p>Uses the spring-based algorithm by Kamada and Kawai to
place nodes. See <code><a href="igraph.html#topic+layout_with_kk">igraph::with_kk()</a></code></p>
</dd>
<dt><code>drl</code></dt><dd><p>Uses the force directed algorithm from the DrL toolbox to
place nodes. See <code><a href="igraph.html#topic+layout_with_drl">igraph::with_drl()</a></code></p>
</dd>
<dt><code>lgl</code></dt><dd><p>Uses the algorithm from Large Graph Layout to place
nodes. See <code><a href="igraph.html#topic+layout_with_lgl">igraph::with_lgl()</a></code></p>
</dd>
</dl>



<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
</p>


<h3>Note</h3>

<p>This function is not intended to be used directly but by setting
<code>layout = 'igraph'</code> in <code><a href="#topic+create_layout">create_layout()</a></code>
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_linear'>Place nodes on a line or circle</h2><span id='topic+layout_tbl_graph_linear'></span>

<h3>Description</h3>

<p>This layout puts all nodes on a line, possibly sorted by a node attribute. If
<code>circular = TRUE</code> the nodes will be laid out on the unit circle instead.
In the case where the <code>sort.by</code> attribute is numeric, the numeric values
will be used as the x-position and it is thus possible to have uneven spacing
between the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_linear(
  graph,
  circular,
  sort.by = NULL,
  use.numeric = FALSE,
  offset = pi/2,
  weight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_linear_+3A_graph">graph</code></td>
<td>
<p>An <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_linear_+3A_circular">circular</code></td>
<td>
<p>Logical. Should the layout be transformed to a circular
representation. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_linear_+3A_sort.by">sort.by</code></td>
<td>
<p>The name of a node variable to sort the nodes by.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_linear_+3A_use.numeric">use.numeric</code></td>
<td>
<p>Logical. Should a numeric sort.by attribute be used as the
actual x-coordinates in the layout. May lead to overlapping nodes. Defaults
to FALSE</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_linear_+3A_offset">offset</code></td>
<td>
<p>If <code>circular = TRUE</code>, where should it begin. Defaults to
<code>pi/2</code> which is equivalent to 12 o'clock.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_linear_+3A_weight">weight</code></td>
<td>
<p>A weight for each node. Nodes will be spread out according to
their weight so that nodes with heigher weight will have more space around
them. Ignored if <code>use.numeric = TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
Further, if <code>circular = FALSE</code> a <code>width</code> column and if <code>circular = TRUE</code> a
<code>start</code>, <code>end</code>, and <code>r0</code> column.
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_manual'>Manually specify a layout for layout_tbl_graph</h2><span id='topic+layout_tbl_graph_manual'></span>

<h3>Description</h3>

<p>This layout function lets you pass the node positions in manually. The
supplied positions must match the order of the nodes in the tbl_graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_manual(graph, x, y, circular)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_manual_+3A_graph">graph</code></td>
<td>
<p>An <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_manual_+3A_x">x</code>, <code id="layout_tbl_graph_manual_+3A_y">y</code></td>
<td>
<p>Expressions with the x and y positions of the nodes</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_manual_+3A_circular">circular</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph.
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_matrix'>Place nodes on a diagonal</h2><span id='topic+layout_tbl_graph_matrix'></span>

<h3>Description</h3>

<p>This layout puts all nodes on a diagonal, thus preparing the layout for use
with <code><a href="#topic+geom_edge_point">geom_edge_point()</a></code> resulting in a matrix layout. While matrix
layouts excel in scalability, the interpretation of the visual is very
dependent on the sorting of the nodes. Different sorting algorithms have been
implemented in <code>tidygraph</code> and these can be used directly. Behrisch
<em>et al.</em> (2016) have provided a nice overview of some of the different
sorting algorithms and what insight they might bring, along with a rundown of
different patterns to look out for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_matrix(graph, circular = FALSE, sort.by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_matrix_+3A_graph">graph</code></td>
<td>
<p>An <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_matrix_+3A_circular">circular</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_matrix_+3A_sort.by">sort.by</code></td>
<td>
<p>An expression providing the sorting of the nodes. If <code>NULL</code>
the nodes will be ordered by their index in the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
</p>


<h3>References</h3>

<p>Behrisch, M., Bach, B., Riche, N. H., Schreck, T., Fekete, J.-D. (2016).
<em>Matrix Reordering Methods for Table and Network Visualization</em>.
Computer Graphics Forum, 35: 693–716. <a href="https://doi.org/10.1111/cgf.12935">doi:10.1111/cgf.12935</a>
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_metro'>Place nodes according to the standard design of metro maps</h2><span id='topic+layout_tbl_graph_metro'></span>

<h3>Description</h3>

<p>This layouttries to optimise the placement of nodes so that they adhere to
the classic look of metro maps. As such it optimizes on the distribution of
incident edge angles, conformity of edge length, and edge angles in multiples
of 45 degrees. As it works as a refinement of an already existing layout
(the physical location of metro stations) it requires an a priori node
location. Due to it's purpose it probably works best with planar graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_metro(
  graph,
  x,
  y,
  length = 2,
  grid_space = 0.0025,
  optimization_weights = NULL,
  max_movement = 5,
  circular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_metro_+3A_graph">graph</code></td>
<td>
<p>A tbl_graph object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_metro_+3A_x">x</code>, <code id="layout_tbl_graph_metro_+3A_y">y</code></td>
<td>
<p>The start location of the nodes</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_metro_+3A_length">length</code></td>
<td>
<p>Desired multiple of grid point spacing. (<code>length * grid_space</code>
determines desired edge length)</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_metro_+3A_grid_space">grid_space</code></td>
<td>
<p>The distance between consecitive grid points</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_metro_+3A_optimization_weights">optimization_weights</code></td>
<td>
<p>The relative weight to be placed on the 5
criteria during optimization as a numeric vector of length 4. The criteria
are:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;Angular Resolution Criterion&#8288;</code>: The angles of incident edges at each
station should be maximized, because if there is only a small angle between
any two adjacent edges, then it can become difficult to distinguish between
them.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Edge Length Criterion&#8288;</code>: The edge lengths across the whole map should be
approximately equal to ensure regular spacing between stations. It is based
on the preferred multiple, l, of the grid spacing, g. The purpose of the
criterion is to penalize edges that are longer than or shorter than lg.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Balanced Edge Length Criterion&#8288;</code>: The length of edges incident to a
particular station should be similar.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Line Straightness Criterion&#8288;</code>: (not yet implemented) Edges that form part
of a line should, where possible, be co-linear either side of each station
that the line passes through.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Octiinearity Criterion&#8288;</code>: Each edge should be drawn horizontally,
vertically, or diagonally at 45 degree, so we penalize edges that are not
at a desired angle.
If <code>NULL</code> all criteria are given equal weight.
</p>
</li></ul>
</td></tr>
<tr><td><code id="layout_tbl_graph_metro_+3A_max_movement">max_movement</code></td>
<td>
<p>Number of grid points a station can move away rom its
original position</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_metro_+3A_circular">circular</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
</p>


<h3>Author(s)</h3>

<p>The underlying algorithm is implemented in the graphlayouts package
by David Schoch
</p>


<h3>References</h3>

<p>Stott, J., Rodgers, P., Martinez-Ovando, J. C., and Walker, S. G. (2011).
<em>Automatic metro map layout using multicriteria optimization</em> In IEEE Trans
Vis Comput Graph 17(1) pp. 101-114. https://doi.org/10.1109/tvcg.2010.24
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_partition'>Calculate nodes as areas dividing their parent</h2><span id='topic+layout_tbl_graph_partition'></span>

<h3>Description</h3>

<p>The partition layout is a way to show hierarchical data in the same way as
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap()</a></code>. Instead of subdividing the parent area
the partition layout shows the division of a nodes children next to the area
of the node itself. As such the node positions will be very reminiscent of
a reingold-tilford tree layout but by plotting nodes as areas it better
communicate the total weight of a node by summing up all its children.
Often partition layouts are called icicle plots or sunburst diagrams (in case
a radial transform is applied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_partition(
  graph,
  weight = NULL,
  circular = FALSE,
  height = NULL,
  sort.by = NULL,
  direction = "out",
  offset = pi/2,
  const.area = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_partition_+3A_graph">graph</code></td>
<td>
<p>An <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_partition_+3A_weight">weight</code></td>
<td>
<p>An optional node variable to use as weight. Will only affect
the weight of leaf nodes as the weight of non-leaf nodes are derived from
their children.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_partition_+3A_circular">circular</code></td>
<td>
<p>Logical. Should the layout be transformed to a circular
representation. If <code>TRUE</code> the resulting layout will be a sunburst
diagram.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_partition_+3A_height">height</code></td>
<td>
<p>An optional node variable to use as height. If <code>NULL</code>
all nodes will be given a height of 1.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_partition_+3A_sort.by">sort.by</code></td>
<td>
<p>The name of a node variable to sort the nodes by.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_partition_+3A_direction">direction</code></td>
<td>
<p>The direction of the tree in the graph. <code>'out'</code> (default)
means that parents point towards their children, while <code>'in'</code> means that
children point towards their parent.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_partition_+3A_offset">offset</code></td>
<td>
<p>If <code>circular = TRUE</code>, where should it begin. Defaults to
<code>pi/2</code> which is equivalent to 12 o'clock.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_partition_+3A_const.area">const.area</code></td>
<td>
<p>Logical. Should 'height' be scaled for area proportionality
when using <code>circular = TRUE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>circular = FALSE</code> A data.frame with the columns <code>x</code>,
<code>y</code>, <code>width</code>, <code>height</code>, <code>leaf</code>,
<code>depth</code>, <code>circular</code> as well as any information stored as node
variables in the tbl_graph object.
If <code>circular = TRUE</code> A data.frame with the columns <code>x</code>, <code>y</code>,
<code>r0</code>, <code>r</code>, <code>start</code>, <code>end</code>, <code>leaf</code>,
<code>depth</code>, <code>circular</code> as well as any information stored as node
variables in the tbl_graph object.
</p>


<h3>Note</h3>

<p>partition is a layout intended for trees, that is, graphs where nodes
only have one parent and zero or more children. If the provided graph does
not fit this format an attempt to convert it to such a format will be made.
</p>


<h3>References</h3>

<p>Kruskal, J. B., Landwehr, J. M. (1983). <em>Icicle Plots: Better Displays
for Hierarchical Clustering</em>. American Statistician Vol 37(2), 162-168.
https://doi.org/10.2307/2685881
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_pmds'>Place nodes based on a multidimensional scaling of a set of pivot nodes</h2><span id='topic+layout_tbl_graph_pmds'></span>

<h3>Description</h3>

<p>This layout is similar to the 'mds' layout but uses only a subset of pivot
nodes for the mds calculation, making it considerably faster and thus suited
for large graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_pmds(graph, pivots, weights = NULL, circular = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_pmds_+3A_graph">graph</code></td>
<td>
<p>A tbl_graph object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_pmds_+3A_pivots">pivots</code></td>
<td>
<p>The number of pivot nodes</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_pmds_+3A_weights">weights</code></td>
<td>
<p>An expression evaluated on the edge data to provide edge
weights for the layout. Currently ignored for the sparse version</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_pmds_+3A_circular">circular</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
</p>


<h3>Author(s)</h3>

<p>The underlying algorithm is implemented in the graphlayouts package
by David Schoch
</p>


<h3>References</h3>

<p>Brandes, U. and Pich, C. (2006). <em>Eigensolver Methods for Progressive
Multidimensional Scaling of Large Data.</em> In International Symposium on Graph
Drawing (pp. 42-53). Springer
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_sf'>Place nodes on their geographical space</h2><span id='topic+layout_tbl_graph_sf'></span>

<h3>Description</h3>

<p>This layout is built for objects of class <code>sfnetwork</code> and is meant to
plot a graph on its geographical space, by extracting its X and Y coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_sf(graph, circular = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_sf_+3A_graph">graph</code></td>
<td>
<p>An sfnetwork object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_sf_+3A_circular">circular</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code>.
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_stress'>Place nodes using stress majorisation</h2><span id='topic+layout_tbl_graph_stress'></span><span id='topic+layout_tbl_graph_sparse_stress'></span>

<h3>Description</h3>

<p>This layout is related to the stress-minimization algorithm known as
Kamada-Kawai (available as the 'kk' layout), but uses another optimization
strategy. It generally have better runtime, quality, and stability compared
to the Kamada-Kawai layout and is thus generally preferred. The sparse
version of the layout have better performance (especially on larger networks)
at the expense of layout quality, but will generally outperform many other
algorithms for large graphs in both runtime and quality (e.g. the 'drl'
layout from igraph).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_stress(
  graph,
  weights = NULL,
  niter = 500,
  tolerance = 1e-04,
  mds = TRUE,
  bbox = 50,
  x = NULL,
  y = NULL,
  circular = FALSE
)

layout_tbl_graph_sparse_stress(
  graph,
  pivots,
  weights = NULL,
  niter = 500,
  circular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_stress_+3A_graph">graph</code></td>
<td>
<p>a tbl_graph object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_stress_+3A_weights">weights</code></td>
<td>
<p>An expression evaluated on the edge data to provide edge
weights for the layout. Currently ignored for the sparse version</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_stress_+3A_niter">niter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_stress_+3A_tolerance">tolerance</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_stress_+3A_mds">mds</code></td>
<td>
<p>should an MDS layout be used as initial layout (default: TRUE)</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_stress_+3A_bbox">bbox</code></td>
<td>
<p>constrain dimension of output. Only relevant to determine the
placement of disconnected graphs.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_stress_+3A_x">x</code>, <code id="layout_tbl_graph_stress_+3A_y">y</code></td>
<td>
<p>Expressions evaluated on the node data giving
coordinates along x and/or y axis to fix nodes to. You can chose to only fix
selected nodes by leaving the remaining nodes with <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_stress_+3A_circular">circular</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_stress_+3A_pivots">pivots</code></td>
<td>
<p>The number of pivot nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code> as
well as any information stored as node variables in the tbl_graph object.
</p>


<h3>Author(s)</h3>

<p>The underlying algorithm is implemented in the graphlayouts package
by David Schoch
</p>


<h3>References</h3>

<p>Gansner, E. R., Koren, Y., &amp; North, S. (2004). <em>Graph drawing by stress
majorization.</em> In International Symposium on Graph Drawing (pp. 239-250). Springer, Berlin, Heidelberg.
</p>
<p>Ortmann, M. and Klimenta, M. and Brandes, U. (2016). <em>A Sparse Stress Model.</em> https://arxiv.org/pdf/1608.08909.pdf
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_treemap'>Calculate nodes as rectangles subdividing that of their parent</h2><span id='topic+layout_tbl_graph_treemap'></span>

<h3>Description</h3>

<p>A treemap is a space filling hierarchical layout that maps nodes to
rectangles. The rectangles of the children of a node is packed into the
rectangle of the node so that the size of a rectangle is a function of the
size of the children. The size of the leaf nodes can be mapped arbitrarily
(defaults to 1). Many different algorithms exists for dividing a rectangle
into smaller bits, some optimizing the aspect ratio and some focusing on the
ordering of the rectangles. See details for more discussions on this. The
treemap layout was first developed by Ben Shneiderman for visualizing disk
usage in the early '90 and has seen many improvements since.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_treemap(
  graph,
  algorithm = "split",
  weight = NULL,
  circular = FALSE,
  sort.by = NULL,
  direction = "out",
  height = 1,
  width = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_treemap_+3A_graph">graph</code></td>
<td>
<p>A <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_treemap_+3A_algorithm">algorithm</code></td>
<td>
<p>The name of the tiling algorithm to use. Defaults to 'split'</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_treemap_+3A_weight">weight</code></td>
<td>
<p>An optional node variable to use as weight. Will only affect
the weight of leaf nodes as the weight of non-leaf nodes are derived from
their children.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_treemap_+3A_circular">circular</code></td>
<td>
<p>Logical. Should the layout be transformed to a circular
representation. Ignored.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_treemap_+3A_sort.by">sort.by</code></td>
<td>
<p>The name of a node variables to sort the nodes by.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_treemap_+3A_direction">direction</code></td>
<td>
<p>The direction of the tree in the graph. <code>'out'</code> (default)
means that parents point towards their children, while <code>'in'</code> means that
children point towards their parent.</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_treemap_+3A_height">height</code></td>
<td>
<p>The height of the bounding rectangle</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_treemap_+3A_width">width</code></td>
<td>
<p>The width of the bounding rectangle</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different approaches to dividing the rectangles in a treemap exists; all with
their strengths and weaknesses. Currently only the split algorithm is
implemented which strikes a good balance between aspect ratio and order
preservation, but other, more well-known, algorithms such as squarify and
slice-and-dice will eventually be implemented.
</p>
<p><strong>Algorithms</strong>
</p>
<p><em>Split</em> (default)
</p>
<p>The Split algorithm was developed by Bjorn Engdahl in order to address the
downsides of both the original slice-and-dice algorithm (poor aspect ratio)
and the popular squarify algorithm (no ordering of nodes). It works by
finding the best cut in the ordered list of children in terms of making sure
that the two rectangles associated with the split will have optimal aspect
ratio.
</p>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>width</code>,
<code>height</code>, <code>leaf</code>, <code>depth</code>, <code>circular</code> as well as any
information stored as node variables in the tbl_graph object.
</p>


<h3>Note</h3>

<p>Treemap is a layout intended for trees, that is, graphs where nodes
only have one parent and zero or more children. If the provided graph does
not fit this format an attempt to convert it to such a format will be made.
</p>


<h3>References</h3>

<p>Engdahl, B. (2005). <em>Ordered and unordered treemap algorithms and their
applications on handheld devices</em>. Master's Degree Project.
</p>
<p>Johnson, B., &amp; Ben Shneiderman. (1991). <em>Tree maps: A Space-Filling
Approach to the Visualization of Hierarchical Information Structures</em>. IEEE
Visualization, 284-291. <a href="https://doi.org/10.1109/VISUAL.1991.175815">doi:10.1109/VISUAL.1991.175815</a>
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_unrooted">layout_tbl_graph_unrooted</a>()</code>
</p>

<hr>
<h2 id='layout_tbl_graph_unrooted'>Create an unrooted layout using equal-angle or equal-daylight</h2><span id='topic+layout_tbl_graph_unrooted'></span>

<h3>Description</h3>

<p>When drawing unrooted trees the standard dendrogram layout is a bad fit as it
implicitly creates a visual root node. Instead it is possible to spread the
leafs out on the plane without putting any special emphasis on a particular
node using an unrooted layout. The standard algorithm is the equal angle
algorithm, but it can struggle with optimising the leaf distribution for
large trees with very uneven branch length. The equal daylight
algorithm modifies the output of the equal angle algorithm to better disperse
the leaves, at the cost of higher computational cost and the possibility of
edge crossings for very large unbalanced trees. For standard sized trees the
daylight algorithm is far superior and not too heavy so it is the default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_unrooted(
  graph,
  daylight = TRUE,
  length = NULL,
  tolerance = 0.05,
  rotation_mod = 1,
  maxiter = 100,
  circular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_tbl_graph_unrooted_+3A_graph">graph</code></td>
<td>
<p>A tbl_graph object</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_unrooted_+3A_daylight">daylight</code></td>
<td>
<p>Should equal-daylight adjustments be made</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_unrooted_+3A_length">length</code></td>
<td>
<p>An expression evaluating to the branch length of each edge</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_unrooted_+3A_tolerance">tolerance</code></td>
<td>
<p>The threshold for mean angular adjustment before terminating
the daylight adjustment</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_unrooted_+3A_rotation_mod">rotation_mod</code></td>
<td>
<p>A modifier for the angular adjustment of each branch. Set
it below 1 to let the daylight adjustment progress more slowly</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_unrooted_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations in the the daylight
adjustment</p>
</td></tr>
<tr><td><code id="layout_tbl_graph_unrooted_+3A_circular">circular</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>x</code>, <code>y</code>, <code>circular</code>, <code>leaf</code> as well as
any information stored as node variables in the tbl_graph object.
</p>


<h3>Note</h3>

<p>Unrooted is a layout intended for undirected trees, that is, graphs with no
cycles. If the provided graph does not fit this format an attempt to convert
it to such a format will be made.
</p>


<h3>References</h3>

<p>Felsenstein, J. (2004) <em>Drawing Trees</em>, in Inferring Phylogenies. Sinauer
Assoc., pp 573-584
</p>


<h3>See Also</h3>

<p>Other layout_tbl_graph_*: 
<code><a href="#topic+layout_tbl_graph_auto">layout_tbl_graph_auto</a>()</code>,
<code><a href="#topic+layout_tbl_graph_backbone">layout_tbl_graph_backbone</a>()</code>,
<code><a href="#topic+layout_tbl_graph_cactustree">layout_tbl_graph_cactustree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_centrality">layout_tbl_graph_centrality</a>()</code>,
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a>()</code>,
<code><a href="#topic+layout_tbl_graph_dendrogram">layout_tbl_graph_dendrogram</a>()</code>,
<code><a href="#topic+layout_tbl_graph_eigen">layout_tbl_graph_eigen</a>()</code>,
<code><a href="#topic+layout_tbl_graph_fabric">layout_tbl_graph_fabric</a>()</code>,
<code><a href="#topic+layout_tbl_graph_focus">layout_tbl_graph_focus</a>()</code>,
<code><a href="#topic+layout_tbl_graph_hive">layout_tbl_graph_hive</a>()</code>,
<code><a href="#topic+layout_tbl_graph_htree">layout_tbl_graph_htree</a>()</code>,
<code><a href="#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a>()</code>,
<code><a href="#topic+layout_tbl_graph_linear">layout_tbl_graph_linear</a>()</code>,
<code><a href="#topic+layout_tbl_graph_manual">layout_tbl_graph_manual</a>()</code>,
<code><a href="#topic+layout_tbl_graph_matrix">layout_tbl_graph_matrix</a>()</code>,
<code><a href="#topic+layout_tbl_graph_metro">layout_tbl_graph_metro</a>()</code>,
<code><a href="#topic+layout_tbl_graph_partition">layout_tbl_graph_partition</a>()</code>,
<code><a href="#topic+layout_tbl_graph_pmds">layout_tbl_graph_pmds</a>()</code>,
<code><a href="#topic+layout_tbl_graph_sf">layout_tbl_graph_sf</a>()</code>,
<code><a href="#topic+layout_tbl_graph_stress">layout_tbl_graph_stress</a>()</code>,
<code><a href="#topic+layout_tbl_graph_treemap">layout_tbl_graph_treemap</a>()</code>
</p>

<hr>
<h2 id='layout_to_table'>Convert a layout to a table</h2><span id='topic+layout_to_table'></span>

<h3>Description</h3>

<p>This generic takes care of dispatching various layout types (names,
functions, tables) to their respective functions that will return a valid
layout table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_to_table(layout, graph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_to_table_+3A_layout">layout</code></td>
<td>
<p>A supported object</p>
</td></tr>
<tr><td><code id="layout_to_table_+3A_graph">graph</code></td>
<td>
<p>A <code>tbl_graph</code></p>
</td></tr>
<tr><td><code id="layout_to_table_+3A_...">...</code></td>
<td>
<p>passed on to implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A valid data.frame
</p>

<hr>
<h2 id='makeContent.cappedpathgrob'>Dynamic capping of paths</h2><span id='topic+makeContent.cappedpathgrob'></span>

<h3>Description</h3>

<p>This function takes care of updating which parts of the paths get removed
when the device dimensions are updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cappedpathgrob'
makeContent(x)
</code></pre>

<hr>
<h2 id='makeContent.textalong'>Text angled according to line</h2><span id='topic+makeContent.textalong'></span>

<h3>Description</h3>

<p>This function takes care of recalculating the angle of the text as the device
size changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'textalong'
makeContent(x)
</code></pre>

<hr>
<h2 id='node_angle'>Get the angle of nodes and edges</h2><span id='topic+node_angle'></span><span id='topic+edge_angle'></span>

<h3>Description</h3>

<p>These helper functions makes it easy to calculate the angle associated with
nodes and edges. For nodes the angle is defined as the angle of the vector
pointing towards the node position, and is thus mainly suited for circular
layouts where it can be used to calculate the angle of labels. For edges it
is simply the angle of the vector describing the edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_angle(x, y, degrees = TRUE, avoid_flip = TRUE)

edge_angle(x, y, xend, yend, degrees = TRUE, avoid_flip = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_angle_+3A_x">x</code>, <code id="node_angle_+3A_y">y</code></td>
<td>
<p>A vector of positions</p>
</td></tr>
<tr><td><code id="node_angle_+3A_degrees">degrees</code></td>
<td>
<p>Logical. Should the angle be returned in degree (<code>TRUE</code>)
or radians (<code>FALSE</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="node_angle_+3A_avoid_flip">avoid_flip</code></td>
<td>
<p>Logical. Should the angle be adjusted so that text is
always upside-down</p>
</td></tr>
<tr><td><code id="node_angle_+3A_xend">xend</code>, <code id="node_angle_+3A_yend">yend</code></td>
<td>
<p>The end position of the edge</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the angle of each node/edge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tidygraph)
flareGraph &lt;- tbl_graph(flare$vertices, flare$edges)

ggraph(flareGraph, 'dendrogram', circular = TRUE) +
  geom_edge_diagonal0() +
  geom_node_text(aes(filter = leaf, angle = node_angle(x, y), label = shortName),
    hjust = 'outward', size = 2
  ) +
  expand_limits(x = c(-1.3, 1.3), y = c(-1.3, 1.3))
</code></pre>

<hr>
<h2 id='pack_circles'>Pack circles together</h2><span id='topic+pack_circles'></span>

<h3>Description</h3>

<p>This function is a direct interface to the circle packing algorithm used by
<code><a href="#topic+layout_tbl_graph_circlepack">layout_tbl_graph_circlepack</a></code>. It takes a vector of sizes and
returns the x and y position of each circle as a two-column matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack_circles(areas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pack_circles_+3A_areas">areas</code></td>
<td>
<p>A vector of circle areas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns and the same number of rows as the length
of the &quot;areas&quot; vector. The matrix has the following attributes added:
&quot;enclosing_radius&quot; giving the radius of the smallest enclosing circle, and
&quot;front_chain&quot; giving the terminating members of the front chain (see
Wang <em>et al</em>. 2006).
</p>


<h3>References</h3>

<p>Wang, W., Wang, H. H., Dai, G., &amp; Wang, H. (2006). <em>Visualization of
large hierarchical data by circle packing</em>. Chi, 517-520.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggforce)
sizes &lt;- sample(10, 100, TRUE)

position &lt;- pack_circles(sizes)
data &lt;- data.frame(x = position[,1], y = position[,2], r = sqrt(sizes/pi))

ggplot() +
  geom_circle(aes(x0 = x, y0 = y, r = r), data = data, fill = 'steelblue') +
  geom_circle(aes(x0 = 0, y0 = 0, r = attr(position, 'enclosing_radius'))) +
  geom_polygon(aes(x = x, y = y),
               data = data[attr(position, 'front_chain'), ],
               fill = NA,
               colour = 'black')

</code></pre>

<hr>
<h2 id='qgraph'>Deprecated autograph predecessor</h2><span id='topic+qgraph'></span>

<h3>Description</h3>

<p>Deprecated autograph predecessor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgraph(...)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+scale_color_viridis'></span><span id='topic+scale_fill_viridis'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>viridis</dt><dd><p><code><a href="viridis.html#topic+scale_viridis">scale_color_viridis</a></code>, <code><a href="viridis.html#topic+scale_viridis">scale_fill_viridis</a></code></p>
</dd>
</dl>

<hr>
<h2 id='scale_edge_alpha'>Edge alpha scales</h2><span id='topic+scale_edge_alpha'></span><span id='topic+scale_edge_alpha_continuous'></span><span id='topic+scale_edge_alpha_discrete'></span><span id='topic+scale_edge_alpha_binned'></span><span id='topic+scale_edge_alpha_manual'></span><span id='topic+scale_edge_alpha_identity'></span>

<h3>Description</h3>

<p>This set of scales defines new alpha scales for edge geoms equivalent to the
ones already defined by ggplot2. See <code><a href="ggplot2.html#topic+scale_alpha">ggplot2::scale_alpha()</a></code> for
more information. The different geoms will know whether to use edge scales or
the standard scales so it is not necessary to write <code>edge_alpha</code> in
the call to the geom - just use <code>alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_edge_alpha(..., range = c(0.1, 1))

scale_edge_alpha_continuous(..., range = c(0.1, 1))

scale_edge_alpha_discrete(..., range = c(0.1, 1))

scale_edge_alpha_binned(..., range = c(0.1, 1))

scale_edge_alpha_manual(..., values, breaks = waiver(), na.value = NA)

scale_edge_alpha_identity(..., guide = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_edge_alpha_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+continuous_scale">continuous_scale()</a></code>, <code><a href="ggplot2.html#topic+binned_scale">binned_scale()</a></code>,
or <code><a href="ggplot2.html#topic+discrete_scale">discrete_scale()</a></code> as appropriate, to control name, limits,
breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_edge_alpha_+3A_range">range</code></td>
<td>
<p>Output range of alpha values. Must lie between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_edge_alpha_+3A_values">values</code></td>
<td>
<p>a set of aesthetic values to map data values to. The values
will be matched in order (usually alphabetical) with the limits of the
scale, or with <code>breaks</code> if provided. If this is a named vector, then the
values will be matched based on the names instead. Data values that don't
match will be given <code>na.value</code>.</p>
</td></tr>
<tr><td><code id="scale_edge_alpha_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_alpha_+3A_na.value">na.value</code></td>
<td>
<p>The aesthetic value to use for missing (<code>NA</code>) values</p>
</td></tr>
<tr><td><code id="scale_edge_alpha_+3A_guide">guide</code></td>
<td>
<p>Guide to use for this scale. Defaults to <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object inheriting from <code>Scale</code>
</p>


<h3>See Also</h3>

<p>Other scale_edge_*: 
<code><a href="#topic+scale_edge_colour">scale_edge_colour</a></code>,
<code><a href="#topic+scale_edge_fill">scale_edge_fill</a></code>,
<code><a href="#topic+scale_edge_linetype">scale_edge_linetype</a>()</code>,
<code><a href="#topic+scale_edge_shape">scale_edge_shape</a>()</code>,
<code><a href="#topic+scale_edge_size">scale_edge_size</a>()</code>,
<code><a href="#topic+scale_edge_width">scale_edge_width</a>()</code>,
<code><a href="#topic+scale_label_size">scale_label_size</a>()</code>
</p>

<hr>
<h2 id='scale_edge_colour'>Edge colour scales</h2><span id='topic+scale_edge_colour'></span><span id='topic+scale_edge_colour_hue'></span><span id='topic+scale_edge_colour_brewer'></span><span id='topic+scale_edge_colour_distiller'></span><span id='topic+scale_edge_colour_gradient'></span><span id='topic+scale_edge_colour_gradient2'></span><span id='topic+scale_edge_colour_gradientn'></span><span id='topic+scale_edge_colour_grey'></span><span id='topic+scale_edge_colour_identity'></span><span id='topic+scale_edge_colour_manual'></span><span id='topic+scale_edge_colour_viridis'></span><span id='topic+scale_edge_colour_steps'></span><span id='topic+scale_edge_colour_steps2'></span><span id='topic+scale_edge_colour_stepsn'></span><span id='topic+scale_edge_colour_fermenter'></span><span id='topic+scale_edge_colour_continuous'></span><span id='topic+scale_edge_colour_discrete'></span><span id='topic+scale_edge_colour_binned'></span><span id='topic+scale_edge_color_hue'></span><span id='topic+scale_edge_color_brewer'></span><span id='topic+scale_edge_color_distiller'></span><span id='topic+scale_edge_color_gradient'></span><span id='topic+scale_edge_color_gradient2'></span><span id='topic+scale_edge_color_gradientn'></span><span id='topic+scale_edge_color_grey'></span><span id='topic+scale_edge_color_identity'></span><span id='topic+scale_edge_color_manual'></span><span id='topic+scale_edge_color_continuous'></span><span id='topic+scale_edge_color_discrete'></span><span id='topic+scale_edge_color_viridis'></span><span id='topic+scale_edge_color_steps'></span><span id='topic+scale_edge_color_steps2'></span><span id='topic+scale_edge_color_stepsn'></span><span id='topic+scale_edge_color_fermenter'></span><span id='topic+scale_edge_color_binned'></span>

<h3>Description</h3>

<p>This set of scales defines new colour scales for edge geoms equivalent to the
ones already defined by ggplot2. The parameters are equivalent to the ones
from ggplot2 so there is nothing new under the sun. The different geoms will
know whether to use edge scales or the standard scales so it is not necessary
to write <code>edge_colour</code> in the call to the geom - just use <code>colour</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_edge_colour_hue(
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50",
  aesthetics = "edge_colour"
)

scale_edge_colour_brewer(
  ...,
  type = "seq",
  palette = 1,
  direction = 1,
  aesthetics = "edge_colour"
)

scale_edge_colour_distiller(
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour"
)

scale_edge_colour_gradient(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour"
)

scale_edge_colour_gradient2(
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour"
)

scale_edge_colour_gradientn(
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour",
  colors
)

scale_edge_colour_grey(
  ...,
  start = 0.2,
  end = 0.8,
  na.value = "red",
  aesthetics = "edge_colour"
)

scale_edge_colour_identity(..., guide = "none", aesthetics = "edge_colour")

scale_edge_colour_manual(
  ...,
  values,
  aesthetics = "edge_colour",
  breaks = waiver(),
  na.value = "grey50"
)

scale_edge_colour_viridis(
  ...,
  alpha = 1,
  begin = 0,
  end = 1,
  direction = 1,
  discrete = FALSE,
  option = "D",
  aesthetics = "edge_colour"
)

scale_edge_colour_steps(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour"
)

scale_edge_colour_steps2(
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour"
)

scale_edge_colour_stepsn(
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour",
  colors
)

scale_edge_colour_fermenter(
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour"
)

scale_edge_colour_continuous(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour"
)

scale_edge_colour_discrete(
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50",
  aesthetics = "edge_colour"
)

scale_edge_colour_binned(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour"
)

scale_edge_color_hue(
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50",
  aesthetics = "edge_colour"
)

scale_edge_color_brewer(
  ...,
  type = "seq",
  palette = 1,
  direction = 1,
  aesthetics = "edge_colour"
)

scale_edge_color_distiller(
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour"
)

scale_edge_color_gradient(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour"
)

scale_edge_color_gradient2(
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour"
)

scale_edge_color_gradientn(
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour",
  colors
)

scale_edge_color_grey(
  ...,
  start = 0.2,
  end = 0.8,
  na.value = "red",
  aesthetics = "edge_colour"
)

scale_edge_color_identity(..., guide = "none", aesthetics = "edge_colour")

scale_edge_color_manual(
  ...,
  values,
  aesthetics = "edge_colour",
  breaks = waiver(),
  na.value = "grey50"
)

scale_edge_color_continuous(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_colour"
)

scale_edge_color_discrete(
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50",
  aesthetics = "edge_colour"
)

scale_edge_color_viridis(
  ...,
  alpha = 1,
  begin = 0,
  end = 1,
  direction = 1,
  discrete = FALSE,
  option = "D",
  aesthetics = "edge_colour"
)

scale_edge_color_steps(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour"
)

scale_edge_color_steps2(
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour"
)

scale_edge_color_stepsn(
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour",
  colors
)

scale_edge_color_fermenter(
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour"
)

scale_edge_color_binned(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_colour"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_edge_colour_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_h">h</code></td>
<td>
<p>range of hues to use, in [0, 360]</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_c">c</code></td>
<td>
<p>chroma (intensity of colour), maximum value varies depending on
combination of hue and luminance.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_l">l</code></td>
<td>
<p>luminance (lightness), in [0, 100]</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_h.start">h.start</code></td>
<td>
<p>hue to start at</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_direction">direction</code></td>
<td>
<p>direction to travel around the colour wheel,
1 = clockwise, -1 = counter-clockwise</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_type">type</code></td>
<td>
<p>One of &quot;seq&quot; (sequential), &quot;div&quot; (diverging) or &quot;qual&quot;
(qualitative)</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_palette">palette</code></td>
<td>
<p>If a string, will use that named palette. If a number, will index into
the list of palettes of appropriate <code>type</code>. The list of available palettes can found
in the Palettes section.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use <code>"colourbar"</code> for continuous
colour bar, or <code>"legend"</code> for discrete colour legend.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_low">low</code>, <code id="scale_edge_colour_+3A_high">high</code></td>
<td>
<p>Colours for low and high ends of the gradient.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_mid">mid</code></td>
<td>
<p>colour for mid point</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_midpoint">midpoint</code></td>
<td>
<p>The midpoint (in data value) of the diverging scale.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_colours">colours</code>, <code id="scale_edge_colour_+3A_colors">colors</code></td>
<td>
<p>Vector of colours to use for n-colour gradient.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_start">start</code></td>
<td>
<p>grey value at low end of palette</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_end">end</code></td>
<td>
<p>grey value at high end of palette</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_begin">begin</code></td>
<td>
<p>The (corrected) hue in [0,1] at which the color map begins.</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_discrete">discrete</code></td>
<td>
<p>Generate a discrete palette? (default: <code>FALSE</code> -
generate continuous palette).</p>
</td></tr>
<tr><td><code id="scale_edge_colour_+3A_option">option</code></td>
<td>
<p>A character string indicating the color map option to use.
Eight options are available:
</p>

<ul>
<li><p> &quot;magma&quot; (or &quot;A&quot;)
</p>
</li>
<li><p> &quot;inferno&quot; (or &quot;B&quot;)
</p>
</li>
<li><p> &quot;plasma&quot; (or &quot;C&quot;)
</p>
</li>
<li><p> &quot;viridis&quot; (or &quot;D&quot;)
</p>
</li>
<li><p> &quot;cividis&quot; (or &quot;E&quot;)
</p>
</li>
<li><p> &quot;rocket&quot; (or &quot;F&quot;)
</p>
</li>
<li><p> &quot;mako&quot; (or &quot;G&quot;)
</p>
</li>
<li><p> &quot;turbo&quot; (or &quot;H&quot;)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object inheriting from <code>Scale</code>
</p>


<h3>See Also</h3>

<p>Other scale_edge_*: 
<code><a href="#topic+scale_edge_alpha">scale_edge_alpha</a>()</code>,
<code><a href="#topic+scale_edge_fill">scale_edge_fill</a></code>,
<code><a href="#topic+scale_edge_linetype">scale_edge_linetype</a>()</code>,
<code><a href="#topic+scale_edge_shape">scale_edge_shape</a>()</code>,
<code><a href="#topic+scale_edge_size">scale_edge_size</a>()</code>,
<code><a href="#topic+scale_edge_width">scale_edge_width</a>()</code>,
<code><a href="#topic+scale_label_size">scale_label_size</a>()</code>
</p>

<hr>
<h2 id='scale_edge_fill'>Edge fill scales</h2><span id='topic+scale_edge_fill'></span><span id='topic+scale_edge_fill_hue'></span><span id='topic+scale_edge_fill_brewer'></span><span id='topic+scale_edge_fill_distiller'></span><span id='topic+scale_edge_fill_gradient'></span><span id='topic+scale_edge_fill_gradient2'></span><span id='topic+scale_edge_fill_gradientn'></span><span id='topic+scale_edge_fill_grey'></span><span id='topic+scale_edge_fill_identity'></span><span id='topic+scale_edge_fill_manual'></span><span id='topic+scale_edge_fill_viridis'></span><span id='topic+scale_edge_fill_steps'></span><span id='topic+scale_edge_fill_steps2'></span><span id='topic+scale_edge_fill_stepsn'></span><span id='topic+scale_edge_fill_fermenter'></span><span id='topic+scale_edge_fill_continuous'></span><span id='topic+scale_edge_fill_discrete'></span><span id='topic+scale_edge_fill_binned'></span>

<h3>Description</h3>

<p>This set of scales defines new fill scales for edge geoms equivalent to the
ones already defined by ggplot2. The parameters are equivalent to the ones
from ggplot2 so there is nothing new under the sun. The different geoms will
know whether to use edge scales or the standard scales so it is not necessary
to write <code>edge_fill</code> in the call to the geom - just use <code>fill</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_edge_fill_hue(
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50",
  aesthetics = "edge_fill"
)

scale_edge_fill_brewer(
  ...,
  type = "seq",
  palette = 1,
  direction = 1,
  aesthetics = "edge_fill"
)

scale_edge_fill_distiller(
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_fill"
)

scale_edge_fill_gradient(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_fill"
)

scale_edge_fill_gradient2(
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_fill"
)

scale_edge_fill_gradientn(
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_fill",
  colors
)

scale_edge_fill_grey(
  ...,
  start = 0.2,
  end = 0.8,
  na.value = "red",
  aesthetics = "edge_fill"
)

scale_edge_fill_identity(..., guide = "none", aesthetics = "edge_fill")

scale_edge_fill_manual(
  ...,
  values,
  aesthetics = "edge_fill",
  breaks = waiver(),
  na.value = "grey50"
)

scale_edge_fill_viridis(
  ...,
  alpha = 1,
  begin = 0,
  end = 1,
  direction = 1,
  discrete = FALSE,
  option = "D",
  aesthetics = "edge_fill"
)

scale_edge_fill_steps(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_fill"
)

scale_edge_fill_steps2(
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_fill"
)

scale_edge_fill_stepsn(
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_fill",
  colors
)

scale_edge_fill_fermenter(
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_fill"
)

scale_edge_fill_continuous(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_colourbar",
  aesthetics = "edge_fill"
)

scale_edge_fill_discrete(
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50",
  aesthetics = "edge_fill"
)

scale_edge_fill_binned(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "edge_coloursteps",
  aesthetics = "edge_fill"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_edge_fill_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_h">h</code></td>
<td>
<p>range of hues to use, in [0, 360]</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_c">c</code></td>
<td>
<p>chroma (intensity of colour), maximum value varies depending on
combination of hue and luminance.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_l">l</code></td>
<td>
<p>luminance (lightness), in [0, 100]</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_h.start">h.start</code></td>
<td>
<p>hue to start at</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_direction">direction</code></td>
<td>
<p>direction to travel around the colour wheel,
1 = clockwise, -1 = counter-clockwise</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_type">type</code></td>
<td>
<p>One of &quot;seq&quot; (sequential), &quot;div&quot; (diverging) or &quot;qual&quot;
(qualitative)</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_palette">palette</code></td>
<td>
<p>If a string, will use that named palette. If a number, will index into
the list of palettes of appropriate <code>type</code>. The list of available palettes can found
in the Palettes section.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use <code>"colourbar"</code> for continuous
colour bar, or <code>"legend"</code> for discrete colour legend.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_low">low</code>, <code id="scale_edge_fill_+3A_high">high</code></td>
<td>
<p>Colours for low and high ends of the gradient.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_mid">mid</code></td>
<td>
<p>colour for mid point</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_midpoint">midpoint</code></td>
<td>
<p>The midpoint (in data value) of the diverging scale.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_colours">colours</code>, <code id="scale_edge_fill_+3A_colors">colors</code></td>
<td>
<p>Vector of colours to use for n-colour gradient.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_start">start</code></td>
<td>
<p>grey value at low end of palette</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_end">end</code></td>
<td>
<p>grey value at high end of palette</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_begin">begin</code></td>
<td>
<p>The (corrected) hue in [0,1] at which the color map begins.</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_discrete">discrete</code></td>
<td>
<p>Generate a discrete palette? (default: <code>FALSE</code> -
generate continuous palette).</p>
</td></tr>
<tr><td><code id="scale_edge_fill_+3A_option">option</code></td>
<td>
<p>A character string indicating the color map option to use.
Eight options are available:
</p>

<ul>
<li><p> &quot;magma&quot; (or &quot;A&quot;)
</p>
</li>
<li><p> &quot;inferno&quot; (or &quot;B&quot;)
</p>
</li>
<li><p> &quot;plasma&quot; (or &quot;C&quot;)
</p>
</li>
<li><p> &quot;viridis&quot; (or &quot;D&quot;)
</p>
</li>
<li><p> &quot;cividis&quot; (or &quot;E&quot;)
</p>
</li>
<li><p> &quot;rocket&quot; (or &quot;F&quot;)
</p>
</li>
<li><p> &quot;mako&quot; (or &quot;G&quot;)
</p>
</li>
<li><p> &quot;turbo&quot; (or &quot;H&quot;)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object inheriting from <code>Scale</code>
</p>


<h3>See Also</h3>

<p>Other scale_edge_*: 
<code><a href="#topic+scale_edge_alpha">scale_edge_alpha</a>()</code>,
<code><a href="#topic+scale_edge_colour">scale_edge_colour</a></code>,
<code><a href="#topic+scale_edge_linetype">scale_edge_linetype</a>()</code>,
<code><a href="#topic+scale_edge_shape">scale_edge_shape</a>()</code>,
<code><a href="#topic+scale_edge_size">scale_edge_size</a>()</code>,
<code><a href="#topic+scale_edge_width">scale_edge_width</a>()</code>,
<code><a href="#topic+scale_label_size">scale_label_size</a>()</code>
</p>

<hr>
<h2 id='scale_edge_linetype'>Edge linetype scales</h2><span id='topic+scale_edge_linetype'></span><span id='topic+scale_edge_linetype_continuous'></span><span id='topic+scale_edge_linetype_discrete'></span><span id='topic+scale_edge_linetype_binned'></span><span id='topic+scale_edge_linetype_manual'></span><span id='topic+scale_edge_linetype_identity'></span>

<h3>Description</h3>

<p>This set of scales defines new linetype scales for edge geoms equivalent to
the ones already defined by ggplot2. See
<code><a href="ggplot2.html#topic+scale_linetype">ggplot2::scale_linetype()</a></code> for more information. The different
geoms will know whether to use edge scales or the standard scales so it is
not necessary to write <code>edge_linetype</code> in the call to the geom - just
use <code>linetype</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_edge_linetype(..., na.value = "blank")

scale_edge_linetype_continuous(...)

scale_edge_linetype_discrete(..., na.value = "blank")

scale_edge_linetype_binned(..., na.value = "blank")

scale_edge_linetype_manual(..., values, breaks = waiver(), na.value = "blank")

scale_edge_linetype_identity(..., guide = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_edge_linetype_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>aesthetics</code></dt><dd><p>The names of the aesthetics that this scale works with.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_edge_linetype_+3A_na.value">na.value</code></td>
<td>
<p>The linetype to use for <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="scale_edge_linetype_+3A_values">values</code></td>
<td>
<p>a set of aesthetic values to map data values to. The values
will be matched in order (usually alphabetical) with the limits of the
scale, or with <code>breaks</code> if provided. If this is a named vector, then the
values will be matched based on the names instead. Data values that don't
match will be given <code>na.value</code>.</p>
</td></tr>
<tr><td><code id="scale_edge_linetype_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_linetype_+3A_guide">guide</code></td>
<td>
<p>Guide to use for this scale. Defaults to <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object inheriting from <code>Scale</code>
</p>


<h3>See Also</h3>

<p>Other scale_edge_*: 
<code><a href="#topic+scale_edge_alpha">scale_edge_alpha</a>()</code>,
<code><a href="#topic+scale_edge_colour">scale_edge_colour</a></code>,
<code><a href="#topic+scale_edge_fill">scale_edge_fill</a></code>,
<code><a href="#topic+scale_edge_shape">scale_edge_shape</a>()</code>,
<code><a href="#topic+scale_edge_size">scale_edge_size</a>()</code>,
<code><a href="#topic+scale_edge_width">scale_edge_width</a>()</code>,
<code><a href="#topic+scale_label_size">scale_label_size</a>()</code>
</p>

<hr>
<h2 id='scale_edge_shape'>Edge shape scales</h2><span id='topic+scale_edge_shape'></span><span id='topic+scale_edge_shape_discrete'></span><span id='topic+scale_edge_shape_continuous'></span><span id='topic+scale_edge_shape_binned'></span><span id='topic+scale_edge_shape_manual'></span><span id='topic+scale_edge_shape_identity'></span>

<h3>Description</h3>

<p>This set of scales defines new shape scales for edge geoms equivalent to the
ones already defined by ggplot2. See <code><a href="ggplot2.html#topic+scale_shape">ggplot2::scale_shape()</a></code> for
more information. The different geoms will know whether to use edge scales or
the standard scales so it is not necessary to write <code>edge_shape</code> in
the call to the geom - just use <code>shape</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_edge_shape(..., solid = TRUE)

scale_edge_shape_discrete(..., solid = TRUE)

scale_edge_shape_continuous(...)

scale_edge_shape_binned(..., solid = TRUE)

scale_edge_shape_manual(..., values, breaks = waiver(), na.value = NA)

scale_edge_shape_identity(..., guide = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_edge_shape_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>na.value</code></dt><dd><p>If <code>na.translate = TRUE</code>, what aesthetic value should the
missing values be displayed as? Does not apply to position scales
where <code>NA</code> is always placed at the far right.</p>
</dd>
<dt><code>aesthetics</code></dt><dd><p>The names of the aesthetics that this scale works with.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_edge_shape_+3A_solid">solid</code></td>
<td>
<p>Should the shapes be solid, <code>TRUE</code>, or hollow,
<code>FALSE</code>?</p>
</td></tr>
<tr><td><code id="scale_edge_shape_+3A_values">values</code></td>
<td>
<p>a set of aesthetic values to map data values to. The values
will be matched in order (usually alphabetical) with the limits of the
scale, or with <code>breaks</code> if provided. If this is a named vector, then the
values will be matched based on the names instead. Data values that don't
match will be given <code>na.value</code>.</p>
</td></tr>
<tr><td><code id="scale_edge_shape_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_shape_+3A_na.value">na.value</code></td>
<td>
<p>The aesthetic value to use for missing (<code>NA</code>) values</p>
</td></tr>
<tr><td><code id="scale_edge_shape_+3A_guide">guide</code></td>
<td>
<p>Guide to use for this scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object inheriting from <code>Scale</code>
</p>


<h3>See Also</h3>

<p>Other scale_edge_*: 
<code><a href="#topic+scale_edge_alpha">scale_edge_alpha</a>()</code>,
<code><a href="#topic+scale_edge_colour">scale_edge_colour</a></code>,
<code><a href="#topic+scale_edge_fill">scale_edge_fill</a></code>,
<code><a href="#topic+scale_edge_linetype">scale_edge_linetype</a>()</code>,
<code><a href="#topic+scale_edge_size">scale_edge_size</a>()</code>,
<code><a href="#topic+scale_edge_width">scale_edge_width</a>()</code>,
<code><a href="#topic+scale_label_size">scale_label_size</a>()</code>
</p>

<hr>
<h2 id='scale_edge_size'>Edge size scales</h2><span id='topic+scale_edge_size'></span><span id='topic+scale_edge_size_continuous'></span><span id='topic+scale_edge_radius'></span><span id='topic+scale_edge_size_discrete'></span><span id='topic+scale_edge_size_binned'></span><span id='topic+scale_edge_size_area'></span><span id='topic+scale_edge_size_binned_area'></span><span id='topic+scale_edge_size_manual'></span><span id='topic+scale_edge_size_identity'></span>

<h3>Description</h3>

<p>This set of scales defines new size scales for edge geoms equivalent to the
ones already defined by ggplot2. See <code><a href="ggplot2.html#topic+scale_size">ggplot2::scale_size()</a></code> for
more information. The different geoms will know whether to use edge scales or
the standard scales so it is not necessary to write <code>edge_size</code> in
the call to the geom - just use <code>size</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_edge_size_continuous(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  trans = "identity",
  guide = "legend"
)

scale_edge_radius(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  trans = "identity",
  guide = "legend"
)

scale_edge_size(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  trans = "identity",
  guide = "legend"
)

scale_edge_size_discrete(...)

scale_edge_size_binned(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  n.breaks = NULL,
  nice.breaks = TRUE,
  trans = "identity",
  guide = "bins"
)

scale_edge_size_area(..., max_size = 6)

scale_edge_size_binned_area(..., max_size = 6)

scale_edge_size_manual(..., values, breaks = waiver(), na.value = NA)

scale_edge_size_identity(..., guide = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_edge_size_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_range">range</code></td>
<td>
<p>a numeric vector of length 2 that specifies the minimum and
maximum size of the plotting symbol after transformation.</p>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+continuous_scale">continuous_scale</a></code>
</p>

<dl>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>na.value</code></dt><dd><p>Missing values will be replaced with this value.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_n.breaks">n.breaks</code></td>
<td>
<p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_nice.breaks">nice.breaks</code></td>
<td>
<p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_max_size">max_size</code></td>
<td>
<p>Size of largest points.</p>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_values">values</code></td>
<td>
<p>a set of aesthetic values to map data values to. The values
will be matched in order (usually alphabetical) with the limits of the
scale, or with <code>breaks</code> if provided. If this is a named vector, then the
values will be matched based on the names instead. Data values that don't
match will be given <code>na.value</code>.</p>
</td></tr>
<tr><td><code id="scale_edge_size_+3A_na.value">na.value</code></td>
<td>
<p>The aesthetic value to use for missing (<code>NA</code>) values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object inheriting from <code>Scale</code>
</p>


<h3>Note</h3>

<p>In ggplot2 size conflates both line width and point size into one
scale. In ggraph there is also a width scale (<code><a href="#topic+scale_edge_width">scale_edge_width()</a></code>)
that is used for linewidth. As edges are often represented by lines the width
scale is the most common.
</p>


<h3>See Also</h3>

<p>Other scale_edge_*: 
<code><a href="#topic+scale_edge_alpha">scale_edge_alpha</a>()</code>,
<code><a href="#topic+scale_edge_colour">scale_edge_colour</a></code>,
<code><a href="#topic+scale_edge_fill">scale_edge_fill</a></code>,
<code><a href="#topic+scale_edge_linetype">scale_edge_linetype</a>()</code>,
<code><a href="#topic+scale_edge_shape">scale_edge_shape</a>()</code>,
<code><a href="#topic+scale_edge_width">scale_edge_width</a>()</code>,
<code><a href="#topic+scale_label_size">scale_label_size</a>()</code>
</p>

<hr>
<h2 id='scale_edge_width'>Edge width scales</h2><span id='topic+scale_edge_width'></span><span id='topic+scale_edge_width_continuous'></span><span id='topic+scale_edge_width_discrete'></span><span id='topic+scale_edge_width_binned'></span><span id='topic+scale_edge_width_manual'></span><span id='topic+scale_edge_width_identity'></span>

<h3>Description</h3>

<p>This set of scales defines width scales for edge geoms. Of all the new edge
scales defined in ggraph, this is the only one not having an equivalent in
ggplot2. In essence it mimics the use of size in
<code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code> and related. As almost all edge
representations are lines of some sort, edge_width will be used much more
often than edge_size. It is not necessary to spell out that it is an edge
scale as the geom knows if it is drawing an edge. Just write <code>width</code> and
not <code>edge_width</code> in the call to geoms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_edge_width_continuous(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  trans = "identity",
  guide = "legend"
)

scale_edge_width(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  trans = "identity",
  guide = "legend"
)

scale_edge_width_discrete(...)

scale_edge_width_binned(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  n.breaks = NULL,
  nice.breaks = TRUE,
  trans = "identity",
  guide = "bins"
)

scale_edge_width_manual(..., values, breaks = waiver(), na.value = NA)

scale_edge_width_identity(..., guide = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_edge_width_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_range">range</code></td>
<td>
<p>a numeric vector of length 2 that specifies the minimum and
maximum size of the plotting symbol after transformation.</p>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+continuous_scale">continuous_scale</a></code>
</p>

<dl>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>na.value</code></dt><dd><p>Missing values will be replaced with this value.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_n.breaks">n.breaks</code></td>
<td>
<p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_nice.breaks">nice.breaks</code></td>
<td>
<p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_values">values</code></td>
<td>
<p>a set of aesthetic values to map data values to. The values
will be matched in order (usually alphabetical) with the limits of the
scale, or with <code>breaks</code> if provided. If this is a named vector, then the
values will be matched based on the names instead. Data values that don't
match will be given <code>na.value</code>.</p>
</td></tr>
<tr><td><code id="scale_edge_width_+3A_na.value">na.value</code></td>
<td>
<p>The aesthetic value to use for missing (<code>NA</code>) values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object inheriting from <code>Scale</code>
</p>


<h3>See Also</h3>

<p>Other scale_edge_*: 
<code><a href="#topic+scale_edge_alpha">scale_edge_alpha</a>()</code>,
<code><a href="#topic+scale_edge_colour">scale_edge_colour</a></code>,
<code><a href="#topic+scale_edge_fill">scale_edge_fill</a></code>,
<code><a href="#topic+scale_edge_linetype">scale_edge_linetype</a>()</code>,
<code><a href="#topic+scale_edge_shape">scale_edge_shape</a>()</code>,
<code><a href="#topic+scale_edge_size">scale_edge_size</a>()</code>,
<code><a href="#topic+scale_label_size">scale_label_size</a>()</code>
</p>

<hr>
<h2 id='scale_label_size'>Edge label size scales</h2><span id='topic+scale_label_size'></span><span id='topic+scale_label_size_continuous'></span><span id='topic+scale_label_size_discrete'></span><span id='topic+scale_label_size_binned'></span><span id='topic+scale_label_size_manual'></span><span id='topic+scale_label_size_identity'></span>

<h3>Description</h3>

<p>This set of scales defines new size scales for edge labels in order to allow
for separate sizing of edges and their labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_label_size_continuous(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  trans = "identity",
  guide = "legend"
)

scale_label_size(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  trans = "identity",
  guide = "legend"
)

scale_label_size_discrete(...)

scale_label_size_binned(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  n.breaks = NULL,
  nice.breaks = TRUE,
  trans = "identity",
  guide = "bins"
)

scale_label_size_manual(..., values, breaks = waiver(), na.value = NA)

scale_label_size_identity(..., guide = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_label_size_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_label_size_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_label_size_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_label_size_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_label_size_+3A_range">range</code></td>
<td>
<p>a numeric vector of length 2 that specifies the minimum and
maximum size of the plotting symbol after transformation.</p>
</td></tr>
<tr><td><code id="scale_label_size_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="scale_label_size_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_label_size_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+continuous_scale">continuous_scale</a></code>
</p>

<dl>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>na.value</code></dt><dd><p>Missing values will be replaced with this value.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_label_size_+3A_n.breaks">n.breaks</code></td>
<td>
<p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</td></tr>
<tr><td><code id="scale_label_size_+3A_nice.breaks">nice.breaks</code></td>
<td>
<p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</td></tr>
<tr><td><code id="scale_label_size_+3A_values">values</code></td>
<td>
<p>a set of aesthetic values to map data values to. The values
will be matched in order (usually alphabetical) with the limits of the
scale, or with <code>breaks</code> if provided. If this is a named vector, then the
values will be matched based on the names instead. Data values that don't
match will be given <code>na.value</code>.</p>
</td></tr>
<tr><td><code id="scale_label_size_+3A_na.value">na.value</code></td>
<td>
<p>The aesthetic value to use for missing (<code>NA</code>) values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object inheriting from <code>Scale</code>
</p>


<h3>See Also</h3>

<p>Other scale_edge_*: 
<code><a href="#topic+scale_edge_alpha">scale_edge_alpha</a>()</code>,
<code><a href="#topic+scale_edge_colour">scale_edge_colour</a></code>,
<code><a href="#topic+scale_edge_fill">scale_edge_fill</a></code>,
<code><a href="#topic+scale_edge_linetype">scale_edge_linetype</a>()</code>,
<code><a href="#topic+scale_edge_shape">scale_edge_shape</a>()</code>,
<code><a href="#topic+scale_edge_size">scale_edge_size</a>()</code>,
<code><a href="#topic+scale_edge_width">scale_edge_width</a>()</code>
</p>

<hr>
<h2 id='scale_type.ggraph_geometry'>Define default scale type for geometry</h2><span id='topic+scale_type.ggraph_geometry'></span>

<h3>Description</h3>

<p>This function is quite useless as geometry is not meant to be scaled, but it
is a requirement for ggplot2 to handle it correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggraph_geometry'
scale_type(x)
</code></pre>

<hr>
<h2 id='StatFilter'>ggraph extensions to ggplot2</h2><span id='topic+StatFilter'></span><span id='topic+StatReverse'></span><span id='topic+StatFilterSf'></span><span id='topic+FacetEdges'></span><span id='topic+FacetGraph'></span><span id='topic+FacetNodes'></span><span id='topic+StatAxisHive'></span><span id='topic+GeomAxisHive'></span><span id='topic+StatConnBundle'></span><span id='topic+StatConnBundle2'></span><span id='topic+StatConnBundle0'></span><span id='topic+GeomEdgePath'></span><span id='topic+GeomEdgeParallelPath'></span><span id='topic+GeomEdgeSegment'></span><span id='topic+GeomEdgeParallelSegment'></span><span id='topic+GeomEdgeSpanPath'></span><span id='topic+GeomEdgeSpanSegment'></span><span id='topic+GeomEdgePoint'></span><span id='topic+GeomEdgeTile'></span><span id='topic+GeomEdgeBezier'></span><span id='topic+GeomEdgeBspline'></span><span id='topic+StatEdgeArc'></span><span id='topic+StatEdgeArc2'></span><span id='topic+StatEdgeArc0'></span><span id='topic+StatEdgeBend'></span><span id='topic+StatEdgeBend2'></span><span id='topic+StatEdgeBend0'></span><span id='topic+StatEdgeBundleForce'></span><span id='topic+StatEdgeBundleForce2'></span><span id='topic+StatEdgeBundleForce0'></span><span id='topic+StatEdgeBundleMinimal'></span><span id='topic+StatEdgeBundleMinimal2'></span><span id='topic+StatEdgeBundleMinimal0'></span><span id='topic+StatEdgeBundlePath'></span><span id='topic+StatEdgeBundlePath2'></span><span id='topic+StatEdgeBundlePath0'></span><span id='topic+StatEdgeDensity'></span><span id='topic+GeomEdgeDensity'></span><span id='topic+StatEdgeDiagonal'></span><span id='topic+StatEdgeDiagonal2'></span><span id='topic+StatEdgeDiagonal0'></span><span id='topic+StatEdgeElbow'></span><span id='topic+StatEdgeElbow2'></span><span id='topic+StatEdgeElbow0'></span><span id='topic+StatEdgeFan'></span><span id='topic+StatEdgeFan2'></span><span id='topic+StatEdgeFan0'></span><span id='topic+StatEdgeHive'></span><span id='topic+StatEdgeHive2'></span><span id='topic+StatEdgeHive0'></span><span id='topic+StatEdgeLink'></span><span id='topic+StatEdgeLink2'></span><span id='topic+StatEdgeLoop'></span><span id='topic+StatEdgeLoop0'></span><span id='topic+StatEdgeParallel'></span><span id='topic+StatEdgeParallel2'></span><span id='topic+StatEdgeParallel0'></span><span id='topic+GeomEdgeSf'></span><span id='topic+StatNodeArcBar'></span><span id='topic+StatNodeCircle'></span><span id='topic+GeomNodeTile'></span><span id='topic+StatNodeVoronoi'></span><span id='topic+ggraph-extensions'></span>

<h3>Description</h3>

<p>This help page lists all exported ggproto classes defined by ggraph. In
general these should be of no concern to the user as the main interface to
the functionality is, as with ggplot2, the <code style="white-space: pre;">&#8288;geom_*&#8288;</code> format. As opposed
to ggplot2 there really aren't any use for separate <code style="white-space: pre;">&#8288;stat_*&#8288;</code> functions
as they are intimately linked to each geom and mixing and matching stats and
geoms would only cause a lot of trouble.
</p>


<h3>Details</h3>

<p>Many of the <code style="white-space: pre;">&#8288;geom_edge_*&#8288;</code> geoms comes in different flavors dependent on
the functionality required. There will always be a base geom and some will
have a <code>geom_edge_*0</code> and <code>geom_edge_*2</code> version. The base geom
will, in the case of multiple versions, draw the edge as a sequence of small
segments. The different aesthetics will be repeated for each segment and a
counter will be added the enumerates the progression of segments, so that a
gradient of colour or size can be added along the edge by assigning the
respective aesthetic to <code>after_stat(index)</code>. <code>geom_edge_*2</code> will also draw
the edge as segments but will interpolate between the aesthetics at the end
points. This makes it possible for an edge to interpolate node properties of
its end nodes. <code>geom_edge_*2</code> is less performant than the base geom so
use only when interpolation is needed. <code>geom_edge_*0</code> is a
high-performance version that usually maps directly to a grid grob. It does
not allow for drawing gradients or interpolations though, so use only for
simple edge drawings.
</p>

<hr>
<h2 id='theme_graph'>A theme tuned for graph visualizations</h2><span id='topic+theme_graph'></span><span id='topic+th_foreground'></span><span id='topic+th_no_axes'></span><span id='topic+set_graph_style'></span><span id='topic+unset_graph_style'></span>

<h3>Description</h3>

<p>When plotting graphs, networks, and trees the coordinate values are often of
no importance and axes are thus a distraction. <code>ggraph</code> comes with a
build-in theme that removes redundant elements in order to put focus on the
data. Furthermore the default behaviour is to use a narrow font so text takes
up less space. Theme colour is defined by a background and foreground colour
where the background defines the colour of the whole graphics area and the
foreground defines the colour of the strip and border. By default strip and
border is turned off as it is an unnecessary element unless facetting is
used. To add a foreground colour to a plot that is already using
<code>theme_graph</code> the <code>th_foreground</code> helper is provided. In order to
use this appearance as default use the <code>set_graph_style</code> function. An
added benefit of this is that it also changes the default text-related values
in the different geoms for a completely coherent look.
<code>unset_graph_style</code> can be used to revert the defaults back to their
default settings (that is, they are not necessarily reverted back to what
they were prior to calling <code>set_graph_style</code>). The <code>th_no_axes()</code> helper is
provided to modify an existing theme so that grid and axes are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_graph(
  base_family = "Arial Narrow",
  base_size = 11,
  background = "white",
  foreground = NULL,
  border = TRUE,
  text_colour = "black",
  bg_text_colour = text_colour,
  fg_text_colour = text_colour,
  title_family = base_family,
  title_size = 18,
  title_face = "bold",
  title_margin = 10,
  title_colour = bg_text_colour,
  subtitle_family = base_family,
  subtitle_size = 12,
  subtitle_face = "plain",
  subtitle_margin = 15,
  subtitle_colour = bg_text_colour,
  strip_text_family = base_family,
  strip_text_size = 10,
  strip_text_face = "bold",
  strip_text_colour = fg_text_colour,
  caption_family = base_family,
  caption_size = 9,
  caption_face = "italic",
  caption_margin = 10,
  caption_colour = bg_text_colour,
  plot_margin = margin(30, 30, 30, 30)
)

th_foreground(foreground = "grey80", fg_text_colour = NULL, border = FALSE)

th_no_axes()

set_graph_style(
  family = "Arial Narrow",
  face = "plain",
  size = 11,
  text_size = 11,
  text_colour = "black",
  ...
)

unset_graph_style()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_graph_+3A_base_size">base_size</code>, <code id="theme_graph_+3A_size">size</code>, <code id="theme_graph_+3A_text_size">text_size</code>, <code id="theme_graph_+3A_title_size">title_size</code>, <code id="theme_graph_+3A_subtitle_size">subtitle_size</code>, <code id="theme_graph_+3A_strip_text_size">strip_text_size</code>, <code id="theme_graph_+3A_caption_size">caption_size</code></td>
<td>
<p>The size to use for the various text elements. <code>text_size</code> will be used as geom defaults</p>
</td></tr>
<tr><td><code id="theme_graph_+3A_background">background</code></td>
<td>
<p>The colour to use for the background. This theme sets all
background elements except for plot.background to <code>element_blank</code> so
this controls the background for all elements of the plot. Set to <code>NA</code>
to remove the background (thus making the plot transparent)</p>
</td></tr>
<tr><td><code id="theme_graph_+3A_foreground">foreground</code></td>
<td>
<p>The colour of foreground elements, specifically strip and
border. Set to <code>NA</code> to remove.</p>
</td></tr>
<tr><td><code id="theme_graph_+3A_border">border</code></td>
<td>
<p>Logical. Should border be drawn if a foreground colour is
provided?</p>
</td></tr>
<tr><td><code id="theme_graph_+3A_text_colour">text_colour</code>, <code id="theme_graph_+3A_bg_text_colour">bg_text_colour</code>, <code id="theme_graph_+3A_fg_text_colour">fg_text_colour</code>, <code id="theme_graph_+3A_title_colour">title_colour</code>, <code id="theme_graph_+3A_subtitle_colour">subtitle_colour</code>, <code id="theme_graph_+3A_strip_text_colour">strip_text_colour</code>, <code id="theme_graph_+3A_caption_colour">caption_colour</code></td>
<td>
<p>The colour of the text in the various text elements</p>
</td></tr>
<tr><td><code id="theme_graph_+3A_title_margin">title_margin</code>, <code id="theme_graph_+3A_subtitle_margin">subtitle_margin</code>, <code id="theme_graph_+3A_caption_margin">caption_margin</code></td>
<td>
<p>The margin to use between the text elements and the plot area</p>
</td></tr>
<tr><td><code id="theme_graph_+3A_plot_margin">plot_margin</code></td>
<td>
<p>The plot margin</p>
</td></tr>
<tr><td><code id="theme_graph_+3A_family">family</code>, <code id="theme_graph_+3A_base_family">base_family</code>, <code id="theme_graph_+3A_title_family">title_family</code>, <code id="theme_graph_+3A_subtitle_family">subtitle_family</code>, <code id="theme_graph_+3A_strip_text_family">strip_text_family</code>, <code id="theme_graph_+3A_caption_family">caption_family</code></td>
<td>
<p>The font to use for the different elements</p>
</td></tr>
<tr><td><code id="theme_graph_+3A_face">face</code>, <code id="theme_graph_+3A_title_face">title_face</code>, <code id="theme_graph_+3A_subtitle_face">subtitle_face</code>, <code id="theme_graph_+3A_strip_text_face">strip_text_face</code>, <code id="theme_graph_+3A_caption_face">caption_face</code></td>
<td>
<p>The fontface to use for the various text elements</p>
</td></tr>
<tr><td><code id="theme_graph_+3A_...">...</code></td>
<td>
<p>Parameters passed on the <code>theme_graph</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidygraph)
graph &lt;- as_tbl_graph(highschool)

ggraph(graph) + geom_edge_link() + geom_node_point() + theme_graph()
</code></pre>

<hr>
<h2 id='whigs'>Membership network of American Whigs</h2><span id='topic+whigs'></span>

<h3>Description</h3>

<p>This dataset shows the membership of 136 colonial Americans in 5 whig
organization and is a bipartite graph. The data appeared in the appendix to
David Hackett Fischer's <em>Paul Revere's Ride</em> (Oxford University Press,
1995) and compiled by Kieran Healy for the blog post
<a href="https://kieranhealy.org/blog/archives/2013/06/09/using-metadata-to-find-paul-revere/">Using Metadata to Find Paul Revere</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whigs
</code></pre>


<h3>Format</h3>

<p>The data is stored as an incidence matrix with persons as rows and
organizations as columns. A 0 means no membership while a one means
membership.
</p>


<h3>Source</h3>

<p><a href="https://github.com/kjhealy/revere/blob/master/data/PaulRevereAppD.csv">https://github.com/kjhealy/revere/blob/master/data/PaulRevereAppD.csv</a>
adapted from:
</p>
<p>Fischer, David H. (1995) <em>Paul Revere's Ride</em>. Oxford University Press
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
