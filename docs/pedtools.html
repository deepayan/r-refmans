<!DOCTYPE html><html><head><title>Help for package pedtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pedtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pedtools-package'><p>pedtools: Creating and Working with Pedigrees and Marker Data</p></a></li>
<li><a href='#addAllele'><p>Add allele</p></a></li>
<li><a href='#as_kinship2_pedigree'><p>Convert pedigree to kinship2 format</p></a></li>
<li><a href='#as.data.frame.ped'><p>Convert ped to data.frame</p></a></li>
<li><a href='#as.matrix.ped'><p>Convert <code>ped</code> to matrix</p></a></li>
<li><a href='#as.ped'><p>Conversions to ped objects</p></a></li>
<li><a href='#connectedComponents'><p>Connected pedigree components</p></a></li>
<li><a href='#distributeMarkers'><p>Distribute markers evenly along a set of chromosomes</p></a></li>
<li><a href='#famid'><p>Family identifier</p></a></li>
<li><a href='#founderInbreeding'><p>Inbreeding coefficients of founders</p></a></li>
<li><a href='#freqDatabase'><p>Allele frequency database</p></a></li>
<li><a href='#getAlleles'><p>Allele matrix manipulation</p></a></li>
<li><a href='#getComponent'><p>Pedigree component</p></a></li>
<li><a href='#getGenotypes'><p>Genotype matrix</p></a></li>
<li><a href='#getMap'><p>Tabulate marker positions</p></a></li>
<li><a href='#getSex'><p>Get or set the sex of pedigree members</p></a></li>
<li><a href='#inbreedingLoops'><p>Pedigree loops</p></a></li>
<li><a href='#is.marker'><p>Test if something is a marker</p></a></li>
<li><a href='#is.ped'><p>Is an object a <code>ped</code> object?</p></a></li>
<li><a href='#locusAttributes'><p>Get or set locus attributes</p></a></li>
<li><a href='#marker'><p>Marker objects</p></a></li>
<li><a href='#marker_attach'><p>Attach markers to pedigrees</p></a></li>
<li><a href='#marker_getattr'><p>Get marker attributes</p></a></li>
<li><a href='#marker_inplace'><p>Set marker attributes</p></a></li>
<li><a href='#marker_prop'><p>Marker properties</p></a></li>
<li><a href='#marker_select'><p>Select or remove attached markers</p></a></li>
<li><a href='#marker_setattr'><p>Set marker attributes</p></a></li>
<li><a href='#maskPed'><p>Mask and unmask pedigree datasets</p></a></li>
<li><a href='#mendelianCheck'><p>Check for Mendelian errors</p></a></li>
<li><a href='#mergePed'><p>Merge two pedigrees</p></a></li>
<li><a href='#newMarker'><p>Internal marker constructor</p></a></li>
<li><a href='#newPed'><p>Internal ped constructor</p></a></li>
<li><a href='#nMarkers'><p>The number of markers attached to a pedigree</p></a></li>
<li><a href='#ped'><p>Pedigree construction</p></a></li>
<li><a href='#ped_basic'><p>Create simple pedigrees</p></a></li>
<li><a href='#ped_complex'><p>Complex pedigree structures</p></a></li>
<li><a href='#ped_internal'><p>Internal ordering of pedigree members</p></a></li>
<li><a href='#ped_modify'><p>Add/remove pedigree members</p></a></li>
<li><a href='#ped_subgroups'><p>Pedigree subgroups</p></a></li>
<li><a href='#ped_utils'><p>Pedigree utilities</p></a></li>
<li><a href='#plot.ped'><p>Plot pedigree</p></a></li>
<li><a href='#plotmethods'><p>Internal plot methods</p></a></li>
<li><a href='#plotPedList'><p>Plot a collection of pedigrees.</p></a></li>
<li><a href='#print.nucleus'><p>S3 methods</p></a></li>
<li><a href='#print.ped'><p>Printing pedigrees</p></a></li>
<li><a href='#randomPed'><p>Random pedigree</p></a></li>
<li><a href='#readPed'><p>Read a pedigree from file</p></a></li>
<li><a href='#relabel'><p>Get or modify pedigree labels</p></a></li>
<li><a href='#setMutmod'><p>Set a mutation model</p></a></li>
<li><a href='#setSNPs'><p>Attach SNP loci to a pedigree</p></a></li>
<li><a href='#sortGenotypes'><p>Sort the alleles in each genotype</p></a></li>
<li><a href='#transferMarkers'><p>Transfer marker data</p></a></li>
<li><a href='#validatePed'><p>Pedigree errors</p></a></li>
<li><a href='#writePed'><p>Write a pedigree to file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Creating and Working with Pedigrees and Marker Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive collection of tools for creating,
    manipulating and visualising pedigrees and genetic marker data.
    Pedigrees can be read from text files or created on the fly with
    built-in functions. A range of utilities enable modifications like
    adding or removing individuals, breaking loops, and merging pedigrees.
    An online tool for creating pedigrees interactively, based on
    'pedtools', is available at <a href="https://magnusdv.shinyapps.io/quickped">https://magnusdv.shinyapps.io/quickped</a>.
    'pedtools' is the hub of the 'pedsuite', a collection of packages for
    pedigree analysis. A detailed presentation of the 'pedsuite' is given
    in the book 'Pedigree Analysis in R' (Vigeland, 2021,
    ISBN:9780128244302).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/magnusdv/pedtools">https://github.com/magnusdv/pedtools</a>,
<a href="https://magnusdv.github.io/pedsuite/">https://magnusdv.github.io/pedsuite/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>kinship2, pedmut</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, kableExtra, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-28 11:34:23 UTC; magnu</td>
</tr>
<tr>
<td>Author:</td>
<td>Magnus Dehli Vigeland
    <a href="https://orcid.org/0000-0002-9134-4962"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Magnus Dehli Vigeland &lt;m.d.vigeland@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pedtools-package'>pedtools: Creating and Working with Pedigrees and Marker Data</h2><span id='topic+pedtools'></span><span id='topic+pedtools-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A comprehensive collection of tools for creating, manipulating and visualising pedigrees and genetic marker data. Pedigrees can be read from text files or created on the fly with built-in functions. A range of utilities enable modifications like adding or removing individuals, breaking loops, and merging pedigrees. An online tool for creating pedigrees interactively, based on 'pedtools', is available at <a href="https://magnusdv.shinyapps.io/quickped">https://magnusdv.shinyapps.io/quickped</a>. 'pedtools' is the hub of the 'pedsuite', a collection of packages for pedigree analysis. A detailed presentation of the 'pedsuite' is given in the book 'Pedigree Analysis in R' (Vigeland, 2021, ISBN:9780128244302).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Magnus Dehli Vigeland <a href="mailto:m.d.vigeland@medisin.uio.no">m.d.vigeland@medisin.uio.no</a> (<a href="https://orcid.org/0000-0002-9134-4962">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/magnusdv/pedtools">https://github.com/magnusdv/pedtools</a>
</p>
</li>
<li> <p><a href="https://magnusdv.github.io/pedsuite/">https://magnusdv.github.io/pedsuite/</a>
</p>
</li></ul>


<hr>
<h2 id='addAllele'>Add allele</h2><span id='topic+addAllele'></span>

<h3>Description</h3>

<p>Extends the allele set of a marker attached to a pedigree, by adding a single
allele.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addAllele(x, marker, allele, freq = 0.001, adjust = c("previous", "all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addAllele_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such, or a frequency database (list of
numeric vectors).</p>
</td></tr>
<tr><td><code id="addAllele_+3A_marker">marker</code></td>
<td>
<p>The name or index of a marker attached to <code>x</code>.</p>
</td></tr>
<tr><td><code id="addAllele_+3A_allele">allele</code></td>
<td>
<p>The name of the new allele.</p>
</td></tr>
<tr><td><code id="addAllele_+3A_freq">freq</code></td>
<td>
<p>The frequency of the new allele, by default 0.001.</p>
</td></tr>
<tr><td><code id="addAllele_+3A_adjust">adjust</code></td>
<td>
<p>Either &quot;previous&quot; or &quot;all&quot;, indicating how the frequencies
should be adjusted so that they sum to 1. If &quot;previous&quot; (default), the
frequencies of the original alleles are multiplied with <code>1 - freq</code>. If
&quot;all&quot;, scaling is performed after adding the new allele, i.e., dividing all
frequencies by <code>1 + freq</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> with modified marker attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Ped input
x = nuclearPed() |&gt;
  addMarker(geno = c(NA, NA, "b/c"), afreq = c(b = 0.5, c = 0.5))

y = addAllele(x, marker = 1, allele = "a")
afreq(y, 1)

z = addAllele(y, marker = 1, allele = "d", freq = 0.1, adjust = "all")
afreq(z, 1)


## Database input
db = list(M1 = c(a = .2, b = .3, c = .5),
          M2 = c("7" = .9, "8.3" = .1))
addAllele(db, marker = "M2", allele = "8")

</code></pre>

<hr>
<h2 id='as_kinship2_pedigree'>Convert pedigree to kinship2 format</h2><span id='topic+as_kinship2_pedigree'></span>

<h3>Description</h3>

<p>Convert pedigree to kinship2 format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_kinship2_pedigree(
  x,
  deceased = NULL,
  aff = NULL,
  twins = NULL,
  hints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_kinship2_pedigree_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+ped">ped()</a></code> object.</p>
</td></tr>
<tr><td><code id="as_kinship2_pedigree_+3A_deceased">deceased</code></td>
<td>
<p>A vector of labels indicating deceased pedigree members.</p>
</td></tr>
<tr><td><code id="as_kinship2_pedigree_+3A_aff">aff</code></td>
<td>
<p>A vector of labels identifying members whose plot symbols should
be filled. (This is typically used in medical pedigrees to indicate
affected members.)</p>
</td></tr>
<tr><td><code id="as_kinship2_pedigree_+3A_twins">twins</code></td>
<td>
<p>A data frame with columns <code>id1</code>, <code>id2</code> and <code>code</code>, passed on to
the <code>relation</code> parameter of <code><a href="kinship2.html#topic+plot.pedigree">kinship2::plot.pedigree()</a></code>.</p>
</td></tr>
<tr><td><code id="as_kinship2_pedigree_+3A_hints">hints</code></td>
<td>
<p>An optional list of hints passed on to
<code><a href="kinship2.html#topic+align.pedigree">kinship2::align.pedigree()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed()
as_kinship2_pedigree(x)

</code></pre>

<hr>
<h2 id='as.data.frame.ped'>Convert ped to data.frame</h2><span id='topic+as.data.frame.ped'></span>

<h3>Description</h3>

<p>Convert a <code>ped</code> object to a data.frame. The first columns are id, fid, mid
and sex, followed by genotype columns for all (or a selection of) markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ped'
as.data.frame(x, ..., markers, sep = "/", missing = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.ped_+3A_x">x</code></td>
<td>
<p>Object of class <code>ped</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ped_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
<tr><td><code id="as.data.frame.ped_+3A_markers">markers</code></td>
<td>
<p>Vector of marker names or indices. By default, all markers
are included.</p>
</td></tr>
<tr><td><code id="as.data.frame.ped_+3A_sep">sep</code></td>
<td>
<p>A single string to be used as allele separator in marker genotypes.</p>
</td></tr>
<tr><td><code id="as.data.frame.ped_+3A_missing">missing</code></td>
<td>
<p>A single string to be used for missing alleles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the output of <code><a href="#topic+as.data.frame.ped">as.data.frame.ped()</a></code> is quite different from that of
<code><a href="#topic+as.matrix.ped">as.matrix.ped()</a></code>. This reflects the fact that these functions have different
purposes.
</p>
<p>Conversion to a data frame is primarily intended for pretty printing. It uses
correct labels for pedigree members and marker alleles, and pastes alleles to
form nice-looking genotypes.
</p>
<p>The matrix method, on the other hand, is a handy tool for manipulating the
pedigree structure. It produces a numeric matrix, using the internal index
labelling both for individuals and alleles, making it very fast. In addition,
all necessary meta information (loop breakers, allele frequencies a.s.o) is
kept as attributes, which makes it possible to recreate the original <code>ped</code>
object.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with <code>pedsize(x)</code> rows and <code>4 + nMarkers(x)</code> columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.ped">as.matrix.ped()</a></code>
</p>

<hr>
<h2 id='as.matrix.ped'>Convert <code>ped</code> to matrix</h2><span id='topic+as.matrix.ped'></span><span id='topic+restorePed'></span>

<h3>Description</h3>

<p>Converts a <code>ped</code> object to a numeric matrix using internal labels, with
additional info necessary to recreate the original <code>ped</code> attached as
attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ped'
as.matrix(x, include.attrs = TRUE, ...)

restorePed(x, attrs = NULL, validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.ped_+3A_x">x</code></td>
<td>
<p>a <code>ped</code> object. In <code>restorePed</code>: A numerical matrix.</p>
</td></tr>
<tr><td><code id="as.matrix.ped_+3A_include.attrs">include.attrs</code></td>
<td>
<p>a logical indicating if marker annotations and other
info should be attached as attributes. See Value.</p>
</td></tr>
<tr><td><code id="as.matrix.ped_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="as.matrix.ped_+3A_attrs">attrs</code></td>
<td>
<p>a list containing labels and other <code>ped</code> info compatible with
<code>x</code>, in the format produced by <code>as.matrix</code>. If NULL, the attributes of <code>x</code>
itself are used.</p>
</td></tr>
<tr><td><code id="as.matrix.ped_+3A_validate">validate</code></td>
<td>
<p>a logical, forwarded to <code><a href="#topic+ped">ped()</a></code>. If FALSE, no checks for
pedigree errors are performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>restorePed</code> is the reverse of <code>as.matrix.ped</code>.
</p>


<h3>Value</h3>

<p>For <code>as.matrix</code>: A numerical matrix with <code>pedsize(x)</code> rows. If
<code>include.attrs = TRUE</code> the following attributes are added to the matrix,
allowing <code>x</code> to be exactly reproduced by <code>restorePed</code>:
</p>

<ul>
<li> <p><code>FAMID</code> the family identifier (a string)
</p>
</li>
<li> <p><code>LABELS</code> the ID labels (a character vector)
</p>
</li>
<li> <p><code>UNBROKEN_LOOPS</code> a logical indicating whether <code>x</code> has unbroken loops
</p>
</li>
<li> <p><code>LOOP_BREAKERS</code> a numerical matrix, or NULL
</p>
</li>
<li> <p><code>markerattr</code> a list of length <code>nMarkers(x)</code>, containing the attributes of
each marker
</p>
</li></ul>

<p>For <code>restorePed</code>: A <code>ped</code> object.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ped">ped()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = relabel(nuclearPed(1), letters[1:3])

# To examplify the ped -&gt; matrix -&gt; ped trick, we show how to
# reverse the internal ordering of the pedigree.
m = as.matrix(x, include.attrs = TRUE)
m[] = m[3:1, ]

# Must reverse the labels also:
attrs = attributes(m)
attrs$LABELS = rev(attrs$LABELS)

# Restore ped:
y = restorePed(m, attrs = attrs)

# Of course a simpler way is use reorderPed():
z = reorderPed(x, 3:1)
stopifnot(identical(y, z))

</code></pre>

<hr>
<h2 id='as.ped'>Conversions to ped objects</h2><span id='topic+as.ped'></span><span id='topic+as.ped.data.frame'></span>

<h3>Description</h3>

<p>Conversions to ped objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ped(x, ...)

## S3 method for class 'data.frame'
as.ped(
  x,
  famid_col = NA,
  id_col = NA,
  fid_col = NA,
  mid_col = NA,
  sex_col = NA,
  marker_col = NA,
  locusAttributes = NULL,
  missing = 0,
  sep = NULL,
  sexCodes = NULL,
  addMissingFounders = FALSE,
  validate = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ped_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
<tr><td><code id="as.ped_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.ped_+3A_famid_col">famid_col</code></td>
<td>
<p>Index of family ID column. If NA, the program looks for a
column named &quot;famid&quot; (ignoring case).</p>
</td></tr>
<tr><td><code id="as.ped_+3A_id_col">id_col</code></td>
<td>
<p>Index of individual ID column. If NA, the program looks for a
column named &quot;id&quot; (ignoring case).</p>
</td></tr>
<tr><td><code id="as.ped_+3A_fid_col">fid_col</code></td>
<td>
<p>Index of father ID column. If NA, the program looks for a
column named &quot;fid&quot; (ignoring case).</p>
</td></tr>
<tr><td><code id="as.ped_+3A_mid_col">mid_col</code></td>
<td>
<p>Index of mother ID column. If NA, the program looks for a
column named &quot;mid&quot; (ignoring case).</p>
</td></tr>
<tr><td><code id="as.ped_+3A_sex_col">sex_col</code></td>
<td>
<p>Index of column with gender codes (0 = unknown; 1 = male; 2 =
female). If NA, the program looks for a column named &quot;sex&quot; (ignoring case).
If this is not found, genders of parents are deduced from the data, leaving
the remaining as unknown.</p>
</td></tr>
<tr><td><code id="as.ped_+3A_marker_col">marker_col</code></td>
<td>
<p>Index vector indicating columns with marker alleles. If NA,
all columns to the right of all pedigree columns are used. If <code>sep</code> (see
below) is non-NULL, each column is interpreted as a genotype column and
split into separate alleles with <code>strsplit(..., split = sep, fixed = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="as.ped_+3A_locusattributes">locusAttributes</code></td>
<td>
<p>Passed on to <code><a href="#topic+setMarkers">setMarkers()</a></code> (see explanation there).</p>
</td></tr>
<tr><td><code id="as.ped_+3A_missing">missing</code></td>
<td>
<p>Passed on to <code><a href="#topic+setMarkers">setMarkers()</a></code> (see explanation there).</p>
</td></tr>
<tr><td><code id="as.ped_+3A_sep">sep</code></td>
<td>
<p>Passed on to <code><a href="#topic+setMarkers">setMarkers()</a></code> (see explanation there).</p>
</td></tr>
<tr><td><code id="as.ped_+3A_sexcodes">sexCodes</code></td>
<td>
<p>A list with optional entries &quot;male&quot;, &quot;female&quot; and &quot;unknown&quot;,
indicating how non-default entries in the <code>sex</code> column should be
interpreted. Default values: male = 1, female = 2, unknown = 0.</p>
</td></tr>
<tr><td><code id="as.ped_+3A_addmissingfounders">addMissingFounders</code></td>
<td>
<p>A logical. If TRUE, any parent not included in the
<code>id</code> column is added as a founder of corresponding sex. By default, missing
founders result in an error.</p>
</td></tr>
<tr><td><code id="as.ped_+3A_validate">validate</code></td>
<td>
<p>A logical indicating if the pedigree structure should be
validated.</p>
</td></tr>
<tr><td><code id="as.ped_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ped</code> object or a list of such.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df = data.frame(famid = c("S1", "S2"),
                id = c("A", "B"),
                fid = 0,
                mid = 0,
                sex = 1)

# gives a list of two singletons
as.ped(df)

# Trio
df1 = data.frame(id = 1:3, fid = c(0,0,1), mid = c(0,0,2), sex = c(1,2,1))
as.ped(df1)

# Disconnected example: Trio (1-3) + singleton (4)
df2 = data.frame(id = 1:4, fid = c(2,0,0,0), mid = c(3,0,0,0),
                M = c("1/2", "1/1", "2/2", "3/4"))
as.ped(df2)

# Two singletons
df3 = data.frame(id = 1:2, fid = 0, mid = 0, sex = 1)
as.ped(df3)

# Add missing parents as founders
df4 = data.frame(id = 1, fid = 2, mid = 3, sex = 1)
as.ped(df4, addMissingFounders = TRUE)

</code></pre>

<hr>
<h2 id='connectedComponents'>Connected pedigree components</h2><span id='topic+connectedComponents'></span>

<h3>Description</h3>

<p>Compute the connected parts of a pedigree. This is an important step when
converting pedigree data from other formats (where disconnected pedigrees may
be allowed) to <code>pedtools</code> (which requires pedigrees to be connected).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectedComponents(id, fid = NULL, mid = NULL, fidx = NULL, midx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connectedComponents_+3A_id">id</code></td>
<td>
<p>A vector of ID labels (character or numeric).</p>
</td></tr>
<tr><td><code id="connectedComponents_+3A_fid">fid</code></td>
<td>
<p>The ID labels of the fathers (or &quot;0&quot; if missing).</p>
</td></tr>
<tr><td><code id="connectedComponents_+3A_mid">mid</code></td>
<td>
<p>The ID labels of the mothers (or &quot;0&quot; if missing).</p>
</td></tr>
<tr><td><code id="connectedComponents_+3A_fidx">fidx</code>, <code id="connectedComponents_+3A_midx">midx</code></td>
<td>
<p>(For internal use mostly.) Integer vectors with paternal
(resp. maternal) indices. These may be given instead of <code>id</code>, <code>fid</code>, <code>mid</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, where each element is a subset of <code>id</code> constituting a
connected pedigree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A trio (1-3) and a singleton (4)
x = data.frame(id = 1:4, fid = c(2,0,0,0), mid = c(3,0,0,0))
connectedComponents(x$id, x$fid, x$mid)

</code></pre>

<hr>
<h2 id='distributeMarkers'>Distribute markers evenly along a set of chromosomes</h2><span id='topic+distributeMarkers'></span>

<h3>Description</h3>

<p>Create and attach identical (empty) marker objects, distributed along a set
of chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distributeMarkers(
  x,
  n = NULL,
  dist = NULL,
  chromLen = NULL,
  alleles = 1:2,
  afreq = NULL,
  prefix = "M"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distributeMarkers_+3A_x">x</code></td>
<td>
<p>A ped object.</p>
</td></tr>
<tr><td><code id="distributeMarkers_+3A_n">n</code></td>
<td>
<p>The total number of markers. Either this or <code>dist</code> must be NULL.</p>
</td></tr>
<tr><td><code id="distributeMarkers_+3A_dist">dist</code></td>
<td>
<p>A positive number; the distance (in megabases) between markers.</p>
</td></tr>
<tr><td><code id="distributeMarkers_+3A_chromlen">chromLen</code></td>
<td>
<p>A numeric vector indicating chromosome lengths (in Mb). By
default, the lengths of the human chromosomes 1-22 are used, as returned by
<code>sapply(ibdsim2::loadMap("decode"), ibdsim2::physRange)</code>.</p>
</td></tr>
<tr><td><code id="distributeMarkers_+3A_alleles">alleles</code>, <code id="distributeMarkers_+3A_afreq">afreq</code></td>
<td>
<p>Passed onto <code><a href="#topic+marker">marker()</a></code>.</p>
</td></tr>
<tr><td><code id="distributeMarkers_+3A_prefix">prefix</code></td>
<td>
<p>A string used as prefix for marker names. Default: &quot;M&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: When using the <code>dist</code> parameter, the function treats each chromosome
separately, places one marker at the start and then every <code>dist</code> megabases.
(See Examples.)
</p>


<h3>Value</h3>

<p>A copy of <code>x</code> with the indicated markers attached.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = distributeMarkers(nuclearPed(), n = 10)
getMap(x)

y = distributeMarkers(nuclearPed(), dist = 100)
getMap(y)
</code></pre>

<hr>
<h2 id='famid'>Family identifier</h2><span id='topic+famid'></span><span id='topic+famid.ped'></span><span id='topic+famid+3C-'></span><span id='topic+famid+3C-.ped'></span>

<h3>Description</h3>

<p>Functions for getting or setting the family ID of a <code>ped</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>famid(x, ...)

## S3 method for class 'ped'
famid(x, ...)

famid(x, ...) &lt;- value

## S3 replacement method for class 'ped'
famid(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="famid_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object</p>
</td></tr>
<tr><td><code id="famid_+3A_...">...</code></td>
<td>
<p>(Not used)</p>
</td></tr>
<tr><td><code id="famid_+3A_value">value</code></td>
<td>
<p>The new family ID, which must be (coercible to) a character
string.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(1)
famid(x) # empty string

famid(x) = "trio"
famid(x)

</code></pre>

<hr>
<h2 id='founderInbreeding'>Inbreeding coefficients of founders</h2><span id='topic+founderInbreeding'></span><span id='topic+founderInbreeding+3C-'></span><span id='topic+setFounderInbreeding'></span>

<h3>Description</h3>

<p>Functions to get or set inbreeding coefficients for the pedigree founders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>founderInbreeding(x, ids, named = FALSE, chromType = "autosomal")

founderInbreeding(x, ids, chromType = "autosomal") &lt;- value

setFounderInbreeding(x, ids = NULL, value, chromType = "autosomal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="founderInbreeding_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="founderInbreeding_+3A_ids">ids</code></td>
<td>
<p>Any subset of <code>founders(x)</code>. If <code>ids</code> is missing in
<code>founderInbreeding()</code>, it is set to <code>founders(x)</code>.</p>
</td></tr>
<tr><td><code id="founderInbreeding_+3A_named">named</code></td>
<td>
<p>A logical: If TRUE, the output vector is named with the ID
labels.</p>
</td></tr>
<tr><td><code id="founderInbreeding_+3A_chromtype">chromType</code></td>
<td>
<p>Either &quot;autosomal&quot; (default) or &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="founderInbreeding_+3A_value">value</code></td>
<td>
<p>A numeric of the same length as <code>ids</code>, entries in the interval
<code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>. If the vector is named, then the names are interpreted as ID
labels of the founders whose inbreeding coefficients should be set. In this
case, the <code>ids</code> argument should not be used. (See examples.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>founderInbreeding</code>, a numeric vector of the same length as
<code>ids</code>, containing the founder inbreeding coefficients.
</p>
<p>For <code>setFounderInbreeding()</code>, a copy of <code>x</code> with modified founder
inbreeding.
</p>
<p><code style="white-space: pre;">&#8288;founderInbreeding&lt;-&#8288;</code> is an in-place version of <code>setFounderInbreeding()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(father = "fa", mother = "mo", child = 1)
founderInbreeding(x, "fa") = 1
founderInbreeding(x, named = TRUE)

# Setting all founders at once (replacement value is recycled)
founderInbreeding(x, ids = founders(x)) = 0.5
founderInbreeding(x, named = TRUE)

# Alternative syntax, using a named vector
founderInbreeding(x) = c(fa = 0.1, mo = 0.2)
founderInbreeding(x, named = TRUE)

</code></pre>

<hr>
<h2 id='freqDatabase'>Allele frequency database</h2><span id='topic+freqDatabase'></span><span id='topic+getFreqDatabase'></span><span id='topic+setFreqDatabase'></span><span id='topic+readFreqDatabase'></span><span id='topic+writeFreqDatabase'></span>

<h3>Description</h3>

<p>Functions for reading, setting and extracting allele frequency databases, in
either &quot;list&quot; format, &quot;merlin&quot; format or &quot;allelic ladder&quot; format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFreqDatabase(x, markers = NULL, format = c("list", "ladder"))

setFreqDatabase(x, database, format = c("list", "ladder"), ...)

readFreqDatabase(
  filename = NULL,
  df = NULL,
  format = c("list", "ladder", "merlin"),
  fixNames = FALSE,
  scale1 = FALSE,
  verbose = TRUE,
  ...
)

writeFreqDatabase(x, filename, markers = NULL, format = c("list", "ladder"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqDatabase_+3A_x">x</code></td>
<td>
<p>A ped object, or a list of such.</p>
</td></tr>
<tr><td><code id="freqDatabase_+3A_markers">markers</code></td>
<td>
<p>A character vector (with marker names) or a numeric vector
(with marker indices).</p>
</td></tr>
<tr><td><code id="freqDatabase_+3A_format">format</code></td>
<td>
<p>Either &quot;list&quot;, &quot;ladder&quot; or &quot;merlin&quot; (only in
<code>readFreqDatabase()</code>).</p>
</td></tr>
<tr><td><code id="freqDatabase_+3A_database">database</code></td>
<td>
<p>Either a list or matrix/data frame with allele frequencies,
or a file path (to be passed on to <code>readFreqDatabase()</code>).</p>
</td></tr>
<tr><td><code id="freqDatabase_+3A_...">...</code></td>
<td>
<p>Optional arguments passed on to <code><a href="utils.html#topic+read.table">read.table()</a></code>, e.g. <code>sep = "\t"</code>
if the file is tab separated.</p>
</td></tr>
<tr><td><code id="freqDatabase_+3A_filename">filename</code></td>
<td>
<p>The path to a text file containing allele frequencies either
in &quot;list&quot; or &quot;allelic ladder&quot; format.</p>
</td></tr>
<tr><td><code id="freqDatabase_+3A_df">df</code></td>
<td>
<p>A data frame of allele frequencies in either &quot;list&quot; or &quot;allelic
ladder&quot; format. This can be supplied instead of <code>filename</code>.</p>
</td></tr>
<tr><td><code id="freqDatabase_+3A_fixnames">fixNames</code></td>
<td>
<p>A logical, by default FALSE. If TRUE all marker names are
converted to upper case, and all periods and space characters are replaced
with &quot;_&quot; (underscore).</p>
</td></tr>
<tr><td><code id="freqDatabase_+3A_scale1">scale1</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, all frequency vectors are
scaled to ensure that it sums to 1.</p>
</td></tr>
<tr><td><code id="freqDatabase_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A frequency database in &quot;list&quot; format is a list of numeric vectors; each
vector named with the allele labels, and the list itself named with the
marker names.
</p>
<p>Text files containing frequencies in &quot;list&quot; format should look as follows,
where &quot;M1&quot; and &quot;M2&quot; are marker names, and &quot;a1&quot;,&quot;a2&quot;,... are allele labels
(which may be characters or numeric, but will always be converted to
characters):
</p>
<pre>
M1
a1 0.2
a2 0.5
a3 0.3

M2
a1 0.9
a2 0.1
</pre>
<p>In &quot;merlin&quot; format, used by the software MERLIN (Abecasis et. al, 2002), the
same frequency data would be presented as follows:
</p>
<pre>
M M1
A a1 0.2
A a2 0.5
A a3 0.3
M M2
A a1 0.9
A a2 0.1
</pre>
<p>A database in &quot;allelic ladder&quot; format is rectangular, i.e., a numeric matrix
(or data frame), with allele labels as row names and markers as column names.
<code>NA</code> entries correspond to unobserved alleles.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>getFreqDatabase</code>: either a list (if <code>format = "list"</code>) or a data
frame (if <code>format = "ladder"</code>).
</p>
</li>
<li> <p><code>readFreqDatabase</code>: a list of named numeric vectors.
</p>
</li>
<li> <p><code>setFreqDatabase</code>: a modified version of <code>x</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+setLocusAttributes">setLocusAttributes()</a></code>, <code><a href="#topic+setMarkers">setMarkers()</a></code>, <code><a href="#topic+setAlleles">setAlleles()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loc1 = list(name = "m1", afreq = c(a = .1, b = .9))
loc2 = list(name = "m2", afreq = c("1" = .2, "10.2" = .3, "3" = .5))
x = setMarkers(singleton(1), locus = list(loc1, loc2))
db = getFreqDatabase(x)
db

y = setFreqDatabase(x, database = db)
stopifnot(identical(x, y))

# The database can also be read directly from file
tmp = tempfile()
write("m1\na 0.1\nb 0.9\n\nm2\n1 0.2\n3 0.5\n10.2 0.3", tmp)

z = setFreqDatabase(x, database = tmp)
stopifnot(all.equal(x, z))

</code></pre>

<hr>
<h2 id='getAlleles'>Allele matrix manipulation</h2><span id='topic+getAlleles'></span><span id='topic+setAlleles'></span>

<h3>Description</h3>

<p>Functions for getting and setting the genotypes of multiple
individuals/markers simultaneously
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAlleles(x, ids = NULL, markers = NULL)

setAlleles(x, ids = NULL, markers = NULL, alleles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAlleles_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such</p>
</td></tr>
<tr><td><code id="getAlleles_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels. If NULL (default) all individuals are
included.</p>
</td></tr>
<tr><td><code id="getAlleles_+3A_markers">markers</code></td>
<td>
<p>A vector of indices or names of markers attaches to <code>x</code>. If
NULL (default) all markers are included.</p>
</td></tr>
<tr><td><code id="getAlleles_+3A_alleles">alleles</code></td>
<td>
<p>A character of the same format and dimensions as the output of
<code>getAlleles(x, ids, markers)</code>, or an object which can be converted by
<code>as.matrix()</code> into such a matrix. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>alleles</code> argument of <code>setAlleles()</code> is not a matrix, it is recycled
(if necessary), and converted into a matrix of the correct dimensions. For
example, setting <code>alleles = 0</code> gives a simple way of removing the genotypes
of some or all individuals (while keeping the markers attached).
</p>


<h3>Value</h3>

<p><code>getAlleles()</code> returns a character matrix with <code>length(ids)</code> rows and
<code>2 * length(markers)</code> columns. The ID labels of <code>x</code> are used as rownames,
while the columns are named <code style="white-space: pre;">&#8288;&lt;m1&gt;.1&#8288;</code>, <code style="white-space: pre;">&#8288;&lt;m1&gt;.2&#8288;</code>, ... where <code style="white-space: pre;">&#8288;&lt;m1&gt;&#8288;</code> is the
name of the first marker, a.s.o.
</p>
<p><code>setAlleles()</code> returns a <code>ped</code> object identical to <code>x</code>, except for the
modified alleles. In particular, all locus attributes are unchanged.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transferMarkers">transferMarkers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup: Pedigree with two markers
x = nuclearPed(1)
x = addMarker(x, `2` = "1/2", alleles = 1:2, name = "m1")
x = addMarker(x, `3` = "2/2", alleles = 1:2, name = "m2")

# Extract allele matrix
mat1 = getAlleles(x)
mat2 = getAlleles(x, ids = 2:3, markers = "m2")
stopifnot(identical(mat1[2:3, 3:4], mat2))

# Remove all genotypes
y = setAlleles(x, alleles = 0)
y

# Setting a single genotype
z = setAlleles(y, ids = "1", marker = "m2", alleles = 1:2)

# Alternative: In-place modification with `genotype()`
genotype(y, id = "1", marker = "m2") = "1/2"
stopifnot(identical(y,z))


### Manipulation of pedlist objects
s = transferMarkers(x, singleton("s"))
peds = list(x, s)

getAlleles(peds)

setAlleles(peds, ids = "s", marker = "m1", alleles = 1:2)

</code></pre>

<hr>
<h2 id='getComponent'>Pedigree component</h2><span id='topic+getComponent'></span>

<h3>Description</h3>

<p>Given a list of <code>ped</code> objects (called pedigree components), and a vector of
ID labels, find the index of the component holding each individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getComponent(x, ids, checkUnique = FALSE, errorIfUnknown = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getComponent_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object, or a list of such.</p>
</td></tr>
<tr><td><code id="getComponent_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels (coercible to character).</p>
</td></tr>
<tr><td><code id="getComponent_+3A_checkunique">checkUnique</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, an error is raised
if any element of <code>ids</code> occurs more than once in <code>x</code>.</p>
</td></tr>
<tr><td><code id="getComponent_+3A_errorifunknown">errorIfUnknown</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, the function
stops with an error if not all elements of <code>ids</code> are found in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of the same length as <code>ids</code>, with NA entries where
the corresponding label was not found in any of the components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+internalID">internalID()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = list(nuclearPed(1), singleton(id = "A"))
getComponent(x, c(3, "A"))

</code></pre>

<hr>
<h2 id='getGenotypes'>Genotype matrix</h2><span id='topic+getGenotypes'></span>

<h3>Description</h3>

<p>Extract the genotypes of multiple individuals/markers in form of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGenotypes(x, ids = NULL, markers = NULL, sep = "/", missing = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGenotypes_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such</p>
</td></tr>
<tr><td><code id="getGenotypes_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels. If NULL (default) all individuals are
included.</p>
</td></tr>
<tr><td><code id="getGenotypes_+3A_markers">markers</code></td>
<td>
<p>A vector of indices or names of markers attaches to <code>x</code>. If
NULL (default) all markers are included.</p>
</td></tr>
<tr><td><code id="getGenotypes_+3A_sep">sep</code></td>
<td>
<p>A single string to be used as allele separator in marker
genotypes.</p>
</td></tr>
<tr><td><code id="getGenotypes_+3A_missing">missing</code></td>
<td>
<p>A single string to be used for missing alleles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getGenotypes()</code> returns a character matrix with <code>length(ids)</code> rows
and <code>length(markers)</code> columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAlleles">getAlleles()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed() |&gt;
  addMarker(`2` = "1/2", name = "m1") |&gt;
  addMarker(`3` = "a/a", name = "m2")

getGenotypes(x)

### A list of pedigrees

s = transferMarkers(x, singleton("s"))
peds = list(x, s)

getGenotypes(peds)

</code></pre>

<hr>
<h2 id='getMap'>Tabulate marker positions</h2><span id='topic+getMap'></span><span id='topic+setMap'></span><span id='topic+hasLinkedMarkers'></span>

<h3>Description</h3>

<p>Return a map of the markers attached to a pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMap(x, markers = NULL, na.action = 0, merlin = FALSE, verbose = TRUE)

setMap(x, map, matchNames = NA, ...)

hasLinkedMarkers(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMap_+3A_x">x</code></td>
<td>
<p>An object of class <code>ped</code> or a list of such.</p>
</td></tr>
<tr><td><code id="getMap_+3A_markers">markers</code></td>
<td>
<p>A vector of names or indices referring to markers attached to
<code>x</code>. By default, all markers are included.</p>
</td></tr>
<tr><td><code id="getMap_+3A_na.action">na.action</code></td>
<td>
<p>Either 0 (default), 1 or 2. (See Details.)</p>
</td></tr>
<tr><td><code id="getMap_+3A_merlin">merlin</code></td>
<td>
<p>A logical mostly for internal use: If TRUE the function returns
a matrix instead of a data frame.</p>
</td></tr>
<tr><td><code id="getMap_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="getMap_+3A_map">map</code></td>
<td>
<p>Either a data frame or the path to a map file. See Details
regarding format.</p>
</td></tr>
<tr><td><code id="getMap_+3A_matchnames">matchNames</code></td>
<td>
<p>A logical; if TRUE, pre-existing marker names of <code>x</code> will
be used to assign chromosome labels and positions from <code>map</code>.</p>
</td></tr>
<tr><td><code id="getMap_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>read.table()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>na.action</code> argument controls how missing values are dealt with:
</p>

<ul>
<li> <p><code>na.action</code> = 0: Return map unmodified
</p>
</li>
<li> <p><code>na.action</code> = 1: Replace missing values with dummy values.
</p>
</li>
<li> <p><code>na.action</code> = 2: Remove markers with missing data.
</p>
</li></ul>

<p>In <code>setMap()</code>, the <code>map</code> argument should be a data frame (or file) with the
following columns in order:
</p>

<ol>
<li><p> chromosome
</p>
</li>
<li><p> marker name
</p>
</li>
<li><p> position (Mb)
</p>
</li></ol>

<p>Column names are ignored, as are any columns after the first three.
</p>


<h3>Value</h3>

<p><code>getMap()</code> returns a data frame with columns <code>CHROM</code>, <code>MARKER</code> and
<code>MB</code>.
</p>
<p><code>setMap()</code> returns <code>x</code> with modified marker attributes.
</p>
<p><code>hasLinkedMarkers()</code> returns TRUE if two markers are located (with set
position) on the same chromosome, and FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = singleton(1)
m1 = marker(x, chrom = 1, posMb = 10, name = "m1")
m2 = marker(x, chrom = 1, posMb = 11)
m3 = marker(x, chrom = 1)
x = setMarkers(x, list(m1, m2, m3))

# Compare effect of `na.action`
getMap(x, na.action = 0)
getMap(x, na.action = 1)
getMap(x, na.action = 2)

# Getting and setting map are inverses
y = setMap(x, getMap(x))
stopifnot(identical(x,y))

hasLinkedMarkers(x)

</code></pre>

<hr>
<h2 id='getSex'>Get or set the sex of pedigree members</h2><span id='topic+getSex'></span><span id='topic+setSex'></span><span id='topic+swapSex'></span>

<h3>Description</h3>

<p>Functions for retrieving or changing the sex of specified pedigree members.
When used in pedigree constructions, <code>swapSex()</code> is usually more convenient
than <code>setSex()</code>, since it deals with spouses automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSex(x, ids = NULL, named = FALSE)

setSex(x, ids = NULL, sex)

swapSex(x, ids, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSex_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="getSex_+3A_ids">ids</code></td>
<td>
<p>A vector identifying members of <code>x</code>, or a function, in which case
it is replaced with <code>ids(x)</code> labels. If NULL, defaults to all members of
<code>x</code>.</p>
</td></tr>
<tr><td><code id="getSex_+3A_named">named</code></td>
<td>
<p>A logical: return a named vector or not.</p>
</td></tr>
<tr><td><code id="getSex_+3A_sex">sex</code></td>
<td>
<p>A numeric vector with entries 1 (= male), 2 (= female) or 0 (=
unknown). If <code>ids</code> is NULL, <code>sex</code> must be named with ID labels. If <code>sex</code> is
unnamed and shorter than <code>ids</code> it is recycled to <code>length(ids)</code>.</p>
</td></tr>
<tr><td><code id="getSex_+3A_verbose">verbose</code></td>
<td>
<p>A logical: Verbose output or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To set unknown sex, use <code>setSex(x, ids, sex = 0)</code>. Note that if a nonfounder
has unknown sex the pedigree cannot be plotted in the usual way, only with
<code>plot(x, arrows = TRUE)</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>getSex(x, ids)</code> returns an integer vector of the same length as <code>ids</code>,
with entries 0 (unknown), 1 (male) or 2 (female).
</p>
</li>
<li> <p><code>setSex(x, ids, sex)</code> returns a ped object similar to <code>x</code>, but where the
sex of <code>ids</code> is set according to the entries of <code>sex</code>
</p>
</li>
<li> <p><code>swapSex(x, ids)</code> returns a ped object identical to <code>x</code>, but where the sex
of <code>ids</code> (and their spouses) are swapped (1 &lt;-&gt; 2). Individuals of unknown
sex are ignored.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ped">ped()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(father = "fa", mother = "mo", children = "ch")

stopifnot(all.equal(
  getSex(x, named = TRUE),
  c(fa = 1, mo = 2, ch = 1)
))

# Make child female
setSex(x, ids = "ch", sex = 2)

# Same, using a named vector
setSex(x, sex = c(ch = 2))

# Same, using a function (setting all leaves to be female)
setSex(x, ids = leaves, sex = 2)

# swapSex() deals with spouses automatically
swapSex(x, ids = "fa")

# setting/getting sex in a pedlist
y = singletons(id = 1:3, sex = c(2,1,1))
sx = getSex(y, named = TRUE)
y2 = setSex(y, sex = sx)

stopifnot(identical(y, y2))

</code></pre>

<hr>
<h2 id='inbreedingLoops'>Pedigree loops</h2><span id='topic+inbreedingLoops'></span><span id='topic+breakLoops'></span><span id='topic+tieLoops'></span><span id='topic+findLoopBreakers'></span><span id='topic+findLoopBreakers2'></span>

<h3>Description</h3>

<p>Functions for identifying, breaking and restoring loops in pedigrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inbreedingLoops(x)

breakLoops(x, loopBreakers = NULL, verbose = TRUE, errorIfFail = TRUE)

tieLoops(x, verbose = TRUE)

findLoopBreakers(x)

findLoopBreakers2(x, errorIfFail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inbreedingLoops_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+ped">ped()</a></code> object.</p>
</td></tr>
<tr><td><code id="inbreedingLoops_+3A_loopbreakers">loopBreakers</code></td>
<td>
<p>either NULL (resulting in automatic selection of loop
breakers) or a numeric containing IDs of individuals to be used as loop
breakers.</p>
</td></tr>
<tr><td><code id="inbreedingLoops_+3A_verbose">verbose</code></td>
<td>
<p>a logical: Verbose output or not?</p>
</td></tr>
<tr><td><code id="inbreedingLoops_+3A_erroriffail">errorIfFail</code></td>
<td>
<p>a logical: If TRUE an error is raised if the loop breaking
is unsuccessful. If FALSE, the pedigree is returned unchanged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pedigree loops are usually handled (by pedtools and related packages) under
the hood - using the functions described here - without need for explicit
action from end users. When a ped object <code>x</code> is created, an internal routine
detects if the pedigree contains loops, in which case <code>x$UNBROKEN_LOOPS</code> is
set to TRUE.
</p>
<p>In cases with complex inbreeding, it can be instructive to plot the pedigree
after breaking the loops. Duplicated individuals are plotted with appropriate
labels (see examples).
</p>
<p>The function <code>findLoopBreakers</code> identifies a set of individuals breaking all
inbreeding loops, but not marriage loops. These require more machinery for
efficient detection, and pedtools does this is a separate function,
<code>findLoopBreakers2</code>, utilizing methods from the <code>igraph</code> package. Since this
is rarely needed for most users, <code>igraph</code> is not imported when loading
pedtools, only when <code>findLoopBreakers2</code> is called.
</p>
<p>In practice, <code>breakLoops</code> first calls <code>findLoopBreakers</code> and breaks at the
returned individuals. If the resulting ped object still has loops,
<code>findLoopBreakers2</code> is called to break any marriage loops.
</p>


<h3>Value</h3>

<p>For <code>breakLoops</code>, a <code>ped</code> object in which the indicated loop breakers
are duplicated. The returned object will also have a non-null
<code>loopBreakers</code> entry, namely a matrix with the IDs of the original loop
breakers in the first column and the duplicates in the second. If loop
breaking fails, then depending on <code>errorIfFail</code> either an error is raised,
or the input pedigree is returned, still containing unbroken loops.
</p>
<p>For <code>tieLoops</code>, a <code>ped</code> object in which any duplicated individuals (as
given in the <code>x$LOOP_BREAKERS</code> entry) are merged. For any ped object <code>x</code>,
the call <code>tieLoops(breakLoops(x))</code> should return <code>x</code>.
</p>
<p>For <code>inbreedingLoops</code>, a list containing all inbreeding loops (not marriage
loops) found in the pedigree. Each loop is represented as a list with
elements <code>top</code>, <code>bottom</code>, <code>pathA</code> (individuals forming a path from top to
bottom) and <code>pathB</code> (creating a different path from top to bottom, with no
individuals in common with <code>pathA</code>). Note that the number of loops reported
here counts all closed paths in the pedigree and will in general be larger
than the genus of the underlying graph.
</p>
<p>For <code>findLoopBreakers</code> and <code>findLoopBreakers2</code>, a numeric vector of
individual ID's.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = cousinPed(1, child = TRUE)
plot(breakLoops(x))

# Pedigree with marriage loop: Double first cousins
if(requireNamespace("igraph", quietly = TRUE)) {
  y = doubleCousins(1, 1, child = TRUE)
  findLoopBreakers(y) # --&gt; 9
  findLoopBreakers2(y) # --&gt; 7 and 9
  y2 = breakLoops(y)
  plot(y2)

  # Or loop breakers chosen by user
  y3 = breakLoops(y, 6:7)
  plot(y3)
}

</code></pre>

<hr>
<h2 id='is.marker'>Test if something is a marker</h2><span id='topic+is.marker'></span><span id='topic+is.markerList'></span>

<h3>Description</h3>

<p>Functions for testing if something is a <code>marker</code> object, or a list of such
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.marker(x)

is.markerList(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.marker_+3A_x">x</code></td>
<td>
<p>Any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical
</p>

<hr>
<h2 id='is.ped'>Is an object a <code>ped</code> object?</h2><span id='topic+is.ped'></span><span id='topic+is.singleton'></span><span id='topic+is.pedList'></span>

<h3>Description</h3>

<p>Functions for checking whether an object is a <code><a href="#topic+ped">ped()</a></code> object, a <code><a href="#topic+singleton">singleton()</a></code>
or a list of such.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ped(x)

is.singleton(x)

is.pedList(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ped_+3A_x">x</code></td>
<td>
<p>Any <code>R</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>singleton</code> class inherits from <code>ped</code>, so if <code>x</code> is a
singleton, <code>is.ped(x)</code> returns TRUE.
</p>


<h3>Value</h3>

<p>For <code>is.ped()</code>: TRUE if <code>x</code> is a <code>ped</code> or <code>singleton</code> object, otherwise FALSE.
</p>
<p>For <code>is.singleton()</code>: TRUE if <code>x</code> is a <code>singleton</code> object, otherwise FALSE.
</p>
<p>For <code>is.pedList()</code>: TRUE if <code>x</code> is a list of <code>ped</code> and/or <code>singleton</code>
objects, otherwise FALSE.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ped">ped()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1 = nuclearPed(1)
x2 = singleton(1)
stopifnot(is.ped(x1), !is.singleton(x1),
          is.ped(x2), is.singleton(x2),
          is.pedList(list(x1,x2)))

</code></pre>

<hr>
<h2 id='locusAttributes'>Get or set locus attributes</h2><span id='topic+locusAttributes'></span><span id='topic+getLocusAttributes'></span><span id='topic+setLocusAttributes'></span>

<h3>Description</h3>

<p>Retrieve or modify the attributes of attached markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLocusAttributes(
  x,
  markers = NULL,
  checkComps = FALSE,
  attribs = c("alleles", "afreq", "name", "chrom", "posMb", "mutmod")
)

setLocusAttributes(
  x,
  markers = NULL,
  locusAttributes,
  matchNames = NA,
  erase = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locusAttributes_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object, or a list of such.</p>
</td></tr>
<tr><td><code id="locusAttributes_+3A_markers">markers</code></td>
<td>
<p>A character vector (with marker names) or a numeric vector
(with marker indices). If NULL (default), the behaviour depends on
<code>matchNames</code>, see Details.</p>
</td></tr>
<tr><td><code id="locusAttributes_+3A_checkcomps">checkComps</code></td>
<td>
<p>A logical. If TRUE, and <code>x</code> is a list of pedigrees, an
error is raised if marker attributes differ between components.</p>
</td></tr>
<tr><td><code id="locusAttributes_+3A_attribs">attribs</code></td>
<td>
<p>A subset of the character vector <code>c("alleles", "afreq", "name" ,"chrom" ,"posMb", "mutmod", "rate")</code>.</p>
</td></tr>
<tr><td><code id="locusAttributes_+3A_locusattributes">locusAttributes</code></td>
<td>
<p>A list of lists, with attributes for each marker.</p>
</td></tr>
<tr><td><code id="locusAttributes_+3A_matchnames">matchNames</code></td>
<td>
<p>A logical, only relevant if <code>markers = NULL</code>. If TRUE, then
the markers to be modified are identified by the 'name' component of each
<code>locusAttributes</code> entry. If FALSE, all markers attached to <code>x</code> are selected
in order.</p>
</td></tr>
<tr><td><code id="locusAttributes_+3A_erase">erase</code></td>
<td>
<p>A logical. If TRUE, all previous attributes of the selected
markers are erased. If FALSE, attributes not affected by the submitted
<code>locusAttributes</code> remain untouched.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default setting <code>markers = NULL</code> select markers automatically, depending
on the <code>matchNames</code> argument. If <code>matchNames = FALSE</code>, all markers are chosen
If <code>matchNames = TRUE</code>, markers will be matched against the <code>name</code> entries in
<code>locusAttributes</code> (and an error issued if these are missing).
</p>
<p>Note that the default value <code>NA</code> of <code>matchNames</code> is changed to TRUE if all
entries of <code>locusAttributes</code> have a <code>name</code> component which matches the name a
an attached marker.
</p>
<p>Possible attributes given in <code>locusAttributes</code> are as follows (default values
in parenthesis):
</p>

<ul>
<li> <p><code>alleles</code> : a character vector with allele labels
</p>
</li>
<li> <p><code>afreq</code> :  a numeric vector with allele frequencies (<code>rep.int(1/L, L)</code>,
where <code>L = length(alleles)</code>)
</p>
</li>
<li> <p><code>name</code> : marker name (NA)
</p>
</li>
<li> <p><code>chrom</code> : chromosome number (NA)
</p>
</li>
<li> <p><code>posMb</code> : physical location in megabases (NA)
</p>
</li>
<li> <p><code>mutmod</code> : mutation model, or model name (NULL)
</p>
</li>
<li> <p><code>rate</code> : mutation model parameter (NULL)
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>getLocusAttributes</code> : a list of lists
</p>
</li>
<li> <p><code>setLocusAttributes</code> : a modified version of <code>x</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x = singleton(1)
x = addMarkers(x, marker(x, name = "m1", alleles = 1:2))
x = addMarkers(x, marker(x, name = "m2", alleles = letters[1:2], chrom = "X"))

# Change frequencies at both loci
y = setLocusAttributes(x, markers = 1:2, loc = list(afreq = c(.1, .9)))
getMarkers(y, 1)

# Set the same mutation model at both loci
z = setLocusAttributes(x, markers = 1:2, loc = list(mutmod = "proportional", rate = .1))
mutmod(z, 1)

# By default, the markers to be modified are identified by name
locs = list(list(name = "m1", alleles = 1:10),
            list(name = "m2", alleles = letters[1:10]))
w = setLocusAttributes(x, loc = locs)
getMarkers(w, 1:2)

# If `erase = TRUE` attributes not explicitly given are erased
w2 = setLocusAttributes(x, loc = locs, erase = TRUE)
chrom(w2, 2) # not "X" anymore

# The getter and setter are inverses
newx = setLocusAttributes(x, loc = getLocusAttributes(x))
stopifnot(identical(x, newx))

</code></pre>

<hr>
<h2 id='marker'>Marker objects</h2><span id='topic+marker'></span><span id='topic+addMarker'></span>

<h3>Description</h3>

<p>Creating a marker object associated with a pedigree. The function <code>marker()</code>
returns a marker object, while <code>addMarker()</code> first creates the marker and
then attaches it to <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker(
  x,
  ...,
  geno = NULL,
  allelematrix = NULL,
  alleles = NULL,
  afreq = NULL,
  chrom = NA,
  posMb = NA,
  name = NA,
  mutmod = NULL,
  rate = NULL,
  NAstrings = c(0, "", NA, "-"),
  validate = TRUE,
  validateMut = validate
)

addMarker(
  x,
  ...,
  geno = NULL,
  allelematrix = NULL,
  alleles = NULL,
  afreq = NULL,
  chrom = NA,
  posMb = NA,
  name = NA,
  mutmod = NULL,
  rate = NULL,
  locusAttr = NULL,
  NAstrings = c(0, "", NA, "-"),
  validate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="marker_+3A_...">...</code></td>
<td>
<p>One or more expressions of the form <code>id = genotype</code>, where <code>id</code> is
the ID label of a member of <code>x</code>, and <code>genotype</code> is a numeric or character
vector of length 1 or 2 (see Examples).</p>
</td></tr>
<tr><td><code id="marker_+3A_geno">geno</code></td>
<td>
<p>A character vector of length <code>pedsize(x)</code>, with genotypes written
in the format &quot;a/b&quot;.</p>
</td></tr>
<tr><td><code id="marker_+3A_allelematrix">allelematrix</code></td>
<td>
<p>A matrix with 2 columns and <code>pedsize(x)</code> rows. If this is
non-NULL, then <code>...</code> must be empty.</p>
</td></tr>
<tr><td><code id="marker_+3A_alleles">alleles</code></td>
<td>
<p>A character containing allele names. If not given, and <code>afreq</code>
is named, <code>names(afreq)</code> is used. The default action is to take the sorted
vector of distinct alleles occurring in <code>allelematrix</code>, <code>geno</code> or <code>...</code>.</p>
</td></tr>
<tr><td><code id="marker_+3A_afreq">afreq</code></td>
<td>
<p>A numeric of the same length as <code>alleles</code>, indicating the
population frequency of each allele. A warning is issued if the frequencies
don't sum to 1 after rounding to 3 decimals. If the vector is named, and
<code>alleles</code> is not NULL, an error is raised if <code>setequal(names(afreq), alleles)</code> is not TRUE. If <code>afreq</code> is not specified, all alleles are given
equal frequencies.</p>
</td></tr>
<tr><td><code id="marker_+3A_chrom">chrom</code></td>
<td>
<p>A single integer: the chromosome number. Default: NA.</p>
</td></tr>
<tr><td><code id="marker_+3A_posmb">posMb</code></td>
<td>
<p>A nonnegative real number: the physical position of the marker,
in megabases. Default: NA.</p>
</td></tr>
<tr><td><code id="marker_+3A_name">name</code></td>
<td>
<p>A character string: the name of the marker. Default: NA.</p>
</td></tr>
<tr><td><code id="marker_+3A_mutmod">mutmod</code>, <code id="marker_+3A_rate">rate</code></td>
<td>
<p>Mutation model parameters to be passed on to
<code><a href="pedmut.html#topic+mutationModel">pedmut::mutationModel()</a></code>; see there for details. Note: <code>mutmod</code>
corresponds to the <code>model</code> parameter. Default: NULL (no mutation model).</p>
</td></tr>
<tr><td><code id="marker_+3A_nastrings">NAstrings</code></td>
<td>
<p>A character vector containing strings to be treated as
missing alleles. Default: <code>c("", "0", NA, "-")</code>.</p>
</td></tr>
<tr><td><code id="marker_+3A_validate">validate</code></td>
<td>
<p>A logical indicating if the validity of the marker object
should be checked. Default: TRUE.</p>
</td></tr>
<tr><td><code id="marker_+3A_validatemut">validateMut</code></td>
<td>
<p>A logical indicating if the mutation model (if present)
should be checked.</p>
</td></tr>
<tr><td><code id="marker_+3A_locusattr">locusAttr</code></td>
<td>
<p>A list with names <code>alleles</code>, <code>afreq</code>, <code>chrom</code>, <code>name</code>,
<code>posMb</code>, <code>mutmod</code>, <code>rate</code> (or a subset of these). This can be used as an
alternative to entering the arguments as function parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>marker</code>. This is an integer matrix with 2 columns
and one row per individual, and the following attributes:
</p>

<ul>
<li> <p><code>alleles</code> (a character vector with allele labels)
</p>
</li>
<li> <p><code>afreq</code> (allele frequencies; default <code>rep.int(1/length(alleles),   length(alleles))</code>)
</p>
</li>
<li> <p><code>chrom</code> (chromosome number; default = NA)
</p>
</li>
<li> <p><code>posMb</code> (physical location in megabases; default = NA)
</p>
</li>
<li> <p><code>name</code> (marker identifier; default = NA)
</p>
</li>
<li> <p><code>mutmod</code> (a list of two (male and female) mutation matrices; default =
NULL)
</p>
</li></ul>



<h3>See Also</h3>

<p>Get/set marker attributes: <a href="#topic+marker_getattr">marker_getattr</a>, <a href="#topic+marker_setattr">marker_setattr</a>.
</p>
<p>Retrieve various marker properties: <a href="#topic+marker_prop">marker_prop</a>, <code><a href="#topic+nMarkers">nMarkers()</a></code>,
</p>
<p>Add alleles to an existing marker: <code><a href="#topic+addAllele">addAllele()</a></code>
</p>
<p>Attach multiple markers: <a href="#topic+marker_attach">marker_attach</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(father = "fa", mother = "mo", children = "child")

# An empty SNP with alleles "A" and "B"
marker(x, alleles = c("A", "B"))

# Creating and attaching to `x`
addMarker(x, alleles = c("A", "B"))

# Alleles/frequencies can be given jointly or separately
stopifnot(identical(
  marker(x, afreq = c(A = 0.01, B = 0.99)),
  marker(x, alleles = c("A", "B"), afreq = c(0.01, 0.99)),
  ))

# Genotypes can be assigned individually ...
marker(x, fa = "1/1", mo = "1/2")

# ... or using the `geno` vector (all members in order)
marker(x, geno = c("1/1", "1/2", NA))


# Attaching a marker to the pedigree
m = marker(x) # By default a SNP with alleles 1,2
x = setMarkers(x, m)

# A marker with a "proportional" mutation model,
# with different rates for males and females
mutrates = list(female = 0.1, male = 0.2)
marker(x, alleles = 1:2, mutmod = "prop", rate = mutrates)

</code></pre>

<hr>
<h2 id='marker_attach'>Attach markers to pedigrees</h2><span id='topic+marker_attach'></span><span id='topic+setMarkers'></span><span id='topic+addMarkers'></span>

<h3>Description</h3>

<p>In many applications it is useful to <em>attach</em> markers to their associated
<code>ped</code> object. In particular for bigger projects with many markers, this makes
it easier to manipulate the dataset as a unit. The function <code>setMarkers()</code>
replaces all existing markers with the supplied ones, while <code>addMarkers()</code>
appends the supplied markers to any existing ones. Note that there is also
the function <code><a href="#topic+addMarker">addMarker()</a></code>, which creates and attaches a single marker in one
go.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMarkers(
  x,
  m = NULL,
  alleleMatrix = NULL,
  locusAttributes = NULL,
  missing = 0,
  sep = NULL,
  checkCons = TRUE
)

addMarkers(
  x,
  m = NULL,
  alleleMatrix = NULL,
  locusAttributes = NULL,
  missing = 0,
  sep = NULL,
  checkCons = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_attach_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object</p>
</td></tr>
<tr><td><code id="marker_attach_+3A_m">m</code></td>
<td>
<p>Either a single <code>marker</code> object or a list of <code>marker</code> objects</p>
</td></tr>
<tr><td><code id="marker_attach_+3A_allelematrix">alleleMatrix</code></td>
<td>
<p>A matrix with <code>pedsize(x)</code> rows, containing the observed
alleles for one or several markers. The matrix must have either 1 or 2
columns per marker. If the former, then a <code>sep</code> string must be a given, and
will be used to split all entries.</p>
</td></tr>
<tr><td><code id="marker_attach_+3A_locusattributes">locusAttributes</code></td>
<td>
<p>A list of lists, with attributes for each marker. See
Details for possible attributes.</p>
</td></tr>
<tr><td><code id="marker_attach_+3A_missing">missing</code></td>
<td>
<p>A single character (or coercible to one) indicating the symbol
for missing alleles.</p>
</td></tr>
<tr><td><code id="marker_attach_+3A_sep">sep</code></td>
<td>
<p>If this is a single string, each entry of <code>alleleMatrix</code> is
interpreted as a genotype, and will be split by calling <code>strsplit(..., split = sep, fixed = TRUE)</code>. If <code>alleleMatrix</code> contains entries with &quot;/&quot;,
this will be taken as separator by default. (To override this behaviour,
put <code>sep = FALSE</code>.)</p>
</td></tr>
<tr><td><code id="marker_attach_+3A_checkcons">checkCons</code></td>
<td>
<p>A logical. If TRUE (default), each marker is checked for
consistency with <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most general format of <code>locusAttributes</code> a list of lists, one for each
marker, where possible entries in the inner lists are as follows (default
values in parenthesis):
</p>

<ul>
<li> <p><code>alleles</code> : a character vector with allele labels
</p>
</li>
<li> <p><code>afreq</code> :  a numeric vector with allele frequencies (<code>rep.int(1/L, L)</code>,
where <code>L = length(alleles)</code>)
</p>
</li>
<li> <p><code>chrom</code> : chromosome number (NA)
</p>
</li>
<li> <p><code>posMb</code> : physical location in megabases (NA)
</p>
</li>
<li> <p><code>name</code> : marker name (NA)
</p>
</li>
<li> <p><code>mutmod</code> : mutation model, or model name (NULL)
</p>
</li>
<li> <p><code>rate</code> : mutation model parameter (NULL)
</p>
</li></ul>

<p>If <code>locusAttributes</code> is a single list of attributes (not a list of lists),
then it is repeated to match the number of markers.
</p>


<h4>Alternative formats of <code>locusAttributes</code>:</h4>


<ul>
<li><p> data frame or matrix. In this case an attempt is made to interpret it as a
frequency database in <code style="white-space: pre;">&#8288;allelic ladder&#8288;</code> format.
</p>
</li>
<li><p> A list of frequency vectors. All vectors should sum to 1, and be named
(with allele labels)
</p>
</li>
<li><p> Shortcut for simple SNP data: The argument <code>locusAttributes = "snp-AB"</code>
sets all markers to be equifrequent SNPs with alleles A and B. The letters A
and B may be replaced by other single-character letters or numbers.
</p>
</li></ul>




<h3>Value</h3>

<p>A <code>ped</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addMarker">addMarker()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = singleton(1)
m1 = marker(x, `1` = "1/2")
m2 = marker(x, `1` = "a/b")

# Attach to x
x1 = setMarkers(x, list(m1, m2))

# Reversing the order of the markers
setMarkers(x, list(m2, m1))

# Alternative syntax, adding one marker at a time
x2 = x |&gt;
  addMarker(`1` = "1/2") |&gt;
  addMarker(`1` = "a/b")

stopifnot(identical(x1, x2))

</code></pre>

<hr>
<h2 id='marker_getattr'>Get marker attributes</h2><span id='topic+marker_getattr'></span><span id='topic+genotype'></span><span id='topic+genotype.marker'></span><span id='topic+genotype.ped'></span><span id='topic+mutmod'></span><span id='topic+mutmod.marker'></span><span id='topic+mutmod.ped'></span><span id='topic+mutmod.list'></span><span id='topic+alleles'></span><span id='topic+alleles.marker'></span><span id='topic+alleles.ped'></span><span id='topic+alleles.list'></span><span id='topic+afreq'></span><span id='topic+afreq.marker'></span><span id='topic+afreq.ped'></span><span id='topic+afreq.list'></span><span id='topic+name'></span><span id='topic+name.marker'></span><span id='topic+name.ped'></span><span id='topic+name.list'></span><span id='topic+chrom'></span><span id='topic+chrom.marker'></span><span id='topic+chrom.ped'></span><span id='topic+chrom.list'></span><span id='topic+posMb'></span><span id='topic+posMb.marker'></span><span id='topic+posMb.ped'></span>

<h3>Description</h3>

<p>S3 methods retrieving marker attributes. They work on single marker objects
and markers attached to ped objects (or lists of such).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotype(x, ...)

## S3 method for class 'marker'
genotype(x, id, ...)

## S3 method for class 'ped'
genotype(x, markers = NULL, id, ...)

mutmod(x, ...)

## S3 method for class 'marker'
mutmod(x, ...)

## S3 method for class 'ped'
mutmod(x, marker, ...)

## S3 method for class 'list'
mutmod(x, marker, ...)

alleles(x, ...)

## S3 method for class 'marker'
alleles(x, ...)

## S3 method for class 'ped'
alleles(x, marker, ...)

## S3 method for class 'list'
alleles(x, marker, ...)

afreq(x, ...)

## S3 method for class 'marker'
afreq(x, ...)

## S3 method for class 'ped'
afreq(x, marker, ...)

## S3 method for class 'list'
afreq(x, marker, ...)

name(x, ...)

## S3 method for class 'marker'
name(x, ...)

## S3 method for class 'ped'
name(x, markers = NULL, ...)

## S3 method for class 'list'
name(x, markers = NULL, ...)

chrom(x, ...)

## S3 method for class 'marker'
chrom(x, ...)

## S3 method for class 'ped'
chrom(x, markers = NULL, ...)

## S3 method for class 'list'
chrom(x, markers = NULL, ...)

posMb(x, ...)

## S3 method for class 'marker'
posMb(x, ...)

## S3 method for class 'ped'
posMb(x, markers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_getattr_+3A_x">x</code></td>
<td>
<p>Either a <code>marker</code> object, a <code>ped</code> object or a list of <code>ped</code> objects.</p>
</td></tr>
<tr><td><code id="marker_getattr_+3A_...">...</code></td>
<td>
<p>Further arguments, not used.</p>
</td></tr>
<tr><td><code id="marker_getattr_+3A_id">id</code></td>
<td>
<p>The ID label of a single pedigree member.</p>
</td></tr>
<tr><td><code id="marker_getattr_+3A_marker">marker</code>, <code id="marker_getattr_+3A_markers">markers</code></td>
<td>
<p>The index or name of a marker (or a vector indicating
several markers) attached to <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The associated marker attributes.
</p>


<h3>See Also</h3>

<p>Setting marker attributes: <a href="#topic+marker_setattr">marker_setattr</a> and <a href="#topic+marker_inplace">marker_inplace</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(1)
x = addMarker(x) # add empty marker

# Inspect default attributes
alleles(x, marker = 1)
afreq(x, marker = 1)
name(x, marker = 1)  # NA
chrom(x, marker = 1) # NA

</code></pre>

<hr>
<h2 id='marker_inplace'>Set marker attributes</h2><span id='topic+marker_inplace'></span><span id='topic+genotype+3C-'></span><span id='topic+genotype+3C-.marker'></span><span id='topic+genotype+3C-.ped'></span><span id='topic+mutmod+3C-'></span><span id='topic+mutmod+3C-.marker'></span><span id='topic+mutmod+3C-.ped'></span><span id='topic+mutmod+3C-.list'></span><span id='topic+afreq+3C-'></span><span id='topic+afreq+3C-.marker'></span><span id='topic+afreq+3C-.ped'></span><span id='topic+afreq+3C-.list'></span><span id='topic+name+3C-'></span><span id='topic+name+3C-.marker'></span><span id='topic+name+3C-.ped'></span><span id='topic+name+3C-.list'></span><span id='topic+chrom+3C-'></span><span id='topic+chrom+3C-.marker'></span><span id='topic+chrom+3C-.ped'></span><span id='topic+chrom+3C-.list'></span><span id='topic+posMb+3C-'></span><span id='topic+posMb+3C-.marker'></span><span id='topic+posMb+3C-.ped'></span>

<h3>Description</h3>

<p>These S3 methods perform in-place modifications of marker attributes. They
work on single marker objects and markers attached to ped objects (or lists
of such). Although these functions will continue to exist, we recommend the
newer alternatives <code><a href="#topic+setGenotype">setGenotype()</a></code>, <code><a href="#topic+setAfreq">setAfreq()</a></code>, ... in most cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotype(x, ...) &lt;- value

## S3 replacement method for class 'marker'
genotype(x, id, ...) &lt;- value

## S3 replacement method for class 'ped'
genotype(x, marker, id, ...) &lt;- value

mutmod(x, ...) &lt;- value

## S3 replacement method for class 'marker'
mutmod(x, ...) &lt;- value

## S3 replacement method for class 'ped'
mutmod(x, marker = NULL, ...) &lt;- value

## S3 replacement method for class 'list'
mutmod(x, marker = NULL, ...) &lt;- value

afreq(x, ...) &lt;- value

## S3 replacement method for class 'marker'
afreq(x, ...) &lt;- value

## S3 replacement method for class 'ped'
afreq(x, marker, ...) &lt;- value

## S3 replacement method for class 'list'
afreq(x, marker, ...) &lt;- value

name(x, ...) &lt;- value

## S3 replacement method for class 'marker'
name(x, ...) &lt;- value

## S3 replacement method for class 'ped'
name(x, markers = NULL, ...) &lt;- value

## S3 replacement method for class 'list'
name(x, markers = NULL, ...) &lt;- value

chrom(x, ...) &lt;- value

## S3 replacement method for class 'marker'
chrom(x, ...) &lt;- value

## S3 replacement method for class 'ped'
chrom(x, markers = NULL, ...) &lt;- value

## S3 replacement method for class 'list'
chrom(x, markers = NULL, ...) &lt;- value

posMb(x, ...) &lt;- value

## S3 replacement method for class 'marker'
posMb(x, ...) &lt;- value

## S3 replacement method for class 'ped'
posMb(x, markers = NULL, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_inplace_+3A_x">x</code></td>
<td>
<p>Either a <code>marker</code> object, a <code>ped</code> object or a list of <code>ped</code> objects.</p>
</td></tr>
<tr><td><code id="marker_inplace_+3A_...">...</code></td>
<td>
<p>Further arguments, not used.</p>
</td></tr>
<tr><td><code id="marker_inplace_+3A_value">value</code></td>
<td>
<p>Replacement value(s).</p>
</td></tr>
<tr><td><code id="marker_inplace_+3A_id">id</code></td>
<td>
<p>The ID label of a single pedigree member.</p>
</td></tr>
<tr><td><code id="marker_inplace_+3A_marker">marker</code>, <code id="marker_inplace_+3A_markers">markers</code></td>
<td>
<p>The index or name of a marker (or a vector indicating
several markers) attached to <code>ped</code>. Used if <code>x</code> is a <code>ped</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions perform in-place modification of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Alternative setters (not in-place): <a href="#topic+marker_setattr">marker_setattr</a>.
Marker attribute getters: <a href="#topic+marker_getattr">marker_getattr</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(1)
x = addMarker(x, alleles = 1:2)

# Set genotypes
genotype(x, marker = 1, id = 1) = "1/2"

# Set marker name
name(x, 1) = "M"

# Change allele freqs
afreq(x, "M") = c(`1` = 0.1, `2` = 0.9)

# Set position
chrom(x, "M") = 1
posMb(x, "M") = 123.45

# Check result
m = marker(x, `1` = "1/2", name = "M", afreq = c(`1` = 0.1, `2` = 0.9),
           chrom = 1, posMb = 123.45)
stopifnot(identical(x$MARKERS[[1]], m))

</code></pre>

<hr>
<h2 id='marker_prop'>Marker properties</h2><span id='topic+marker_prop'></span><span id='topic+emptyMarker'></span><span id='topic+emptyMarker.default'></span><span id='topic+emptyMarker.marker'></span><span id='topic+emptyMarker.ped'></span><span id='topic+emptyMarker.list'></span><span id='topic+nTyped'></span><span id='topic+nTyped.default'></span><span id='topic+nTyped.marker'></span><span id='topic+nTyped.ped'></span><span id='topic+nTyped.list'></span><span id='topic+nAlleles'></span><span id='topic+nAlleles.default'></span><span id='topic+nAlleles.marker'></span><span id='topic+nAlleles.ped'></span><span id='topic+nAlleles.list'></span><span id='topic+isXmarker'></span><span id='topic+isXmarker.default'></span><span id='topic+isXmarker.marker'></span><span id='topic+isXmarker.ped'></span><span id='topic+isXmarker.list'></span><span id='topic+allowsMutations'></span><span id='topic+allowsMutations.default'></span><span id='topic+allowsMutations.marker'></span><span id='topic+allowsMutations.ped'></span><span id='topic+allowsMutations.list'></span>

<h3>Description</h3>

<p>These functions are used to retrieve various properties of marker objects.
Each function accepts as input either a single <code>marker</code> object, a <code>ped</code>
object, or a list of <code>ped</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emptyMarker(x, ...)

## Default S3 method:
emptyMarker(x, ...)

## S3 method for class 'marker'
emptyMarker(x, ...)

## S3 method for class 'ped'
emptyMarker(x, markers = NULL, ...)

## S3 method for class 'list'
emptyMarker(x, markers = NULL, ...)

nTyped(x, ...)

## Default S3 method:
nTyped(x, ...)

## S3 method for class 'marker'
nTyped(x, ...)

## S3 method for class 'ped'
nTyped(x, markers = NULL, ...)

## S3 method for class 'list'
nTyped(x, markers = NULL, ...)

nAlleles(x, ...)

## Default S3 method:
nAlleles(x, ...)

## S3 method for class 'marker'
nAlleles(x, ...)

## S3 method for class 'ped'
nAlleles(x, markers = NULL, ...)

## S3 method for class 'list'
nAlleles(x, markers = NULL, ...)

isXmarker(x, ...)

## Default S3 method:
isXmarker(x, ...)

## S3 method for class 'marker'
isXmarker(x, ...)

## S3 method for class 'ped'
isXmarker(x, markers = NULL, ...)

## S3 method for class 'list'
isXmarker(x, markers = NULL, ...)

allowsMutations(x, ...)

## Default S3 method:
allowsMutations(x, ...)

## S3 method for class 'marker'
allowsMutations(x, ...)

## S3 method for class 'ped'
allowsMutations(x, markers = NULL, ...)

## S3 method for class 'list'
allowsMutations(x, markers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_prop_+3A_x">x</code></td>
<td>
<p>A single <code>marker</code> object or a <code>ped</code> object (or a list of such)</p>
</td></tr>
<tr><td><code id="marker_prop_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="marker_prop_+3A_markers">markers</code></td>
<td>
<p>A vector of names or indices of markers attached to <code>x</code>. By
default all attached markers are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>emptyMarker()</code> returns TRUE for markers with no genotypes. If the input is a
list of pedigrees, all must be empty for the result to be TRUE.
</p>
<p><code>nTyped()</code> returns the number of typed individuals for each marker. Note that
if the input is a list of pedigrees, the function returns the sum over all
components.
</p>
<p><code>nAlleles()</code> returns the number of alleles of each marker.
</p>
<p><code>isXmarker()</code> returns TRUE for markers whose <code>chrom</code> attribute is either &quot;X&quot;
or 23.
</p>
<p><code>allowsMutations</code> returns TRUE for markers whose <code>mutmod</code> attribute is
non-NULL and differs from the identity matrix.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a single <code>marker</code> object, the output is a vector of length 1.
</p>
<p>Otherwise, a vector of length <code>nMarkers(x)</code> (default) or <code>length(markers)</code>,
reporting the property of each marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmp1 = nuclearPed(1)
cmp2 = singleton(10)
loc = list(alleles = 1:2)
x = setMarkers(list(cmp1, cmp2), locus = rep(list(loc), 3))

#-------- nAlleles() ------------
# All markers have 2 alleles
stopifnot(identical(nAlleles(x), c(2L,2L,2L)))

#-------- emptyMarkers() ------------
# Add genotype for indiv 1 at marker 1
genotype(x[[1]], 1, 1) = "1/2"

# Check that markers 2 and 3 are empty
stopifnot(identical(emptyMarker(x), c(FALSE,TRUE,TRUE)),
          identical(emptyMarker(x[[1]]), c(FALSE,TRUE,TRUE)),
          identical(emptyMarker(x[[2]]), c(TRUE,TRUE,TRUE)),
          identical(emptyMarker(x, markers = c(3,1)), c(TRUE,FALSE)))

#-------- nTyped() ------------
stopifnot(identical(nTyped(x), c(1L,0L,0L)))

# Add genotypes for third marker
genotype(x[[1]], marker = 3, id = 1:3) = "1/1"
genotype(x[[2]], marker = 3, id = 10) = "2/2"

# nTyped() returns total over all components
stopifnot(identical(nTyped(x), c(1L,0L,4L)))

#-------- allowsMutations() ------------
# Marker 2 allows mutations
mutmod(x, 2) = list("prop", rate = 0.1)

stopifnot(identical(allowsMutations(x), c(FALSE,TRUE,FALSE)),
          identical(allowsMutations(x, markers = 2:3), c(TRUE,FALSE)))

#-------- isXmarker() ------------
# Make marker 3 X-linked
chrom(x[[1]], 3) = "X"
chrom(x[[2]], 3) = "X"

stopifnot(identical(isXmarker(x), c(FALSE,FALSE,TRUE)))

</code></pre>

<hr>
<h2 id='marker_select'>Select or remove attached markers</h2><span id='topic+marker_select'></span><span id='topic+selectMarkers'></span><span id='topic+getMarkers'></span><span id='topic+removeMarkers'></span><span id='topic+whichMarkers'></span>

<h3>Description</h3>

<p>Functions for manipulating markers attached to <code>ped</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectMarkers(x, markers = NULL, chroms = NULL, fromPos = NULL, toPos = NULL)

getMarkers(x, markers = NULL, chroms = NULL, fromPos = NULL, toPos = NULL)

removeMarkers(x, markers = NULL, chroms = NULL, fromPos = NULL, toPos = NULL)

whichMarkers(x, markers = NULL, chroms = NULL, fromPos = NULL, toPos = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_select_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object, or a list of such</p>
</td></tr>
<tr><td><code id="marker_select_+3A_markers">markers</code></td>
<td>
<p>Either a character vector (with marker names), a numeric
vector (with marker indices), a logical (of length <code>nMarkers(x)</code>), or NULL.</p>
</td></tr>
<tr><td><code id="marker_select_+3A_chroms">chroms</code></td>
<td>
<p>A vector of chromosome names, or NULL</p>
</td></tr>
<tr><td><code id="marker_select_+3A_frompos">fromPos</code></td>
<td>
<p>A single number or NULL</p>
</td></tr>
<tr><td><code id="marker_select_+3A_topos">toPos</code></td>
<td>
<p>A single number or NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>markers</code> consists of negative integers, it will be converted to its
complement within <code>1:nMarkers(x)</code>.
</p>


<h3>Value</h3>

<p>The return values of these functions are:
</p>

<ul>
<li> <p><code>selectMarkers()</code>: an object identical to <code>x</code>, but where only the
indicated markers are kept
</p>
</li>
<li> <p><code>removeMarkers()</code>: an object identical to <code>x</code>, but where the indicated
markers are removed
</p>
</li>
<li> <p><code>getMarkers()</code>: a list of <code>marker</code> objects. Note: If <code>x</code> is a list of
pedigrees, the marker objects attached to the first component will be
returned.
</p>
</li>
<li> <p><code>whichMarkers()</code>: an integer vector with indices of the indicated
markers. If <code>x</code> is a list of pedigrees an error is raised unless
<code>whichMarkers()</code> gives the same result for all components.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+setMarkers">setMarkers()</a></code>
</p>

<hr>
<h2 id='marker_setattr'>Set marker attributes</h2><span id='topic+marker_setattr'></span><span id='topic+setGenotype'></span><span id='topic+setAfreq'></span><span id='topic+setAlleleLabels'></span><span id='topic+setMarkername'></span><span id='topic+setChrom'></span><span id='topic+setPosition'></span>

<h3>Description</h3>

<p>These functions set or modify various attributes of markers attached to a
pedigree. They are sometimes more convenient (and pipe-friendly) than the
in-place modifiers described in <a href="#topic+marker_inplace">marker_inplace</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGenotype(x, marker = NULL, ids = NULL, geno = NULL, id = NULL)

setAfreq(x, marker, afreq, strict = TRUE)

setAlleleLabels(x, marker, alleles)

setMarkername(x, marker = NULL, name)

setChrom(x, marker = NULL, chrom)

setPosition(x, marker = NULL, posMb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_setattr_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of <code>ped</code> objects.</p>
</td></tr>
<tr><td><code id="marker_setattr_+3A_marker">marker</code></td>
<td>
<p>A vector of indices or names of one or several markers attached
to <code>x</code>.</p>
</td></tr>
<tr><td><code id="marker_setattr_+3A_geno">geno</code></td>
<td>
<p>A character vector of length <code>pedsize(x)</code>, with genotypes written
in the format &quot;a/b&quot;.</p>
</td></tr>
<tr><td><code id="marker_setattr_+3A_id">id</code>, <code id="marker_setattr_+3A_ids">ids</code></td>
<td>
<p>A vector naming one or several pedigree members, or a function
(e.g., <code><a href="#topic+founders">founders()</a></code>).</p>
</td></tr>
<tr><td><code id="marker_setattr_+3A_afreq">afreq</code></td>
<td>
<p>A numeric of the same length as <code>alleles</code>, indicating the
population frequency of each allele. A warning is issued if the frequencies
don't sum to 1 after rounding to 3 decimals. If the vector is named, and
<code>alleles</code> is not NULL, an error is raised if <code>setequal(names(afreq), alleles)</code> is not TRUE. If <code>afreq</code> is not specified, all alleles are given
equal frequencies.</p>
</td></tr>
<tr><td><code id="marker_setattr_+3A_strict">strict</code></td>
<td>
<p>A logical. If TRUE (default) the new frequencies cannot remove
or add any alleles.</p>
</td></tr>
<tr><td><code id="marker_setattr_+3A_alleles">alleles</code></td>
<td>
<p>A character containing allele names. If not given, and <code>afreq</code>
is named, <code>names(afreq)</code> is used. The default action is to take the sorted
vector of distinct alleles occurring in <code>allelematrix</code>, <code>geno</code> or <code>...</code>.</p>
</td></tr>
<tr><td><code id="marker_setattr_+3A_name">name</code></td>
<td>
<p>A character of the same length as <code>marker</code>, containing marker
names.</p>
</td></tr>
<tr><td><code id="marker_setattr_+3A_chrom">chrom</code></td>
<td>
<p>A character of the same length as <code>marker</code>, containing
chromosome labels.</p>
</td></tr>
<tr><td><code id="marker_setattr_+3A_posmb">posMb</code></td>
<td>
<p>A numeric of the same length as <code>marker</code>, containing the
physical marker positions in megabases (or NA).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> with modified attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed() |&gt;
  addMarker(alleles = 1:2) |&gt;
  setMarkername(marker = 1, name = "M") |&gt;
  setGenotype(marker = "M", ids = 1, geno = "1/2") |&gt;
  setAfreq(marker = "M", afreq = c(`1` = 0.1, `2` = 0.9)) |&gt;
  setChrom(marker = "M", chrom = 1) |&gt;
  setPosition(marker = "M", posMb = 123.45)

# Alternatively, all of this could have been done on creation:
y = addMarker(nuclearPed(),
              `1` = "1/2",
              afreq = c(`1` = 0.1, `2` = 0.9),
              name = "M",
              chrom = 1,
              posMb = 123.45)
stopifnot(identical(x, y))

</code></pre>

<hr>
<h2 id='maskPed'>Mask and unmask pedigree datasets</h2><span id='topic+maskPed'></span><span id='topic+unmaskPed'></span>

<h3>Description</h3>

<p>The <code>maskPed()</code> function replaces the individual IDs, marker names and allele
names with generic labels, and randomly changes their internal order. For
markers with stepwise mutation models, the allelic ladder is simply
translated to start at 1, thereby preserving the intra-allelic differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskPed(
  x,
  ids = NULL,
  markerNames = NULL,
  markerShuffle = TRUE,
  alleleLabels = NULL,
  alleleShuffle = TRUE,
  seed = NULL
)

unmaskPed(x, keys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskPed_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="maskPed_+3A_ids">ids</code></td>
<td>
<p>(Optional) A named character with the new IDs, written as <code>c(old = new, ...)</code>. By default: 1, 2, ... .</p>
</td></tr>
<tr><td><code id="maskPed_+3A_markernames">markerNames</code></td>
<td>
<p>(Optional) A named character with the new marker names
(and order), written as <code>c(old = new, ...)</code>. By default: M1, M2, ... .</p>
</td></tr>
<tr><td><code id="maskPed_+3A_markershuffle">markerShuffle</code></td>
<td>
<p>A logical: Randomly reorder the markers? (Default: TRUE)</p>
</td></tr>
<tr><td><code id="maskPed_+3A_allelelabels">alleleLabels</code></td>
<td>
<p>(Optional) A list of character vectors. The list names
should be the original marker names. Each vector gives the new allele
labels, as <code>c(old = new, ...)</code>. By default, each marker gets alleles 1, 2,
... .</p>
</td></tr>
<tr><td><code id="maskPed_+3A_alleleshuffle">alleleShuffle</code></td>
<td>
<p>A logical: Randomly reorder the alleles? (Default: TRUE)</p>
</td></tr>
<tr><td><code id="maskPed_+3A_seed">seed</code></td>
<td>
<p>An optional seed for the random number generator.</p>
</td></tr>
<tr><td><code id="maskPed_+3A_keys">keys</code></td>
<td>
<p>A list with entries <code>ids</code>, <code>markerNames</code>, <code>alleleLabels</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in order to preserve likelihoods, the allele frequencies are not
modified. Thus, if the data uses a publicly available frequency databases,
the result cannot be considered to be fully anonymised, since one could (at
least in theory) deduce the original marker names and alleles from the
frequencies.)
</p>


<h3>Value</h3>

<p>An object similar to <code>x</code> but with replaced ID labels, marker names
and allele labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(father = "fa", mother = "mo", children = "ch") |&gt;
  addMarker(name = "myMarker", ch = "b/c", afreq = c(a=0.2, b=0.3, c=0.5)) |&gt;
  setMutmod(model = "proportional", rate = 0.01)

# Mask
y = maskPed(x, seed = 1729)

# Unmask
z = unmaskPed(y$maskedPed, keys = y$keys)
stopifnot(identical(x, z))

# With stepwise model
x2 = x |&gt;
  addMarker(name = "mySTR", ch = "7.2/8.2",
            alleles = c("7", "7.2", "8", "8.2")) |&gt;
  setMutmod(marker = 2, model = "stepwise", rate = 0.1, rate2 = 1e-6,
            range = 0.1)

y2 = maskPed(x2, seed = 1729)

z2 = unmaskPed(y2$maskedPed, keys = y2$keys)

stopifnot(identical(x2, z2))

# Check likelihoods with pedprobr:
# stopifnot(setequal(likelihood(x2), likelihood(y2$maskedPed)))

</code></pre>

<hr>
<h2 id='mendelianCheck'>Check for Mendelian errors</h2><span id='topic+mendelianCheck'></span>

<h3>Description</h3>

<p>Check marker data for Mendelian inconsistencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mendelianCheck(x, remove = FALSE, verbose = !remove)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mendelianCheck_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+ped">ped()</a></code> object</p>
</td></tr>
<tr><td><code id="mendelianCheck_+3A_remove">remove</code></td>
<td>
<p>a logical. If FALSE, the function returns the indices of
markers found to incorrect.  If TRUE, a new <code>ped</code> object is
returned, where the incorrect markers have been deleted.</p>
</td></tr>
<tr><td><code id="mendelianCheck_+3A_verbose">verbose</code></td>
<td>
<p>a logical. If TRUE, details of the markers failing the tests
are shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric containing the indices of the markers
that did not pass all tests, or (if <code>remove = TRUE</code>) a new <code>ped</code>
object where the failing markers are removed.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed()

# Add a SNP with Mendelian error
m = marker(x, '1' = "1/1", '2' = "1/1", '3' = "1/2")
x = setMarkers(x, m)

mendelianCheck(x)

</code></pre>

<hr>
<h2 id='mergePed'>Merge two pedigrees</h2><span id='topic+mergePed'></span>

<h3>Description</h3>

<p>This function merges two <code>ped</code> objects, joining them at the indicated
individuals. Only ped objects without marker data are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergePed(x, y, by = NULL, relabel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergePed_+3A_x">x</code>, <code id="mergePed_+3A_y">y</code></td>
<td>
<p><code><a href="#topic+ped">ped()</a></code> objects</p>
</td></tr>
<tr><td><code id="mergePed_+3A_by">by</code></td>
<td>
<p>The individuals to merge by. The most general form uses a named
vector with entries of the form <code>id.x = id.y</code> (see Examples). If the vector
is unnamed, it is assumed that the merging individuals have the same labels
in both pedigrees. Finally, if <code>by = NULL</code> (default), it is set to
<code>intersect(labels(x), labels(y))</code>.</p>
</td></tr>
<tr><td><code id="mergePed_+3A_relabel">relabel</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, <code>relabel(..., "asPlot")</code>
is run on the merged pedigree before returning.</p>
</td></tr>
<tr><td><code id="mergePed_+3A_...">...</code></td>
<td>
<p>further arguments passed along to <code><a href="#topic+ped">ped()</a></code>, e.g. <code>famid</code>,
<code>validate</code> and <code>reorder</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some internal checks are done to ensure that merging individuals have the
same sex and the same parents.
</p>
<p>If <code>relabel = FALSE</code>, some relabelling might still be performed in order to
ensure unique labels for everyone. Specifically, this is the case if some ID
labels occur in both <code>x</code> and <code>y</code> other than those given in the <code>by</code> argument.
In such cases, the relevant members of <code>y</code> get a suffix <code>.y</code>.
</p>


<h3>Value</h3>

<p>A <code>ped</code> object.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
############
# Example 1
# A family trio where each parent have first cousin parents.
############

# Trio
x = nuclearPed(1)

# Add paternal family
pat = cousinPed(1, child = TRUE)
x = mergePed(x, pat, by = c("1" = "9"))

# Maternal family
mat = cousinPed(1, child = TRUE) |&gt; swapSex("9")
x = mergePed(x, mat, by = c("2" = "9"))

# Relabel (Alternative: add `relabel = TRUE` in the previous call)
x = relabel(x, "asPlot")

plot(x)


##################################
# Example 2: Double first cousins
##################################

# First cousins, whose fathers are brothers
y = cousinPed(degree = 1)

# Create two sisters
motherPed = nuclearPed(2, sex = 2)

# Plot to see who is who: `plotPedList(list(y, motherPed))`

# Merge
z = mergePed(y, motherPed, by = c("4" = 3, "6" = 4), relabel = TRUE)
plot(z)

</code></pre>

<hr>
<h2 id='newMarker'>Internal marker constructor</h2><span id='topic+newMarker'></span>

<h3>Description</h3>

<p>This is the internal constructor of <code>marker</code> objects. It does not do any
input validation and should only be used in programming scenarios, and only
if you know what you are doing. Most users are recommended to use the regular
constructor <code><a href="#topic+marker">marker()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newMarker(
  alleleMatrixInt,
  alleles,
  afreq,
  name = NA_character_,
  chrom = NA_character_,
  posMb = NA_real_,
  mutmod = NULL,
  pedmembers,
  sex
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newMarker_+3A_allelematrixint">alleleMatrixInt</code></td>
<td>
<p>An integer matrix.</p>
</td></tr>
<tr><td><code id="newMarker_+3A_alleles">alleles</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="newMarker_+3A_afreq">afreq</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="newMarker_+3A_name">name</code></td>
<td>
<p>A character of length 1.</p>
</td></tr>
<tr><td><code id="newMarker_+3A_chrom">chrom</code></td>
<td>
<p>A character of length 1.</p>
</td></tr>
<tr><td><code id="newMarker_+3A_posmb">posMb</code></td>
<td>
<p>A numeric of length 1.</p>
</td></tr>
<tr><td><code id="newMarker_+3A_mutmod">mutmod</code></td>
<td>
<p>A mutation model.</p>
</td></tr>
<tr><td><code id="newMarker_+3A_pedmembers">pedmembers</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="newMarker_+3A_sex">sex</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+marker">marker()</a></code> for more details about the marker attributes.
</p>


<h3>Value</h3>

<p>A <code>marker</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
newMarker(matrix(c(1L, 0L, 1L, 1L, 0L, 2L), ncol = 2),
          alleles = c("A", "B"), afreq = c(0.1, 0.9), name = "M",
          pedmembers = c("1", "2", "3"), sex = c(1L, 2L, 1L))

</code></pre>

<hr>
<h2 id='newPed'>Internal ped constructor</h2><span id='topic+newPed'></span>

<h3>Description</h3>

<p>This is the internal constructor of <code>ped</code> objects. It does not do any
validation of input other than simple type checking. In particular it should
only be used in programming scenarios where it is known that the input is a
valid, connected pedigree. End users are recommended to use the regular
constructor <code><a href="#topic+ped">ped()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newPed(ID, FIDX, MIDX, SEX, FAMID, detectLoops = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newPed_+3A_id">ID</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="newPed_+3A_fidx">FIDX</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="newPed_+3A_midx">MIDX</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="newPed_+3A_sex">SEX</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="newPed_+3A_famid">FAMID</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="newPed_+3A_detectloops">detectLoops</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+ped">ped()</a></code> for details about the input parameters.
</p>


<h3>Value</h3>

<p>A <code>ped</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
newPed("a", 0L, 0L, 1L, "")

</code></pre>

<hr>
<h2 id='nMarkers'>The number of markers attached to a pedigree</h2><span id='topic+nMarkers'></span><span id='topic+hasMarkers'></span>

<h3>Description</h3>

<p>The number of markers attached to a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nMarkers(x, compwise = FALSE)

hasMarkers(x, compwise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nMarkers_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="nMarkers_+3A_compwise">compwise</code></td>
<td>
<p>A logical, only relevant if <code>x</code> is a ped list. Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nMarkers()</code> by default returns a single number; the number of marker
objects attached to <code>x</code>. If <code>x</code> is a ped list, an error is raised if the
components have different numbers of markers. This check can be skipped by
setting <code>compwise = TRUE</code>, in which case the function returns a vector of
the component-wise marker numbers.
</p>
<p>The function <code>hasMarkers(x)</code> returns TRUE if (at least component of) <code>x</code>
has attached markers, otherwise FALSE. If <code>compwise = TRUE</code>, a logical
vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed() |&gt; addMarker()
nMarkers(x) # = 1

y = list(x, singleton(1))
nMarkers(y, compwise = TRUE) # c(1,0)

hasMarkers(y) # TRUE
hasMarkers(y, compwise = TRUE) # c(TRUE, FALSE)

</code></pre>

<hr>
<h2 id='ped'>Pedigree construction</h2><span id='topic+ped'></span><span id='topic+singleton'></span><span id='topic+singletons'></span>

<h3>Description</h3>

<p>This is the basic constructor of <code>ped</code> objects. Utility functions for
creating many common pedigree structures are described in <a href="#topic+ped_basic">ped_basic</a>. See
also <code><a href="#topic+as.ped">as.ped()</a></code> and <code><a href="#topic+readPed">readPed()</a></code>, which are more liberal regarding the input
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped(
  id,
  fid,
  mid,
  sex,
  famid = "",
  reorder = TRUE,
  validate = TRUE,
  detectLoops = TRUE,
  isConnected = FALSE,
  verbose = FALSE
)

singleton(id = 1, sex = 1, famid = "")

singletons(id, sex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped_+3A_id">id</code></td>
<td>
<p>A vector (coercible to character) of individual ID labels.</p>
</td></tr>
<tr><td><code id="ped_+3A_fid">fid</code>, <code id="ped_+3A_mid">mid</code></td>
<td>
<p>Vectors of the same length as <code>id</code>, naming the father and
mother of each individual, respectively. Missing parents (i.e.,
corresponding to founder individuals) may be entered as &quot;0&quot;, &quot;&quot; or NA.</p>
</td></tr>
<tr><td><code id="ped_+3A_sex">sex</code></td>
<td>
<p>A numeric of the same length as <code>id</code>, describing the genders of
the individuals (in the same order as <code>id</code>.) Each entry must be either 1
(=male), 2 (=female) or 0 (=unknown).</p>
</td></tr>
<tr><td><code id="ped_+3A_famid">famid</code></td>
<td>
<p>A character string. Default: An empty string.</p>
</td></tr>
<tr><td><code id="ped_+3A_reorder">reorder</code></td>
<td>
<p>A logical indicating if the pedigree should be reordered so
that all parents precede their children. Default: TRUE.</p>
</td></tr>
<tr><td><code id="ped_+3A_validate">validate</code></td>
<td>
<p>A logical indicating if a validation of the pedigree
structure should be performed. Default: TRUE.</p>
</td></tr>
<tr><td><code id="ped_+3A_detectloops">detectLoops</code></td>
<td>
<p>A logical indicating if the presence of loops should be
detected. Setting this to FALSE may speed up the processing of large
pedigrees. Default: TRUE.</p>
</td></tr>
<tr><td><code id="ped_+3A_isconnected">isConnected</code></td>
<td>
<p>A logical indicating if the input is known to be a
connected pedigree. Setting this to TRUE speeds up the processing. Default:
FALSE.</p>
</td></tr>
<tr><td><code id="ped_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each individual must have either both parents specified, or no parents.
Missing parents are indicated with entries &quot;0&quot;, &quot;&quot; or NA in <code>fid</code> and <code>mid</code>.
Note that <code>id</code>,<code>fid</code>,<code>mid</code> are all converted to character vectors before
matching to establish the parent connections.
</p>
<p>If the pedigree is disconnected, it is split into its connected components
and returned as a list of <code>ped</code> objects.
</p>
<p>A singleton is a special <code>ped</code> object whose pedigree contains 1 individual.
The class attribute of a singleton is <code>c('singleton', 'ped')</code>.
</p>
<p><code>singletons()</code> creates a list of singletons with the indicated labels and
sexes.
</p>
<p>Selfing, i.e. the presence of pedigree members whose father and mother are
the same individual, is allowed in <code>ped</code> objects. Any such &quot;self-fertilizing&quot;
parent must have undecided sex (<code>sex = 0</code>).
</p>


<h3>Value</h3>

<p>A <code>ped</code> object, which is essentially a list with the following
entries:
</p>

<ul>
<li> <p><code>ID</code> : A character vector of ID labels. Unless the pedigree is reordered
during creation, this equals <code>as.character(id)</code>
</p>
</li>
<li> <p><code>FIDX</code> : An integer vector with paternal indices: For each <code class="reqn">j =
  1,2,...</code>, the entry <code>FIDX[j]</code> is 0 if <code>ID[j]</code> has no father within the
pedigree; otherwise <code>ID[FIDX[j]]</code> is the father of <code>ID[j]</code>.
</p>
</li>
<li> <p><code>MIDX</code> : An integer vector with maternal indices: For each <code class="reqn">j =
  1,2,...</code>, the entry <code>MIDX[j]</code> is 0 if <code>ID[j]</code> has no mother within the
pedigree; otherwise <code>ID[MIDX[j]]</code> is the mother of <code>ID[j]</code>.
</p>
</li>
<li> <p><code>SEX</code> : An integer vector with gender codes. Unless the pedigree is
reordered, this equals <code>as.integer(sex)</code>.
</p>
</li>
<li> <p><code>FAMID</code> : The family ID.
</p>
</li>
<li> <p><code>UNBROKEN_LOOPS</code> : A logical indicating if the pedigree has unbroken
loops, or NA if the status is currently unknown.
</p>
</li>
<li> <p><code>LOOP_BREAKERS</code> : A matrix with loop breaker ID's in the first column and
their duplicates in the second column. All entries refer to the internal
IDs. This is usually set by <code><a href="#topic+breakLoops">breakLoops()</a></code>.
</p>
</li>
<li> <p><code>FOUNDER_INBREEDING</code> : A list of two potential entries, &quot;autosomal&quot; and
&quot;x&quot;; both numeric vectors with the same length as <code>founders(x)</code>.
<code>FOUNDER_INBREEDING</code> is always NULL when a new <code>ped</code> is created. See
<code><a href="#topic+founderInbreeding">founderInbreeding()</a></code>.
</p>
</li>
<li> <p><code>MARKERS</code> : A list of <code>marker</code> objects, or NULL.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newPed">newPed()</a></code>, <a href="#topic+ped_basic">ped_basic</a>, <a href="#topic+ped_modify">ped_modify</a>, <a href="#topic+ped_subgroups">ped_subgroups</a>, <code><a href="#topic+relabel">relabel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Trio
x = ped(id = 1:3, fid = c(0,0,1), mid = c(0,0,2), sex = c(1,2,1))

# Female singleton
y = singleton('NN', sex = 2)

# Selfing
z = ped(id = 1:2, fid = 0:1, mid = 0:1, sex = 0:1)
stopifnot(hasSelfing(z))

# Disconnected pedigree: Trio + singleton
ped(id = 1:4, fid = c(2,0,0,0), mid = c(3,0,0,0), sex = c(1,1,2,1))

# List of singletons
singletons(1:2)

</code></pre>

<hr>
<h2 id='ped_basic'>Create simple pedigrees</h2><span id='topic+ped_basic'></span><span id='topic+nuclearPed'></span><span id='topic+halfSibPed'></span><span id='topic+linearPed'></span><span id='topic+cousinPed'></span><span id='topic+avuncularPed'></span><span id='topic+halfCousinPed'></span><span id='topic+ancestralPed'></span><span id='topic+selfingPed'></span>

<h3>Description</h3>

<p>Utility functions for creating some common pedigree structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nuclearPed(nch = 1, sex = 1, father = "1", mother = "2", children = NULL)

halfSibPed(
  nch1 = 1,
  nch2 = 1,
  sex1 = 1,
  sex2 = 1,
  type = c("paternal", "maternal")
)

linearPed(n, sex = 1)

cousinPed(
  degree,
  removal = 0,
  side = c("right", "left"),
  half = FALSE,
  child = FALSE
)

avuncularPed(
  top = c("uncle", "aunt"),
  bottom = c("nephew", "niece"),
  side = c("right", "left"),
  type = c("paternal", "maternal"),
  removal = 1,
  half = FALSE
)

halfCousinPed(degree, removal = 0, side = c("right", "left"), child = FALSE)

ancestralPed(g)

selfingPed(s, sex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped_basic_+3A_nch">nch</code></td>
<td>
<p>The number of children, by default 1. If <code>children</code> is not NULL,
<code>nch</code> is set to <code>length(children)</code></p>
</td></tr>
<tr><td><code id="ped_basic_+3A_sex">sex</code></td>
<td>
<p>A vector with integer gender codes (0=unknown, 1=male, 2=female).
In <code>nuclearPed()</code>, it contains the genders of the children and is recycled
(if necessary) to length <code>nch</code>. In <code>linearPed()</code> it also contains the
genders of the children (1 in each generation) and should have length at
most <code>n</code> (recycled if shorter than this). In <code>selfingPed()</code> it should be a
single number, indicating the gender of the last individual (the others
must necessarily have gender code 0.)</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_father">father</code></td>
<td>
<p>The label of the father. Default: &quot;1&quot;.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_mother">mother</code></td>
<td>
<p>The label of the mother. Default: &quot;2&quot;.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_children">children</code></td>
<td>
<p>A character with labels of the children. Default: &quot;3&quot;, &quot;4&quot;,
...</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_nch1">nch1</code>, <code id="ped_basic_+3A_nch2">nch2</code></td>
<td>
<p>The number of children in each sibship.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_sex1">sex1</code>, <code id="ped_basic_+3A_sex2">sex2</code></td>
<td>
<p>Vectors of gender codes for the children in each sibship.
Recycled (if necessary) to lengths <code>nch1</code> and <code>nch2</code> respectively.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_type">type</code></td>
<td>
<p>Either &quot;paternal&quot; or &quot;maternal&quot;.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_n">n</code></td>
<td>
<p>The number of generations, not including the initial founders.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_degree">degree</code></td>
<td>
<p>A non-negative integer: 0=siblings, 1=first cousins; 2=second
cousins, a.s.o.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_removal">removal</code></td>
<td>
<p>A non-negative integer. See Details and Examples.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_side">side</code></td>
<td>
<p>Either &quot;right&quot; or &quot;left&quot;; the side on which removals should be
added.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_half">half</code></td>
<td>
<p>A logical indicating if the relationship should be &quot;half-like&quot;.
Default: FALSE.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_child">child</code></td>
<td>
<p>A logical: Should an inbred child be added to the two bottom
individuals?</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_top">top</code>, <code id="ped_basic_+3A_bottom">bottom</code></td>
<td>
<p>Words indicating the gender combination in avuncular
relationships. The first must be either &quot;uncle&quot; or &quot;aunt&quot;, while the second
is &quot;nephew&quot; or &quot;niece&quot;. Both can be abbreviated.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_g">g</code></td>
<td>
<p>A nonnegative integer indicating the number of ancestral generations
to include. The resulting pedigree has <code>2^(g+1)-1</code> members. The case <code>g = 0</code> results in a singleton.</p>
</td></tr>
<tr><td><code id="ped_basic_+3A_s">s</code></td>
<td>
<p>Either a character vector of ID labels, or a nonnegative integer
indicating the number of consecutive selfings. The case <code>s = 0</code> results in
a singleton.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>halfSibPed(nch1, nch2)</code> produces a pedigree containing two sibships (of
sizes <code>nch1</code> and <code>nch2</code>) with the same father, but different mothers. If
maternal half sibs are wanted instead, add <code>type = "maternal"</code>.
</p>
<p><code>cousinPed(degree = n, removal = k)</code> creates a pedigree with two <code>n</code>'th
cousins, <code>k</code> times removed. By default, removals are added on the right side,
but this can be changed by adding <code>side = left</code>.
</p>
<p><code>halfCousinPed(...)</code> is a synonym for <code>cousinPed(..., half = TRUE)</code>.
</p>
<p><code>avuncularPed()</code> creates uncle/aunt - nephew/niece pedigrees. The empty call
<code>avuncularPed()</code> is equivalent to avuncularPed(&quot;uncle&quot;, &quot;nephew&quot;). Note that
the arguments can be abbreviated, so that e.g. <code>avuncularPed("a", "ni")</code>
produces an aunt-niece relationship. Grand (and great-grand etc) uncles/aunts
can be produced by specifying <code>removal</code> greater than 1.
</p>
<p><code>ancestralPed(g)</code> returns the family tree of a single individual, including
all ancestors <code>g</code> generations back.
</p>
<p><code>selfingPed(s)</code> returns a line of <code>s</code> consecutive selfings.
</p>


<h3>Value</h3>

<p>A <code>ped</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ped">ped()</a></code>, <code><a href="#topic+singleton">singleton()</a></code>, <a href="#topic+ped_complex">ped_complex</a>, <a href="#topic+ped_subgroups">ped_subgroups</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A nuclear family with 2 boys and 3 girls
nuclearPed(5, sex = c(1, 1, 2, 2, 2))

# A straight line of females
linearPed(3, sex = 2)

# Paternal half brothers
halfSibPed()

# Maternal half sisters
halfSibPed(sex1 = 2, sex2 = 2, type = "maternal")

# Larger half sibships: boy and girl on one side; 3 girls on the other
halfSibPed(nch1 = 2, sex = 1:2, nch2 = 3, sex2 = 2)

# Grand aunt:
cousinPed(degree = 0, removal = 2)

# Second cousins once removed.
cousinPed(degree = 2, removal = 1)

# Same, but with the 'removal' on the left side.
cousinPed(2, 1, side = "left")

# A child of half first cousins.
halfCousinPed(degree = 1, child = TRUE)

# The 'family tree' of a person
ancestralPed(g = 2)

</code></pre>

<hr>
<h2 id='ped_complex'>Complex pedigree structures</h2><span id='topic+ped_complex'></span><span id='topic+doubleCousins'></span><span id='topic+doubleFirstCousins'></span><span id='topic+quadHalfFirstCousins'></span><span id='topic+fullSibMating'></span><span id='topic+halfSibStack'></span><span id='topic+halfSibTriangle'></span>

<h3>Description</h3>

<p>Functions for creating a selection of pedigrees that are awkward to construct
from scratch or with the simple structures described in <a href="#topic+ped_basic">ped_basic</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleCousins(
  degree1,
  degree2,
  removal1 = 0,
  removal2 = 0,
  half1 = FALSE,
  half2 = FALSE,
  child = FALSE
)

doubleFirstCousins()

quadHalfFirstCousins()

fullSibMating(n)

halfSibStack(n)

halfSibTriangle(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped_complex_+3A_degree1">degree1</code>, <code id="ped_complex_+3A_degree2">degree2</code>, <code id="ped_complex_+3A_removal1">removal1</code>, <code id="ped_complex_+3A_removal2">removal2</code></td>
<td>
<p>Nonnegative integers.</p>
</td></tr>
<tr><td><code id="ped_complex_+3A_half1">half1</code>, <code id="ped_complex_+3A_half2">half2</code></td>
<td>
<p>Logicals, indicating if the fathers (resp. mothers) should
be full or half cousins.</p>
</td></tr>
<tr><td><code id="ped_complex_+3A_child">child</code></td>
<td>
<p>A logical: Should a child be added to the double cousins?</p>
</td></tr>
<tr><td><code id="ped_complex_+3A_n">n</code></td>
<td>
<p>A positive integer indicating the number of crossings.</p>
</td></tr>
<tr><td><code id="ped_complex_+3A_g">g</code></td>
<td>
<p>A positive integer; the number of generations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>doubleCousins</code> returns a pedigree linking two individuals who
are simultaneous paternal and maternal cousins. More precisely, they are:
</p>

<ul>
<li><p> paternal (full or half) cousins of type (<code>degree1</code>, <code>removal1</code>)
</p>
</li>
<li><p> maternal (full or half) cousins of type (<code>degree2</code>, <code>removal2</code>).
</p>
</li></ul>

<p>For convenience, a wrapper <code>doubleFirstCousins</code> is provided for the most
common case, double first cousins.
</p>
<p><code>quadHalfFirstCousins</code> produces a pedigree with quadruple half first cousins.
</p>
<p><code>fullSibMating</code> crosses full sibs consecutively <code>n</code> times.
</p>
<p><code>halfSibStack</code> produces a breeding scheme where the two individuals in the
final generation are simultaneous half k'th cousins, for each <code style="white-space: pre;">&#8288;k = 0,...,n-1&#8288;</code>.
</p>
<p><code>halfSibTriangle</code> produces a triangular pedigree in which every pair of
parents are half siblings.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+ped">ped</a></code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+ped_basic">ped_basic</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Consecutive brother-sister matings.
x = fullSibMating(2)
# plot(x)

# Simultaneous half siblings and half first cousins
x = halfSibStack(2)
# plot(x)

# Double first cousins
x = doubleFirstCousins()
# plot(x)

# Quadruple half first cousins
x = quadHalfFirstCousins()
# plot(x) # Weird plotting behaviour for this pedigree.

# Triangular half-sib pattern
x = halfSibTriangle(4)
# plot(x)

</code></pre>

<hr>
<h2 id='ped_internal'>Internal ordering of pedigree members</h2><span id='topic+ped_internal'></span><span id='topic+reorderPed'></span><span id='topic+parentsBeforeChildren'></span><span id='topic+hasParentsBeforeChildren'></span><span id='topic+foundersFirst'></span><span id='topic+internalID'></span>

<h3>Description</h3>

<p>These functions give access to - and enable modifications of - the order in
which the members of a pedigree are stored. (This is the order in which the
members are listed when a <code>ped</code> object is printed to the screen.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorderPed(x, neworder = NULL, internal = FALSE)

parentsBeforeChildren(x)

hasParentsBeforeChildren(x)

foundersFirst(x)

internalID(x, ids, errorIfUnknown = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped_internal_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object. Most of these functions also accepts ped lists.</p>
</td></tr>
<tr><td><code id="ped_internal_+3A_neworder">neworder</code></td>
<td>
<p>A permutation of <code>labels(x)</code> (or a subset of this),
indicating the new internal ordering. If <code>internal = TRUE</code>, <code>neworder</code>
refers to the internal ordering, so must be numeric. <code>1:pedsize(x)</code>. By
default, the natural order of the ID labels is used.</p>
</td></tr>
<tr><td><code id="ped_internal_+3A_internal">internal</code></td>
<td>
<p>A logical (default: FALSE). If TRUE, <code>neworder</code> is
interpreted as referring to the internal ordering.</p>
</td></tr>
<tr><td><code id="ped_internal_+3A_ids">ids</code></td>
<td>
<p>A character vector (or coercible to one) of original ID labels.</p>
</td></tr>
<tr><td><code id="ped_internal_+3A_errorifunknown">errorIfUnknown</code></td>
<td>
<p>A logical. If TRUE (default), the function stops with
an error if not all elements of <code>ids</code> are recognised as names of members in
<code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal ordering is usually of little importance for end users, with one
important exception: Certain pedigree-traversing algorithms require parents
to precede their children. A special function, <code>parentsBeforeChildren()</code> is
provided for this purpose. This is a wrapper of the more general
<code>reorderPed()</code> which allows any permutation of the members.
</p>
<p>It should be noted that <code><a href="#topic+ped">ped()</a></code> by default calls <code>parentsBeforeChildren()</code>
whenever a pedigree is created, unless explicitly avoided with <code>reorder = FALSE</code>.
</p>
<p><code>hasParentsBeforeChildren()</code> can be used as a quick test to decide if it is
necessary to call <code>parentsBeforeChildren()</code>.
</p>
<p>The <code>foundersFirst()</code> function reorders the pedigree so that all the founders
come first.
</p>
<p>The utility <code>internalID()</code> converts ID labels to indices in the internal
ordering. If <code>x</code> is a list of pedigrees, the output is a data frame
containing both the component number and internal ID (within the component).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ped">ped()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = ped(id = 3:1, fid = c(1,0,0), mid = c(2,0,0), sex = c(1,2,1), reorder = FALSE)
x

# The 'ids' argument is converted to character, hence these are the same:
internalID(x, ids = 3)
internalID(x, ids = "3")

hasParentsBeforeChildren(x)

# Put parents first
parentsBeforeChildren(x)

# Typical use of reorderPed: Swap sibling plot order
y = nuclearPed(2) |&gt; reorderPed(4:3)
plot(y)


### If labels are numeric, argument `internal` is important
z = singleton(1) |&gt; addParents(1)
z
reorderPed(z, 1:3, internal = FALSE) # ID order = "1","2","3"
reorderPed(z, 1:3, internal = TRUE)  # index order: 1,2,3 (i.e., no change)

</code></pre>

<hr>
<h2 id='ped_modify'>Add/remove pedigree members</h2><span id='topic+ped_modify'></span><span id='topic+addChildren'></span><span id='topic+addChild'></span><span id='topic+addSon'></span><span id='topic+addDaughter'></span><span id='topic+addParents'></span><span id='topic+removeIndividuals'></span><span id='topic+branch'></span><span id='topic+subset.ped'></span>

<h3>Description</h3>

<p>Functions for adding or removing individuals in a 'ped' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addChildren(
  x,
  father = NULL,
  mother = NULL,
  nch = NULL,
  sex = 1L,
  ids = NULL,
  verbose = TRUE
)

addChild(x, parents, id = NULL, sex = 1, verbose = TRUE)

addSon(x, parents, id = NULL, verbose = TRUE)

addDaughter(x, parents, id = NULL, verbose = TRUE)

addParents(x, id, father = NULL, mother = NULL, verbose = TRUE)

removeIndividuals(
  x,
  ids,
  remove = c("descendants", "ancestors"),
  returnLabs = FALSE,
  verbose = TRUE
)

branch(x, id)

## S3 method for class 'ped'
subset(x, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped_modify_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object, or a list of such.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_father">father</code>, <code id="ped_modify_+3A_mother">mother</code></td>
<td>
<p>Single ID labels. At least one of these must be an
existing member of <code>x</code>. The other may be (i) another existing member, (ii)
a new founder to be created, or (iii) missing (i.e., NULL), in which case
the other parent is created and given a suitable name.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_nch">nch</code></td>
<td>
<p>A positive integer indicating the number of children to be
created. Default: 1.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_sex">sex</code></td>
<td>
<p>Gender codes of the created children (recycled if needed).</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels. In <code>addChildren()</code> these are the children
to be created. If NULL (default) given, automatic labels are generated.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_verbose">verbose</code></td>
<td>
<p>A logical: Verbose output or not.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_parents">parents</code></td>
<td>
<p>A vector of 1 or 2 ID labels, of which at least one must be an
existing member of <code>x</code>.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_id">id</code></td>
<td>
<p>The ID label of a pedigree member.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_remove">remove</code></td>
<td>
<p>Either &quot;ancestors&quot; or &quot;descendants&quot; (default), dictating the
method of removing pedigree members. Abbreviations are allowed.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_returnlabs">returnLabs</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, <code>removeIndividuals()</code>
returns only the labels of all members to be removed, instead of actually
removing them.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_subset">subset</code></td>
<td>
<p>A character vector (or coercible to such) with ID labels
forming a connected sub-pedigree.</p>
</td></tr>
<tr><td><code id="ped_modify_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>addChildren()</code> and <code>addParents()</code>, labels of added individuals are
generated automatically if they are not specified by the user. The automatic
labelling uses the smallest integers not already in use.
</p>
<p><code>addChild()</code>, <code>addSon()</code> and <code>addDaughter()</code> are convenient wrappers for the
most common use of <code>addChildren()</code>, namely adding a single child to a
pedigree. Note that the parents can be given in any order. If only one parent
is supplied, the other is created as a new individual.
</p>
<p><code>removeIndividuals()</code> removes the individuals indicated with <code>ids</code> along with
all of their ancestors OR descendants, depending on the <code>remove</code> argument.
Leftover spouses disconnected to the remaining pedigree are also removed. An
error is raised if result is a disconnected pedigree.
</p>
<p>The <code>branch()</code> function extracts the sub-pedigree formed by <code>id</code> and all
his/her spouses and descendants.
</p>
<p>Finally, <code>subset()</code> can be used to extract any connected sub-pedigree. (Note
that in the current implementation, the function does not actually check that
the indicated subset forms a connected pedigree; failing to comply with this
may lead to obscure errors.)
</p>


<h3>Value</h3>

<p>The modified <code>ped</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ped">ped()</a></code>, <code><a href="#topic+relabel">relabel()</a></code>, <code><a href="#topic+swapSex">swapSex()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(1) |&gt;
  addSon(3) |&gt;
  addParents(4, father = 6, mother = 7) |&gt;
  addChildren(father = 6, mother = 7, nch = 3, sex = c(2,1,2))

# Remove 6 and 7 and their descendants
y1 = removeIndividuals(x, 6:7)

# Remove 8-10 and their parents
y2 = removeIndividuals(x, 8:10, remove = "ancestors")

# Adding a child across components
z = singletons(1:2, sex = 1:2) |&gt; addDaughter(1:2)


</code></pre>

<hr>
<h2 id='ped_subgroups'>Pedigree subgroups</h2><span id='topic+ped_subgroups'></span><span id='topic+founders'></span><span id='topic+nonfounders'></span><span id='topic+leaves'></span><span id='topic+males'></span><span id='topic+females'></span><span id='topic+typedMembers'></span><span id='topic+untypedMembers'></span><span id='topic+father'></span><span id='topic+mother'></span><span id='topic+children'></span><span id='topic+offspring'></span><span id='topic+spouses'></span><span id='topic+unrelated'></span><span id='topic+parents'></span><span id='topic+grandparents'></span><span id='topic+siblings'></span><span id='topic+nephews_nieces'></span><span id='topic+ancestors'></span><span id='topic+commonAncestors'></span><span id='topic+descendants'></span><span id='topic+commonDescendants'></span><span id='topic+descentPaths'></span>

<h3>Description</h3>

<p>A collection of utility functions for identifying pedigree members with
certain properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>founders(x, internal = FALSE)

nonfounders(x, internal = FALSE)

leaves(x, internal = FALSE)

males(x, internal = FALSE)

females(x, internal = FALSE)

typedMembers(x, internal = FALSE)

untypedMembers(x, internal = FALSE)

father(x, id, internal = FALSE)

mother(x, id, internal = FALSE)

children(x, id, internal = FALSE)

offspring(x, id, internal = FALSE)

spouses(x, id, internal = FALSE)

unrelated(x, id, internal = FALSE)

parents(x, id, internal = FALSE)

grandparents(x, id, degree = 2, internal = FALSE)

siblings(x, id, half = NA, internal = FALSE)

nephews_nieces(x, id, removal = 1, half = NA, internal = FALSE)

ancestors(x, id, maxGen = Inf, inclusive = FALSE, internal = FALSE)

commonAncestors(x, ids, maxGen = Inf, inclusive = FALSE, internal = FALSE)

descendants(x, id, maxGen = Inf, inclusive = FALSE, internal = FALSE)

commonDescendants(x, ids, maxGen = Inf, inclusive = FALSE, internal = FALSE)

descentPaths(x, ids = founders(x), internal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped_subgroups_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+ped">ped()</a></code> object or a list of such.</p>
</td></tr>
<tr><td><code id="ped_subgroups_+3A_internal">internal</code></td>
<td>
<p>A logical indicating whether <code>id</code> (or <code>ids</code>) refers to the
internal order.</p>
</td></tr>
<tr><td><code id="ped_subgroups_+3A_id">id</code>, <code id="ped_subgroups_+3A_ids">ids</code></td>
<td>
<p>A character (or coercible to such) with one or several ID
labels.</p>
</td></tr>
<tr><td><code id="ped_subgroups_+3A_degree">degree</code>, <code id="ped_subgroups_+3A_removal">removal</code></td>
<td>
<p>Non-negative integers.</p>
</td></tr>
<tr><td><code id="ped_subgroups_+3A_half">half</code></td>
<td>
<p>a logical or NA. If TRUE (resp. FALSE), only half (resp. full)
siblings/cousins/nephews/nieces are returned. If NA, both categories are
included.</p>
</td></tr>
<tr><td><code id="ped_subgroups_+3A_maxgen">maxGen</code></td>
<td>
<p>The number of generations to include. Default: Inf (no limit).</p>
</td></tr>
<tr><td><code id="ped_subgroups_+3A_inclusive">inclusive</code></td>
<td>
<p>A logical indicating whether an individual should be counted
among his or her own ancestors/descendants</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>founders</code>, <code>nonfounders</code>, <code>males</code>, <code>females</code>, <code>leaves</code>
each return a vector containing the IDs of all pedigree members with the
wanted property. (Recall that a founder is a member without parents in the
pedigree, and that a leaf is a member without children in the pedigree.)
</p>
<p>The functions <code>father</code>, <code>mother</code>, <code>cousins</code>, <code>grandparents</code>,
<code>nephews_nieces</code>, <code>children</code>, <code>parents</code>, <code>siblings</code>, <code>spouses</code>,
<code>unrelated</code>, each returns a vector containing the IDs of all pedigree
members having the specified relationship with <code>id</code>.
</p>
<p>The commands <code>ancestors(x, id)</code> and <code>descendants(x, id)</code> return vectors
containing the IDs of all ancestors (resp. descendants) of the individual
<code>id</code> within the pedigree <code>x</code>. If <code>inclusive = TRUE</code>, <code>id</code> is included in
the output, otherwise not. To cut off at a specific number of generations,
use <code>maxGen</code>.
</p>
<p>For <code>commonAncestors(x, ids)</code> and <code>commonDescendants(x, ids)</code>, the output
is a vector containing the IDs of common ancestors (descendants) to all of
<code>ids</code>.
</p>
<p>Finally, <code>descentPaths(x, ids)</code> returns a list of lists, containing all
pedigree paths descending from each individual in <code>ids</code> (by default all
founders).
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = ped(id = 2:9,
        fid = c(0,0,2,0,4,4,0,2),
        mid = c(0,0,3,0,5,5,0,8),
        sex = c(1,2,1,2,1,2,2,2))

spouses(x, id = 2) # 3, 8
children(x, 2)     # 4, 9
siblings(x, 4)     # 9 (full or half)
unrelated(x, 4)    # 5, 8
father(x, 4)       # 2
mother(x, 4)       # 3

siblings(x, 4, half = FALSE) # none
siblings(x, 4, half = TRUE)  # 9

ancestors(x, 6)                               # 2, 3, 4, 5
ancestors(x, 6, maxGen = 2, inclusive = TRUE) # 4, 5, 6

descendants(x, 2)                                # 4, 6, 7, 9
descendants(x, 2, maxGen = 2, inclusive = TRUE)  # 2, 4, 9

leaves(x)          # 6, 7, 9
founders(x)        # 2, 3, 5, 8

</code></pre>

<hr>
<h2 id='ped_utils'>Pedigree utilities</h2><span id='topic+ped_utils'></span><span id='topic+pedsize'></span><span id='topic+generations'></span><span id='topic+hasUnbrokenLoops'></span><span id='topic+hasInbredFounders'></span><span id='topic+hasSelfing'></span><span id='topic+hasCommonAncestor'></span><span id='topic+subnucs'></span><span id='topic+peelingOrder'></span>

<h3>Description</h3>

<p>Various utility functions for <code>ped</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedsize(x)

generations(x, what = c("max", "compMax", "indiv", "depth"))

hasUnbrokenLoops(x)

hasInbredFounders(x, chromType = "autosomal")

hasSelfing(x)

hasCommonAncestor(x)

subnucs(x)

peelingOrder(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped_utils_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object, or (in some functions - see Details) a list of such.</p>
</td></tr>
<tr><td><code id="ped_utils_+3A_what">what</code></td>
<td>
<p>Either &quot;max&quot;, &quot;compMax&quot;, &quot;indiv&quot; or &quot;depth&quot; (See Value.)</p>
</td></tr>
<tr><td><code id="ped_utils_+3A_chromtype">chromType</code></td>
<td>
<p>Either &quot;autosomal&quot; (default) or &quot;x&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>pedsize(x)</code> returns the number of pedigree members in each component of
<code>x</code>.
</p>
</li>
<li> <p><code>generations(x)</code> by default returns the number of generations in <code>x</code>,
defined as the number of individuals in the longest line of parent-child
links. (Note that this is well-defined also if <code>x</code> has loops and/or
cross-generational marriages.) For individual generation numbers, use <code>what = "indiv"</code> (generation numbering as in the plot) or <code style="white-space: pre;">&#8288;what = "depth" (length of the longest chain up to a founder). Finally, if &#8288;</code>x<code style="white-space: pre;">&#8288; has multiple components, and what = "compMax"&#8288;</code>, the function returns a vector with the generation
count from each component.
</p>
</li>
<li> <p><code>hasUnbrokenLoops(x)</code> returns TRUE if <code>x</code> has loops, otherwise FALSE. (No
computation is done here; the function simply returns the value of
<code>x$UNBROKEN_LOOPS</code>).
</p>
</li>
<li> <p><code>hasInbredFounders(x)</code> returns TRUE is founder inbreeding is specified for
<code>x</code> and at least one founder has positive inbreeding coefficient. See
<code><a href="#topic+founderInbreeding">founderInbreeding()</a></code> for details.
</p>
</li>
<li> <p><code>hasSelfing(x)</code> returns TRUE if the pedigree contains selfing events. This
is recognised by father and mother begin equal for some child. (Note that for
this to be allowed, the gender code of the parent must be 0.)
</p>
</li>
<li> <p><code>hasCommonAncestor(x)</code> computes a logical matrix <code>A</code> whose entry <code>A[i,j]</code>
is TRUE if pedigree members i and j have a common ancestor in <code>x</code>, and FALSE
otherwise. By convention, <code>A[i,i]</code> is TRUE for all i.
</p>
</li>
<li> <p><code>subnucs(x)</code> returns a list of all nuclear sub-pedigrees of <code>x</code>, wrapped as
<code>nucleus</code> objects. Each nucleus is a list with entries <code>father</code>, <code>mother</code> and
<code>children</code>.
</p>
</li>
<li> <p><code>peelingOrder(x)</code> calls <code>subnucs(x)</code> and extends each entry with a <code>link</code>
individual, indicating a member linking the nucleus to the remaining
pedigree. One application of this function is the fact that if <em>fails</em> to
find a complete peeling order if and only if the pedigree has loops. (In fact
it is called each time a new <code>ped</code> object is created by <code><a href="#topic+ped">ped()</a></code> in order to
detect loops.) The main purpose of the function, however, is to prepare for
probability calculations in other packages, as e.g. in
<code>pedprobr::likelihood</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x = fullSibMating(1)
stopifnot(pedsize(x) == 6)
stopifnot(hasUnbrokenLoops(x))
stopifnot(generations(x) == 3)

# All members have common ancestors except the grandparents
CA = hasCommonAncestor(x)
stopifnot(!CA[1,2], !CA[2,1], sum(CA) == length(CA) - 2)

# Effect of breaking the loop
y = breakLoops(x)
stopifnot(!hasUnbrokenLoops(y))
stopifnot(pedsize(y) == 7)

# A pedigree with selfing (note the necessary `sex = 0`)
z1 = singleton(1, sex = 0)
z2 = addChildren(z1, father = 1, mother = 1, nch = 1)
stopifnot(!hasSelfing(z1), hasSelfing(z2))

# Nucleus sub-pedigrees
stopifnot(length(subnucs(z1)) == 0)
peelingOrder(cousinPed(1))

# Plot with generation numbers as labels
w = cousinPed(1)
g = generations(w, what = "indiv")
labs = setNames(labels(w), g)
plot(w, labs = labs)

# ... compare with
plot(relabel(w, "generations"))

</code></pre>

<hr>
<h2 id='plot.ped'>Plot pedigree</h2><span id='topic+plot.ped'></span><span id='topic+drawPed'></span><span id='topic+plot.pedList'></span><span id='topic+plot.list'></span>

<h3>Description</h3>

<p>This is the main function for plotting pedigrees. Many options are available
for controlling the appearance of pedigree symbols and accompanying labels.
The most important ones are illustrated in the Examples section below; for a
complete overview, see the separate page <a href="#topic+plotmethods">plotmethods</a>, which also explains
the plotting procedure in more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ped'
plot(x, draw = TRUE, keep.par = FALSE, ...)

drawPed(alignment, annotation = NULL, scaling = NULL, keep.par = FALSE, ...)

## S3 method for class 'pedList'
plot(x, ...)

## S3 method for class 'list'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ped_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+ped">ped()</a></code> object or a list of such.</p>
</td></tr>
<tr><td><code id="plot.ped_+3A_draw">draw</code></td>
<td>
<p>A logical, by default TRUE. If FALSE, no plot is produced, only
the plotting parameters are returned.</p>
</td></tr>
<tr><td><code id="plot.ped_+3A_keep.par">keep.par</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, the graphical
parameters are not reset after plotting, which may be useful for adding
additional annotation.</p>
</td></tr>
<tr><td><code id="plot.ped_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the internal plot functions. For a complete
list of parameters, see <a href="#topic+plotmethods">plotmethods</a>. The most important ones are
illustrated in the Examples below.</p>
</td></tr>
<tr><td><code id="plot.ped_+3A_alignment">alignment</code></td>
<td>
<p>List of alignment details, as returned by <code><a href="#topic+.pedAlignment">.pedAlignment()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ped_+3A_annotation">annotation</code></td>
<td>
<p>List of annotation details as returned by <code><a href="#topic+.pedAnnotation">.pedAnnotation()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ped_+3A_scaling">scaling</code></td>
<td>
<p>List of scaling parameters as returned by <code><a href="#topic+.pedScaling">.pedScaling()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main pedigree layout is calculated with the <code>kinship2</code> package, see
<a href="kinship2.html#topic+align.pedigree">kinship2::align.pedigree</a> for details. Unlike <code>kinship2</code>, the implementation
here also supports singletons, and plotting pedigrees as DAGs. In addition,
some minor adjustments have been made to improve scaling and avoid unneeded
duplications.
</p>
<p>If <code>x</code> is a list of <code>ped</code> objects these are plotted next to each other,
vertically centred in the plot window. For finer control, and possibly
nested lists of pedigrees, use <code><a href="#topic+plotPedList">plotPedList()</a></code>.
</p>


<h3>Value</h3>

<p>A list of three lists with various plot details: <code>alignment</code>,
<code>annotation</code>, <code>scaling</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPedList">plotPedList()</a></code>, <code><a href="kinship2.html#topic+plot.pedigree">kinship2::plot.pedigree()</a></code>. Plot options are
documented in <a href="#topic+plotmethods">plotmethods</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Singleton
plot(singleton(1))

# Trio
x = nuclearPed(father = "fa", mother = "mo", child = "boy")
plot(x)

#' # Modify margins
plot(x, margins = 6)
plot(x, margins = c(0,0,6,6)) # b,l,t,r

# Larger text and symbols
plot(x, cex = 1.5)

# Enlarge symbols only
plot(x, symbolsize = 1.5)

# Various annotations
plot(x, hatched = "boy", starred = "fa", deceased = "mo", title = "Fam 1")

# Swap spouse order
plot(x, spouseOrder = c("mo", "fa"))

#----- ID labels -----

# Label only some members
plot(x, labs = c("fa", "mo"))

# Label males only
plot(x, labs = males)

# Rename some individuals
plot(x, labs = c(FATHER = "fa", "boy"))

# By default, long names are folded to width ~12 characters
plot(x, labs = c("Very long father's name" = "fa"), margin = 2)

# Folding width may be adjusted ...
plot(x, labs = c("Very long father's name" = "fa"), foldLabs = 6)

# ... or switched off (requires larger margin!)
plot(x, labs = c("Very long father's name" = "fa"), foldLabs = FALSE)

# By default, labels are trimmed for initial/trailing line breaks ...
plot(x, labs = c("\nFA" = "fa"))

# ... but this can be overridden
plot(x, labs = c("\nFA" = "fa"), trimLabs = FALSE)

#----- Colours -----

plot(x, col = c(fa = "red"), fill = c(mo = "green", boy = "blue"))

# Non-black hatch colours are specified with the `fill` argument
plot(x, hatched = labels, fill = c(boy = "red"))

# Use functions to specify colours
plot(x, fill = list(red = leaves, blue = ancestors(x, "boy")))

#----- Symbol line types and widths -----

# Dotted, thick symbols
plot(x, lty = 3, lwd = 4, cex = 2)

# Detailed specification of line types and width
plot(x, lty = list(dashed = founders), lwd = c(boy = 4))

#----- Genotypes -----

x = nuclearPed(father = "fa", mother = "mo", child = "boy") |&gt;
  addMarker(fa = "1/1", boy = "1/2", name = "SNP") |&gt;
  addMarker(boy = "a/b")

# Show genotypes for first marker
plot(x, marker = 1)

# Show empty genotypes for untyped individuas
plot(x, marker = 1, showEmpty = TRUE)

# Markers can also be called by name
plot(x, marker = "SNP")

# Multiple markers
plot(x, marker = 1:2)

#----- Further text annotation -----

# Founder inbreeding is shown by default
xinb = x |&gt; setFounderInbreeding("mo", value = 0.1)
plot(xinb)

# ... but can be suppressed
plot(xinb, fouInb = NULL)

# Text can be placed around and inside symbols
plot(x, textAnnot = list(topright = 1:3, inside = LETTERS[1:3]))

# Use lists to add further options; see `?text()`
plot(x, margin = 2, textAnnot = list(
  topright = list(1:3, cex = 0.8, col = 2, font = 2, offset = 0.1),
  left = list(c(boy = "comment"), cex = 2, col = 4, offset = 2, srt = 20)))

# Exhaustive list of annotation positions
plot(singleton(1), cex = 3, textAnnot = list(top="top", left="left",
  right="right", bottom="bottom", topleft="topleft", topright="topright",
  bottomleft="bottomleft", bottomright="bottomright", inside="inside"))

#----- Special pedigrees -----

# Plot as DAG (directed acyclic graph)
plot(x, arrows = TRUE, title = "DAG")

# Medical pedigree
plot(x, aff = "boy", carrier = "mo")

# Twins
x = nuclearPed(children = c("tw1", "tw2", "tw3"))
plot(x, twins = data.frame(id1 = "tw1", id2 = "tw2", code = 1)) # MZ
plot(x, twins = data.frame(id1 = "tw1", id2 = "tw2", code = 2)) # DZ

# Triplets
plot(x, twins = data.frame(id1 = c("tw1", "tw2"),
                           id2 = c("tw2", "tw3"),
                           code = 2))

# Selfing
plot(selfingPed(2))

# Complex pedigree: Quadruple half first cousins
plot(quadHalfFirstCousins())

# Straight legs
plot(quadHalfFirstCousins(), align = c(0,0))

# Lists of multiple pedigree
plot(list(singleton(1), nuclearPed(1), linearPed(2)))

# Use of `drawPed()`
dat = plot(nuclearPed(), draw = FALSE)
drawPed(dat$alignment, dat$annotation, dat$scaling)

</code></pre>

<hr>
<h2 id='plotmethods'>Internal plot methods</h2><span id='topic+plotmethods'></span><span id='topic+.pedAlignment'></span><span id='topic+.pedAnnotation'></span><span id='topic+.pedScaling'></span><span id='topic+.drawPed'></span><span id='topic+.annotatePed'></span>

<h3>Description</h3>

<p>The main purpose of this page is to document the many options for pedigree
plotting. Most of the arguments shown here may be supplied directly in
<code>plot(x, ...)</code>, where <code>x</code> is a pedigree. See <code><a href="#topic+plot.ped">plot.ped()</a></code> for many examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pedAlignment(
  x = NULL,
  plist = NULL,
  arrows = FALSE,
  twins = NULL,
  packed = TRUE,
  width = 10,
  align = c(1.5, 2),
  spouseOrder = NULL,
  hints = NULL,
  ...
)

.pedAnnotation(
  x,
  title = NULL,
  marker = NULL,
  sep = "/",
  missing = "-",
  showEmpty = FALSE,
  labs = labels(x),
  foldLabs = 12,
  trimLabs = TRUE,
  col = 1,
  fill = NA,
  lty = 1,
  lwd = 1,
  hatched = NULL,
  hatchDensity = 25,
  aff = NULL,
  carrier = NULL,
  deceased = NULL,
  starred = NULL,
  textAnnot = NULL,
  textInside = NULL,
  textAbove = NULL,
  fouInb = "autosomal",
  ...
)

.pedScaling(
  alignment,
  annotation,
  cex = 1,
  symbolsize = 1,
  margins = 1,
  addSpace = 0,
  xlim = NULL,
  ylim = NULL,
  vsep2 = FALSE,
  autoScale = FALSE,
  minsize = 0.15,
  ...
)

.drawPed(alignment, annotation, scaling)

.annotatePed(
  alignment,
  annotation,
  scaling,
  font = NULL,
  fam = NULL,
  col = NULL,
  colUnder = 1,
  colInside = 1,
  colAbove = 1,
  cex.main = NULL,
  font.main = NULL,
  col.main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmethods_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+ped">ped()</a></code> object.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_plist">plist</code></td>
<td>
<p>Alignment list with format similar to
<code><a href="kinship2.html#topic+align.pedigree">kinship2::align.pedigree()</a></code>.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_arrows">arrows</code></td>
<td>
<p>A logical (default = FALSE). If TRUE, the pedigree is plotted
as a DAG, i.e., with arrows connecting parent-child pairs.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_twins">twins</code></td>
<td>
<p>A data frame with columns <code>id1</code>, <code>id2</code> and <code>code</code>, passed on to
the <code>relation</code> parameter of <code><a href="kinship2.html#topic+plot.pedigree">kinship2::plot.pedigree()</a></code>.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_packed">packed</code>, <code id="plotmethods_+3A_width">width</code>, <code id="plotmethods_+3A_align">align</code></td>
<td>
<p>Parameters passed on to
<code><a href="kinship2.html#topic+align.pedigree">kinship2::align.pedigree()</a></code>. Can usually be left untouched.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_spouseorder">spouseOrder</code></td>
<td>
<p>An optional vector (or list of vectors) indicating plot
ordering for spouses. (This is converted into a matrix and forward as
<code>hints</code>; see below.)</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_hints">hints</code></td>
<td>
<p>An optional list of hints passed on to
<code><a href="kinship2.html#topic+align.pedigree">kinship2::align.pedigree()</a></code>.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_...">...</code></td>
<td>
<p>Further parameters passed between methods.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_title">title</code></td>
<td>
<p>The plot title. If NULL (default) or &rdquo;, no title is added to
the plot.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_marker">marker</code></td>
<td>
<p>Either a vector of names or indices referring to markers
attached to <code>x</code>, a <code>marker</code> object, or a list of such. The genotypes for
the chosen markers are written below each individual in the pedigree, in
the format determined by <code>sep</code> and <code>missing</code>. See also <code>showEmpty</code>. If NULL
(the default), no genotypes are plotted.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_sep">sep</code></td>
<td>
<p>A character of length 1 separating alleles for diploid markers.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_missing">missing</code></td>
<td>
<p>The symbol (integer or character) for missing alleles.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_showempty">showEmpty</code></td>
<td>
<p>A logical, indicating if empty genotypes should be included.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_labs">labs</code></td>
<td>
<p>A vector or function controlling the individual labels in the
plot. By default, <code>labels(x)</code> are used. See Details for valid formats.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_foldlabs">foldLabs</code></td>
<td>
<p>A number or function controlling the folding of long labels.
If a number, line breaks are inserted at roughly this width, trying to
break at break-friendly characters. If a function, this is applied to each
label.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_trimlabs">trimLabs</code></td>
<td>
<p>A logical, by default TRUE. Removes line breaks and tabs from
both ends of the labels (after adding genotypes, if <code>marker</code> is not NULL).</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_col">col</code></td>
<td>
<p>A vector or list specifying outline colours for the pedigree
members. See Details for valid formats.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_fill">fill</code></td>
<td>
<p>A vector or list specifying fill/hatch colours for the pedigree
members. See Details for valid formats. Note that if <code>fill</code> is unnamed, and
either <code>aff</code> or <code>hatched</code> are given, then the fill colour is applied only
to those.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_lty">lty</code>, <code id="plotmethods_+3A_lwd">lwd</code></td>
<td>
<p>Vectors or lists specifying linetype and width of pedigree
symbol outlines. See Details for valid formats.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_hatched">hatched</code></td>
<td>
<p>A vector of labels identifying members whose plot symbols
should be hatched.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_hatchdensity">hatchDensity</code></td>
<td>
<p>A number specifying the hatch density in lines per inch.
Default: 25.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_aff">aff</code></td>
<td>
<p>A vector of labels identifying members whose plot symbols should
be filled. (This is typically used in medical pedigrees to indicate
affected members.)</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_carrier">carrier</code></td>
<td>
<p>A vector of labels identifying members whose plot symbols
should be marked with a dot. (This is typically used in medical pedigrees
to indicate unaffected carriers of the disease allele.)</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_deceased">deceased</code></td>
<td>
<p>A vector of labels indicating deceased pedigree members.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_starred">starred</code></td>
<td>
<p>A vector of labels indicating pedigree members that should be
marked with a star in the pedigree plot.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_textannot">textAnnot</code></td>
<td>
<p>A list specifying further text annotation around or inside
the pedigree symbols. See Details for more information.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_textinside">textInside</code>, <code id="plotmethods_+3A_textabove">textAbove</code></td>
<td>
<p>Character vectors of text to be printed inside or
above pedigree symbols. [Soft deprecated; replaced by <code>textAnnot</code>.]</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_fouinb">fouInb</code></td>
<td>
<p>Either &quot;autosomal&quot; (default), &quot;x&quot; or NULL. If &quot;autosomal&quot; or
&quot;x&quot;, inbreeding coefficients are added to the plot above the inbred
founders. If NULL, or if no founders are inbred, nothing is added.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_alignment">alignment</code></td>
<td>
<p>List of alignment details, as returned by <code><a href="#topic+.pedAlignment">.pedAlignment()</a></code>.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_annotation">annotation</code></td>
<td>
<p>List of annotation details as returned by
<code><a href="#topic+.pedAnnotation">.pedAnnotation()</a></code>.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_cex">cex</code></td>
<td>
<p>Expansion factor controlling font size. This also affects symbol
sizes, which by default have the width of 2.5 characters. Default: 1.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_symbolsize">symbolsize</code></td>
<td>
<p>Expansion factor for pedigree symbols. Default: 1.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_margins">margins</code></td>
<td>
<p>A numeric indicating the plot margins. If a single number is
given, it is recycled to length 4.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_addspace">addSpace</code></td>
<td>
<p>A numeric of length 4, indicating extra padding (in inches)
around the pedigree inside the plot region. Default: 0.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_xlim">xlim</code>, <code id="plotmethods_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vectors of length 2, used to set <code>par("usr")</code>
explicitly. Rarely needed by end users.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_vsep2">vsep2</code></td>
<td>
<p>A logical; for internal use.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_autoscale">autoScale</code></td>
<td>
<p>A logical. It TRUE, an attempt is made to adjust <code>cex</code> so
that the symbol dimensions are at least <code>minsize</code> inches. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_minsize">minsize</code></td>
<td>
<p>A positive number, by default 0.15. (See <code>autoScale</code>.)</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_scaling">scaling</code></td>
<td>
<p>List of scaling parameters as returned by <code><a href="#topic+.pedScaling">.pedScaling()</a></code>.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_font">font</code>, <code id="plotmethods_+3A_fam">fam</code></td>
<td>
<p>Arguments passed on to <code><a href="graphics.html#topic+text">text()</a></code>.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_colunder">colUnder</code>, <code id="plotmethods_+3A_colinside">colInside</code>, <code id="plotmethods_+3A_colabove">colAbove</code></td>
<td>
<p>Colour vectors.</p>
</td></tr>
<tr><td><code id="plotmethods_+3A_cex.main">cex.main</code>, <code id="plotmethods_+3A_col.main">col.main</code>, <code id="plotmethods_+3A_font.main">font.main</code></td>
<td>
<p>Parameters passed on to <code><a href="graphics.html#topic+title">title()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The workflow of <code>plot.ped(x, ...)</code> is approximately as follows:
</p>
<div class="sourceCode"><pre>
# Calculate plot parameters

align = .pedAlignment(x, ...)

annot = .pedAnnotation(x, ...)

scale = .pedScaling(align, annot, ...)

# Produce plot

.drawPed(align, annot, scale)

.annotatePed(align, annot, scale)

</pre></div>
<p>The <code>labs</code> argument control the individual ID labels printed below the
pedigree symbols. By default the output of <code>labels(x)</code> is used, but there are
several alternative forms:
</p>

<ul>
<li><p> If <code>labs</code> is a vector with nonempty intersection with <code>labels(x)</code>, only
these individuals will be labelled. If the vector is named, then the names
are used instead of the ID label. (See Examples.)
</p>
</li>
<li><p> If <code>labs</code> is the word &quot;num&quot;, then all individuals are numerically
labelled following the internal ordering.
</p>
</li>
<li><p> Use <code>labs = NULL</code> to remove all labels.
</p>
</li>
<li><p> If <code>labs</code> is a function, it is replaced with <code>labs(x)</code> and handled as
above. (See Examples.)
</p>
</li></ul>

<p>The argument <code>textAnnot</code> allows customised annotation around and inside each
symbol. This takes a list of lists, whose names may include &quot;topleft&quot;,
&quot;topright&quot;, &quot;left&quot;, &quot;right&quot;, &quot;bottomleft&quot;, &quot;bottom&quot;, &quot;bottomright&quot; and
&quot;inside&quot;. Each inner list should contain a character vector as its first
element (with the text to printed), followed by further arguments passed to
<code><a href="graphics.html#topic+text">text()</a></code>. For example, <code>textAnnot = list(left = list(c(A = "1"), cex = 2))</code>
prints a large number &quot;1&quot; to the left of individual A (if such an individual
exists in the pedigree. See Examples.
</p>
<p>The arguments <code>col</code>, <code>fill</code>, <code>lty</code> and <code>lwd</code> can all be indicated in a number
of ways:
</p>

<ul>
<li><p> An unnamed vector. This will be recycled and applied to all members. For
example, <code>lty = 2</code> gives everyone a dashed outline.
</p>
</li>
<li><p> A named vector. Only pedigree members appearing in the names are affected.
Example: <code>fill = c("1" = "red", foo = "blue")</code> fills individual <code>1</code> red and
<code>foo</code> blue.
</p>
</li>
<li><p> A list of ID vectors, where the list names indicate the parameter values.
Example: <code>col = list(red = 1:2, blue = 3:5)</code>.
</p>
</li>
<li><p> List entries may also be functions, taking the pedigree <code>x</code> as input and
producing a vector of ID labels. The many built-in functions in
<a href="#topic+ped_subgroups">ped_subgroups</a> are particularly handy here, e.g.: <code>fill = list(red = founders, blue = leaves)</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed()

align = .pedAlignment(x)
annot = .pedAnnotation(x)
scale = .pedScaling(align, annot)

frame()
drawPed(align, annot, scale)

</code></pre>

<hr>
<h2 id='plotPedList'>Plot a collection of pedigrees.</h2><span id='topic+plotPedList'></span>

<h3>Description</h3>

<p>This function creates a row of pedigree plots, each created by <code><a href="#topic+plot.ped">plot.ped()</a></code>.
Any parameter accepted by <code><a href="#topic+plot.ped">plot.ped()</a></code> can be applied, either to all plots
simultaneously, or to individual plots.  Some effort is made to guess a
reasonable window size and margins, but in general the user must be prepared
to do manual resizing of the plot window. See various examples in the
Examples section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPedList(
  plots,
  widths = NULL,
  groups = NULL,
  titles = NULL,
  frames = TRUE,
  fmar = NULL,
  source = NULL,
  dev.height = NULL,
  dev.width = NULL,
  newdev = !is.null(dev.height) || !is.null(dev.width),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPedList_+3A_plots">plots</code></td>
<td>
<p>A list of lists. Each element of <code>plots</code> is a list, where the
first element is a pedigree, and the remaining elements are passed on to
<code>plot.ped</code>. These elements must be correctly named. See examples below.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_widths">widths</code></td>
<td>
<p>A numeric vector of relative widths of the subplots. Recycled
to <code>length(plots)</code> if necessary, before passed on to <code><a href="graphics.html#topic+layout">layout()</a></code>. Note that
the vector does not need to sum to 1.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_groups">groups</code></td>
<td>
<p>A list of vectors, each consisting of consecutive integers,
indicating subplots to be grouped. By default the grouping follows the list
structure of <code>plots</code>.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_titles">titles</code></td>
<td>
<p>A character vector of titles for each group. Overrides titles
given in individuals subplots.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_frames">frames</code></td>
<td>
<p>A logical indicating if groups should be framed.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_fmar">fmar</code></td>
<td>
<p>A single number in the interval <code class="reqn">[0,0.5)</code> controlling the
position of the frames.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_source">source</code></td>
<td>
<p>NULL (default), or the name or index of an element of <code>plots</code>.
If given, marker data is temporarily transferred from this to all the other
pedigrees. This may save some typing when plotting the same genotypes on
several pedigrees.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_dev.height">dev.height</code>, <code id="plotPedList_+3A_dev.width">dev.width</code></td>
<td>
<p>The dimensions of the new plot window. If these
are NA suitable values are guessed from the pedigree sizes.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_newdev">newdev</code></td>
<td>
<p>A logical, indicating if a new plot window should be opened.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to each call to <code><a href="#topic+plot.ped">plot.ped()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for tweaking dev.height and dev.width the function <code><a href="grDevices.html#topic+dev.size">dev.size()</a></code> is
useful to determine the size of the active device.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ped">plot.ped()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Basic examples #
##################

# Simples use: Just give a list of ped objects.
peds = list(nuclearPed(3), cousinPed(2), singleton(12), halfSibPed())
plotPedList(peds, newdev = TRUE)

# Override automatic determination of relative widths
w = c(2, 3, 1, 2)
plotPedList(peds, widths = w)

# In most cases the guessed dimensions are ok but not perfect.
# Resize plot window manually and re-plot with `newdev = FALSE` (default)
# plotPedList(peds, widths = w)

## Remove frames
plotPedList(peds, widths = w, frames = FALSE)

# Non-default grouping
plotPedList(peds, widths = w, groups = list(1, 2:3, 4), titles = 1:3)

# Parameters added in the main call are used in each sub-plot
plotPedList(peds, widths = w, labs = leaves, hatched = leaves,
            col = list(blue = males, red = females), symbolsize = 1.3)

dev.off()

#################################
# Example of automatic grouping #
#################################
H1 = nuclearPed()
H2 = singletons(id = c(1,3))

plotPedList(list(H1, H2), dev.height = 3, dev.width = 4,
            titles = c(expression(H[1]), expression(H[2])),
            cex = 1.5, cex.main = 1.3)

dev.off()

############################################################
# Complex example with individual parameters for each plot #
############################################################

# For more control of individual plots, each plot and all
# its parameters can be specified in its own list.

x1 = nuclearPed(nch = 3) |&gt;
  addMarker(`3` = "1/2")
plot1 = list(x1, title = "Plot 1", marker = 1, deceased = 1:2, cex = 1.3,
             margins = c(7, 4, 7, 4))

x2 = cousinPed(2) |&gt;
  addMarker(`11` = "A/A", `12` = "A/A")
plot2 = list(x2, title = "Family", marker = 1, symbolsize = 1.2, labs = NULL,
             margins = c(3, 4, 2, 4))

x3 = singleton("NN")
plot3 = list(x3, cex = 2, carrier = "NN", lty = c(NN = 2))

x4 = halfSibPed()
plot4 = list(x4, title = "Half sibs", cex = 1.3, hatched = leaves,
             col = list(red = founders), fill = list(blue = leaves),
             margins = c(7, 4, 7, 4))

plotPedList(list(plot1, plot2, plot3, plot4), widths = c(2,3,1,2),
            fmar = 0.03, groups = list(1, 2:3, 4), newdev = TRUE,
            cex.main = 1.5)

dev.off()

################################
# Example with large pedigrees #
################################

# Important to set device dimensions here

plotPedList(list(halfCousinPed(4), cousinPed(7)),
            titles = c("Large", "Very large"), widths = c(1, 1.3),
            dev.height = 8, dev.width = 6, margins = 1.5)

dev.off()

</code></pre>

<hr>
<h2 id='print.nucleus'>S3 methods</h2><span id='topic+print.nucleus'></span>

<h3>Description</h3>

<p>S3 methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nucleus'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nucleus_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="print.nucleus_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>

<hr>
<h2 id='print.ped'>Printing pedigrees</h2><span id='topic+print.ped'></span>

<h3>Description</h3>

<p>Print a <code>ped</code> object using original labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ped'
print(x, ..., markers, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ped_+3A_x">x</code></td>
<td>
<p>object of class <code>ped</code>.</p>
</td></tr>
<tr><td><code id="print.ped_+3A_...">...</code></td>
<td>
<p>(optional) arguments passed on to <code><a href="base.html#topic+print.data.frame">print.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="print.ped_+3A_markers">markers</code></td>
<td>
<p>(optional) vector of marker indices. If missing, and <code>x</code> has
less than 10 markers, they are all displayed. If <code>x</code> has 10 or more
markers, the first 5 are displayed.</p>
</td></tr>
<tr><td><code id="print.ped_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, a message is printed if only the first 5 markers are
printed. (See above).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This first calls <code><a href="#topic+as.data.frame.ped">as.data.frame.ped()</a></code> and then prints the resulting
data.frame. The data.frame is returned invisibly.
</p>

<hr>
<h2 id='randomPed'>Random pedigree</h2><span id='topic+randomPed'></span>

<h3>Description</h3>

<p>Generate a random connected pedigree by applying random mating starting from
a finite population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomPed(n, founders = 2, maxDirectGap = 1, selfing = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomPed_+3A_n">n</code></td>
<td>
<p>A positive integer: the total number of individuals. Must be at
least 3.</p>
</td></tr>
<tr><td><code id="randomPed_+3A_founders">founders</code></td>
<td>
<p>A positive integer: the number of founders. Must be at least
2 unless selfing is allowed.</p>
</td></tr>
<tr><td><code id="randomPed_+3A_maxdirectgap">maxDirectGap</code></td>
<td>
<p>An integer; the maximum distance between direct
descendants allowed to mate. For example, the default value of 1 allows
parent-child mating, but not grandparent-grandchild. Set to <code>Inf</code> or <code>NULL</code>
to remove all restrictions.</p>
</td></tr>
<tr><td><code id="randomPed_+3A_selfing">selfing</code></td>
<td>
<p>A logical indicating if selfing is allowed. Default: FALSE.</p>
</td></tr>
<tr><td><code id="randomPed_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting from an initial set of founders, a sequence of <code>n - founders</code> random
matings is performed. The sampling of parents in each mating is set up to
ensure that the final result is connected.
</p>


<h3>Value</h3>

<p>A connected pedigree returned as a <code>ped</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(randomPed(n = 7, seed = 12))

# Disallow mating between direct descendants
plot(randomPed(n = 7, seed = 12, maxDirectGap = 0))

# No restrictions on mating between direct descendants
plot(randomPed(n = 7, seed = 12, maxDirectGap = Inf))

# Allow selfing
y = randomPed(5, seed = 2, selfing = TRUE)
hasSelfing(y)
y
plot(y, arrows = TRUE)

</code></pre>

<hr>
<h2 id='readPed'>Read a pedigree from file</h2><span id='topic+readPed'></span>

<h3>Description</h3>

<p>Reads a text file in pedigree format, or something fairly close to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readPed(
  pedfile,
  colSep = "",
  header = NA,
  famid_col = NA,
  id_col = NA,
  fid_col = NA,
  mid_col = NA,
  sex_col = NA,
  marker_col = NA,
  locusAttributes = NULL,
  missing = 0,
  sep = NULL,
  colSkip = NULL,
  sexCodes = NULL,
  addMissingFounders = FALSE,
  validate = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readPed_+3A_pedfile">pedfile</code></td>
<td>
<p>A file name</p>
</td></tr>
<tr><td><code id="readPed_+3A_colsep">colSep</code></td>
<td>
<p>A column separator character, passed on as the <code>sep</code> argument
of <code><a href="utils.html#topic+read.table">read.table()</a></code>. The default is to separate on white space, that is, one
or more spaces, tabs, newlines or carriage returns. (Note: the parameter
<code>sep</code> is used to indicate allele separation in genotypes.)</p>
</td></tr>
<tr><td><code id="readPed_+3A_header">header</code></td>
<td>
<p>A logical. If NA, the program will interpret the first line as
a header line it contains both &quot;id&quot; and &quot;sex&quot; as part of some entries
(ignoring case).</p>
</td></tr>
<tr><td><code id="readPed_+3A_famid_col">famid_col</code></td>
<td>
<p>Index of family ID column. If NA, the program looks for a
column named &quot;famid&quot; (ignoring case).</p>
</td></tr>
<tr><td><code id="readPed_+3A_id_col">id_col</code></td>
<td>
<p>Index of individual ID column. If NA, the program looks for a
column named &quot;id&quot; (ignoring case).</p>
</td></tr>
<tr><td><code id="readPed_+3A_fid_col">fid_col</code></td>
<td>
<p>Index of father ID column. If NA, the program looks for a
column named &quot;fid&quot; (ignoring case).</p>
</td></tr>
<tr><td><code id="readPed_+3A_mid_col">mid_col</code></td>
<td>
<p>Index of mother ID column. If NA, the program looks for a
column named &quot;mid&quot; (ignoring case).</p>
</td></tr>
<tr><td><code id="readPed_+3A_sex_col">sex_col</code></td>
<td>
<p>Index of column with gender codes (0 = unknown; 1 = male; 2 =
female). If NA, the program looks for a column named &quot;sex&quot; (ignoring case).
If this is not found, genders of parents are deduced from the data, leaving
the remaining as unknown.</p>
</td></tr>
<tr><td><code id="readPed_+3A_marker_col">marker_col</code></td>
<td>
<p>Index vector indicating columns with marker alleles. If NA,
all columns to the right of all pedigree columns are used. If <code>sep</code> (see
below) is non-NULL, each column is interpreted as a genotype column and
split into separate alleles with <code>strsplit(..., split = sep, fixed = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="readPed_+3A_locusattributes">locusAttributes</code></td>
<td>
<p>Passed on to <code><a href="#topic+setMarkers">setMarkers()</a></code> (see explanation there).</p>
</td></tr>
<tr><td><code id="readPed_+3A_missing">missing</code></td>
<td>
<p>Passed on to <code><a href="#topic+setMarkers">setMarkers()</a></code> (see explanation there).</p>
</td></tr>
<tr><td><code id="readPed_+3A_sep">sep</code></td>
<td>
<p>Passed on to <code><a href="#topic+setMarkers">setMarkers()</a></code> (see explanation there).</p>
</td></tr>
<tr><td><code id="readPed_+3A_colskip">colSkip</code></td>
<td>
<p>Columns to skip, given as a vector of indices or columns
names. If given, these columns are removed directly after <code>read.table()</code>,
before any other processing.</p>
</td></tr>
<tr><td><code id="readPed_+3A_sexcodes">sexCodes</code></td>
<td>
<p>A list with optional entries &quot;male&quot;, &quot;female&quot; and &quot;unknown&quot;,
indicating how non-default entries in the <code>sex</code> column should be
interpreted. Default values: male = 1, female = 2, unknown = 0.</p>
</td></tr>
<tr><td><code id="readPed_+3A_addmissingfounders">addMissingFounders</code></td>
<td>
<p>A logical. If TRUE, any parent not included in the
<code>id</code> column is added as a founder of corresponding sex. By default, missing
founders result in an error.</p>
</td></tr>
<tr><td><code id="readPed_+3A_validate">validate</code></td>
<td>
<p>A logical indicating if the pedigree structure should be
validated.</p>
</td></tr>
<tr><td><code id="readPed_+3A_...">...</code></td>
<td>
<p>Further parameters passed on to <code><a href="utils.html#topic+read.table">read.table()</a></code>, e.g.
<code>comment.char</code> and <code>quote</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are no headers, and no column information is provided by the user,
the program assumes the following column order:
</p>

<ul>
<li><p> family ID (optional; guessed from the data)
</p>
</li>
<li><p> individual ID
</p>
</li>
<li><p> father's ID
</p>
</li>
<li><p> mother's ID
</p>
</li>
<li><p> sex
</p>
</li>
<li><p> marker data (remaining columns)
</p>
</li></ul>



<h4>Reading SNP data</h4>

<p>Adding the argument <code>locusAttributes = "snp-AB"</code>, sets all markers to be
equifrequent SNPs with alleles A and B. Moreover, the letters A and B may be
replaced by other single-character letters or numbers, e.g., &quot;snp-12&quot; gives
alleles 1 and 2.
</p>



<h3>Value</h3>

<p>A <a href="#topic+ped">ped</a> object or a list of such.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tf = tempfile()

### Write and read a trio
trio = data.frame(id = 1:3, fid = c(0,0,1), mid = c(0,0,2), sex = c(1,2,1))
write.table(trio, file = tf, row.names = FALSE)
readPed(tf)

# With marker data in one column
trio.marker = cbind(trio, M = c("1/1", "2/2", "1/2"))
write.table(trio.marker, file = tf, row.names = FALSE)
readPed(tf)

# With marker data in two allele columns
trio.marker2 = cbind(trio, M.1 = c(1,2,1), M.2 = c(1,2,2))
write.table(trio.marker2, file = tf, row.names = FALSE)
readPed(tf)

### Two singletons in the same file
singles = data.frame(id = c("S1", "S2"),
                     fid = c(0,0), mid = c(0,0), sex = c(2,1),
                     M = c("9/14.2", "9/9"))
write.table(singles, file = tf, row.names = FALSE)
readPed(tf)

### Two trios in the same file
trio2 = cbind(famid = rep(c("trio1", "trio2"), each = 3), rbind(trio, trio))

# With column names
write.table(trio2, file = tf, col.names = TRUE, row.names = FALSE)
readPed(tf)

# Without column names
write.table(trio2, file = tf, col.names = FALSE, row.names = FALSE)
readPed(tf)

### With non-standard `sex` codes
trio3 = data.frame(id = 1:3, fid = c(0,0,1), mid = c(0,0,2),
                   sex = c("male","female","?"))
write.table(trio3, file = tf, row.names = FALSE)
readPed(tf, sexCodes = list(male = "male", female = "female", unknown = "?"))

# Cleanup
unlink(tf)

</code></pre>

<hr>
<h2 id='relabel'>Get or modify pedigree labels</h2><span id='topic+relabel'></span><span id='topic+labels.ped'></span><span id='topic+labels.list'></span>

<h3>Description</h3>

<p>Functions for getting or changing the ID labels of pedigree members.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relabel(
  x,
  new = "asPlot",
  old = labels(x),
  reorder = FALSE,
  returnLabs = FALSE,
  .alignment = NULL
)

## S3 method for class 'ped'
labels(object, ...)

## S3 method for class 'list'
labels(object, ..., unlist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relabel_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="relabel_+3A_new">new</code></td>
<td>
<p>The following values are valid (see Details and Examples):
</p>

<ul>
<li><p> a character vector containing new labels. If named, interpreted as
<code>old = new</code>
</p>
</li>
<li><p> a function, which should take the old labels as input and output a
character of the same length
</p>
</li>
<li><p> one of the special keywords &quot;asPlot&quot; (default) or &quot;generations&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="relabel_+3A_old">old</code></td>
<td>
<p>A vector of ID labels, of the same length as <code>new</code>. (Ignored if
<code>new</code> is one of the special words.) If not given, taken from the names of
<code>new</code> if these exist.</p>
</td></tr>
<tr><td><code id="relabel_+3A_reorder">reorder</code></td>
<td>
<p>A logical. If TRUE, <code><a href="#topic+reorderPed">reorderPed()</a></code> is called on <code>x</code> after
relabelling. Default: FALSE.</p>
</td></tr>
<tr><td><code id="relabel_+3A_returnlabs">returnLabs</code></td>
<td>
<p>A logical. If TRUE, the new labels are returned as a named
character vector.</p>
</td></tr>
<tr><td><code id="relabel_+3A_.alignment">.alignment</code></td>
<td>
<p>A list of alignment details for <code>x</code>, used if <code>new</code> equals
&quot;asPlot&quot; or &quot;generations&quot;. If not supplied, this is computed internally
with <code><a href="#topic+.pedAlignment">.pedAlignment()</a></code>.</p>
</td></tr>
<tr><td><code id="relabel_+3A_object">object</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="relabel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="relabel_+3A_unlist">unlist</code></td>
<td>
<p>A logical; if TRUE (default), the output is unlisted to a
single character vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>relabel(x)</code> relabels everyone as 1, 2, ..., in the order given
by the plot (top to bottom; left to right).
</p>
<p>Alternatively, <code>relabel(x, "generations")</code> labels the members in the top
generation I-1, I-2, ..., in the second generation II-1, II-2, ..., etc.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>labels()</code> returns a character vector containing the ID labels of all
pedigree members. If the input is a list of ped objects, the output is a list
of character vectors.
</p>
</li>
<li> <p><code>relabel()</code> by default returns a <code>ped</code> object similar to <code>x</code>, but with
modified labels. If <code>returnLabs</code> is TRUE, the new labels are returned as a
named character vector
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ped">ped()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed()
x
labels(x)

y = relabel(x, new = "girl", old = 3)
y

# Back to the numeric labels
z = relabel(y)
stopifnot(identical(x,z))

# Generation labels
relabel(x, "generations")

</code></pre>

<hr>
<h2 id='setMutmod'>Set a mutation model</h2><span id='topic+setMutmod'></span>

<h3>Description</h3>

<p>This function offers a convenient way to set or modify mutation models to
markers attached to a pedigree. It wraps <code><a href="pedmut.html#topic+mutationModel">pedmut::mutationModel()</a></code>, which
does the main work of creating the models, but relieves the user from having
to loop through the markers in order to supply the correct alleles and
frequencies for each marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMutmod(x, markers = NULL, ..., update = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMutmod_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="setMutmod_+3A_markers">markers</code></td>
<td>
<p>A vector of names or indices referring to markers attached to
<code>x</code>. (Default: All markers.)</p>
</td></tr>
<tr><td><code id="setMutmod_+3A_...">...</code></td>
<td>
<p>Arguments forwarded to <code><a href="pedmut.html#topic+mutationModel">pedmut::mutationModel()</a></code>, e.g., <code>model</code>,
<code>rate</code>, etc.</p>
</td></tr>
<tr><td><code id="setMutmod_+3A_update">update</code></td>
<td>
<p>A logical. If TRUE, existing mutation models (if present) are
updated with the parameters specified in <code>...</code>. If FALSE (default), any
previous models are ignored, and new mutation models are created from the
parameters in <code>...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the following models are supported:
</p>

<ul>
<li> <p><code>equal</code>:  All mutations equally likely; probability <code>1 - rate</code> of no
mutation
</p>
</li>
<li> <p><code>proportional</code>: Mutation probabilities are proportional to the target
allele frequencies
</p>
</li>
<li> <p><code>onestep</code>: A simple model for microsatellite markers, in which mutations
are only allowed to the nearest neighbours in the allelic ladder. For
example, '10' may mutate to either '9' or '11' (unless '10' is the lowest
allele, in which case '11' is the only option). Not applicable to loci with
non-integral microvariants.
</p>
</li>
<li> <p><code>stepwise</code>: A common model for microsatellite markers. Mutation rates
depend on the step size in the allelic ladder, and also the allelic classes:
integral repeats like '16', versus non-integer microvariants like '16.3'.
</p>
</li>
<li> <p><code>custom</code>: Allows any mutation matrix to be provided by the user, in the
<code>matrix</code> parameter
</p>
</li>
<li> <p><code>random</code>: This produces a matrix of random numbers, where each row is
normalised so that it sums to 1
</p>
</li>
<li> <p><code>trivial</code>: The identity matrix; no mutations are possible
</p>
</li></ul>



<h3>Value</h3>

<p>An object similar to <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example requires the pedmut package ###

if (requireNamespace("pedmut", quietly = TRUE)){

# A pedigree with 1 empty marker; attach 'equal' mutation model
x = nuclearPed(1) |&gt;
  addMarker() |&gt;
  setMutmod(model = "equal", rate = 0.01)

mutmod(x, 1)

# Update rate (but still "equal" model)
y = setMutmod(x, rate = 0.05, update = TRUE)
mutmod(y, 1)

# Change to stepwise model
z = setMutmod(x, model = "stepwise",
              rate = list(female = 0.01, male = 0.02),
              range = 0.1, rate2 = 1e-6)
mutmod(z, 1)

# Remove mutation model
w = setMutmod(x, model = NULL)
mutmod(w, 1)

}

</code></pre>

<hr>
<h2 id='setSNPs'>Attach SNP loci to a pedigree</h2><span id='topic+setSNPs'></span>

<h3>Description</h3>

<p>Create and attach a list of empty SNP markers with specified position and
allele frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSNPs(x, snpData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSNPs_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="setSNPs_+3A_snpdata">snpData</code></td>
<td>
<p>A data frame with 6 columns. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame <code>snpData</code> should contain the following columns, in order:
</p>

<ul>
<li> <p><code>CHROM</code>: Chromosome (character)
</p>
</li>
<li> <p><code>MARKER</code>: Marker name (character)
</p>
</li>
<li> <p><code>MB</code>: Physical position in megabases (numeric)
</p>
</li>
<li> <p><code>A1</code>: First allele (single-letter character)
</p>
</li>
<li> <p><code>A2</code>: Second allele (single-letter character)
</p>
</li>
<li> <p><code>FREQ1</code>: Allele frequency of <code>A1</code> (number in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>)
</p>
</li></ul>

<p>The actual column names do not matter.
</p>
<p>Each column must be of the stated type, or coercible to it. (For example,
<code>CHROM</code>, <code>A1</code> and <code>A2</code> may be given as numbers, but will be internally
converted to characters.)
</p>


<h3>Value</h3>

<p>A copy of <code>x</code> with the indicated SNP markers attached.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
snps = data.frame(
  CHROM  = 1:2,
  MARKER = c("M1", "M2"),
  MB     = c(1.23, 2.34),
  A1     = c("A", "G"),
  A2     = c("C", "C"),
  FREQ1  = c(0.7, 0.12))

x = setSNPs(nuclearPed(), snpData = snps)

# Inspect the results:
getMap(x)
getFreqDatabase(x)

</code></pre>

<hr>
<h2 id='sortGenotypes'>Sort the alleles in each genotype</h2><span id='topic+sortGenotypes'></span>

<h3>Description</h3>

<p>Ensure that all genotypes are sorted internally. For example, if a marker
attached to <code>x</code> has alleles 1 and 2, then running this function will replace
all genotypes &quot;2/1&quot; by &quot;1/2&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortGenotypes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortGenotypes_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object identical to <code>x</code> except that the all genotypes are sorted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = singleton(1)

# Various markers with misordered genotypes
m1 = marker(x, `1` = "2/1")
m2 = marker(x, `1` = "b/a")
m3 = marker(x, `1` = "100.3/99.1")
x = setMarkers(x, list(m1, m2, m3))
x

# Sort all genotypes
y = sortGenotypes(x)
y

# Also works when input is a list of peds
sortGenotypes(list(x, x))

</code></pre>

<hr>
<h2 id='transferMarkers'>Transfer marker data</h2><span id='topic+transferMarkers'></span>

<h3>Description</h3>

<p>Transfer marker data between pedigrees. Any markers attached to the target
are overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transferMarkers(
  from,
  to,
  ids = NULL,
  idsFrom = ids,
  idsTo = ids,
  erase = TRUE,
  matchNames = TRUE,
  checkSex = FALSE,
  checkAttrs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transferMarkers_+3A_from">from</code></td>
<td>
<p>A <code>ped</code> or <code>singleton</code> object, or a list of such objects.</p>
</td></tr>
<tr><td><code id="transferMarkers_+3A_to">to</code></td>
<td>
<p>A <code>ped</code> or <code>singleton</code> object, or a list of such objects.</p>
</td></tr>
<tr><td><code id="transferMarkers_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels. This should be used only if the individuals
have the same name in both pedigrees; otherwise use <code>idsFrom</code> and <code>idsTo</code>
instead.</p>
</td></tr>
<tr><td><code id="transferMarkers_+3A_idsfrom">idsFrom</code>, <code id="transferMarkers_+3A_idsto">idsTo</code></td>
<td>
<p>Vectors of equal length, denoting source individuals (in
the <code>from</code> pedigree) and target individuals (in the <code>to</code> pedigree),
respectively.</p>
</td></tr>
<tr><td><code id="transferMarkers_+3A_erase">erase</code></td>
<td>
<p>A logical. If <code>TRUE</code> (default), all markers attached to <code>to</code> are
erased prior to transfer, and new marker objects are created with the same
attributes as in <code>from</code>. If <code>FALSE</code> no new marker objects are attached to
<code>to</code>. Only the genotypes of the <code>ids</code> individuals are modified, while
genotypes for other pedigree members - and marker attributes - remain
untouched.</p>
</td></tr>
<tr><td><code id="transferMarkers_+3A_matchnames">matchNames</code></td>
<td>
<p>A logical, only relevant if <code>erase = FALSE</code>. If <code>matchNames = TRUE</code> (default) marker names are used to ensure genotypes are transferred
into the right markers, The output contains only markers present in <code>from</code>,
in the same order. (An error is raised if the markers are not named.)</p>
</td></tr>
<tr><td><code id="transferMarkers_+3A_checksex">checkSex</code></td>
<td>
<p>A logical. If TRUE, it is checked that <code>fromIds</code> and <code>toIds</code>
have the same sex. Default: FALSE.</p>
</td></tr>
<tr><td><code id="transferMarkers_+3A_checkattrs">checkAttrs</code></td>
<td>
<p>A logical. If TRUE, and <code>from</code> is a list of pedigrees, an
error is raised if marker attributes differ between components. Default:
TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, genotypes are transferred between all individuals present in both
pedigrees.
</p>


<h3>Value</h3>

<p>A <code>ped</code> object (or a list of such) similar to <code>to</code>, but where all
individuals also present in <code>from</code> have marker genotypes copied over.  Any
previous marker data is erased.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(fa = "A", mo = "B", child = "C")
x = addMarker(x, A = "1/2", B = "1/1", C = "1/2", name = "M1")

y = list(singleton("A"), nuclearPed(fa = "D", mo = "B", child = "C"))

# By default all common individuals are transferred
transferMarkers(x, y)

# Transfer data for the boy only
transferMarkers(x, y, ids = "C")

# Transfer without first erasing the target markers
z = nuclearPed(fa = "A", mo = "B", child = "C")
z = addMarker(z, A = "1/1", alleles = 1:2, name = "M1")

transferMarkers(x, z, ids = "C", erase = FALSE)
transferMarkers(x, z, ids = "C", erase = TRUE) # note the difference

</code></pre>

<hr>
<h2 id='validatePed'>Pedigree errors</h2><span id='topic+validatePed'></span>

<h3>Description</h3>

<p>Validate the internal pedigree structure. The input may be either a (possibly
malformed) <code><a href="#topic+ped">ped()</a></code> object, or its defining vectors <code>id</code>, <code>fid</code>, <code>mid</code>, <code>sex</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validatePed(x = NULL, id = NULL, fid = NULL, mid = NULL, sex = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validatePed_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="validatePed_+3A_id">id</code></td>
<td>
<p>A vector (coercible to character) of individual ID labels.</p>
</td></tr>
<tr><td><code id="validatePed_+3A_fid">fid</code>, <code id="validatePed_+3A_mid">mid</code></td>
<td>
<p>Vectors of the same length as <code>id</code>, naming the father and
mother of each individual, respectively. Missing parents (i.e.,
corresponding to founder individuals) may be entered as &quot;0&quot;, &quot;&quot; or NA.</p>
</td></tr>
<tr><td><code id="validatePed_+3A_sex">sex</code></td>
<td>
<p>A numeric of the same length as <code>id</code>, describing the genders of
the individuals (in the same order as <code>id</code>.) Each entry must be either 1
(=male), 2 (=female) or 0 (=unknown).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no errors are detected, the function returns NULL invisibly.
Otherwise, messages describing the errors are printed to the screen and an
error is raised.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed()
validatePed(x)

# Various errors
# validatePed(id = c(1,2), fid = c(2,0), mid = c(0,1), sex = c(1,2))

</code></pre>

<hr>
<h2 id='writePed'>Write a pedigree to file</h2><span id='topic+writePed'></span>

<h3>Description</h3>

<p>Write a pedigree to file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writePed(
  x,
  prefix,
  what = "ped",
  famid = is.pedList(x),
  header = TRUE,
  merlin = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writePed_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object</p>
</td></tr>
<tr><td><code id="writePed_+3A_prefix">prefix</code></td>
<td>
<p>A character string giving the prefix of the files. For
instance, if <code>prefix = "myped"</code> and <code>what = c("ped", "map")</code>, the output
files are &quot;myped.ped&quot; and &quot;myped.map&quot; in the current directory. Paths to
other folder may be included, e.g. <code>prefix = "path-to-my-dir/myped"</code>.</p>
</td></tr>
<tr><td><code id="writePed_+3A_what">what</code></td>
<td>
<p>A subset of the character vector <code>c("ped", "map", "dat", "freq")</code>, indicating which files should be created. By default only the
&quot;ped&quot; file is created. This option is ignored if <code>merlin = TRUE</code>.</p>
</td></tr>
<tr><td><code id="writePed_+3A_famid">famid</code></td>
<td>
<p>A logical indicating if family ID should be included as the
first column in the ped file. The family ID is taken from <code>famid(x)</code>. If
<code>x</code> is a list of pedigrees, the family IDs are taken from <code>names(x)</code>, or if
this is NULL, the component-wise <code>famid()</code> values. Missing values are
replaced by natural numbers. This option is ignored if <code>merlin = TRUE</code>.</p>
</td></tr>
<tr><td><code id="writePed_+3A_header">header</code></td>
<td>
<p>A logical indicating if column names should be included in the
ped file. This option is ignored if <code>merlin = TRUE</code>.</p>
</td></tr>
<tr><td><code id="writePed_+3A_merlin">merlin</code></td>
<td>
<p>A logical. If TRUE, &quot;ped&quot;, &quot;map&quot;, &quot;dat&quot; and &quot;freq&quot; files are
written in a format readable by the MERLIN software. In particular MERLIN
requires non-numerical allele labels in the frequency file.</p>
</td></tr>
<tr><td><code id="writePed_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the file names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(1)
x = addMarker(x, "3" = "a/b", name = "m1")

# Write to file
fn = writePed(x, prefix = tempfile("test"))

# Read
y = readPed(fn)

stopifnot(identical(x, y))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
