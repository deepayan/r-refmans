<!DOCTYPE html><html><head><title>Help for package Cascade</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Cascade}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze_network,network-method'><p>Analysing the network</p></a></li>
<li><a href='#as.micro_array'><p>Coerce a matrix into a micro_array object.</p></a></li>
<li><a href='#Cascade-package'><p>The Cascade Package: Selection, Reverse-Engineering and Prediction in Cascade Networks</p></a></li>
<li><a href='#compare-methods'><p>Some basic criteria of comparison between actual and inferred network.</p></a></li>
<li><a href='#cutoff,network-method'><p>Choose the best cutoff</p></a></li>
<li><a href='#dim'><p>Dimension of the data</p></a></li>
<li><a href='#evolution,network-method'><p>See the evolution of the network with change of cutoff</p></a></li>
<li><a href='#gene_expr_simulation,network-method'><p>Simulates microarray data based on a given network.</p></a></li>
<li><a href='#geneNeighborhood,network-method'><p>Find the neighborhood of a set of nodes.</p></a></li>
<li><a href='#geneSelection'><p>Methods for selecting genes</p></a></li>
<li><a href='#head,micro_array-method'><p>Overview of a micro_array object</p></a></li>
<li><a href='#inference,micro_array-method'><p>Reverse-engineer the network</p></a></li>
<li><a href='#M'><p>Simulated M data for examples.</p></a></li>
<li><a href='#micro_array-class'><p>Class <code>"micro_array"</code></p></a></li>
<li><a href='#micropredict-class'><p>Class <code>"micropredict"</code></p></a></li>
<li><a href='#Net'><p>Simulated network data for examples.</p></a></li>
<li><a href='#Net_inf'><p>Reverse-engineered network of the simulated data.</p></a></li>
<li><a href='#network'><p>A network object data.</p></a></li>
<li><a href='#network_random'><p>Generates a network.</p></a></li>
<li><a href='#network-class'><p>Class <code>"network"</code></p></a></li>
<li><a href='#plot-methods'><p>Plot</p></a></li>
<li><a href='#position-methods'><p>Returns the position of edges in the network</p></a></li>
<li><a href='#predict,micro_array-method'><p>Prediction of the gene expressions after a knock-out experience</p>
<code>predict</code></a></li>
<li><a href='#print-methods'><p>Methods for Function <code>print</code></p></a></li>
<li><a href='#Selection'><p>Selection of genes.</p></a></li>
<li><a href='#summary-methods'><p>Methods for Function <code>summary</code></p></a></li>
<li><a href='#unionMicro-methods'><p>Makes the union between two micro_array objects.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Selection, Reverse-Engineering and Prediction in Cascade
Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-28</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, animation, cluster, grid, igraph, lars, lattice, limma,
magic, methods, nnls, splines, stats4, survival, tnet, VGAM</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, CascadeData, knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederic Bertrand <a href="https://orcid.org/0000-0002-0837-8281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Myriam Maumy-Bertrand
    <a href="https://orcid.org/0000-0002-4615-1512"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Laurent Vallat [ctb],
  Nicolas Jung [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederic Bertrand &lt;frederic.bertrand@utt.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A modeling tool allowing gene selection, reverse engineering, and prediction in cascade networks. Jung, N., Bertrand, F., Bahram, S., Vallat, L., and Maumy-Bertrand, M. (2014) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtt705">doi:10.1093/bioinformatics/btt705</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>Cascade-package.R global.R micro_array.R network.R
micro_array-network.R micropredict.R datasets.R</td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62J05, 62J07, 62J99, 92C42</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fbertran.github.io/Cascade/">https://fbertran.github.io/Cascade/</a>,
<a href="https://github.com/fbertran/Cascade/">https://github.com/fbertran/Cascade/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fbertran/Cascade/issues/">https://github.com/fbertran/Cascade/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-28 09:54:41 UTC; fbertran</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-28 12:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze_network+2Cnetwork-method'>Analysing the network</h2><span id='topic+analyze_network+2Cnetwork-method'></span><span id='topic+analyze_network'></span><span id='topic+analyze_network-methods'></span>

<h3>Description</h3>

<p>Calculates some indicators for each node in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'network'
analyze_network(Omega, nv, label_v = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_network+2B2Cnetwork-method_+3A_omega">Omega</code></td>
<td>
<p>a network object</p>
</td></tr>
<tr><td><code id="analyze_network+2B2Cnetwork-method_+3A_nv">nv</code></td>
<td>
<p>the level of cutoff at which the analysis should be done</p>
</td></tr>
<tr><td><code id="analyze_network+2B2Cnetwork-method_+3A_label_v">label_v</code></td>
<td>
<p>(optionnal) the name of the genes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing, for each node, its betweenness,its degree, its
output, its closeness.
</p>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	data(network)
	analyze_network(network,nv=0)

</code></pre>

<hr>
<h2 id='as.micro_array'>Coerce a matrix into a micro_array object.</h2><span id='topic+as.micro_array'></span>

<h3>Description</h3>

<p>Coerce a matrix into a micro_array object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.micro_array(M, time, subject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.micro_array_+3A_m">M</code></td>
<td>
<p>A matrix. Contains the microarray measurements. Should of size N *
K, with N the number of genes and K=T*P with T the number of time points,
and P the number of individuals. This matrix should be created using
cbind(M1,M2,...) with M1 a N*T matrix with the measurements for individual
1, M2 a N*T matrix with the measurements for individual 2.</p>
</td></tr>
<tr><td><code id="as.micro_array_+3A_time">time</code></td>
<td>
<p>A vector. The time points measurements.</p>
</td></tr>
<tr><td><code id="as.micro_array_+3A_subject">subject</code></td>
<td>
<p>The number of subjects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A micro_array object.
</p>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if(require(CascadeData)){
	data(micro_US)
	micro_US&lt;-as.micro_array(micro_US,time=c(60,90,210,390),subject=6)
	}

</code></pre>

<hr>
<h2 id='Cascade-package'>The Cascade Package: Selection, Reverse-Engineering and Prediction in Cascade Networks</h2><span id='topic+Cascade-package'></span><span id='topic+Cascade'></span>

<h3>Description</h3>

<p>A modeling tool allowing gene selection, reverse engineering, and prediction in cascade networks. Jung, N., Bertrand, F., Bahram, S., Vallat, L., and Maumy-Bertrand, M. (2014) &lt;doi:10.1093/bioinformatics/btt705&gt;.
</p>


<h3>Author(s)</h3>

<p>This package has been written by Frédéric Bertrand, Myriam
Maumy-Bertrand and Nicolas Jung with biological insights from Laurent
Vallat. Maintainer: Frédéric Bertrand &lt;frederic.bertrand@math.unistra.fr&gt;
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>

<hr>
<h2 id='compare-methods'>Some basic criteria of comparison between actual and inferred network.</h2><span id='topic+compare-methods'></span><span id='topic+compare'></span><span id='topic+compare+2Cnetwork+2Cnetwork+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Allows comparison between actual and inferred network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'network,network,numeric'
compare(Net, Net_inf, nv = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare-methods_+3A_net">Net</code></td>
<td>
<p>A network object containing the
actual network.</p>
</td></tr>
<tr><td><code id="compare-methods_+3A_net_inf">Net_inf</code></td>
<td>
<p>A network object containing the inferred
network.</p>
</td></tr>
<tr><td><code id="compare-methods_+3A_nv">nv</code></td>
<td>
<p>A number that indicates at which level of cutoff the
comparison should be done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing : sensibility, predictive positive value, and
the F-score
</p>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(Net = \&quot;network\&quot;, Net_inf = \&quot;network\&quot;, nv =
\&quot;numeric\&quot;)&quot;)</dt><dd></dd>
</dl>



<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Net)
data(Net_inf)

#Comparing true and inferred networks
F_score=NULL

#Here are the cutoff level tested
test.seq&lt;-seq(0,max(abs(Net_inf@network*0.9)),length.out=200)
for(u in test.seq){
	F_score&lt;-rbind(F_score,Cascade::compare(Net,Net_inf,u))
}
matplot(test.seq,F_score,type="l",ylab="criterion value",xlab="cutoff level",lwd=2)

</code></pre>

<hr>
<h2 id='cutoff+2Cnetwork-method'>Choose the best cutoff</h2><span id='topic+cutoff+2Cnetwork-method'></span><span id='topic+cutoff'></span><span id='topic+cutoff-methods'></span>

<h3>Description</h3>

<p>Allows estimating the best cutoff, in function of the scale-freeness of the
network.  For a sequence of cutoff, the corresponding p-value is then
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'network'
cutoff(Omega, sequence = NULL, x_min = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff+2B2Cnetwork-method_+3A_omega">Omega</code></td>
<td>
<p>a network object</p>
</td></tr>
<tr><td><code id="cutoff+2B2Cnetwork-method_+3A_sequence">sequence</code></td>
<td>
<p>(optional) a vector corresponding to the sequence of cutoffs 
that will be tested.</p>
</td></tr>
<tr><td><code id="cutoff+2B2Cnetwork-method_+3A_x_min">x_min</code></td>
<td>
<p>(optional) an integer ; only values over x_min are further 
retained for performing the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two objects : </p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>the p values
corresponding to the sequence of cutoff</p>
</td></tr> <tr><td><code>p.value.inter</code></td>
<td>
<p>the smoothed p
value vector, using the loess function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

	data(network)
	cutoff(network)
	#See vignette for more details


</code></pre>

<hr>
<h2 id='dim'>Dimension of the data</h2><span id='topic+dim'></span><span id='topic+dim-methods'></span><span id='topic+dim+2Cmicro_array-method'></span>

<h3>Description</h3>

<p>Dimension of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'micro_array'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_+3A_x">x</code></td>
<td>
<p>an object of class &quot;micro-array</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;micro_array\&quot;)&quot;)</dt><dd><p> Gives the dimension of the
matrix of measurements. </p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
 if(require(CascadeData)){
	data(micro_US)
	micro_US&lt;-as.micro_array(micro_US,time=c(60,90,210,390),subject=6)
	dim(micro_US)
	}

</code></pre>

<hr>
<h2 id='evolution+2Cnetwork-method'>See the evolution of the network with change of cutoff</h2><span id='topic+evolution+2Cnetwork-method'></span><span id='topic+evolution'></span><span id='topic+evolution-methods'></span>

<h3>Description</h3>

<p>See the evolution of the network with change of cutoff.  This function may
be usefull to see if the global topology is changed while increasing the
cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'network'
evolution(
  net,
  list_nv,
  gr = NULL,
  color.vertex = NULL,
  fix = TRUE,
  gif = TRUE,
  taille = c(2000, 1000),
  label_v = 1:dim(net@network)[1],
  legend.position = "topleft",
  frame.color = "black",
  label.hub = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_net">net</code></td>
<td>
<p>a network object</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_list_nv">list_nv</code></td>
<td>
<p>a vector of cutoff at which the network should be shown</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_gr">gr</code></td>
<td>
<p>a vector giving the group of each gene</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_color.vertex">color.vertex</code></td>
<td>
<p>a vector giving the color of each node</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_fix">fix</code></td>
<td>
<p>logical, should the position of the node in the network be calculated once at the beginning ? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_gif">gif</code></td>
<td>
<p>logical, TRUE</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_taille">taille</code></td>
<td>
<p>vector giving the size of the plot. Default to c(2000,1000)</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_label_v">label_v</code></td>
<td>
<p>(optional) the name of the genes</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_legend.position">legend.position</code></td>
<td>
<p>(optional) the position of the legend, defaults to &quot;topleft&quot;</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_frame.color">frame.color</code></td>
<td>
<p>(optional) the color of the frame, defaults to &quot;black&quot;</p>
</td></tr>
<tr><td><code id="evolution+2B2Cnetwork-method_+3A_label.hub">label.hub</code></td>
<td>
<p>(optional) boolean, defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A HTML page with the evolution of the network.
</p>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

	data(network)
	sequence&lt;-seq(0,0.2,length.out=20)
	#setwd("inst/animation")
	#evolution(network,sequence)


</code></pre>

<hr>
<h2 id='gene_expr_simulation+2Cnetwork-method'>Simulates microarray data based on a given network.</h2><span id='topic+gene_expr_simulation+2Cnetwork-method'></span><span id='topic+gene_expr_simulation'></span><span id='topic+gene_expr_simulation-methods'></span>

<h3>Description</h3>

<p>Simulates microarray data based on a given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'network'
gene_expr_simulation(network, time_label = 1:4, subject = 5, level_peak = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene_expr_simulation+2B2Cnetwork-method_+3A_network">network</code></td>
<td>
<p>A network object.</p>
</td></tr>
<tr><td><code id="gene_expr_simulation+2B2Cnetwork-method_+3A_time_label">time_label</code></td>
<td>
<p>a vector containing the time labels.</p>
</td></tr>
<tr><td><code id="gene_expr_simulation+2B2Cnetwork-method_+3A_subject">subject</code></td>
<td>
<p>the number of subjects</p>
</td></tr>
<tr><td><code id="gene_expr_simulation+2B2Cnetwork-method_+3A_level_peak">level_peak</code></td>
<td>
<p>the mean level of peaks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A micro_array object.
</p>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Net)
set.seed(1)

#We simulate gene expression according to the network Net
Msim&lt;-gene_expr_simulation(
	network=Net,
	time_label=rep(1:4,each=25),
	subject=5,
	level_peak=200)
head(Msim)

</code></pre>

<hr>
<h2 id='geneNeighborhood+2Cnetwork-method'>Find the neighborhood of a set of nodes.</h2><span id='topic+geneNeighborhood+2Cnetwork-method'></span><span id='topic+geneNeighborhood'></span><span id='topic+geneNeighborhood-methods'></span>

<h3>Description</h3>

<p>Find the neighborhood of a set of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'network'
geneNeighborhood(
  net,
  targets,
  nv = 0,
  order = length(net@time_pt) - 1,
  label_v = NULL,
  ini = NULL,
  frame.color = "white",
  label.hub = FALSE,
  graph = TRUE,
  names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_net">net</code></td>
<td>
<p>a network object</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_targets">targets</code></td>
<td>
<p>a vector containing the set of nodes</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_nv">nv</code></td>
<td>
<p>the level of cutoff. Defaut to 0.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_order">order</code></td>
<td>
<p>of the neighborhood. Defaut to 'length(net@time_pt)-1'.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_label_v">label_v</code></td>
<td>
<p>vector defining the vertex labels.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_ini">ini</code></td>
<td>
<p>using the &ldquo;position&rdquo; function, you can
fix the position of the nodes.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_frame.color">frame.color</code></td>
<td>
<p>color of the frames.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_label.hub">label.hub</code></td>
<td>
<p>logical ; if TRUE only the hubs are labeled.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_graph">graph</code></td>
<td>
<p>plot graph of the network. Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Cnetwork-method_+3A_names">names</code></td>
<td>
<p>return names of the neighbors. Defaults to 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The neighborhood of the targeted genes.
</p>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Selection)
data(network)
#A nv value can chosen using the cutoff function
nv=.11 
EGR1&lt;-which(match(Selection@name,"EGR1")==1)
P&lt;-position(network,nv=nv)

geneNeighborhood(network,targets=EGR1,nv=nv,ini=P,
label_v=network@name)

</code></pre>

<hr>
<h2 id='geneSelection'>Methods for selecting genes</h2><span id='topic+geneSelection'></span><span id='topic+genePeakSelection'></span><span id='topic+genePeakSelection-methods'></span><span id='topic+geneSelection-methods'></span><span id='topic+geneSelection+2Clist+2Clist+2Cnumeric-method'></span><span id='topic+geneSelection+2Cmicro_array+2Cmicro_array+2Cnumeric-method'></span><span id='topic+genePeakSelection+2Cmicro_array+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Selection of differentially expressed genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'micro_array,micro_array,numeric'
geneSelection(
  x,
  y,
  tot.number,
  data_log = TRUE,
  wanted.patterns = NULL,
  forbidden.patterns = NULL,
  peak = NULL,
  alpha = 0.05,
  Design = NULL,
  lfc = 0
)

## S4 method for signature 'list,list,numeric'
geneSelection(
  x,
  y,
  tot.number,
  data_log = TRUE,
  alpha = 0.05,
  cont = FALSE,
  lfc = 0,
  f.asso = NULL
)

## S4 method for signature 'micro_array,numeric'
genePeakSelection(
  x,
  peak,
  y = NULL,
  data_log = TRUE,
  durPeak = c(1, 1),
  abs_val = TRUE,
  alpha_diff = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneSelection_+3A_x">x</code></td>
<td>
<p>either a micro_array object or a list of micro_array objects. In
the first case, the micro_array object represents the stimulated
measurements. In the second case, the control unstimulated data (if present)
should be the first element of the list.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_y">y</code></td>
<td>
<p>either a micro_array object or a list of strings. In the first
case, the micro_array object represents the stimulated measurements. In the
second case, the list is the way to specify the contrast: </p>

<dl>
<dt>First element:</dt><dd><p> condition, condition&amp;time or pattern. The condition
specification is used when the overall is to compare two conditions.  The
condition&amp;time specification is used when comparing two conditions at two
precise time points. The pattern specification allows to decide which time
point should be differentially expressed.</p>
</dd> <dt>Second element:</dt><dd><p>a vector
of length 2. The two conditions which should be compared. If a condition is
used as control, it should be the first element of the vector. However, if
this control is not measured throught time, the option cont=TRUE should be
used.</p>
</dd> <dt>Third element:</dt><dd><p>depends on the first element.  It is no needed
if condition has been specified.  If condition&amp;time has been specified, then
this is a vector containing the time point at which the comparison should be
done. If pattern has been specified, then this is a vector of 0 and 1 of
length T, where T is the number of time points. The time points with desired
differential expression are provided with 1.  </p>
</dd></dl>
</td></tr>
<tr><td><code id="geneSelection_+3A_tot.number">tot.number</code></td>
<td>
<p>an integer. The number of selected genes. If tot.number &lt;0
all differentially genes are selected. If tot.number &gt; 1, tot.number is the
maximum of diffenrtially genes that will be selected.  If 0&lt;tot.number&lt;1,
tot.number represents the proportion of diffenrentially genes that are
selected.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_data_log">data_log</code></td>
<td>
<p>logical (default to TRUE); should data be logged ?</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_wanted.patterns">wanted.patterns</code></td>
<td>
<p>a matrix with wanted patterns [only for geneSelection].</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_forbidden.patterns">forbidden.patterns</code></td>
<td>
<p>a matrix with forbidden patterns [only for geneSelection].</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_peak">peak</code></td>
<td>
<p>interger. At which time points measurements should the genes be
selected [optionnal for geneSelection].</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_alpha">alpha</code></td>
<td>
<p>float; the risk level. Default to 'alpha=0.05'</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_design">Design</code></td>
<td>
<p>the design matrix of the experiment. Defaults to 'NULL'.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_lfc">lfc</code></td>
<td>
<p>log fold change value used in limma's 'topTable'. Defaults to 0.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_cont">cont</code></td>
<td>
<p>use contrasts. Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_f.asso">f.asso</code></td>
<td>
<p>function used to assess the association between the genes. 
The default value 'NULL' implies the use of the usual 'mean' function.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_durpeak">durPeak</code></td>
<td>
<p>vector of size 2 (default to c(1,1)) ; the first elements gives the length of the peak at
the left, the second at the right. [only for genePeakSelection]</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_abs_val">abs_val</code></td>
<td>
<p>logical (default to TRUE) ; should genes be selected on the
basis of their absolute value expression ? [only for genePeakSelection]</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_alpha_diff">alpha_diff</code></td>
<td>
<p>float; the risk level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A micro_array object.
</p>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 if(require(CascadeData)){
	data(micro_US)
	micro_US&lt;-as.micro_array(micro_US,time=c(60,90,210,390),subject=6)
	data(micro_S)
	micro_S&lt;-as.micro_array(micro_S,time=c(60,90,210,390),subject=6)

  #Basically, to find the 50 more significant expressed genes you will use:
  Selection_1&lt;-geneSelection(x=micro_S,y=micro_US,
  tot.number=50,data_log=TRUE)
  summary(Selection_1)
  
  #If we want to select genes that are differentially 
  #at time t60 or t90 :
  Selection_2&lt;-geneSelection(x=micro_S,y=micro_US,tot.number=30,
  wanted.patterns=
  rbind(c(0,1,0,0),c(1,0,0,0),c(1,1,0,0)))
  summary(Selection_2)

  #To select genes that have a differential maximum of expression at a specific time point.
  
  Selection_3&lt;-genePeakSelection(x=micro_S,y=micro_US,peak=1,
  abs_val=FALSE,alpha_diff=0.01)
  summary(Selection_3)
  }

 if(require(CascadeData)){
data(micro_US)
micro_US&lt;-as.micro_array(micro_US,time=c(60,90,210,390),subject=6)
data(micro_S)
micro_S&lt;-as.micro_array(micro_S,time=c(60,90,210,390),subject=6)
#Genes with differential expression at t1
Selection1&lt;-geneSelection(x=micro_S,y=micro_US,20,wanted.patterns= rbind(c(1,0,0,0)))
#Genes with differential expression at t2
Selection2&lt;-geneSelection(x=micro_S,y=micro_US,20,wanted.patterns= rbind(c(0,1,0,0)))
#Genes with differential expression at t3
Selection3&lt;-geneSelection(x=micro_S,y=micro_US,20,wanted.patterns= rbind(c(0,0,1,0)))
#Genes with differential expression at t4
Selection4&lt;-geneSelection(x=micro_S,y=micro_US,20,wanted.patterns= rbind(c(0,0,0,1)))
#Genes with global differential expression 
Selection5&lt;-geneSelection(x=micro_S,y=micro_US,20)

#We then merge these selections:
Selection&lt;-unionMicro(list(Selection1,Selection2,Selection3,Selection4,Selection5))
print(Selection)

#Prints the correlation graphics Figure 4:
summary(Selection,3)

##Uncomment this code to retrieve geneids.
#library(org.Hs.eg.db)
#
#ff&lt;-function(x){substr(x, 1, nchar(x)-3)}
#ff&lt;-Vectorize(ff)
#
##Here is the function to transform the probeset names to gene ID.
#
#library("hgu133plus2.db")
#
#probe_to_id&lt;-function(n){  
#x &lt;- hgu133plus2SYMBOL
#mp&lt;-mappedkeys(x)
#xx &lt;- unlist(as.list(x[mp]))
#genes_all = xx[(n)]
#genes_all[is.na(genes_all)]&lt;-"unknown"
#return(genes_all)
#}
#Selection@name&lt;-probe_to_id(Selection@name)
}


</code></pre>

<hr>
<h2 id='head+2Cmicro_array-method'>Overview of a micro_array object</h2><span id='topic+head+2Cmicro_array-method'></span><span id='topic+methods'></span><span id='topic+head-methods'></span><span id='topic+head+2CANY-method'></span>

<h3>Description</h3>

<p>Overview of a micro_array object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'micro_array'
head(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head+2B2Cmicro_array-method_+3A_x">x</code></td>
<td>
<p>an object of class 'micro_array'.</p>
</td></tr>
<tr><td><code id="head+2B2Cmicro_array-method_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;ANY\&quot;)&quot;)</dt><dd><p> Gives an overview. </p>
</dd>
<dt>list(&quot;signature(x = \&quot;micro_array\&quot;)&quot;)</dt><dd><p> Gives an overview. </p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
 if(require(CascadeData)){
	data(micro_US)
	micro_US&lt;-as.micro_array(micro_US,time=c(60,90,210,390),subject=6)
	head(micro_US)
	}
</code></pre>

<hr>
<h2 id='inference+2Cmicro_array-method'>Reverse-engineer the network</h2><span id='topic+inference+2Cmicro_array-method'></span><span id='topic+inference'></span><span id='topic+inference-methods'></span>

<h3>Description</h3>

<p>Reverse-engineer the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'micro_array'
inference(
  M,
  tour.max = 30,
  g = function(x) {
     1/x
 },
  conv = 0.001,
  cv.subjects = TRUE,
  nb.folds = NULL,
  eps = 10^-5,
  type.inf = "iterative"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inference+2B2Cmicro_array-method_+3A_m">M</code></td>
<td>
<p>a micro_array object.</p>
</td></tr>
<tr><td><code id="inference+2B2Cmicro_array-method_+3A_tour.max">tour.max</code></td>
<td>
<p>maximal number of steps. Defaults to 'tour.max=30'</p>
</td></tr>
<tr><td><code id="inference+2B2Cmicro_array-method_+3A_g">g</code></td>
<td>
<p>the new solution is choosen as
(the old solution + g(x) * the new solution)/(1+g(x)) where x is the number
of steps. Defaults to 'g=function(x) 1/x'</p>
</td></tr>
<tr><td><code id="inference+2B2Cmicro_array-method_+3A_conv">conv</code></td>
<td>
<p>convergence criterion. Defaults to 'conv=10e-3'</p>
</td></tr>
<tr><td><code id="inference+2B2Cmicro_array-method_+3A_cv.subjects">cv.subjects</code></td>
<td>
<p>should the cross validation be done removing the
subject one by one ? Defaults to 'cv.subjects=TRUE'.</p>
</td></tr>
<tr><td><code id="inference+2B2Cmicro_array-method_+3A_nb.folds">nb.folds</code></td>
<td>
<p>Relevant only if cv.subjects is
FALSE. The number of folds in cross validation. Defaults to 'NULL'.</p>
</td></tr>
<tr><td><code id="inference+2B2Cmicro_array-method_+3A_eps">eps</code></td>
<td>
<p>machine zero. Defaults to '10e-5'.</p>
</td></tr>
<tr><td><code id="inference+2B2Cmicro_array-method_+3A_type.inf">type.inf</code></td>
<td>
<p>&quot;iterative&quot; or &quot;noniterative&quot; : should the
algorithm be computed iteratively. Defaults to '&quot;iterative&quot;'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object.
</p>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#With simulated data
data(M)
infM &lt;- inference(M)
str(infM)

#With selection of genes from GSE39411
data(Selection)
infSel &lt;- inference(Selection)
str(infSel)


</code></pre>

<hr>
<h2 id='M'>Simulated M data for examples.</h2><span id='topic+M'></span>

<h3>Description</h3>

<p>Simulated M microarray.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(M)
head(M)

</code></pre>

<hr>
<h2 id='micro_array-class'>Class <code>"micro_array"</code></h2><span id='topic+micro_array-class'></span>

<h3>Description</h3>

<p>The <code>"micro_array"</code> class
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("micro_array", ...)</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("micro_array")

</code></pre>

<hr>
<h2 id='micropredict-class'>Class <code>"micropredict"</code></h2><span id='topic+micropredict-class'></span>

<h3>Description</h3>

<p>The <code>"micropredict"</code> class
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("micropredict", ...)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("micropredict")

</code></pre>

<hr>
<h2 id='Net'>Simulated network data for examples.</h2><span id='topic+Net'></span>

<h3>Description</h3>

<p>Simulated network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Net)
str(Net)

</code></pre>

<hr>
<h2 id='Net_inf'>Reverse-engineered network of the simulated data.</h2><span id='topic+Net_inf'></span>

<h3>Description</h3>

<p>The reverse-engineered network of the simulated data (M and Net).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Net_inf)
str(Net_inf)

</code></pre>

<hr>
<h2 id='network'>A network object data.</h2><span id='topic+network'></span>

<h3>Description</h3>

<p>A network object. It is the same as the result in the vignette for the
inference of the network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(network)
plot(network)
print(network)

</code></pre>

<hr>
<h2 id='network_random'>Generates a network.</h2><span id='topic+network_random'></span>

<h3>Description</h3>

<p>Generates a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_random(
  nb,
  time_label,
  exp,
  init,
  regul,
  min_expr,
  max_expr,
  casc.level
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_random_+3A_nb">nb</code></td>
<td>
<p>Integer. The number of genes.</p>
</td></tr>
<tr><td><code id="network_random_+3A_time_label">time_label</code></td>
<td>
<p>Vector. The time points measurements.</p>
</td></tr>
<tr><td><code id="network_random_+3A_exp">exp</code></td>
<td>
<p>The exponential parameter, as in the barabasi.game function in
igraph package.</p>
</td></tr>
<tr><td><code id="network_random_+3A_init">init</code></td>
<td>
<p>The attractiveness of the vertices with no adjacent edges. See
barabasi.game function.</p>
</td></tr>
<tr><td><code id="network_random_+3A_regul">regul</code></td>
<td>
<p>A vector mapping each gene with its number of regulators.</p>
</td></tr>
<tr><td><code id="network_random_+3A_min_expr">min_expr</code></td>
<td>
<p>Minimum of strength of a non-zero link</p>
</td></tr>
<tr><td><code id="network_random_+3A_max_expr">max_expr</code></td>
<td>
<p>Maximum of strength of a non-zero link</p>
</td></tr>
<tr><td><code id="network_random_+3A_casc.level">casc.level</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object.
</p>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
Net&lt;-network_random(
	nb=100,
	time_label=rep(1:4,each=25),
	exp=1,
	init=1,
	regul=round(rexp(100,1))+1,
	min_expr=0.1,
	max_expr=2,
	casc.level=0.4
	)
plot(Net)

</code></pre>

<hr>
<h2 id='network-class'>Class <code>"network"</code></h2><span id='topic+network-class'></span>

<h3>Description</h3>

<p>The <code>"network"</code> class
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("network", ...)</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("network")

</code></pre>

<hr>
<h2 id='plot-methods'>Plot</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CANY+2CANY-method'></span><span id='topic+plot+2Cmicro_array+2CANY-method'></span><span id='topic+plot+2Cnetwork+2CANY-method'></span><span id='topic+plot+2Cmicropredict+2CANY-method'></span>

<h3>Description</h3>

<p>Considering the class of the argument which is passed to plot, the graphical
output differs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'micro_array,ANY'
plot(x, y, ...)

## S4 method for signature 'network,ANY'
plot(
  x,
  y,
  choice = "network",
  nv = 0,
  gr = NULL,
  ini = NULL,
  color.vertex = NULL,
  video = TRUE,
  weight.node = NULL,
  ani = FALSE,
  taille = c(2000, 1000),
  label_v = 1:dim(x@network)[1],
  horiz = TRUE,
  legend.position = "topleft",
  frame.color = "black",
  label.hub = FALSE,
  ...
)

## S4 method for signature 'micropredict,ANY'
plot(
  x,
  time = NULL,
  label_v = NULL,
  frame.color = "white",
  ini = NULL,
  label.hub = FALSE,
  edge.arrow.size = 0.7,
  edge.thickness = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>a micro_array object, a network object or a micropredict object</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p>optional and not used if x is an appropriate structure</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_choice">choice</code></td>
<td>
<p>what graphic should be plotted: either &quot;F&quot;
(for a representation of the matrices F) or &quot;network&quot;.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_nv">nv</code></td>
<td>
<p>the level of cutoff. Defaut to '0'.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_gr">gr</code></td>
<td>
<p>a vector giving the group of each gene</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ini">ini</code></td>
<td>
<p>using the &ldquo;position&rdquo; function, you can
fix the position of the nodes.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_color.vertex">color.vertex</code></td>
<td>
<p>a vector defining the color of the vertex.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_video">video</code></td>
<td>
<p>if ani is TRUE and video is TRUE, the result of the animation is saved as an animated GIF.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_weight.node">weight.node</code></td>
<td>
<p>nodes weighting. Defaults to 'NULL'.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ani">ani</code></td>
<td>
<p>animated plot?</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_taille">taille</code></td>
<td>
<p>vector giving the size of the plot. Default to 'c(2000,1000)'.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_label_v">label_v</code></td>
<td>
<p>vector defining the vertex labels.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_horiz">horiz</code></td>
<td>
<p>landscape? Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_legend.position">legend.position</code></td>
<td>
<p>position of the legend.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_frame.color">frame.color</code></td>
<td>
<p>color of the frames.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_label.hub">label.hub</code></td>
<td>
<p>logical ; if TRUE only the hubs are labeled.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_time">time</code></td>
<td>
<p>sets the time for plot of the prediction. Defaults to 'NULL'</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>
<p>size of the arrows ; default to 0.7.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_edge.thickness">edge.thickness</code></td>
<td>
<p>edge thickness ; default to 1.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;micro_array\&quot;, y = \&quot;ANY\&quot;,...)&quot;)</dt><dd> 
<dl>
<dt>x</dt><dd><p>a micro_array object</p>
</dd> <dt>list_nv</dt><dd><p>a vector of cutoff at which
the network should be shown</p>
</dd> </dl>
 </dd> <dt>list(&quot;signature(x = \&quot;network\&quot;, y =
\&quot;ANY\&quot;,...)&quot;)</dt><dd>  <dl>
<dt>x</dt><dd><p>a network object</p>
</dd>
<dt>list()</dt><dd><p>Optionnal arguments: </p>
 <dl>
<dt>gr</dt><dd><p>a vector giving the
group of each gene</p>
</dd> <dt>choice</dt><dd><p>what graphic should be plotted: either &quot;F&quot;
(for a representation of the matrices F) or &quot;network&quot;.</p>
</dd> <dt>nv</dt><dd><p>the level
of cutoff. Defaut to 0.</p>
</dd> <dt>ini</dt><dd><p>using the &ldquo;position&rdquo; function, you can
fix the position of the nodes</p>
</dd> <dt>color.vertex</dt><dd><p>a vector defining the
color of the vertex</p>
</dd> <dt>ani</dt><dd><p>animated plot?</p>
</dd> <dt>size</dt><dd><p>vector giving the size of the plot. Default
to c(2000,1000)</p>
</dd> <dt>video</dt><dd><p>if ani is TRUE and video is TRUE, the
animation result is a GIF video</p>
</dd> <dt>label_v</dt><dd><p>vector defining the vertex
labels</p>
</dd> <dt>legend.position</dt><dd><p>position of the legend</p>
</dd>
<dt>frame.color</dt><dd><p>color of the frames</p>
</dd> <dt>label.hub</dt><dd><p>logical ; if TRUE
only the hubs are labeled</p>
</dd> <dt>edge.arrow.size</dt><dd><p>size of the arrows ;
default to 0.7</p>
</dd> <dt>edge.thickness</dt><dd><p>edge thickness ; default to 1.</p>
</dd> </dl>
 </dd></dl>
</dd>
<dt>list(&quot;signature(x = \&quot;micropredict\&quot;, y = \&quot;ANY\&quot;,...)&quot;)</dt><dd> 
<dl>
<dt>x</dt><dd><p>a micropredict object</p>
</dd> <dt>list()</dt><dd><p>Optionnal arguments: see plot
for network</p>
</dd> </dl>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(Net)
plot(Net)

data(M)
plot(M)

data(Selection)
data(network)
nv&lt;-0.11
plot(network,choice="network",gr=Selection@group,nv=nv,label_v=Selection@name,
edge.arrow.size=0.9,edge.thickness=1.5)

</code></pre>

<hr>
<h2 id='position-methods'>Returns the position of edges in the network</h2><span id='topic+position-methods'></span><span id='topic+position'></span><span id='topic+position+2Cnetwork-method'></span>

<h3>Description</h3>

<p>Returns the position of edges in the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'network'
position(net, nv = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position-methods_+3A_net">net</code></td>
<td>
<p>a network object</p>
</td></tr>
<tr><td><code id="position-methods_+3A_nv">nv</code></td>
<td>
<p>the level of cutoff at which the analysis should be done</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(net = \&quot;network\&quot;)&quot;)</dt><dd><p> Returns a matrix with the
position of the node. This matrix can then be used as an argument in the
plot function. </p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(Net)
position(Net)

</code></pre>

<hr>
<h2 id='predict+2Cmicro_array-method'>Prediction of the gene expressions after a knock-out experience
<code>predict</code></h2><span id='topic+predict+2Cmicro_array-method'></span><span id='topic+predict'></span><span id='topic+predict-methods'></span><span id='topic+predict+2CANY-method'></span>

<h3>Description</h3>

<p>Prediction of the gene expressions after a knock-out experience
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'micro_array'
predict(object, Omega, nv = 0, targets = NULL, adapt = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict+2B2Cmicro_array-method_+3A_object">object</code></td>
<td>
<p>a micro_array object</p>
</td></tr>
<tr><td><code id="predict+2B2Cmicro_array-method_+3A_omega">Omega</code></td>
<td>
<p>a network object.</p>
</td></tr>
<tr><td><code id="predict+2B2Cmicro_array-method_+3A_nv">nv</code></td>
<td>
<p>[=0] numeric; the level of the cutoff</p>
</td></tr>
<tr><td><code id="predict+2B2Cmicro_array-method_+3A_targets">targets</code></td>
<td>
<p>[NULL] vector; which genes are knocked out?</p>
</td></tr>
<tr><td><code id="predict+2B2Cmicro_array-method_+3A_adapt">adapt</code></td>
<td>
<p>[TRUE] boolean; do not raise an error if used with vectors 
instead of one column matrices.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas Jung, Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>References</h3>

<p>Jung, N., Bertrand, F., Bahram, S., Vallat, L., and
Maumy-Bertrand, M. (2014). Cascade: a R-package to study, predict and
simulate the diffusion of a signal through a temporal gene network.
<em>Bioinformatics</em>, btt705.
</p>
<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M., Bertrand, F.,
Meyer, N., ... &amp; Bahram, S. (2013). Reverse-engineering the genetic
circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. <em>Proceedings of the National Academy of
Sciences</em>, 110(2), 459-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Selection)
data(network)
#A nv value can chosen using the cutoff function
nv=.11
EGR1&lt;-which(match(Selection@name,"EGR1")==1)
P&lt;-position(network,nv=nv)

#We predict gene expression modulations within the network if EGR1 is experimentaly knocked-out. 
prediction_ko5&lt;-predict(Selection,network,nv=nv,targets=EGR1)

#Then we plot the results. Here for example we see changes at time point t2:
plot(prediction_ko5,time=2,ini=P,label_v=Selection@name)

</code></pre>

<hr>
<h2 id='print-methods'>Methods for Function <code>print</code></h2><span id='topic+print-methods'></span><span id='topic+print+2CANY-method'></span><span id='topic+print+2Cmicro_array-method'></span><span id='topic+print+2Cnetwork-method'></span>

<h3>Description</h3>

<p>Methods for function <code>print</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'micro_array'
print(x, ...)

## S4 method for signature 'network'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print-methods_+3A_x">x</code></td>
<td>
<p>an object of class micro-array or network</p>
</td></tr>
<tr><td><code id="print-methods_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Net)
print(Net)

data(M)
print(M)

</code></pre>

<hr>
<h2 id='Selection'>Selection of genes.</h2><span id='topic+Selection'></span>

<h3>Description</h3>

<p>20 (at most) genes with differential expression at t1, 20 (at most) genes
with differential expression at t2, 20 (at most) genes with differential
expression at t3, 20 (at most) genes with differential expression at t4 et
20 (at most) genes with global differential expression were selected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Selection)
head(Selection)
summary(Selection,3)

</code></pre>

<hr>
<h2 id='summary-methods'>Methods for Function <code>summary</code></h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2Cmicro_array-method'></span>

<h3>Description</h3>

<p>Methods for function <code>summary</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'micro_array'
summary(object, nb.graph = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p>an object of class micro-array</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_nb.graph">nb.graph</code></td>
<td>
<p>(optionnal) choose the graph to plot. Displays all graphs by default.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(M)
summary(M)

</code></pre>

<hr>
<h2 id='unionMicro-methods'>Makes the union between two micro_array objects.</h2><span id='topic+unionMicro-methods'></span><span id='topic+unionMicro'></span><span id='topic+unionMicro+2Cmicro_array+2Cmicro_array-method'></span><span id='topic+unionMicro+2Clist+2CANY-method'></span>

<h3>Description</h3>

<p>Makes the union between two micro_array objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'micro_array,micro_array'
unionMicro(M1, M2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unionMicro-methods_+3A_m1">M1</code></td>
<td>
<p>a micro-array or a list of micro-arrays</p>
</td></tr>
<tr><td><code id="unionMicro-methods_+3A_m2">M2</code></td>
<td>
<p>a micro-array or nothing if M1 is a list of micro-arrays</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(M1 = \&quot;micro_array\&quot;, M2 = \&quot;micro_array\&quot;)&quot;)</dt><dd>
<p>Returns a micro_array object which is the union of M1 and M2.  </p>
</dd>
<dt>list(&quot;signature(M1 = \&quot;list\&quot;, M2 = \&quot;ANY\&quot;)&quot;)</dt><dd><p> Returns a micro_array
object which is the union of the elements of M1.  </p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(M)
#Create another microarray object with 100 genes
Mbis&lt;-M
#Rename the 100 genes
Mbis@name&lt;-paste(M@name,"bis")
rownames(Mbis@microarray) &lt;- Mbis@name
#Union (merge without duplicated names) of the two microarrays. 
str(unionMicro(M,Mbis))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
