<!DOCTYPE html><html><head><title>Help for package mixAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mixAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mixAR-package'>







<p>Mixture Autoregressive Models</p></a></li>
<li><a href='#.canonic_coef'><p>Put core MixAR coefficients into a canonical form, internal function</p></a></li>
<li><a href='#adjustLengths'>
<p>Adjust the length of the second argument to be the same as that of the</p>
first one</a></li>
<li><a href='#bayes_mixAR'><p>Bayesian sampling of mixture autoregressive models</p></a></li>
<li><a href='#bx_dx'>
<p>RJMCMC move for AR order selection of mixture autoregressive models</p></a></li>
<li><a href='#Choose_pk'><p>Choose the autoregressive order of MixAR components</p></a></li>
<li><a href='#companion_matrix'><p>Create a companion matrix from a vector</p></a></li>
<li><a href='#cond_loglik'>
<p>Log-likelihood of MixAR models</p></a></li>
<li><a href='#dist_norm'>
<p>Functions for the standard normal distribution</p></a></li>
<li><a href='#em_est_dist'><p> Optimise scale parameters in MixARgen models</p></a></li>
<li><a href='#em_est_sigma'>
<p>Update the scale parameters of MixAR models</p></a></li>
<li><a href='#em_rinit'><p>Gaussian EM-step with random initialisation</p></a></li>
<li><a href='#em_tau'>
<p>Compute probabilities for the observations to belong to each of the components</p></a></li>
<li><a href='#err'>
<p>Calculate component specific error terms under MixAR model</p></a></li>
<li><a href='#err_k'><p>Utility function for MixAR</p></a></li>
<li><a href='#est_templ'><p>Create estimation templates from MixAR model objects</p></a></li>
<li><a href='#exampleModels'>
<p>MixAR models for examples and testing</p></a></li>
<li><a href='#fit_mixAR-methods'>
<p>Fit mixture autoregressive models</p></a></li>
<li><a href='#fit_mixARreg-methods'>
<p>Fit time series regression models with mixture autoregressive residuals</p></a></li>
<li><a href='#fit_mixVAR-methods'><p>Fit mixture vector autoregressive models</p></a></li>
<li><a href='#fnoise'><p>Generator functions for noise distributions</p></a></li>
<li><a href='#get_edist-methods'><p> Methods for function <code>get_edist</code> in package <span class="pkg">mixAR</span></p></a></li>
<li><a href='#initialize-methods'><p> Methods for function <code>initialize</code> in package <span class="pkg">mixAR</span></p></a></li>
<li><a href='#inner'>
<p>Generalised inner product and methods for class <code>"MixComp"</code></p></a></li>
<li><a href='#isStable'><p>Check if a MixAR model is stable</p></a></li>
<li><a href='#label_switch'><p>A posteriori relabelling of a Markov chain</p></a></li>
<li><a href='#lastn'>
<p>Extract the last n elements of a vector</p></a></li>
<li><a href='#lik_params'><p>  Vector of parameters of a MixAR model</p></a></li>
<li><a href='#lik_params_bounds'>
<p>Give natural limits for parameters of a MixAR model.</p></a></li>
<li><a href='#make_fcond_lik-methods'>
<p>Create a function for computation of conditional likelihood</p></a></li>
<li><a href='#marg_loglik'>
<p>Calculate marginal loglikelihood at high density points of a MAR model.</p></a></li>
<li><a href='#mix_central_moment-methods'><p>Methods for mix_central_moment</p></a></li>
<li><a href='#mix_ek'>
<p>Function and methods to compute component residuals for MixAR models</p></a></li>
<li><a href='#mix_hatk'><p>Compute component predictions for MixAR models</p></a></li>
<li><a href='#mix_location-methods'><p>Conditional mean of MixAR models</p></a></li>
<li><a href='#mix_moment'><p>Conditional moments of MixAR models</p></a></li>
<li><a href='#mix_moment-methods'><p>Methods for mix_moment</p></a></li>
<li><a href='#mix_ncomp-methods'>
<p>Number of rows or columns of a MixComp object</p></a></li>
<li><a href='#mix_pdf-methods'><p>Conditional pdf's and cdf's of MixAR models</p></a></li>
<li><a href='#mix_qf-methods'><p>Conditional quantile functions of MixAR models</p></a></li>
<li><a href='#mix_se-methods'><p>Compute standard errors of estimates of MixAR models</p></a></li>
<li><a href='#mix_variance-methods'><p>Methods for mix_variance</p></a></li>
<li><a href='#mixAR_BIC'>
<p>BIC based model selection for MixAR models</p></a></li>
<li><a href='#mixAR_cond_probs'><p>The E-step of the EM algorithm for MixAR models</p></a></li>
<li><a href='#mixAR_diag'>
<p>Diagnostic checks for mixture autoregressive models</p></a></li>
<li><a href='#mixAR_sim'><p>Simulate from MixAR models</p></a></li>
<li><a href='#mixAR_switch'><p>Relabel the components of a MixAR model</p></a></li>
<li><a href='#MixAR-class'><p>Class <code>"MixAR"</code> &mdash; mixture autoregressive models</p></a></li>
<li><a href='#mixAR-internal'><p>Internal mixAR Functions</p></a></li>
<li><a href='#mixAR-methods'><p>Create MixAR objects</p></a></li>
<li><a href='#mixARemFixedPoint'>
<p>EM estimation for mixture autoregressive models</p></a></li>
<li><a href='#mixARExperiment'><p>Simulation experiments with MixAR models</p></a></li>
<li><a href='#MixARGaussian-class'><p>mixAR models with Gaussian noise components</p></a></li>
<li><a href='#MixARgen-class'><p>Class <code>"MixARgen"</code></p></a></li>
<li><a href='#mixARnoise_sim'>
<p>Simulate white noise series from a list of functions and vector of regimes</p></a></li>
<li><a href='#MixComp-class'><p>Class <code>"MixComp"</code> &mdash; manipulation of MixAR time series</p></a></li>
<li><a href='#mixFilter'>
<p>Filter time series with MixAR filters</p></a></li>
<li><a href='#mixgenMstep'>
<p>M-step for models from class MixARgen</p></a></li>
<li><a href='#mixMstep'>
<p>Internal functions for estimation of MixAR models with Gaussian components</p></a></li>
<li><a href='#mixSARfit'>
<p>Fit mixture autoregressive models with seasonal AR parameters</p></a></li>
<li><a href='#mixSubsolve'>
<p>Support for EM estimation of MixAR models, internal function.</p></a></li>
<li><a href='#mixVAR_sim'><p>Simulate from multivariate MixAR models</p></a></li>
<li><a href='#MixVAR-class'><p>Class <code>"MixVAR"</code> &mdash; mixture vector autoregressive models</p></a></li>
<li><a href='#mixVARfit'>
<p>Fit mixture vector autoregressive models</p></a></li>
<li><a href='#MixVARGaussian-class'>
<p>MixVAR models with multivariate Gaussian noise components</p></a></li>
<li><a href='#multiStep_dist-methods'><p>Multi-step predictions for MixAR models</p></a></li>
<li><a href='#noise_dist'><p>Internal mixAR functions</p></a></li>
<li><a href='#noise_dist-methods'><p> Methods for function <code>noise_dist</code> in package <span class="pkg">mixAR</span></p></a></li>
<li><a href='#noise_moment-methods'><p>Compute moments of the noise components</p></a></li>
<li><a href='#noise_params-methods'><p> Methods for function <code>noise_params</code> in package <span class="pkg">mixAR</span></p></a></li>
<li><a href='#noise_rand-methods'><p> Methods for function <code>noise_rand</code> in package <span class="pkg">mixAR</span></p></a></li>
<li><a href='#parameters'><p>Set or extract the parameters of MixAR objects</p></a></li>
<li><a href='#percent_of'>
<p>Infix operator to apply functions to matrix-like objects</p></a></li>
<li><a href='#permn_cols'><p>All permutations of the columns of a matrix</p></a></li>
<li><a href='#PortfolioData1'><p>Closing prices of four stocks</p></a></li>
<li><a href='#predict_coef'><p>Exact predictive parameters for multi-step MixAR prediction</p></a></li>
<li><a href='#ragged'>
<p>Small utilities for ragged objects</p></a></li>
<li><a href='#ragged2char'><p>Convert a ragged list into a matrix of characters</p></a></li>
<li><a href='#raggedCoef-class'>
<p>Class <code>"raggedCoef"</code> &mdash; ragged list objects</p></a></li>
<li><a href='#raggedCoefS-class'>
<p>Class <code>"raggedCoefS"</code> &mdash; ragged list</p></a></li>
<li><a href='#raggedCoefV-class'>
<p>Class <code>"raggedCoefV"</code> &mdash; ragged list</p></a></li>
<li><a href='#raghat1'>
<p>Filter a time series with options to shift and scale</p></a></li>
<li><a href='#randomArCoefficients'><p>Random initial values for MixAR estimation</p></a></li>
<li><a href='#row_lengths-methods'><p> Methods for function <code>row_lengths</code> in package <span class="pkg">mixAR</span></p></a></li>
<li><a href='#sampZpi'>
<p>Sampling functions for Bayesian analysis of mixture autoregressive</p>
models</a></li>
<li><a href='#show_diff'><p>Show differences between two models</p></a></li>
<li><a href='#simuExperiment'><p>Perform simulation experiments</p></a></li>
<li><a href='#stdnormmoment'><p>Compute moments and absolute moments of standardised-t and normal distributions</p></a></li>
<li><a href='#tau2probhat'>
<p>Estimate probabilities of a MixAR model from tau.</p></a></li>
<li><a href='#test_unswitch'><p>A test for 'unswitch'</p></a></li>
<li><a href='#tomarparambyComp'>
<p>Translations of my old MixAR Mathematica functions</p></a></li>
<li><a href='#ui'><p>Utility function for mixAR</p></a></li>
<li><a href='#unswitch'>
<p>Dealing with label switching in MixAR experiments</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mixture Autoregressive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.22.8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Model time series using mixture autoregressive (MAR)
             models.  Implemented are frequentist (EM) and Bayesian
             methods for estimation, prediction and model
             evaluation. See Wong and Li (2002)
             &lt;<a href="https://doi.org/10.1111%2F1467-9868.00222">doi:10.1111/1467-9868.00222</a>&gt;, Boshnakov (2009)
             &lt;<a href="https://doi.org/10.1016%2Fj.spl.2009.04.009">doi:10.1016/j.spl.2009.04.009</a>&gt;), and the extensive
             references in the documentation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, utils, stats4, BB, combinat, timeDate,
fGarch, Rdpack (&ge; 0.7), gbutils (&ge; 0.3-1), MCMCpack, e1071,
permute, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fma, testthat, covr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://geobosh.github.io/mixAR/">https://geobosh.github.io/mixAR/</a> (doc),
<a href="https://github.com/GeoBosh/mixAR/">https://github.com/GeoBosh/mixAR/</a> (devel)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeoBosh/mixAR/issues">https://github.com/GeoBosh/mixAR/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>raggedCoef.R raggedCoefS.R mixComp.R mixAR.R mixARcalc.R
mixutil.R dist.R predict.R mix_se.R obs_info_matrix.R
samp_functions.R bayes_mixAR.R label_switch.R Choose_pk.R
marg_loglik.R mixSARfit.R mixARreg.R fit_mixARreg.R
raggedCoefV.R mixVAR.R fit_mixVAR.R cond_loglikV.R mixVAR_sim.R
tsdiag.R mixAR_diag.R devel.R em0.R emGaussian.R emgen.R
00marmath.R exmodels.R mixARsim.R</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-18 17:02:12 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Georgi N. Boshnakov [aut, cre],
  Davide Ravagli [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 01:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mixAR-package'>







Mixture Autoregressive Models
</h2><span id='topic+mixAR-package'></span>

<h3>Description</h3>

<p>Model time series using mixture autoregressive (MAR)
             models.  Implemented are frequentist (EM) and Bayesian
             methods for estimation, prediction and model
             evaluation. See Wong and Li (2002)
             &lt;doi:10.1111/1467-9868.00222&gt;, Boshnakov (2009)
             &lt;doi:10.1016/j.spl.2009.04.009&gt;), and the extensive
             references in the documentation.
</p>


<h3>Details</h3>
















<p>Package <span class="pkg">mixAR</span> provides functions for modelling with mixture
autoregressive (MixAR) models. The S4 class <code>"MixARGaussian"</code> can
be used when the error distributions of the components are standard
Gaussian. The class <code>"MixARgen"</code> admits arbitrary (well, within
reason) distributions for the error components. Both classes inherit
from the virtual class <code>"MixAR"</code>.
</p>
<p>Estimation can be done with <code>fit_mixAR</code>.  Currently, the EM
algorithm is used for estimation.
</p>
<p>For <code>"MixARGaussian"</code> the M-step of the EM algorithm reduces to a
system of linear equations. For <code>"MixARgen"</code> the problem is
substantially non-linear. The implementation is fairly general but
currently not optimised for efficiency. The specification of the error
distributions went through several stages and may still be
reviewed. However, backward compatibility will be kept.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov [aut, cre],
  Davide Ravagli [aut]
</p>
<p>Maintainer: Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;
</p>


<h3>References</h3>

<p>Akinyemi MI (2013).
<em>Mixture autoregressive models: asymptotic properties and application to financial risk</em>.
Ph.D. thesis, Probability and Statistics Group, School of Mathematics, University of Manchester.
</p>
<p>Boshnakov GN (2009).
&ldquo;Analytic expressions for predictive distributions in mixture autoregressive models.&rdquo;
<em>Stat. Probab. Lett. </em>, <b>79</b>(15), 1704-1709.
<a href="https://doi.org/10.1016/j.spl.2009.04.009">doi:10.1016/j.spl.2009.04.009</a>.
</p>
<p>Boshnakov GN (2011).
&ldquo;On First and Second Order Stationarity of Random Coefficient Models.&rdquo;
<em>Linear Algebra Appl.</em>, <b>434</b>(2), 415&ndash;423.
<a href="https://doi.org/10.1016/j.laa.2010.09.023">doi:10.1016/j.laa.2010.09.023</a>.
</p>
<p>Fong PW, Li WK, Yau CW, Wong CS (2007).
&ldquo;On a mixture vector autoregressive model.&rdquo;
<em>Can. J. Stat. </em>, <b>35</b>(1), 135-150.
</p>
<p>Ravagli D, Boshnakov GN (2020).
&ldquo;Bayesian analysis of mixture autoregressive models covering the complete parameter space.&rdquo;
2006.11041, <a href="https://arxiv.org/abs/2006.11041">https://arxiv.org/abs/2006.11041</a>.
</p>
<p>Ravagli D, Boshnakov GN (2020).
&ldquo;Portfolio optimization with mixture vector autoregressive models.&rdquo;
2005.13396, <a href="https://arxiv.org/abs/2005.13396">https://arxiv.org/abs/2005.13396</a>.
</p>
<p>Hossain AS (2012).
<em>Complete Bayesian analysis of some mixture time series models</em>.
Ph.D. thesis, Probability and Statistics Group, School of Mathematics, University of Manchester.
</p>
<p>Wong CS (1998).
<em>Statistical inference for some nonlinear time series models</em>.
Ph.D. thesis, University of Hong Kong, Hong Kong .
</p>
<p>Wong CS, Li WK (2000).
&ldquo;On a mixture autoregressive model.&rdquo;
<em>J. R. Stat. Soc., Ser. B, Stat. Methodol. </em>, <b>62</b>(1), 95-115.
</p>
<p>Wong CS, Li WK (2001).
&ldquo;On a logistic mixture autoregressive model.&rdquo;
<em>Biometrika </em>, <b>88</b>(3), 833-846.
<a href="https://doi.org/10.1093/biomet/88.3.833">doi:10.1093/biomet/88.3.833</a>.
</p>
<p>Wong CS, Li WK (2001).
&ldquo;On a mixture autoregressive conditional heteroscedastic model.&rdquo;
<em>J. Am. Stat. Assoc. </em>, <b>96</b>(455), 982-995.
<a href="https://doi.org/10.1198/016214501753208645">doi:10.1198/016214501753208645</a>.
</p>


<h3>See Also</h3>

<p>fit several types of mixAR models:
<code><a href="#topic+fit_mixAR">fit_mixAR</a></code>, <code><a href="#topic+bayes_mixAR">bayes_mixAR</a></code>,
<code><a href="#topic+fit_mixARreg">fit_mixARreg</a></code>,
<code><a href="#topic+mixSARfit">mixSARfit</a></code>;
</p>
<p>Predictive distributions and summaries:
<code><a href="#topic+mix_pdf">mix_pdf</a></code>, <code><a href="#topic+mix_cdf">mix_cdf</a></code>, <code><a href="#topic+mix_qf">mix_qf</a></code>,
<code><a href="#topic+mix_location">mix_location</a></code>,
<code><a href="#topic+mix_variance">mix_variance</a></code>,
<code><a href="#topic+mix_central_moment">mix_central_moment</a></code>,
<code><a href="#topic+mix_moment">mix_moment</a></code>,
<code><a href="#topic+mix_kurtosis">mix_kurtosis</a></code>,
<code><a href="#topic+mix_ekurtosis">mix_ekurtosis</a></code>
</p>
<p>multi-step prediction:
<code><a href="#topic+multiStep_dist">multiStep_dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## object 'exampleModels' contains a number of models for examples and testing
names(exampleModels)
exampleModels$WL_ibm

## some of the models below are available in object 'exampleModels';
## the examples here show how to create them from scratch
mo_WLprob &lt;- c(0.5439, 0.4176, 0.0385)              # model coefficients from Wong&amp;Li
mo_WLsigma &lt;- c(4.8227, 6.0082, 18.1716)
mo_WLar &lt;- list(c(0.6792, 0.3208), c(1.6711, -0.6711), 1)

mo_WL &lt;- new("MixARGaussian", prob = mo_WLprob, scale = mo_WLsigma, arcoef = mo_WLar)
                                        
mo_WL_A &lt;- new("MixARGaussian"                         # WongLi, model A
              , prob = c(0.5, 0.5)
              , scale = c(5, 1)
              , shift = c(0, 0)
              , arcoef = list(c(0.5), c(1.1))
              )

mo_WL_B &lt;- new("MixARGaussian"                         # WongLi, model B
              , prob = c(0.75, 0.25)
              , scale = c(5, 1)
              , shift = c(0, 0)
              , arcoef = list(c(0.5), c(1.4))
              )
                                        
mo_WL_I &lt;- new("MixARGaussian"                          # WongLi, model I
              , prob = c(0.4, 0.3, 0.3)
              , scale = c(1, 1, 5)
              , shift = c(0, 0, -5)
              , arcoef = list(c(0.9, -0.6), c(-0.5), c(1.50, -0.74, 0.12))
              )

mo_WL_II &lt;- new("MixARGaussian"                         # WongLi, model II
               , prob = c(0.4, 0.3, 0.3)
               , scale = c(1, 1, 5)
               , shift = c(5, 0, -5)
               , arcoef = list(c(0.9, -0.6), c(-0.7, 0), c( 0, 0.80))
               )

## MixAR models with arbitrary dist. of the components
## (user interface not finalized)

## Gaussian
mo_WLgen &lt;- new("MixARgen", prob = mo_WLprob, scale = mo_WLsigma, arcoef = mo_WLar,
               dist = list(dist_norm))

## t_3
mo_WLt3v &lt;- new("MixARgen", prob = mo_WLprob, scale = mo_WLsigma, arcoef = mo_WLar,
               dist = list(fdist_stdt(3, fixed = FALSE)))

## t_20, t_30, t_40 (can be used to start estimation)
mo_WLtf &lt;- new("MixARgen", prob = mo_WLprob, scale = mo_WLsigma, arcoef = mo_WLar,
              dist = list(generator =
                              function(par)
                                  fn_stdt(par, fixed = FALSE), param = c(20, 30, 40)))

## data(ibmclose, package = "fma")  # for `ibmclose'

## The examples below are quick but some of them are marked as 'not run'
## to avoid cumulative time of more than 5s on CRAN.

## fit a MAR(2,2,1) model
a0a &lt;- fit_mixAR(as.numeric(fma::ibmclose), c(2, 2, 1), crit = 1e-4)
## same with 2 sets of automatically generated initial values.

a0b &lt;- fit_mixAR(as.numeric(fma::ibmclose), c(2, 2, 1), 2, crit = 1e-4)


## fix the shift parameters:
a1a &lt;- fit_mixAR(as.numeric(fma::ibmclose), c(2, 2, 1), fix = "shift", crit = 1e-4)
## ... with 3 sets of automatically generated initial values.

a1b &lt;- fit_mixAR(as.numeric(fma::ibmclose), c(2, 2, 1), 3, fix = "shift", crit = 1e-4)



## specify the model using a MixAR model object
a1c &lt;- fit_mixAR(as.numeric(fma::ibmclose), a1a$model, init = a0a$model, fix = "shift",
           crit = 1e-4)

## fit a model like mo_WL using as initial values 2 automatically generated sets.
a2 &lt;- fit_mixAR(as.numeric(fma::ibmclose), mo_WL, 2, fix = "shift", permute = TRUE, 
          crit = 1e-4)


moT_B3 &lt;- new("MixARgen"
               , prob = c(0.3, 0.3, 0.4)
               , scale = c(2, 1, 0.5)
               , shift = c(5, -5, 0)
               , arcoef = list(c(0.5, 0.24), c(-0.9), c(1.5, -0.74, 0.12))
                                        # t4, t4, t10
               , dist = distlist("stdt", c(4,10), fixed = c(FALSE, TRUE), tr = c(1, 1, 2))
               )

moT_C1 &lt;- new("MixARgen"
              , prob = c(0.3, 0.3, 0.4)
              , scale = c(2, 1, 0.5)
              , shift = c(5, -5, 0)
              , arcoef = list(c(0.5, 0.24), c(-0.9), c(1.5, -0.74, 0.12))
                                        # t4, t7, N(0,1)
              , dist = distlist(c("stdt", "stdt", "stdnorm"), c(4,7))
              )

## demonstrate reuse of existing models
exampleModels$WL_Bt_1
moT_C2 &lt;- new("MixARgen"
              , model = exampleModels$WL_Bt_1
              , dist = distlist(c("stdt", "stdt", "stdnorm"), c(4,7))  # t4, t7, N(0,1)
              )
moT_C3 &lt;- new("MixARGaussian", model = exampleModels$WL_Bt_1 )
</code></pre>

<hr>
<h2 id='.canonic_coef'>Put core MixAR coefficients into a canonical form, internal function</h2><span id='topic+.canonic_coef'></span>

<h3>Description</h3>

<p>Put core MixAR coefficients into a canonical form, internal
function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.canonic_coef(coef, filler)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".canonic_coef_+3A_coef">coef</code></td>
<td>
<p>the core coefficients of a MixAR model, a list.</p>
</td></tr>
<tr><td><code id=".canonic_coef_+3A_filler">filler</code></td>
<td>
<p>a value for filling unspecified entries, such as
<code>NA_real_</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function called by <code>mixAR</code> to put MixAR
parameters into a canonical form. <code>"shift"</code>, <code>"scale"</code> and
<code>"prob"</code> are normally vectors with one element for each
component but they may also be given as a single number, in which case
it is taken to be the common value for all parameters and
<code>.canonic_coef</code> extends them correspondingly. Also, the AR
coefficients may be specified in a number of ways and this function
converts them to the format used by the MixAR classes.
</p>


<h3>Value</h3>

<p>a list with the folowing components:
</p>
<table>
<tr><td><code>order</code></td>
<td>
<p>MixAR order, a vector of integers</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>MixAR probabilities, vector of length<code>length(order)</code></p>
</td></tr>
<tr><td><code>shift</code></td>
<td>
<p>MixAR shift parameters, vector of length<code>length(order)</code></p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>MixAR scle parameters, vector of length<code>length(order)</code></p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficients as a <code>"raggedCoef"</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixAR">mixAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## missing components are filled with 'filler', extended accordingly
mixAR:::.canonic_coef(list(order = c(2,3)), filler = NA)

# here 'scale' is replicated, the missing 'shift' is inserted
mo &lt;- list(order = c(2,3), prob = c(0.4, 0.6), scale = 1,
           arcoef = list(c(0.5, -0.5), c(1.1,  0.0, -0.5)) )
mixAR:::.canonic_coef(mo, filler = NA)
</code></pre>

<hr>
<h2 id='adjustLengths'>
Adjust the length of the second argument to be the same as that of the
first one
</h2><span id='topic+adjustLengths'></span>

<h3>Description</h3>

<p>Adjust the length of the second argument to be the same as that of the
first one. Appends 0's if the second argument is shorter and drops
excess elements if it is longer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustLengths(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustLengths_+3A_x">x</code></td>
<td>
<p>the template vector</p>
</td></tr>
<tr><td><code id="adjustLengths_+3A_y">y</code></td>
<td>
<p>the vector to be adjusted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code></p>

<hr>
<h2 id='bayes_mixAR'>Bayesian sampling of mixture autoregressive models</h2><span id='topic+bayes_mixAR'></span>

<h3>Description</h3>

<p>Samples parameters of a mixture autoregressive model from respective
posterior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_mixAR(y, model, fix_shift = FALSE, a = .2, c = 2, tau, nsim, burnin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_mixAR_+3A_y">y</code></td>
<td>
<p>a time series (currently a numeric vector).</p>
</td></tr>
<tr><td><code id="bayes_mixAR_+3A_model">model</code></td>
<td>

<p>an object of class <code>MixAR</code>. Currently only handles
<code>MixARGaussian</code> objects.
</p>
</td></tr>
<tr><td><code id="bayes_mixAR_+3A_fix_shift">fix_shift</code></td>
<td>

<p>should <code>shift</code> be kept fixed? If <code>FALSE</code> (default)
<code>shift</code> is sampled.
</p>
</td></tr>
<tr><td><code id="bayes_mixAR_+3A_a">a</code>, <code id="bayes_mixAR_+3A_c">c</code></td>
<td>

<p>numeric hyperparameters, default values are from
Richardson and Green (1997).
</p>
</td></tr>
<tr><td><code id="bayes_mixAR_+3A_tau">tau</code></td>
<td>

<p><code>numeric</code> vector of length g, the number of components in the
mixture. Tuning parameter for M-H move in updating AR parameters. If
<code>length(tau)</code> is 1, same tuning parameter is taken for all
components.
</p>
</td></tr>
<tr><td><code id="bayes_mixAR_+3A_nsim">nsim</code></td>
<td>

<p><code>numeric</code>, the number of iterations.
</p>
</td></tr>
<tr><td><code id="bayes_mixAR_+3A_burnin">burnin</code></td>
<td>

<p><code>numeric</code>, the number of iterations taken as burn-in period.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see Ravagli and Boshnakov (2020).
</p>


<h3>Value</h3>

<p>a list with following elements:
</p>
<table>
<tr><td><code>mix_weights</code></td>
<td>

<p>a <code>g</code> columns matrix with samples from the posterior distributions of
the mixing weights.
</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>

<p>a <code>g</code> columns matrix with samples from posterior distributions of
scale parameters.
</p>
</td></tr>
<tr><td><code>precision</code></td>
<td>

<p>a <code>g</code> columns matrix with samples from posterior distributions of
precision parameters, defined as <code>1 / (scale ^ 2)</code>.
</p>
</td></tr>
<tr><td><code>shift</code></td>
<td>

<p>a <code>g</code> columns matrix with samples from posterior distributions of
shift parameters, namely phi_k0.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>

<p>a <code>g</code> columns matrix with samples from posterior distributions
of component means, calculated as <code>phi_k0 / (1 - phi_k1 - phi_k2 - ...)</code>.
</p>
</td></tr>
<tr><td><code>ARcoeff</code></td>
<td>

<p>a list which elements are matrices, one for each AR component in the
mixture.
</p>
</td></tr>
<tr><td><code>acc_rate</code></td>
<td>

<p><code>numeric</code> vector, the acceptance rate for M-H moves.
</p>
</td></tr>
<tr><td><code>n_samp</code></td>
<td>

<p>the sample size, calculated as <code>nsim - burnin</code>.
</p>
</td></tr>
<tr><td><code>LatentZ</code></td>
<td>

<p>the latest Z variables drawn (for utility only).
</p>
</td></tr>
<tr><td><code>n_comp</code></td>
<td>

<p>the number of components in the mixture.
</p>
</td></tr>
<tr><td><code>fix_shift</code></td>
<td>

<p>same as input, whether the shift parameter was kept fixed or not.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Davide Ravagli
</p>


<h3>References</h3>

<p>Richardson S, Green PJ (1997).
&ldquo;On Bayesian Analysis of Mixtures with an Unknown Number of Components.&rdquo;
<em>J. R. Stat. Soc., Ser. B, Stat. Methodol. </em>, <b>59</b>(4), 731-792.
</p>
<p>Ravagli D, Boshnakov GN (2020).
&ldquo;Bayesian analysis of mixture autoregressive models covering the complete parameter space.&rdquo;
2006.11041, <a href="https://arxiv.org/abs/2006.11041">https://arxiv.org/abs/2006.11041</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob &lt;- c(0.5, 0.5)
sigma &lt;- c(1, 2)
ar &lt;- list(-0.5, 1)

model &lt;- new("MixARGaussian", prob = prob, scale = sigma, arcoef = ar)

## MAR(1,1) model
y &lt;- mixAR_sim(model, 300, rep(0, max(model@order)))

bayes_mixAR(y, model, fix_shift = FALSE, tau = c(.15,.25), nsim = 20, burnin = 10)
</code></pre>

<hr>
<h2 id='bx_dx'>
RJMCMC move for AR order selection of mixture autoregressive models
</h2><span id='topic+bx_dx'></span>

<h3>Description</h3>

<p>Computes probabilities for deciding whether the AR order should be
increased or decreased by 1 at each iteration in Bayesian analysis of
mixture autoregressive models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bx_dx(method = c("Ratio", "Poisson", "NULL"), par, pk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bx_dx_+3A_method">method</code></td>
<td>

<p>the method used for updating probabilities. If <code>"Ratio"</code> or
<code>"Poisson"</code>, probabilities depend on <code>par</code> and decrease
as <code>pk</code> increases. If <code>"NULL"</code>, probabilities are set to
0.5. See Examples for details.
</p>
</td></tr>
<tr><td><code id="bx_dx_+3A_par">par</code></td>
<td>

<p>tuning parameter for calculating updating probabilities.
</p>
</td></tr>
<tr><td><code id="bx_dx_+3A_pk">pk</code></td>
<td>

<p>autoregressive order of the selected component.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>2</code> elements:
</p>
<table>
<tr><td><code>bx</code></td>
<td>
<p>The probability of increasing the autoregressive order by 1.</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>

<p>The probability of decreasing the autoregressive order by 1,
calculated as <code>1 - bx</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is for use within <code><a href="#topic+Choose_pk">Choose_pk</a></code>.
</p>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>References</h3>

<p>Ravagli D, Boshnakov GN (2020).
&ldquo;Bayesian analysis of mixture autoregressive models covering the complete parameter space.&rdquo;
2006.11041, <a href="https://arxiv.org/abs/2006.11041">https://arxiv.org/abs/2006.11041</a>.
</p>

<hr>
<h2 id='Choose_pk'>Choose the autoregressive order of MixAR components</h2><span id='topic+Choose_pk'></span>

<h3>Description</h3>

<p>Reversible Jump MCMC algorithm to choose the optimal
autoregressive order of each component of a mixture autoregressive
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Choose_pk(y, model, fix_shift = FALSE, tau, pmax, method, par = NULL, nsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Choose_pk_+3A_y">y</code></td>
<td>

<p>a time series. Currently a <code>numeric</code> vector.
</p>
</td></tr>
<tr><td><code id="Choose_pk_+3A_model">model</code></td>
<td>

<p>an object inheriting from class <code>"MixAR"</code>.
</p>
</td></tr>
<tr><td><code id="Choose_pk_+3A_fix_shift">fix_shift</code></td>
<td>

<p>whether the shift/mean parameter should be kept fixed to its
starting value or not. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="Choose_pk_+3A_tau">tau</code></td>
<td>

<p>tuning parameters for Metropolis-Hastings algorithm in sampling AR
coefficients.
</p>
</td></tr>
<tr><td><code id="Choose_pk_+3A_pmax">pmax</code></td>
<td>

<p>the largest autoregressive order allowed for each component.
</p>
</td></tr>
<tr><td><code id="Choose_pk_+3A_method">method</code></td>
<td>

<p>character vector of length 1. Method for calculating probability of
new AR order to be increased/decreased by 1 unit. Currently
available <code>"Ratio"</code>, <code>"Poisson"</code> and
<code>"NULL"</code>. Default is <code>"NULL"</code>.
</p>
</td></tr>
<tr><td><code id="Choose_pk_+3A_par">par</code></td>
<td>

<p><code>numeric</code>, parameter for tuning probabilities according to
<code>method</code>. Ignored if <code>method</code> is &quot;NULL&quot;.
</p>
</td></tr>
<tr><td><code id="Choose_pk_+3A_nsim">nsim</code></td>
<td>

<p><code>numeric</code>, the number of iterations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>

<p>a dataframe with <code>g+1</code> columns. The first <code>g</code> columns
contain the autoregressive orders of the components, the last column
how often a model is preferred, divided by <code>nsim</code>.
</p>
</td></tr>
<tr><td><code>fix_shift</code></td>
<td>
<p>the choice made for the shift/mean parameters.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used to increase/decrease AR orders.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>Choose_pk</code> currenlty supports class <code>"MixARGaussian"</code>
only.
</p>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>References</h3>

<p>Ravagli D, Boshnakov GN (2020).
&ldquo;Bayesian analysis of mixture autoregressive models covering the complete parameter space.&rdquo;
2006.11041, <a href="https://arxiv.org/abs/2006.11041">https://arxiv.org/abs/2006.11041</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bx_dx">bx_dx</a></code> for more details on the <code>method</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- new("MixARGaussian", 
             prob   = exampleModels$WL_At@prob,      # c(0.5, 0.5)
             scale  = exampleModels$WL_At@scale,     # c(1, 2)        
             arcoef = list(-0.5, 1) )
             # note: arcoef != list(-0.5, 1.1) == exampleModels$WL_At@arcoef@a

set.seed(1234)
n &lt;- 50 # 200
y &lt;- mixAR_sim(model, n, rep(0, max(model@order)), nskip = 100)

nsim &lt;- 25 # 100
pk_star &lt;- Choose_pk(y, model, tau = c(.15, .25), pmax = 5, method = "NULL", nsim = nsim)
</code></pre>

<hr>
<h2 id='companion_matrix'>Create a companion matrix from a vector</h2><span id='topic+companion_matrix'></span>

<h3>Description</h3>

<p>Create a companion matrix from a vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>companion_matrix(v, ncol = length(v), nrow = ncol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="companion_matrix_+3A_v">v</code></td>
<td>
<p>the first row of the matrix, a numeric vector or a matrix
with one row.</p>
</td></tr>
<tr><td><code id="companion_matrix_+3A_ncol">ncol</code></td>
<td>
<p>number of columns, a number.</p>
</td></tr>
<tr><td><code id="companion_matrix_+3A_nrow">nrow</code></td>
<td>
<p>number of rows, a number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default settings, a square <code class="reqn">m\times m</code> matrix is
returned, where <code class="reqn">m</code> is the length of <code>v</code>. If <code>ncol&gt;</code><code class="reqn">m</code>,
the vector is amended with 0's. It is an error for <code>ncol</code> to be
smaller than <code class="reqn">m</code>.
</p>
<p>Argument <code>nrow</code> may be used to get a rectangular matrix, although
the term &quot;companion&quot; is normally used only for square matrices.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>companion_matrix(4:1)
companion_matrix(4:1, ncol=6)
companion_matrix(4:1, ncol=6, nrow=3)
</code></pre>

<hr>
<h2 id='cond_loglik'>
Log-likelihood of MixAR models
</h2><span id='topic+cond_loglik'></span><span id='topic+cond_loglikS'></span>

<h3>Description</h3>

<p>Compute the log-likelihood of a MixAR model for a univariate time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_loglik(model, x, index)
cond_loglikS(model, x, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_loglik_+3A_model">model</code></td>
<td>
<p>a MixAR model.</p>
</td></tr>
<tr><td><code id="cond_loglik_+3A_x">x</code></td>
<td>
<p>a time series or numeric vector.</p>
</td></tr>
<tr><td><code id="cond_loglik_+3A_index">index</code></td>
<td>

<p>a vector of integers giving the indices in <code>x</code> over which to
compute the sum for the log-likelihood, default is
<code>(p+1):length(x)</code>, where <code>p</code> is the maximum AR order of
the components of the model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cond_loglik</code> computes the conditional log-likelihood of a MixAR
model. Conditional here means conditional on the first <code>p</code> values
being fixed, where <code>p</code> is the maximum AR order of the components
of the model.
</p>
<p>Argument <code>index</code> can be used to compute the sum over a subset of
time points. 
</p>
<p><code>cond_loglikS</code> is a variant of <code>cond_loglik</code> for the case
when the input model contains seasonal AR coefficients.
</p>


<h3>Value</h3>

<p>the log-likelihood, a numeric value
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov and Davide Ravagli</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data(ibmclose, package = "fma") # doesn't work with fma v2.4, using '::'
cond_loglik(exampleModels$WL_ibm,     as.numeric(fma::ibmclose))
cond_loglik(exampleModels$WL_ibm_gen, as.numeric(fma::ibmclose))

data(lynx)  # for 'lynx' data
sar &lt;- new("raggedCoefS", a = list(c(1.1022, -0.2835), c(1.5279, -0.8871)),
                          as = list(c(0, 0), 0), s = 10)

## SMAR(2; 2, 2)(2, 1)_10
model_s10 &lt;- new("MixARGaussian", prob = c(.3, .7), scale = c(.08, .202),
                                  arcoef = sar, shift = c(.7,1)) 
cond_loglikS(model_s10, log(lynx))
cond_loglikS(model_s10, log(lynx), index = 45:114) # on reduced dataset
</code></pre>

<hr>
<h2 id='dist_norm'>
Functions for the standard normal distribution
</h2><span id='topic+dist_norm'></span>

<h3>Description</h3>

<p>The noise distributions are specified by a list of functions for the
density, quantiles, etc. This object demonstrates this for the
standard normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_norm</code></pre>


<h3>Format</h3>

<p>This is a list of functions or names of functions for calculations
related to the standard normal distribution. Currently it has
elements with the following names:
&quot;pdf&quot;, &quot;cdf&quot;, &quot;rand&quot;, &quot;logpdf&quot;, &quot;Fscore&quot;, &quot;xFscore&quot;, &quot;Parscore&quot;, &quot;get_param&quot;, &quot;set_param&quot;, &quot;any_param&quot;, &quot;show&quot;.
</p>


<h3>Details</h3>

<p><code>dist_norm</code> may be used to specify the noise distribution for
<code>MixAR</code> models. It can be used as a template if other
distributions are needed, see also <code>fdist_stdnorm</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fdist_stdnorm">fdist_stdnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_norm
dist_norm$pdf
dist_norm$cdf
</code></pre>

<hr>
<h2 id='em_est_dist'> Optimise scale parameters in MixARgen models </h2><span id='topic+em_est_dist'></span>

<h3>Description</h3>

<p>Optimise the scale parameters in MixAR models from class MixARgen.
Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>em_est_dist(tau, etk, parscore, sigma, nu, logpdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="em_est_dist_+3A_tau">tau</code></td>
<td>
<p>conditional probabilities, an object of class &quot;MixComp&quot;,
see 'Details'.</p>
</td></tr>
<tr><td><code id="em_est_dist_+3A_etk">etk</code></td>
<td>
<p>component residuals, see 'Details'.</p>
</td></tr>
<tr><td><code id="em_est_dist_+3A_parscore">parscore</code></td>
<td>
<p>the score function(s), see 'Details'.</p>
</td></tr>
<tr><td><code id="em_est_dist_+3A_sigma">sigma</code></td>
<td>
<p>current values of the scale parameters, a numeric vector.</p>
</td></tr>
<tr><td><code id="em_est_dist_+3A_nu">nu</code></td>
<td>
<p>current values of the parameters. w.r.t. which optimisation
is done. 
</p>
</td></tr>
<tr><td><code id="em_est_dist_+3A_logpdf">logpdf</code></td>
<td>
<p>the log of pdf as a function of the parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One or more of the error distributions of a MixAR model may have
parameters that are considered unknown. In that case
<code>em_est_dist</code> can be used to optimise with respect to them.
</p>
<p>The representation of the error distributions in &quot;MixARgen&quot; models
carries all the necessary information about
parameters. <code>em_est_dist</code> works by extracting their current
values from <code>logpdf</code>, passes them to the optimisation function
(or equation solver) and stores the result back into <code>logpdf</code>.
<code>em_est_dist</code> is quite general, as long as <code>logpdf</code> is
prepared according to the conventions it expects (this is so if they
are valid elements of the <code>dist</code> slot of &quot;MixARgen&quot; objects).
</p>


<h3>Value</h3>

<p>the new values of the parameters
</p>

<hr>
<h2 id='em_est_sigma'>
Update the scale parameters of MixAR models
</h2><span id='topic+em_est_sigma'></span><span id='topic+tauetk2sigmahat'></span>

<h3>Description</h3>

<p>Calculates estimates of scale parameters of MixAR models from
conditional probabilities and mixture &lsquo;residuals&rsquo;.
Used in EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauetk2sigmahat(tau, etk)

em_est_sigma(tau, etk, Fscore, sigma,
             dontfix = rep(TRUE, length(sigma)), compwise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="em_est_sigma_+3A_tau">tau</code></td>
<td>

<p>the conditional probabilities for the groups, a <code>"MixComp"</code>
object.
</p>
</td></tr>
<tr><td><code id="em_est_sigma_+3A_etk">etk</code></td>
<td>
<p>component &quot;residuals&quot;, MixComp object(?).</p>
</td></tr>
<tr><td><code id="em_est_sigma_+3A_fscore">Fscore</code></td>
<td>
<p>the score function(s) of the noise distributions.</p>
</td></tr>
<tr><td><code id="em_est_sigma_+3A_sigma">sigma</code></td>
<td>
<p>current values of the scale parameters.</p>
</td></tr>
<tr><td><code id="em_est_sigma_+3A_compwise">compwise</code></td>
<td>
<p>if <code>TRUE</code> solve the equations component-wise, see
'Details.</p>
</td></tr>
<tr><td><code id="em_est_sigma_+3A_dontfix">dontfix</code></td>
<td>
<p>a logical vector containig <code>TRUE</code> in the positions
of elements of <code>sigma</code> that are to be estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tauetk2sigmahat</code> calculates estimates of the scale parameters
for a MixAR time series with Gaussian components. There is an explicit
formula in that case.
</p>
<p><code>em_est_sigma</code> calculates estimates of the scale parameters in
the general case.  The non-linear equations are solved using functions
from package <code>BB</code>. The equations for the components can often be
solved independently. When that is the case, <code>compwise</code> may speed
things up a little.
</p>


<h3>Value</h3>

<p>The new values of the scale parameters, a numeric vector
</p>

<hr>
<h2 id='em_rinit'>Gaussian EM-step with random initialisation</h2><span id='topic+em_rinit'></span><span id='topic+etk2tau'></span>

<h3>Description</h3>

<p>Gaussian EM-step with random initialisation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>em_rinit(y, order, partempl)

etk2tau(etk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="em_rinit_+3A_y">y</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="em_rinit_+3A_order">order</code></td>
<td>
<p>MixAR order, vector of length the number of components.</p>
</td></tr>
<tr><td><code id="em_rinit_+3A_partempl">partempl</code></td>
<td>

<p>parameter template, a list containing one element for each mixture
component, see <code><a href="#topic+randomArCoefficients">randomArCoefficients</a></code>.
</p>
</td></tr>
<tr><td><code id="em_rinit_+3A_etk">etk</code></td>
<td>
<p>MixAR component residuals, a matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>em_rinit</code> generates random MAR residuals, performs a non-distributional
E-step, and a Gaussian M-step.

</p>
<p><code>etk2tau</code> estimates <code>tau</code> from component residuals
only. Note that this is unlike <code><a href="#topic+em_tau">em_tau</a></code>, which also needs
the noise pdf's, as well as estimates of the mixture probabilities.
</p>
<p><code>em_rinit</code> uses <code>etk2tau</code> to start the EM algorithm.
</p>


<h3>Value</h3>

<p>for <code>em_rinit</code>, an object from class <code>"MixARGaussian"</code>
</p>
<p>for <code>etk2tau</code>, a matrix representing <code>tau</code> (i-th row
contains probabilities corresponding to the i-th observation) 
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='em_tau'>
Compute probabilities for the observations to belong to each of the components
</h2><span id='topic+em_tau'></span><span id='topic+em_tau_safe'></span>

<h3>Description</h3>

<p>Supporting function for EM algorithm. Update the conditional
probabilities of the components of the MixAR model
(for E-step of EM algorithm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>em_tau(stdetk, prob, scale, pdf = dnorm)

em_tau_safe(stdetk, prob, scale, pdf = dnorm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="em_tau_+3A_stdetk">stdetk</code></td>
<td>

<p>standardised component residuals, a <code>MixComp</code> object.
</p>
</td></tr>
<tr><td><code id="em_tau_+3A_prob">prob</code></td>
<td>

<p>current estimates of the probabilities of the components, a numeric
vector of length equal to the number of components in the model.
</p>
</td></tr>
<tr><td><code id="em_tau_+3A_scale">scale</code></td>
<td>

<p>scales (standard deviations) of the noise components, a numeric
vector of length equal to the number of components in the model.
</p>
</td></tr>
<tr><td><code id="em_tau_+3A_pdf">pdf</code></td>
<td>

<p>densities of the noise components.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>em_tau</code> and <code>em_tau_safe</code> compute the conditional
probabilities of the components of the MixAR model (for the E-step of
the EM algorithm). The two functions do the same computations but
<code>em_tau_safe</code>, in addition, protects agains <code>NaN</code>'s and
infinite values in argument <code>stdetk</code> or obtained during
computations.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='err'>
Calculate component specific error terms under MixAR model
</h2><span id='topic+err'></span>

<h3>Description</h3>

<p>Returns a matrix which columns correspond to the error terms. Each
column's row will assume value 0 if the observation was not &quot;assigned&quot;
to that component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>err(AR, mu, y, z, pk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="err_+3A_ar">AR</code></td>
<td>
<p>a <code>list</code> with autoregressive components.</p>
</td></tr>
<tr><td><code id="err_+3A_mu">mu</code></td>
<td>
<p>Component means.</p>
</td></tr>
<tr><td><code id="err_+3A_y">y</code></td>
<td>
<p>a time series (currently a numeric vector).</p>
</td></tr>
<tr><td><code id="err_+3A_z">z</code></td>
<td>

<p>a <code>matrix</code> which columns contain observations
&quot;assignment&quot;. Hence each row will contain one 1 and (g-1) 0's
</p>
</td></tr>
<tr><td><code id="err_+3A_pk">pk</code></td>
<td>
<p>autoregressive orders.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>e</code></td>
<td>

<p>a matrix which columns correspond to component specific &quot;residuals&quot;,
which are equal to 0 for observations not assigned to such
component.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is built for use within sampling functions.</p>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>

<hr>
<h2 id='err_k'>Utility function for MixAR</h2><span id='topic+err_k'></span>

<h3>Description</h3>

<p>Calculates residuals under a certain component of the mixture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>err_k(AR, mu, y, z, p, pk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="err_k_+3A_ar">AR</code></td>
<td>
<p>a <code>list</code> with autoregressive parameters.</p>
</td></tr>
<tr><td><code id="err_k_+3A_mu">mu</code></td>
<td>
<p>component means.</p>
</td></tr>
<tr><td><code id="err_k_+3A_y">y</code></td>
<td>
<p>a time series (currently a numeric vector).</p>
</td></tr>
<tr><td><code id="err_k_+3A_z">z</code></td>
<td>
<p>a vector of allocation to a specific component.</p>
</td></tr>
<tr><td><code id="err_k_+3A_p">p</code></td>
<td>
<p>maximum autoregressive order</p>
</td></tr>
<tr><td><code id="err_k_+3A_pk">pk</code></td>
<td>
<p>autoregressive order of the component.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>e</code></td>
<td>
<p>a vector containing component specific residuals.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is built as a utility function.</p>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>

<hr>
<h2 id='est_templ'>Create estimation templates from MixAR model objects</h2><span id='topic+est_templ'></span>

<h3>Description</h3>

<p>Create estimation templates from MixAR model objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_templ(model, shift = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_templ_+3A_model">model</code></td>
<td>
<p>a <code>"MixAR"</code> object.</p>
</td></tr>
<tr><td><code id="est_templ_+3A_shift">shift</code></td>
<td>
<p>logical, see Details.</p>
</td></tr>
<tr><td><code id="est_templ_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>model</code> is used as a template to specify values of
parameters and/or which parameters to estimate or fix. In general,
If a value of a parameter in <code>model</code> is <code>NA</code>, then it is to
be estimated. Otherwise the parameter is taken as is.
</p>
<p>The current implementation is incomplete. In particular, the AR
parameters are always designated for estimation.
</p>
<p>Argument <code>shift</code> can be used to overwrite some or values
component <code>shift</code> in <code>model</code>.  If <code>shift</code> has length
one, it is replicated to the number of MixAR components. If
<code>shift[k]</code> is <code>TRUE</code>, then the shift coefficient for the
k-th component is set to <code>NA</code> to request its
estimation. Otherwise, the value of the shift for the k-th component
in <code>model</code> is taken.
</p>
<p>Argument <code>shift</code> has a default of <code>TRUE</code> which causes the
shift coefficients to be estimated irrespectively of their values in
model. 
</p>
<p><code>est_templ</code> returns a list with as many components as there are
MixAR components in the model. The k-th component of the list is itself a list
specifing which parameters of the i-th MixAR component to estimate or fix. 
</p>


<h3>Value</h3>

<p>a list, as described in Details. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleModels$WL_A
est_templ(exampleModels$WL_A)
est_templ(exampleModels$WL_A, shift = FALSE)

exampleModels$WL_I
est_templ(exampleModels$WL_I)
</code></pre>

<hr>
<h2 id='exampleModels'>
MixAR models for examples and testing
</h2><span id='topic+exampleModels'></span><span id='topic+moWLprob'></span><span id='topic+moWLsigma'></span><span id='topic+moWLar'></span><span id='topic+moWL_I'></span><span id='topic+moWL_II'></span><span id='topic+moWL_A'></span><span id='topic+moWL_B'></span><span id='topic+moWL'></span><span id='topic+moWLgen'></span><span id='topic+moWLt3v'></span><span id='topic+moWLtf'></span><span id='topic+moT_A'></span><span id='topic+moT_B'></span><span id='topic+moT_B2'></span><span id='topic+moT_B3'></span><span id='topic+moT_C1'></span><span id='topic+moT_C2'></span><span id='topic+moT_C3'></span>

<h3>Description</h3>

<p>MixAR models for examples and testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleModels
</code></pre>


<h3>Details</h3>

<p>Coefficients of models from the examples in
Wong and Li (2000). Variations on these with different
noise distributions are used throughout the examples in <span class="pkg">mixAR</span>.
The models are from classes inheriting from class <code>"MixAR"</code>.
</p>
<p><code>exampleModels</code> is a list with the following components:
</p>




















<table>
<tr>
 <td style="text-align: left;">
  WL_ibm <br />WL_A <br />WL_B <br />WL_I <br />WL_II <br />WL_ibm_gen <br />WL_ibm_t3v <br />WL_ibm_tf <br />WL_At <br />WL_Bt_1 <br />WL_Bt_2 <br />WL_Bt_3 <br />WL_Ct_1 <br />WL_Ct_2 <br />WL_Ct_3
  </td>
</tr>

</table>

<p>Each component is a MixAR model, i.e. an object inheriting from class
<code>"MixAR"</code>. 
</p>


<h3>Source</h3>

<p>Wong CS, Li WK (2000).
&ldquo;On a mixture autoregressive model.&rdquo;
<em>J. R. Stat. Soc., Ser. B, Stat. Methodol. </em>, <b>62</b>(1), 95-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use these instead of moWL, moWL_A, moWL_B, etc.
exampleModels$WL_ibm

exampleModels$WL_A
exampleModels$WL_B
# what is the difference between A and B?
show_diff(exampleModels$WL_A, exampleModels$WL_B)

exampleModels$WL_I
exampleModels$WL_II
#show_diff(exampleModels$WL_I, exampleModels$WL_II)

exampleModels$WL_ibm_gen
exampleModels$WL_ibm_t3v
exampleModels$WL_ibm_tf
#show_diff(exampleModels$WL_ibm_gen, exampleModels$WL_ibm_t3v)

exampleModels$WL_At

exampleModels$WL_Bt_1
exampleModels$WL_Bt_2
exampleModels$WL_Bt_3
## what is different between Bt_2 and Bt_1? (df of component 2)
show_diff(exampleModels$WL_Bt_2, exampleModels$WL_Bt_1)

exampleModels$WL_Ct_1
exampleModels$WL_Ct_2
exampleModels$WL_Ct_3

## The models were created with something like:
moWLprob &lt;- c(0.5439,0.4176,0.0385)
moWLsigma &lt;- c(4.8227,6.0082,18.1716)
moWLar &lt;- list(c(0.6792,0.3208), c(1.6711,-0.6711), 1)

moWL &lt;- new("MixARGaussian", prob = moWLprob, scale = moWLsigma,
            arcoef = moWLar)
moWLgen &lt;- new("MixARgen", prob = moWLprob, scale = moWLsigma,
               arcoef = moWLar, dist = list(dist_norm))
## clean up a bit
rm(moWLprob, moWLsigma, moWLar, moWL, moWLgen)
</code></pre>

<hr>
<h2 id='fit_mixAR-methods'>
Fit mixture autoregressive models
</h2><span id='topic+fit_mixAR'></span><span id='topic+fit_mixAR-methods'></span><span id='topic+fit_mixAR+2CANY+2CANY+2CANY-method'></span><span id='topic+fit_mixAR+2CANY+2CMixAR+2Clist-method'></span><span id='topic+fit_mixAR+2CANY+2CMixAR+2Cmissing-method'></span><span id='topic+fit_mixAR+2CANY+2CMixAR+2CMixAR-method'></span><span id='topic+fit_mixAR+2CANY+2CMixAR+2Cnumeric-method'></span><span id='topic+fit_mixAR+2CANY+2CMixARGaussian+2CMixAR-method'></span><span id='topic+fit_mixAR+2CANY+2Cnumeric+2Cmissing-method'></span><span id='topic+fit_mixAR+2CANY+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Estimate a MixAR model for a time series. This is a generic function.
The methods defined in package <span class="pkg">mixAR</span> are described here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mixAR(x, model, init, fix, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mixAR-methods_+3A_x">x</code></td>
<td>
<p>a time series.</p>
</td></tr>
<tr><td><code id="fit_mixAR-methods_+3A_model">model</code></td>
<td>
<p>model, object inheriting from MixAR class.</p>
</td></tr>
<tr><td><code id="fit_mixAR-methods_+3A_init">init</code></td>
<td>
<p>what initializations to do, see Details.</p>
</td></tr>
<tr><td><code id="fit_mixAR-methods_+3A_fix">fix</code></td>
<td>
<p>which parameters to fix, see Details.</p>
</td></tr>
<tr><td><code id="fit_mixAR-methods_+3A_...">...</code></td>
<td>
<p>additional arguments for the methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method dispatch is done on the first three arguments:
<code>x</code>, <code>model</code> and <code>init</code>.
</p>
<p><code>model</code> specifies the model to fit. If <code>model</code> inherits from
<code>"MixAR"</code>, it is used as a template.  If <code>init</code> is missing,
the parameters of <code>model</code> are also used as initial values. 
<code>model</code> can also be a numeric vector specifying the order of a
MixAR model with Gaussian components. 
</p>
<p>Argument <code>init</code> can be used to give initial values in  variety of
ways. If it is a MixAR object it doesn't need to be of the same class
as <code>model</code>, to allow using as initial values common parameters
of different MixAR models. A positive integer value of <code>init</code>
asks to run the fitting procedure <code>init</code> times, each time
generating random initial values.  
</p>
<p><code>init</code> can also be a list. In that case, each component of the
list should itself be an acceptable value for <code>init</code> and the
fitting procedure is run with each component of <code>init</code>.
</p>
<p>Argument <code>fix</code> can be given in a number of ways. Note however
that currently there is no method dispatch on it.
</p>
<p>Currently the default method for <code>fit_mixAR</code> just throws error,
since there seems no suitable default task to do. 
</p>
<p>See individual methods for further details.
</p>



<h3>Value</h3>

<p>a MixAR model or a list of MixAR models, depending on the arguments.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", model = "ANY", init = "ANY")</code></dt><dd>
<p>The default method throws error.
</p>
</dd>
<dt><code>signature(x = "ANY", model = "MixAR", init = "missing")</code></dt><dd>
<p>This is equivalent to setting <code>init = model</code>.
</p>
</dd>
<dt><code>signature(x = "ANY", model = "MixAR", init = "MixAR")</code></dt><dd>
<p><code>model</code> is a template for the result, <code>init</code> specifies
initial values for the parameters. In principle, <code>model</code> and
<code>init</code> may be from different classes, to allow for example
using AR coefficients from a Gaussian fit for other distributions.
</p>


</dd>
<dt><code>signature(x = "ANY", model = "MixAR", init = "numeric")</code></dt><dd>
<p><code>init</code> must be a single positive integer here. The model is
fitted <code>init</code> times, each time starting with a new set of
randomly generated initial values. If <code>select</code> is <code>TRUE</code>,
the default, the model with the largest likelihood is returned,
otherwise a list containing the <code>init</code> fitted models is
returned.
</p>
</dd>
<dt><code>signature(x = "ANY", model = "MixAR", init = "list")</code></dt><dd>
<p>Each element of the list <code>init</code> should be an acceptable value
for <code>init</code>. The model is fitted with the initial value  set to each
element of <code>init</code>. A list containing the fitted models is
returned. 
</p>
</dd>
<dt><code>signature(x = "ANY", model = "MixARGaussian", init = "MixAR")</code></dt><dd>

</dd>
<dt><code>signature(x = "ANY", model = "numeric", init = "missing")</code></dt><dd>
<p>This is equivalent to setting <code>init = 1</code>.
</p>
</dd>
<dt><code>signature(x = "ANY", model = "numeric", init = "numeric")</code></dt><dd>
<p>A numeric <code>model</code> should be a vector of non-negative integers
specifying the order of the MixAR model. The distribution of the
components is assumed Gaussian.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## model coefficients from Wong&amp;Li (IBM fit)
prob  &lt;- exampleModels$WL_ibm@prob     # c(0.5439, 0.4176, 0.0385)
sigma &lt;- exampleModels$WL_ibm@scale    # c(4.8227, 6.0082, 18.1716)
ar    &lt;- exampleModels$WL_ibm@arcoef@a # list(c(0.6792, 0.3208), c(1.6711, -0.6711), 1)

## data(ibmclose, package = "fma")  # `ibmclose'

mot30 &lt;- new("MixARgen", prob = prob, scale = sigma, arcoef = ar,
             dist = distlist("stdt", c(30, 30, 30)))

mot20_30_40 &lt;- new("MixARgen", prob = prob, scale = sigma, arcoef = ar,
                   dist = distlist("stdt", c(20, 30, 40)))

mo_t20_t30_norm &lt;- new("MixARgen", prob = prob, scale = sigma, arcoef = ar,
                   dist = distlist(c("stdt", "stdt", "stdnorm"), c(20, 30)))

## Gaussian components
fi0 &lt;- fit_mixAR(fma::ibmclose, exampleModels$WL_ibm, fix = "shift", crit = 1e-4)
fi0$model

if(FALSE){ # don't run on CRAN to save a couple of seconds
## remove minniter/maxniter below for realistic results.

## std-t components
fi1 &lt;- fit_mixAR(fma::ibmclose, mot30, fix = "shift",
                 crit = 1e-4, minniter = 1, maxniter = 3)
fi1$model

## 1st and 2nd components std-t, 3rd Gaussian
fi2 &lt;- fit_mixAR(fma::ibmclose, mo_t20_t30_norm, fix = "shift",
                 crit = 1e-4, minniter = 1, maxniter = 3)
fi2$model
}
</code></pre>

<hr>
<h2 id='fit_mixARreg-methods'>
Fit time series regression models with mixture autoregressive residuals
</h2><span id='topic+mixARreg'></span><span id='topic+fit_mixARreg'></span><span id='topic+fit_mixARreg-methods'></span><span id='topic+fit_mixARreg+2CANY+2Cdata.frame+2CMixAR+2Cmissing-method'></span><span id='topic+fit_mixARreg+2CANY+2Cmatrix+2CMixAR+2Cmissing-method'></span><span id='topic+fit_mixARreg+2CANY+2Cdata.frame+2Cmissing+2Clist-method'></span><span id='topic+fit_mixARreg+2CANY+2Cmatrix+2Cmissing+2Clist-method'></span><span id='topic+fit_mixARreg+2CANY+2Cnumeric+2CMixAR+2Cmissing-method'></span><span id='topic+fit_mixARreg+2CANY+2Cnumeric+2Cmissing+2Clist-method'></span><span id='topic+fit_mixARreg+2CANY+2CANY+2CMixAR+2Clist-method'></span><span id='topic+fit_mixARreg+2CANY+2CANY+2Cmissing+2Clist-method'></span>

<h3>Description</h3>

<p>Estimate a linear regression model for time series with residuals
from a mixture autoregressive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mixARreg(x, y, mixARmodel, EMinit, ...)

mixARreg(x, y, mixARmodel, tol = 1e-6, niter = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mixARreg-methods_+3A_x">x</code></td>
<td>
<p>the response time series (currently a numeric vector).</p>
</td></tr>
<tr><td><code id="fit_mixARreg-methods_+3A_y">y</code></td>
<td>

<p><code>data.frame</code>, <code>matrix</code> or <code>numeric</code> vector. If either
of the first two, each column must contain one covariate (currently
numeric). A check for matching lengths between <code>x</code> and <code>y</code>
is done. 
</p>
</td></tr>
<tr><td><code id="fit_mixARreg-methods_+3A_mixarmodel">mixARmodel</code></td>
<td>

<p>An object inheriting from class <code>"MixAR"</code>, giving initial
values for EM-estimation of mixture autoregressive
parameters. Currenlty only <code>"MixARGaussian"</code> is supported.
</p>
</td></tr>
<tr><td><code id="fit_mixARreg-methods_+3A_eminit">EMinit</code></td>
<td>

<p>starting values for EM estimation of MixAR parameters. If present,
must be a named list, containing at least <code>prob</code> and
<code>scale</code> as numeric vectors, and a list for <code>arcoef</code>.
</p>
</td></tr>
<tr><td><code id="fit_mixARreg-methods_+3A_tol">tol</code></td>
<td>

<p>threshold for convergence criterion.
</p>
</td></tr>
<tr><td><code id="fit_mixARreg-methods_+3A_...">...</code></td>
<td>
<p>passed on to <code>MixARreg</code>.</p>
</td></tr>
<tr><td><code id="fit_mixARreg-methods_+3A_niter">niter</code></td>
<td>
<p>maximal number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fit_mixARreg</code> is a generic function. 
Currently there is no default method for <code>fit_mixARreg</code>.
Arguments <code>y</code>, <code>mixARmodel</code>, <code>EMinit</code> can be given in a
number of ways, see individual methods for details. 
</p>
<p>Argument <code>mixARmodel</code> gives the details of the the MixAR part of
the model and initial values for the parameters. For
<code>fit_mixARreg</code> this can alternatively be done with a list using 
argument <code>EMinit</code>. Currently, at least one of the two must be
supplied, and if both are present <code>EMinit</code> is ignored.
</p>
<p><code>mixARreg</code> performs a two-step estimation of a linear regression
model with mixture autoregressive residuals.  It is the workhorse for
<code>fit_mixARreg</code> which calls it to do the computations.
</p>


<h3>Value</h3>

  
<table>
<tr><td><code>reg</code></td>
<td>
<p>The summary output of the regression part of the model.</p>
</td></tr>
<tr><td><code>mixARmodel</code></td>
<td>

<p>Estimates of the mixture autoregressive part of the model. 
</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>The number of iterations until convergence.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", y = "data.frame", mixARmodel =
	"MixAR", EMinit = "missing")
    </code></dt><dd><p>Covariates <code>y</code> are supplied as <code>data.frame</code>: each column
corresponds to one covariate. Initialization of <code>MixAR</code> paramters is
done using input <code>mixARmodel</code></p>
</dd>
<dt><code>signature(x = "ANY", y = "matrix",
        mixARmodel = "MixAR", EMinit = "missing")</code>
</dt><dd><p>Covariates <code>y</code> are supplied as <code>matrix</code>: each column
corresponds to one covariate. Initialization of <code>MixAR</code> paramters is
done using input <code>mixARmodel</code></p>
</dd>
<dt><code>signature(x = "ANY", y = "numeric", mixARmodel = "MixAR", EMinit = "missing")</code>
</dt><dd><p>Covariates <code>y</code> is supplied as <code>numeric</code>: this method handles the
simple regression case with a single covairate. 
Initialization of <code>MixAR</code> paramters is done using input <code>mixARmodel</code></p>
</dd>

<dt><code>signature(x = "ANY", y = "ANY", mixARmodel = "missing", EMinit = "list")</code></dt><dd>
<p><code>EMinit</code> must be a named list (see 'Arguments').

</p>
</dd>
<dt><code>signature(x = "ANY", y = "ANY", mixARmodel = "MixAR", EMinit = "list")</code></dt><dd>
<p>When both <code>mixARmodel</code> and <code>EMinit</code> are supplied, the second is ignored.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Estimation is done using the function <code>mixARreg</code> within each
method.
</p>


<h3>Author(s)</h3>

<p>Davide Ravagli and Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_mixAR">fit_mixAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate covariates
set.seed(1234)
n &lt;- 50 # for CRAN
y &lt;- data.frame(rnorm(n, 7, 1), rt(n, 3), rnorm(n, 3, 2))

## Build mixAR part
model &lt;- new("MixARGaussian", 
             prob   = exampleModels$WL_At@prob,      # c(0.5, 0.5)
             scale  = exampleModels$WL_At@scale,     # c(1, 2)        
             arcoef = exampleModels$WL_At@arcoef@a ) # list(-0.5, 1.1)

## Simulate from MixAR part
u &lt;- mixAR_sim(model, n, 0)

x &lt;- 10 + y[, 1] + 3 * y[, 2] + 2 * y[, 3] + u

## Fit model

## Using MixARGaussian
fit_mixARreg(x = x, y = y, mixARmodel = model, niter = 3)

## Using EMinit
EMinit &lt;- list(prob = exampleModels$WL_At@prob, scale = exampleModels$WL_At@scale,
               arcoef = exampleModels$WL_At@arcoef@a)
fit_mixARreg(x = x, y = y, EMinit = EMinit, niter = 3)
</code></pre>

<hr>
<h2 id='fit_mixVAR-methods'>Fit mixture vector autoregressive models</h2><span id='topic+fit_mixVAR'></span><span id='topic+fit_mixVAR-methods'></span><span id='topic+fit_mixVAR+2CANY+2CMixVAR-method'></span><span id='topic+fit_mixVAR+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Estimate a MixVAR model for a multivariate time series. This is a
generic function.  The methods defined in package <span class="pkg">MixAR</span> are
described here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mixVAR(x, model, fix, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mixVAR-methods_+3A_x">x</code></td>
<td>

<p>a multivariate time series (currently a numeric matrix).
</p>
</td></tr>
<tr><td><code id="fit_mixVAR-methods_+3A_model">model</code></td>
<td>

<p>model, object inheriting from MixVAR class.
</p>
</td></tr>
<tr><td><code id="fit_mixVAR-methods_+3A_fix">fix</code></td>
<td>
<p>if TRUE, fix the shift parameters.</p>
</td></tr>
<tr><td><code id="fit_mixVAR-methods_+3A_...">...</code></td>
<td>

<p>additional arguments for the methods (not currently used).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model</code> specifies the model to fit. If <code>model</code> inherits from
<code>"MixVAR"</code>, it is used as a template.  Estimation is done via
EM-Algorithm, using the function <code>mixVARfit</code>.
</p>
<p>Currently the default method for <code>fit_mixAR</code> just throws error,
since there seems no suitable default task to do. 
</p>




<h3>Value</h3>

<p>a MixVAR model.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", model = "MixVAR")</code></dt><dd>

</dd>
<dt><code>signature(x = "ANY", model = "ANY")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mixVARfit">mixVARfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AR &lt;- list()
AR[[1]] &lt;- array(c(0.5, -0.3, -0.6, 0, 0, 0.5, 0.4, 0.5, -0.3), dim = c(3, 3, 1))
AR[[2]] &lt;- array(c(-0.5, 0.3, 0, 1, 0, -0.5, -0.4, -0.2, 0.5), dim = c(3, 3, 1))

prob &lt;- c(0.75, 0.25)
shift &lt;- cbind(c(0, 0, 0), c(0, 0, 0))

Sigma1 &lt;- cbind(c(1, 0.5, -0.4), c(0.5, 2, 0.8), c(-0.4, 0.8, 4))
Sigma2 &lt;- cbind(c(1, 0.2, 0), c(0.2,  2, -0.15), c(0, -0.15, 4))
Sigma &lt;- array(c(Sigma1, Sigma2), dim = c(3, 3, 2))

m &lt;- new("MixVARGaussian", prob = prob, vcov = Sigma, arcoef = AR, shift = shift)

set.seed(1234)
y &lt;- mixVAR_sim(m, n = 100, init = matrix(0, ncol = 3), nskip = 50, flag = FALSE)

fit_mixVAR(y, m, tol = 1e-3)
mixVARfit(y, m, tol = 1e-3)
</code></pre>

<hr>
<h2 id='fnoise'>Generator functions for noise distributions</h2><span id='topic+fnoise'></span><span id='topic+fdist_stdnorm'></span><span id='topic+fdist_stdt'></span><span id='topic+fn_stdt'></span><span id='topic+b_show'></span><span id='topic+distlist'></span><span id='topic+ed_nparam'></span><span id='topic+ed_parse'></span><span id='topic+ed_skeleton'></span><span id='topic+ed_src'></span><span id='topic+ed_stdnorm'></span><span id='topic+ed_stdt'></span><span id='topic+ed_stdt0'></span><span id='topic+ed_stdt1'></span><span id='topic+ft_stdt'></span>

<h3>Description</h3>

<p>These functions and objects are mostly internal and should not be
needed for routine use. Generate noise distribution, currently
standard normal and standardised t-distributions. These functions can
be used as templates for new distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdist_stdnorm()

fdist_stdt(df, fixed = TRUE)

fn_stdt(df, fixed = TRUE)

b_show(x)

distlist(type, param, ncomp = NULL, fixed = FALSE, tr = NULL, ...)

ed_nparam

ed_parse(s)

ed_skeleton(df, fixed = FALSE, n = length(df), tr = NULL)

ed_src

ed_stdnorm

ed_stdt

ed_stdt0

ed_stdt1

ft_stdt
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnoise_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="fnoise_+3A_fixed">fixed</code></td>
<td>
<p>if TRUE, the parameters are fixed, otherwise they are
variable, see Details.</p>
</td></tr>
<tr><td><code id="fnoise_+3A_x">x</code></td>
<td>
<p>a fitted object.</p>
</td></tr>
<tr><td><code id="fnoise_+3A_type">type</code></td>
<td>
<p>list of distributions.</p>
</td></tr>
<tr><td><code id="fnoise_+3A_param">param</code></td>
<td>
<p>parameters.</p>
</td></tr>
<tr><td><code id="fnoise_+3A_ncomp">ncomp</code></td>
<td>
<p>number of components.</p>
</td></tr>
<tr><td><code id="fnoise_+3A_tr">tr</code></td>
<td>
<p>transformation.</p>
</td></tr>
<tr><td><code id="fnoise_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="fnoise_+3A_s">s</code></td>
<td>
<p>named vector.</p>
</td></tr>
<tr><td><code id="fnoise_+3A_n">n</code></td>
<td>
<p>number of different degrees of freedom.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>fixed</code> is TRUE, estimation functions assume that the
parameter(s) are fixed, otherwise they estimate it. The support is
incomplete, see below.
</p>
<p><code>fdist_stdnorm</code> is for the standard normal distribution. For
example <code>dist_norm</code> is generated by it.
</p>
<p><code>fdist_stdt</code> is for the t-distribution with <code>df</code> degrees of
freedom.
</p>
<p><code>fn_stdt</code> is also for the t-distribution but the degrees of
freedom, <code>df</code>, may be a vector. The value is a list of
distributions. Although the list can be obtained by repeated calls of
<code>fdist_stdt</code> 
</p>
<p>The support is incomplete.  In particular, if parameter <code>fixed</code>
is TRUE, changes to the parameter(s) should probably not be allowed
(this can be achieved by simply dropping the corresponding function
from the list). However, a thorough rethinking is necessary, as I
introduced it on the fly while developing estimation functions and
forbidding changes may necessitate changes in the code. Changes are
useful for estimation for convenience but also to avoid recreating the
whole distributions again and again.
</p>
<p>However, there is a major drawback, which in the final version needs
to be addressed satisfactorily. Since parameters are held in local
environments, changes to the parameters are reflected in copies of the
objects. For example, an estimation function (or the user) may call
another function with a model containing an object generated by the
above functions and assign the result to a new object. However if the
parameters of the noise distribution are changed in the process this
will be reflected in the original model.
</p>
<p>Note that the above effect is valid only if an object generated by the
above functions is reused. Objects created by different calls have
different environments, so the problem does not arise for them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stdt3 &lt;- fdist_stdt(3)
stdt3v &lt;- fdist_stdt(3, fixed = FALSE)
fn_stdt(c(20, 30, 40), fixed = FALSE)

mo_tf &lt;- new("MixARgen", prob = exampleModels$WL_ibm@prob,
             scale = exampleModels$WL_ibm@scale, arcoef = exampleModels$WL_ibm@arcoef@a,
             dist = list(generator = function(par)
                 fn_stdt(par, fixed = FALSE), param = c(20, 30, 40)))
mo_tf
str(mo_tf)

noise_dist(mo_tf, "pdf")
parameters(mo_tf)
parameters(mo_tf, names = TRUE)
get_edist(mo_tf)
noise_params(mo_tf)
</code></pre>

<hr>
<h2 id='get_edist-methods'> Methods for function <code>get_edist</code> in package <span class="pkg">mixAR</span> </h2><span id='topic+get_edist-methods'></span><span id='topic+get_edist+2CMixAR-method'></span><span id='topic+get_edist+2CMixARGaussian-method'></span><span id='topic+get_edist+2CMixARgen-method'></span>

<h3>Description</h3>

<p>Methods for function <code>get_edist</code> in package <span class="pkg">mixAR</span>
</p>


<h3>Methods</h3>

<p><code>get_edist</code> gives the error (or noise) distribution of MixAR
objects.
</p>
<p>Currently the distribution is returned as a list of functions. The
list contains one element for each component. If the error
distributions of all components are the same, then the list may
contain a single element representing the common error distribution.
</p>
<p>Note that the distribution is not necessarily stored in slot
<code>dist</code> in this format, see the description of this slot in class
<code>"<a href="#topic+MixARgen-class">MixARgen</a>"</code>.
Such a slot may even not exist if the distribution of the error
components is fixed as is the case for class <code>MixARGaussian</code>.
</p>
<p>Each subclass of <code>MixAR</code> needs to define a method for
<code>get_edist</code>.
</p>

<dl>
<dt><code>signature(model = "MixAR")</code></dt><dd>
<p>Issue an error message and stop.
</p>
<p>This method is invoked for subclasses of <code>MixAR</code> that have
not defined their own method for <code>get_edist</code>. This is an
error.
</p>
</dd>
<dt><code>signature(model = "MixARGaussian")</code></dt><dd>
<p>Return an object representing the fact that the error
distributions of the components of <code>MixARGaussian</code> objects
are standard normal.
</p>
</dd>
<dt><code>signature(model = "MixARgen")</code></dt><dd>
<p>Return an object representing the error distributions of the
components of <code>MixARgen</code> objects. The distributions are not
necessarilly the same for such objects.
</p>
</dd>
</dl>

<hr>
<h2 id='initialize-methods'> Methods for function <code>initialize</code> in package <span class="pkg">mixAR</span> </h2><span id='topic+initialize-methods'></span><span id='topic+initialize+2CMixAR-method'></span><span id='topic+initialize+2CraggedCoef-method'></span><span id='topic+initialize+2CraggedCoefS-method'></span><span id='topic+initialize+2CMixARgen-method'></span><span id='topic+initialize+2CraggedCoefV-method'></span><span id='topic+initialize+2CMixVAR-method'></span>

<h3>Description</h3>

<p>Methods for function <code>initialize</code> in package <span class="pkg">mixAR</span>.
</p>


<h3>Methods</h3>

<p>These methods are for internal use by the user-level function
<code>new()</code> to create objects from the corresponding classes.  The
creation of objects from a class and examples can be found in the
description of the corresponding class.
</p>

<dl>
<dt><code>signature(.Object = "MixAR")</code></dt><dd>
<p>Objects from class <code>MixAR</code> cannot be created since it is virtual.
This method is called by initialisation methods of non-virtual
subclasses of <code>MixAR</code> to set up its slots.
</p>
</dd>
<dt><code>signature(.Object = "raggedCoef")</code></dt><dd>
<p>Creates objects from class <code>"<a href="#topic+raggedCoef-class">raggedCoef</a>"</code>.
</p>
</dd>
<dt><code>signature(.Object = "MixARgen")</code></dt><dd>
<p>Creates objects from class <code>MixARgen</code>.

</p>
</dd></dl>

<hr>
<h2 id='inner'>
Generalised inner product and methods for class <code>"MixComp"</code>
</h2><span id='topic+inner'></span><span id='topic+inner-methods'></span><span id='topic+inner+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+inner+2CMixComp+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+inner+2CMixComp+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic+inner+2Cnumeric+2CMixComp+2Cmissing+2Cmissing-method'></span><span id='topic+inner+2CMixComp+2Cnumeric+2CANY+2CANY-method'></span><span id='topic+inner+2CMixComp+2Cnumeric+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generalised inner product and methods for class MixComp. The methods
for MixComp provide for very convenient computing with MixAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner(x, y, star = "*", plus = .mplus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner_+3A_x">x</code></td>
<td>
<p>the first argument.</p>
</td></tr>
<tr><td><code id="inner_+3A_y">y</code></td>
<td>
<p>the second argument.</p>
</td></tr>
<tr><td><code id="inner_+3A_star">star</code></td>
<td>

<p>function to apply to pairs of elements from <code>x</code> and <code>y</code>,
default is multiplication, as for the usual inner product.
</p>
</td></tr>
<tr><td><code id="inner_+3A_plus">plus</code></td>
<td>

<p>function to apply to combine the results from the pairs,
default  is addition, as for the usual inner product.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inner</code> computes a generalised inner product <code>x . y</code>, where
multiplication and summation can be replaced by other functions.
</p>
<p>The default method of <code>inner</code> applies <code>star</code> to the
corresponding pairs of elements and combines them with <code>plus</code>.
There is no recycling, if <code>x</code> and <code>y</code> have different
lengths, an error is raised.  The elements of <code>x</code> and <code>y</code>
are accessed with &quot;[[&quot;. <code>plus</code> should be an <code>n</code>-ary
operation.
</p>


<h3>Value</h3>

<p>the inner product, the type of the result depends on the arguments
</p>


<h3>Methods</h3>







<p>Methods for inner product between a <code>"MixComp"</code> object and a
vector are similar to a product between a matrix and a vector but
comply with the conventions of class <code>"MixComp"</code>. For this reason
they are described in the help page for class
<code>"<a href="#topic+MixComp-class">MixComp</a>"</code>, along with methods for other functions
and operators applied to <code>"MixComp"</code> objects.
</p>

<dl>
<dt><code>signature(x = "ANY", y = "ANY", star = "ANY", plus = "ANY")</code></dt><dd>
<p>This is the default method, see section Details.
</p>
</dd>
<dt><code>signature(x = "MixComp", y = "missing", star = "missing", plus = "missing")</code></dt><dd>
<p>see <code>"<a href="#topic+MixComp-class">MixComp</a>"</code>.
</p>
</dd>
<dt><code>signature(x = "MixComp", y = "numeric", star = "missing", plus = "missing")</code></dt><dd>
<p>see <code>"<a href="#topic+MixComp-class">MixComp</a>"</code>.
</p>
</dd>
<dt><code>signature(x = "numeric", y = "MixComp", star = "missing", plus = "missing")</code></dt><dd>
<p>see <code>"<a href="#topic+MixComp-class">MixComp</a>"</code>.
</p>
</dd>
<dt><code>signature(x = "MixComp", y = "numeric", star = "ANY", plus = "ANY")</code></dt><dd>
<p>see <code>"<a href="#topic+MixComp-class">MixComp</a>"</code>.

</p>
</dd>
<dt><code>signature(x = "MixComp", y = "numeric", star = "ANY", plus = "missing")</code></dt><dd>
<p>see <code>"<a href="#topic+MixComp-class">MixComp</a>"</code>.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>"<a href="#topic+MixComp-class">MixComp</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inner(1:3, 2:4) # [1] 20
class(inner(1:3, 2:4)) # [1] "integer"
## compare to:
1:3 %*% 2:4        # 20, but (1,1)-matrix
class(1:3 %*% 2:4) # matrix
</code></pre>

<hr>
<h2 id='isStable'>Check if a MixAR model is stable</h2><span id='topic+isStable'></span>

<h3>Description</h3>

<p>Checks if a MixAR model is stable. This is also the second
order stationarity condition.</p>


<h3>Usage</h3>

<pre><code class='language-R'>isStable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isStable_+3A_x">x</code></td>
<td>
<p>the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If each component of a MixAR model corresponds to a stable
autoregression model, then the MixAR model is also stable. However,
the MixAR model may be stable also when some of its components
correspond to integrated or explosive AR models, see the references.
</p>


<h3>Value</h3>

<p>True if the model is stable (second order stationary), FALSE otherwise.
</p>


<h3>References</h3>

<p>Boshnakov GN (2011).
&ldquo;On First and Second Order Stationarity of Random Coefficient Models.&rdquo;
<em>Linear Algebra Appl.</em>, <b>434</b>(2), 415&ndash;423.
<a href="https://doi.org/10.1016/j.laa.2010.09.023">doi:10.1016/j.laa.2010.09.023</a>.
</p>
<p>Wong CS, Li WK (2000).
&ldquo;On a mixture autoregressive model.&rdquo;
<em>J. R. Stat. Soc., Ser. B, Stat. Methodol. </em>, <b>62</b>(1), 95-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isStable(exampleModels$WL_I)
isStable(exampleModels$WL_II)
</code></pre>

<hr>
<h2 id='label_switch'>A posteriori relabelling of a Markov chain</h2><span id='topic+label_switch'></span>

<h3>Description</h3>

<p>Takes the output from a MCMC simulation of parameters of a mixture,
and detects whether labels switch has occured while sampling, using
the method by Celeux (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_switch(x, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_switch_+3A_x">x</code></td>
<td>

<p>output from an MCMC sampling of a mixture. A <code>matrix</code>, each
column corresponds to one component of the mixture.
</p>
</td></tr>
<tr><td><code id="label_switch_+3A_m">m</code></td>
<td>

<p>the number of observations in the sample that will be used to
initialise the algorithm. <code>m~100</code> is recommended.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function can be directly executed when <code>x</code> is one of
<code>mix_weights</code>, <code>scale</code>, <code>precision</code>, <code>shift</code> or
<code>mu</code> from <code>bayes_mixAR</code> output.  <code>ARcoeff</code> cannot be input
as it is, but element from the list may be used.
</p>


<h3>Value</h3>

<p>A list of 2:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The input matrix, with adjusted labels</p>
</td></tr>
<tr><td><code>true_perm</code></td>
<td>
<p>The &quot;true&quot; permutation at each iteration.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There is no absolute choice on what <code>x</code> should be to obtain the
&quot;true&quot; permutation at any given point. User is subject to make the
most suitable choice, given output of their MCMC.
</p>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>References</h3>

<p>Celeux G (2000).
<em>Bayesian Inference of Mixture: The Label Switching Problem.</em>.
Payne R., Green P. (eds) COMPSTAT. Physica, Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayes_mixAR">bayes_mixAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- new("MixARGaussian",
             prob   = exampleModels$WL_At@prob,      # c(0.5, 0.5)
             scale  = exampleModels$WL_At@scale,     # c(1, 2)        
             arcoef = exampleModels$WL_At@arcoef@a ) # list(-0.5, 1.1)

y &lt;- mixAR_sim(model, n = 300, init = rep(0, which.max(model@order)))

## just examples, use larger numbers in practice
nsim &lt;- 30   # 200
burnin &lt;- 10  # 100
x &lt;- bayes_mixAR(y, model, fix_shift = FALSE, tau = c(.15, .25),
              nsim = nsim, burnin = burnin)

label_switch(x$mix_weights, m = 5)
</code></pre>

<hr>
<h2 id='lastn'>
Extract the last n elements of a vector
</h2><span id='topic+lastn'></span>

<h3>Description</h3>

<p>Extract the last n elements of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lastn(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lastn_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="lastn_+3A_n">n</code></td>
<td>
<p>number of elements to keep, an integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I did not know about the function <code>tail()</code> when I did this one,
but the two functions are not completely equivalent (and <code>tail</code>
is generic).
</p>
<p>If <code>n</code> is equal to <code>length(x)</code>, <code>x</code> is returned as is.
If <code>n</code> is equal to zero or is negative, a length zero vector is
returned. 
</p>
<p>It is an error for <code>n</code> to be larger than <code>length(x)</code>.
</p>


<h3>Value</h3>

<p>a vector containing the last <code>n</code> elements of <code>x</code>,
see Details 
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="utils.html#topic+tail">tail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lastn(1:10, 3) # 8:10
lastn(letters, 5) # "v" "w" "x" "y" "z"
</code></pre>

<hr>
<h2 id='lik_params'>  Vector of parameters of a MixAR model </h2><span id='topic+lik_params'></span><span id='topic+lik_params-methods'></span><span id='topic+lik_params+2CMixAR-method'></span><span id='topic+lik_params+2CMixARgen-method'></span>

<h3>Description</h3>

<p>Give a numeric vector containing non-redundant parameters of a MixAR
model in a form suitable for use by optimisation routines.  The
methods defined in package <span class="pkg">mixAR</span> for this generic function are
described here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lik_params(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lik_params_+3A_model">model</code></td>
<td>
<p>a MixAR model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lik_params</code> gives the parameters of a MixAR model as a numeric
vector.
</p>
<p>This is a generic function.  Parameters common to all MixAR models are
arranged as described below. There are no other parameters when the error
distributions do not contain parameters of their own.  Methods for
sub-classes with additional parameters should append them after the
common parameters.
</p>
<p>If <code class="reqn">k</code> is the number of components and <code class="reqn">\pi_i</code> is the
probability associated with the <code class="reqn">i</code>th component, then the
parameters are put in a vector as follows:
</p>

<ol>
<li>
<p>component probabilities, <code class="reqn">\pi_1,\ldots,\pi_{k-1}</code>,
(note: <code class="reqn">\pi_{k}</code> is not included)

</p>
</li>
<li>
<p>scales, <code class="reqn">\sigma_1,\ldots,\sigma_{k}</code>,

</p>
</li>
<li>
<p>shifts, <code class="reqn">\mu_1,\ldots,\mu_{k}</code>,

</p>
</li>
<li>
<p>AR coefficients of the 1st component,

</p>
</li>
<li>
<p>AR coefficients of the 2nd component,

</p>
</li>
<li>
<p>...

</p>
</li>
<li>
<p>AR coefficients of the <code class="reqn">k</code>th component.

</p>
</li></ol>



<h3>Value</h3>

<p>A numeric vector containing all parameters except the probability
associated with the last component.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARgen")</code></dt><dd>
</dd>
</dl>


<h3>Note</h3>

<p>The probability associated with the <code class="reqn">k</code>th component is omitted
as it is redundant. This makes it possible to try unconstrained
optimisation though it is not likely to give useful results since
there are other restrictions on the probabilities.
</p>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='lik_params_bounds'>
Give natural limits for parameters of a MixAR model.
</h2><span id='topic+lik_params_bounds'></span>

<h3>Description</h3>

<p>Give the natural lower and upper limits for the parameters of a MixAR
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lik_params_bounds(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lik_params_bounds_+3A_model">model</code></td>
<td>
<p>a <code>MixAR</code> model
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function gives crude limits:
the probabilities of the components are between 0 and 1,
the standard deviations of the components are non-negative.
For the other parameters the limits are
<code class="reqn">(-\infty,\infty)</code>.
</p>
<p>There are further restrictions, e.g.
the sum of the probabilities should be less than or equal to 1
and
the autoregression coefficients normally are restricted to a
particular region, but these are not indicated in the returned value.
</p>


<h3>Value</h3>

<p>A list with two components describing the limits on the parameters.
The order of the parameters is as the one returned by <code><a href="#topic+lik_params">lik_params</a></code>.
</p>
<table>
<tr><td><code>lower</code></td>
<td>
<p>lower limits, a numeric vector</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper limits, a numeric vector</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+lik_params">lik_params</a></code>
</p>

<hr>
<h2 id='make_fcond_lik-methods'>
Create a function for computation of conditional likelihood
</h2><span id='topic+make_fcond_lik'></span><span id='topic+make_fcond_lik-methods'></span><span id='topic+make_fcond_lik+2CMixAR+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Create a function for the computation of the conditional likelihood of
MixAR models for a given time series.  The methods for this generic
function defined in package <span class="pkg">mixAR</span> are described here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_fcond_lik(model, ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_fcond_lik-methods_+3A_model">model</code></td>
<td>
<p>a <code>MixAR</code> model</p>
</td></tr>
<tr><td><code id="make_fcond_lik-methods_+3A_ts">ts</code></td>
<td>
<p>the time series</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned value is a function, say <code>f(x)</code>, whose only argument
is a numeric vector of parameters with the arrangement of
<code><a href="#topic+lik_params">lik_params</a></code>, for which it computes the conditional
loglikelihood.
<code>f</code> can be given to optimisation routines.
</p>
<p>Argument <code>model</code> is an object inheriting from <code>MixAR</code> and
determines the structure of the MixAR model for the function,
<code>f</code>, that it creates. So, properties of the model,
such as number of components, AR order, and distribution of the noise
components are fixed when <code>f</code> is created and only the numeric
values of the parameters are changed by calls to it.
</p>


<h3>Value</h3>

<p>a function of one argument, the parameters of a MixAR model as a
numeric vector with the arrangement of <code><a href="#topic+lik_params">lik_params</a></code>, for which
it computes the conditional loglikelihood
</p>


<h3>Todo</h3>

<p>The environment of the returned function contains the time series and
the model object (initially argument <code>model</code>, later the model
used in the last call to <code>f</code>). So, these things can be extracted
from <code>f</code>.
Is it necessary to create convenience functions?
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR", ts = "numeric")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mix_pdf">mix_pdf</a></code>,
<code><a href="#topic+mix_cdf">mix_cdf</a></code>
</p>

<hr>
<h2 id='marg_loglik'>
Calculate marginal loglikelihood at high density points of a MAR model.
</h2><span id='topic+marg_loglik'></span>

<h3>Description</h3>

<p>The function implements the method by
Chib (1995) and
Chib and Jeliazkov (2001) for calculation of the
marginal loglikelihood of a mixture autoregressive model. It
automatically finds high density values for model parameters, and
evaluates the likelihood at such points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg_loglik(y, model, tau, nsim, prob_mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marg_loglik_+3A_y">y</code></td>
<td>
<p>a time series (currently a numeric vector).</p>
</td></tr>
<tr><td><code id="marg_loglik_+3A_model">model</code></td>
<td>

<p>object of formal class <code>MixAR</code>, containing initial values for
the parameters. Currently available for <code>MixARGaussian</code> objects
only.
</p>
</td></tr>
<tr><td><code id="marg_loglik_+3A_tau">tau</code></td>
<td>

<p>tuning parameter for Metropolis-Hasting move to update
autoregressive parameters.
</p>
</td></tr>
<tr><td><code id="marg_loglik_+3A_nsim">nsim</code></td>
<td>

<p>sample size on which to evaluate highest density values.
</p>
</td></tr>
<tr><td><code id="marg_loglik_+3A_prob_mod">prob_mod</code></td>
<td>

<p>this is currently the output from <code>Choose_pk</code>: the proportion
of times the &quot;best model&quot; was chosen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nsim</code> is the sample size on which to evaluate highest density
values for each set of parameters. For example, choosing
<code>nsim=1000</code> results in <code>1000*(g+3)</code> (1000 iterations for
each autoregressive component, plus 1000 for mean and scale parameters
and mixing weights).
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>marg_loglik</code></td>
<td>
<p>value of the marginal loglikelihood.</p>
</td></tr>
<tr><td><code>phi_hd</code></td>
<td>
<p>set of highest density autoregressive parameters.</p>
</td></tr>
<tr><td><code>prec_hd</code></td>
<td>
<p>set of highest density precision parameters.</p>
</td></tr>
<tr><td><code>mu_hd</code></td>
<td>
<p>set of highest density mean parameters.</p>
</td></tr>
<tr><td><code>weig_hd</code></td>
<td>
<p>set of highest density mixing weights.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>References</h3>

<p>Chib S (1995).
&ldquo;Marginal likelihood from the Gibbs output.&rdquo;
<em>J. A. Stat. Ass.</em>, <b>90</b>(432), 1313-1321.
</p>
<p>Chib S, Jeliazkov I (2001).
&ldquo;Marginal likelihood from the Metropolis-Hastings output.&rdquo;
<em>J. A. Stat. Ass.</em>, <b>96</b>(453), 270-281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob &lt;- c(0.5, 0.5)
sigma &lt;- c(1, 2)
arco &lt;- list(-0.5, 1)

model &lt;- new("MixARGaussian", prob = prob, scale = sigma, arcoef = arco)

set.seed(1234)
y &lt;- mixAR_sim(model, 250, rep(0, max(model@order)), nskip = 100)  # data

nsim &lt;- 10 # 50
marg_loglik(y, model, tau = c(.15, .25), nsim = nsim, 0.5)
</code></pre>

<hr>
<h2 id='mix_central_moment-methods'>Methods for mix_central_moment</h2><span id='topic+mix_central_moment-methods'></span><span id='topic+mix_central_moment+2CMixAR+2Cmissing+2Cmissing+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods for <code>mix_central_moment</code> in package &ldquo;pcts&rdquo;</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR", x = "missing", index = "missing", xcond = "numeric")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mix_location">mix_location</a></code> for examples and related functions
</p>

<hr>
<h2 id='mix_ek'>
Function and methods to compute component residuals for MixAR models
</h2><span id='topic+mix_ek'></span><span id='topic+mix_ek-methods'></span><span id='topic+mix_ek+2CMixAR+2Cnumeric+2Cmissing+2Cnumeric+2Clogical-method'></span><span id='topic+mix_ek+2CMixAR+2Cnumeric+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic+mix_ek+2CMixAR+2Cnumeric+2Cnumeric+2Cmissing+2Clogical-method'></span><span id='topic+mix_ek+2CMixAR+2Cnumeric+2Cnumeric+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Compute component residuals for MixAR models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix_ek(model, x, index, xcond, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mix_ek_+3A_model">model</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="mix_ek_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="mix_ek_+3A_index">index</code></td>
<td>

<p>a vector of positive integer specifying the indices for which to
compute the residuls, has a natural default.
</p>
</td></tr>
<tr><td><code id="mix_ek_+3A_xcond">xcond</code></td>
<td>

<p>the past values needed for the conditional distribution, a numeric
vector of length at least the maximal AR order of the components.
</p>
</td></tr>
<tr><td><code id="mix_ek_+3A_scale">scale</code></td>
<td>

<p>logical or missing, if <code>TRUE</code> standardise the residuals.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>mix_ek</code> computes component residuals from MixAR models.
</p>
<p>It is highly desirable to use it along with <code><a href="#topic+mix_hatk">mix_hatk</a></code> and
the underlying function <code><a href="#topic+mixFilter">mixFilter</a></code>. Doing this ensures
transparent code and easy maintenance. Also, more efficient
implementation can be introduced without changing other code.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR", x = "numeric", index = "missing",
	xcond = "numeric", scale = "logical")</code></dt><dd>

</dd>
<dt><code>signature(model = "MixAR", x = "numeric", index = "missing",
	xcond = "numeric", scale = "missing")</code></dt><dd>

</dd>
<dt><code>signature(model = "MixAR", x = "numeric", index = "numeric",
	xcond = "missing", scale = "logical")</code></dt><dd>

</dd>
<dt><code>signature(model = "MixAR", x = "numeric", index = "numeric",
	xcond = "missing", scale = "missing")</code></dt><dd>

</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixFilter">mixFilter</a></code> which is used by <code>mix_ek</code> to do the job,
<code><a href="#topic+MixComp-class">MixComp-class</a></code> for easy manipulation of the returned
object.
</p>
<p>class <code>"<a href="#topic+MixAR-class">MixAR</a>"</code>
</p>

<hr>
<h2 id='mix_hatk'>Compute component predictions for MixAR models</h2><span id='topic+mix_hatk'></span><span id='topic+mix_hatk-methods'></span><span id='topic+mix_hatk+2CMixAR+2Cnumeric+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Function and methods to compute component predictions for MixAR models

</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix_hatk(model, x, index, xcond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mix_hatk_+3A_model">model</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="mix_hatk_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="mix_hatk_+3A_index">index</code></td>
<td>

<p>a vector of positive integers specifying the indices for which to
compute the residuals, has a natural default.
</p>
</td></tr>
<tr><td><code id="mix_hatk_+3A_xcond">xcond</code></td>
<td>

<p>the past values needed for the conditional distribution, a numeric
vector of length at least the maximal AR order of the components.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR", x = "numeric", index = "numeric",
      xcond = "missing")</code></dt><dd>

</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p>class <code>"<a href="#topic+MixAR-class">MixAR</a>"</code>
</p>

<hr>
<h2 id='mix_location-methods'>Conditional mean of MixAR models</h2><span id='topic+mix_location-methods'></span><span id='topic+mix_location+2CMixAR+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+mix_location+2CMixAR+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_location+2CMixAR+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic+mix_location+2CMixAR+2Cnumeric+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Conditional mean of MixAR models.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR", x = "missing", index = "missing", xcond = "missing")</code></dt><dd>
<p>This method returns a function with argument <code>xcond</code>, suitable
for calls with many values of <code>xcond</code>.   
</p>
</dd>
<dt><code>signature(model = "MixAR", x = "missing", index = "missing", xcond = "numeric")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixAR", x = "numeric", index = "missing", xcond = "missing")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixAR", x = "numeric", index = "numeric", xcond = "missing")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mix_location">mix_location</a></code> for examples and related functions
</p>

<hr>
<h2 id='mix_moment'>Conditional moments of MixAR models</h2><span id='topic+mix_location'></span><span id='topic+mix_variance'></span><span id='topic+mix_central_moment'></span><span id='topic+mix_moment'></span><span id='topic+mix_kurtosis'></span><span id='topic+mix_ekurtosis'></span>

<h3>Description</h3>

<p>Conditional moments of MixAR models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix_location(model, x, index, xcond)
mix_variance(model, x, index, xcond)
mix_central_moment(model, x, index, xcond, k)
mix_moment(model, x, index, xcond, k)
mix_kurtosis(...)
mix_ekurtosis(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mix_moment_+3A_model">model</code></td>
<td>
<p>a MixAR object.</p>
</td></tr>
<tr><td><code id="mix_moment_+3A_x">x</code></td>
<td>
<p>a time series.</p>
</td></tr>
<tr><td><code id="mix_moment_+3A_index">index</code></td>
<td>

<p>a vector of indices in <code>x</code> for which to compute the requested
property.  If missing, the computation is done for all indices
greater than <code>max(model@order)</code>.
</p>
</td></tr>
<tr><td><code id="mix_moment_+3A_xcond">xcond</code></td>
<td>

<p>a time series, the point prediction is computed for the
first value after the end of the time series. Only the last
<code>max(model@order)</code> values in <code>xcond</code> are used.
</p>
</td></tr>
<tr><td><code id="mix_moment_+3A_k">k</code></td>
<td>
<p>a positive integer specifying the moment to compute.</p>
</td></tr>
<tr><td><code id="mix_moment_+3A_...">...</code></td>
<td>
<p>passed on to <code>mix_central_moment</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute conditional moments and related quantities.
</p>
<p><code>kurtosis</code> and <code>ekurtosis</code> compute conditional kurtosis and
excess kurtosis, respectively. Effectively, they have the same
parameters as <code>mix_central_moment</code>, since they pass <code>"..."</code>
to it along with <code>k = 4</code>. It is an error to supply argument
<code>k</code> to the kurtosis functions.
</p>


<h3>Value</h3>

<p>when called with one argument (<code>model</code>), a function with argument <code>xcond</code>;
otherwise if <code>xcond</code> is not missing, a single numeric value;
otherwise a vector of length <code>length(index)</code>.
</p>


<h3>Note</h3>


<p>I wrote the above description recently from reading six years old
code, it may need further verification. 
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (2009).
&ldquo;Analytic expressions for predictive distributions in mixture autoregressive models.&rdquo;
<em>Stat. Probab. Lett. </em>, <b>79</b>(15), 1704-1709.
<a href="https://doi.org/10.1016/j.spl.2009.04.009">doi:10.1016/j.spl.2009.04.009</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mix_pdf">mix_pdf</a></code>, <code><a href="#topic+mix_cdf">mix_cdf</a></code>, <code><a href="#topic+mix_qf">mix_qf</a></code>
for the predictive distributions (pdf, cdf, quantiles);
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data(ibmclose, package = "fma") # `ibmclose'
ibmclose &lt;- as.numeric(fma::ibmclose)
length(ibmclose) # 369
max(exampleModels$WL_ibm@order) # 2

## compute point predictions for t = 3,...,369
pred &lt;- mix_location(exampleModels$WL_ibm, ibmclose)
plot(pred)
## compute one-step point predictions for t = 360,...369
mix_location(exampleModels$WL_ibm, ibmclose, index = 369 - 9:0 )

f &lt;- mix_location(exampleModels$WL_ibm) # a function
## predict the value after the last
f(ibmclose)

## a different way to compute one-step point predictions for t = 360,...369
sapply(369 - 10:1, function(k) f(ibmclose[1:k]))

## the results are the same, but notice that xcond gives past values
## while index above specifies the times for which to compute the predictions.
identical(sapply(369 - 10:1, function(k) f(ibmclose[1:k])),
          mix_location(exampleModels$WL_ibm, ibmclose, index = 369 - 9:0 ))


## conditional variance
f &lt;- mix_variance(exampleModels$WL_ibm) # a function
## predict the value after the last
f(ibmclose)

## a different way to compute one-step point predictions for t = 360,...369
sapply(369 - 10:1, function(k) f(ibmclose[1:k]))

## the results are the same, but notice that xcond gives past values
## while index above specifies the times for which to compute the predictions.
identical(sapply(369 - 10:1, function(k) f(ibmclose[1:k])),
          mix_variance(exampleModels$WL_ibm, ibmclose, index = 369 - 9:0 ))


# interesting example
# bimodal distribution, low kurtosis, 4th moment not much larger than 2nd
moWL &lt;- exampleModels$WL_ibm

mix_location(moWL,xcond = c(500,450))
mix_kurtosis(moWL,xcond = c(500,450))

f1pdf &lt;- mix_pdf(moWL,xcond = c(500,450))
f1cdf &lt;- mix_cdf(moWL,xcond = c(500,450))
gbutils::plotpdf(f1pdf,cdf=f1cdf)
gbutils::plotpdf(f1cdf,cdf=f1cdf)
f1cdf(c(400,480))

mix_variance(moWL,xcond = c(500,450))
mix_central_moment(moWL,xcond = c(500,450), k=2)

sqrt(mix_variance(moWL,xcond = c(500,450)))
sqrt(mix_central_moment(moWL,xcond = c(500,450), k=2))
</code></pre>

<hr>
<h2 id='mix_moment-methods'>Methods for mix_moment</h2><span id='topic+mix_moment-methods'></span><span id='topic+mix_moment+2CMixAR+2Cmissing+2Cmissing+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods for <code>mix_moment</code> in package <span class="pkg">pcts</span></p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR", x = "missing", index = "missing", xcond = "numeric")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mix_location">mix_location</a></code> for examples and related functions
</p>

<hr>
<h2 id='mix_ncomp-methods'>
Number of rows or columns of a MixComp object
</h2><span id='topic+mix_ncomp'></span><span id='topic+mix_ncomp-methods'></span><span id='topic+mix_ncomp+2CMixAR-method'></span><span id='topic+mix_ncomp+2CMixComp-method'></span>

<h3>Description</h3>

<p>Function and methods to get the number of component in a mixture
object. For <code>"MixComp"</code> objects this is equivalent to
<code>ncol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix_ncomp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mix_ncomp-methods_+3A_x">x</code></td>
<td>
<p>an object, such as <code>"MixComp"</code> or  <code>"MixAR"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "MixAR")</code></dt><dd>
</dd>
<dt><code>signature(x = "MixComp")</code></dt><dd>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixComp-class">MixComp-class</a></code>,
<code><a href="#topic+MixAR-class">MixAR-class</a></code>
</p>

<hr>
<h2 id='mix_pdf-methods'>Conditional pdf's and cdf's of MixAR models</h2><span id='topic+mix_pdf'></span><span id='topic+mix_pdf-methods'></span><span id='topic+mix_pdf+2CMixARGaussian+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_pdf+2CMixARGaussian+2Cnumeric+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_pdf+2CMixARGaussian+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic+mix_pdf+2CMixARgen+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_pdf+2CMixARgen+2Cnumeric+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_pdf+2CMixARgen+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic+mix_cdf'></span><span id='topic+mix_cdf-methods'></span><span id='topic+mix_cdf+2CMixARGaussian+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_cdf+2CMixARGaussian+2Cnumeric+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_cdf+2CMixARGaussian+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic+mix_cdf+2CMixARgen+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_cdf+2CMixARgen+2Cnumeric+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_cdf+2CMixARgen+2Cnumeric+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Gives conditional probability densities and distribution functions of
mixture autoregressive models. 
</p>


<h3>Methods</h3>

<p><code>mix_pdf</code> gives a probability density, <code>mix_cdf</code> a
distribution function. If argument <code>x</code> is supplied, the functions
are evaluated for the specified values of <code>x</code>, otherwise function
objects are returned and can be used for further computations, eg for
graphs. 
</p>
<p><code>mix_pdf</code> and <code>mix_cdf</code> have methods with the following
signatures. 
</p>

<dl>
<dt><code>signature(model = "MixARGaussian", x = "missing", index = "missing", xcond = "numeric")</code></dt><dd>
<p>Return (as a function of one argument) the conditional density
(respectively cdf), <code class="reqn">f(x|xcond)</code>, of <code class="reqn">X_{t+1}</code> given
the past values <code>xcond</code>. The values in <code>xcond</code> are in
natural time order, e.g. the last value in <code>xcond</code> is
<code class="reqn">x_{t}</code>. <code>xcond</code> must contain enough values for the
computation of the conditional density (cdf) but if more are given,
only the necessary ones are used.
</p>
</dd>
<dt><code>signature(model = "MixARGaussian", x = "numeric", index = "missing", xcond = "numeric")</code></dt><dd>
<p>Compute the conditional density (respectively cdf) at the values given
by <code>x</code>.
</p>
</dd>
<dt><code>signature(model = "MixARGaussian", x = "numeric", index = "numeric", xcond = "missing")</code></dt><dd>
<p>Compute conditional densities (respectively cdf) for times
specified in <code>index</code>. For each <code class="reqn">t\in{}</code><code>index</code> the
past values needed for the computation of the pdf (cdf) are
<code>...,x[t-2],x[t-1]</code>.
</p>
</dd>
<dt><code>signature(model = "MixARgen", x = "missing", index = "missing",
          xcond = "numeric")</code></dt><dd>

</dd><dt><code>signature(model = "MixARgen", x = "numeric", index = "missing",
          xcond = "numeric")</code></dt><dd>

</dd><dt><code>signature(model = "MixARgen", x = "numeric", index = "numeric",
          xcond = "missing")</code></dt><dd>

</dd></dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mix_moment">mix_moment</a></code> for examples and computation of summary statistics of the
predictive distributions
</p>
<p><code><a href="#topic+mix_qf">mix_qf</a></code> for computation of quantiles.
</p>

<hr>
<h2 id='mix_qf-methods'>Conditional quantile functions of MixAR models</h2><span id='topic+mix_qf'></span><span id='topic+mix_qf-methods'></span><span id='topic+mix_qf+2CMixARGaussian+2Cmissing+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_qf+2CMixARGaussian+2Cnumeric+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_qf+2CMixARGaussian+2Cnumeric+2Cnumeric+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Gives conditional quantile functions of mixture autoregressive models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix_qf(model, p, x, index, xcond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mix_qf-methods_+3A_model">model</code></td>
<td>
<p>mixAR model.</p>
</td></tr>
<tr><td><code id="mix_qf-methods_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="mix_qf-methods_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="mix_qf-methods_+3A_index">index</code></td>
<td>
<p>vector of positive integers.</p>
</td></tr>
<tr><td><code id="mix_qf-methods_+3A_xcond">xcond</code></td>
<td>

<p>the past values needed for the conditional distribution, a numeric
vector of length at least the maximal AR order of the components.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>depending on the arguments, a function for computing quantiles or
a numeric vector representing quantiles, see sections 'Details' and
'Methods
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixARGaussian", p = "missing", x = "missing", index = "missing", xcond = "numeric")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARGaussian", p = "numeric", x = "missing", index = "missing", xcond = "numeric")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARGaussian", p = "numeric", x = "numeric", index = "numeric", xcond = "missing")</code></dt><dd>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mix_pdf">mix_pdf</a></code>,
<code><a href="#topic+mix_cdf">mix_cdf</a></code>;
</p>
<p><code><a href="#topic+mix_moment">mix_moment</a></code> for examples
</p>

<hr>
<h2 id='mix_se-methods'>Compute standard errors of estimates of MixAR models</h2><span id='topic+mix_se'></span><span id='topic+mix_se-methods'></span><span id='topic+mix_se+2CANY+2Clist-method'></span><span id='topic+mix_se+2CANY+2CMixAR-method'></span><span id='topic+mix_se+2CANY+2CMixARGaussian-method'></span>

<h3>Description</h3>

<p>Compute standard errors of estimates of MixAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix_se(x, model, fix_shift)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mix_se-methods_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="mix_se-methods_+3A_model">model</code></td>
<td>

<p>MixAR model, an object inheriting from class &ldquo;MixAR&rdquo;.
</p>
</td></tr>
<tr><td><code id="mix_se-methods_+3A_fix_shift">fix_shift</code></td>
<td>

<p><code>logical</code>. Should the shift paramters be fixed? Default is
<code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For formulas used in the computation, see
Wong (1998).
</p>


<h3>Value</h3>

<p>a list with components:
</p>
<table>
<tr><td><code>standard_errors</code></td>
<td>

<p>Standard error of parameter estimates,
</p>
</td></tr>
<tr><td><code>covariance_matrix</code></td>
<td>

<p>The covariance matrix, obtained as inverse of the information matrix,
</p>
</td></tr>
<tr><td><code>Complete_Information</code></td>
<td>

<p>Complete information matrix,
</p>
</td></tr>
<tr><td><code>Missing_Information</code></td>
<td>

<p>Missing information matrix.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", model = "list")</code></dt><dd>
</dd>
<dt><code>signature(x = "ANY", model = "MixAR")</code></dt><dd>
</dd>
<dt><code>signature(x = "ANY", model = "MixARGaussian")</code></dt><dd>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Davide Ravagli
</p>


<h3>References</h3>

<p>Wong CS (1998).
<em>Statistical inference for some nonlinear time series models</em>.
Ph.D. thesis, University of Hong Kong, Hong Kong .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with IBM data

## data(ibmclose, package = "fma")

moWLprob &lt;- exampleModels$WL_ibm@prob    # 2019-12-15; was: c(0.5339,0.4176,0.0385)     
moWLsigma &lt;- exampleModels$WL_ibm@scale  #                  c(4.8227,6.0082,18.1716)
moWLar &lt;- list(-0.3208, 0.6711,0)        # @Davide - is this from some model?

moWLibm &lt;- new("MixARGaussian", prob = moWLprob, scale = moWLsigma, arcoef = moWLar)

IBM &lt;- diff(fma::ibmclose)
mix_se(as.numeric(IBM), moWLibm, fix_shift = TRUE)$'standard_errors'
</code></pre>

<hr>
<h2 id='mix_variance-methods'>Methods for mix_variance</h2><span id='topic+mix_variance-methods'></span><span id='topic+mix_variance+2CMixAR+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+mix_variance+2CMixAR+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mix_variance+2CMixAR+2Cnumeric+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for <code>mix_variance</code> in package &ldquo;pcts&rdquo;</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR", x = "missing", index = "missing", xcond = "missing")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixAR", x = "missing", index = "missing", xcond = "numeric")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixAR", x = "numeric", index = "numeric", xcond = "missing")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mix_location">mix_location</a></code> for examples and related functions
</p>

<hr>
<h2 id='mixAR_BIC'>
BIC based model selection for MixAR models
</h2><span id='topic+mixAR_BIC'></span><span id='topic+BIC_comp'></span>

<h3>Description</h3>

<p>BIC calculations for mixture autoregressive models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixAR_BIC(y, model, fix = NULL, comp_loglik = TRUE, index)
BIC_comp(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixAR_BIC_+3A_y">y</code></td>
<td>
<p>a time series.</p>
</td></tr>
<tr><td><code id="mixAR_BIC_+3A_model">model</code></td>
<td>

<p>the model for which to calculate BIC, an object inheriting from
class <code>MixAR</code>. Alternatively, an output list from
<code>fit_mixAR</code>.
</p>
</td></tr>
<tr><td><code id="mixAR_BIC_+3A_fix">fix</code></td>
<td>

<p>If <code>fix = "shift"</code> shift parameters are not included in
calculation of BIC. Default is <code>NULL</code>, i.e. shift parameters are
included.
</p>
</td></tr>
<tr><td><code id="mixAR_BIC_+3A_comp_loglik">comp_loglik</code></td>
<td>
<p>Should the loglikelihood be calculated?  Default is
<code>TRUE</code>. If <code>FALSE</code> and model is output of
<code>fit_mixAR</code>, then the loglikelihood is not recalculated.
</p>
</td></tr>
<tr><td><code id="mixAR_BIC_+3A_index">index</code></td>
<td>

<p>Discard the first <code>1:index</code> observations. If <code>missing</code>,
<code>index</code> is set to the largest AR order.
</p>
</td></tr>
<tr><td><code id="mixAR_BIC_+3A_x">x</code></td>
<td>

<p>a list containing a combination of <code>MixAR</code> objects and/or
output lists from <code>fit_mixAR</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mixAR_BIC</code> calculates the BIC criterion of a given <code>MixAR</code>
object with respect to a specified time series.
</p>
<p>If <code>index</code> is specified, it has to be at least equal to the
largest autoregressive order. The function calculates BIC on the last
<code>(index + 1):n</code> data points.
</p>
<p><code>BIC_comp</code> calculates the value of BIC for the models listed in
<code>x</code> with respect to the specified time series <code>y</code>.
</p>
<p>If the distributions of the components contain estimated parameters,
then their number is included in the number of parameters for the
calculation of BIC.
</p>


<h3>Value</h3>

<p>If <code>comp_loglik = TRUE</code>, the function calculates BIC based on the
given model, data and <code>index</code>.
</p>
<p>If <code>comp_loglik = FALSE</code> and model is output from
<code>fit_mixAR</code>, it returns object <code>vallogf</code> from that list.
</p>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>Examples</h3>

<pre><code class='language-R'>model1 &lt;- new("MixARGaussian", prob = c(0.5, 0.5), scale = c(1, 2),
              arcoef = list(-0.5, 1.1))

model2 &lt;- new("MixARGaussian", prob = c(0.5, 0.3, 0.2), scale = c(1, 3, 8),
              arcoef = list(c(-0.5, 0.5), 1, 0.4))

set.seed(123)
y &lt;- mixAR_sim(model1, 400, c(0, 0, 0), nskip = 100)

mixAR_BIC(y, model1)

model_fit1 &lt;- fit_mixAR(y, model1)
model_fit2 &lt;- fit_mixAR(y, model2, crit = 1e-4)

mixAR_BIC(y, model_fit1)
mixAR_BIC(y, model_fit2)

BIC_comp(list(model1, model2, model_fit1, model_fit2), y)

mixAR_BIC(y, model_fit1, index = 20)
mixAR_BIC(y, model_fit2, index = 20)
</code></pre>

<hr>
<h2 id='mixAR_cond_probs'>The E-step of the EM algorithm for MixAR models</h2><span id='topic+mixAR_cond_probs'></span>

<h3>Description</h3>

<p>Compute conditional probabilities for the E-step of the EM
algorithm for MixAR models. Internal function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixAR_cond_probs(model, y, indx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixAR_cond_probs_+3A_model">model</code></td>
<td>
<p>an object from a sub-class of &quot;MixAR&quot;.</p>
</td></tr>
<tr><td><code id="mixAR_cond_probs_+3A_y">y</code></td>
<td>
<p>the time series, a numeric vector.</p>
</td></tr>
<tr><td><code id="mixAR_cond_probs_+3A_indx">indx</code></td>
<td>
<p>indices of elements for which to compute residuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is essentially the E-step for the MixAR models.
</p>


<h3>Value</h3>

<p>the conditional probabilities, an object from class &quot;MixComp&quot;.
</p>

<hr>
<h2 id='mixAR_diag'>
Diagnostic checks for mixture autoregressive models
</h2><span id='topic+mixAR_diag'></span><span id='topic+tsdiag'></span><span id='topic+tsdiag.MixAR'></span>

<h3>Description</h3>

<p>Carry out diagnostic checks and tests on fitted mixAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MixAR'
tsdiag(object, gof.lag = NULL, y, ask = interactive(), ..., 
       plot = interactive(), std.resid = FALSE)

mixAR_diag(model, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixAR_diag_+3A_model">model</code>, <code id="mixAR_diag_+3A_object">object</code></td>
<td>

<p>the model on which to perform the checks, an object from class
<code>MixAR</code>. <code>model</code> can also be the output list from
<code>fit_mixAR</code>.
</p>
</td></tr>
<tr><td><code id="mixAR_diag_+3A_gof.lag">gof.lag</code></td>
<td>

<p>Goodness of fit lag(s) for the Ljung-Box tests. Vector containing
one or more positive integers. <code>max(gof.lag)</code> is the maximal
lag in the acf and pacf plots.
</p>
<p>how many lags to compute for acf and pacf? The default is as that of
<code>lag.max</code> for <code>acf</code>.
</p>
</td></tr>
<tr><td><code id="mixAR_diag_+3A_y">y</code></td>
<td>
<p>a time series, currently a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="mixAR_diag_+3A_ask">ask</code></td>
<td>

<p>if <code>TRUE</code>, ask (using a menu) which plot to present. Otherwise
just plot the selected plots. <code>ask</code> is ignored if only one plot 
is selected with argument <code>plot</code>. 
</p>
</td></tr>
<tr><td><code id="mixAR_diag_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code>, the default, produce diagnostic plots. If
<code>FALSE</code> don't produce plots. Otherwise, a numeric vector of
integers defining a subset of plots to consider, see Details.
</p>
</td></tr>
<tr><td><code id="mixAR_diag_+3A_std.resid">std.resid</code></td>
<td>

<p>if <code>TRUE</code> standardise the ordinary residuals using
the conditional standard deviations. <strong>NOTE:</strong>  the default is
currently <code>FALSE</code> but it may soon be changed to <code>TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="mixAR_diag_+3A_...">...</code></td>
<td>
<p>for <code>mixAR_diag</code>, passed on to <code>tsdiag</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to use <code>tsdiag</code>.  <code>mixAR_diag</code> is
essentially deprecated and is still here for compatibility with old
code. Moreover, the <code>tsdiag</code> method is more flexible. The only
advantage of <code>mixAR_diag</code> is that it accepts also a list for
argument <code>model</code> but this is equivalent to calling <code>tsdiag</code>
with <code>object = model$model</code>.
</p>
<p>The function calculates several types of residuals, provides
diagnostic plots for each of them, and returns numerical results.
The following choices are currently available:
</p>

<ol>
<li><p> ACF/PACF of residuals,
</p>
</li>
<li><p> ACF/PACF of U_residuals,
</p>
</li>
<li><p> ACF/PACF of tau_residuals,
</p>
</li>
<li><p> ACF/Histogram of tau_residuals.
</p>
</li></ol>

<p>In interactive sessions the user is presented with a menu to select
plot(s) from the available ones. The choice can be restricted to a
subset of them by giving argument <code>plot</code> a vector of integers.
This is most useful to select a particular plot, with somethinng like
<code>plot = 2</code> in the call to <code>tsdiag</code>.  <code>plot</code> is used as
an index vector, so <code>plot = -1</code> would remove the first item
listed above from the offered alternatives.
</p>
<p>Transformations on the data are performed, as described in Smith
(1985).
</p>
<p>Four types of residuals are computed:
</p>

<dl>
<dt>ordinary residuals</dt><dd>
<p>difference (possibly scaled) between observed values and point
predictions.
</p>
</dd>
<dt>U_residuals/PIT residuals</dt><dd>
<p>probability integral transform of the data using the CDF of the
conditional distributions implied by the fitted model.  For a good
model these should resemble an IID sequence uniformly distributed
on (0,1).


</p>
</dd>
<dt>V_residuals</dt><dd>
<p>set of transformed <code>U_residuals</code> with the quantile function
of the standard normal distribution (<code>qnorm</code>).  For a good
model these should resemble an IID sequence from N(0,1).
</p>
</dd>
<dt>tau_residuals</dt><dd>
<p>These residuals are calculated as the component specific residual
<code>e_tk</code> divided by its corresponding scale <code>sigma_k</code>,
according to under which component y_t has largest density.  Under
correct model specification, these should be jointly
Normal. Shapiro-Wilk test is performed on this set of residual to
assess the hypothesis.
</p>
</dd>
</dl>
<p>For all types of residual results for the Ljung-Box test are
provided. This test is particularly relevant for the V- and
tau-residuals.
</p>
<p>Kolmogorov-Smirnov test is carried out for the U_residuals to assess
the hypothesis of uniform distribution.
</p>
<p>Shapiro-Wilk test of normality is applied to V- and tau-residuals.
</p>


<h3>Value</h3>

<p>returns invisibly a list with class <code>"tsdiagMixAR"</code>, currently
containing the following components:
</p>
<table>
<tr><td><code>residuals</code></td>
<td>
<p>ordinary residuals,</p>
</td></tr>
<tr><td><code>U_residuals</code></td>
<td>
<p>see Details,</p>
</td></tr>
<tr><td><code>V_residuals</code></td>
<td>
<p>see Details,</p>
</td></tr>
<tr><td><code>tau_residuals</code></td>
<td>
<p>see Details,</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>the value of the BIC criterion, a number.</p>
</td></tr>
</table>
<p>Each component, except <code>BIC</code>, is a list containing the residuals
in component <code>value</code>, Ljung-Box test in <code>"Ljung-Box"</code> and
possibly other tests suitable for the corresponding type of
residuals. 
</p>


<h3>Note</h3>

<p>This function should be used for diagnostic checking of <code>MixARGaussian</code>
objects only.
</p>


<h3>Author(s)</h3>

<p>Davide Ravagli and Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Smith JQ (1985).
&ldquo;Diagnostic checks of non-standard time series models.&rdquo;
<em>Journal of Forecasting</em>, <b>4</b>(3), 283-291.
<a href="https://doi.org/10.1002/for.3980040305">doi:10.1002/for.3980040305</a>, https://onlinelibrary.wiley.com/doi/pdf/10.1002/for.3980040305, <a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/for.3980040305">https://onlinelibrary.wiley.com/doi/abs/10.1002/for.3980040305</a>.
</p>
<p>Wong CS, Li WK (2000).
&ldquo;On a mixture autoregressive model.&rdquo;
<em>J. R. Stat. Soc., Ser. B, Stat. Methodol. </em>, <b>62</b>(1), 95-115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixAR_BIC">mixAR_BIC</a></code>,
<code><a href="stats.html#topic+tsdiag">tsdiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model1 &lt;- new("MixARGaussian", prob = c(0.5, 0.5), scale = c(1, 2),
              arcoef = list(-0.5, 1.1))
set.seed(123)
y &lt;- mixAR_sim(model1, 400, c(0,0,0), nskip = 100) 

fit1 &lt;- fit_mixAR(y, model1)
d &lt;- tsdiag(fit1$model, c(10, 20, 50), y)
d
## This will put each plot in a separate file (mydiag01.pdf, ..., mydiag04.pdf)
## pdf("mydiag%02d.pdf", onefile = FALSE)
## d &lt;- tsdiag(fit1$model, c(10, 20, 50), y,  ask = FALSE)
## dev.off()
</code></pre>

<hr>
<h2 id='mixAR_sim'>Simulate from MixAR models</h2><span id='topic+mixAR_sim'></span><span id='topic+mixAny_sim'></span>

<h3>Description</h3>

<p>Simulate from MixAR models</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixAR_sim(model, n, init, nskip = 100, flag = FALSE)

mixAny_sim(model, n, init, nskip=100, flag = FALSE,
                  theta, galpha0, galpha, gbeta)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixAR_sim_+3A_model">model</code></td>
<td>
<p>model from which to simulate, an object inheriting from class <code>MixAR</code>.</p>
</td></tr>
<tr><td><code id="mixAR_sim_+3A_init">init</code></td>
<td>
<p>initial values, numeric vector.</p>
</td></tr>
<tr><td><code id="mixAR_sim_+3A_n">n</code></td>
<td>
<p>size of the simulated series.</p>
</td></tr>
<tr><td><code id="mixAR_sim_+3A_nskip">nskip</code></td>
<td>
<p>number of burn-in values, see Details.</p>
</td></tr>
<tr><td><code id="mixAR_sim_+3A_flag">flag</code></td>
<td>
<p>if <code>TRUE</code> return also the regimes.</p>
</td></tr>
<tr><td><code id="mixAR_sim_+3A_theta">theta</code></td>
<td>
<p>ma coef, a list.</p>
</td></tr>
<tr><td><code id="mixAR_sim_+3A_galpha0">galpha0</code></td>
<td>
<p>alpha0[k], k=1,...,g.</p>
</td></tr>
<tr><td><code id="mixAR_sim_+3A_galpha">galpha</code></td>
<td>
<p>garch alpha.</p>
</td></tr>
<tr><td><code id="mixAR_sim_+3A_gbeta">gbeta</code></td>
<td>
<p>garch beta.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mixAR_sim</code> simulates a series of length <code>nskip+n</code> and
returns the last <code>n</code> values.
</p>
<p><code>mixAny_sim</code> simulates from a MixAR model with GARCH
innovations. <code>mixAny_sim</code> was a quick fix for Shahadat and needs
consolidation. 
</p>
<p>The vector <code>init</code> provides the initial values for
<code class="reqn">t=...,-1,0</code>. Its length must be at least equal to the maximal AR
order. If it is longer, only the last <code>max(model@order)</code> elements
are used.
</p>


<h3>Value</h3>

<p>a numeric vector of length <code>n</code>. If <code>flag = TRUE</code> it has
attribute <code>regimes</code> containing <code>z</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleModels$WL_ibm
## simulate a continuation of BJ ibm data
ts1 &lt;- mixAR_sim(exampleModels$WL_ibm, n = 30, init = c(346, 352, 357), nskip = 0)

# a simulation based estimate of the 1-step predictive distribution
# for the first date after the data.
s1 &lt;- replicate(1000, mixAR_sim(exampleModels$WL_ibm, n = 1, init = c(346, 352, 357), 
                      nskip = 0))
plot(density(s1))

# load ibm data from BJ
## data(ibmclose, package = "fma")

# overlay the 'true' predictive density.
pdf1 &lt;- mix_pdf(exampleModels$WL_ibm, xcond = as.numeric(fma::ibmclose))
curve(pdf1, add = TRUE, col = 'blue')

# estimate of 5% quantile of predictive distribution
quantile(s1, 0.05)

# Monte Carlo estimate of "expected shortfall"
# (but the data has not been converted into returns...)
mean(s1[ s1 &lt;= quantile(s1, 0.05) ])
</code></pre>

<hr>
<h2 id='mixAR_switch'>Relabel the components of a MixAR model</h2><span id='topic+mixAR_switch'></span><span id='topic+mixAR_permute'></span>

<h3>Description</h3>

<p>Relabel the components of a MixAR model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixAR_switch(model, perm)
mixAR_permute(model, perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixAR_switch_+3A_model">model</code></td>
<td>
<p>a MixAR model</p>
</td></tr>
<tr><td><code id="mixAR_switch_+3A_perm">perm</code></td>
<td>
<p>a permutation for relabeling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the permutation is the identity permutation the model is returned
as is. Otherwise the order of the components is changed according to
<code>perm</code>.  Basically, <code>perm</code> is used as index,
e.g. <code>prob[perm]</code>, etc.
</p>





<h3>Note</h3>

<p>Currently the function only reorders the &quot;usual&quot;
components. Subclasses of &quot;MixAR&quot; may contain other parameters
(e.g. different error distributions). So this function may not be
appropriate for them.
</p>


<hr>
<h2 id='MixAR-class'>Class <code>"MixAR"</code> &mdash; mixture autoregressive models </h2><span id='topic+MixAR-class'></span>

<h3>Description</h3>

<p>Mixture autoregressive models</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: no objects can be created from it.
</p>
<p>Derived classes add distribution properties, e.g. use class
<code>"<a href="#topic+MixARGaussian-class">MixARGaussian</a>"</code> for MixAR models with Gaussian
error components.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prob</code>:</dt><dd><p>the mixing probabilities, <code>"numeric"</code>.</p>
</dd>
<dt><code>order</code>:</dt><dd><p>the AR orders, <code>"numeric"</code>.</p>
</dd>
<dt><code>shift</code>:</dt><dd><p>intercept terms, <code>"numeric"</code>.</p>
</dd>
<dt><code>scale</code>:</dt><dd><p>scaling factor, <code>"numeric"</code>.</p>
</dd>
<dt><code>arcoef</code>:</dt><dd>
<p>autoregressive coefficients, an object from class
<code>"raggedCoef"</code> containing one row for each mixture component.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>fit_mixAR</dt><dd><p><code>signature(x = "ANY", model = "MixAR", init = "list")</code>: ... </p>
</dd>
<dt>fit_mixAR</dt><dd><p><code>signature(x = "ANY", model = "MixAR", init = "missing")</code>: ... </p>
</dd>
<dt>fit_mixAR</dt><dd><p><code>signature(x = "ANY", model = "MixAR", init = "MixAR")</code>: ... </p>
</dd>
<dt>fit_mixAR</dt><dd><p><code>signature(x = "ANY", model = "MixAR", init = "numeric")</code>: ... </p>
</dd>
<dt>fit_mixAR</dt><dd><p><code>signature(x = "ANY", model = "MixARGaussian", init = "MixAR")</code>: ... </p>
</dd>
<dt>get_edist</dt><dd><p><code>signature(model = "MixAR")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "MixAR")</code>: ... </p>
</dd>
<dt>lik_params</dt><dd><p><code>signature(model = "MixAR")</code>: ... </p>
</dd>
<dt>make_fcond_lik</dt><dd><p><code>signature(model = "MixAR", ts = "numeric")</code>: ... </p>
</dd>
<dt>mix_ek</dt><dd><p><code>signature(model = "MixAR", x = "numeric", index = "numeric", xcond = "missing", scale = "missing")</code>: ... </p>
</dd>
<dt>mix_ek</dt><dd><p><code>signature(model = "MixAR", x = "numeric", index = "numeric", xcond = "missing", scale = "logical")</code>: ... </p>
</dd>
<dt>mix_ek</dt><dd><p><code>signature(model = "MixAR", x = "numeric", index = "missing", xcond = "numeric", scale = "missing")</code>: ... </p>
</dd>
<dt>mix_ek</dt><dd><p><code>signature(model = "MixAR", x = "numeric", index = "missing", xcond = "numeric", scale = "logical")</code>: ... </p>
</dd>
<dt>mix_hatk</dt><dd><p><code>signature(model = "MixAR", x = "numeric", index = "numeric", xcond = "missing")</code>: ... </p>
</dd>
<dt>mix_ncomp</dt><dd><p><code>signature(x = "MixAR")</code>: ... </p>
</dd>
<dt>mixAR</dt><dd><p><code>signature(template = "MixAR")</code>: ... </p>
</dd>
<dt>noise_dist</dt><dd><p><code>signature(model = "MixAR")</code>: ... </p>
</dd>
<dt>noise_params</dt><dd><p><code>signature(model = "MixAR")</code>: ... </p>
</dd>
<dt>noise_rand</dt><dd><p><code>signature(model = "MixAR")</code>: ... </p>
</dd>
<dt>parameters</dt><dd><p><code>signature(model = "MixAR")</code>: ... </p>
</dd>
<dt>row_lengths</dt><dd><p><code>signature(x = "MixAR")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixAR">mixAR</a></code>,
classes <code>"<a href="#topic+MixARGaussian-class">MixARGaussian</a>"</code>,
<code>"<a href="#topic+MixARgen-class">MixARgen</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## some models from subclasses of (virtual) class "MixAR"
names(exampleModels)
exampleModels$WL_A
exampleModels$WL_At

## modify an existing model, here change the mixture weights
mixAR(exampleModels$WL_A, coef = list((prob = c(0.4, 0.6))))
</code></pre>

<hr>
<h2 id='mixAR-internal'>Internal mixAR Functions</h2><span id='topic+param_score_stdt'></span>

<h3>Description</h3>

<p>Internal mixAR functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_score_stdt(x, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixAR-internal_+3A_x">x</code></td>
<td>
<p>~~ TODO: describe this argument. ~~</p>
</td></tr>
<tr><td><code id="mixAR-internal_+3A_nu">nu</code></td>
<td>
<p>~~ TODO: describe this argument. ~~</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are not to be called by the user (or in some cases are just
waiting for proper documentation to be written.
</p>

<hr>
<h2 id='mixAR-methods'>Create MixAR objects</h2><span id='topic+mixAR'></span><span id='topic+mixAR-methods'></span><span id='topic+mixAR+2CANY-method'></span><span id='topic+mixAR+2CMixAR-method'></span>

<h3>Description</h3>

<p>Generic function with methods for creating MixAR objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixAR(template, coef, ..., filler = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixAR-methods_+3A_template">template</code></td>
<td>

<p>an object to be used as a template for the new object, typically
inheriting from <code>"MixAR"</code>. Alternatively, missing or a numeric
vector specifying the order of the MixAR model, see Details.
</p>
</td></tr>
<tr><td><code id="mixAR-methods_+3A_coef">coef</code></td>
<td>

<p>parameters for the new object a list with components
<code>"arcoef"</code>, <code>"order"</code>, <code>"prob"</code>,
<code>"shift"</code>, and <code>"scale"</code>.
</p>
</td></tr>
<tr><td><code id="mixAR-methods_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
<tr><td><code id="mixAR-methods_+3A_filler">filler</code></td>
<td>

<p>value for unspecified parameters, default is <code>NA_real_</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mixAR</code> provides an alternative to the function <code>new</code> for
specifying MixAR models.
</p>
<p>If <code>template</code> is numeric vector, it is taken to specify the AR order
of the model and the number of mixture components. A Gaussian MixAR
model is created with parameters filled initially with NA's and then
updated with values given by <code>coef</code>. <code>coef</code> does not need to
have values for all parameters and may be missing altogether. If NA's
are not suitable for initialisation, a suitable value can be specified
with <code>filler</code>.
</p>
<p>If <code>template</code> is a MixAR object, then the new object will
have the class of <code>template</code>. The new object is set
initially to a copy of <code>template</code> and then updated with
parameters specified by <code>coef</code> (and maybe others for some
methods). 
</p>
<p>In principle, the numeric parameters are vectors of length the number of
components of the MixAR model. For convenience, single values are
replicated to the number of components. For this to work, at least one
component must be specified completely, for example the order. It is
an error for the parameters to imply conflicting number of components.  
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(template = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(template = "MixAR")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p>class <code>"<a href="#topic+MixARGaussian-class">MixARGaussian</a>"</code>,
class <code>"<a href="#topic+MixARgen-class">MixARgen</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mixAR(coef = list(prob = c(.5,.5), scale = c(1,2), 
                  arcoef = list(.5, 1.1), shift = c(0,0), order = c(1,1)))

mixAR(template = c(1,1))
mixAR(coef = list(order = c(1,1))) # same

m2 &lt;- new("MixARGaussian", order = c(3, 2, 1),
          arcoef = matrix(c(1:3, c(1:2, 0), c(1, 0, 0)), nrow = 3, byrow = TRUE))
m2a &lt;- mixAR(m2, list(prob = c(0.5, 0.25, 0.25)))
show_diff(m2, m2a)
</code></pre>

<hr>
<h2 id='mixARemFixedPoint'>
EM estimation for mixture autoregressive models
</h2><span id='topic+mixARemFixedPoint'></span><span id='topic+mixARgenemFixedPoint'></span>

<h3>Description</h3>

<p>Fit a mixture autoregressive model to a univariate time series using the
EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixARemFixedPoint(y, model, est_shift = TRUE, crit = 1e-14, 
                  maxniter = 200, minniter = 10, verbose = FALSE)

mixARgenemFixedPoint(y, model, crit = 1e-14, maxniter = 200, 
                     minniter = 10, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixARemFixedPoint_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="mixARemFixedPoint_+3A_model">model</code></td>
<td>
<p>an object of class MixAR, a mixture autoregressive model providing the model
specifications and initial values for the parameters.
</p>
</td></tr>
<tr><td><code id="mixARemFixedPoint_+3A_est_shift">est_shift</code></td>
<td>
<p>if TRUE optimise also w.r.t. the shift (constant) terms of the AR
components, if FALSE keep the shift terms fixed.
</p>
</td></tr>
<tr><td><code id="mixARemFixedPoint_+3A_crit">crit</code></td>
<td>
<p>stop iterations when the relative change in the
log-likelihood becomes smaller than this value.
</p>
</td></tr>
<tr><td><code id="mixARemFixedPoint_+3A_maxniter">maxniter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mixARemFixedPoint_+3A_minniter">minniter</code></td>
<td>
<p>minimum number of iterations, do  at leat that many
iterations.</p>
</td></tr>
<tr><td><code id="mixARemFixedPoint_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to the M-step
optimiser.</p>
</td></tr>
<tr><td><code id="mixARemFixedPoint_+3A_verbose">verbose</code></td>
<td>
<p>print more details during optimisation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mixARemFixedPoint</code> and <code>mixARgenemFixedPoint</code> estimate
MixAR models with the EM algorithm.  For <code>mixARemFixedPoint</code>, the
distribution of the components are fixed to be Gaussian. For
<code>mixARgenemFixedPoint</code>, the distributions can, in principle be
arbitrary (well, to a point).
</p>
<p>Starting with <code>model</code>, the expectation and maximisation steps of
the EM algorithm are repeated until convergence is detected or the
maximum number of iterations, <code>maxniter</code> is exceeded.
</p>
<p>Currently the convergence check is very basic&mdash;the iterations stop
when the relative change in the log-likelihood in the last two
iterations is smaller than the threshold value specified by
<code>crit</code> and at least <code>minniter</code> iterations have been done.
</p>
<p>The EM algorithm may converge very slowly. To do additional iterations
use the returned value in another call of this function.
</p>


<h3>Value</h3>

<p>the fitted model as an object inheriting from &quot;MixAR&quot;.
</p>


<h3>Note</h3>

<p>This function was not intended to be called directly by the user
(hence the inconvenient name).
</p>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_mixAR">fit_mixAR</a></code> which uses these functions for estimation,
classes
<code>"<a href="#topic+MixARGaussian-class">MixARGaussian</a>"</code>,
<code>"<a href="#topic+MixARgen-class">MixARgen</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data(ibmclose, package = "fma") # ibm data from BJ

m0 &lt;- exampleModels$WL_ibm
m1 &lt;- mixARemFixedPoint(fma::ibmclose, m0)
m1a &lt;- mixARemFixedPoint(fma::ibmclose, m1$model)
show_diff(m1$model, m1a$model)

mixARemFixedPoint(fma::ibmclose, m0, est_shift = FALSE)


## simulate a continuation of ibmclose, assuming m0
ts1 &lt;- mixAR_sim(m0, n = 50, init = c(346, 352, 357), nskip = 0)
m2a &lt;- mixARemFixedPoint(ts1,       m0, est_shift = FALSE)$model
m2b &lt;- mixARemFixedPoint(diff(ts1), m0, est_shift = FALSE)$model

</code></pre>

<hr>
<h2 id='mixARExperiment'>Simulation experiments with MixAR models</h2><span id='topic+mixARExperiment'></span>

<h3>Description</h3>

<p>Perform simulation experiments with MixAR models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixARExperiment(model, imodel = NULL, simargs = NULL, estargs = NULL, fix, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixARExperiment_+3A_model">model</code></td>
<td>
<p>the underlying model, an object inheriting from &quot;MixAR&quot;,
see 'Details'.</p>
</td></tr>
<tr><td><code id="mixARExperiment_+3A_imodel">imodel</code></td>
<td>
<p>initial model,  an object inheriting from &quot;MixAR&quot;, see 'Details'.</p>
</td></tr>
<tr><td><code id="mixARExperiment_+3A_simargs">simargs</code></td>
<td>
<p>additional arguments for the simulation function, a
list, see 'Details'.</p>
</td></tr>
<tr><td><code id="mixARExperiment_+3A_estargs">estargs</code></td>
<td>
<p>additional arguments for the estimation function, a
list, see 'Details'.</p>
</td></tr>
<tr><td><code id="mixARExperiment_+3A_fix">fix</code></td>
<td>
<p>which arguments to keep fixed during estimation; currently
if <code>fix = "shift"</code> the shift parameters are kept fixed, otherwise
all parameters are estimated.</p>
</td></tr>
<tr><td><code id="mixARExperiment_+3A_...">...</code></td>
<td>
<p>additional arguments to pass on to <code><a href="#topic+simuExperiment">simuExperiment</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mixARExperiment</code> is a wrapper for <code>simuExperiment</code>.
</p>
<p>The simulation function is <code>mixARsim</code> and the estimation function
is <code>fit_mixAR</code>. The simulation function gets <code>model</code> as
first argument. The first argument of the estimation function is
<code>imodel</code>, if supplied, or <code>model</code> otherwise. Some
appropriate defaults for other arguments are also supplied. Arguments
<code>simargs</code> and <code>estargs</code> are needed only to override
defaults.
</p>
<p>If <code>fix = "shift"</code>, the shifts components are not estimated and
are kept fixed. This may be useful when fitting the model to
differenced series, for example.
</p>
<p><code>mixARExperiment</code> sets <code>keep</code> and <code>summary_fun</code> to some
defaults (currently <code>mixAR:::.fsumA</code> for the latter).
</p>


<h3>Value</h3>

<p>A list with one or more elements, depending on the arguments
<code>...</code> passed on to <code><a href="#topic+simuExperiment">simuExperiment</a></code>.
</p>
<table>
<tr><td><code>Summary</code></td>
<td>
<p>a summary of the experiment, by default sample means
and standard deviations of the estimates. This is a list of MixAR models.</p>
</td></tr>
<tr><td><code>Raw</code></td>
<td>
<p>A list of the estimated models.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is an initial version of this function, some of its arguments may
change.  Additional elements may be made available in the returned
value, so refer to those by name, not with a numeric index.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+simuExperiment">simuExperiment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleModels$WL_II

set.seed(1234)
n = 20 # toy size
N = 5 # toy number of simulations
mixARExperiment(exampleModels$WL_II, N = N, estargs = list(crit = 1e-4))
mixARExperiment(exampleModels$WL_II, N = N, raw = TRUE, estargs = list(crit = 1e-4))
mixARExperiment(exampleModels$WL_II, N = N, raw = TRUE,
    simargs = list(n = n), estargs = list(crit = 1e-4) )
</code></pre>

<hr>
<h2 id='MixARGaussian-class'>mixAR models with Gaussian noise components</h2><span id='topic+MixARGaussian-class'></span><span id='topic+MixARGaussian'></span>

<h3>Description</h3>

<p>Class <code>"MixARGaussian"</code> represents MixAR models with Gaussian
noise components.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MixARGaussian",
  ...)</code>, giving the elements of the model as named arguments, see the
examples below. All elements of the model, except <code>arcoef</code>, are
simple numeric vectors. From version 0.19-15 of package MixAR it is
possible to create objects using <code>MixARGaussian(...)</code>. The two
forms are completely equivalent.
</p>
<p><code>arcoef</code> contains the AR coefficients, one numeric vector for
each mixture component. It can be given as a
<code>"<a href="#topic+raggedCoef-class">raggedCoef</a>"</code> object or as a list of numeric
vectors.
</p>
<p>To input a model with seasonal AR coefficients, argument passed to <code>arcoef</code> can be passed as a <code>raggedCoefS</code> object, or as a <code>list</code> of three elements.
For the latter, seasonality <code>s</code> must be explicitly indicated.
AR coefficients can be given as <code>list</code> or <code>matrix</code> within the main list (one for main AR coefficients, named <code>a</code>, and one for seasonal AR coefficients, <code>as</code>). Each row of a input matrix/element of the list denotes one component of the mixture.
If not named, initialisation takes the first passed element to be <code>a</code> and the second to be <code>as</code>.
</p>
<p>The AR order of the model is inferred from <code>arcoef</code>
argument. If argument <code>order</code> is given, it is checked for
consistency with <code>arcoef</code>.  The <code>shift</code> slot defaults to a
vector of zeroes and the <code>scale</code> slot to a vector of ones.
</p>
<p>The distribution of the noise components is standard Gaussian, N(0,1).
</p>


<h3>Slots</h3>

<p>All slots except <code>arcoef</code> are numeric vectors of length
equal to the number of components in the model.
</p>

<dl>
<dt><code>prob</code>:</dt><dd><p>probabilities of the mixture components</p>
</dd>
<dt><code>order</code>:</dt><dd><p>AR orders of the components</p>
</dd>
<dt><code>shift</code>:</dt><dd><p>the shift (intercept) terms of the AR components</p>
</dd>
<dt><code>scale</code>:</dt><dd><p>the standard deviations of the noise terms of the AR components</p>
</dd>
<dt><code>arcoef</code>:</dt><dd><p>The AR components, object of class <code>"raggedCoef"</code></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+MixAR-class">MixAR</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>mix_cdf</dt><dd>
<p><code>signature(model = "MixARGaussian", x = "numeric", index = "numeric", xcond = "missing")</code>:
... </p>
</dd>
<dt>mix_cdf</dt><dd>
<p><code>signature(model = "MixARGaussian", x = "numeric", index = "missing", xcond = "numeric")</code>:
... </p>
</dd>
<dt>fit_mixAR</dt><dd><p><code>signature(x = "ANY", model = "MixARGaussian", init = "MixAR")</code>: ... </p>
</dd>
<dt>get_edist</dt><dd><p><code>signature(model = "MixARGaussian")</code>: ... </p>
</dd>
<dt>mix_cdf</dt><dd><p><code>signature(model = "MixARGaussian", x = "missing", index = "missing", xcond = "numeric")</code>: ... </p>
</dd>
<dt>mix_pdf</dt><dd><p><code>signature(model = "MixARGaussian", x = "missing", index = "missing", xcond = "numeric")</code>: ... </p>
</dd>
<dt>mix_pdf</dt><dd><p><code>signature(model = "MixARGaussian", x = "numeric", index = "missing", xcond = "numeric")</code>: ... </p>
</dd>
<dt>mix_pdf</dt><dd><p><code>signature(model = "MixARGaussian", x = "numeric", index = "numeric", xcond = "missing")</code>: ... </p>
</dd>
<dt>noise_dist</dt><dd><p><code>signature(model = "MixARGaussian")</code>: ... </p>
</dd>
<dt>noise_rand</dt><dd><p><code>signature(model = "MixARGaussian")</code>: ... </p>
</dd></dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p>classes
<code>"<a href="#topic+MixARgen-class">MixARgen</a>"</code>,
<code>"<a href="#topic+MixAR-class">MixAR</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MixARGaussian")

## load ibm data from BJ
## data(ibmclose, package = "fma")

## compute a predictive density, assuming exampleModels$WL_ibm model
## for the first date after the end of the data
pdf1 &lt;- mix_pdf(exampleModels$WL_ibm, xcond = as.numeric(fma::ibmclose))

## plot the predictive density
## (cdf is used to determine limits on the x-axis)
cdf1 &lt;- mix_cdf(exampleModels$WL_ibm, xcond = as.numeric(fma::ibmclose))
gbutils::plotpdf(pdf1, cdf = cdf1, lq = 0.001, uq = 0.999)

## compute lower 5% quantile of cdf1
gbutils::cdf2quantile(0.05, cdf = cdf1)
</code></pre>

<hr>
<h2 id='MixARgen-class'>Class <code>"MixARgen"</code></h2><span id='topic+MixARgen-class'></span><span id='topic+mixARgen'></span>

<h3>Description</h3>

<p>A class for MixAR models with arbitrary noise distributions. <code>"MixARgen"</code>
inherits from <code>"MixAR"</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MixARgen",
  dist, ...)</code>  or <code>mixARgen(...)</code>. The two forms are completely
equivalent. The latter is available from version 0.19-15 of package
MixAR.
</p>


<h3>Slots</h3>

<p>Most slots are inherited from class <code>"<a href="#topic+MixAR-class">MixAR</a>"</code>.
</p>

<dl>
<dt><code>prob</code>:</dt><dd><p>the mixing probabilities, <code>"numeric"</code>.</p>
</dd>
<dt><code>order</code>:</dt><dd><p>the AR orders, <code>"numeric"</code>.</p>
</dd>
<dt><code>shift</code>:</dt><dd><p>intercept terms, <code>"numeric"</code>.</p>
</dd>
<dt><code>scale</code>:</dt><dd><p>scaling factor, <code>"numeric"</code>.</p>
</dd>
<dt><code>arcoef</code>:</dt><dd>
<p>autoregressive coefficients, an object from class
<code>"raggedCoef"</code> containing one row for each mixture component.
</p>
</dd>
<dt><code>dist</code>:</dt><dd><p>Object of class <code>"list"</code>, representing the
noise distributions. The list contains one element for each
component of the MixAR model or a single element if the
noise distribution is the same for all components.
</p>
<p>If the distributions do not contain parameters (e.g. Gaussian or
<code class="reqn">t_4</code>) it is sufficient to give the list of functions in the
element <code>dist</code> of the list.
</p>
<p>If the distributions do contain parameters the recommended
arrangement is to give a list with components <code>generator</code> and
<code>param</code>, such that a call <code>generator(param)</code> should
produce the required list of distributions.
</p>
<p>This is not finalised but if changed, backward compatibility
with existing objects will be maintained.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+MixAR-class">MixAR</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>get_edist</dt><dd><p><code>signature(model = "MixARgen")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "MixARgen")</code>: ... </p>
</dd>
<dt>lik_params</dt><dd><p><code>signature(model = "MixARgen")</code>: ... </p>
</dd>
<dt>mix_cdf</dt><dd><p><code>signature(model = "MixARgen", x = "missing", index = "missing", xcond = "numeric")</code>: ... </p>
</dd> 
<dt>mix_cdf</dt><dd><p><code>signature(model = "MixARgen", x = "numeric", index = "missing", xcond = "numeric")</code>: ... </p>
</dd>
<dt>mix_cdf</dt><dd><p><code>signature(model = "MixARgen", x = "numeric", index = "numeric", xcond = "missing")</code>: ... </p>
</dd>
<dt>mix_pdf</dt><dd><p><code>signature(model = "MixARgen", x = "missing", index = "missing", xcond = "numeric")</code>: ... </p>
</dd>
<dt>mix_pdf</dt><dd><p><code>signature(model = "MixARgen", x = "numeric", index = "missing", xcond = "numeric")</code>: ... </p>
</dd>
<dt>mix_pdf</dt><dd><p><code>signature(model = "MixARgen", x = "numeric", index = "numeric", xcond = "missing")</code>: ... </p>
</dd>
<dt>noise_dist</dt><dd><p><code>signature(model = "MixARgen")</code>: ... </p>
</dd>
<dt>noise_params</dt><dd><p><code>signature(model = "MixARgen")</code>: ... </p>
</dd>
<dt>noise_rand</dt><dd><p><code>signature(model = "MixARgen")</code>: ... </p>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("MixARgen")

exampleModels$WL_ibm_gen@dist
noise_dist(exampleModels$WL_ibm_gen, "cdf")
noise_dist(exampleModels$WL_ibm_gen, "pdf")
noise_dist(exampleModels$WL_ibm_gen, "pdf", expand = TRUE)
noise_dist(exampleModels$WL_ibm_gen, "cdf", expand = TRUE)

## data(ibmclose, package = "fma")  # for `ibmclose'

pdf1 &lt;- mix_pdf(exampleModels$WL_ibm, xcond = as.numeric(fma::ibmclose))
cdf1 &lt;- mix_cdf(exampleModels$WL_ibm, xcond = as.numeric(fma::ibmclose))
gbutils::plotpdf(pdf1, cdf = cdf1, lq = 0.001, uq = 0.999)

pdf1gen &lt;- mix_pdf(exampleModels$WL_ibm_gen, xcond = as.numeric(fma::ibmclose))
cdf1gen &lt;- mix_cdf(exampleModels$WL_ibm_gen, xcond = as.numeric(fma::ibmclose))
gbutils::plotpdf(pdf1gen, cdf = cdf1gen, lq = 0.001, uq = 0.999)

length(fma::ibmclose)
cdf1gena &lt;- mix_cdf(exampleModels$WL_ibm_gen, xcond = as.numeric(fma::ibmclose)[-(369:369)])
pdf1gena &lt;- mix_pdf(exampleModels$WL_ibm_gen, xcond = as.numeric(fma::ibmclose)[-(369:369)])
gbutils::plotpdf(pdf1gena, cdf = cdf1gena, lq = 0.001, uq = 0.999)

pdf1a &lt;- mix_pdf(exampleModels$WL_ibm, xcond = as.numeric(fma::ibmclose)[-(369:369)])
cdf1a &lt;- mix_cdf(exampleModels$WL_ibm, xcond = as.numeric(fma::ibmclose)[-(369:369)])
gbutils::plotpdf(pdf1a, cdf = cdf1a, lq = 0.001, uq = 0.999)


cdf1gena &lt;- mix_cdf(exampleModels$WL_ibm_gen, xcond = as.numeric(fma::ibmclose)[-(369:369)])

cond_loglik(exampleModels$WL_ibm, as.numeric(fma::ibmclose))
cond_loglik(exampleModels$WL_ibm_gen, as.numeric(fma::ibmclose))

ts1gen &lt;- mixAR_sim(exampleModels$WL_ibm_gen, n = 30, init = c(346, 352, 357), nskip = 0)
plot(ts1gen)

plot(mixAR_sim(exampleModels$WL_ibm_gen, n = 100, init = c(346, 352, 357), nskip = 0),
     type = "l")

plot(diff(mixAR_sim(exampleModels$WL_ibm_gen, n = 100, init = c(346, 352, 357), nskip = 0)),
     type = "l")

noise_dist(exampleModels$WL_ibm_gen, "Fscore")

prob   &lt;- exampleModels$WL_ibm@prob
scale  &lt;- exampleModels$WL_ibm@scale
arcoef &lt;- exampleModels$WL_ibm@arcoef@a

mo_WLt3  &lt;- new("MixARgen", prob = prob, scale = scale, arcoef = arcoef,
                dist = list(fdist_stdt(3)))
mo_WLt30 &lt;- new("MixARgen", prob = prob, scale = scale, arcoef = arcoef,
                dist = list(fdist_stdt(30)))
</code></pre>

<hr>
<h2 id='mixARnoise_sim'>
Simulate white noise series from a list of functions and vector of regimes
</h2><span id='topic+mixARnoise_sim'></span>

<h3>Description</h3>

<p>Simulate white noise series from a list of functions and vector of
regimes. This function is used internally for simulation from  MixAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixARnoise_sim(rdist, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixARnoise_sim_+3A_rdist">rdist</code></td>
<td>
<p>a list of functions for random number generation, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="mixARnoise_sim_+3A_z">z</code></td>
<td>
<p>a vector of positive integers specifying the 'regimes'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the length of the list <code>rdist</code> is <code>max(z)</code>, then
<code>z[[i]]</code> is the random number generator for regime <code>i</code>.
Alternatively, if <code>rdist</code> is of length one, then the same
generator will be used for all regimes.
</p>
<p><code>mixARnoise_sim</code> returns a vector, say <code>y</code>, of the same
length as <code>z</code>, such that <code>y[i]</code> is generated by
<code>z[[i]]</code>.
</p>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixAR_sim">mixAR_sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## MixAR with 2 components: N(0,1) and t_5
set.seed = 1234
z &lt;- sample(2, size = 5, replace = TRUE)
mixARnoise_sim(list(rnorm, function(n) rt(n, 5)), z)
</code></pre>

<hr>
<h2 id='MixComp-class'>Class <code>"MixComp"</code> &mdash; manipulation of MixAR time series</h2><span id='topic+MixComp-class'></span><span id='topic+dim+2CMixComp-method'></span><span id='topic+-+2CMixComp+2Cmissing-method'></span><span id='topic+-+2CMixComp+2Cnumeric-method'></span><span id='topic+-+2Cnumeric+2CMixComp-method'></span><span id='topic++2A+2Ccharacter+2CMixComp-method'></span><span id='topic++2A+2Cfunction+2CMixComp-method'></span><span id='topic++2A+2CMixComp+2CMixComp-method'></span><span id='topic++2A+2CMixComp+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CMixComp-method'></span><span id='topic++2F+2CMixComp+2Cnumeric-method'></span><span id='topic++2F+2Cnumeric+2CMixComp-method'></span><span id='topic++2B+2CMixComp+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CMixComp-method'></span><span id='topic++5E+2CMixComp+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Class <code>"MixComp"</code> represents components of mixture autoregressive
time series and their transformations obtained by arithmetic and
related operations. Methods are provided to allow convenient
computation with such time series.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MixComp", ...)</code>. 
It is more usual however to obtain such objects initially
from functions such as <code>mix_ek</code>. Methods are defined to allow for
convenient and intuitive further manipulation of such objects.
</p>
<p>Internally, an object of class <code>MixComp</code> is a matrix with one column
for each component. However, methods for arithmetic operations
involving <code>MixComp</code> objects  are defined to perform natural
operations for mixture objects. For example, multiplication by
vectors is commutative and &ldquo;does the right thing&rdquo;.
</p>


<h3>Slots</h3>


<dl>
<dt><code>m</code>:</dt><dd>
<p>Object of class <code>"matrix"</code> with one column correponding to
each component of the mixture AR model.
</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Arithmetic operations involving <code>MixComp</code> objects are defined
to allow for convenient execution of computations for mixture
autoregressive models, see class <code>"<a href="#topic+MixComp-class">MixComp</a>"</code>.
</p>

<dl>
<dt>-</dt><dd><p><code>signature(e1 = "MixComp", e2 = "missing")</code>:
unary minus for &quot;MixComp&quot; objects.
</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "MixComp")</code>:
</p>
<p>If <code>e2</code> is thought of as a matrix, <code class="reqn">m</code>, then the number
of elements of <code>e1</code> must be the same as the number of rows
of <code class="reqn">m</code> and each column of <code class="reqn">m</code> is subtracted from
<code>e1</code>, see also <code>"mix_ek"</code>, <code>"mix_hatk"</code>.
</p>
<p>As a special case, if <code class="reqn">m</code> has only one row, then it is
subtracted from each element of <code>e1</code>, i.e. that row is
replicated to obtain a matrix with as many rows as the length of
<code>e1</code> and then subtracted from <code>e1</code> as above.
</p>
<p>The result is a <code>MixComp</code> object.
</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
This is analogous to the above method. (<b>FIXME:</b> the code
of this function does not deal with the special case as in the
above method. Is this an omission or I have done it on purpose?)
</p>
</dd>
<dt>%of%</dt><dd><p><code>signature(e1 = "function", e2 = "MixComp")</code>:
This applies the function <code>e1</code> to each element of
<code>e2</code>. Together with the arithmetic operations this allows for
easy computation with MixComp objects (e.g. pdfs, likelihoods).
</p>
</dd>
<dt>%of%</dt><dd><p><code>signature(e1 = "character", e2 = "MixComp")</code>:</p>
</dd>
<dt>%of%</dt><dd><p><code>signature(e1 = "list", e2 = "MixComp")</code>:
If <code>e1</code> is of length one it specifies a function to be
applied to each element of <code>e2</code>, otherwise it is a list of
functions, such that the <code class="reqn">i</code>th function is applied to the
<code class="reqn">i</code>th column of <code>e2@m</code>.
</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "MixComp", e2 = "MixComp")</code>: ... </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
see the following.
</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "MixComp")</code>:
&ldquo;Column&rdquo; <code class="reqn">i</code> of the <code>MixComp</code> object is multiplied by
the <code class="reqn">i</code>th element of the numeric vector, i.e. each &ldquo;row&rdquo;
of the <code>MixComp</code> object is multiplied by the vector (or, the
vector is replicated to a matrix to be multiplied by the
<code>MixComp</code> object).
</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "function", e2 = "MixComp")</code>:
Multiplying a function by  a <code>MixComp</code> object actually
applies the function to each element of the object.
This is a misuse of methods, prefer operator
<code>%of%</code> which does the same.
</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "character", e2 = "MixComp")</code>:
The first argument is a name of a function which is
applied to each element of the <code>MixComp</code> object. This is a
misuse of methods, see operator <code><a href="#topic+percent_of">%of%</a></code>
which does the same.  


</p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
</p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "numeric", e2 = "MixComp")</code>:
Division works analogously to <code>"*"</code>.
</p>
</dd>
<dt>^</dt><dd><p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
If <code>k</code> is a scalar, raise each element of <code>e1@m</code> to
power <code>k</code>.
</p>

<p>(For consistency this operation should have the
semantics of &quot;*&quot; and &quot;/&quot; but this operator probably makes sense
only for scalar 'e2', where the semantics doesn't matter. So,
don't bother for now.)
</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "MixComp")</code>:
</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
Addition involving <code>MixComp</code> objects works analogously to subtraction.
</p>
</dd>
<dt>inner</dt><dd><p><code>signature(x = "MixComp", y = "missing", star = "missing", plus = "missing")</code>:
With one argument <code>inner</code> computes the sum of the columns of
the argument. This is conceptually equivalent to <code>y</code> being a
vector of ones.
</p>
</dd>
<dt>inner</dt><dd><p><code>signature(x = "MixComp", y = "numeric", star = "missing", plus = "missing")</code>:
</p>
</dd>
<dt>inner</dt><dd><p><code>signature(x = "numeric", y = "MixComp", star = "missing", plus = "missing")</code>:
The number of elements of the numeric argument should be equal to
the number of rows of the <code>MixComp</code> object. Effectively,
computes the inner product of the two arguments. The order of the
arguments does not matter.

</p>
<p>Returns a numeric vector.
</p>
</dd>
<dt>inner</dt><dd><p><code>signature(x = "MixComp", y = "numeric", star = "ANY", plus = "ANY")</code>:
Computes a generalised inner product of <code>x</code> with <code>y</code> using the
specified functions in place of the usual &quot;*&quot; and &quot;+&quot;
operations. The defaults for <code>star</code> and <code>+</code> are
equivalent to multiplication and addition, respectively.
</p>
<p>Note that &quot;+&quot; is a binary operation (not <code class="reqn">n</code>-ary) in <span class="rlang"><b>R</b></span>. So
technically the correct way to specify the default operation here
is &quot;sum&quot; or <code>sum</code>. Since it is easy to make this mistake, if
<code>plus == "+"</code>, it is replaced by &quot;sum&quot;.
(In fact, <code>plus</code> is given a single argument, the vector of
values to work on. Since &quot;+&quot; works as a unary operator on one
argument, it would give surprising results if left as is.)
</p>
</dd>
<dt>inner</dt><dd><p><code>signature(x = "MixComp", y = "numeric", star = "ANY", plus = "missing")</code>:
This is a more efficient implementation for the case when
<code>plus = sum</code>.
</p>
</dd>
<dt>mix_ncomp</dt><dd><p><code>signature(x = "MixComp")</code>:
Number of components.
</p>
</dd>
<dt><code>signature(x = "MixComp")</code></dt><dd>
<p>A <code>"MixComp"</code> object is essentially a matrix. This method
gives the dimension of the underlying matrix. This method
indirectly ensures that <code>nrow()</code> and <code>ncol()</code> work
naturally for <code>"MixComp"</code> objects.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## dim, nrow, ncol
a &lt;- new("MixComp", m = matrix(c(1:7, 11:17, 21:27), ncol = 3))
a
dim(a)
nrow(a)
ncol(a)
mix_ncomp(a)

-a
a - 1:7 
1:7 + a
2*a


b &lt;- new("MixComp", m = matrix(rnorm(18), ncol = 3))

## apply a function to the columns of a MixComp object
pnorm %of% b

## apply a separate function to to each column
flist &lt;- list(function(x) pnorm(x),
              function(x) pt(x, df = 5),
              function(x) pt(x, df = 4) )
flist %of% b
</code></pre>

<hr>
<h2 id='mixFilter'>
Filter time series with MixAR filters
</h2><span id='topic+mixFilter'></span><span id='topic+mixFilter-methods'></span><span id='topic+mixFilter+2CANY+2CANY+2CANY-method'></span><span id='topic+mixFilter+2Cnumeric+2CraggedCoef+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Filter time series with MixAR filters, a generic function with no
default method (currently).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixFilter(x, coef, index, shift = 0, residual = FALSE, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixFilter_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="mixFilter_+3A_coef">coef</code></td>
<td>
<p>the filter coefficients</p>
</td></tr>
<tr><td><code id="mixFilter_+3A_index">index</code></td>
<td>
<p>indices for which to calculate the filtered values.</p>
</td></tr>
<tr><td><code id="mixFilter_+3A_shift">shift</code></td>
<td>
<p>optional shifts (intercept) terms.</p>
</td></tr>
<tr><td><code id="mixFilter_+3A_residual">residual</code></td>
<td>

<p>If FALSE (default) calculate &ldquo;predictions&rdquo;, if TRUE calculate
&ldquo;residuals&rdquo;.
</p>
</td></tr>
<tr><td><code id="mixFilter_+3A_scale">scale</code></td>
<td>

<p>optional scale factor(s), makes sense only when
<code>residual=TRUE</code>, corresponds to <code>scale</code> in the
specification of a MixAR model.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MixComp</code> object
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", coef = "ANY", index = "ANY")</code></dt><dd>
<p>This  method simply prints an error message and stops.
</p>
</dd>
<dt><code>signature(x = "numeric", coef = "raggedCoef", index = "numeric")</code></dt><dd>

</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+raghat1">raghat1</a></code>
<code><a href="#topic+mix_ek">mix_ek</a></code>
<code><a href="#topic+mix_hatk">mix_hatk</a></code>
</p>

<hr>
<h2 id='mixgenMstep'>
M-step for models from class MixARgen
</h2><span id='topic+mixgenMstep'></span>

<h3>Description</h3>

<p>M-step for models from class MixARgen. This function is for use by
other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixgenMstep(y, tau, model, index, fix = NULL, comp_sigma = FALSE,
            method = "BBsolve", maxit = 100, trace = FALSE,
            lessverbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixgenMstep_+3A_y">y</code></td>
<td>
<p>time series, a numeric vector.</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_tau">tau</code></td>
<td>
<p>conditional probabilities, an object of class &quot;MixComp&quot;.</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_model">model</code></td>
<td>
<p>the current model, an object from a subclass of class
&quot;MixAR&quot;.</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_index">index</code></td>
<td>
<p>indices of observations for which to compute residuals, a
vector of positive integers, see 'Details'.</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_method">method</code></td>
<td>
<p> optimisation or equation  solving method for package BB</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_...">...</code></td>
<td>
<p>arguments to pass on to optimisation functions, not
thought over yet. Do not use until this notice is removed.</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_comp_sigma">comp_sigma</code></td>
<td>
<p>If TRUE optimise the scale parameters using
univariate optimisation. (note: does not work with argument 'fix'
yet.)</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_fix">fix</code></td>
<td>
<p>specify parameters to be held fixed during optimisation,
see 'Details'.</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_maxit">maxit</code></td>
<td>
<p>maximal number of iterations for BB optimisers and
solvers. Meant mainly for testing.</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_trace">trace</code></td>
<td>
<p>if TRUE, BB optimisers and
solvers will print information about their proceedings. Meant mainly
for testing.</p>
</td></tr>
<tr><td><code id="mixgenMstep_+3A_lessverbose">lessverbose</code></td>
<td>
<p>if TRUE, print a dot instead of more verbose
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mixgenMstep</code> is an implementation of the M-step of the EM
algorithm for mixture autoregressive models specified by objects of
class &quot;MixARgen&quot;. The function was build and modified incrementally
with the main goal of providing flexibility. Speed will be addressed
later.
</p>
<p>By default optimisation is done with respect to all parameters.
Argument <code>fix</code> may be a list with elements &quot;prob&quot;, &quot;shift&quot;,
&quot;scale&quot; and &quot;arcoef&quot;. These elements should be logical vectors
containing <code>TRUE</code> in the positions of the fixed parameters.
Elements with no fixed parameters may be omitted. (Currently the
&quot;prob&quot; element is ignored, i.e. it is not possible to fix any of the
component probabilities.)
</p>
<p>If <code>fix = "shift"</code> the shift parameters are kept fixed. This is
equivalent to <code>fix = list(shift = rep(TRUE,g))</code>.
</p>
<p>The parameters (if any) of the distributions of the error components
are estimated by default. Currently the above method cannot be used to
fix some of them. 
This can be achieved however by modifying the distribution part of the
model since that incorporates information about the parameters and
whether they are fixed or not. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_mixAR">fit_mixAR</a></code> and
<code><a href="#topic+mixARgenemFixedPoint">mixARgenemFixedPoint</a></code>
which are meant to be called by users.
</p>

<hr>
<h2 id='mixMstep'>
Internal functions for estimation of MixAR models with Gaussian components
</h2><span id='topic+mixMstep'></span><span id='topic+tauCorrelate'></span><span id='topic+tau2arcoef'></span>

<h3>Description</h3>

<p>Internal functions for EM estimation of MixAR models with Gaussian components:
sums of products and crossproducts;
M-step for MixAR estimation;
estimation of autoregressive part of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauCorrelate(y, tau, order)
tau2arcoef(y, tau, order, est_shift = TRUE)
mixMstep(y, tau, order, index, est_shift = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixMstep_+3A_y">y</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="mixMstep_+3A_tau">tau</code></td>
<td>

<p>conditional probabilties for the observations to belong to each of
the components, a <code>MixComp</code> object.
</p>
</td></tr>
<tr><td><code id="mixMstep_+3A_order">order</code></td>
<td>

<p>order of the MixAR model, numeric vector of length the number of
mixture components.
</p>
</td></tr>
<tr><td><code id="mixMstep_+3A_index">index</code></td>
<td>

<p>indices of the observations to include in the likelihood
calculations, typically <code>(p+1):n</code>, where <code>p</code> is
<code>max(order)</code> and <code>n=length(y)</code>.
</p>
</td></tr>
<tr><td><code id="mixMstep_+3A_est_shift">est_shift</code></td>
<td>

<p>if TRUE include shifts (intercepts) in the AR components, otherwise
set them to zero.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mixMstep</code> performs an M-step for estimation of MixAR models with
Gaussian components.
</p>
<p><code>tauCorrelate</code> computes crossproducts needed for EM estimation
of MixAR models with Gaussian components.
</p>
<p><code>tau2arcoef</code> computes the AR coefficients by solving
Yule-Walker-type equations for each component.
</p>


<h3>Value</h3>

<p>For <code>mixMstep</code>, a MixAR model, an object of class <code>MixARGaussian</code>.
</p>
<p>For <code>tauCorrelate</code>, a named list with the following components:
</p>
<table>
<tr><td><code>Stau</code></td>
<td>
</td></tr> 
<tr><td><code>Stauy</code></td>
<td>
</td></tr>
<tr><td><code>Stauyy</code></td>
<td>
</td></tr>
</table>
<p>For <code>tau2arcoef</code>,   a list with two components:
</p>
<table>
<tr><td><code>shift</code></td>
<td>
<p>the shift (intercept) terms, a numeric vector</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>the AR coefficients as a list, whose i-th component contains
the coefficients for component i (as a numeric vector)</p>
</td></tr>
</table>

<hr>
<h2 id='mixSARfit'>
Fit mixture autoregressive models with seasonal AR parameters
</h2><span id='topic+mixSARfit'></span>

<h3>Description</h3>

<p>Provides estimation via EM-Algorithm for mixture autoregressive models
including seasonal AR parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixSARfit(y, model, est_shift = FALSE, tol = 10^-14)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixSARfit_+3A_y">y</code></td>
<td>
<p>a time series (currently a numeric vector).</p>
</td></tr>
<tr><td><code id="mixSARfit_+3A_model">model</code></td>
<td>

<p>an object of class <code>"MixAR"</code> including seasonal components.
</p>
</td></tr>
<tr><td><code id="mixSARfit_+3A_est_shift">est_shift</code></td>
<td>

<p>if missing or <code>FALSE</code>, fix the intercepts to zero, otherwise
estimate them.
</p>
</td></tr>
<tr><td><code id="mixSARfit_+3A_tol">tol</code></td>
<td>
<p>threshold for stopping criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function only works for <code>"MixAR"</code> objects in which slot
<code>arcoef</code> is of class <code>"raggedCoefS"</code>.
</p>


<h3>Value</h3>

<p>A list of 2:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>an object of class <code>"MixAR"</code>. The estimated model.</p>
</td></tr>
<tr><td><code>vallogf</code></td>
<td>

<p>the value of the loglikelihood function for the returned model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Davide Ravagli and Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar1 &lt;- list(c(0.5, -0.5), c(1.1, 0, -0.5))
ar12 &lt;- list(0, c(-0.3, 0.1))
s = 12

rag &lt;- new("raggedCoefS", a = ar1, as = ar12, s = s)

model &lt;- new("MixARGaussian", prob = exampleModels$WL_A@prob, # c(0.5, 0.5)
             scale = exampleModels$WL_A@scale,                # c(5, 1)
             arcoef = rag)

set.seed(1234)
y &lt;- mixAR_sim(model, n = 100, init = rep(0, 24))

mixSARfit(y, model)
## fix the intercepts to zero
mixSARfit(y, model, est_shift = FALSE, tol = 10e-4)
</code></pre>

<hr>
<h2 id='mixSubsolve'>
Support for EM estimation of MixAR models, internal function.
</h2><span id='topic+mixSubsolve'></span>

<h3>Description</h3>

<p>Solve the linear sub-system arising in the M-step of the EM algorithm
for MixAR models with Gaussian noise components. This gives estimates
of the parameters of the <code class="reqn">k</code>th AR component of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixSubsolve(k, pk, Stau, Stauy, Stauyy, shift, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixSubsolve_+3A_k">k</code></td>
<td>
<p>which component, an integer.</p>
</td></tr>
<tr><td><code id="mixSubsolve_+3A_pk">pk</code></td>
<td>
<p>AR order of the <code class="reqn">k</code>th component.</p>
</td></tr>
<tr><td><code id="mixSubsolve_+3A_stau">Stau</code>, <code id="mixSubsolve_+3A_stauy">Stauy</code>, <code id="mixSubsolve_+3A_stauyy">Stauyy</code></td>
<td>

<p>sums and cross-sums needed to form the system.
</p>
</td></tr>
<tr><td><code id="mixSubsolve_+3A_shift">shift</code></td>
<td>

<p>If <code>TRUE</code>, estimate also a shift, otherwise set the shift to 0.
</p>
</td></tr>
<tr><td><code id="mixSubsolve_+3A_tol">tol</code></td>
<td>
<p>tolerance, only used in case of trouble, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mixSubsolve</code> forms and solves a linear subsytem to obtain
estimates of the AR parameters (and the shift, if <code>shift</code> is
<code>TRUE</code>)  for the <code>k</code>-th MixAR component.
</p>
<p>First, <code>solve()</code> is tried. If it reports that the system is
(numerically) singular, a solution is computed using SVD with
tolerance <code>tol</code>.
</p>
<p>Note that argument <code>tol</code> is not used in the call to
<code>solve()</code>. The net effect is that <code>solve()</code> computes the
solution with its very small default tollerance. Probably I wanted
discontinuity during optimisation, which could result if using a
larger tolerance, and only resort to that if absolutely needed.
</p>
<p>I don't remember why I used pseudo-inverse in <code>mixSubsolve()</code>,
when <code>solve()</code> has a similar <code>tol</code> argument for its
QR-decomposition.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='mixVAR_sim'>Simulate from multivariate MixAR models
</h2><span id='topic+mixVAR_sim'></span>

<h3>Description</h3>

<p>Simulate data from multivariate MixAR models
under the assumptions of multivariate Gaussian innovarion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixVAR_sim(model, n, init, nskip = 100, flag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixVAR_sim_+3A_model">model</code></td>
<td>

<p>model from which to simulate, an object inheriting from class
<code>MixVAR</code>.
</p>
</td></tr>
<tr><td><code id="mixVAR_sim_+3A_n">n</code></td>
<td>
<p>size of simulated multivariate series.</p>
</td></tr>
<tr><td><code id="mixVAR_sim_+3A_init">init</code></td>
<td>

<p>initial values, a numeric matrix. If <code>missing</code>, a matrix of 0
values is generated.
</p>
</td></tr>
<tr><td><code id="mixVAR_sim_+3A_nskip">nskip</code></td>
<td>
<p>number of burn-in values.</p>
</td></tr>
<tr><td><code id="mixVAR_sim_+3A_flag">flag</code></td>
<td>

<p>if <code>TRUE</code> returns also the regimes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mixVAR_sim simulates a series of length <code>nskip + n</code> and returns
the last <code>n</code> values.  <code>init</code> provides initial values for the
algorithm. Each row is considered as a time point. The number of rows
must be at least equal to the maximal AR order.
</p>


<h3>Value</h3>

<p>a numeric <code>matrix</code> with <code>n</code> rows. 
</p>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mixAR_sim">mixAR_sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AR &lt;- list()
AR[[1]] &lt;- array(c(0.5,-0.3,-0.6,0,0,0.5,0.4,0.5,-0.3), dim = c(3,3,1))
AR[[2]] &lt;- array(c(-0.5,0.3,0,1,0,-0.5,-0.4,-0.2, 0.5), dim = c(3,3,1))

prob &lt;- c(0.75, 0.25)
shift &lt;- cbind(c(0,0,0), c(0,0,0))

Sigma1 &lt;- cbind(c(1, 0.5, -0.4), c(0.5, 2, 0.8), c(-0.4, 0.8, 4))
Sigma2 &lt;- cbind(c(1,0.2, 0), c(0.2, 2, -0.15), c(0, -0.15, 4))
Sigma &lt;- array(c(Sigma1, Sigma2), dim = c(3,3,2))

m &lt;- new("MixVARGaussian", prob=prob, vcov=Sigma, arcoef=AR, shift=shift)
mixVAR_sim(m, n=500, init=matrix(rep(0,3), ncol=3), nskip=100, flag=FALSE)
</code></pre>

<hr>
<h2 id='MixVAR-class'>Class <code>"MixVAR"</code> &mdash; mixture vector autoregressive models </h2><span id='topic+MixVAR-class'></span>

<h3>Description</h3>

<p>Mixture vector autoregressive models</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.
</p>
<p>Derived classes add distribution properties, e.g. use class
<code>"<a href="#topic+MixVARGaussian-class">MixVARGaussian</a>"</code> for MixVAR models with Gaussian
error components.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prob</code>:</dt><dd>
<p>the mixing probabilities,
an object of class <code>"numeric"</code>
</p>
</dd>
<dt><code>order</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>shift</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"array"</code> ~~ </p>
</dd>
<dt><code>arcoef</code>:</dt><dd><p>Object of class <code>"raggedCoefV"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>fit_mixVAR</dt><dd><p><code>signature(x = "ANY", model = "MixAR")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>See Also</h3>


<p>class <code>"<a href="#topic+MixVARGaussian-class">MixVARGaussian</a>"</code>
</p>

<hr>
<h2 id='mixVARfit'>
Fit mixture vector autoregressive models
</h2><span id='topic+mixVARfit'></span>

<h3>Description</h3>

<p>Provides EM-estimation of mixture autoregressive models for
multivariate time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixVARfit(y, model, fix = FALSE, tol = 10^-6, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixVARfit_+3A_y">y</code></td>
<td>
<p>a data matrix.</p>
</td></tr>
<tr><td><code id="mixVARfit_+3A_model">model</code></td>
<td>

<p>an object of class <code>"MixVAR"</code> with initial values of parameter
for EM estimation.
</p>
</td></tr>
<tr><td><code id="mixVARfit_+3A_tol">tol</code></td>
<td>

<p>Threshold for convergence criterion.
</p>
</td></tr>
<tr><td><code id="mixVARfit_+3A_fix">fix</code></td>
<td>
<p>if TRUE, fix the shift parameters.</p>
</td></tr>
<tr><td><code id="mixVARfit_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> print information during the optimisation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation is done under the assumption of multivariate Gaussian
innovations.
</p>


<h3>Value</h3>

<p>An object of class <code>MixVARGaussian</code> with EM estimates of model
parameters.  
</p>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>References</h3>

<p>Fong PW, Li WK, Yau CW, Wong CS (2007).
&ldquo;On a Mixture Vector Autoregressive Model.&rdquo;
<em>The Canadian Journal of Statistics / La Revue Canadienne de Statistique</em>, <b>35</b>(1), 135&ndash;150.
ISSN 03195724, <a href="https://doi.org/10.1002/cjs.5550350112">doi:10.1002/cjs.5550350112</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_mixVAR-methods">fit_mixVAR-methods</a></code> for examples
</p>

<hr>
<h2 id='MixVARGaussian-class'>
MixVAR models with multivariate Gaussian noise components
</h2><span id='topic+MixVARGaussian-class'></span><span id='topic+MixVARGaussian'></span>

<h3>Description</h3>

<p>Class MixVARGaussian represents MixAR models with multivariate
Gaussian noise components.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("MixVARGaussian", ...)</code>, giving the elements of the model as
named arguments, see the examples below.
</p>
<p><code>arcoef</code> contains the AR coefficients, one numeric array for
each mixture component. It can be given as a
<code>"<a href="#topic+raggedCoefV-class">raggedCoefV</a>"</code> object or as a list of numeric
arrays.
</p>
<p>The AR order of the model is inferred from <code>arcoef</code>
argument. If argument <code>order</code> is given, it is checked for
consistency with <code>arcoef</code>.  The <code>shift</code> slot defaults to a
matrix of zeroes and the <code>vcov</code> slot to an array of 
identity matrices, one for each component.
</p>
<p>The distribution of the noise components is standard multivariate
Gaussian, N(0,1).
</p>


<h3>Slots</h3>

<p>All slots except <code>arcoef</code> are numeric vectors of length
equal to the number of components in the model.
</p>

<dl>
<dt><code>prob</code>:</dt><dd>
<p>probabilities of the mixture components,
</p>
</dd>
<dt><code>order</code>:</dt><dd>
<p>AR orders of the components,
</p>
</dd>
<dt><code>shift</code>:</dt><dd>
<p>the shift (intercept) terms of the AR components,
</p>
</dd>
<dt><code>vcov</code>:</dt><dd>
<p>covariance matrices of the noise terms of the AR components,
</p>
</dd>
<dt><code>arcoef</code>:</dt><dd>
<p>The AR components, object of class <code>"raggedCoefV"</code>.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+MixAR-class">MixAR</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>fit_mixAR</dt><dd><p><code>signature(x = "ANY", model =	"MixARGaussian")</code>:
... 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>See Also</h3>


<p>class <code>"<a href="#topic+MixAR-class">MixAR</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MixVARGaussian")

## Create array of covariance matrices
Sigma1 &lt;- cbind(c(0.0013, 0.0011), c(0.0011, 0.0012))
Sigma2 &lt;- cbind(c(0.0072, 0.0047), c(0.0047, 0.0039))
Sigma  &lt;- array(c(Sigma1, Sigma2), dim=c(2,2,2))

## Create list of AR coefficients
AR &lt;- list()
AR[[1]] &lt;- array(c(0.0973, -0.0499,  0.2927,  0.4256,  ## VAR(2;4)
                  -0.0429,  0.0229, -0.1515, -0.1795,
                  -0.0837, -0.1060, -0.1530,  0.1947,
                  -0.1690, -0.0903,  0.1959,  0.0955), dim=c(2,2,4))
AR[[2]] &lt;- array(c(0.3243,  0.2648,  0.4956,  0.2870,  ## VAR(2;3)
                  -0.1488,  0.0454, -0.0593, -0.3629,
                   0.1314,  0.0274,  0.0637,  0.0485), dim=c(2,2,3))

## Create vector of mixing weights
prob &lt;- c(0.6376, 0.3624)

## Create matrix of shift parameters
shift &lt;- cbind(c(0.0044, 0.0020), c(-0.0039, -0.0014))

## Build "MixVARGaussian" model
new("MixVARGaussian", prob=prob, vcov=Sigma, arcoef=AR, shift=shift)
</code></pre>

<hr>
<h2 id='multiStep_dist-methods'>Multi-step predictions for MixAR models</h2><span id='topic+multiStep_dist'></span><span id='topic+multiStep_dist-methods'></span><span id='topic+multiStep_dist+2CMixAR+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+multiStep_dist+2CMixARGaussian+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic+multiStep_dist+2CMixARGaussian+2Cnumeric+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>Multi-step predictions for MixAR models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiStep_dist(model, maxh, N, xcond, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiStep_dist-methods_+3A_model">model</code></td>
<td>
<p>a MixAR model.</p>
</td></tr>
<tr><td><code id="multiStep_dist-methods_+3A_maxh">maxh</code></td>
<td>
<p>maximal horizon, a positive integer.</p>
</td></tr>
<tr><td><code id="multiStep_dist-methods_+3A_n">N</code></td>
<td>

<p>an integer specifying the number of simulation samples to use, see
'Details. This argument is used only by simulation based methods.
</p>
</td></tr>
<tr><td><code id="multiStep_dist-methods_+3A_xcond">xcond</code></td>
<td>

<p>the past values needed for the conditional distribution, a numeric
vector of length at least the maximal AR order of the components.
</p>
</td></tr>
<tr><td><code id="multiStep_dist-methods_+3A_...">...</code></td>
<td>

<p>used only in some methods, see the details for the individual
methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently implements two methods: the exact method due to
Boshnakov (2009) and a simulation
method described by (Wong and Li 2000) for Gaussian MixAR
models but valid more generally.
</p>
<p>The simulation method is available for any MixAR model, while
the exact method is currently implemented only for models with
Gaussian components (&quot;MixARGaussian&quot; class).
</p>
<p><code>multiStep_dist</code> returns a function which can be used to obtain
various properties of the predictive distribution for lags up to
<code>maxh</code>.
</p>
<p>If argument <code>N</code> is missing the exact method is tried. Currently
an error will result if the exact method is not implemented for
<code>model</code>.
</p>
<p>If argument <code>N</code> is given it must be a scalar numeric value, the
number of simulations to be performed to construct an approximation
for the predictive distributions.
</p>
<p>The simulation is done by <code>multiStep_dist</code>. The properties
obtained later from the function returned by <code>multiStep_dist</code> use
the samples generated by the call to <code>multiStep_dist</code>.
To do a simulation with different parameters (e.g., with larger
<code>N</code>) call <code>multiStep_dist</code> again.
</p>


<h4>Details on the returned function</h4>

<p>If <code>xcond</code> is missing <code>multiStep_dist</code> returns a function
with arguments <code>h</code>, <code>what</code> and <code>xcond</code>.

If <code>xcond</code> is supplied, then it is fixed to that value and the
arguments of the returned function are <code>h</code>, <code>what</code> and
<code>'...'</code>. The dots argument is currently used in the case of the
simulation method, see below.
</p>
<p>Let <code>f</code> be the function returned by <code>multiStep_dist</code>.
Argument <code>h</code> is the required prediction horizon and can be a
number in the interval <code class="reqn">[1,maxh]</code>. Argument <code>what</code> is the
required property of the predictive distribution for lag
<code>h</code>. If <code>what</code> is a function, it is applied to the simulated
sample for the requested horizon (currently available only for
the simulation method). If <code>what</code> is a character string, the
corresponding property of the predictive distribution for horizon
<code>h</code> is returned.
Currently possible values for <code>what</code> are:
</p>

<dl>
<dt>&quot;pdf&quot;</dt><dd><p>the probability density function.</p>
</dd>
<dt>&quot;cdf&quot;</dt><dd><p>the cumulative distribution function.</p>
</dd>
<dt>&quot;location&quot;</dt><dd><p>the location (conditional mean).</p>
</dd>
<dt>&quot;variance&quot;</dt><dd><p>the conditional variance, a.k.a (squared) volatility.</p>
</dd>
<dt>&quot;sd&quot;</dt><dd><p>the conditional standard deviation, a.k.a volatility.</p>
</dd>
<dt>&quot;skewness&quot;</dt><dd><p>the conditional skewness.</p>
</dd>
<dt>&quot;kurtosis&quot;</dt><dd><p>the conditional kurtosis.</p>
</dd>
</dl>

<p>Note that <code>what = "pdf"</code> and <code>what = "cdf"</code> return functions
even in the simulation case. For &quot;pdf&quot; the function is constructed
using <code>density</code> and the <code>"..."</code> arguments passed to <code>f</code> will
be passed on to <code>density</code> if finer control is needed.
</p>
<p>If <code>what</code> is none of the above, the raw object is returned
currently (but this may change).
</p>



<h3>Value</h3>

<p>a function as described in sections &lsquo;Details&rsquo; and &lsquo;Methods&rsquo;
</p>


<h3>Methods</h3>

<p>The Details section gives a rather detailed description of the
function, so the descriptions below are brief.
</p>

<dl>
<dt><code>signature(model = "MixAR", maxh = "numeric", N = "numeric",
	xcond = "numeric")</code></dt><dd> 
<p>Non-missing <code>N</code> requests the simulation method. The
predictive distribution is approximated by simulating <code>N</code>
of future paths up to horizon <code>maxh</code> and using a
non-parametric estimate. Arguments <code>"..."</code> are passed to
<code>density</code> to allow finer control.
</p>
</dd>
<dt><code>signature(model = "MixARGaussian", maxh = "numeric", N = "missing", 
	xcond = "missing")</code></dt><dd>
<p>Computes the predictive distribution using the exact method.
Returns a function with arguments <code>h</code>, <code>what</code> and <code>xcond</code>.
</p>
</dd>
<dt><code>signature(model = "MixARGaussian", maxh = "numeric", N = "missing",
	xcond = "ANY")</code></dt><dd>
<p>Computes the predictive distribution using the exact method.
Returns a function with arguments <code>h</code> and <code>what</code>.
(i.e., <code>xcond</code> is fixed to the supplied argument <code>xcond</code>).
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (2009).
&ldquo;Analytic expressions for predictive distributions in mixture autoregressive models.&rdquo;
<em>Stat. Probab. Lett. </em>, <b>79</b>(15), 1704-1709.
<a href="https://doi.org/10.1016/j.spl.2009.04.009">doi:10.1016/j.spl.2009.04.009</a>.<br /><br /> Wong CS, Li WK (2000).
&ldquo;On a mixture autoregressive model.&rdquo;
<em>J. R. Stat. Soc., Ser. B, Stat. Methodol. </em>, <b>62</b>(1), 95-115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict_coef">predict_coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## exact method, without xcond
dist &lt;- multiStep_dist(exampleModels$WL_ibm, maxh = 3)

tfpdf &lt;- dist(3, "pdf", xcond = c(560, 600)) # xcond is argument to 'dist' here
tfcdf &lt;- dist(3, "cdf", xcond = c(560, 600))
## plot the pdf (gbutils::plotpdf determines suitable range automatically)
gbutils::plotpdf(tfpdf, cdf = tfcdf)

args(dist(3, "pdf", xcond = c(500, 600)))  # x

## use a simulation method with N = 1000
tf  &lt;- multiStep_dist(exampleModels$WL_ibm, maxh = 3, N = 1000, xcond = c(560, 600))
args(tf) # (h, what, ...)

## the exact method may also be used with fixed xcond:
tfe &lt;- multiStep_dist(exampleModels$WL_ibm, maxh = 3, xcond = c(560, 600))

## get pdf and cdf for horizon 3
tfepdf &lt;- tfe(3, "pdf")
tfecdf &lt;- tfe(3, "cdf")
## plot the pdf
gbutils::plotpdf(tfepdf, cdf = tfecdf)

tf(3, "location")

tf(1, "location")
mix_location(exampleModels$WL_ibm, xcond = c(560, 600))

## larger simulation gives better approximation, in general
tf &lt;- multiStep_dist(exampleModels$WL_ibm, maxh = 3, N = 10000, xcond = c(560, 600))
tf(1, "location")

tf1000pdf &lt;- tf(3, "pdf")
tf1000cdf &lt;- tf(3, "cdf")
gbutils::plotpdf(tf1000pdf, cdf = tf1000cdf)

## plot the exact and simulated pdf's together for comparison
gbutils::plotpdf(tfepdf, cdf = tfecdf)
curve(tf1000pdf, add = TRUE, col = "red")

## get the raw data
tfs &lt;- tf(1, "sampled")
apply(tfs, 2, mean) # location for lags from 1 to maxh (here 3)

tf(1, "location")
tf(1, "variance")
tf(1, "sd")
mix_variance(exampleModels$WL_ibm, xcond = c(560, 600))
sqrt(mix_variance(exampleModels$WL_ibm, xcond = c(560, 600)))

mix_kurtosis(exampleModels$WL_ibm, xcond = c(359, 200))
mix_kurtosis(exampleModels$WL_ibm, xcond = c(359, 400))
</code></pre>

<hr>
<h2 id='noise_dist'>Internal mixAR functions</h2><span id='topic+get_edist'></span><span id='topic+noise_dist'></span><span id='topic+noise_rand'></span><span id='topic+noise_params'></span><span id='topic+set_noise_params'></span>

<h3>Description</h3>

<p>Functions for the distributions of the components of MixAR models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edist(model)
noise_dist(model, what, expand = FALSE)
noise_rand(model, expand = FALSE)
noise_params(model)
set_noise_params(model, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noise_dist_+3A_model">model</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="noise_dist_+3A_what">what</code></td>
<td>
<p>the property, a character string.</p>
</td></tr>
<tr><td><code id="noise_dist_+3A_expand">expand</code></td>
<td>
<p>if TRUE, expand the list to length equal to the number
of components, see Details.</p>
</td></tr>
<tr><td><code id="noise_dist_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_edist</code> gives the distributions of the noise components of
<code>model</code>.
<code>noise_dist</code> gives property <code>what</code> of the noise
distribution.
<code>noise_rand</code> gives a list of functions for simulation from the
component distributions.
</p>
<p>In each case, the list contains one element for each component but if
it is of length one, then the only element is common for all
components.  To force a complete list even in this case, use
<code>expand = TRUE</code>.
</p>
<p><code>noise_params</code> gives the parameters of the model as a numeric
vector.



</p>
<p>The distribution is specified as a list. Element &quot;dist&quot; contain the
distribution. Element &quot;generator&quot; is a function that generates a
distribution like the one specified. If &quot;dist&quot; is absent or NULL, the
generator is called to generate a distribution object.
</p>
<p>Initially the distribution itself was used for slot <code>dist</code>. For
compatibility with old code using that format, this is still
supported.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+fdist_stdnorm">fdist_stdnorm</a></code>,
<code><a href="#topic+fdist_stdt">fdist_stdt</a></code>,
<code><a href="#topic+fn_stdt">fn_stdt</a></code>.
</p>

<hr>
<h2 id='noise_dist-methods'> Methods for function <code>noise_dist</code> in package <span class="pkg">mixAR</span> </h2><span id='topic+noise_dist-methods'></span><span id='topic+noise_dist+2CMixAR-method'></span><span id='topic+noise_dist+2CMixARGaussian-method'></span><span id='topic+noise_dist+2CMixARgen-method'></span>

<h3>Description</h3>

<p>Methods for function <code>noise_dist</code> in package <span class="pkg">mixAR</span>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARGaussian")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARgen")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+noise_dist">noise_dist</a></code>
</p>

<hr>
<h2 id='noise_moment-methods'>Compute moments of the noise components</h2><span id='topic+noise_moment'></span><span id='topic+noise_moment-methods'></span><span id='topic+noise_moment+2CANY+2CANY-method'></span><span id='topic+noise_moment+2CMixARGaussian+2Cnumeric-method'></span><span id='topic+noise_moment+2CMixARgen+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Compute moments of the noise components.</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_moment(model, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noise_moment-methods_+3A_model">model</code></td>
<td>
<p>a MixAR model.</p>
</td></tr>
<tr><td><code id="noise_moment-methods_+3A_k">k</code></td>
<td>
<p>which moment to compute?</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "ANY", k = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARGaussian", k = "numeric")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARgen", k = "numeric")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='noise_params-methods'> Methods for function <code>noise_params</code> in package <span class="pkg">mixAR</span> </h2><span id='topic+noise_params-methods'></span><span id='topic+noise_params+2CMixAR-method'></span><span id='topic+noise_params+2CMixARgen-method'></span>

<h3>Description</h3>

<p>Methods for function <code>noise_params</code> in package <span class="pkg">mixAR</span>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARgen")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='noise_rand-methods'> Methods for function <code>noise_rand</code> in package <span class="pkg">mixAR</span> </h2><span id='topic+noise_rand-methods'></span><span id='topic+noise_rand+2CMixAR-method'></span><span id='topic+noise_rand+2CMixARGaussian-method'></span><span id='topic+noise_rand+2CMixARgen-method'></span>

<h3>Description</h3>

<p>Methods for function <code>noise_rand</code> in package <span class="pkg">mixAR</span>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "MixAR")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARGaussian")</code></dt><dd>
</dd>
<dt><code>signature(model = "MixARgen")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='parameters'>Set or extract the parameters of MixAR objects</h2><span id='topic+parameters'></span><span id='topic+parameters-methods'></span><span id='topic+parameters+2CANY-method'></span><span id='topic+parameters+2CMixAR-method'></span><span id='topic+parameters+3C-'></span><span id='topic+parameters+3C--methods'></span><span id='topic+parameters+3C-+2CANY-method'></span><span id='topic+parameters+3C-+2CMixAR-method'></span><span id='topic+set_parameters'></span><span id='topic+set_parameters-methods'></span><span id='topic+set_parameters+2CANY-method'></span><span id='topic+set_parameters+2CMixAR-method'></span>

<h3>Description</h3>

<p>Set or extract the parameters of MixAR objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(model, namesflag = FALSE, drop = character(0))

parameters(model) &lt;- value
## S4 replacement method for signature 'MixAR'
parameters(model) &lt;- value
## S4 replacement method for signature 'ANY'
parameters(model) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameters_+3A_model">model</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="parameters_+3A_namesflag">namesflag</code></td>
<td>
<p>if TRUE, generate names.</p>
</td></tr>
<tr><td><code id="parameters_+3A_drop">drop</code></td>
<td>

<p>names of parameters not to include in the returned value, a
character vector. The default is to return all parameters, see
Details.
</p>
</td></tr>
<tr><td><code id="parameters_+3A_value">value</code></td>
<td>
<p>values of the parameters, numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function. The dispatch is on argument <code>model</code>.
The default calls <code>coef</code>.
</p>
<p><code>parameters</code> extracts the parameters of a MixAR object. It
returns a numeric vector. If <code>namesflag</code> is <code>TRUE</code> the
returned vector is named, so that the parameters can be referred to by
names. Argument <code>drop</code> is a character vector giving names of
parameters not to be included in the returned value.
</p>
<p>This function can be useful for setting parameters from optimisation
routines.
</p>
<p><code>set_parameters</code> is deprecated,
use <code>parameters(model) &lt;- value</code> instead.
</p>


<h3>Value</h3>

<p>a vector of parameters, maybe with names.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "ANY")</code></dt><dd>

</dd>
<dt><code>signature(model = "MixAR")</code></dt><dd>

</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>parameters(exampleModels$WL_ibm)
parameters(exampleModels$WL_ibm, namesflag = TRUE)
## drop orders
parameters(exampleModels$WL_ibm, namesflag = TRUE, drop = "order")
## drop orders and mixing weights
parameters(exampleModels$WL_ibm, namesflag = TRUE, drop = c("order", "prob"))

parameters(exampleModels$WL_I,  namesflag = TRUE)
parameters(exampleModels$WL_II, namesflag = TRUE)
</code></pre>

<hr>
<h2 id='percent_of'>
Infix operator to apply functions to matrix-like objects
</h2><span id='topic+percent_of'></span><span id='topic++25of+25'></span><span id='topic++25of+25-methods'></span><span id='topic++25of+25+2CANY+2CANY-method'></span><span id='topic++25of+25+2Ccharacter+2CMixComp-method'></span><span id='topic++25of+25+2Cfunction+2CMixComp-method'></span><span id='topic++25of+25+2Clist+2CMixComp-method'></span>

<h3>Description</h3>

<p>The infix operator <code>%of%</code> is a generic function which applies
functions to objects.  This page describes the function and the
methods defined in package <span class="pkg">mixAR</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"%of%"(e1, e2)
e1 %of% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percent_of_+3A_e1">e1</code></td>
<td>

<p>usually a function, the name of a function, a character vector, or a
list of functions, see Details.
</p>
</td></tr>
<tr><td><code id="percent_of_+3A_e2">e2</code></td>
<td>
<p>an object, usually matrix-like.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>%of%</code> is a generic function with dispatch on both arguments.
It is intended to be used mainly in infix form.
</p>
<p><code>%of%</code> transforms each &ldquo;column&rdquo; of a matrix-like object by a
function. If <code>e1</code> specifies a single function, that is applied to all
columns. Otherwise <code>length(e1)</code> should equal the number of 
&ldquo;columns&rdquo; of <code>e2</code> and <code>e1[[i]]</code> is applied to the
<code>i</code>-th &ldquo;column&rdquo; of <code>e2</code>.
</p>
<p>The mental model is that the first argument, <code>e1</code>, is (converted
to) a list of functions containing one function for each column of
<code>e2</code>. The i-th function is applied to each element of the i-th
column.
</p>
<p>The methods for <code>"MixComp"</code> objects allow for very transparent
and convenient computing with <code>"MixAR"</code> objects.
</p>


<h3>Value</h3>

<p>for the default method, a matrix;
</p>
<p>for methods with <code>e2</code> from class <code>MixComp</code>, a <code>MixComp</code>
object with its slot <code>m</code> replaced by the result of applying
<code>e1</code> to its elements, see the descriptions of the individual
methods for details;
</p>


<h3>Methods</h3>

<p>Below are the descriptions of the methods for <code>%of%</code> defined by
package <span class="pkg">mixAR</span>.
</p>

<dl>
<dt><code>signature(e1 = "ANY", e2 = "ANY")</code></dt><dd>
<p>This is the default method. It uses <code>apply()</code> to evaluate
<code>e1</code> for each element of the matrix <code>e2</code>, without
checking the arguments. If the arguments are not suitable for
<code>apply()</code>, any error messages will come from it. So, for this
method <code>e1</code> is a function (or the name of a function) and
<code>e2</code> is a matrix or array.
</p>
</dd>
<dt><code>signature(e1 = "function", e2 = "MixComp")</code></dt><dd>
<p>Create (and return) a <code>MixComp</code> object with its slot <code>m</code>
replaced by the result of applying the function <code>e1</code> to each
element of the <code>MixComp</code> object <code>e2</code>, see class
<code>"<a href="#topic+MixComp-class">MixComp</a>"</code>.
</p>
</dd>
<dt><code>signature(e1 = "character", e2 = "MixComp")</code></dt><dd>
<p>Here <code>e1</code> contains the names of one or more functions.  If
<code>length(e1) = 1</code>, this is equivalent to the method for
<code>e1</code> of class <code>"function"</code>.
</p>
<p>If <code>length(e1) &gt; 1</code>, then for each <code>i</code> the function
specified by <code>e1[i]</code> is applied to the <code>i</code>th column of
<code>e2@m</code>.  In this case there is no recycling: <code>e1</code> must
have <code>ncol(e2@m)</code> elements.
</p>
</dd>
<dt><code>signature(e1 = "list", e2 = "MixComp")</code></dt><dd>
<p>Here each element of <code>e1</code> is a function or the name of a
function. It works analogously to the method with <code>e1</code> from
class <code>"character"</code>.  If <code>length(e1) = 1</code>, then
<code>e1[[1]]</code> is applied to each element of
<code>e1@m</code>. Otherwise, if <code>length(e1) &gt; 1</code>, then
<code>e1[[i]]</code> is applied to the <code>i</code>th column of <code>e2@m</code>.
</p>
</dd>
</dl>


<h3>Note</h3>

<p>The code is rather inefficient for some of the methods. 
</p>
<p>Maybe should require that the functions in the first argument are
vectorised. (Some methods effectively assume it.)
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p>class <code>"<a href="#topic+MixComp-class">MixComp</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(rnorm(18), ncol = 3)
## defult method
pm1 &lt;- pnorm %of% m
f3 &lt;- list(pnorm, function(x, ...) pnorm(x, mean = 0.1),
                  function(x, ...) pnorm(x, mean = -0.1) )
## no method for f from "list" yet:
## pm2 &lt;- f3 %of% m

mc &lt;- new("MixComp", m = m)
pnorm %of% mc
pmc3 &lt;- f3 %of% mc
## result is equivalent to applying f3[[i] to m[ , i]:
all.equal(pmc3@m, cbind(f3[[1]](m[ , 1]), f3[[2]](m[ , 2]), f3[[3]](m[ , 3])))
</code></pre>

<hr>
<h2 id='permn_cols'>All permutations of the columns of a matrix</h2><span id='topic+permn_cols'></span>

<h3>Description</h3>

<p>All permutations of the columns of a matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>permn_cols(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permn_cols_+3A_m">m</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for   <code>permn</code> from package &lsquo;combinat&rsquo;.
</p>


<h3>Value</h3>

<p>a list with one element for each permutation of the columns. Each
element of the list is an unnamed list with two components:
</p>

<ol>
<li><p> the permutation, a vector of positive integers,
</p>
</li>
<li><p> a matrix obtained by permuting the columns of <code>m</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(11:14,21:24,31:34), ncol=3)
pm &lt;- permn_cols(m)
pm[[2]]
</code></pre>

<hr>
<h2 id='PortfolioData1'>Closing prices of four stocks</h2><span id='topic+PortfolioData1'></span>

<h3>Description</h3>

<p>Closing prices of four stocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("PortfolioData1")
</code></pre>


<h3>Format</h3>

<p>A data frame with 867 observations on the following 4 variables.
</p>

<dl>
<dt><code>DELL</code></dt><dd><p>numeric, Dell Technologies Inc.</p>
</dd>
<dt><code>MSFT</code></dt><dd><p>numeric, Microsoft Corporation.</p>
</dd>
<dt><code>INTC</code></dt><dd><p>numeric, Intel Corporation.</p>
</dd>
<dt><code>IBM</code></dt><dd><p>numericr, International Business Machine Corporation.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Time series of daily adjusted close prices of the above stocks from 2
January 2016 to 29 January 2020 (867 observations).
</p>


<h3>Source</h3>

<p>&lsquo;<span class="samp">&#8288;https://finance.yahoo.com/&#8288;</span>&rsquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PortfolioData1)
dim(PortfolioData1)
head(PortfolioData1)
</code></pre>

<hr>
<h2 id='predict_coef'>Exact predictive parameters for multi-step MixAR prediction</h2><span id='topic+predict_coef'></span>

<h3>Description</h3>

<p>Exact predictive parameters for multi-step MixAR prediction.</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_coef(model, maxh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_coef_+3A_model">model</code></td>
<td>
<p>a MixAR model.</p>
</td></tr>
<tr><td><code id="predict_coef_+3A_maxh">maxh</code></td>
<td>
<p>maximal horizon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict_coef()</code> implements the method of
Boshnakov (2009) for the h-step prediction
of MixAR processes. The h-step predictive distribution has a MixAR
distribution with <code class="reqn">g^h</code> components and this function computes its
parameters.
</p>
<p><code>predict_coef()</code> implements the results by
Boshnakov (2009) to compute the parameters
of the predictive distributions.  <code>predict_coef()</code> is mostly a
helper function, use <code><a href="#topic+multiStep_dist">multiStep_dist</a></code> for
prediction/forecasting (the exact method for <code><a href="#topic+multiStep_dist">multiStep_dist</a></code> 
uses <code>predict_coef()</code> to do the main work).
</p>
<p><code>predict_coef()</code> returns a list of lists containing the
quantities needed for each horizon <code class="reqn">h</code>, see section Value. 
</p>
<p>Alternatiely, the parameters can be obtained as MixAR models
by calling the function generated by the exact method of
<code><a href="#topic+multiStep_dist">multiStep_dist</a></code> with argument <code>what = "MixAR"</code>.
</p>


<h3>Value</h3>

<p>a list with components:
</p>
<table>
<tr><td><code>arcoefs</code></td>
<td>
<p>a list, <code>arcoefs[[h]]</code> gives the ar coefficients
for the h-step predictive distribution.</p>
</td></tr>
<tr><td><code>sigmas</code></td>
<td>
<p>a list, <code>sigmas[[h]]</code>
sigmas[[h]] is a matrix, in which the <code class="reqn">k</code>th column contains
the theta coefficients needed to compute <code class="reqn">sigma_k</code> in the formula for
sigma in Equation (16) (see Boshnakov 2009). In the
paper the index is a tuple <code class="reqn">(k_1,…,k_h)</code> for clarity. In the
code each tuple <code class="reqn">(k_1,…,k_h)</code> is mapped to a linear index in
<code class="reqn">1,\ldots,g^h</code> (there are <code class="reqn">g^h</code> tuples for horizon <code class="reqn">h</code>,
since the mixture has <code class="reqn">g^h</code> components).</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>a list, <code>probs[[h]]</code> gives the mixture weights
for the h-step predictive distribution.</p>
</td></tr>
<tr><td><code>sStable</code></td>
<td>
<p>a list, <code>sigmas[[h]]</code> gives the scale parameters
for the h-step predictive distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (2009).
&ldquo;Analytic expressions for predictive distributions in mixture autoregressive models.&rdquo;
<em>Stat. Probab. Lett. </em>, <b>79</b>(15), 1704-1709.
<a href="https://doi.org/10.1016/j.spl.2009.04.009">doi:10.1016/j.spl.2009.04.009</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiStep_dist">multiStep_dist</a></code>
</p>

<hr>
<h2 id='ragged'>
Small utilities for ragged objects
</h2><span id='topic+rag_modify'></span><span id='topic+ragged2vec'></span>

<h3>Description</h3>

<p>Small utilities for ragged objects.
Modify the elements of raggedCoef objects, extract them as a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rag_modify(rag, v)
ragged2vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ragged_+3A_rag">rag</code></td>
<td>
<p>the <code>raggedCoef</code> object to be modified.</p>
</td></tr>
<tr><td><code id="ragged_+3A_v">v</code></td>
<td>
<p>vector of values to replace the old ones.</p>
</td></tr>
<tr><td><code id="ragged_+3A_x">x</code></td>
<td>
<p>a <code>raggedCoef</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An error will occur if the length of <code>v</code> is not equal to
<code>sum(rag@p)</code>.
</p>
<p><code>rag_modify</code> is, in a sense, the inverse of <code>ragged2vec</code>.
</p>


<h3>Value</h3>

<p>for <code>rag_modify</code>, a <code>raggedCoef</code> object of the same order as
<code>rag</code> but with coefficients replaced by the new values.
</p>
<p>for <code>ragged2vec</code>, a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rag1 &lt;- new("raggedCoef", list(1, 2:3, 4:6))
a1 &lt;- (1:6)^2
rag1a &lt;- rag_modify(rag1, a1)

rag2 &lt;- new("raggedCoef", list(1, numeric(0), 4:6)) # a zero-length ccomponent
a2 &lt;- (1:4)^2
rag2a &lt;- rag_modify(rag2, a2)

</code></pre>

<hr>
<h2 id='ragged2char'>Convert a ragged list into a matrix of characters</h2><span id='topic+ragged2char'></span>

<h3>Description</h3>

<p>The function transforms a ragged list into a matrix of characters. It
is used in <span class="pkg">mixAR</span> for output visualisation purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ragged2char(raglist, filler = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ragged2char_+3A_raglist">raglist</code></td>
<td>
<p>A ragged list (from <code>raggedCoef</code>).</p>
</td></tr>
<tr><td><code id="ragged2char_+3A_filler">filler</code></td>
<td>
<p>The character filling order mismatches.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ragged2char</code> converts a ragged list into a character matrix with
as many columns as the longest component of the list, filling the
missing entries with the values of argument <code>filler</code>. The latter
defaults to <code>NA</code>.
</p>
<p>In MixAR context the <code>i</code>-th row represents the AR coefficients
for the <code>i</code>-th component.
</p>


<h3>Value</h3>

<p>a character matrix
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+raggedCoef">raggedCoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>li1 &lt;- list(1.5, c(1.51, 1.522), c(10.311, 1.31, 1.313))
ragged2char(li1)
ragged2char(li1, "")
</code></pre>

<hr>
<h2 id='raggedCoef-class'>
Class <code>"raggedCoef"</code> &mdash; ragged list objects
</h2><span id='topic+raggedCoef'></span><span id='topic+raggedCoef-class'></span><span id='topic++5B-methods'></span><span id='topic++5B+2CraggedCoef+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2CraggedCoef+2Cnumeric+2Cmissing+2CANY-method'></span><span id='topic++5B+2CraggedCoef+2Cmissing+2Cnumeric+2CANY-method'></span><span id='topic++5B+2CraggedCoef+2Cnumeric+2Cnumeric+2CANY-method'></span><span id='topic++5B+5B-methods'></span><span id='topic++5B+5B+2CraggedCoef+2CANY+2Cmissing-method'></span><span id='topic++5B+5B+2CraggedCoef+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CraggedCoef+2CANY+2CANY+2Cnumeric-method'></span><span id='topic++5B+3C-+2CraggedCoef+2CANY+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2CraggedCoef+2CANY+2Cmissing+2Clist-method'></span><span id='topic++5B+3C-+2CraggedCoef+2CANY+2Cmissing+2Cmatrix-method'></span><span id='topic++5B+3C-+2CraggedCoef+2Cmissing+2Cmissing+2Clist-method'></span><span id='topic++5B+3C-+2CraggedCoef+2Cmissing+2Cmissing+2Cmatrix-method'></span><span id='topic++5B+3C-+2CraggedCoef+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2CraggedCoef+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CraggedCoef+2Cnumeric+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CraggedCoef+2Cnumeric+2Cnumeric+2CANY-method'></span><span id='topic++5B+5B+3C--methods'></span><span id='topic++5B+5B+3C-+2CraggedCoef+2CANY+2CANY+2Cnumeric-method'></span><span id='topic++5B+5B+3C-+2CraggedCoef+2CANY+2Cmissing+2Cnumeric-method'></span><span id='topic+anyNA+2CraggedCoef-method'></span><span id='topic+dim+2CraggedCoef-method'></span><span id='topic+length+2CraggedCoef-method'></span>

<h3>Description</h3>

<p>Some models have several several vectors of parameters, possibly of
different lengths, such that in some circumstances they are thought of
as lists, in others as matrices after suitable padding with zeroes.
Class <code>"raggedCoef"</code> represents such ragged lists.  In package
<code>"MixAR"</code> it is used to hold the autoregressive coefficients of
MixAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raggedCoef(p, value = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raggedCoef-class_+3A_p">p</code></td>
<td>
<p>orders, vector of integers.</p>
</td></tr>
<tr><td><code id="raggedCoef-class_+3A_value">value</code></td>
<td>
<p>typically, a list, but see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Class <code>"raggedCoef"</code> is for objects that can be considered as
both, lists and matrices. The elements of the list are vectors,
possibly of different lengths.  When the object is viewed as a matrix,
each element of the list (suitably padded with zeroes or <code>NA</code>s)
represents a row of a matrix.
</p>
<p>The recommended way to create objects from class <code>"raggedCoef"</code>
is with the function <code>raggedCoef</code>. 
</p>
<p>If <code>value</code> is a &quot;raggedCoef&quot; object it is returned.
If value is a list, it is converted to &quot;raggedCoef&quot; using
<code>new()</code>.
If argument <code>p</code> is missing, it is inferred from the
lengths of the elements of the list.  
If argument <code>p</code> is not missing, a consistency check
is made to ensure that the order of the object is as specified by
<code>p</code>.
</p>
<p>Otherwise, if <code>value</code> is of length one, it is replicated to form
a ragged list with i-th element a vector of length
<code>p[i]</code>. Although not checked, the intention here is that
<code>value</code> is from some atomic class.  The default for <code>value</code>
is <code>NA_real_</code> to give a convenient way to create a ragged list.
</p>
<p>Finally, if none of the above applies, <code>value</code> is effectively assumed to
be a vector of length <code>sum(p)</code>, although other cases are
admissible (but I don't remember if this was intended). In this case,
<code>value</code> is reshaped into a ragged list to match <code>p</code>. This is
convenient when, for example, the elements of a ragged array are
obtained from an optimisation routine which expects plain vector.


</p>


<h3>Objects from the Class</h3>

<p>Below we describe the <code>"initialize"</code> method that underlies
<code>new("raggedCoef", ...)</code>.  The recommended way to create
<code>"raggedCoef"</code> objects is with the function <code>raggedCoef</code>,
see section Details.
</p>
<p>Objects can also be created by calls of the form
<code>new("raggedCoef", v)</code>, where <code>v</code> is a list whose elements
are numeric vectors, or <code>new("raggedCoef", v1, v2, ...)</code>, where
<code>v1, v2, ...</code> are numeric vectors.  The two forms are equivalent
if <code>v = list(v1, v2, ...)</code>.
</p>
<p>The elements of the list <code>v</code> may be named.
Similarly, named arguments can be used in the second form, say
<code>new("raggedCoef", name1 = v1, name2 = v2, ...)</code>.
In both cases the names are preserved in the internal representaion,
but not used.
</p>
<p>If the arguments are not as specified above the result should be
considered undefined. 
Currently, if there are other arguments after the list <code>v</code>, they
are ignored with a warning. If the first argument is not a list then
all arguments must be <code>numeric</code> and an error is raised if this is
not the case. For completeness, we mention that exactly two arguments named
<code>a</code>, and <code>p</code> are also accepted by <code>new()</code>, eg
<code>new("raggedCoef", p = c(1, 2), a =  list(3, 4:5))</code>, but these
are assigned to the slots without any checking. so it is
most flexible (and recommended) to use <code>raggedCoef()</code> instead.
</p>


<h3>Slots</h3>


<dl>
<dt><code>a</code>:</dt><dd><p>Object of class <code>"list"</code> containing the values. </p>
</dd>
<dt><code>p</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the
lengths of the components of <code>a</code>.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Indexing with &quot;[&quot; treats a <code>raggedCoef</code> object as a matrix, while
&quot;[[&quot; treats the object as list (it works on slot <code>a</code>).
</p>
<p>Note that there is a difference between <code>x[2,]</code> (or the
equivalent <code>x[2]</code>) and <code>x[[2]]</code>&mdash;the former gives a vector
of length <code>max(p)</code>, so potentially padded with zeroes, while the
latter gives the component with its &ldquo;natural&rdquo; length.
</p>
<p>The replacement variants of &quot;[&quot; and &quot;[[&quot; do not change the structure
of the object and issue errors if the replacement value would result
in that. In situations where the checks are deemed redundant, direct
assignments to the corresponding slots may be used.
</p>

<dl>
<dt>[</dt><dd><p><code>signature(x = "raggedCoef", i = "missing", j = "missing", drop = "ANY")</code>: </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "raggedCoef", i = "missing", j = "numeric", drop = "ANY")</code>: </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "raggedCoef", i = "numeric", j = "missing", drop = "ANY")</code>: </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "raggedCoef", i = "numeric", j = "numeric", drop = "ANY")</code>:
Indexing with &quot;[&quot; treats a <code>raggedCoef</code> object as a matrix
with one row for each component and number of columns equal to
<code>max(p)</code>. However, <code>x[2]</code> is equivalent to <code>x[2,]</code>
which is different from the treatment of <code>matrix</code> objects in
base <span class="rlang"><b>R</b></span>.
</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "raggedCoef", i = "ANY", j = "missing")</code>:</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "raggedCoef", i = "ANY", j = "ANY")</code>:
<code>"[["</code> extracts the corresponding element of slot <code>a</code>.</p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(x = "raggedCoef", i = "ANY", j = "ANY", value = "numeric")</code>:
Replace the j-th element of i-th row with <code>value</code>.
All arguments must be scalars.
</p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(x = "raggedCoef", i = "ANY", j = "missing", value = "numeric")</code>:
</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "raggedCoef", i = "ANY", j = "missing", value = "numeric")</code>:
Replace the i-th row with <code>value</code>. Argument <code>i</code> must be
a scalar while the length of <code>value</code> must be the same as that
of <code>x@a[[i]]</code>. The methods for &quot;[&quot; and &quot;[[&quot; with this
signature coinside.
</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "raggedCoef", i = "ANY", j = "missing", value = "list")</code>:
The elements of <code>value</code> must have the same lengths as the
elements they are replacing.
</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "raggedCoef", i = "ANY", j = "missing", value = "matrix")</code>:
This is essentially the reverse od the corresponding
non-replacement operator. <code>value</code> must have at least as many
columns as the longest element of <code>x</code> that is replaced.
</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "raggedCoef", i = "ANY", j = "ANY", value = "numeric")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "raggedCoef", i = "missing", j = "missing", value = "list")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "raggedCoef", i = "missing", j = "missing", value = "matrix")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "raggedCoef", i = "missing", j = "missing", value = "numeric")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "raggedCoef")</code>:
Creates objects of class <code>raggedCoef</code>. This method is used
internally by <code>new()</code>. Users should use <code>new()</code> for
creation of objects from this class, see the examples.
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "raggedCoef")</code>: ... </p>
</dd>
<dt>mixFilter</dt><dd><p><code>signature(x = "numeric", coef = "raggedCoef", index = "numeric")</code>:
Apply a mixture filter to a time series.

</p>
</dd>
<dt>row_lengths</dt><dd><p><code>signature(x = "raggedCoef")</code>:
Gives <code>x@p</code>, which is the same as <code>lengths(x@a)</code>.
</p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "raggedCoef")</code>:
Gives the total number of coefficients (<code>sum(x@p)</code>).
</p>
</dd>
<dt>anyNA</dt><dd><p><code>signature(x = "raggedCoef")</code>:
Are there <code>NA</code>'s in <code>x@a</code>?
</p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "raggedCoef")</code>:
The dimension of the object, when viewed as a matrix.
The presence of this method also ensures that <code>nrow()</code>
and related functions give the expected result.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>Slot <code>p</code> is redundant but convenient.
</p>




<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p>class <code>"<a href="#topic+MixARGaussian-class">MixARGaussian</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ragged1 &lt;- list(1, 2:3, 4:6)
ragged2 &lt;- list(a = 1, b = 2:3, c = 4:6)

raggedCoef(1:3)          # only order given, fill with NA's
raggedCoef(1:3, 0)       # fill with a number (zero in this case)

## init with a list
raggedCoef(ragged1)
raggedCoef(value = ragged1) 

## error, since the shape of ragged1 is not c(2, 2, 3):
## raggedCoef(c(2, 2, 3), value = ragged1)

## init with a flattened list
raggedCoef(p = 1:3, value = 1:6)

## specify each component separately
ragA &lt;- new("raggedCoef", 1, 2:3, 4:6)
ragB &lt;- new("raggedCoef", list(1, 2:3, 4:6))  # same
identical(ragA, ragB) #TRUE

## extract as a matrix
ragA[]

## extract the 2nd component
ragA[2]      # c(2, 3, 0) ("[" pads with 0's)
ragA[[2]]    # c(2, 3)    ("[[" does not pad)

## get the 2nd and 3rd components as a matrix
ragA[2:3, ]    # "[" treats object (almost) as matrix
ragA[2:3]      # same (though not as for "matrix")

## names are kept in the list but currently not used 
ragC  &lt;- new("raggedCoef", list(a = 1, b = 2:3, c = 4:6))
ragC1 &lt;- new("raggedCoef", a = 1, b = 2:3, c = 4:6)
identical(ragC, ragC1) # TRUE
names(ragC@a) # [1] "a" "b" "c"

length(ragA)
dim(ragA)
c(nrow(ragA), ncol(ragA))
c(NROW(ragA), NCOL(ragA))
</code></pre>

<hr>
<h2 id='raggedCoefS-class'>
Class <code>"raggedCoefS"</code> &mdash; ragged list
</h2><span id='topic+raggedCoefS-class'></span><span id='topic+raggedCoefS'></span><span id='topic++5B+2CraggedCoefS+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2CraggedCoefS+2Cnumeric+2Cmissing+2CANY-method'></span><span id='topic++5B+2CraggedCoefS+2Cmissing+2Cnumeric+2CANY-method'></span><span id='topic++5B+2CraggedCoefS+2Cnumeric+2Cnumeric+2CANY-method'></span><span id='topic++5B+5B+2CraggedCoefS+2CANY+2Cmissing-method'></span><span id='topic++5B+5B+2CraggedCoefS+2CANY+2CANY-method'></span><span id='topic++5B+5B+3C-+2CraggedCoefS+2CANY+2CANY+2Cnumeric-method'></span><span id='topic++5B+5B+3C-+2CraggedCoefS+2CANY+2Cmissing+2Clist-method'></span>

<h3>Description</h3>

<p>Ragged list used to hold coefficients of MixAR models with seasonal AR parameters.
</p>


<h3>Objects from the Class</h3>

<p>Objects are created by calls of the form
</p>
<p><code>new("raggedCoefS", a = list(v1, v2 , ...), as = list(vs1, vs2, ...), s)</code>. 
</p>
<p>If orders <code>p</code> and <code>ps</code> are specified, a consistency check is made.
</p>


<h3>Slots</h3>


<dl>
<dt>a</dt><dd><p>Object of class &quot;<code>list</code>&quot; containing AR values. Each element of the list must be &quot;<code>numeric</code>&quot;</p>
</dd>
<dt>p</dt><dd><p>Object of class &quot;<code>numeric</code>&quot; containing the lengths of components in <code>a</code>. If missing, it is generated based on lengths of elements of <code>a</code>.</p>
</dd>
<dt>as</dt><dd><p>Object of class &quot;<code>list</code>&quot; containing seasonal AR values. Each element of the list must be &quot;<code>numeric</code>&quot;</p>
</dd>
<dt>ps</dt><dd><p>Object of class &quot;<code>numeric</code>&quot; containing the lengths of elements of <code>as</code>. If missing, it is generated based on lengths of elements of <code>as</code>.</p>
</dd>
<dt>s</dt><dd><p>A single element &quot;<code>numeric</code>&quot; vector
determining the seasonality in the model(monthly, quarterly, etc..).</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Indexing with &quot;[&quot; treats a <code>raggedCoef</code> object as a matrix
(one row for each component), while
&quot;[[&quot; treats the object as list (it works on slot <code>a</code>). Specifically,
&quot;[[1]]&quot; picks the systematic AR parameters, &quot;[[2]]&quot; picks seasonal AR
parameters.
</p>
<p>The replacement variants of &quot;[&quot; and &quot;[[&quot; do not change the structure
of the object. 
</p>
<p>Replacement methods only work for subsets
<code>x[[i]]</code>, <code>x[[i]][[j]]</code>, <code>x[[i]][[j]][k]</code> for suitable <code>i</code>, 
<code>j</code> and <code>k</code>.
</p>
<p><code>i</code> must be equal to 1 for <code>x@a</code> and 2 for <code>x@as</code>.
</p>

<dl>
<dt>[</dt><dd><p><code>signature(x = "raggedCoefS", i = "missing", j = "missing")</code>:</p>
</dd>
</dl>
<p>returns the complete matrix of coefficients, one row corresponding to one component,
with '0's to match different orders
</p>
<dl>
<dt>[</dt><dd><p><code>signature(x = "raggedCoefS", i = "missing", j =
        "missing")</code>:</p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "raggedCoefS", i = "numeric", j =
        "missing")</code>:</p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "raggedCoefS", i = "numeric", j = "numeric")</code>:
Indexing with &quot;[&quot; treats a <code>raggedCoef</code> object as a matrix
with one row for each component and number of columns equal to
<code>max(p) + max(ps)</code> in increasing lag. 
However, <code>x[2]</code> is equivalent to <code>x[2,]</code>
which is different from the treatment of <code>matrix</code> objects in
base <span class="rlang"><b>R</b></span>.</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "raggedCoefS"), i = "numeric"</code>:</p>
</dd>
</dl>
<p>if i=1 selects the list of systematic AR parameters;
if i=2 selects the list of seasonal AR parameters.
</p>
<dl>
<dt>[[</dt><dd><p><code>signature(x = "raggedCoefS"), i = "numeric", j = "numeric"</code>:</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "raggedCoefS"), i = "numeric", j = "numeric", k = "numeric"</code>:</p>
</dd>
</dl>
<p>j and k are used to select specific elements from the listt of interest.

</p>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>See Also</h3>

<p>class <code>"<a href="#topic+raggedCoef-class">raggedCoef</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("raggedCoefS")

ragA &lt;- new("raggedCoefS", a = list( c(0.5, -0.5), 1),
            as = list(0, c(0.3, -0.1) ), s = 12)
ragB &lt;- new("raggedCoefS", a = list( c(0.5, -0.5), 1), p = c(2, 1),
            as = list(0, c(0.3, -0.1) ), ps = c(1, 2), s = 12)  # same

## Elements selection examples

ragA[]             ## matrix of coefficients
ragA[1]; ragA[1, ] ## vector of coefficients from first component
ragA[[2]]          ## list of seasonal AR parameters
ragA[[2]][[1]]      ## vector of seasonal AR parameters from first component

## Replacement of values in 'raggedCoefS' objects


ragB[[2]] &lt;- list(1, c(-0.5,0.5))
ragB[[2]][[2]] &lt;- c(20, 22)
ragB[[1]][[1]][1] &lt;- 0


</code></pre>

<hr>
<h2 id='raggedCoefV-class'>
Class <code>"raggedCoefV"</code> &mdash; ragged list
</h2><span id='topic+raggedCoefV-class'></span><span id='topic+raggedCoefV'></span><span id='topic++5B+2CraggedCoefV+2Cnumeric+2CANY-method'></span><span id='topic++5B+2CraggedCoefV+2Cnumeric+2CANY+2CANY-method'></span><span id='topic++5B+2CraggedCoefV+2Cnumeric+2Cmissing+2CANY-method'></span><span id='topic++5B+2CraggedCoefV+2Cmissing+2Cnumeric+2CANY-method'></span><span id='topic++5B+2CraggedCoefV+2Cnumeric+2Cnumeric+2CANY-method'></span><span id='topic++5B+5B+2CraggedCoefV+2Cmissing+2CANY-method'></span><span id='topic++5B+5B+2CraggedCoefV+2Cnumeric+2CANY-method'></span><span id='topic++5B+2CraggedCoefV+2Cmissing+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Ragged list used to hold coefficients of MixVAR models.
</p>


<h3>Objects from the Class</h3>

<p>Objects are created by calls of the form
<code>new("raggedCoefV", a = list(v1, v2 ,...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>a</code>:</dt><dd>
<p>Object of class <code>"list"</code> containing AR values. Each element of
the list must be <code>"array"</code>.
</p>
</dd>
<dt><code>p</code>:</dt><dd>
<p>Object of class <code>"numeric"</code> containing the length of arrays in
<code>a</code> (AR orders). If missing, it is generated based on lengths
of elements of <code>a</code>.
</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Indexing with &quot;[&quot; and &quot;[[&quot; works on slot <code>a</code>.
</p>
<p>&quot;[&quot; and &quot;[[&quot; can be use alternatively. Specifically, &quot;[]&quot; and &quot;[[]]&quot;
produce the same result, the complete list of AR coefficients.
Similarly, <code>[i,]</code>, <code>[i]</code> and <code>[[i]]</code> all return the
i^th element of the list, the array for i^th component.  <code>[,j]</code>
returns an array with j^th lag autoregressive parameters for each
component.
</p>

<dl>
<dt>[</dt><dd><p><code>signature(x = "raggedCoefV", i = "missing", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "raggedCoefV", i = "missing", j = "numeric", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "raggedCoefV", i = "numeric", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "raggedCoefV", i = "numeric", j = "numeric", drop = "ANY")</code>: ... </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "raggedCoefV", i = "missing", j = "ANY")</code>: ... </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "raggedCoefV", i = "numeric", j = "ANY")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "raggedCoefV")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "raggedCoefV")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>See Also</h3>

<p>class <code>"<a href="#topic+MixVAR-class">MixVAR</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("raggedCoefV")

AR &lt;- list()
AR[[1]] &lt;- array(c(0.0973, -0.0499,  0.2927,  0.4256,  ## VAR(2;4)
                  -0.0429,  0.0229, -0.1515, -0.1795,
                  -0.0837, -0.1060, -0.1530,  0.1947,
                  -0.1690, -0.0903,  0.1959,  0.0955), dim=c(2,2,4))
AR[[2]] &lt;- array(c(0.3243,  0.2648,  0.4956,  0.2870,  ## VAR(2;3)
                  -0.1488,  0.0454, -0.0593, -0.3629,
                   0.1314,  0.0274,  0.0637,  0.0485), dim=c(2,2,3))
                   
new("raggedCoefV", AR)
new("raggedCoefV", a=AR, p=c(4,3))
</code></pre>

<hr>
<h2 id='raghat1'>
Filter a time series with options to shift and scale
</h2><span id='topic+raghat1'></span>

<h3>Description</h3>

<p>Filter a time series with options to shift and scale. This function is
used by mixFilter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raghat1(filter, x, index, shift = 0, residual = FALSE, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raghat1_+3A_filter">filter</code></td>
<td>
<p>The coefficients of the filter, numeric, see Details.</p>
</td></tr>
<tr><td><code id="raghat1_+3A_x">x</code></td>
<td>
<p>time series, numeric.</p>
</td></tr>
<tr><td><code id="raghat1_+3A_index">index</code></td>
<td>

<p>indices for which to compute the filtered values, numeric.
</p>
</td></tr> 
<tr><td><code id="raghat1_+3A_shift">shift</code></td>
<td>

<p>a constant to be added to each filtered element, a number.
</p>
</td></tr>
<tr><td><code id="raghat1_+3A_residual">residual</code></td>
<td>

<p>if TRUE calculate a &lsquo;residual&rsquo;, otherwise calculate a &lsquo;hat&rsquo; value.
</p>
</td></tr>
<tr><td><code id="raghat1_+3A_scale">scale</code></td>
<td>

<p>if <code>scale != 1</code> calculate scaled residuals by divividing by
this value. Probably meaningful only if <code>residual=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code>mixFilter</code>. Applies an autoregressive
filter to a time series for indices specified by <code>index</code>.
</p>
<p>Note that &lsquo;filter&rsquo; here is equivalent to calculating one-step
predictions (or residuals if <code>residual=TRUE</code>) from
autoregressions.
</p>
<p><code>index</code> should not specify indices smaller than
<code>length(filter)+1</code> or larger than <code>length(x)+1</code>.  The value
<code>length(x)+1</code> can legitimately be used to calculate a prediction
(but not a residual of course) for the first value after the end of the
series.
</p>


<h3>Value</h3>

<p>A numeric vector of length equal to <code>length(index)</code>.
</p>


<h3>Note</h3>

<p>This should probably use <code>filter</code> but for the purposes of this
package <code>filter</code> is usually short and the calculation is
vectorised w.r.t. <code>index</code>, so should not be terribly slow.
</p>

<hr>
<h2 id='randomArCoefficients'>Random initial values for MixAR estimation</h2><span id='topic+randomArCoefficients'></span><span id='topic+randomMarParametersKernel'></span><span id='topic+randomMarResiduals'></span><span id='topic+tsDesignMatrixExtended'></span>

<h3>Description</h3>

<p>Translations of functions from my Mathematica sources. Not used currently?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomArCoefficients(ts, wv, pk, pmax, partempl, sub_size = 10,
                     condthr = 10, nattempt = 10, startfrom = pmax + 1)

randomMarParametersKernel(ts, ww, pk, pmax, partempl, ...)

randomMarResiduals(ts, p, partempl)

tsDesignMatrixExtended(ts, p, ind, partempl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomArCoefficients_+3A_ts">ts</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_wv">wv</code>, <code id="randomArCoefficients_+3A_ww">ww</code></td>
<td>
<p>a vector of weights (?).</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_pk">pk</code></td>
<td>
<p>the AR order of the requested component.</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_pmax">pmax</code></td>
<td>

<p>the maximal AR order in the model. Needed since it cannot be
determined by functions working on a single component.
</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_partempl">partempl</code></td>
<td>

<p>parameter template, a list containing one element for each mixture
component, see Details.
</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_sub_size">sub_size</code></td>
<td>

<p>the size of the subsample to use, default is 10.
</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_condthr">condthr</code></td>
<td>

<p>threshold for the condition number.
</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_nattempt">nattempt</code></td>
<td>

<p>if <code>condthr</code> is not reached after <code>nattempt</code> attempts, the
function returns the results from the last subset tried.
</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_startfrom">startfrom</code></td>
<td>

<p>the starting index (in <code>ts</code>) to use for subsampling, default is
<code>pmax + 1</code>.
</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_...">...</code></td>
<td>
<p>arguments to pass on to <code>randomArCoefficients()</code>.</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_p">p</code></td>
<td>
<p>a vector of non-negative integers, the MixAR order.</p>
</td></tr>
<tr><td><code id="randomArCoefficients_+3A_ind">ind</code></td>
<td>

<p>a vector of positive integers specifying the indices of the
observations to use for the &ldquo;response&rdquo; variable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>randomArCoefficients</code> tries small subsamples (not necessarilly
contiguous) from the observations in search of a cluster hopefully
belonging to one mixture component and estimates the corresponding
shift and AR parameters.
</p>
<p><code>randomMarResiduals</code> selects random parameters for each mixture
component and returns the corresponding residuals.
<code>randomMarParametersKernel</code> is a helper function which does the
computation for one component.
</p>
<p><code>tsDesignMatrixExtended</code> forms the extended design matrix
corresponding to a subsample. This is used for least square estimation
of the parameters. 
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+tomarparambyComp">tomarparambyComp</a></code>
</p>

<hr>
<h2 id='row_lengths-methods'> Methods for function <code>row_lengths</code> in package <span class="pkg">mixAR</span></h2><span id='topic+row_lengths-methods'></span><span id='topic+row_lengths'></span><span id='topic+row_lengths+2CANY-method'></span><span id='topic+row_lengths+2CMixAR-method'></span><span id='topic+row_lengths+2CraggedCoef-method'></span>

<h3>Description</h3>

<p>Determine the lengths of the &lsquo;rows&rsquo; of a ragged object.
</p>


<h3>Methods</h3>

<p>Some objects in this package contain (effectively) lists of vectors.
These vectors are considered &lsquo;rows&rsquo; and this function returns their
lengths (as a vector).
</p>

<dl>
<dt><code>signature(x = "ANY")</code></dt><dd>
<p>The default method. Applies <code>length</code> to the elements of the
argument (2020-03-28: now using <code>lengths(x)</code>).
</p>
</dd>
<dt><code>signature(x = "raggedCoef")</code></dt><dd>
<p>Returns the lengths of the rows of the components, a numeric vector.
</p>
</dd>
<dt><code>signature(x = "MixAR")</code></dt><dd>
<p>Returns the AR orders of the model components, a numeric vector.
</p>
</dd>
</dl>

<hr>
<h2 id='sampZpi'>
Sampling functions for Bayesian analysis of mixture autoregressive
models
</h2><span id='topic+sampZpi'></span><span id='topic+sampMuShift'></span><span id='topic+sampSigmaTau'></span>

<h3>Description</h3>

<p>Sampling functions for Bayesian analysis of mixture autoregressive
models. Draws observations from posterior distributions of the latent
variables <code>Z_t</code>s and the parameters of mixture autoregressive
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampZpi(y, pk, prob, mu, AR, sigma, nsim, d)
sampMuShift(y, pk, prec, nk, shift, z, AR, nsim)
sampSigmaTau(y, pk, prec, nk, AR, mu, z, a, c, nsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampZpi_+3A_y">y</code></td>
<td>
<p>a time series (currently a  <code>numeric</code> vector).</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_pk">pk</code></td>
<td>

<p><code>numeric</code> vector of length <code>g</code>. The autoregressive order
of each component.
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_prob">prob</code></td>
<td>

<p><code>numeric</code> vector of length <code>g</code>. Current mixing weights.
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_mu">mu</code></td>
<td>

<p><code>numeric</code> vector of length <code>g</code>. Current mean parameters.
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_shift">shift</code></td>
<td>

<p><code>numeric</code> vector of length <code>g</code>. Current shift parameters.
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_ar">AR</code></td>
<td>

<p><code>list</code> of <code>g</code> elements. Autoregressive coefficients for
each component.
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_sigma">sigma</code></td>
<td>

<p><code>numeric</code> vector of length <code>g</code>. Current scale parameters
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_nsim">nsim</code></td>
<td>
<p>dessired sample size.</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_d">d</code></td>
<td>

<p><code>numeric</code> vector of length <code>g</code>. Hyperparameters for
Dirichlet prior. If missing, a vector of <code>1</code>s is generated. If
length is <code>1</code>, creates a vector of length <code>g</code> with given
number.
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_prec">prec</code></td>
<td>

<p><code>numeric</code> vector of length <code>g</code>. Current precision
parameters.
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_nk">nk</code></td>
<td>

<p>output from <code>sampZpi</code>. Component sum of latent variables Z_t.
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_z">z</code></td>
<td>

<p>output <code>latentZ</code> from <code>sampZpi</code>. A matrix containing the
simulated latent variables.
</p>
</td></tr>
<tr><td><code id="sampZpi_+3A_a">a</code>, <code id="sampZpi_+3A_c">c</code></td>
<td>
<p>hyperparameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sampZpi</code> draws observations from posterior distributions of the
latent variables <code>Z_t</code>s and mixing weights of a Mixture
autoregressive model.
</p>
<p><code>sampSigmaTau</code> draws observations from posterior distributions of
the precisions <code>tau_k</code> of a Mixture autoregressive model, and
obtains scales <code>sigma_k</code> by transformation.
</p>
<p><code>sampMuShift</code> Draws observations from posterior distributions of
the means <code>mu_k</code> of a Mixture autoregressive model, and obtains
shifts <code>phi_k0</code> by transformation.
</p>


<h3>Value</h3>

<p>for <code>sampZpi</code>, a list containing the following elements:
</p>
<table>
<tr><td><code>mix_weights</code></td>
<td>

<p><code>matrix</code> with <code>nrow = nsim</code> and <code>ncol = g</code>: 
sampled mixing weights.
</p>
</td></tr>
<tr><td><code>latentZ</code></td>
<td>

<p><code>matrix</code> with <code>nrow = n - p</code> and <code>ncol = g</code>, <code>n</code> equal to
<code>length(y)</code> and <code>p</code> equal to <code>max(pk</code>: 
the simulated latent variables <code>Z_t</code> at the last of <code>nsim</code> iterations 
(functional). Specifically, each row contains <code>1</code> for exactly 
one component, and is filled with <code>0</code>. 
</p>
</td></tr>
<tr><td><code>nk</code></td>
<td>

<p>Vector of length <code>g</code>. Column sums of <code>latentZ</code>.
</p>
</td></tr>
</table>
<p>for <code>sampMuShift</code>, a list containing the following elements:
</p>
<table>
<tr><td><code>shift</code></td>
<td>

<p><code>matrix</code> with <code>nrow = nsim</code> and <code>ncol = g</code>: 
simulated shift parameters, obtained by transformation of the
means.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>

<p><code>matrix</code> with <code>nrow = nsim</code> and <code>ncol = g</code>:
simulated mean parameters.</p>
</td></tr>
</table>
<p>for <code>sampSigmaTau</code>, a list containing the following elements:
</p>
<table>
<tr><td><code>scale</code></td>
<td>

<p><code>matrix</code> with <code>nrow = nsim</code> and <code>ncol = g</code>: 
scale parameters, obtained by transformation
of precisions.
</p>
</td></tr>
<tr><td><code>precision</code></td>
<td>

<p><code>matrix</code> with <code>nrow = nsim</code> and <code>ncol = g</code>: 
precision parameters.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p><code>numeric</code> vector of length <code>nsim</code> simulated values 
of hyperparameter lambda, due to hierarchical setup.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Davide Ravagli</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- new("MixARGaussian",
             prob   = exampleModels$WL_At@prob,      # c(0.5, 0.5)
             scale  = exampleModels$WL_At@scale,     # c(1, 2)        
             arcoef = exampleModels$WL_At@arcoef@a ) # list(-0.5, 1.1)
             
prob  &lt;- model@prob
sigma &lt;- model@scale
prec  &lt;- 1 / sigma ^ 2
g     &lt;- length(model@prob)
d     &lt;- rep(1, g)
pk    &lt;- model@arcoef@p
p     &lt;- max(pk)
shift &lt;- mu &lt;- model@shift
         
AR &lt;- model@arcoef@a       

model

set.seed(1234)
n &lt;- 50 # 500
nsim &lt;- 50

y &lt;- mixAR_sim(model, n = n, init = 0)
x  &lt;- sampZpi(y, pk, prob, shift, AR, sigma, nsim = nsim, d)
x1 &lt;- sampMuShift(y, pk, prec, nk = x$nk, shift, z = x$latentZ, AR, nsim = nsim)
x2 &lt;- sampSigmaTau(y, pk, prec, nk = x$nk, AR, mu = x1$mu, z = x$latentZ,
                   a = 0.2, c = 2, nsim = nsim)
</code></pre>

<hr>
<h2 id='show_diff'>Show differences between two models</h2><span id='topic+show_diff'></span><span id='topic+show_diff-methods'></span><span id='topic+show_diff+2CMixAR+2CMixAR-method'></span><span id='topic+show_diff+2CMixARGaussian+2CMixARgen-method'></span><span id='topic+show_diff+2CMixARgen+2CMixARGaussian-method'></span><span id='topic+show_diff+2CMixARgen+2CMixARgen-method'></span>

<h3>Description</h3>

<p>Show differences between two MixAR models in a way that enables quick
comparison between them. This is a generic function, package
<span class="pkg">mixAR</span> defines methods for <code>MixAR</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_diff(model1, model2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_diff_+3A_model1">model1</code>, <code id="show_diff_+3A_model2">model2</code></td>
<td>

<p>the MixAR models to be compared.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>show_diff()</code> is a generic function with dispatch on both
arguments.
</p>
<p><code>show_diff()</code> prints the differences between two
models in convenient form for comparison. The methods for MixAR models
allow to see differences between similar models at a glance.
</p>


<h3>Value</h3>

<p>The function is called for the side effect of printing the differences
between the two models and has no useful return value.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model1 = "MixAR", model2 = "MixAR")</code></dt><dd>

</dd>
<dt><code>signature(model1 = "MixARGaussian", model2 = "MixARgen")</code></dt><dd>

</dd>
<dt><code>signature(model1 = "MixARgen", model2 = "MixARGaussian")</code></dt><dd>

</dd>
<dt><code>signature(model1 = "MixARgen", model2 = "MixARgen")</code></dt><dd>

</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the examples reveal that the models below
##        differ only in the noise distributions
show_diff(exampleModels$WL_Ct_3, exampleModels$WL_Bt_1)
show_diff(exampleModels$WL_Bt_1, exampleModels$WL_Ct_3)
show_diff(exampleModels$WL_Ct_2, exampleModels$WL_Bt_3)
</code></pre>

<hr>
<h2 id='simuExperiment'>Perform simulation experiments</h2><span id='topic+simuExperiment'></span>

<h3>Description</h3>

<p>Perform simulation experiments</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuExperiment(model, simu, est, N = 100, use_true = FALSE,
               raw = FALSE, init_name = "init", keep = identity,
               summary_fun = .fsummary, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simuExperiment_+3A_model">model</code></td>
<td>
<p>the model, see 'Details'.</p>
</td></tr>
<tr><td><code id="simuExperiment_+3A_simu">simu</code></td>
<td>
<p>arguments for the simulation function, a list, see 'Details'.</p>
</td></tr>
<tr><td><code id="simuExperiment_+3A_est">est</code></td>
<td>
<p>arguments for the estimation function, a list, see 'Details'.</p>
</td></tr>
<tr><td><code id="simuExperiment_+3A_n">N</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="simuExperiment_+3A_use_true">use_true</code></td>
<td>
<p>if TRUE, use also the &quot;true&quot; coefficients as initial
values, see 'Details'.</p>
</td></tr>
<tr><td><code id="simuExperiment_+3A_raw">raw</code></td>
<td>
<p>if TRUE, include the list of estimated models in the
returned value.</p>
</td></tr>
<tr><td><code id="simuExperiment_+3A_init_name">init_name</code></td>
<td>
<p>name of the argument of the estimation function
which specifies the initial values for estimation, not always used,
see &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="simuExperiment_+3A_keep">keep</code></td>
<td>
<p>what values to keep from each simulation run, a function,
see 'Details'.</p>
</td></tr>
<tr><td><code id="simuExperiment_+3A_summary_fun">summary_fun</code></td>
<td>
<p>A function to apply at the end of the experiment to
obtain a summary, see 'Details'.</p>
</td></tr>
<tr><td><code id="simuExperiment_+3A_...">...</code></td>
<td>
<p>additional arguments to pass on to the summary
function. NOTE: this may change.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>model</code> specifies the underlying model and is not always
needed, see the examples.
Argument <code>simu</code> specifies how to simulate the data.
Argument <code>est</code> specifies the estimation procedure.
Argument <code>N</code> specifies the number of simulation runs.
The remaining arguments control details of the simulations, mostly
what is returned.
</p>
<p>Basically, <code>simuExperiment</code> does <code>N</code> simulation-estimation
runs.
The <code>keep</code> function is applied to the value obtained from each
run.
The results from <code>keep</code> are assembled in a list (these are the
'raw' results).
Finally, the summary function (argument <code>summary_fun</code>) is applied
to the raw list.
</p>
<p><code>simu</code> and <code>est</code> are lists with two elements: <code>fun</code> and
<code>args</code>. <code>fun</code> is a function or the name of a
function. <code>args</code> is a list of arguments to that function. The
first argument of the estimation function, <code>est$fun</code>, is the
simulated data. This argument is inserted by <code>simuExperiment</code> and
should not be put in <code>est$args</code>.
</p>
<p>The value returned by the summary function is the main part of the
result. If <code>raw = TRUE</code>, then the raw list is returned, as well.
Further fields may be made possible through additional arguments but
'Summary' and 'Raw' are guaranteed to be as described here.
</p>
<p><code>simuExperiment</code> uses <code>init_name</code> only if <code>use_true</code> is
TRUE to arrange a call of the estimation function with initial value
<code>model</code>.  Obviously, <code>simuExperiment</code> does not know how (or
if) the estimation function does with its arguments.
</p>
<p>The function specified by argument <code>keep</code> is called with one
argument when <code>use_true</code> is FALSE and two arguments otherwise.
</p>


<h3>Value</h3>

<p>A list with one or more elements, depending on the arguments.
</p>
<table>
<tr><td><code>Summary</code></td>
<td>
<p>a summary of the experiment, by default sample means
and standard deviations of the estimates.</p>
</td></tr>
<tr><td><code>Raw</code></td>
<td>
<p>A list of the estimated models.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## explore dist. of the mean of a random sample of length 5.
## (only illustration, such simple cases hardly need simuExperiment)
sim1 &lt;- list(fun="rnorm", args = list(n=5, mean=3, sd = 2))
est1 &lt;- list(fun=mean, args = list())

# a basic report function
fsum1 &lt;-  function(x){ wrk &lt;- do.call("c",x)
                       c(n = length(wrk), mean = mean(wrk), sd = sd(wrk))}

a1 &lt;- simuExperiment(TRUE, simu = sim1, est = est1, N = 1000, summary_fun = fsum1)

# explore also the dist. of the sample s.d.
est2 &lt;- est1
est2$fun &lt;- function(x) c(xbar = mean(x), s = sd(x))

a2  &lt;- simuExperiment(TRUE, simu = sim1, est = est2, N = 1000)

# keep the raw sample means and s.d.'s for further use
a2a &lt;- simuExperiment(TRUE, simu = sim1, est = est2, N = 1000, raw = TRUE)
a2a$Summary

# replicate a2a$Summary
s5 &lt;- sapply(a2a$Raw, identity)
apply(s5, 1, mean)
apply(s5, 1, sd)

hist(s5[1,], prob=TRUE)
lines(density(s5[1,]))
curve(dnorm(x, mean(s5[1,]), sd(s5[1,])), add = TRUE, col = "red")

mixAR:::.fsummary(a2a$Raw)
mixAR:::.fsummary(a2a$Raw, merge = TRUE)
</code></pre>

<hr>
<h2 id='stdnormmoment'>Compute moments and absolute moments of standardised-t and normal distributions</h2><span id='topic+stdnormmoment'></span><span id='topic+stdnormabsmoment'></span><span id='topic+stdtmoment'></span><span id='topic+stdtabsmoment'></span><span id='topic+tabsmoment'></span>

<h3>Description</h3>

<p>Compute moments and absolute moments of standardised-t, t and normal
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdnormmoment(k)
stdnormabsmoment(k)
stdtmoment(nu, k)
stdtabsmoment(nu, k)
tabsmoment(nu, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdnormmoment_+3A_k">k</code></td>
<td>
<p>numeric vector, moments to compute.</p>
</td></tr>
<tr><td><code id="stdnormmoment_+3A_nu">nu</code></td>
<td>
<p>a number, degrees of freedom.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute moments of standardised-t and standard normal
distibutions. These distributions have mean zero and variance 1.
Standardised-t is often prefferred over Student-t for innovation
distributions, since its variance doesn't depend on its parameter
(degrees of freedom). The absolute moments of the usual
t-distributions are provided, as well.
</p>
<p>The names of the functions start with an abbreviated name of the
distribution concerned: <code>stdnorm</code> (N(0,1)), <code>stdt</code>
(standardised-t), <code>t</code> (Student-t). 
</p>
<p>The functions with names ending in <code>absmoment()</code>
(<code>stdnormabsmoment()</code>, <code>stdtabsmoment()</code> and <code>tabsmoment()</code>)
compute absolute moments, The rest (<code>stdnormmoment()</code> and
<code>stdtmoment()</code>) compute ordinary moments.
</p>
<p>The absolute moments are valid for (at least) <code>k &gt;= 0</code>, not
necessarily integer. The ordinary moments are currently intended only
for integer moments and return NaN's for fractional ones, with
warnings.
</p>
<p>Note that the Student-t and standardised-t with <code class="reqn">\nu</code> degrees
of freedom have finite (absolute) moments only for <code class="reqn">k&lt;\nu</code>.
As a consequence, standardised-t is defined only for <code class="reqn">\nu&gt;2</code> 
(otherwise the variance is infinite).
</p>
<p><code>stdtabsmoment</code> returns <code>Inf</code> for any <code class="reqn">k \ge \nu</code>. 
<code>stdtmoment</code> returns <code>Inf</code> for even integer <code>k</code>'s, such
that <code class="reqn">k \ge \nu</code>. However, for odd integers it returns
zero and for non-integer moments it returns <code>NaN</code>.
Here is an example, where the first two k's are smaller than
<code>nu</code>, while the others are not:
</p>
<pre>stdtabsmoment(nu = 5, k = c(4, 4.5, 5, 5.5))
##: [1]  9.00000 29.31405      Inf      Inf
stdtmoment(nu = 5, k = c(4, 4.5, 5, 5.5))
##: [1]   9 NaN   0 NaN
</pre>

<p>These functions are designed to work with scalar <code>nu</code> but this
is not enforced.
</p>


<h3>Value</h3>

<p>numeric vector of the same length as <code>k</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Würtz D, Chalabi Y, Luksan L (2006).
&ldquo;Parameter Estimation of ARMA Models with GARCH / APARCH Errors An R and SPlus Software Implementation.&rdquo;
<a href="http://www-stat.wharton.upenn.edu/%7Esteele/Courses/956/RResources/GarchAndR/WurtzEtAlGarch.pdf">http://www-stat.wharton.upenn.edu/%7Esteele/Courses/956/RResources/GarchAndR/WurtzEtAlGarch.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## some familiar positive integer moments
stdnormmoment(1:6)
## fractional moments of N(0,1) currently give NaN
stdnormmoment(seq(1, 6, by = 0.5))
## abs moments don't need to be integer
curve(stdnormabsmoment, from = 0, to = 6, type = "l", col = "blue")

## standardised-t
stdtmoment(5, 1:6)
stdtabsmoment(5, 1:6)
stdtabsmoment(5, 1:6)

## Student-t
tabsmoment(5, 1:6)
</code></pre>

<hr>
<h2 id='tau2probhat'>
Estimate probabilities of a MixAR model from tau.
</h2><span id='topic+tau2probhat'></span>

<h3>Description</h3>

<p>Estimate probabilities of a MixAR model from tau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau2probhat(tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tau2probhat_+3A_tau">tau</code></td>
<td>
<p>todo: explain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>

<hr>
<h2 id='test_unswitch'>A test for 'unswitch'</h2><span id='topic+test_unswitch'></span>

<h3>Description</h3>

<p>A test for 'unswitch'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_unswitch(models, true_model, allperm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_unswitch_+3A_models">models</code></td>
<td>
<p>a list of MixAR models to process.</p>
</td></tr>
<tr><td><code id="test_unswitch_+3A_true_model">true_model</code></td>
<td>
<p>the MixAR model used in the experiment.</p>
</td></tr>
<tr><td><code id="test_unswitch_+3A_allperm">allperm</code></td>
<td>
<p>which permutations to try.</p>
</td></tr>
<tr><td><code id="test_unswitch_+3A_...">...</code></td>
<td>
<p>additional arguments to pass on to <code><a href="#topic+unswitch">unswitch</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function permutes ('switches') randomly each model in <code>models</code> and calls
<code>unswitch</code> to 'unswitch' the switched models. It calculates
summary statistics for the three sets of models.
</p>
<p>The summary statistics for the 'switched' models will often be
meaningless. Those for the 'unswitched' ones should be good.
</p>
<p>The quality of the statistics for argument <code>models</code> itself
depend on how they are obtained and on the specifics of the model.
They are good if, as is often done is mixture experiments, estimation
is initialised with the true values of the parameters, since there is
little scope for switching in that case. If initial values are chosen
randomly, then there may still be little switching, largely dependent
on the probabilities of the components.
</p>


<h3>Value</h3>

<p>A list with the summaries for the 3 sets of models.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## N is small for to make the examples run instantly.
set.seed(1234)
aII10data &lt;- mixARExperiment(exampleModels$WL_II, N = 5, raw = TRUE,
                 estargs = list(crit = 1e-4))
aII10 &lt;- test_unswitch(aII10data$Raw, exampleModels$WL_II)
aII10

aII10adata &lt;- mixARExperiment(exampleModels$WL_II, N = 5, raw = TRUE,
                  simargs = list(n = 100), estargs = list(crit = 1e-4))
aII10a &lt;- test_unswitch(aII10adata$Raw, exampleModels$WL_II)
aII10a
</code></pre>

<hr>
<h2 id='tomarparambyComp'>
Translations of my old MixAR Mathematica functions
</h2><span id='topic+tomarparambyComp'></span><span id='topic+tomarparambyType'></span><span id='topic+permuteArpar'></span>

<h3>Description</h3>

<p>Translations of some of my MixAR Mathematica functions.
Not sure if these are still used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tomarparambyComp(params)
tomarparambyType(params)
permuteArpar(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tomarparambyComp_+3A_params">params</code></td>
<td>
<p>the parameters of the MixAR model, a list, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>







<p><code>tomarparambyComp</code> is for completeness, my Mathematica programs
do not have this currently.
</p>
<p>The arrangement of the parameters of MixAR models in package
<code>"MixAR"</code> is &ldquo;by type&rdquo;: slot <code>prob</code> contains the mixture
probabilities (weights), <code>shift</code> contains intercepts, and so on.
</p>
<p>An alternative representation is &ldquo;by component&rdquo;: a list whose k-th
elements contains all parameters associated with the k-th mixture
component. The functions described here use the following order for
the parameter of the k-th component: prob_k, shift_k, arcoeff_k,
sigma2_k.
</p>
<p><code>tomarparambyType</code> takes an argument, <code>params</code>, arranged
&ldquo;by component&rdquo; and converts it to &ldquo;by type&rdquo;.
<code>tomarparambyComp</code> does the inverse operation, from &ldquo;by type&rdquo;
to &ldquo;by component&rdquo;.
</p>
<p><code>permuteArpar</code> creates all permutaions of the components of a
MixAR model. It takes a &ldquo;by component&rdquo; argument. The autoregressive
orders are not permuted, in that if the input model has AR orders
<code>c(2, 1, 3)</code>, all permuted models are also <code>c(2, 1, 3)</code>.
The AR coefficients of shorter or longer components are padded with
zeroes or truncated, respectively, see the unexported
<code>adjustLengths()</code>.
</p>


<h3>Value</h3>

<p>For <code>tomarparambyComp</code>, a list containing the parameters of
the model arranged &ldquo;by component&rdquo;, see Details.
</p>
<p>For <code>tomarparambyType</code>, a list containing the parameters of
the model arranged &ldquo;by type&rdquo;. It contains the following elements.
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>mixture probabilities, a numeric vector,</p>
</td></tr>
<tr><td><code>shift</code></td>
<td>
<p>shifts, a numeric vector,</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>autoregressive coefficients,</p>
</td></tr>
<tr><td><code>s2</code></td>
<td>
<p>noise variances, a numeric vector.</p>
</td></tr>
</table>
<p>For <code>permuteArpar</code>, a list with one element (arranged &ldquo;by
type&rdquo;) for each possible permutation of the AR parameters.

</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomArCoefficients">randomArCoefficients</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bycomp &lt;- list(list(0.1, 10,  0.11,                1),
               list(0.2,  20, c(0.11, 0.22),       2),
               list(0.3,  30, c(0.11, 0.22, 0.33), 3) )
bytype &lt;- tomarparambyType(bycomp)
identical(bycomp, tomarparambyComp(bytype)) # TRUE
               
permuteArpar(bycomp)
</code></pre>

<hr>
<h2 id='ui'>Utility function for mixAR
</h2><span id='topic+ui'></span>

<h3>Description</h3>

<p>Extracts the (t-i)th component from a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui(x, t, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ui_+3A_x">x</code></td>
<td>
<p>A vector.
</p>
</td></tr>
<tr><td><code id="ui_+3A_t">t</code></td>
<td>
<p>The present &quot;time&quot;.
</p>
</td></tr>
<tr><td><code id="ui_+3A_i">i</code></td>
<td>
<p>The lag. Can be a vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the (t-i)th element of the vector. If i=0, returns 1.
</p>


<h3>Note</h3>

<p>This is a utility function for mixAR.
</p>


<h3>Author(s)</h3>

<p>Davide Ravagli
</p>

<hr>
<h2 id='unswitch'>
Dealing with label switching in MixAR experiments
</h2><span id='topic+unswitch'></span>

<h3>Description</h3>

<p>Deal with label switching in MixAR experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unswitch(models, true_model, Nref = 100, simargs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unswitch_+3A_models">models</code></td>
<td>
<p>a list of MixAR models to process.</p>
</td></tr>
<tr><td><code id="unswitch_+3A_true_model">true_model</code></td>
<td>
<p>the MixAR model used in the experiment.</p>
</td></tr>
<tr><td><code id="unswitch_+3A_nref">Nref</code></td>
<td>
<p>length of the reference series</p>
</td></tr>
<tr><td><code id="unswitch_+3A_simargs">simargs</code></td>
<td>
<p>arguments for simulation of the reference series, see 'Details'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the unswitched models.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov
</p>


<h3>References</h3>

<p>Boshnakov, Georgi N., (2012) Label switching in MixAR models (in preparation).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
