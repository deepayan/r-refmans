<!DOCTYPE html><html><head><title>Help for package epidm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epidm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cip_spells'><p>Continuous Inpatient (CIP) Spells</p></a></li>
<li><a href='#csv_from_zip'><p>Download a csv from a zip</p></a></li>
<li><a href='#genus_gram_stain'><p>Bacterial Genus Gram Stain Lookup Table</p></a></li>
<li><a href='#group_time'><p>Grouping of intervals or events in time together</p></a></li>
<li><a href='#inpatient_codes'><p>Inpatient Codes cleanup</p></a></li>
<li><a href='#link_ae_inpatient'><p>Link A&amp;E to Inpatient records</p></a></li>
<li><a href='#lookup_recode'><p>Lookup table switch handler</p></a></li>
<li><a href='#proxy_episode_dates'><p>HES/SUS Episode Date Cleaning</p></a></li>
<li><a href='#respeciate_generic'><p>Respeciate unspecified samples</p></a></li>
<li><a href='#respeciate_organism'><p>Respeciated organisms</p></a></li>
<li><a href='#specimen_type_grouping'><p>Specimen type grouping</p></a></li>
<li><a href='#sql_clean'><p>Clean and Read a SQL query</p></a></li>
<li><a href='#sql_connect'><p>Connect to a SQL database</p></a></li>
<li><a href='#sql_read'><p>Read a table from a SQL database</p></a></li>
<li><a href='#sql_write'><p>Write a table to a SQL database</p></a></li>
<li><a href='#uk_patient_id'><p>Patient ID record grouping</p></a></li>
<li><a href='#valid_nhs'><p>NHS Number Validity Check</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Title:</td>
<td>UK Epidemiological Data Management</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains utilities and functions for the cleaning, processing and
    management of patient level public health data for surveillance
    and analysis held by the UK Health Security Agency, UKHSA.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexbhatt/epidm">https://github.com/alexbhatt/epidm</a>,
<a href="https://alexbhatt.github.io/epidm/">https://alexbhatt.github.io/epidm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexbhatt/epidm/issues">https://github.com/alexbhatt/epidm/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, DBI, odbc, phonics, purrr, readr, stats, stringi,
stringr, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-11 10:55:44 UTC; Alex.Bhattacharya</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Bhattacharya <a href="https://orcid.org/0000-0003-3000-2771"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Bhattacharya &lt;alex.bhatt@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-11 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cip_spells'>Continuous Inpatient (CIP) Spells</h2><span id='topic+cip_spells'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>A continuous inpatient (CIP) spell is a continuous period of care
within the NHS, which does allow specific types of transfers
to take place. It can therefore be made up of one or more provider
spells. A CIP spell starts when a decision has been made to admit
the patient, and a consultant has taken responsibility for their care.
The spell ends when the patient dies or is discharged from hospital.
This follows the NHS Digital Provider Spells Methodology:
http://content.digital.nhs.uk/media/11859/Provider-Spells-Methodology/pdf/Spells_Methodology.pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cip_spells(
  x,
  group_vars,
  spell_start_date,
  admission_method,
  admission_source,
  spell_end_date,
  discharge_destination,
  patient_classification,
  .forceCopy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cip_spells_+3A_x">x</code></td>
<td>
<p>a data frame; will be converted to a data.table</p>
</td></tr>
<tr><td><code id="cip_spells_+3A_group_vars">group_vars</code></td>
<td>
<p>a vector containing any variables to be used for
record grouping, minimum is a patient identifier</p>
</td></tr>
<tr><td><code id="cip_spells_+3A_spell_start_date">spell_start_date</code></td>
<td>
<p>Inpatient provider spell or episode admission date</p>
</td></tr>
<tr><td><code id="cip_spells_+3A_admission_method">admission_method</code></td>
<td>
<p>CDS admission method code</p>
</td></tr>
<tr><td><code id="cip_spells_+3A_admission_source">admission_source</code></td>
<td>
<p>CDS admission source code</p>
</td></tr>
<tr><td><code id="cip_spells_+3A_spell_end_date">spell_end_date</code></td>
<td>
<p>Inpatient provider spell or episode discharge  date</p>
</td></tr>
<tr><td><code id="cip_spells_+3A_discharge_destination">discharge_destination</code></td>
<td>
<p>CDS discharge destination code</p>
</td></tr>
<tr><td><code id="cip_spells_+3A_patient_classification">patient_classification</code></td>
<td>
<p>CDS patient classification code</p>
</td></tr>
<tr><td><code id="cip_spells_+3A_.forcecopy">.forceCopy</code></td>
<td>
<p>default FALSE; TRUE will force data.table to take a copy
instead of editing the data without reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original data.frame as a data.table
with the following new fields:
</p>

<dl>
<dt><code>cip_indx</code></dt><dd><p>an id field for the CIP spell</p>
</dd>
<dt><code>cip_spell_start</code></dt><dd><p>the start date for the CIP spell</p>
</dd>
<dt><code>cip_spell_end</code></dt><dd><p>the end date for the CIP spell</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
cip_test &lt;- data.frame(
  id = c('465','465','465','465','8418','8418','8418',
         '8418','8418','8418','8418','8418','26443',
         '26443','26443','33299','33299','33299','33299',
         '33299','33299','33299','33299','33299','33299',
         '52635','52635','52635','52635','52635','52635',
         '52635','52635','52635','52635','52635','52635',
         '52635','52635','52635','52635','52635','52635',
         '52635','52635','52635','52635','52635','52635',
         '52635','52635','52635','78915','78915','78915'),
  provider = c('X1T','X1T','X1T','X1T','KHA','KHA','KHA',
               'KHA','KHA','KHA','KHA','KHA','BX2','BX2',
               'BX2','PXH','PXH','PXH','PXH','PXH','PXH',
               'PXH','PXH','PXH','PXH','9HA','9HA','9HA',
               '9HA','9HA','9HA','9HA','9HA','9HA','9HA',
               '9HA','9HA','9HA','9HA','9HA','9HA','YYT',
               'YYT','YYT','YYT','YYT','YYT','YYT','YYT',
               'YYT','YYT','YYT','ABX','ABX','ABX'),
  spell_start = as.Date(c(
    '2020-03-07','2020-03-07','2020-03-25','2020-04-03','2020-01-25',
    '2020-01-26','2020-07-14','2020-08-02','2020-08-12','2020-08-19',
    '2020-08-19','2020-11-19','2019-11-12','2020-04-17','2020-04-23',
    '2020-07-03','2020-01-17','2020-02-07','2020-03-20','2020-04-27',
    '2020-06-21','2020-07-02','2020-10-17','2020-11-27','2021-01-02',
    '2019-12-31','2020-01-02','2020-01-14','2020-01-16','2020-02-07',
    '2020-02-11','2020-02-14','2020-02-18','2020-02-21','2020-02-25',
    '2020-02-28','2020-03-09','2020-03-11','2020-03-12','2020-03-13',
    '2020-03-14','2020-02-04','2020-02-07','2020-02-11','2020-02-14',
    '2020-02-18','2020-02-21','2020-02-25','2020-02-28','2020-03-09',
    '2020-03-11','2020-03-12','2020-04-16','2020-04-24','2020-05-13')),
  spell_end = as.Date(c(
    '2020-03-07','2020-03-25','2020-04-02','2020-04-27','2020-01-25',
    '2020-01-27','2020-07-17','2020-08-07','2020-08-14','2020-08-19',
    '2020-08-22','2020-12-16','2020-04-17','2020-04-23','2020-05-20',
    '2020-07-24','2020-01-28','2020-02-07','2020-03-23','2020-04-29',
    '2020-06-21','2020-07-03','2020-11-27','2021-01-02','2021-01-10',
    '2019-12-31','2020-01-11','2020-01-14','2020-02-04','2020-02-07',
    '2020-02-11','2020-02-14','2020-02-18','2020-02-21','2020-02-25',
    '2020-02-28','2020-03-09','2020-03-11','2020-03-12','2020-03-13',
    '2020-03-30','2020-02-07','2020-02-11','2020-02-14','2020-02-18',
    '2020-02-21','2020-02-25','2020-02-28','2020-03-09','2020-03-11',
    '2020-03-12','2020-03-13','2020-04-24','2020-05-13','2020-06-11')),
  adm_meth = c('21','81','21','81','21','21','11','21','21','21','21',
               '21','21','81','21','81','21','21','21','21','21','21',
               '21','13','13','12','22','12','2D','13','13','13','13',
               '13','13','13','13','13','13','13','21','81','81','81',
               '81','81','13','81','81','13','13','13','21','11','81'),
  adm_src = c('19','51','19','51','19','51','19','51','19','19','19',
              '51','19','51','19','51','19','19','19','19','19','19',
              '19','51','19','19','19','19','19','19','19','19','19',
              '19','19','19','51','51','51','51','19','51','51','51',
              '51','51','51','51','51','51','51','51','19','51','51'),
  dis_meth = c('1','1','1','1','1','1','1','1','1','1','1','4','1','1',
               '4','1','1','1','1','1','1','1','8','1','4','1','1','1',
               '1','1','1','1','1','1','1','1','1','1','1','1','1','1',
               '1','1','1','1','1','1','1','1','1','1','1','1','2'),
  dis_dest = c('51','51','51','54','51','19','19','19','19','51','19',
               '79','51','51','79','65','19','19','19','19','19','29',
               '98','51','79','19','19','19','51','19','19','19','51',
               '51','51','19','19','51','51','19','51','51','51','51',
               '51','51','51','51','51','51','51','51','29','54','19'),
  patclass = c('1','1','1','1','1','1','1','1','1','1','1','1','1','1',
               '1','1','1','1','1','1','1','1','1','1','1','2','1','2',
               '1','2','2','2','2','2','2','2','2','2','2','2','1','1',
               '1','1','1','1','1','1','1','1','1','1','1','1','1')
)

cip_spells(x=cip_test,
  group_vars = c('id','provider'),
  patient_classification = 'patclass',
  spell_start_date = 'spell_start',
  admission_method = 'adm_meth',
  admission_source = 'adm_src',
  spell_end_date = 'spell_end',
  discharge_destination = 'dis_dest'
)[]

</code></pre>

<hr>
<h2 id='csv_from_zip'>Download a csv from a zip</h2><span id='topic+csv_from_zip'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
A convenience function to allow you to pull data from NHS, ONS and ODR assets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csv_from_zip(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csv_from_zip_+3A_x">x</code></td>
<td>
<p>a zip file from the web</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a zip file for ingestion into your chosen readr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
read.csv(csv_from_zip("https://files.digital.nhs.uk/assets/ods/current/succarc.zip"))

## End(Not run)

</code></pre>

<hr>
<h2 id='genus_gram_stain'>Bacterial Genus Gram Stain Lookup Table</h2><span id='topic+genus_gram_stain'></span>

<h3>Description</h3>

<p>A reference table of bacterial gram stain results by genus
to allow faster filtering of bacterial results.
This dataset has been maintained manually against the PHE SGSS database.
If there are organisms missing, please raise and issue or push request on the
<a href="https://github.com/alexbhatt/epidm">epidm GitHub</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genus_gram_stain
</code></pre>


<h3>Format</h3>

<p>A data frame with four columns
</p>

<dl>
<dt>organism_genus</dt><dd><p>The bacterial genus</p>
</dd>
<dt>gram_stain</dt><dd><p>A character string to indicate POSITIVE or NEGATIVE type</p>
</dd>
<dt>gram_positive</dt><dd><p>A 0/1 flag to indicate if the genus is gram positive</p>
</dd>
<dt>gram_negative</dt><dd><p>A 0/1 flag to indicate if the genus is gram negative</p>
</dd>
</dl>


<hr>
<h2 id='group_time'>Grouping of intervals or events in time together</h2><span id='topic+group_time'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Group across multiple observations of
overlapping time intervals, with defined start and end dates,
or events within a static/fixed or rolling window of time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_time(
  x,
  date_start,
  date_end,
  window,
  window_type = c("rolling", "static"),
  group_vars,
  indx_varname = "indx",
  min_varname = "date_min",
  max_varname = "date_max",
  .forceCopy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_time_+3A_x">x</code></td>
<td>
<p>data frame, this will be converted to a data.table</p>
</td></tr>
<tr><td><code id="group_time_+3A_date_start">date_start</code></td>
<td>
<p>column containing the start dates for the grouping,
provided quoted</p>
</td></tr>
<tr><td><code id="group_time_+3A_date_end">date_end</code></td>
<td>
<p>column containing the end dates for the <em>interval</em>, quoted</p>
</td></tr>
<tr><td><code id="group_time_+3A_window">window</code></td>
<td>
<p>an integer representing a time window in days which will be
applied to the start date for grouping <em>events</em></p>
</td></tr>
<tr><td><code id="group_time_+3A_window_type">window_type</code></td>
<td>
<p>character, to determine if a 'rolling' or 'static'
grouping method should be used when grouping <em>events</em></p>
</td></tr>
<tr><td><code id="group_time_+3A_group_vars">group_vars</code></td>
<td>
<p>in a vector, the all columns used to group records, quoted</p>
</td></tr>
<tr><td><code id="group_time_+3A_indx_varname">indx_varname</code></td>
<td>
<p>a character string to set variable name for the
index column which provides a grouping key; default is indx</p>
</td></tr>
<tr><td><code id="group_time_+3A_min_varname">min_varname</code></td>
<td>
<p>a character string to set variable name for the
time period minimum</p>
</td></tr>
<tr><td><code id="group_time_+3A_max_varname">max_varname</code></td>
<td>
<p>a character string set variable name for the time
period maximum</p>
</td></tr>
<tr><td><code id="group_time_+3A_.forcecopy">.forceCopy</code></td>
<td>
<p>default FALSE; TRUE will force data.table to take a copy
instead of editing the data without reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original data.frame as a data.table
with the following new fields:
</p>

<dl>
<dt><code>indx</code>; renamed using <code>indx_varname</code></dt><dd><p>an id field for the new
aggregated events/intervals; note that where the <code>date_start</code> is NA, an
<code>indx</code> value will also be NA</p>
</dd>
<dt><code>min_date</code>; renamed using <code>min_varname</code></dt><dd><p>the start date for the
aggregated events/intervals</p>
</dd>
<dt><code>max_date</code>; renamed using <code>max_varname</code></dt><dd><p>the end date for the
aggregated events/intervals</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>episode_test &lt;- structure(
  list(
    pat_id = c(1L, 1L, 1L, 1L, 2L, 2L, 2L,
               1L, 1L, 1L, 1L, 2L, 2L, 2L),
    species = c(rep("E. coli",7),rep("K. pneumonia",7)),
    spec_type = c(rep("Blood",7),rep("Blood",4),rep("Sputum",3)),
    sp_date = structure(c(18262, 18263, 18281, 18282, 18262, 18263, 18281,
                          18265, 18270, 18281, 18283, 18259, 18260, 18281),
                        class = "Date")
  ),
  row.names = c(NA, -14L), class = "data.frame")

group_time(x=episode_test,
           date_start='sp_date',
           window=14,
           window_type = 'static',
           indx_varname = 'static_indx',
           group_vars=c('pat_id','species','spec_type'))[]

spell_test &lt;- data.frame(
  id = c(rep(99,6),rep(88,4),rep(3,3)),
  provider = c("YXZ",rep("ZXY",5),rep("XYZ",4),rep("YZX",3)),
  spell_start = as.Date(
    c(
      "2020-03-01",
      "2020-07-07",
      "2020-02-08",
      "2020-04-28",
      "2020-03-15",
      "2020-07-01",
      "2020-01-01",
      "2020-01-12",
      "2019-12-25",
      "2020-03-28",
      "2020-01-01",
      rep(NA,2)
    )
  ),
  spell_end = as.Date(
    c(
      "2020-03-10",
      "2020-07-26",
      "2020-05-22",
      "2020-04-30",
      "2020-05-20",
      "2020-07-08",
      "2020-01-23",
      "2020-03-30",
      "2020-01-02",
      "2020-04-20",
      "2020-01-01",
      rep(NA,2)
    )
  )
)

group_time(x = spell_test,
           date_start = 'spell_start',
           date_end = 'spell_end',
           group_vars = c('id','provider'),
           indx_varname = 'spell_id',
           min_varname = 'spell_min_date',
           max_varname = 'spell_max_date')[]

</code></pre>

<hr>
<h2 id='inpatient_codes'>Inpatient Codes cleanup</h2><span id='topic+inpatient_codes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>When HES/SUS ICD/OPCS codes are provided in wide format
you may want to clean them up into long for easier analysis.
This function helps by reshaping long as a separate table.
Ensuring they're separate allows you to retain source data, and aggregate
appropriately later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inpatient_codes(
  x,
  field_strings,
  patient_id_vars,
  type = c("icd9", "icd10", "opcs"),
  .forceCopy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpatient_codes_+3A_x">x</code></td>
<td>
<p>a data.frame or data.table containing inpatient data</p>
</td></tr>
<tr><td><code id="inpatient_codes_+3A_field_strings">field_strings</code></td>
<td>
<p>a vector or string containing the regex for the the columns</p>
</td></tr>
<tr><td><code id="inpatient_codes_+3A_patient_id_vars">patient_id_vars</code></td>
<td>
<p>a vector containing colnames used to identify a patient episode or spell</p>
</td></tr>
<tr><td><code id="inpatient_codes_+3A_type">type</code></td>
<td>
<p>a string to denote if the codes are diagnostic or procedural</p>
</td></tr>
<tr><td><code id="inpatient_codes_+3A_.forcecopy">.forceCopy</code></td>
<td>
<p>default FALSE; TRUE will force data.table to take a copy
instead of editing the data without reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a separate table with codes and id in long form
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inpatient_test &lt;- data.frame(
id = c(1053L,5487L,8180L,528L,1085L,344L,2021L,2040L,
       6504L,10867L,12411L,7917L,2950L,2812L,7757L,12227L,2675L,
       8548L,536L,11830L,12708L,10421L,5503L,2494L,14001L),
spell_id = c("dwPDw","iSpUq","qpgk5","8vrJ1","BAur9","l6LZk",
             "KJllb","tgZID","fJkh8","Y9IPv","DAlUZ",
             "9Ooc4","hUxGn","wtMG9","dw3dO","cz3fI",
             "gdxZK","npplb","tynBh","Uu0Sd","gV1Ac",
             "vOpA1","ttlcD","Fqo29","ivTmN"),
primary_diagnosis_code = c("K602","U071-","I501","U071  ","J22X","J189",
                           "J189","I951","N130","U071","K510 D",NA,
                           "G409-","C780","N185","J955","K573","U071",
                           "I330","L309","M513","U071","A419","U071",
                           "N185-"),
secondary_diagnosis_code_1 = c("K641","J128-","I489","J128  ","Q348","F059",
                               "R296","R296","N131","J128","M0750A",NA,
                               "R401-","C782","Z491","C321","D125","J128",
                               "B952","J459","M4780","B972","N390","J128",
                               "Z491-"),
secondary_diagnosis_code_2 = c("E039","B972-","I10X","L031  ","Z115","I509",
                               "F051","I251","K862","B972","K590-",NA,
                               "E876-","C798","N085","Z938","I209","B972",
                               "I214","Z880","M8588","R296","B962","B972",
                               NA),
secondary_diagnosis_code_3 = c("I422","J9691","E119","I489  ","D509","I489",
                               "D509","I252","T391","J440","R21X-",NA,
                               "R945-","E119","M310","I480","I252","J9690",
                               "E111",NA,"Z115","R410","J181","Z518",NA),
secondary_diagnosis_code_4 = c(NA,"I10X-","E669","E109  ","K219","Z921","I251",
                               "I259","R458","B972","F200-",NA,"E039-",
                               "I10X",NA,"I500","F171","I489","E162",NA,
                               "I480","M2551","L892","E86X",NA),
secondary_diagnosis_code_5 = c(NA,"E119-","J449","F03X  ",NA,"Z518","I252",
                               "I209","C61X","A419","R761-",NA,"E119-",
                               "K219",NA,"Z115","F329","N179","N179",NA,
                               "H353","Z638","L033","R54X",NA),
secondary_diagnosis_code_6 = c(NA,NA,"Z966","I10X  ",NA,"N179","N183","Z115",
                               "K627","N390",NA,NA,"J459-","M4780",NA,
                               "Z900",NA,"I10X","R34X",NA,"I951","I10X",
                               "D510","F059",NA),
secondary_diagnosis_code_7 = c(NA,NA,"Z854","I679  ",NA,"N183","Z951","M190",
                               "R634","L031",NA,NA,"I10X-","M512",NA,
                               "Z921",NA,"E119","I959",NA,"H903","I678",
                               "K639","F03X",NA),
secondary_diagnosis_code_8 = c(NA,NA,"Z864","J459  ",NA,"E115","E119","N183",
                               "E111","E871",NA,NA,"R51X-","H409",NA,
                               "Z870",NA,NA,"J90X",NA,"M199","J459",
                               "N133","F29X",NA),
secondary_diagnosis_code_9 = c(NA,NA,"Z921","R296  ",NA,"L97X","I10X","M4806",
                               "E114","S099",NA,NA,"Q070-","H544",NA,
                               NA,NA,NA,"I501",NA,"K811","F03X","J90X",
                               "N189",NA),
secondary_diagnosis_code_10 = c(NA,NA,NA,"Z921  ",NA,"L089","Z921","N40X",
                                "G590","R296",NA,NA,"E668-","Z858",NA,NA,NA,
                                NA,"I489",NA,"K219","G20X","N202",
                                "F719",NA),
secondary_diagnosis_code_11 = c(NA,NA,NA,"Z515  ",NA,"R02X","Z507","Z864",
                                "E162","I489",NA,NA,"G473-","Z923",NA,NA,NA,
                                NA,"I447",NA,"J459","E119","L031",
                                "Z960",NA),
secondary_diagnosis_code_12 = c(NA,NA,NA,"Z501  ",NA,"B370","K579","Z955",
                                "E46X","Z921",NA,NA,"R600-","Z926",NA,NA,NA,
                                NA,"E86X",NA,"I10X",NA,"J981","Z922",
                                NA),
secondary_diagnosis_code_13 = c(NA,NA,NA,"Z507  ",NA,"E039","M109",NA,"I259",
                                "K709",NA,NA,"M1999","Z895",NA,NA,NA,NA,
                                "R33X",NA,"J40X",NA,"E119",NA,NA),
secondary_diagnosis_code_14 = c(NA,NA,NA,NA,NA,NA,"J459",NA,"N131","Z864",NA,
                                NA,"R468-","Z902",NA,NA,NA,NA,"R296",
                                NA,NA,NA,"I739",NA,NA),
secondary_diagnosis_code_15 = c(NA,NA,NA,NA,NA,NA,"Z880",NA,"K862","Z501",NA,
                                NA,"Z115-","Z971",NA,NA,NA,NA,"R468",
                                NA,NA,NA,"N183",NA,NA),
secondary_diagnosis_code_16 = c(NA,NA,NA,NA,NA,NA,"Z867",NA,"T391","Z505",NA,
                                NA,"Z501-","Z878",NA,NA,NA,NA,"R31X",
                                NA,NA,NA,"I489",NA,NA),
secondary_diagnosis_code_17 = c(NA,NA,NA,NA,NA,NA,"Z864",NA,"R458","Z518",NA,
                                NA,"Z507-","Z958",NA,NA,NA,NA,"Z115",
                                NA,NA,NA,"M549",NA,NA),
secondary_diagnosis_code_18 = c(NA,NA,NA,NA,NA,NA,"F03X",NA,"C61X",NA,NA,NA,
                                NA,"Z867",NA,NA,NA,NA,"I252",NA,NA,
                                NA,"I252",NA,NA),
secondary_diagnosis_code_19 = c(NA,NA,NA,NA,NA,NA,NA,NA,"K627",NA,NA,NA,NA,
                                "Z864",NA,NA,NA,NA,"I259",NA,NA,NA,
                                "I259",NA,NA),
secondary_diagnosis_code_20 = c(NA,NA,NA,NA,NA,NA,NA,NA,"R634",NA,NA,NA,NA,
                                "Z880",NA,NA,NA,NA,"I10X",NA,NA,NA,
                                "E669",NA,NA),
secondary_diagnosis_code_21 = c(NA,NA,NA,NA,NA,NA,NA,NA,"E111",NA,NA,NA,NA,
                                "Z800",NA,NA,NA,NA,"I352",NA,NA,NA,
                                "Z867",NA,NA),
secondary_diagnosis_code_22 = c(NA,NA,NA,NA,NA,NA,NA,NA,"E114",NA,NA,NA,NA,
                                "Z801",NA,NA,NA,NA,"R15X",NA,NA,NA,
                                "Z896",NA,NA),
secondary_diagnosis_code_23 = c(NA,NA,NA,NA,NA,NA,NA,NA,"G590",NA,NA,NA,NA,
                                NA,NA,NA,NA,NA,"R32X",NA,NA,NA,
                                "Z960",NA,NA),
secondary_diagnosis_code_24 = c(NA,NA,NA,NA,NA,NA,NA,NA,"E162",NA,NA,NA,NA,
                                NA,NA,NA,NA,NA,"R418",NA,NA,NA,
                                "Z874",NA,NA),
primary_procedure_code = c("H289",NA,"K634",NA,"X292",NA,NA,NA,NA,NA,
                           "H251",NA,"U051","L913","X403",NA,"H231",
                           "U071","M473","X384",NA,NA,NA,NA,"X403"),
primary_procedure_date = c("20170730",NA,"20201202",NA,"20170914",NA,NA,NA,
                           NA,NA,"20210105",NA,"20170724",
                           "20210111","20171114",NA,"20170622","20210104",
                           "20171013","20170313",NA,NA,NA,NA,
                           "20171107"),
secondary_procedure_code_1 = c("H626",NA,"Y534",NA,"U297",NA,NA,NA,NA,NA,
                               "Z286",NA,"Y981","Y031",NA,NA,"Z286",
                               "Y981",NA,NA,NA,NA,NA,NA,NA),
secondary_procedure_date_1 = c("20170730",NA,"20201202",NA,"20170928",NA,NA,NA,
                               NA,NA,"20210105",NA,"20170724",
                               "20210111",NA,NA,"20170622","20210104",NA,NA,NA,
                               NA,NA,NA,NA),
secondary_procedure_code_2 = c("H444",NA,"Z941",NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               "U212",NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               NA,NA,NA),
secondary_procedure_date_2 = c("20170730",NA,"20201202",NA,NA,NA,NA,NA,NA,NA,
                               NA,NA,"20170729",NA,NA,NA,NA,NA,NA,
                               NA,NA,NA,NA,NA,NA),
secondary_procedure_code_3 = c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,"Y973",
                               NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               NA),
secondary_procedure_date_3 = c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               "20170729",NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               NA,NA),
secondary_procedure_code_4 = c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,"Y982",
                               NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               NA),
secondary_procedure_date_4 = c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               "20170729",NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               NA,NA),
secondary_procedure_code_5 = c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,"Z926",
                               NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               NA),
secondary_procedure_date_5 = c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               "20170729",NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               NA,NA),
secondary_procedure_code_6 = c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,"O161",
                               NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               NA),
secondary_procedure_date_6 = c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               "20170729",NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
                               NA,NA)
)

inpatient_codes(x=inpatient_test,
                field_strings='diagnosis',
                patient_id_vars = c('id','spell_id'),
                type = 'icd10')

inpatient_codes(x=inpatient_test,
                field_strings=c('procedure_code','procedure_date'),
                patient_id_vars = c('id','spell_id'),
                type = 'opcs')

</code></pre>

<hr>
<h2 id='link_ae_inpatient'>Link A&amp;E to Inpatient records</h2><span id='topic+link_ae_inpatient'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Link together ECDS A&amp;E records to HES/SUS inpatient records on
NHS number, Hospital Number and Date of Birth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_ae_inpatient(
  ae_data,
  ae_in,
  ae_out,
  inpatient_data,
  admission_date,
  spell_id,
  nhs_number = c("nhs_number", "nhs_number"),
  hospital_number = c("local_patient_identifier", "local_patient_identifier"),
  patient_dob = c("patient_birth_date", "date_birth"),
  org_code = c("organisation_code_of_provider", "organisation_code_code_of_provider"),
  .forceCopy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_ae_inpatient_+3A_ae_data">ae_data</code></td>
<td>
<p>the ECDS A&amp;E dataset</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_ae_in">ae_in</code></td>
<td>
<p>the ECDS arrival date</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_ae_out">ae_out</code></td>
<td>
<p>the ECDS discharge date</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_inpatient_data">inpatient_data</code></td>
<td>
<p>the HES/SUS inpatient dataset</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_admission_date">admission_date</code></td>
<td>
<p>a vector containing the inpatient (HES/SUS) admission date</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_spell_id">spell_id</code></td>
<td>
<p>the HES/SUS spell id</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_nhs_number">nhs_number</code></td>
<td>
<p>a vector containing the columns for the NHS numbers</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_hospital_number">hospital_number</code></td>
<td>
<p>a vector containing the columns for the Hospital numbers</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_patient_dob">patient_dob</code></td>
<td>
<p>a vector containing the columns for the date of birth</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_org_code">org_code</code></td>
<td>
<p>a vector containing the columns for the organisation codes</p>
</td></tr>
<tr><td><code id="link_ae_inpatient_+3A_.forcecopy">.forceCopy</code></td>
<td>
<p>a boolean to control if you want to copy the dataset before
linking together</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a patient level linked hospital record
</p>


<h3>See Also</h3>

<p>group_time continuous_inpatient_spells
</p>

<hr>
<h2 id='lookup_recode'>Lookup table switch handler</h2><span id='topic+lookup_recode'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
A function to call an epidm lookup table and
recode  where we are aware of a new value.
</p>
<p>Built in are  the organism re-classifications and specimen_type groupings
and a manual mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup_recode(src, type = c("species", "specimen", "manual"), .import = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_recode_+3A_src">src</code></td>
<td>
<p>a character, vector or column containing the value(s) to be referenced</p>
</td></tr>
<tr><td><code id="lookup_recode_+3A_type">type</code></td>
<td>
<p>a character value to denote the lookup table used</p>
</td></tr>
<tr><td><code id="lookup_recode_+3A_.import">.import</code></td>
<td>
<p>a list  in the order list(new,old) containing the
values for another lookup table existing in the environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object of the recoded field
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  spec = c(
    sample(grep(")",
                respeciate_organism$previous_organism_name,
                value=TRUE,
                invert = TRUE),
           9),
    "ESCHERICHIA COLI","SARS-COV-2","CANDIDA AUREUS"),
  type = sample(specimen_type_grouping$specimen_type,12),
  date = sample(seq.Date(from = Sys.Date()-365,
                         to = Sys.Date(),
                         by = "day"),12)
)
df &lt;- df[order(df$date),]

# show the data before the changes
df

# check the lookup tables
# observe the changes
head(respeciate_organism[1:2])
df$species &lt;- lookup_recode(df$spec,'species')
df[,c('spec','species','date')]

head(specimen_type_grouping)
df$grp &lt;- lookup_recode(df$type,'specimen')
df[,c('species','type','grp','date')]

# for a tidyverse use
# df %&gt;% mutate(spec=lookup_recode(spec,'species))

# manual input of your own lookup
# .import=list(new,old)
lookup_recode(
  "ALCALIGENES DENITRIFICANS",
  type = 'manual',
  .import=list(respeciate_organism$organism_species_name,
               respeciate_organism$previous_organism_name)
  )
</code></pre>

<hr>
<h2 id='proxy_episode_dates'>HES/SUS Episode Date Cleaning</h2><span id='topic+proxy_episode_dates'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Correcting for missing end dates on HES/SUS episodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proxy_episode_dates(
  x,
  group_vars,
  spell_start_date,
  spell_end_date,
  discharge_destination,
  .dropTmp = TRUE,
  .forceCopy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proxy_episode_dates_+3A_x">x</code></td>
<td>
<p>a data frame; will be converted to a data.table</p>
</td></tr>
<tr><td><code id="proxy_episode_dates_+3A_group_vars">group_vars</code></td>
<td>
<p>a vector containing any variables to be used for
record grouping, minimum is a patient identifier</p>
</td></tr>
<tr><td><code id="proxy_episode_dates_+3A_spell_start_date">spell_start_date</code></td>
<td>
<p>Inpatient provider spell or episode admission date</p>
</td></tr>
<tr><td><code id="proxy_episode_dates_+3A_spell_end_date">spell_end_date</code></td>
<td>
<p>Inpatient provider spell or episode discharge  date</p>
</td></tr>
<tr><td><code id="proxy_episode_dates_+3A_discharge_destination">discharge_destination</code></td>
<td>
<p>CDS discharge destination code</p>
</td></tr>
<tr><td><code id="proxy_episode_dates_+3A_.droptmp">.dropTmp</code></td>
<td>
<p>default TRUE; a logical to drop all tmp values used</p>
</td></tr>
<tr><td><code id="proxy_episode_dates_+3A_.forcecopy">.forceCopy</code></td>
<td>
<p>default FALSE; TRUE will force data.table to take a copy
instead of editing the data without reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with cleaned start and end dates, and an indicator proxy_missing where the value has changed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
proxy_test &lt;- data.frame(
  id = c(
    rep(3051, 4),
    rep(7835,3),
    rep(9891,3),
    rep(1236,3)
  ),
  provider = c(
    rep("QKJ", 4),
    rep("JSD",3),
    rep("YJG",3),
    rep("LJG",3)
  ),
  spell_start = as.Date(c(
    "2020-07-03", "2020-07-14", "2020-07-23", "2020-08-05",
    "2020-11-01", "2020-11-13", "2020-12-01",
    "2020-03-28", "2020-04-06", "2020-04-09",
    "2020-10-06", "2020-11-05", "2020-12-25"
  )),
  spell_end = as.Date(c(
    "2020-07-11", "2020-07-22", "2020-07-30", "2020-07-30",
    "2020-11-11", NA, "2020-12-03",
    "2020-03-28", NA, "2020-04-09",
    "2020-10-06", "2020-11-05", NA
  )),
  disdest = c(
    19, 19, 51, 19,
    19, 19, 19,
    51, 98, 19,
    19, 19, 98
  )
)


proxy_episode_dates(
  x=proxy_test,
  group_vars = c('id','provider'),
  spell_start_date = 'spell_start',
  spell_end_date = 'spell_end',
  discharge_destination = 'disdest'
)[]
</code></pre>

<hr>
<h2 id='respeciate_generic'>Respeciate unspecified samples</h2><span id='topic+respeciate_generic'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Some samples within SGSS are submitted by laboratories as &quot;GENUS SP&quot; or
&quot;GENUS UNNAMED&quot;. However, they may also have a fully identified sample taken
from the same site within a recent time period.  This function captures
species_col  from another sample within X-days of an unspeciated isolate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>respeciate_generic(
  x,
  group_vars,
  species_col,
  date_col,
  window = c(0:Inf),
  .forceCopy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="respeciate_generic_+3A_x">x</code></td>
<td>
<p>a data.frame or data.table object</p>
</td></tr>
<tr><td><code id="respeciate_generic_+3A_group_vars">group_vars</code></td>
<td>
<p>the minimum grouping set of variables for like samples in
a character vector; suggest c('patient_id','specimen_type','genus')</p>
</td></tr>
<tr><td><code id="respeciate_generic_+3A_species_col">species_col</code></td>
<td>
<p>a character containing the column with the organism species_col
name</p>
</td></tr>
<tr><td><code id="respeciate_generic_+3A_date_col">date_col</code></td>
<td>
<p>a character containing the column with the specimen/sample date_col</p>
</td></tr>
<tr><td><code id="respeciate_generic_+3A_window">window</code></td>
<td>
<p>an integer representing the number of days for which you will
allow a sample to be respeciated</p>
</td></tr>
<tr><td><code id="respeciate_generic_+3A_.forcecopy">.forceCopy</code></td>
<td>
<p>default FALSE; TRUE will force data.table to take a copy
instead of editing the data without reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with a recharacterised <code>species_col</code> column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
ptid = c(round(runif(25,1,5))),
spec = sample(c("KLEBSIELLA SP",
                "KLEBSIELLA UNNAMED",
                "KLEBSIELLA PNEUMONIAE",
                "KLEBEIELLA OXYTOCA"),
              25,replace = TRUE),
type = "BLOOD",
specdate = sample(seq.Date(Sys.Date()-21,Sys.Date(),"day"),25,replace = TRUE)
)

respeciate_generic(x=df,
                   group_vars=c('ptid','type'),
                   species_col='spec',
                   date_col='specdate',
                   window = 14)[]

</code></pre>

<hr>
<h2 id='respeciate_organism'>Respeciated organisms</h2><span id='topic+respeciate_organism'></span>

<h3>Description</h3>

<p>Occasionally, research shows that two organisms, previously thought to be
different are in fact one and the same. The reverse is also true.
This is  a manually updated list.
If there are organisms missing, or new respeciates to be added,
please raise and issue or push request on the
<a href="https://github.com/alexbhatt/epidm">epidm GitHub</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>respeciate_organism
</code></pre>


<h3>Format</h3>


<dl>
<dt>previous_organism_name</dt><dd><p>What the organism used to be known as, in the form GENUS SPECIES</p>
</dd>
<dt>organism_species_name</dt><dd><p>What the organism is known as now, in the form GENUS SPECIES</p>
</dd>
<dt>organism_genus_name</dt><dd><p>The genus of the recoded organism</p>
</dd>
<dt>genus_change</dt><dd><p>A 0/1 flag to indicate if the genus has changed</p>
</dd>
<dt>genu_all_species</dt><dd><p>A 0/1 flag to indicate if all species under that genus should change</p>
</dd>
</dl>


<hr>
<h2 id='specimen_type_grouping'>Specimen type grouping</h2><span id='topic+specimen_type_grouping'></span>

<h3>Description</h3>

<p>In order to help clean up an analysis based on a group of specimen types,
a lookup table has been created to help group sampling sites.
This is  a manually updated list.
If there are organisms missing, or new respeciates to be added,
please raise and issue or push request on the
<a href="https://github.com/alexbhatt/epidm">epidm GitHub</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specimen_type_grouping
</code></pre>


<h3>Format</h3>


<dl>
<dt>specimen_type</dt><dd><p>The primary specimen type with detail</p>
</dd>
<dt>specimen_group</dt><dd><p>A simple grouping of like specimen sites</p>
</dd>
</dl>


<hr>
<h2 id='sql_clean'>Clean and Read a SQL query</h2><span id='topic+sql_clean'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>A utility function to read in a SQL query from a character object, clipboard
or text file and remove all comments for use with database query packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_clean(sql)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_clean_+3A_sql">sql</code></td>
<td>
<p>a SQL file or text string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cleaned SQL query without comments as a character string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testSQL &lt;- c(
"/********* INTRO HEADER COMMENTS",
"*********/",
"  SELECT ",
"  [VAR 1]  -- with comments",
",[VAR 2]",",[VAR 3]",
"FROM DATASET ","-- output here")
sql_clean(testSQL)


</code></pre>

<hr>
<h2 id='sql_connect'>Connect to a SQL database</h2><span id='topic+sql_connect'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>An function to help setup connections to SQL databases
acting as a wrapper for the odbc and DBI packages. Used by other sql_*
tools within epidm. This uses the credential manager within the system and
assumes you are using a trusted connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_connect(server, database)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_connect_+3A_server">server</code></td>
<td>
<p>a string containing the server connection;
note that servers may require the use of double backslash <code style="white-space: pre;">&#8288;\\&#8288;</code></p>
</td></tr>
<tr><td><code id="sql_connect_+3A_database">database</code></td>
<td>
<p>a string containing the database name within the data store</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SQL connection object
</p>


<h3>See Also</h3>

<p>sql_clean sql_read sql_write
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sql &lt;- list(
  dsn = list(ser = 'covid.ukhsa.gov.uk',
             dbn = 'infections')
)

sgss_con = sql_connect(server = sql$dsn$ser, database = sql$dsn$dbn)

## End(Not run)

</code></pre>

<hr>
<h2 id='sql_read'>Read a table from a SQL database</h2><span id='topic+sql_read'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Read a table object to a SQL database. Acts a wrapper for odbc and DBI
packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_read(server, database, sql)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_read_+3A_server">server</code></td>
<td>
<p>a string containing the server connection</p>
</td></tr>
<tr><td><code id="sql_read_+3A_database">database</code></td>
<td>
<p>a string containing the database name within the data store</p>
</td></tr>
<tr><td><code id="sql_read_+3A_sql">sql</code></td>
<td>
<p>a string containing a SQL query or to a .sql/.txt SQL query</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table from a SQL database
</p>


<h3>See Also</h3>

<p>sql_clean sql_connect
</p>

<hr>
<h2 id='sql_write'>Write a table to a SQL database</h2><span id='topic+sql_write'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Write a table object to a SQL database. Acts a wrapper for odbc and DBI
packages with additional checks to ensure upload completes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_write(x, server, database, tablename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_write_+3A_x">x</code></td>
<td>
<p>a data.frame/data.table/tibble object</p>
</td></tr>
<tr><td><code id="sql_write_+3A_server">server</code></td>
<td>
<p>a string containing the server connection</p>
</td></tr>
<tr><td><code id="sql_write_+3A_database">database</code></td>
<td>
<p>a string containing the database name within the data store</p>
</td></tr>
<tr><td><code id="sql_write_+3A_tablename">tablename</code></td>
<td>
<p>a string containing the chosen SQL database table name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>writes a data.frame/data.table/tibble to a SQL database
</p>

<hr>
<h2 id='uk_patient_id'>Patient ID record grouping</h2><span id='topic+uk_patient_id'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Groups patient records from multiple isolates with a single integer patientID
by grouping patient identifiers.
</p>
<p>Grouping is based on five stages:
</p>

<ol>
<li><p> matching nhs number and date of birth
</p>
</li>
<li><p> Hospital number &amp;  Date of Birth
</p>
</li>
<li><p> NHS number &amp; Hospital Number
</p>
</li>
<li><p> Date of Birth &amp; Surname IF nhs unknown
</p>
</li>
<li><p> Sex &amp; Date of Birth &amp; Fuzzy Name
</p>
</li></ol>

<p>Identifiers are copied over where they are missing or invalid to the grouped
records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uk_patient_id(
  x,
  nhs_number,
  hospital_number,
  date_of_birth,
  sex_mfu,
  forename = "NONAME",
  surname = "NONAME",
  .sortOrder,
  .keepValidNHS = FALSE,
  .forceCopy = FALSE,
  .experimental = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uk_patient_id_+3A_x">x</code></td>
<td>
<p>a data.frame or data.table containing the cleaned line list</p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_nhs_number">nhs_number</code></td>
<td>
<p>a column as a character containing the patient NHS numbers</p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_hospital_number">hospital_number</code></td>
<td>
<p>a column as a character containing the patient
Hospital numbers</p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_date_of_birth">date_of_birth</code></td>
<td>
<p>a column as a date variable containing the patient
date of birth in date format</p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_sex_mfu">sex_mfu</code></td>
<td>
<p>column as a character containing the patient sex;
NOTE only works if coded only as character versions of Male/Female/Unknown;
does not currently work with additional options <code style="white-space: pre;">&#8288;#future update&#8288;</code></p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_forename">forename</code></td>
<td>
<p>a column as a character containing the patient forename;
leave as NONAME if unavailable</p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_surname">surname</code></td>
<td>
<p>a column as a character containing the patient surname;
leave as NONAME if unavailable</p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_.sortorder">.sortOrder</code></td>
<td>
<p>optional; a column as a character to allow a sorting
order on the id generation</p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_.keepvalidnhs">.keepValidNHS</code></td>
<td>
<p>optional, default FALSE; set TRUE if you wish to retain
the column with the NHS checksum result stored as a BOOLEAN</p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_.forcecopy">.forceCopy</code></td>
<td>
<p>optional, default FALSE; TRUE will force data.table to take a copy
instead of editing the data without reference</p>
</td></tr>
<tr><td><code id="uk_patient_id_+3A_.experimental">.experimental</code></td>
<td>
<p>optional, default FALSE; TRUE will enable the
experimental features for recoding NA values based on the mode</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with one new variable:
</p>

<dl>
<dt><code>id</code></dt><dd><p>a unique patient id</p>
</dd>
<dt><code>valid_nhs</code></dt><dd><p>if retained using argument <code>.keepValidNHS=TRUE</code>, a
BOOLEAN containing the result of the NHS checksum validation</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>id_test &lt;- data.frame(
  nhs_n = c(
    9434765919,9434765919,9434765919,NA,NA,
    3367170666,5185293519,5185293519,5185293519,8082318562,NA,NA,NA
  ),
  hosp_n = c(
    '13','13','13','UNKNOWN','13','13','13','31','31','96','96',NA,'96'),
  sex = c(rep('F',6),rep('Male',4), 'U', 'U', 'M'),
  dateofbirth = as.Date(
    c(
      '1988-10-06','1988-10-06','1900-01-01','1988-10-06','1988-10-06',
      '1988-10-06','1988-10-06','1988-10-06','1988-10-06','2020-01-28',
      '2020-01-28','2020-01-28','2020-01-28'
    )
  ),
  firstname = c(
    'Danger','Danger','Denger','Danger','Danger','DANGER','Danger',
    'Danger','Danger','Crazy','Crazy','Krazy','C'
  ),
  lastname = c(
    'Mouse','Mause','Mouse','Moose','Moose','Mouse','MOUSe',
    'Mouse','Mouse','Frog','FROG','Frug','Frog'
  ),
  testdate = sample(seq.Date(Sys.Date()-21,Sys.Date(),"day"),13,replace = TRUE)
)
uk_patient_id(x = id_test,
              nhs_number = 'nhs_n',
              hospital_number = 'hosp_n',
              forename = 'firstname',
              surname = 'lastname',
              sex_mfu = 'sex',
              date_of_birth = 'dateofbirth',
              .sortOrder = 'testdate')[]

</code></pre>

<hr>
<h2 id='valid_nhs'>NHS Number Validity Check</h2><span id='topic+valid_nhs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Check if NHS numbers are valid based on the checksum algorithm
</p>
<p>This uses the first 9 digits, multiplied by 10 down to 2 eg digit 1x10, d2x9
</p>
<p>The sum of the products of the first 9 digits are divided by 11
</p>
<p>The remainder is checked against the 10th digit
</p>
<p>Where the remainder is 11, it is replaced with 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_nhs(nhs_number)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid_nhs_+3A_nhs_number">nhs_number</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector, 1 if NHS number is valid, 0 if not valid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- floor(runif(1000,1000000000,9999999999))
valid_nhs(test)
valid_nhs(9434765919)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
