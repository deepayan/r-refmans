<!DOCTYPE html><html><head><title>Help for package hysteresis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hysteresis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hysteresis-package'>
<p>Modeling Rate-Dependent Hysteretic Processes</p></a></li>
<li><a href='#EllipseData'>
<p>Simulated Ellipse Data for 6 Ellipses with period=24.</p></a></li>
<li><a href='#fel'>
<p>Fitting Ellipses</p></a></li>
<li><a href='#fel.repeated'>
<p>Methods for easily fitting multiple ellipses from repeated measures designs.</p></a></li>
<li><a href='#floop'>
<p>Fit a Hysteresis Loop</p></a></li>
<li><a href='#floop.repeated'>
<p>Methods for easily fitting multiple loops from repeated measures designs.</p></a></li>
<li><a href='#floopReflect'>
<p>Fitting hysteresis loops for reflected data</p></a></li>
<li><a href='#HysteresisData'>
<p>Simulated Loop Data for 6 Loops with period=24, n=5 and m=3</p></a></li>
<li><a href='#loop.parameters'>
<p>Inherent and Derived Parameter Definitions for Hysteresis Loops/Ellipses</p></a></li>
<li><a href='#mel'>
<p>Simulate (Make) an Ellipse</p></a></li>
<li><a href='#mloop'>
<p>Simulate (Make) a Hysteresis Loop</p></a></li>
<li><a href='#plot.fittedloop'>
<p>Plot a fitted ellipse or hysteresis loop.</p></a></li>
<li><a href='#residuals.fittedloop'>
<p>Residuals, studentized residuals and fitted values for the hysteresis package.</p></a></li>
<li><a href='#summary.fittedloop'>
<p>Summarizing and Bootstrapping Fitted Ellipses or Loops</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Modeling Rate-Dependent Hysteretic Processes and
Ellipses</td>
</tr>
<tr>
<td>Version:</td>
<td>2.7.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Spencer Maynes, Fan Yang, and Anne Parkhurst</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Spencer Maynes &lt;smaynes89@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>car, msm, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit, summarize and plot sinusoidal hysteretic processes using:
    two-step simple harmonic least squares, ellipse-specific non-linear least
    squares, the direct method, geometric least squares or linear least squares. See 
    Yang, F and A. Parkhurst, "Efficient Estimation of Elliptical Hysteresis with 
    Application to the Characterization of Heat Stress" &lt;<a href="https://doi.org/10.1007%2Fs13253-015-0213-6">doi:10.1007/s13253-015-0213-6</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-27 23:48:45 UTC; Client</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hysteresis-package'>
Modeling Rate-Dependent Hysteretic Processes
</h2><span id='topic+hysteresis-package'></span><span id='topic+hysteresis'></span>

<h3>Description</h3>

<p>Fit, summarize and plot sinusoidal hysteretic processes using two step harmonic least squares. If the process is elliptical, other methods such as a geometric method, Halir and Flusser's direct specific least squares, ordinary least squares,
and ellipse-specific non-linear least squares are also available.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> hysteresis</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.7.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-26</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> gpl (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Fits input and output variables x and y that form a hysteresis loop based on the generalized transcendental equation </p>
<p style="text-align: center;"><code class="reqn">x_t=b.x*cos(2pi*t/period+phase.angle)+cx+e_{x,t}</code>
</p>
 <p style="text-align: center;"><code class="reqn">y_t=b.y*cos(2pi*t/period+phase.angle)^n+retention*sin(2pi*t/period+phase.angle)^m+cy+e_{y,t}</code>
</p>
<p>  where </p>
<p style="text-align: center;"><code class="reqn">t=0,...,n.points-1 if times='equal'</code>
</p>
 
<p>The functions <code><a href="#topic+mloop">mloop</a></code> and <code><a href="#topic+floop">floop</a></code> can be used to simulate, fit, and obtain derived parameter estimates (see <code><a href="#topic+loop.parameters">loop.parameters</a></code> or <code><a href="#topic+ellipse.parameters">ellipse.parameters</a></code> ) along with delta method standard errors for hysteresis loops.. Additionally <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code> can be used to bootstrap results in order to produce less biased standard errors for derived parameters and obtain a model fit that is not dependent on the assumption of independent and normally distributed errors.
If m=1 and n=1 then the hysteresis loop will form an ellipse which can be simulated with <code><a href="#topic+mel">mel</a></code>, fitted using 5 different available methods with <code><a href="#topic+fel">fel</a></code>, and bootstrapped using the function method <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code>.
If the upper and lower halves of the loop are structered differently, then the functions <code><a href="#topic+mloop2r">mloop2r</a></code>, <code><a href="#topic+floop2r">floop2r</a></code> and <code><a href="#topic+summary.loop2r">summary.loop2r</a></code> should be used. These functions fit a model with two values of retention for when the curve is above and below the split line.
Studentized residuals are also available ((see <code><a href="#topic+residuals.ellipsesummary">residuals.ellipsesummary</a></code>).
</p>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>
<p>Maintainer: Spencer Maynes &lt;smaynes89@gmail.com&gt;
</p>


<h3>References</h3>

<p>Yang, F and A. Parkhurst, &quot;Efficient Estimation of Elliptical Hysteresis with 
Application to the Characterization of Heat Stress&quot; DOI:10.1007/s13253-015-0213-6
</p>


<h3>See Also</h3>

<p>Check out the vignette browseURL(system.file('doc/index.html',package='hysteresis')) <br />
For simulating hysteresis loops, <code><a href="#topic+mloop">mloop</a></code> and <code><a href="#topic+mel">mel</a></code>. <br />
For fitting hysteresis loops, <code><a href="#topic+floop">floop</a></code> and <code><a href="#topic+fel">fel</a></code>. <br />
For summarizing hysteresis loops, <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code> and <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code>. <br />
For bootstrapping ellipses, <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code>.
For fitting multiple hysteresis loops at once, can use <code><a href="#topic+fel">fel</a></code> and <code><a href="#topic+floop">floop</a></code> or <code><a href="#topic+fel.repeated">fel.repeated</a></code> and <code><a href="#topic+floop.repeated">floop.repeated</a></code> which can be easier to use for studies involving repeated measures. <br />
Miscellaneous <code><a href="#topic+plot.ellipsefit">plot.ellipsefit</a></code>, <code><a href="#topic+plot.ellipsefitlist">plot.ellipsefitlist</a></code>, <code><a href="#topic+plot.ellipsesummary">plot.ellipsesummary</a></code>, <code><a href="#topic+residuals.ellipsesummary">residuals.ellipsesummary</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Take a look at the vignette.
#browseURL(system.file('doc/index.html',package='hysteresis'))

### Simulate and fit a hysteresis loop with m=3 and n=5.
 loop1 &lt;- mloop(sd.x=0.05,sd.y=0.05,n=5,m=3)
 model &lt;- floop(loop1$x,loop1$y,n=5,m=3)
 model                #Gives estimate with delta standard errors
 model$Estimates      #Gives estimates  
 model$Std.Errors     #Lists delta standard errors  
 
### Plot hysteresis loop.
 plot(model,main="Simulated Hysteresis Loop n=5 m=3")

### Bootstrap estimates and standard errors (Seed is necessary if want to reproduce results)
 booted.loop &lt;- floop(loop1$x,loop1$y,,n=5,m=3,boot=TRUE, seed=1523)
 booted.loop                   #Gives boot estimates, boot bias, boot SE and boot quartiles
 booted.loop$Boot.Estimates    #Gives boot estimates 
 booted.loop$Boot.Std.Errors   #Gives boot standard errors 
plot(booted.loop,main="Simulated Bootstrapped Loop n=5, m=3",putNumber=TRUE)


### Simulate and fit an ellipse.
ellipse1 &lt;- mel(sd.x=0.2,sd.y=0.04)
ellipse1.fit &lt;- fel(ellipse1$x,ellipse1$y)
ellipse1.fit             #Gives estimates with delta standard errors and 95%CI
ellipse1.fit$Estimates      #Gives all estimates 
ellipse1.fit$Std.Errors     #Lists delta standard errors  

### Plot ellipse
plot(ellipse1.fit,xlab="Input",ylab="Output",main="Simulated Ellipse")

### Bootstrap estimates and standard errors (Seed is necessary if want to reproduce results)
booted.ellipse &lt;- fel(ellipse1$x,ellipse1$y,boot=TRUE, seed=123)
booted.ellipse                 #Gives boot estimates, boot bias, boot SE and boot quartiles
booted.ellipse$Boot.Estimates  #Gives boot estimates   
booted.ellipse$Boot.Std.Errors #Gives boot standard errors

</code></pre>

<hr>
<h2 id='EllipseData'>
Simulated Ellipse Data for 6 Ellipses with period=24.
</h2><span id='topic+EllipseData'></span>

<h3>Description</h3>

<p>Three subjects with two replications = 6 ellipses created by mel. All 6 ellipses are centered around the origin with a phase angle of pi/2 and 
differ by subject in terms of their retention (0.4,0.8,0.4) and b.x saturation point (0.6,0.6,1). 
Errors in both the input and the output are given a standard deviation of 0.1 for all ellipses. Used in the help page for <code><a href="#topic+fel.repeated">fel.repeated</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EllipseData)</code></pre>


<h3>Format</h3>

<p>A data frame with 144 observations on the following 4 variables. 
</p>

<dl>
<dt><code>X</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>subjects</code></dt><dd><p>subject, one of &quot;A&quot;, &quot;B&quot;, or &quot;C&quot;.</p>
</dd>
<dt><code>repeated</code></dt><dd><p>which ellipse for subject. Either 1 or 2.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Data is created using the following code
set.seed(1)
ellip1 &lt;- mel(method = 2, retention = 0.4, b.x = 0.6, b.y = 0.8, cx = 0, cy = 0, 
    sd.x = 0.1, sd.y = 0.1, period = 24, n.points = 48, phase.angle = pi/2)
ellip2 &lt;- mel(method = 2, retention = 0.8, b.x = 0.6, b.y = 0.8, cx = 0, cy = 0, 
    sd.x = 0.1, sd.y = 0.1, period = 24, n.points = 48, phase.angle = pi/2)
ellip3 &lt;- mel(method = 2, retention = 0.4, b.x = 1, b.y = 0.8, cx = 0, cy = 0, 
    sd.x = 0.1, sd.y = 0.1, period = 24, n.points = 48, phase.angle = pi/2)
X &lt;- c(ellip1$x, ellip2$x, ellip3$x)
Y &lt;- c(ellip1$y, ellip2$y, ellip3$y)
subjects &lt;- c(rep("A", length(ellip1$x)), rep("B", length(ellip2$x)), rep("C", 
    length(ellip3$x)))  
    repeated &lt;- rep(c(1,2),each=24,times=3)  
    
##Use data file to fit 6 ellipses.
data(EllipseData) 
six.models &lt;- fel.repeated(EllipseData$X, EllipseData$Y, method = "harmonic2",
subjects = EllipseData$subjects,repeated=EllipseData$repeated)
six.models
 
#Model fit for B-1
six.models$models["B",1] 
par(mfrow=c(2,3))
plot(six.models,xlab="X input",ylab="Y output")
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='fel'>
Fitting Ellipses
</h2><span id='topic+fel'></span>

<h3>Description</h3>

<p>Fit a sinusoidal hysteretic (elliptical) process between an input and an output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fel(x, y=NULL, method = "harmonic2", period = NULL, subjects = NULL,
  times="unknown",subset = NULL,na.action= getOption("na.action"),
  control=nls.control(), boot=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fel_+3A_x">x</code></td>
<td>

<p>input
</p>
</td></tr>
<tr><td><code id="fel_+3A_y">y</code></td>
<td>

<p>output
</p>
</td></tr>
<tr><td><code id="fel_+3A_method">method</code></td>
<td>

<p>the method to be used for fitting; one of either the default <code>method="harmonic2"</code>, <code>method="nls"</code>, <code>method="direct"</code>, <code>method="lm"</code> or <code>method="geometric"</code>.
</p>
</td></tr>
<tr><td><code id="fel_+3A_period">period</code></td>
<td>

<p>an optional number that defines the length of the <code>period</code>.
</p>
</td></tr>
<tr><td><code id="fel_+3A_subjects">subjects</code></td>
<td>

<p>an optional factor or list of factors, each of the same length as x. Use to identify several different ellipses to fit at once, in which case <code>fel</code> returns an object of class <code>ellipsefitlist</code> instead of <code>ellipsefit</code>. If <code>subjects</code> is a list of factors each combination of the factors must be present in the data or an error will be produced.
</p>
</td></tr>
<tr><td><code id="fel_+3A_times">times</code></td>
<td>

<p>either a numeric vector of length <code>nrow(x)</code> or one of the two options &quot;equal&quot; or the default &quot;unknown&quot;. If the times at which ellipse observations are taken are known, a numeric vector
can be used to give those times. If not, predicted values are found by minimizing geometric distances from the fitted ellipse to the observations. If &quot;equal&quot;, time points are assumed to be equally spaced in a counterclockwise fashion. Do not use the &quot;harmonic2&quot; method unless times are either known or are known to be equal. Bootstrapping results are also more accurate if correct times are used.</p>
</td></tr>
<tr><td><code id="fel_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="fel_+3A_control">control</code></td>
<td>

<p>optional and only used if <code>method="nls"</code> or <code>"geometric"</code>. See <code><a href="stats.html#topic+nls.control">nls.control</a></code> for <code>method="nls"</code>.
</p>
</td></tr>
<tr><td><code id="fel_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain NAs. The default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, the factory-fresh default 
is <code><a href="stats.html#topic+na.omit">na.omit</a></code>. Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.
</p>
</td></tr>
<tr><td><code id="fel_+3A_boot">boot</code></td>
<td>

<p>logical, if <code>TRUE</code> results will be bootstrapped by <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code>.
</p>
</td></tr>
<tr><td><code id="fel_+3A_...">...</code></td>
<td>

<p>other othrt optional arguments passed to <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code> if <code>boot=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Where the response y is a sinusoidal process with an element of randomness that lags the controlling input x, which is also a stochastic sinusoidal process, an ellipse can be used to fit the relationship between
x and y.
</p>
<p>The values of parameters such as area, lag, retention, coercion, split angle and hysteresis.y are estimated from this ellipse. See <code><a href="#topic+loop.parameters">loop.parameters</a></code>.
</p>
<p>The harmonic2 method is a two step harmonic least squares model using generalized transcendental equations presented by Lapshin (1995).  Yang and Parkhurst provide the efficient estimates 
for parameters and as such &quot;harmonic2&quot; is used as the default. Direct specific least squares (<code>method="direct"</code>) based on the work of Radim Halir and Jan Flusser is also available although work on delta method standard errors is still in progress. The geometric method is based on the work of Gander, Golub and Strebel and uses the results of an initial direct method to produce an ellipse that minimizes the sum of the squared geometric distances. Finally <code>method="lm"</code> and 
ellipse specific non-linear least squares (<code>method="nls"</code>) are included as well.
</p>
<p>If x and y contain more than 1 ellipse that needs to be fit, the argument <code>subjects</code> can be used to identify a period of data to fit separate ellipses.
</p>
<p>Bootstrapped estimates for parameter values are provided with <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code>.  These bootstrapped estimates are generally less biased than those provided by <code>fel</code> in isolation.
</p>


<h3>Value</h3>

<p><code>fel</code> returns an object of class <code>ellipsefit</code> or <code>ellipsefitlist</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>information dependent on the fitting method used.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the <code>method</code> used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the input x used.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the output y used.</p>
</td></tr>
<tr><td><code>pred.x</code></td>
<td>
<p>the fitted values for x.</p>
</td></tr>
<tr><td><code>pred.y</code></td>
<td>
<p>the fitted values for y.</p>
</td></tr>
<tr><td><code>period.time</code></td>
<td>
<p>a vector that contains times converted to radians for observations, either estimated after the ellipse has been fitted or given beforehand by <code>times</code>.</p>
</td></tr>
<tr><td><code>fit.statistics</code></td>
<td>
<p>rudimentary measures, based on the &quot;harmonic2&quot; method, include the Multivariate Final Prediction Error (MFPE) and the AIC for both the output alone and the two variables in combination. 
Although degree of freedom adjustments are made for other methods, measures of fit require further study.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>a named vector of parameter estimates. See <code><a href="#topic+loop.parameters">loop.parameters</a></code>, same as Estimates here.</p>
</td></tr>
<tr><td><code>Estimates</code></td>
<td>
<p>a named vector of parameter estimates. See <code><a href="#topic+loop.parameters">loop.parameters</a></code>, same as values.</p>
</td></tr>
<tr><td><code>Std.Errors</code></td>
<td>
<p>Delta standard errors produced by the delta method.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>algebraic residuals from the model. The function <code><a href="#topic+residuals.ellipsefit">residuals.ellipsefit</a></code> can produce other types of residuals from an <code>ellipsefit</code> object.</p>
</td></tr>
</table>
<p>if <code>boot==TRUE</code> <code><a href="#topic+fel">fel</a></code> returns an object of class <code>ellipsesummary</code> by making a call to <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code>. See <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code>.
</p>
<p>For bootstrapping
</p>
<table>
<tr><td><code>Boot.Estimates</code></td>
<td>
<p>bootstrapped estimates.</p>
</td></tr>
<tr><td><code>Boot.Std.Errors</code></td>
<td>
<p>bootstrap standard errors.</p>
</td></tr>
</table>
<p>If multiple ellipses are fit simultaneously there will be three arguments to the response, models which will contain the separate model fits for each ellipse, Estimates which will have all of the parameter estimates in matrix form, and Std.Errors which will have all of the delta method standard errors in matrix form. See <code><a href="#topic+fel.repeated">fel.repeated</a></code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Yang, F and A. Parkhurst, &quot;Efficient Estimation of Elliptical Hysteresis with 
Application to the Characterization of Heat Stress&quot; DOI:10.1007/s13253-015-0213-6
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ellipsefit">plot.ellipsefit</a></code> for plotting and <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code> for summarizing and bootstrapping an <code>ellipsefit</code> object. Also <code><a href="#topic+residuals.ellipsefit">residuals.ellipsefit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulate and fit a Single ellipse.
Sellipse &lt;- mel(method=2,sd.x=0.2,sd.y=0.04)
Sellipse.fit &lt;- fel(Sellipse$x,Sellipse$y)
Sellipse.fit  #Gives estimates, delta standard errors and 95% CI
Sellipse.fit$Estimates  

### Bootstrap estimates and standard errors (Seed is necessary if want to reproduce results)
booted.Sellipse &lt;- fel(Sellipse$x,Sellipse$y,boot=TRUE, seed=123)
booted.Sellipse   #Gives boot estimates, boot bias, boot SE and boot quartiles
plot(booted.Sellipse,main="Simulated Bootstrap Ellipse Loop",xlab="X Input",
ylab="Y Output",values="ellipse.all")

</code></pre>

<hr>
<h2 id='fel.repeated'>
Methods for easily fitting multiple ellipses from repeated measures designs.
</h2><span id='topic+fel.repeated'></span><span id='topic+summary.ellipsefitlist'></span>

<h3>Description</h3>

<p>Fit a sinusoidal hysteretic process between an input and an output variable across multiple loops separated by subjects and repeated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fel.repeated(x,y=NULL,subjects=NULL,repeated=NULL,subjects.in="all",repeated.in="all",...)
## S3 method for class 'ellipsefitlist'
summary(object,N=1000,boot=TRUE,seed=NULL,...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fel.repeated_+3A_x">x</code></td>
<td>

<p>numeric input vector.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_y">y</code></td>
<td>

<p>numeric output vector.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_subjects">subjects</code></td>
<td>

<p>factor of the same length as x that represents experimental units.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_repeated">repeated</code></td>
<td>

<p>factor of the same length as x that represents the repeated measure.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_subjects.in">subjects.in</code></td>
<td>

<p>a vector of characters, the levels of <code>subjects</code> to be included. Default is &quot;all&quot;.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_repeated.in">repeated.in</code></td>
<td>

<p>a vector of characters, the levels of <code>repeated</code> to be included. Default is &quot;all&quot;.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_object">object</code></td>
<td>

<p>an <code>ellipsefitlist</code> object.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_n">N</code></td>
<td>

<p>Number of bootstrap replicates.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_boot">boot</code></td>
<td>

<p>whether to use bootstrapping to obtain standard errors and less biased parameter estimates.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_seed">seed</code></td>
<td>

<p>for generating random numbers. See <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>.
</p>
</td></tr>
<tr><td><code id="fel.repeated_+3A_...">...</code></td>
<td>

<p>extra arguments to either <code><a href="#topic+fel">fel</a></code> or <code><a href="#topic+summary.ellipsefitlist">summary.ellipsefitlist</a>.</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits multiple ellipses with one call, separated by the factors <code>subjects</code> and <code>repeated</code>. The arguments <code>subjects.in</code> and <code>repeated.in</code> are used to select subsets of the factors <code>subjects</code> and <code>repeated</code>.
</p>


<h3>Value</h3>

<p><code>fel.repeated</code> returns an object of class <code>ellipsefitlist</code>.
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p>Separate model fits for each ellipse, see <code><a href="#topic+fel">fel</a></code>.</p>
</td></tr>
<tr><td><code>Estimates</code></td>
<td>
<p>Parameter estimates for all ellipses in matrix form.</p>
</td></tr>
<tr><td><code>Std.Errors</code></td>
<td>
<p>Delta standard errors for all ellipses in matrix form.</p>
</td></tr>
</table>
<p>When <code>boot=TRUE</code> <code><a href="#topic+fel.repeated">fel.repeated</a></code> returns an object of class <code>ellipsesummarylist</code> which consists of
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p> a vector of separate model summaries for each ellipse, see <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code>.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>Bootstrapped parameter estimates, standard errors, quantiles, and more for each ellipse.</p>
</td></tr>
<tr><td><code>Boot.Estimates</code></td>
<td>
<p>Bootstrapped parameter estimates with reduced bias.</p>
</td></tr>
<tr><td><code>Boot.Std.Errors</code></td>
<td>
<p>Standard errors provided by bootstrapping.</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Yang, F. and A. Parkhurst, Efficient Estimation of Elliptical Hysteresis (submitted)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fel">fel</a></code> for a more general way to fit multiple ellipses, or for fitting just one ellipse. <code><a href="#topic+plot.ellipsefit">plot.ellipsefit</a></code> for plotting and <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code> for summarizing and bootstrapping an <code>ellipsefitlist</code> object. Also <code><a href="#topic+residuals.ellipsefitlist">residuals.ellipsefitlist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Select 2 subjects with 2 replications and fit 4 ellipses
data(EllipseData) 
emodels.rep &lt;- fel.repeated(EllipseData$X, EllipseData$Y, method = "harmonic2", 
subjects = EllipseData$subjects,subjects.in=c("A","C"),
repeated=EllipseData$repeated)
emodels.rep                #Gives estimates and delta standard errors 
emodels.rep$Estimates      #List estimates only
emodels.rep$Std.Errors     #List delta standard errors 
par(mfrow=c(2,2))
plot(emodels.rep, main="Repeated Ellipses",xlab="X",ylab="Y")
par(mfrow=c(1,1))

### Bootstrap estimates and standard errors (Seed is necessary if want to reproduce results)
boot.rep.ellipse&lt;-fel.repeated(EllipseData$X,EllipseData$Y,method = "harmonic2",
subjects = EllipseData$subjects,subjects.in=c("A","C"),
repeated=EllipseData$repeated,boot=TRUE,seed=123)
boot.rep.ellipse  #Gives boot estimates, boot bias, boot SE and boot quartiles
par(mfrow=c(2,2))
plot(boot.rep.ellipse, main="Repeated Ellipses",xlab="X",ylab="Y",values="ellipse")
par(mfrow=c(1,1))

##Can write results to a file. First set your directory from the file tab.
#Change file path in command below to coincide with where you want to store data files
#setwd("C:/Users................")
#write.table(boot.rep.ellipse$Boot.Estimates,"Ellipes.eg.repbootvalues.txt")
#test.fel=read.table("Ellipes.eg.repbootvalues.txt",header=TRUE)
#head(test.fel)
</code></pre>

<hr>
<h2 id='floop'>
Fit a Hysteresis Loop
</h2><span id='topic+floop'></span><span id='topic+floop2r'></span>

<h3>Description</h3>

<p>Fits a hysteresis loop given values of n and m chosen by the user. <code>floop2r</code> fits an asymetric loop with different values
for retention above and below the split line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>floop(x,y=NULL,n=1,m=1,times="equal",period=NULL,
subjects=NULL, subset=NULL,na.action=getOption("na.action"),
extended.classical=FALSE,boot=FALSE,method="harmonic2",
...) 
floop2r(x,y=NULL,n=1,m=1,times="equal",period=NULL,
subjects=NULL, subset=NULL,na.action=getOption("na.action"),
extended.classical=FALSE,boot=FALSE,method="harmonic2",
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="floop_+3A_x">x</code></td>
<td>

<p>numeric input vector.
</p>
</td></tr>
<tr><td><code id="floop_+3A_y">y</code></td>
<td>

<p>numeric output vector.
</p>
</td></tr>
<tr><td><code id="floop_+3A_n">n</code></td>
<td>

<p>a positive integer. Shape parameter regulating the central &quot;plateau&quot; of the hysteresis loop. Default is 1, which makes loop an ellipse when m is also equal to 1. See details.
</p>
</td></tr>
<tr><td><code id="floop_+3A_m">m</code></td>
<td>

<p>an odd positive number. Bulging parameter of the hysteresis loop. Default is 1, which makes loop an ellipse when n is also equal to 1. In this case floop will automatically make a call to <code><a href="#topic+fel">fel</a></code>. See details.
</p>
</td></tr>
<tr><td><code id="floop_+3A_period">period</code></td>
<td>

<p>length of time required to make a full loop. Reciprocal of frequency, and if times = &quot;equal&quot;, the number of points needed to make a full loop.
</p>
</td></tr>
<tr><td><code id="floop_+3A_subjects">subjects</code></td>
<td>

<p>an optional factor or list of factors, each of the same length as x. Use to identify a list of different loops to be fit from one set of data, in which case <code>floop</code> returns an object of class <code>fittedlooplist</code> instead of <code>fittedloop</code>.
</p>
</td></tr>
<tr><td><code id="floop_+3A_times">times</code></td>
<td>

<p>either a numeric vector of length nrow(x) or the default &quot;equal&quot;. If the times at which loop observations are taken are known, a numeric vector can be used to give those times. 
If the default &quot;equal&quot; is used instead, time points are assumed to be equally spaced in a counterclockwise fashion.
</p>
</td></tr>
<tr><td><code id="floop_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="floop_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain NAs. The default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, the factory-fresh default 
is <code><a href="stats.html#topic+na.omit">na.omit</a></code>. Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.
</p>
</td></tr>
<tr><td><code id="floop_+3A_extended.classical">extended.classical</code></td>
<td>
 
<p>logical. If true, uses </p>
<p style="text-align: center;"><code class="reqn">y_t=sign(cos(2*pi*t/period))*b.y*abs(cos(2*pi*t/period))^n + retention*sin(2*pi*t/period)^m+cy+e_{y,t}</code>
</p>
<p> instead of 
</p>
<p style="text-align: center;"><code class="reqn">y_t=b.y*cos(2*pi*t/period)^n+retention*sin(2*pi*t/period)^m+cy+e_{y,t}</code>
</p>

<p>Allows the user to fit sinusoidal hysteresis loops with any positive real value of n &gt; 1 instead of just odd numbered n. 
Default is false.
</p>
</td></tr>
<tr><td><code id="floop_+3A_boot">boot</code></td>
<td>

<p>logical, if TRUE results will be bootstrapped by the default arguments of <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>.
</p>
</td></tr>
<tr><td><code id="floop_+3A_method">method</code></td>
<td>

<p>if the default &quot;harmonic2&quot; is used, times along with m and n are either supplied by the user or given default values. Otherwise a non-linear &quot;geometric&quot; method that minimizes the sum of squared geometric residuals will be utilized.
</p>
</td></tr>
<tr><td><code id="floop_+3A_...">...</code></td>
<td>

<p>other optional arguments such as <code>seed</code>, N=number of realizations, <code>cbb</code> for circular block bootstrapping, are passed to <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code> if <code>boot=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits sinusoidal input and output variables x and y that form a hysteresis loop of the form
</p>
<p style="text-align: center;"><code class="reqn">x_t=b.x*cos(2pi*t/period+phase.angle)+cx+e_{x,t}</code>
</p>
 <p style="text-align: center;"><code class="reqn">y_t=b.y*cos(2pi*t/period+phase.angle)^n+
retention*sin(2pi*t/period+phase.angle)^m+cy+e_{y,t}</code>
</p>
<p>  where </p>
<p style="text-align: center;"><code class="reqn">t=0,...,(n.points-1) if times='equal'</code>
</p>
<p> and the error terms, e, are independently and normally distributed. Also produces a vector of derived values.
If <code>floop2r</code> is used, retention is assumed to be different above and below the split line that seperates the upper and lower loop trajectories, and 
addition terms are included in the model.
</p>
<p style="text-align: center;"><code class="reqn">y_t=b.y*cos(2pi*t/period+phase.angle)^n+retention.above*sin(2pi*t/period+phase.angle)^m*I(0 &lt; 2pi*t/period+phase.angle &lt; pi)+retention.below*sin(2pi*t/period+phase.angle)^m*I(pi &lt; 2pi*t/period+phase.angle &lt; 2*pi)+cy+e_{y,t}</code>
</p>
 
<p>where retention.above and retention.below are retention above and below the split line.
</p>


<h3>Value</h3>

<p><code>floop</code> returns an object of class <code>fittedloop</code> while  <code>floop2r</code> returns an object of class <code>splitloop</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>information dependent on the fitting method used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the input.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the output.</p>
</td></tr>
<tr><td><code>pred.x</code></td>
<td>
<p>fitted x values.</p>
</td></tr>
<tr><td><code>pred.y</code></td>
<td>
<p>fitted y values.</p>
</td></tr>
<tr><td><code>period.time</code></td>
<td>
<p>time vector used to fit x and y.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals measured by Euclidean distance.The function <code><a href="#topic+residuals.fittedloop">residuals.fittedloop</a></code> can produce other types of residuals</p>
</td></tr>
<tr><td><code>extended.classical</code></td>
<td>
<p>whether or not an extended loop is fit.</p>
</td></tr>
<tr><td><code>fit.statistics</code></td>
<td>
<p>rudimentary measures, based on the &quot;harmonic2&quot; method, include the Multivariate Final Prediction Error (MFPE) and the AIC for both the output alone and the two variables in combination. 
Although degree of freedom adjustments are made for other methods, measures of fit require further study.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>a named vector of parameter estimates. See <code><a href="#topic+loop.parameters">loop.parameters</a></code>, same as Estimates here.</p>
</td></tr>
<tr><td><code>Estimates</code></td>
<td>
<p>a named vector of parameter estimates. See <code><a href="#topic+loop.parameters">loop.parameters</a></code>, same as values.</p>
</td></tr>  
<tr><td><code>Std.Errors</code></td>
<td>
<p>standard errors for parameters derived using the delta method.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>fitting method used.</p>
</td></tr>
</table>
<p>if <code>boot==TRUE</code> <code><a href="#topic+floop">floop</a></code> returns an object of class <code>loopsummary</code> by making a call to <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>. See <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>.
</p>
<p>For bootstrapping
</p>
<table>
<tr><td><code>Boot.Estimates</code></td>
<td>
<p>bootstrapped estimates.</p>
</td></tr>
<tr><td><code>Boot.Std.Errors</code></td>
<td>
<p>bootstrap standard errors.</p>
</td></tr>
</table>
<p>If multiple loops are fit simultaneously there will be three arguments to the response, models which will contain the separate model fits for each loop, Estimates which will have all of the parameter estimates in matrix form, and Std.Errors which will have all of the delta method standard errors in matrix form. See <code><a href="#topic+floop.repeated">floop.repeated</a></code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Lapshin, R. (1995) Analytical model for the approximation of hysteresis loop and its application to the scanning tunneling microscope.
</p>


<h3>See Also</h3>

<p>Simulate a hysteresis loop with the function <code><a href="#topic+mloop">mloop</a></code>. Alternatively see <code><a href="#topic+fel">fel</a></code> for fitting an ellipse (a hysteresis loop with parameters m=1, n=1) using a variety of methods. Also <code><a href="#topic+residuals.fittedloop">residuals.fittedloop</a></code>. If a loop is an ellipse, use of fel is strongly recommended instead of floop. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulate and fit a hysteresis loop with n=1 and m=3.
loopf &lt;- mloop(sd.x=0.07,sd.y=0.05,n=3,m=3, retention=.5)
loopf.model &lt;- floop(loopf$x,loopf$y,n=3,m=3)
loopf.model                #Gives estimate and delta standard errors
loopf.model$Estimates      #List estimates only  
loopf.model$Std.Errors     #List delta standard errors  

### Plot hysteresis loop.
plot(loopf.model,main="Simulated Hysteresis Loop n=3 m=3", values="hysteresis.all")
### Show characteristics of loop on plot
plot(loopf.model,main="Simulated Hysteresis Loop n=3 m=3",values="hysteresis.all",
show=c("retention","coercion"))
          
### Bootstrap estimates and standard errors (Seed is necessary if want to reproduce results)
booted.loopf &lt;- floop(loopf$x,loopf$y,retention=.5,n=3,m=3,
boot=TRUE, seed=1523)
booted.loopf                   #Gives boot estimates, boot bias, boot SE and boot quartiles
booted.loopf$Boot.Estimates    #Gives boot estimates 
booted.loopf$Boot.Std.Errors   #Gives boot standard errors 
plot(booted.loopf,main="Simulated Bootstrapped Loop n=1, m=3",
putNumber=TRUE,values="hysteresis.all")

</code></pre>

<hr>
<h2 id='floop.repeated'>
Methods for easily fitting multiple loops from repeated measures designs.
</h2><span id='topic+floop.repeated'></span><span id='topic+summary.fittedlooplist'></span><span id='topic+floop2r.repeated'></span><span id='topic+summary.fittedlooplist2r'></span>

<h3>Description</h3>

<p>Fit a sinusoidal hysteretic process between an input and an output variable across multiple loops separated by subjects and repeated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>floop.repeated(x,y=NULL,m=1,n=1,subjects=NULL,repeated=NULL,
subjects.in="all",repeated.in="all",...)
floop2r.repeated(x,y=NULL,m=1,n=1,subjects=NULL,repeated=NULL,
subjects.in="all",repeated.in="all",...)
## S3 method for class 'fittedlooplist'
summary(object,N=1000,boot=TRUE,seed=NULL,...)
## S3 method for class 'fittedlooplist2r'
summary(object,N=1000,boot=TRUE,seed=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="floop.repeated_+3A_x">x</code></td>
<td>

<p>numeric input vector.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_y">y</code></td>
<td>

<p>numeric output vector.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_n">n</code></td>
<td>

<p>positive integer. Loop shape parameter, see <code><a href="#topic+loop.parameters">loop.parameters</a></code>.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_m">m</code></td>
<td>

<p>positive odd integer. Loop bulging parameter, see <code><a href="#topic+loop.parameters">loop.parameters</a></code>.
</p>
</td></tr> 
<tr><td><code id="floop.repeated_+3A_subjects">subjects</code></td>
<td>

<p>factor of the same length as x that represents experimental units.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_repeated">repeated</code></td>
<td>

<p>factor of the same length as x that represents the repeated measure.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_subjects.in">subjects.in</code></td>
<td>

<p>a vector of characters, the levels of <code>subjects</code> to be included. Default is &quot;all&quot;.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_repeated.in">repeated.in</code></td>
<td>

<p>a vector of characters, the levels of <code>repeated</code> to be included. Default is &quot;all&quot;.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_object">object</code></td>
<td>

<p>an <code>fittedlooplist</code> object.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_n">N</code></td>
<td>

<p>number of bootstrap replicates. See <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_boot">boot</code></td>
<td>

<p>whether or not bootstrapping should be performed. See <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_seed">seed</code></td>
<td>

<p>for generating random numbers. See <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>.
</p>
</td></tr>
<tr><td><code id="floop.repeated_+3A_...">...</code></td>
<td>

<p>extra arguments to either  <code><a href="#topic+floop">floop</a></code> or <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits multiple loops with one call, separated by the factors <code>subjects</code> and <code>repeated</code>. The arguments <code>subjects.in</code> and <code>repeated.in</code> are used to select subsets of the factors <code>subjects</code> and <code>repeated</code>.
</p>


<h3>Value</h3>

<p><code>floop.repeated</code> returns an object of class <code>fittedlooplist</code>.
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p>Separate model fits for each loop, see <code><a href="#topic+floop">floop</a></code>.</p>
</td></tr>
<tr><td><code>Estimates</code></td>
<td>
<p>Parameter estimates for all loops in matrix form.</p>
</td></tr>
<tr><td><code>Std.Errors</code></td>
<td>
<p>Delta standard errors for all loops in matrix form.</p>
</td></tr>
</table>
<p>When <code>boot=TRUE</code> <code><a href="#topic+floop.repeated">floop.repeated</a></code> returns an object of class <code>loopsummarylist</code> which consists of
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p>Separate model summaries for each ellipse, see <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>Bootstrapped parameter estimates, standard errors, quantiles, and more for each loop.</p>
</td></tr>
<tr><td><code>Boot.Estimates</code></td>
<td>
<p>Bootstrapped parameter estimates with reduced bias.</p>
</td></tr>
<tr><td><code>Boot.Std.Errors</code></td>
<td>
<p>Standard errors provided by bootstrapping.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Yang, F. and A. Parkhurst, Efficient Estimation of Elliptical Hysteresis (submitted)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+floop">floop</a></code> and <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>, also  <code><a href="#topic+fel.repeated">fel.repeated</a></code> and <code><a href="#topic+summary.ellipsefitlist">summary.ellipsefitlist</a></code>. Also <code><a href="#topic+residuals.fittedlooplist">residuals.fittedlooplist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HysteresisData)
loopmodels.rep &lt;- floop.repeated(HysteresisData$X, HysteresisData$Y,
n=5,m=3, subjects = HysteresisData$subjects,subjects.in=c("A","C"),
repeated=HysteresisData$repeated)
loopmodels.rep                #Gives estimates and delta standard errors
loopmodels.rep$Estimates      #List estimates only
loopmodels.rep$Std.Errors     #List delta standard errors

par(mfrow=c(2,2))
plot(loopmodels.rep,main='Simulated Rep Loops',values="hysteresis")
par(mfrow=c(1,1))

loopmodels.rep$models["A",1]       #Select one subject, one replication

### Bootstrap estimates and standard errors (Seed is necessary if want to reproduce results)
boot.rep.loop=floop.repeated(HysteresisData$X, HysteresisData$Y,
n=5,m=3, subjects = HysteresisData$subjects,subjects.in=c("A","C"),
repeated=HysteresisData$repeated,boot=TRUE,seed=123)
boot.rep.loop                 #Gives boot estimates, boot bias, boot SE and boot quartiles
boot.rep.loop$Boot.Estimates  #Lists boot estimates
boot.rep.loop$Boot.Std.Errors #Gives boot standard errors 

par(mfrow=c(2,2))
plot(boot.rep.loop, main='Simulated Rep Boot Loops', values="hysteresis")
par(mfrow=c(1,1))

##Can write results to a file. First set your directory from the file tab.
## Change file path in command below to coincide with where you want to store data files
##setwd("C:/Users/..........................")
##write.table(boot.rep.loop$Boot.Estimates,"Hys.eg.repbootvalues.txt")
##test.floop=read.table("Hys.eg.repbootvalues.txt",header=TRUE)
##head(test.floop)
</code></pre>

<hr>
<h2 id='floopReflect'>
Fitting hysteresis loops for reflected data
</h2><span id='topic+floopReflect'></span><span id='topic+felReflect'></span>

<h3>Description</h3>

<p>Fits hysteresis loops and ellipses where x and y are flipped and reversed</p>


<h3>Usage</h3>

<pre><code class='language-R'>floopReflect(x,y,...)
felReflect(x,y,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="floopReflect_+3A_x">x</code></td>
<td>

<p>the numeric input vector. To fit the loop x is reversed and treated as y.
</p>
</td></tr>
<tr><td><code id="floopReflect_+3A_y">y</code></td>
<td>

<p>the numeric output vector. To fit the loop y is reversed and treated as x.
</p>
</td></tr>
<tr><td><code id="floopReflect_+3A_...">...</code></td>
<td>

<p>other arguments to either <code><a href="#topic+floop">floop</a></code> or <code><a href="#topic+fel">fel</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A reflected hysteresis loop is one where the output and input are flipped and placed in reverse order.
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+floop">floop</a></code> or <code><a href="#topic+fel">fel</a></code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Yang, F. and A. Parkhurst, Estimating Elliptical Hysteresis: A Comparison of Analytic Methods. (submitted)
</p>

<hr>
<h2 id='HysteresisData'>
Simulated Loop Data for 6 Loops with period=24, n=5 and m=3
</h2><span id='topic+HysteresisData'></span>

<h3>Description</h3>

<p>Three subjects with two replications = 6 loops created by mloop. All 6 loops are created with parameters n=5 and m=3 and centered around the origin with a phase angle of pi/2.
The 3 subject loops differ in terms of their retention (0.4,0.8,0.6) and b.x saturation point (0.3,0.6,1). 
Errors in both the input and the output are given a standard deviation of 0.1 for all loops. Used in the help page for <code><a href="#topic+floop.repeated">floop.repeated</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HysteresisData)</code></pre>


<h3>Format</h3>

<p>A data frame with 144 observations on the following 4 variables.
</p>

<dl>
<dt><code>X</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>subjects</code></dt><dd><p>subject, one of &quot;A&quot;, &quot;B&quot;, or &quot;C&quot;.</p>
</dd>
<dt><code>repeated</code></dt><dd><p>which replication within subject. Either 1 or 2.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Data file is created using the following code
set.seed(1)
loop1 &lt;- mloop(n=5,m=3, retention = 0.4, b.x = 0.3, b.y = 0.8, cx = 0, cy = 0, 
    sd.x = 0.1, sd.y = 0.1, period = 24, n.points = 48, phase.angle = pi/2)
loop2 &lt;- mloop(n=5,m=3, retention = 0.8, b.x = 0.6, b.y = 0.8, cx = 0, cy = 0, 
    sd.x = 0.1, sd.y = 0.1, period = 24, n.points = 48, phase.angle = pi/2)
loop3 &lt;- mloop(n=5,m=3, retention = 0.6, b.x = 1, b.y = 0.8, cx = 0, cy = 0, 
    sd.x = 0.1, sd.y = 0.1, period = 24, n.points = 48, phase.angle = pi/2)
X &lt;- c(loop1$x, loop2$x, loop3$x)
Y &lt;- c(loop1$y, loop2$y, loop3$y)
subjects &lt;- c(rep("A", length(loop1$x)), rep("B", length(loop2$x)), rep("C",length(loop3$x)))  
    repeated &lt;- rep(c(1,2),each=24,times=3)  
    
##Use data to fit 6 Hysteresis Loops  
data(HysteresisData)
six.loops &lt;- floop.repeated(HysteresisData$X, HysteresisData$Y, n=5,m=3,
subjects = HysteresisData$subjects,repeated=HysteresisData$repeated)
six.loops

#Model fit for B-1
six.loops$models["B",1] 
par(mfrow=c(2,3))
plot(six.loops)
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='loop.parameters'>
Inherent and Derived Parameter Definitions for Hysteresis Loops/Ellipses
</h2><span id='topic+loop.parameters'></span><span id='topic+ellipse.parameters'></span>

<h3>Description</h3>

<p><code><a href="#topic+floop">floop</a></code> returns a <code>fittedloop</code> object and calculates a variety of hysteresis loop parameters. This is a list of definitions for these parameters, as well as some only available for ellipses through <code><a href="#topic+fel">fel</a></code>. If <code>floop2r</code> is used a number of these parameters have differing values above and below the split line. The generalized transcendental equations used to fit these loops are </p>
<p style="text-align: center;"><code class="reqn">x_t=b.x*cos(2pi*t/period+phase.angle)+cx+e_{x,t}</code>
</p>
 <p style="text-align: center;"><code class="reqn">y_t=b.y*cos(2pi*t/period+phase.angle)^n+retention*sin(2pi*t/period+phase.angle)^m+cy+e_{y,t}</code>
</p>
<p>  where </p>
<p style="text-align: center;"><code class="reqn">t=0,...,n.points-1 if times='equal'</code>
</p>



<h3>Value</h3>

<p>Specified loop parameters.
</p>
<table>
<tr><td><code>n</code></td>
<td>

<p>Positive integer for the split line parameter. If n=1, split line is linear; If n is even, split line has a u shape; If n is odd and higher than 1, split line has a chair or classical shape.
</p>
</td></tr>
<tr><td><code>m</code></td>
<td>

<p>Positive odd integer for the bulging parameter, indicates degree of outward curving (1=highest level of bulging).
</p>
</td></tr>
</table>
<p>Inherent Parameters
</p>
<table>
<tr><td><code>b.x</code></td>
<td>

<p>saturation point x coordinate. Horizontal distance from the center to the maximum value of the input.
</p>
</td></tr>
<tr><td><code>b.y</code></td>
<td>

<p>saturation point y coordinate. Vertical distance from the center to the point where the input is at its maximum.
</p>
</td></tr>
<tr><td><code>phase.angle</code></td>
<td>

<p>defines the starting point of the loop. The initial angle of the input function at its origin.
</p>
</td></tr>
<tr><td><code>cx</code></td>
<td>

<p>center of input x.
</p>
</td></tr>
<tr><td><code>cy</code></td>
<td>

<p>center of output y.
</p>
</td></tr>
<tr><td><code>retention</code></td>
<td>

<p>split point, representing vertical distance from center to upper loop trajectory. It is the intersection of the loop and the output axis characterizing the distortion in the response at the average input challenge.
</p>
</td></tr>
</table>
<p>Derived Hysteresis Parameters
</p>
<table>
<tr><td><code>coercion</code></td>
<td>

<p>the horizontal distance of the input from the center. It indicates the strain the forcing function places on the output. It is the positive root of intersection between the loop and input axis.
</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>

<p>lag indicates the delay between attributes of the output and the input (such as peak to peak for the ellipse when m=1, n=1).
</p>
</td></tr>
<tr><td><code>area</code></td>
<td>

<p>the area of the hysteresis loop. Can indicate the work done during one cycle or period.
</p>
</td></tr>
<tr><td><code>split.angle</code></td>
<td>

<p>beta, the angle between the tangent to the un-split curve at the center and the input axis.
</p>
</td></tr>
<tr><td><code>hysteresis.x</code></td>
<td>

<p>hysteresis along the input axis. The proportion of coercion due to input saturation b.x.
</p>
</td></tr>
<tr><td><code>hysteresis.y</code></td>
<td>

<p>hysteresis along the output axis. The proportion of retention due to b.y.
</p>
</td></tr>
</table>
<p>Ellipse Parameters
</p>
<table>
<tr><td><code>ampx</code></td>
<td>

<p>Amplitude of the input, equal to b.x.
</p>
</td></tr>
<tr><td><code>ampy</code></td>
<td>

<p>Amplitude of the output.
</p>
</td></tr>
<tr><td><code>rote.deg and rote.rad</code></td>
<td>

<p>theta, counter clockwise angle of rotation between the input axis and the semi-major axis of the loop.In degrees and radians respectively.
</p>
</td></tr>
<tr><td><code>semi.major</code></td>
<td>

<p>half major axis of ellipse, maximum distance from center to perimeter of ellipse.
</p>
</td></tr>
<tr><td><code>semi.minor</code></td>
<td>

<p>half minor axis of ellipse, shortest distance from center to perimeter of ellipse. 
</p>
</td></tr>
<tr><td><code>focus.x</code>, <code>focus.y</code></td>
<td>

<p>input x and output y distances of focus points from center.
</p>
</td></tr>
<tr><td><code>eccentricity</code></td>
<td>

<p>Measure of deviation from circle. Zero indicate no deviation from circle.
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\frac{semi.major^2-semi.minor^2}/{semi.major^2}}</code>
</p>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Lapshin, R. (1995) Analytical model for the approximation of hysteresis loop and its application to the scanning tunneling microscope.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mloop">mloop</a></code> for simulating a hysteresis loop and <code><a href="#topic+floop">floop</a></code> for fitting a hysteresis loop.   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theloop&lt;-mloop(sd.x=0.05,sd.y=0.05,n=2,m=3)
loopmodel&lt;-floop(theloop$x,theloop$y,n=2,m=3)
loopmodel
plot(loopmodel,main="Hysteresis Loop n=2 m=3",values="hysteresis")

#Ellipse Parameters
ellipse.eig &lt;- mel(semi.major=7,semi.minor=4,rote.deg=30)
ellip.eigen.fit &lt;- fel(ellipse.eig$x,ellipse.eig$y)
ellip.eigen.fit$Estimates
plot(ellip.eigen.fit,main="Ellipse from Eigenvalue Parameters",
show=c("semi.major","semi.minor","rote.deg"),values="ellipse")
</code></pre>

<hr>
<h2 id='mel'>
Simulate (Make) an Ellipse
</h2><span id='topic+mel'></span><span id='topic+mel1'></span><span id='topic+mel2'></span><span id='topic+mel3'></span><span id='topic+mel4'></span>

<h3>Description</h3>

<p>Produces an ellipse based on 1 of 4 possible formulations: 1-Eigenvalues, 2-Hysteresis Coefs, 3-Amplitudes and 4-Algebraic Coefs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mel(method=1,seed=NULL,...)
mel1(cx=32,cy=39,rote.deg=2,semi.major=7,semi.minor=0.23,
phase.angle=0,n.points=24,period=24,sd.x=0,sd.y=0)
mel2(cx=32,cy=39,b.x=6.99,b.y=0.244,retention=0.23,
phase.angle=0,n.points=24,period=24,sd.x=0,sd.y=0)
mel3(cx=32,cy=39,ampx=6.99,ampy=0.335,lag=2.888,phase.angle=0,
n.points=24,period=24,sd.x=0,sd.y=0)
mel4(x2=0.002293,xy=-.06960,y2=0.9976,x=2.567,y=-75.58,int=1432.7,
phase.angle=0,n.points=24,period=24,sd.x=0,sd.y=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mel_+3A_method">method</code></td>
<td>

<p>selects which of the functions <code>mel1</code>, <code>mel2</code>, <code>mel3</code>, <code>mel4</code> to use to describe the ellipse.
</p>
</td></tr>
<tr><td><code id="mel_+3A_seed">seed</code></td>
<td>

<p>integer, the starting seed.
</p>
</td></tr>
<tr><td><code id="mel_+3A_...">...</code></td>
<td>

<p>arguments to the functions <code>mel1</code>, <code>mel2</code>, <code>mel3</code>, <code>mel4</code> described below.
</p>
</td></tr>
<tr><td><code id="mel_+3A_cx">cx</code></td>
<td>

<p>Center of input x.
</p>
</td></tr>
<tr><td><code id="mel_+3A_cy">cy</code></td>
<td>

<p>Center of output y.
</p>
</td></tr>
<tr><td><code id="mel_+3A_phase.angle">phase.angle</code></td>
<td>

<p>defines the starting point of the ellipse. Does not change ellipse shape.
</p>
</td></tr>
<tr><td><code id="mel_+3A_rote.deg">rote.deg</code></td>
<td>

<p>Theta, angle of rotation. In degrees. Only used if <code>method=1</code>.
</p>
</td></tr>
<tr><td><code id="mel_+3A_semi.major">semi.major</code></td>
<td>

<p>Half length of major axis. Only used if <code>method=1</code>.
</p>
</td></tr>
<tr><td><code id="mel_+3A_semi.minor">semi.minor</code></td>
<td>

<p>Half length of minor axis. Only used if <code>method=1</code>.
</p>
</td></tr>
<tr><td><code id="mel_+3A_b.x">b.x</code></td>
<td>

<p>Saturation point x coordinate. Only used if <code>method=2</code>.
</p>
</td></tr>
<tr><td><code id="mel_+3A_b.y">b.y</code></td>
<td>

<p>Saturation point y coordinate. Only used if <code>method=2</code>.
</p>
</td></tr>
<tr><td><code id="mel_+3A_retention">retention</code></td>
<td>

<p>another ellipse parameter used if <code>method=2</code>. split point, representing vertical distance from center to upper loop trajectory. It is the intersection of the loop and the output axis characterizing the distortion in the response at the average input challenge.</p>
</td></tr>
<tr><td><code id="mel_+3A_ampx">ampx</code></td>
<td>

<p>The range of the ellipse input values divided by 2. Only used if <code>method=3</code>.
</p>
</td></tr>
<tr><td><code id="mel_+3A_ampy">ampy</code></td>
<td>

<p>The range of the ellipse output values divided by 2. Only used if <code>method=3</code>.
</p>
</td></tr>
<tr><td><code id="mel_+3A_lag">lag</code></td>
<td>

<p>The number of points between the location where the input reaches its maximum value and where the output reaches its maximum value.
Lag is therefore dependent on the value chosen for period. Only used if <code>method=3</code>. 
</p>
</td></tr>
<tr><td><code id="mel_+3A_x2">x2</code></td>
<td>

<p>Coefficient on x^2 in the equation found in details. Only used if <code>method=4</code>. 
</p>
</td></tr>
<tr><td><code id="mel_+3A_xy">xy</code></td>
<td>

<p>Coefficient on xy in the equation found in details. Only used if <code>method=4</code>. 
</p>
</td></tr>
<tr><td><code id="mel_+3A_y2">y2</code></td>
<td>

<p>Coefficient on y^2 in the equation found in details. Only used if <code>method=4</code>. 
</p>
</td></tr>
<tr><td><code id="mel_+3A_x">x</code></td>
<td>

<p>Coefficient on x in the equation found in details. Only used if <code>method=4</code>. 
</p>
</td></tr>
<tr><td><code id="mel_+3A_y">y</code></td>
<td>

<p>Coefficient on y in the equation found in details. Only used if <code>method=4</code>. 
</p>
</td></tr>
<tr><td><code id="mel_+3A_int">int</code></td>
<td>

<p>Coefficient on the intercept in the equation found in details. Only used if <code>method=4</code>. 
</p>
</td></tr>
<tr><td><code id="mel_+3A_n.points">n.points</code></td>
<td>

<p>Number of points on ellipse. Equally spaced around circumference of ellipse/period.
</p>
</td></tr>
<tr><td><code id="mel_+3A_period">period</code></td>
<td>

<p>Number of points required to make a full loop around the ellipse.
</p>
</td></tr>
<tr><td><code id="mel_+3A_sd.x">sd.x</code></td>
<td>

<p>optional number specifying a normally distributed standard deviation for x.
</p>
</td></tr>
<tr><td><code id="mel_+3A_sd.y">sd.y</code></td>
<td>

<p>optional number specifying a normally distributed standard deviation for y.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All of the four methods can be used to specify a series of points that make up an ellipse. The function <code>mel</code>
uses parameters to form an ellipse and find derived variables such as area, lag, retention, and coercion. 
Optionally, normally distributed random variation can be introduced in both the x and y directions. The first method is useful alongside the nls, lm and direct fitting methods,
while the second is comparable to the harmonic2 ellipse fitting method. The third method for mel is included because it is the easiest to interpret. Finally the fourth method uses the equation 0=a0+a1*x^2+a2*xy+a3*y^2+a4*x+a5*y to form an ellipse. The &quot;a&quot; parameters here are marked as int, x2, xy, y2, x and y in the function itself.</p>


<h3>Value</h3>

<p>mel returns an object of class <code>ellipsemake</code>.
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>the nine fundamental parameters (cx,cy,rote.deg,semi.major,semi.minor,b.x,b.y,a,phase.angle) of which only four or five are used 
along with the four derived parameters (area, lag, retention, coercion).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the input x.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the output y.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Yang, F. and A. Parkhurst, Efficient Estimation of Elliptical Hysteresis. (submitted)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fel">fel</a></code> for fitting observations that form an ellipse and creating an <code>ellipsefit</code> object, <code><a href="#topic+plot.ellipsefit">plot.ellipsefit</a></code>for plotting an <code>ellipsefit</code> object.
<code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code> for summarizing an <code>ellipsefit</code> object, and <code><a href="#topic+plot.ellipsesummary">plot.ellipsesummary</a></code> for plotting an <code>ellipsesummary</code> object.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ellipseA &lt;- mel(method=3,cx=35, cy=39, ampx=7, ampy=2, lag=3, sd.x=0.2,sd.y=0.04)
 ellipseA.fit &lt;- fel(ellipseA$x,ellipseA$y)
  plot(ellipseA.fit,xlab="Input",ylab="Output",main="Simulated Ellipse",
  putNumber=TRUE)
 boot.ellipseA.fit &lt;- fel(ellipseA$x,ellipseA$y, boot=TRUE, seed=231)
  plot(boot.ellipseA.fit,xlab="Input",ylab="Output",
  main="Bootstrapped Ellipse",values="ellipse.all")

ellipse.eig &lt;- mel(semi.major=7,semi.minor=4,rote.deg=30)
ellip.eigen.fit &lt;- fel(ellipse.eig$x,ellipse.eig$y)
ellip.eigen.fit$Estimates
plot(ellip.eigen.fit,main="Ellipse from Eigenvalue Parameters",
show=c("semi.major","semi.minor","rote.deg"),values="ellipse")
</code></pre>

<hr>
<h2 id='mloop'>
Simulate (Make) a Hysteresis Loop
</h2><span id='topic+mloop'></span><span id='topic+mloop2r'></span>

<h3>Description</h3>

<p>Simulate a hysteresis loop with a variety of possible parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mloop(cx = 0, cy = 0, retention = 0.2, b.x = 0.6, b.y = 0.8,n = 1, m = 1, 
     sd.x = 0, sd.y = 0, phase.angle = 0, n.points = 24, 
    period = 24,extended.classical=FALSE,seed=NULL)  
mloop2r(cx=0,cy=0,retention.above=0.2,retention.below=0.15,b.x=0.6,b.y=0.8,n=1,
        m=1,sd.x=0,sd.y=0,phase.angle=0,n.points=24,period=24,
        extended.classical=FALSE,seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mloop_+3A_n">n</code></td>
<td>

<p>Positive integer for the split line parameter. If n=1, split line is linear; If n is even, split line has a u shape; If n is odd and higher than 1, split line has a chair or classical shape.
</p>
</td></tr>
<tr><td><code id="mloop_+3A_m">m</code></td>
<td>

<p>Positive odd integer for the bulging parameter, indicates degree of outward curving (1=highest level of bulging). 
</p>
</td></tr>
<tr><td><code id="mloop_+3A_b.x">b.x</code></td>
<td>

<p>number. Saturation point x coordinate. Horizontal distance from the center to the maximum value of the input challenge.
</p>
</td></tr>
<tr><td><code id="mloop_+3A_b.y">b.y</code></td>
<td>

<p>number. Saturation point y coordinate. Vertical distance from the center to the point where the input is at its maximum. 
</p>
</td></tr>
<tr><td><code id="mloop_+3A_phase.angle">phase.angle</code></td>
<td>

<p>number in degrees. Defines the starting point of the loop. The initial angle of the input function at its origin. 
</p>
</td></tr>  
<tr><td><code id="mloop_+3A_cx">cx</code></td>
<td>

<p>number. Center of input x.
</p>
</td></tr>
<tr><td><code id="mloop_+3A_cy">cy</code></td>
<td>

<p>number. Center of output y.
</p>
</td></tr>
<tr><td><code id="mloop_+3A_retention">retention</code></td>
<td>

<p>number. Split point, represents vertical distance from center to upper loop trajectory. 
It is the intersection of the loop and the output axis characterizing the distortion in 
the response at the average input challenge. Assumes symmetrical curve above and below split line.
</p>
</td></tr>
<tr><td><code id="mloop_+3A_retention.above">retention.above</code></td>
<td>

<p>number. Retention above the split line. <code>mloop2r</code> creates a loop where retention above and below the split line may be different.
</p>
</td></tr>
<tr><td><code id="mloop_+3A_retention.below">retention.below</code></td>
<td>

<p>number. Retention below the split line.
</p>
</td></tr>
<tr><td><code id="mloop_+3A_sd.x">sd.x</code></td>
<td>

<p>number. Standard deviation of the normally distributed variation in the input vector x. </p>
</td></tr>
<tr><td><code id="mloop_+3A_sd.y">sd.y</code></td>
<td>

<p>number. Standard deviation of the normally distributed variation in the output vector y. </p>
</td></tr>
<tr><td><code id="mloop_+3A_n.points">n.points</code></td>
<td>

<p>number of points on loop.
</p>
</td></tr> 
<tr><td><code id="mloop_+3A_period">period</code></td>
<td>

<p>number of equally spaced points required to make a full loop.
</p>
</td></tr>
<tr><td><code id="mloop_+3A_extended.classical">extended.classical</code></td>
<td>

<p>logical. If true, fit a classical hysteresis loop regardless of n. Uses </p>
<p style="text-align: center;"><code class="reqn">y_t=sign(cos(2*pi*t/period))*b.y*abs(cos(2*pi*t/period))^n + retention*sin(2*pi*t/period)^m+cy+e_{y,t}</code>
</p>
<p> instead of 
</p>
<p style="text-align: center;"><code class="reqn">y_t=b.y*cos(2*pi*t/period)^n+retention*sin(2*pi*t/period)^m+cy+e_{y,t}</code>
</p>

<p>Allows the user to fit classical loops with any n&gt;1 instead of just odd numbered n. Default is false.
</p>
</td></tr>
<tr><td><code id="mloop_+3A_seed">seed</code></td>
<td>

<p>integer. Starting seed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates input and output variables x and y that form a hysteresis loop of the form </p>
<p style="text-align: center;"><code class="reqn">x_t=b.x*cos(2pi*t/period+phase.angle)+cx+e_{x,t}</code>
</p>
 <p style="text-align: center;"><code class="reqn">y_t=b.y*cos(2pi*t/period+phase.angle)^n+retention*sin(2pi*t/period+phase.angle)^m+cy+e_{y,t}</code>
</p>
<p>  where </p>
<p style="text-align: center;"><code class="reqn">t=0,...,n.points-1 if times='equal'</code>
</p>
<p> and the error terms e are normally distributed. Also produces a vector of derived values.</p>


<h3>Value</h3>

<p>mloop returns an object of class <code>hysteresisloop</code>.
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>estimated values of various coefficients and derived parameters of the hysteresis loop. See <code><a href="#topic+loop.parameters">loop.parameters</a></code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the input x.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the output y.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Lapshin, R. (1995) Analytical model for the approximation of hysteresis loop and its application to the scanning tunneling microscope.
</p>


<h3>See Also</h3>

<p>Fit a hysteresis loop with the function <code><a href="#topic+floop">floop</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate a loop with n=3, m=1, retention=0.9
loop1 &lt;- mloop(cx=5,cy=8,retention=0.9,sd.x=0.01,sd.y=0.05,n=3,m=1)
loopmodel &lt;- floop(loop1$x,loop1$y,n=3,m=1)
loopmodel 
##Plot hysteresis loop.
plot(loopmodel,main="Simulated Hysteresis Loop n=3 m=1",xlab="Input",
ylab="Output",values="hysteresis.all")

</code></pre>

<hr>
<h2 id='plot.fittedloop'>
Plot a fitted ellipse or hysteresis loop.
</h2><span id='topic+plot.ellipsefit'></span><span id='topic+plot.ellipsesummary'></span><span id='topic+plot.ellipsefitlist'></span><span id='topic+plot.ellipsesummarylist'></span><span id='topic+plot.fittedloop'></span><span id='topic+plot.fittedlooplist'></span><span id='topic+plot.fittedlooplist2r'></span><span id='topic+plot.loopsummary'></span><span id='topic+plot.loopsummarylist'></span><span id='topic+plot.loopsummarylist2r'></span><span id='topic+plot.loop2r'></span><span id='topic+plot.loop2rsummary'></span>

<h3>Description</h3>

<p>A scatterplot of x and y fitted with an ellipse or hysteresis loop. Uses objects created by <code><a href="#topic+fel">fel</a></code>, <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code> and <code><a href="#topic+floop">floop</a></code>. Can also plot an <code>ellipsefitlist</code> or <code>ellipsesummarylist</code> object that contains multiple ellipses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ellipsefit'
plot(x,putNumber=FALSE,values=NULL,
xlim=NULL,ylim=NULL,main=NULL,newPred=TRUE,show=NULL,split.line=FALSE,...)
## S3 method for class 'ellipsesummary'
plot(x,putNumber=FALSE,values=NULL,
xlim=NULL,ylim=NULL,main=NULL,newPred=TRUE,split.line=FALSE,...)

## S3 method for class 'ellipsefitlist'
plot(x,main=NULL, values=NULL, ...) 
## S3 method for class 'ellipsesummarylist'
plot(x,main=NULL, values=NULL, ...) 

## S3 method for class 'fittedloop'
plot(x,split.line=TRUE,xlim=NULL,
ylim=NULL,putNumber=FALSE,values=NULL,main=NULL,show=NULL,...)
## S3 method for class 'loopsummary'
plot(x,split.line=TRUE,xlim=NULL,
ylim=NULL,putNumber=FALSE,values=NULL,main=NULL,...)

## S3 method for class 'fittedlooplist'
plot(x,main=NULL,values=NULL,...)
## S3 method for class 'loopsummarylist'
plot(x,main=NULL,values=NULL,...)
## S3 method for class 'fittedlooplist2r'
plot(x,main=NULL,values=NULL,...)
## S3 method for class 'loopsummarylist2r'
plot(x,main=NULL,values=NULL,...)

## S3 method for class 'loop2r'
plot(x,split.line=TRUE,xlim=NULL,ylim=NULL,putNumber=FALSE,main=NULL,values=NULL,...)
## S3 method for class 'loop2rsummary'
plot(x,split.line=TRUE,xlim=NULL,ylim=NULL,putNumber=FALSE,main=NULL,values=NULL,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fittedloop_+3A_x">x</code></td>
<td>

<p>a fitted ellipse or hysteresis loop created by either <code><a href="#topic+fel">fel</a></code>, <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code> or <code><a href="#topic+floop">floop</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.fittedloop_+3A_putnumber">putNumber</code></td>
<td>

<p>optional logical that numbers points from first to last. 
</p>
</td></tr>
<tr><td><code id="plot.fittedloop_+3A_values">values</code></td>
<td>

<p>one of NULL, &quot;hysteresis&quot;, &quot;inherent&quot;, &quot;derived&quot;, &quot;hysteresis.all&quot;, &quot;ellipse&quot;, or &quot;ellipse.all&quot;. Parameter values printed in title. Default is NULL in which case none are printed. See <code><a href="#topic+loop.parameters">loop.parameters</a></code> or <code><a href="#topic+ellipse.parameters">ellipse.parameters</a></code>
</p>
</td></tr>
<tr><td><code id="plot.fittedloop_+3A_xlim">xlim</code></td>
<td>

<p>limits for x axis.
</p>
</td></tr>
<tr><td><code id="plot.fittedloop_+3A_ylim">ylim</code></td>
<td>

<p>limits for y axis.
</p>
</td></tr>
<tr><td><code id="plot.fittedloop_+3A_main">main</code></td>
<td>

<p>an overall title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.fittedloop_+3A_newpred">newPred</code></td>
<td>

<p>draw an ellipse with 100 points. If <code>FALSE</code> use predicted ellipse from <code>ellipsefit</code> object which will result in a rougher shape.
</p>
</td></tr>
<tr><td><code id="plot.fittedloop_+3A_show">show</code></td>
<td>

<p>a character vector of parameters to be shown in the plot. 
Possible values are &quot;retention&quot;, &quot;coercion&quot;, &quot;b.x&quot;, &quot;b.y&quot;, &quot;semi.major&quot;,&quot;semi.minor&quot;,&quot;rote.deg&quot;,&quot;focus.x&quot;,and &quot;focus.y&quot;. 
<code>show</code> is not available for bootstrapped results. 
</p>
</td></tr>
<tr><td><code id="plot.fittedloop_+3A_split.line">split.line</code></td>
<td>

<p>logical. Whether to include the split line, which is the input output relationship when hysteresis is removed.
</p>
</td></tr>
<tr><td><code id="plot.fittedloop_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fel">fel</a></code> for fitting points that form an ellipse and <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code> for bootstrapping and summarizing an ellipsefit object. Also <code><a href="#topic+floop">floop</a></code> and <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code> for fitting and summarizing hysteresis loops more generally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Fit and plot an ellipse
  ellipse1 &lt;- mel(sd.x=0.2,sd.y=0.04)
  ellipse1.fit &lt;- fel(ellipse1$x,ellipse1$y)
plot(ellipse1.fit,main="Simulated Ellipse",xlab="X Input",
ylab="Y Output",show=c("semi.major", "semi.minor"),values="ellipse.all")
### Bootstrapping
  booted.ellipse &lt;- fel(ellipse1$x,ellipse1$y,boot=TRUE, seed=123)
plot(booted.ellipse,xlab="X Input",ylab="Y Output",
main="Simulated Bootstrap Ellipse",values="ellipse")

##Fit and plot a hysteresis loop
  loop1 &lt;- mloop(sd.x=0.05,sd.y=0.05,n=5,m=3)
  loopmodel &lt;- floop(loop1$x,loop1$y,n=5,m=3)
plot(loopmodel,main="Simulated Hysteresis Loop n=5 m=3",
xlab="Input",ylab="Output", values="hysteresis.all")
  booted.loop &lt;- floop(loop1$x,loop1$y,,n=5,m=3,boot=TRUE, seed=1523)
plot(booted.loop,xlab="Input",ylab="Output",
main="Simulated Bootstrapped Loop n=5, m=3",putNumber=TRUE)
plot(booted.loop,main="Simulated Bootstrapped Loop n=5, m=3",
xlab="Input",ylab="Output",values="hysteresis.all")

</code></pre>

<hr>
<h2 id='residuals.fittedloop'>
Residuals, studentized residuals and fitted values for the hysteresis package. 
</h2><span id='topic+residuals.ellipsefit'></span><span id='topic+residuals.ellipsesummary'></span><span id='topic+residuals.fittedloop'></span><span id='topic+residuals.loopsummary'></span><span id='topic+residuals.ellipsefitlist'></span><span id='topic+residuals.ellipsesummarylist'></span><span id='topic+residuals.fittedlooplist'></span><span id='topic+residuals.loopsummarylist'></span><span id='topic+residuals.fittedlooplist2r'></span><span id='topic+residuals.loopsummarylist2r'></span><span id='topic+residuals.loop2r'></span><span id='topic+residuals.loop2rsummary'></span><span id='topic+rstudent.ellipsefit'></span><span id='topic+rstudent.ellipsesummary'></span><span id='topic+rstudent.fittedloop'></span><span id='topic+rstudent.loopsummary'></span><span id='topic+rstudent.ellipsefitlist'></span><span id='topic+rstudent.ellipsesummarylist'></span><span id='topic+rstudent.fittedlooplist'></span><span id='topic+rstudent.loopsummarylist'></span><span id='topic+rstudent.fittedlooplist2r'></span><span id='topic+rstudent.loopsummarylist2r'></span><span id='topic+rstudent.loop2r'></span><span id='topic+rstudent.loop2rsummary'></span><span id='topic+fitted.ellipsefit'></span><span id='topic+fitted.ellipsesummary'></span><span id='topic+fitted.fittedloop'></span><span id='topic+fitted.loopsummary'></span><span id='topic+fitted.ellipsefitlist'></span><span id='topic+fitted.ellipsesummarylist'></span><span id='topic+fitted.fittedlooplist'></span><span id='topic+fitted.loopsummarylist'></span><span id='topic+fitted.fittedlooplist2r'></span><span id='topic+fitted.loopsummarylist2r'></span><span id='topic+fitted.loop2r'></span><span id='topic+fitted.loop2rsummary'></span>

<h3>Description</h3>

<p>Extract input, output, geometric and algebraic residuals, studentized residuals and fitted values from fitted loops or ellipses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>##S3 methods for classes 'ellipsefit', 'ellipsesummary', 'fittedloop',
##'loopsummary','ellipsefitlist', 'ellipsesummarylist', 'fittedlooplist',
##'loopsummarylist', 'loop2r', 'fittedlooplist2r',
##'loopsummarylist2r' and 'loop2rsummary'.
## S3 method for class 'ellipsefit'
residuals(object,...)
## S3 method for class 'ellipsefit'
rstudent(model,...)
## S3 method for class 'ellipsefit'
fitted(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.fittedloop_+3A_object">object</code></td>
<td>

<p>an object created by <code><a href="#topic+fel">fel</a></code> or <code><a href="#topic+floop">floop</a></code>.
</p>
</td></tr>
<tr><td><code id="residuals.fittedloop_+3A_model">model</code></td>
<td>

<p>an object created by <code><a href="#topic+fel">fel</a></code> or <code><a href="#topic+floop">floop</a></code>.
</p>
</td></tr>
<tr><td><code id="residuals.fittedloop_+3A_...">...</code></td>
<td>

<p>other arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geometric residuals are based on the straight line distance between predicted and true values along an x,y cartesian plane, and algebraic residuals are based on the method used to calculate the <code>ellipsefit</code> object. 
If method=&quot;harmonic2&quot; (which is always the case if this is a <code>fittedloop</code> object) or if bootstrapping has occurred, then, there are no algebraic residuals and <code>residuals.ellipsefit</code> replaces these with the geometric residuals.
</p>
<p>Studentization for the <code>rstudent</code> function is performed as if method=&quot;harmonic2&quot; regardless of the method used for fitting the ellipse/loop. Therefore, unless method=&quot;harmonic2&quot; and no bootstrapping is performed, these are pseudo-studentized residuals, not true studentized residuals. This is internal scaling studentization. Studentization for bootstrapping in the functions <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code>/<code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code> differs from the studentization performed by <code>rstudent</code> in that it only accounts for the influence matrix and does not divide by the standard deviation. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>input</code></td>
<td>
<p>a numeric vector. Observed input - fitted input for residuals.</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>a numeric vector. Observed output - fitted output for residuals.</p>
</td></tr>
<tr><td><code>geometric</code></td>
<td>
<p>a numeric vector. Not available with rstudent. See details.</p>
</td></tr>
<tr><td><code>algebraic</code></td>
<td>
<p>a numeric vector. Not available with rstudent or when the 'harmonic2' method is used. See details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Yang, F. and A. Parkhurst, Estimating Elliptical Hysteresis: A Comparison of Analytic Methods. (submitted)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fel">fel</a></code>, <code><a href="#topic+floop">floop</a></code>, <code><a href="#topic+summary.ellipsefit">summary.ellipsefit</a></code> and <code><a href="#topic+summary.fittedloop">summary.fittedloop</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##For multiple loops/ellipses
data(HysteresisData)
Mloopmodels.rep &lt;- floop.repeated(HysteresisData$X, HysteresisData$Y,
n=5,m=3, subjects = HysteresisData$subjects,subjects.in=c("A","C"),
repeated=HysteresisData$repeated)
Mloopmodels.rep                #Gives estimates and delta standard errors
residuals(Mloopmodels.rep)  #$input $output $geometric 
fitted(Mloopmodels.rep)     #$input $output
scatterplotMatrix(cbind(residuals(Mloopmodels.rep)$input,
residuals(Mloopmodels.rep)$output,residuals(Mloopmodels.rep)$geometric,
fitted(Mloopmodels.rep)$input,fitted(Mloopmodels.rep)$output),
  main='Residuals for Multiple Hysteresis Loops',smooth=FALSE,
  var.labels=c("Input Resid","Output Resid","Geometric Resid",
  "Fitted Input", "Fitted Output"),
  groups=residuals(Mloopmodels.rep)$repeated)
rstudent(Mloopmodels.rep)  #$input $output
scatterplotMatrix(cbind(rstudent(Mloopmodels.rep)$input,
rstudent(Mloopmodels.rep)$output,fitted(Mloopmodels.rep)$input,
fitted(Mloopmodels.rep)$output),main='Studentized Residuals 
for Multiple Hysteresis Loops',smooth=FALSE,
var.labels=c("Input Resid","Output Resid", "Fitted Input",
"Fitted Output"),groups=residuals(Mloopmodels.rep)$repeated)

##For single Ellipse
ellipse1 &lt;- mel(sd.x=0.2,sd.y=0.04)
ellipse1.fit &lt;- fel(ellipse1$x,ellipse1$y)
residuals(ellipse1.fit)
fitted(ellipse1.fit)
scatterplotMatrix(cbind(residuals(ellipse1.fit)$input,
residuals(ellipse1.fit)$output,residuals(ellipse1.fit)$geometric,
fitted(ellipse1.fit)$input,fitted(ellipse1.fit)$output),
main='Residuals for Simulated Ellipse',smooth=FALSE,
var.labels=c("Input Resid","Output Resid","Geometric Resid", 
"Fitted Input", "Fitted Output"))

rstudent(ellipse1.fit) #for input and output variables
scatterplotMatrix(cbind(rstudent(ellipse1.fit)$input,
rstudent(ellipse1.fit)$output,fitted(ellipse1.fit)$input,
fitted(ellipse1.fit)$output),main='Studentized Residuals
for Simulated Ellipse',smooth=FALSE,
var.labels=c("Input Resid","Output Resid","Fitted Input",
"Fitted Output"))

plot(ellipse1.fit$pred.y,rstudent(ellipse1.fit)$output,
xlab="Fitted Output",ylab="Output Studentized Residuals",
main="Studentized Residuals:Simulated Ellipse")
abline(h = 0, lty = 2, col = "gray")
qqnorm(rstudent(ellipse1.fit)$output,sub='Output Studentized
Residuals Simulated Ellipse')
qqline(rstudent(ellipse1.fit)$output,col="red") #q-q line
</code></pre>

<hr>
<h2 id='summary.fittedloop'>
Summarizing and Bootstrapping Fitted Ellipses or Loops
</h2><span id='topic+summary.ellipsefit'></span><span id='topic+summary.fittedloop'></span><span id='topic+summary.loop2r'></span>

<h3>Description</h3>

<p>summary methods for classes <code>ellipsefit</code> and <code>fittedloop</code> created by the functions <code><a href="#topic+fel">fel</a></code> and <code><a href="#topic+floop">floop</a></code>. Can bootstrap results to produce parameter estimates with reduced bias and standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ellipsefit'
summary(object,boot=TRUE, N = 1000, 
studentize=TRUE, center=FALSE, cbb=NULL, joint=FALSE,seed=NULL,...)
## S3 method for class 'fittedloop'
summary(object,boot=TRUE,N=1000,
cbb=NULL,joint=FALSE,seed=NULL,...)
## S3 method for class 'loop2r'
summary(object,boot=TRUE,N=1000,
cbb=NULL,joint=FALSE,seed=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fittedloop_+3A_object">object</code></td>
<td>

<p>an object of class <code>ellipsefit</code> or <code>fittedloop</code>, a result of a call to <code><a href="#topic+fel">fel</a></code> or <code><a href="#topic+floop">floop</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.fittedloop_+3A_boot">boot</code></td>
<td>

<p>logical. Whether to perform bootstrapping to get standard errors, which is the default TRUE, or to get standard errors through the delta method if FALSE.
</p>
</td></tr>
<tr><td><code id="summary.fittedloop_+3A_n">N</code></td>
<td>

<p>optional number of bootstrap replicates. Default of 1000.
</p>
</td></tr>
<tr><td><code id="summary.fittedloop_+3A_studentize">studentize</code></td>
<td>

<p>studentize the residuals to improve performance. Default is true.
</p>
</td></tr>
<tr><td><code id="summary.fittedloop_+3A_center">center</code></td>
<td>

<p>center x and y residuals around zero. Default is false. Irrelevant for &quot;harmonic2&quot; method.
</p>
</td></tr>
<tr><td><code id="summary.fittedloop_+3A_cbb">cbb</code></td>
<td>

<p>allows for circular block bootstrapping. The default is NULL in which case circular block bootstrapping is not performed. If cbb is an integer greater than 1 which is a divisor of either the number of observations for methods &quot;nls&quot;, &quot;lm&quot;, &quot;geometric&quot; or the number of observations minus 3 for <code>method="harmonic2"</code> then it is used as the block size for circular block bootstrapping.  
</p>
</td></tr>
<tr><td><code id="summary.fittedloop_+3A_joint">joint</code></td>
<td>

<p>logical that defaults to false. Resample input and output residuals paired by observation, instead of separately.  
</p>
</td></tr>
<tr><td><code id="summary.fittedloop_+3A_seed">seed</code></td>
<td>

<p>either NULL or a positive integer. Set the random number seed.
</p>
</td></tr>
<tr><td><code id="summary.fittedloop_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrap objects created by fitting hysteretic data with one of the functions <code><a href="#topic+fel">fel</a></code> or <code><a href="#topic+floop">floop</a></code> and produce statistical summaries. Bootstrapping reduces the bias on estimates and also gives standard errors. Bootstrap estimates are created by subtracting original estimates from bootstrap means to get a bias estimate, and then subtracting this bias from the original estimate.
</p>
<p>Residuals are studentized as if they were produced using the harmonic2 method, regardless of which method was actually used to produce them. However, unpublished simulation studies show that these studentized residuals provide better 95 percent coverages for all methods despite this. This studentization is not true studentization as in <code><a href="#topic+rstudent.ellipsefit">rstudent.ellipsefit</a></code> as it only accounts for the influence matrix and does not divide by the standard deviation.
</p>
<p>If residuals are serially correlated than the argument cbb may be used to sample blocks of length cbb instead of individual residuals. Circular block bootstrapping is used, which means that all residuals are equally likely to be included and blocks can be made up of the last points on the ellipse together with the first.
</p>
<p>When using the 'nls', 'geometric' or 'lm' methods individual bootstrap replications may occasionally fail to converge, when this occurs an extra replication will take the place of the one that failed to converge and a warning message will be produced.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>function call for original fit.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>fitting method used. Only for <code>summary.ellipsefit</code>. See <code><a href="#topic+fel">fel</a></code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the input x.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the output y.</p>
</td></tr>
<tr><td><code>pred.x</code></td>
<td>
<p>the bootstrap fitted values for x.</p>
</td></tr>
<tr><td><code>pred.y</code></td>
<td>
<p>the bootstrap fitted values for y.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>matrix containing parameter and standard error estimates, bootstrap quantiles, and bootstrapped parameter estimates for a wide variety of parameters. See <code><a href="#topic+loop.parameters">loop.parameters</a></code>.</p>
</td></tr>
<tr><td><code>Delta.Std.Errors</code></td>
<td>
<p>the delta method standard errors.</p>
</td></tr>
<tr><td><code>fit.statistics</code></td>
<td>
<p>rudimentary measures, based on the &quot;harmonic2&quot; method, include the Multivariate Final Prediction Error (MFPE) and the AIC for both the output alone and the two variables in combination. 
Although degree of freedom adjustments are made for other methods, measures of fit require further study</p>
</td></tr>
</table>
<p>For bootstrapping
</p>
<table>
<tr><td><code>summarycall</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>boot.data</code></td>
<td>
<p>parameter estimates from individual bootstrap replications.</p>
</td></tr>
<tr><td><code>Boot.Estimates</code></td>
<td>
<p>bootstrapped estimates.</p>
</td></tr>
<tr><td><code>Boot.Std.Errors</code></td>
<td>
<p>bootstrap standard errors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Spencer Maynes, Fan Yang, and Anne Parkhurst.
</p>


<h3>References</h3>

<p>Yang, F. and A. Parkhurst, Efficient Estimation of Elliptical Hysteresis (submitted)
</p>
<p>Correa, Solange, Extended Bootstrap Bias Correction with Application to Multilevel Modelling of Survey Data under Informative Sampling.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fel">fel</a></code> for fitting points that form an ellipse and creating an ellipsefit object and <code><a href="#topic+plot.ellipsesummary">plot.ellipsesummary</a></code> for plotting an ellipsesummary object.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Loop example with circular block bootstrapping
loop1 &lt;- mloop(n=1,m=2,sd.x=0.05,sd.y=0.05)
loop1.fit &lt;- floop(loop1$x,loop1$y,m=2,n=1)
boot.loop1 &lt;- summary(loop1.fit,cbb=3)
boot.loop1
plot(boot.loop1)

#Ellipse example.
ellipse1 &lt;- mel(sd.x=0.2,sd.y=0.04)
ellipse1.fit &lt;- fel(ellipse1$x,ellipse1$y)
boot.ellipse1.fit &lt;- summary(ellipse1.fit)
boot.ellipse1.fit
plot(boot.ellipse1.fit,xlab="Input",ylab="Output",
main="Bootstrapped Ellipse",putNumber=TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
