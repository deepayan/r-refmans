<!DOCTYPE html><html lang="en"><head><title>Help for package blavaan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {blavaan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bcfa'><p>Fit Confirmatory Factor Analysis Models</p></a></li>
<li><a href='#bgrowth'><p>Fit Growth Curve Models</p></a></li>
<li><a href='#blav_internal'><p>blavaan internal functions</p></a></li>
<li><a href='#blavaan'><p>Fit a Bayesian Latent Variable Model</p></a></li>
<li><a href='#blavaan-class'><p>Class For Representing A (Fitted) Bayesian Latent Variable Model</p></a></li>
<li><a href='#blavCompare'>
<p>Bayesian model comparisons</p></a></li>
<li><a href='#blavFitIndices'><p>SEM Fit Indices for Bayesian SEM</p></a></li>
<li><a href='#blavInspect'><p>Inspect or Extract Information from a Fitted blavaan Object</p></a></li>
<li><a href='#blavPredict'><p>Predict the values of latent variables, observed variables, and missing variables.</p></a></li>
<li><a href='#bsem'><p>Fit Structural Equation Models</p></a></li>
<li><a href='#dpriors'><p>Specify Default Prior Distributions</p></a></li>
<li><a href='#plot.blavaan'><p>blavaan Diagnostic Plots</p></a></li>
<li><a href='#ppmc'><p>Posterior Predictive Model Checks</p></a></li>
<li><a href='#sampleData'><p>Sample data from the posterior (or prior) distribution.</p></a></li>
<li><a href='#standardizedPosterior'><p>Standardized Posterior</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Latent Variable Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit a variety of Bayesian latent variable models, including confirmatory
   factor analysis, structural equation models, and latent growth curve models. References: Merkle &amp; Rosseel (2018) &lt;<a href="https://doi.org/10.18637%2Fjss.v085.i04">doi:10.18637/jss.v085.i04</a>&gt;; Merkle et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i06">doi:10.18637/jss.v100.i06</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0), methods, Rcpp(&ge; 0.12.15)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, lavaan(&ge; 0.6-18), coda, mnormt,
nonnest2(&ge; 0.5-7), loo(&ge; 2.0), rstan(&ge; 2.26.0),
rstantools(&ge; 1.5.0), RcppParallel (&ge; 5.0.1), bayesplot,
Matrix, future.apply, tmvnsim</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>StanHeaders (&ge; 2.26.0), rstan (&ge; 2.26.0), BH (&ge; 1.69.0),
Rcpp (&ge; 0.12.15), RcppEigen (&ge; 0.3.3.4.0), RcppParallel (&ge;
5.0.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>runjags(&ge; 2.0.4-3), modeest(&ge; 2.3.3), rjags, cmdstanr,
semTools, blavsam, tinytest</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ecmerkle.github.io/blavaan/">https://ecmerkle.github.io/blavaan/</a>,
<a href="https://github.com/ecmerkle/blavaan">https://github.com/ecmerkle/blavaan</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ecmerkle/blavaan/issues">https://github.com/ecmerkle/blavaan/issues</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://stan-dev.r-universe.dev">https://stan-dev.r-universe.dev</a>,
<a href="https://ecmerkle.github.io/drat">https://ecmerkle.github.io/drat</a></td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>brms</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-08 16:26:56 UTC; merkle</td>
</tr>
<tr>
<td>Author:</td>
<td>Edgar Merkle <a href="https://orcid.org/0000-0001-7158-0653"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Yves Rosseel [aut],
  Ben Goodrich [aut],
  Mauricio Garnier-Villarreal
    <a href="https://orcid.org/0000-0002-2951-6647"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (R/blav_compare.R, R/ctr_bayes_fit.R, vignettes),
  Terrence D. Jorgensen
    <a href="https://orcid.org/0000-0001-5111-6773"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (R/ctr_bayes_fit.R, R/ctr_ppmc.R, R/blav_predict.R),
  Huub Hoofs [ctb] (R/ctr_bayes_fit.R),
  Rens van de Schoot [ctb] (R/ctr_bayes_fit.R),
  Andrew Johnson [ctb] (Makevars),
  Matthew Emery [ctb] (loo moment_match)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edgar Merkle &lt;merklee@missouri.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-08 19:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='bcfa'>Fit Confirmatory Factor Analysis Models</h2><span id='topic+bcfa'></span>

<h3>Description</h3>

<p>Fit a Confirmatory Factor Analysis (CFA) model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcfa(..., cp = "srs",
     dp = NULL, n.chains = 3, burnin, sample,
     adapt, mcmcfile = FALSE, mcmcextra = list(), inits = "simple",
     convergence = "manual", target = "stan", save.lvs = FALSE,
     wiggle = NULL, wiggle.sd = 0.1, prisamp = FALSE, jags.ic = FALSE,
     seed = NULL, bcontrol = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bcfa_+3A_...">...</code></td>
<td>
<p>Default lavaan arguments.  See <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_cp">cp</code></td>
<td>
<p>Handling of prior distributions on covariance parameters:
possible values are <code>"srs"</code> (default) or
<code>"fa"</code>. Option <code>"fa"</code> is only available for <code>target="jags"</code>.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_dp">dp</code></td>
<td>
<p>Default prior distributions on different types of
parameters, typically the result of a call to <code>dpriors()</code>.
See the <code>dpriors()</code> help file for more information.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of desired MCMC chains.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_burnin">burnin</code></td>
<td>
<p>Number of burnin/warmup iterations (not including the adaptive
iterations, for target=&quot;jags&quot;). Defaults to 4000 or target=&quot;jags&quot; and
500 for Stan targets.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_sample">sample</code></td>
<td>
<p>The total number of samples to take after burnin. Defaults
to 10000 for target=&quot;jags&quot; and 1000 for Stan targets.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_adapt">adapt</code></td>
<td>
<p>For target=&quot;jags&quot;, the number of adaptive iterations to use at the start of
sampling. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_mcmcfile">mcmcfile</code></td>
<td>
<p>If <code>TRUE</code>, the JAGS/Stan model will be written to file
(in the lavExport directory). Can also supply a character
string, which serves as the name of the directory to which files will be written.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_mcmcextra">mcmcextra</code></td>
<td>
<p>A list with potential names <code>syntax</code> (unavailable
for target=<code>"stan"</code>),
<code>monitor</code>, <code>data</code>, and <code>llnsamp</code>. The <code>syntax</code> object is a text string containing extra
code to insert in the JAGS/Stan model syntax. The <code>data</code> object
is a list of extra data to send to the JAGS/Stan model. If 
<code>moment_match_k_threshold</code> is specified within <code>data</code> the looic of 
the model will be calculated using moment matching. The <code>monitor</code> object
is a character vector containing extra JAGS/Stan parameters to
monitor. The <code>llnsamp</code> object is only relevant to models with ordinal
variables, and specifies the number of samples that should be drawn to approximate
the model log-likelihood (larger numbers imply higher accuracy and
longer time). This log-likelihood is specifically used to compute
information criteria.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_inits">inits</code></td>
<td>
<p>If it is a character string, the options are currently
<code>"simple"</code> (default), <code>"Mplus"</code>, <code>"prior"</code>, or <code>"jags"</code>.  In the first two
cases, parameter values are set as though they will be estimated via
ML (see <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>).  The starting parameter value for
each chain is then perturbed from the original values through the
addition of random uniform noise.  If <code>"prior"</code> is used, the starting
parameter values are obtained based on the prior distributions
(while also trying to ensure that the starting values will not crash
the model estimation).  If <code>"jags"</code>, no starting values are
specified and JAGS will choose values on its own (and this will probably
crash Stan targets). You can also supply
a list of starting values for each chain, where the list format can
be obtained from, e.g., <code>blavInspect(fit, "inits")</code>. Finally,
you can specify starting values in a similar way to lavaan,
using the lavaan <code>start</code> argument (see the lavaan
documentation for all the options there). In this case, you should also set
<code>inits="simple"</code>, and be aware that the same starting values
will be used for each chain.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_convergence">convergence</code></td>
<td>
<p>Useful only for <code>target="jags"</code>. If <code>"auto"</code>, parameters are
sampled until convergence is achieved (via <code>autorun.jags()</code>). In
this case, the arguments <code>burnin</code> and <code>sample</code> are passed to
<code>autorun.jags()</code> as <code>startburnin</code> and <code>startsample</code>,
respectively. Otherwise, parameters
are sampled as specified by the user (or by the <code>run.jags</code>
defaults).</p>
</td></tr>
<tr><td><code id="bcfa_+3A_target">target</code></td>
<td>
<p>Desired MCMC sampling, with <code>"stan"</code> (pre-compiled
marginal approach) as
default. Also available is <code>"vb"</code>, which calls the rstan function
<code>vb()</code>. Other options include <code>"jags"</code>, <code>"stancond"</code>, and
<code>"stanclassic"</code>, which sample latent variables and provide some
greater functionality (because syntax is written &quot;on the fly&quot;). But
they are slower and less efficient.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_save.lvs">save.lvs</code></td>
<td>
<p>Should sampled latent variables (factor scores) be
saved? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="bcfa_+3A_wiggle">wiggle</code></td>
<td>
<p>Labels of equality-constrained parameters that should be
&quot;approximately&quot; equal. Can also be &quot;intercepts&quot;, &quot;loadings&quot;,
&quot;regressions&quot;, &quot;means&quot;.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_wiggle.sd">wiggle.sd</code></td>
<td>
<p>The prior sd (of normal distribution) to be used in approximate equality
constraints. Can be one value, or (for target=&quot;stan&quot;) a numeric vector
of values that is the same length as wiggle.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_prisamp">prisamp</code></td>
<td>
<p>Should samples be drawn from the prior, instead of the
posterior (<code>target="stan"</code> only)? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="bcfa_+3A_jags.ic">jags.ic</code></td>
<td>
<p>Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="bcfa_+3A_seed">seed</code></td>
<td>
<p>A vector of length <code>n.chains</code> (for target
<code>"jags"</code>) or an integer (for target <code>"stan"</code>) containing random
seeds for the MCMC run. If <code>NULL</code>, seeds will be chosen randomly.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_bcontrol">bcontrol</code></td>
<td>
<p>A list containing additional parameters passed to
<code>run.jags</code> (or <code>autorun.jags</code>) or <code>stan</code>.  See the manpage of those functions for an
overview of the additional parameters that can be set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>bcfa</code> function is a wrapper for the more general
<code><a href="#topic+blavaan">blavaan</a></code> function, using the following default
<code><a href="lavaan.html#topic+lavaan">lavaan</a></code> arguments:
<code>int.ov.free = TRUE</code>, <code>int.lv.free = FALSE</code>,
<code>auto.fix.first = TRUE</code> (unless <code>std.lv = TRUE</code>),
<code>auto.fix.single = TRUE</code>, <code>auto.var = TRUE</code>,
<code>auto.cov.lv.x = TRUE</code>,
<code>auto.th = TRUE</code>, <code>auto.delta = TRUE</code>,
and <code>auto.cov.y = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object that inherits from class <a href="lavaan.html#topic+lavaan-class">lavaan</a>, for which several methods
are available, including a <code>summary</code> method.
</p>


<h3>References</h3>

<p>Edgar C. Merkle, Ellen Fitzsimmons, James Uanhoro, &amp; Ben Goodrich (2021). Efficient Bayesian Structural Equation Modeling in Stan. Journal of Statistical
Software, 100(6), 1-22. URL http://www.jstatsoft.org/v100/i06/.
</p>
<p>Edgar C. Merkle &amp; Yves Rosseel (2018). blavaan: Bayesian Structural
Equation Models via Parameter Expansion. Journal of Statistical
Software, 85(4), 1-30. URL http://www.jstatsoft.org/v85/i04/.
</p>
<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. URL
http://www.jstatsoft.org/v48/i02/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blavaan">blavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HolzingerSwineford1939, package = "lavaan")

# The Holzinger and Swineford (1939) example
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

## Not run: 
fit &lt;- bcfa(HS.model, data = HolzingerSwineford1939)
summary(fit)

## End(Not run)

# A short run for rough results
fit &lt;- bcfa(HS.model, data = HolzingerSwineford1939, burnin = 100, sample = 100,
            n.chains = 2)
summary(fit)
</code></pre>

<hr>
<h2 id='bgrowth'>Fit Growth Curve Models</h2><span id='topic+bgrowth'></span>

<h3>Description</h3>

<p>Fit a Growth Curve model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgrowth(..., cp = "srs", dp = NULL, n.chains = 3,
burnin, sample, adapt, mcmcfile = FALSE, mcmcextra = list(), 
inits = "simple", convergence = "manual", target = "stan",
save.lvs = FALSE, wiggle = NULL, wiggle.sd = 0.1, prisamp = FALSE,
jags.ic = FALSE, seed = NULL, bcontrol = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bgrowth_+3A_...">...</code></td>
<td>
<p>Default lavaan arguments.  See <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_cp">cp</code></td>
<td>
<p>Handling of prior distributions on covariance parameters:
possible values are <code>"srs"</code> (default) or <code>"fa"</code>. Option <code>"fa"</code> is only available for <code>target="jags"</code>.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_dp">dp</code></td>
<td>
<p>Default prior distributions on different types of
parameters, typically the result of a call to <code>dpriors()</code>.
See the <code>dpriors()</code> help file for more information.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of desired MCMC chains.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_burnin">burnin</code></td>
<td>
<p>Number of burnin/warmup iterations (not including the adaptive
iterations, for target=&quot;jags&quot;). Defaults to 4000 or target=&quot;jags&quot; and
500 for Stan targets.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_sample">sample</code></td>
<td>
<p>The total number of samples to take after burnin. Defaults
to 10000 for target=&quot;jags&quot; and 1000 for Stan targets.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_adapt">adapt</code></td>
<td>
<p>For target=&quot;jags&quot;, the number of adaptive iterations to use at the start of
sampling. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_mcmcfile">mcmcfile</code></td>
<td>
<p>If <code>TRUE</code>, the JAGS/Stan model will be written to file
(in the lavExport directory). Can also supply a character
string, which serves as the name of the directory to which files will be written.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_mcmcextra">mcmcextra</code></td>
<td>
<p>A list with potential names <code>syntax</code> (unavailable
for target=<code>"stan"</code>),
<code>monitor</code>, <code>data</code>, and <code>llnsamp</code>. The <code>syntax</code> object is a text string containing extra
code to insert in the JAGS/Stan model syntax. The <code>data</code> object
is a list of extra data to send to the JAGS/Stan model. If 
<code>moment_match_k_threshold</code> is specified within <code>data</code> the looic of 
the model will be calculated using moment matching. The <code>monitor</code> object
is a character vector containing extra JAGS/Stan parameters to
monitor. The <code>llnsamp</code> object is only relevant to models with ordinal
variables, and specifies the number of samples that should be drawn to approximate
the model log-likelihood (larger numbers imply higher accuracy and
longer time). This log-likelihood is specifically used to compute
information criteria.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_inits">inits</code></td>
<td>
<p>If it is a character string, the options are currently
<code>"simple"</code> (default), <code>"Mplus"</code>, <code>"prior"</code>, or <code>"jags"</code>.  In the first two
cases, parameter values are set as though they will be estimated via
ML (see <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>).  The starting parameter value for
each chain is then perturbed from the original values through the
addition of random uniform noise.  If <code>"prior"</code> is used, the starting
parameter values are obtained based on the prior distributions
(while also trying to ensure that the starting values will not crash
the model estimation).  If <code>"jags"</code>, no starting values are
specified and JAGS will choose values on its own (and this will probably
crash Stan targets). You can also supply
a list of starting values for each chain, where the list format can
be obtained from, e.g., <code>blavInspect(fit, "inits")</code>. Finally,
you can specify starting values in a similar way to lavaan,
using the lavaan <code>start</code> argument (see the lavaan
documentation for all the options there). In this case, you should also set
<code>inits="simple"</code>, and be aware that the same starting values
will be used for each chain.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_convergence">convergence</code></td>
<td>
<p>Useful only for <code>target="jags"</code>. If <code>"auto"</code>, parameters are
sampled until convergence is achieved (via <code>autorun.jags()</code>). In
this case, the arguments <code>burnin</code> and <code>sample</code> are passed to
<code>autorun.jags()</code> as <code>startburnin</code> and <code>startsample</code>,
respectively. Otherwise, parameters
are sampled as specified by the user (or by the <code>run.jags</code>
defaults).</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_target">target</code></td>
<td>
<p>Desired MCMC sampling, with <code>"stan"</code> (pre-compiled
marginal approach) as
default. Also available is <code>"vb"</code>, which calls the rstan function
<code>vb()</code>. Other options include <code>"jags"</code>, <code>"stancond"</code>, and
<code>"stanclassic"</code>, which sample latent variables and provide some
greater functionality (because syntax is written &quot;on the fly&quot;). But
they are slower and less efficient.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_save.lvs">save.lvs</code></td>
<td>
<p>Should sampled latent variables (factor scores) be
saved? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_wiggle">wiggle</code></td>
<td>
<p>Labels of equality-constrained parameters that should be
&quot;approximately&quot; equal. Can also be &quot;intercepts&quot;, &quot;loadings&quot;,
&quot;regressions&quot;, &quot;means&quot;.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_wiggle.sd">wiggle.sd</code></td>
<td>
<p>The prior sd (of normal distribution) to be used in approximate equality
constraints. Can be one value, or (for target=&quot;stan&quot;) a numeric vector
of values that is the same length as wiggle.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_prisamp">prisamp</code></td>
<td>
<p>Should samples be drawn from the prior, instead of the
posterior (<code>target="stan"</code> only)? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_jags.ic">jags.ic</code></td>
<td>
<p>Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_seed">seed</code></td>
<td>
<p>A vector of length <code>n.chains</code> (for target
<code>"jags"</code>) or an integer (for target <code>"stan"</code>) containing random
seeds for the MCMC run. If <code>NULL</code>, seeds will be chosen randomly.</p>
</td></tr>
<tr><td><code id="bgrowth_+3A_bcontrol">bcontrol</code></td>
<td>
<p>A list containing additional parameters passed to
<code>run.jags</code> (or <code>autorun.jags</code>) or <code>stan</code>.  See the manpage of those functions for an
overview of the additional parameters that can be set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>bgrowth</code> function is a wrapper for the more general
<code><a href="#topic+blavaan">blavaan</a></code> function, using the following default
<code><a href="lavaan.html#topic+lavaan">lavaan</a></code> arguments:
<code>meanstructure = TRUE</code>, 
<code>int.ov.free = FALSE</code>, <code>int.lv.free = TRUE</code>,
<code>auto.fix.first = TRUE</code> (unless <code>std.lv = TRUE</code>),
<code>auto.fix.single = TRUE</code>, <code>auto.var = TRUE</code>,
<code>auto.cov.lv.x = TRUE</code>, 
<code>auto.th = TRUE</code>, <code>auto.delta = TRUE</code>,
and <code>auto.cov.y = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+blavaan">blavaan</a></code>, for which several methods
are available, including a <code>summary</code> method.
</p>


<h3>References</h3>

<p>Edgar C. Merkle, Ellen Fitzsimmons, James Uanhoro, &amp; Ben Goodrich (2021). Efficient Bayesian Structural Equation Modeling in Stan. Journal of Statistical
Software, 100(6), 1-22. URL http://www.jstatsoft.org/v100/i06/.
</p>
<p>Edgar C. Merkle &amp; Yves Rosseel (2018). blavaan: Bayesian Structural
Equation Models via Parameter Expansion. Journal of Statistical
Software, 85(4), 1-30. URL http://www.jstatsoft.org/v85/i04/.
</p>
<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. URL
http://www.jstatsoft.org/v48/i02/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blavaan">blavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## linear growth model with a time-varying covariate
data(Demo.growth, package = "lavaan")

model.syntax &lt;- '
  # intercept and slope with fixed coefficients
    i =~ 1*t1 + 1*t2 + 1*t3 + 1*t4
    s =~ 0*t1 + 1*t2 + 2*t3 + 3*t4

  # regressions
    i ~ x1 + x2
    s ~ x1 + x2

  # time-varying covariates
    t1 ~ c1
    t2 ~ c2
    t3 ~ c3
    t4 ~ c4
'

fit &lt;- bgrowth(model.syntax, data = Demo.growth)
summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='blav_internal'>blavaan internal functions</h2><span id='topic+blav_internal'></span><span id='topic+blav_model_test'></span><span id='topic+coeffun'></span><span id='topic+set_phantoms'></span><span id='topic+set_inits'></span><span id='topic+set_priors'></span><span id='topic+labelfun'></span>

<h3>Description</h3>

<p>Internal functions related to Bayesian model estimation.
Not to be called by the user.</p>

<hr>
<h2 id='blavaan'>Fit a Bayesian Latent Variable Model</h2><span id='topic+blavaan'></span>

<h3>Description</h3>

<p>Fit a Bayesian latent variable model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>blavaan(..., cp = "srs",
    dp = NULL, n.chains = 3, burnin, sample,
    adapt, mcmcfile = FALSE, mcmcextra = list(), inits = "simple",
    convergence = "manual", target = "stan", save.lvs = FALSE,
    wiggle = NULL, wiggle.sd = 0.1, prisamp = FALSE, jags.ic = FALSE,
    seed = NULL, bcontrol = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blavaan_+3A_...">...</code></td>
<td>
<p>Default lavaan arguments.  See <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_cp">cp</code></td>
<td>
<p>Handling of prior distributions on covariance parameters:
possible values are <code>"srs"</code> (default) or <code>"fa"</code>.  Option
<code>"fa"</code> is only available for <code>target="jags"</code>.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_dp">dp</code></td>
<td>
<p>Default prior distributions on different types of
parameters, typically the result of a call to <code>dpriors()</code>.
See the <code>dpriors()</code> help file for more information.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of desired MCMC chains.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_burnin">burnin</code></td>
<td>
<p>Number of burnin/warmup iterations (not including the adaptive
iterations, for target=&quot;jags&quot;). Defaults to 4000 or target=&quot;jags&quot; and
500 for Stan targets.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_sample">sample</code></td>
<td>
<p>The total number of samples to take after burnin. Defaults
to 10000 for target=&quot;jags&quot; and 1000 for Stan targets.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_adapt">adapt</code></td>
<td>
<p>For target=&quot;jags&quot;, the number of adaptive iterations to use at the start of
sampling. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_mcmcfile">mcmcfile</code></td>
<td>
<p>If <code>TRUE</code>, the JAGS/Stan model and data will be written
to files (in the lavExport directory). Can also supply a character
string, which serves as the name of the directory to which files will be written.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_mcmcextra">mcmcextra</code></td>
<td>
<p>A list with potential names <code>syntax</code> (unavailable
for target=<code>"stan"</code>),
<code>monitor</code>, <code>data</code>, and <code>llnsamp</code>. The <code>syntax</code> object is a text string containing extra
code to insert in the JAGS/Stan model syntax. The <code>data</code> object
is a list of extra data to send to the JAGS/Stan model. If 
<code>moment_match_k_threshold</code> is specified within <code>data</code> the looic of 
the model will be calculated using moment matching. The <code>monitor</code> object
is a character vector containing extra JAGS/Stan parameters to
monitor. The <code>llnsamp</code> object is only relevant to models with ordinal
variables, and specifies the number of samples that should be drawn to approximate
the model log-likelihood (larger numbers imply higher accuracy and
longer time). This log-likelihood is specifically used to compute
information criteria.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_inits">inits</code></td>
<td>
<p>If it is a character string, the options are currently
<code>"simple"</code> (default), <code>"Mplus"</code>, <code>"prior"</code>, or <code>"jags"</code>.  In the first two
cases, parameter values are set as though they will be estimated via
ML (see <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>).  The starting parameter value for
each chain is then perturbed from the original values through the
addition of random uniform noise.  If <code>"prior"</code> is used, the starting
parameter values are obtained based on the prior distributions
(while also trying to ensure that the starting values will not crash
the model estimation).  If <code>"jags"</code>, no starting values are
specified and JAGS will choose values on its own (and this will probably
crash Stan targets). You can also supply
a list of starting values for each chain, where the list format can
be obtained from, e.g., <code>blavInspect(fit, "inits")</code>. Finally,
you can specify starting values in a similar way to lavaan,
using the lavaan <code>start</code> argument (see the lavaan
documentation for all the options there). In this case, you should also set
<code>inits="simple"</code>, and be aware that the same starting values
will be used for each chain.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_convergence">convergence</code></td>
<td>
<p>Useful only for <code>target="jags"</code>. If <code>"auto"</code>, parameters are
sampled until convergence is achieved (via <code>autorun.jags()</code>). In
this case, the arguments <code>burnin</code> and <code>sample</code> are passed to
<code>autorun.jags()</code> as <code>startburnin</code> and <code>startsample</code>,
respectively. Otherwise, parameters
are sampled as specified by the user (or by the <code>run.jags</code>
defaults).</p>
</td></tr>
<tr><td><code id="blavaan_+3A_target">target</code></td>
<td>
<p>Desired MCMC sampling, with <code>"stan"</code> (pre-compiled
marginal approach) as
default. Also available is <code>"vb"</code>, which calls the rstan function
<code>vb()</code>. Other options include <code>"jags"</code>, <code>"stancond"</code>, and
<code>"stanclassic"</code>, which sample latent variables and provide some
greater functionality (because syntax is written &quot;on the fly&quot;). But
they are slower and less efficient.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_save.lvs">save.lvs</code></td>
<td>
<p>Should sampled latent variables (factor scores) be
saved? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="blavaan_+3A_wiggle">wiggle</code></td>
<td>
<p>Labels of equality-constrained parameters that should be
&quot;approximately&quot; equal. Can also be &quot;intercepts&quot;, &quot;loadings&quot;,
&quot;regressions&quot;, &quot;means&quot;.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_wiggle.sd">wiggle.sd</code></td>
<td>
<p>The prior sd (of normal distribution) to be used in approximate equality
constraints. Can be one value, or (for target=&quot;stan&quot;) a numeric vector
of values that is the same length as wiggle.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_prisamp">prisamp</code></td>
<td>
<p>Should samples be drawn from the prior, instead of the
posterior (<code>target="stan"</code> only)? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="blavaan_+3A_jags.ic">jags.ic</code></td>
<td>
<p>Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="blavaan_+3A_seed">seed</code></td>
<td>
<p>A vector of length <code>n.chains</code> (for target
<code>"jags"</code>) or an integer (for target <code>"stan"</code>) containing random
seeds for the MCMC run. If <code>NULL</code>, seeds will be chosen randomly.</p>
</td></tr>
<tr><td><code id="blavaan_+3A_bcontrol">bcontrol</code></td>
<td>
<p>A list containing additional parameters passed to
<code>run.jags</code> (or <code>autorun.jags</code>) or <code>stan</code>.  See the manpage of those functions for an
overview of the additional parameters that can be set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that inherits from class <a href="lavaan.html#topic+lavaan-class">lavaan</a>, for which several methods
are available, including a <code>summary</code> method.
</p>


<h3>References</h3>

<p>Edgar C. Merkle, Ellen Fitzsimmons, James Uanhoro, &amp; Ben Goodrich (2021). Efficient Bayesian Structural Equation Modeling in Stan. Journal of Statistical
Software, 100(6), 1-22. URL http://www.jstatsoft.org/v100/i06/.
</p>
<p>Edgar C. Merkle &amp; Yves Rosseel (2018). blavaan: Bayesian Structural
Equation Models via Parameter Expansion. Journal of Statistical
Software, 85(4), 1-30. URL http://www.jstatsoft.org/v85/i04/.
</p>
<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. URL
http://www.jstatsoft.org/v48/i02/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bcfa">bcfa</a></code>, <code><a href="#topic+bsem">bsem</a></code>, <code><a href="#topic+bgrowth">bgrowth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HolzingerSwineford1939, package = "lavaan")

# The Holzinger and Swineford (1939) example
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- blavaan(HS.model, data = HolzingerSwineford1939,
               auto.var = TRUE, auto.fix.first = TRUE,
               auto.cov.lv.x = TRUE)
summary(fit)
coef(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='blavaan-class'>Class For Representing A (Fitted) Bayesian Latent Variable Model</h2><span id='topic+blavaan-class'></span><span id='topic+coef+2Cblavaan-method'></span><span id='topic+show+2Cblavaan-method'></span><span id='topic+predict+2Cblavaan-method'></span><span id='topic+summary+2Cblavaan-method'></span>

<h3>Description</h3>

<p>The <code>blavaan</code> class contains the <code>lavaan</code>
class, representing a (fitted) Bayesian latent variable
model. It contains a description of the model as specified by the user,
a summary of the data, an internal matrix representation, and if the model
was fitted, the fitting results.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created via the
<code><a href="#topic+bcfa">bcfa</a></code>, <code><a href="#topic+bsem">bsem</a></code>, <code><a href="#topic+bgrowth">bgrowth</a></code> or
<code><a href="#topic+blavaan">blavaan</a></code> functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>version</code>:</dt><dd><p>The lavaan package version used to create this objects</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The function call as returned by <code>match.call()</code>.</p>
</dd>
<dt><code>timing</code>:</dt><dd><p>The elapsed time (user+system) for various parts of
the program as a list, including the total time.</p>
</dd>
<dt><code>Options</code>:</dt><dd><p>Named list of options that were provided by
the user, or filled-in automatically.</p>
</dd>
<dt><code>ParTable</code>:</dt><dd><p>Named list describing the model parameters. Can be coerced to a data.frame. In the documentation, this is called the &lsquo;parameter table&rsquo;.</p>
</dd>
<dt><code>pta</code>:</dt><dd><p>Named list containing parameter table attributes.</p>
</dd>
<dt><code>Data</code>:</dt><dd><p>Object of internal class <code>"Data"</code>: information
about the data.</p>
</dd>
<dt><code>SampleStats</code>:</dt><dd><p>Object of internal class <code>"SampleStats"</code>: sample
statistics</p>
</dd>
<dt><code>Model</code>:</dt><dd><p>Object of internal class <code>"Model"</code>: the
internal (matrix) representation of the model</p>
</dd>
<dt><code>Cache</code>:</dt><dd><p>List using objects that we try to compute only once, and reuse many times.</p>
</dd>
<dt><code>Fit</code>:</dt><dd><p>Object of internal class <code>"Fit"</code>: the
results of fitting the model. No longer used.</p>
</dd>
<dt><code>boot</code>:</dt><dd><p>List. Unused for Bayesian models.</p>
</dd>
<dt><code>optim</code>:</dt><dd><p>List. Information about the optimization.</p>
</dd>
<dt><code>loglik</code>:</dt><dd><p>List. Information about the loglikelihood of the model (if maximum likelihood was used).</p>
</dd>
<dt><code>implied</code>:</dt><dd><p>List. Model implied statistics.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>List. Information about the variance matrix (vcov) of the model parameters.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>List. Different test statistics.</p>
</dd>
<dt><code>h1</code>:</dt><dd><p>List. Information about the unrestricted h1 model (if available).</p>
</dd>
<dt><code>baseline</code>:</dt><dd><p>List. Information about a baseline model (often
the independence model) (if available).</p>
</dd>
<dt><code>external</code>:</dt><dd><p>List. Includes Stan or JAGS objects used for MCMC.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "blavaan", type = "free")</code>: Returns
the estimates of the parameters in the model as a named numeric vector.
If <code>type="free"</code>, only the free parameters are returned.
If <code>type="user"</code>, all parameters listed in the parameter table
are returned, including constrained and fixed parameters.</p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "lavaan")</code>: returns the
covariance matrix of the estimated parameters.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "blavaan")</code>: Print a short summary
of the model fit</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "blavaan", header = TRUE,
     fit.measures = FALSE, estimates = TRUE, ci = TRUE, 
     standardized = FALSE, rsquare = FALSE, std.nox = FALSE,
     psrf = TRUE, neff = FALSE, postmedian = FALSE, postmode = FALSE,
     priors = TRUE, bf = FALSE, nd = 3L)</code>:
Print a nice summary of the model estimates.
If <code>header = TRUE</code>, the header section (including fit measures) is
printed.
If <code>fit.measures = TRUE</code>, additional fit measures are added to the
header section.
If <code>estimates = TRUE</code>, print the parameter estimates section.
If <code>ci = TRUE</code>, add confidence intervals to the parameter estimates
section.
If <code>standardized = TRUE</code>,
the standardized solution is also printed.  Note that <em>SE</em>s and
tests are still based on unstandardized estimates. Use
<code><a href="lavaan.html#topic+standardizedSolution">standardizedSolution</a></code> to obtain <em>SE</em>s and test
statistics for standardized estimates.
If <code>rsquare=TRUE</code>, the R-Square values for the dependent variables
in the model are printed.
If <code>std.nox = TRUE</code>, the <code>std.all</code> column contains the
the <code>std.nox</code> column from the parameterEstimates() output.
If <code>psrf = TRUE</code>, potential scale reduction factors (Rhats)
are printed.
If <code>neff = TRUE</code>, effective sample sizes are printed.
If <code>postmedian</code> or <code>postmode</code> are TRUE, posterior
medians or modes are printed instead of posterior means.
If <code>priors = TRUE</code>, parameter prior distributions are
printed.
If <code>bf = TRUE</code>, Savage-Dickey approximations of the Bayes
factor are printed for certain parameters.
Nothing is returned (use
<code>lavInspect</code> or another extractor function
to extract information from a fitted model).</p>
</dd>
</dl>



<h3>References</h3>

<p>Edgar C. Merkle, Ellen Fitzsimmons, James Uanhoro, &amp; Ben Goodrich (2021). Efficient Bayesian Structural Equation Modeling in Stan. Journal of Statistical
Software, 100(6), 1-22. URL http://www.jstatsoft.org/v100/i06/.
</p>
<p>Edgar C. Merkle &amp; Yves Rosseel (2018). blavaan: Bayesian Structural
Equation Models via Parameter Expansion. Journal of Statistical
Software, 85(4), 1-30. URL http://www.jstatsoft.org/v85/i04/.
</p>
<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. URL
http://www.jstatsoft.org/v48/i02/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bcfa">bcfa</a></code>, <code><a href="#topic+bsem">bsem</a></code>, <code><a href="#topic+bgrowth">bgrowth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- bcfa(HS.model, data=HolzingerSwineford1939)

summary(fit, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)
coef(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='blavCompare'>
Bayesian model comparisons
</h2><span id='topic+blavCompare'></span><span id='topic+BF'></span>

<h3>Description</h3>

<p>Bayesian model comparisons, including WAIC, LOO, and Bayes factor approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blavCompare(object1, object2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blavCompare_+3A_object1">object1</code></td>
<td>
<p>An object of class <code>blavaan</code>.</p>
</td></tr>
<tr><td><code id="blavCompare_+3A_object2">object2</code></td>
<td>
<p>A second object of class <code>blavaan</code>.</p>
</td></tr>
<tr><td><code id="blavCompare_+3A_...">...</code></td>
<td>
<p>Other arguments to loo().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes Bayesian model comparison metrics, including a
Bayes factor approximation, WAIC, and LOOIC.
</p>
<p>The log-Bayes factor of the two models is based on the Laplace
approximation to each model's marginal log-likelihood.
</p>
<p>The WAIC and LOOIC metrics come from the loo package. The ELPD
difference and SE specifically come from loo::loo_compare().
</p>


<h3>Value</h3>

<p>A list containing separate results for log-Bayes factor, WAIC, LOOIC,
and differences between WAIC and LOOIC.
</p>


<h3>References</h3>

<p>Raftery, A. E. (1993). Bayesian model selection in structural equation models. In K. A. Bollen &amp; J. S. Long (Eds.), Testing structural equation models (pp. 163-180). Beverly Hills, CA: Sage.
</p>
<p>Vehtari A., Gelman A., Gabry J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. Statistics and Computing, 27, 1413-1432.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HolzingerSwineford1939, package = "lavaan")

hsm1 &lt;- ' visual  =~ x1 + x2 + x3 + x4
          textual =~ x4 + x5 + x6
          speed   =~ x7 + x8 + x9 '

fit1 &lt;- bcfa(hsm1, data = HolzingerSwineford1939)

hsm2 &lt;- ' visual  =~ x1 + x2 + x3
          textual =~ x4 + x5 + x6 + x7
          speed   =~ x7 + x8 + x9 '

fit2 &lt;- bcfa(hsm2, data = HolzingerSwineford1939)

blavCompare(fit1, fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='blavFitIndices'>SEM Fit Indices for Bayesian SEM</h2><span id='topic+blavFitIndices'></span><span id='topic+blavFitIndices-class'></span><span id='topic+show+2CblavFitIndices-method'></span><span id='topic+summary+2CblavFitIndices-method'></span><span id='topic+summary.bfi'></span>

<h3>Description</h3>

<p>This function provides a posterior distribution of some <code class="reqn">\chi^2</code>-based fit
indices to assess the global fit of a latent variable model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>blavFitIndices(object, thin = 1L, pD = c("loo","waic","dic"),
               rescale = c("devM","ppmc","mcmc"),
               fit.measures = "all", baseline.model = NULL)

## S4 method for signature 'blavFitIndices'
## S4 method for signature 'blavFitIndices'
summary(object, ...)

## S3 method for class 'bfi'
summary(object, central.tendency = c("mean","median","mode"),
        hpd = TRUE, prob = .90)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blavFitIndices_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+blavaan-class">blavaan</a></code>.</p>
</td></tr>
<tr><td><code id="blavFitIndices_+3A_thin">thin</code></td>
<td>
<p>Optional <code>integer</code> indicating how much to thin each chain.
Default is <code>1L</code>, indicating not to thin the chains.</p>
</td></tr>
<tr><td><code id="blavFitIndices_+3A_pd">pD</code></td>
<td>
<p><code>character</code> indicating from which information criterion
returned by <code>fitMeasures(object)</code> to use the estimated number of
parameters. The default is from the leave-one-out information criterion
(LOO-IC), which is most highly recommended by Vehtari et al. (2017).</p>
</td></tr>
<tr><td><code id="blavFitIndices_+3A_rescale">rescale</code></td>
<td>
<p><code>character</code> indicating the method used to calculate
fit indices. If <code>rescale = "devM"</code> (default), the Bayesian analog of
the <code class="reqn">\chi^2</code> statistic (the deviance evaluated at the posterior mean
of the model parameters) is approximated by rescaling the deviance at each
iteration by subtracting the estimated number of parameters. If
<code>rescale = "PPMC"</code>, the deviance at each iteration is rescaled by
subtracting the deviance of data simulated from the posterior predictive
distribution (as in posterior predictive model checking; see Hoofs et al.,
2017). If <code>rescale = "MCMC"</code>, the fit measures are simply calculated
using <code><a href="lavaan.html#topic+fitMeasures">fitMeasures</a></code> at each iteration of the Markov
chain(s), based on the model-implied moments at that iteration (NOT advised
when the model includes informative priors, in which case the model's
estimated <em>pD</em> will deviate from the number of parameters used to
calculate <em>df</em> in <code><a href="lavaan.html#topic+fitMeasures">fitMeasures</a></code>).</p>
</td></tr>
<tr><td><code id="blavFitIndices_+3A_fit.measures">fit.measures</code></td>
<td>
<p>If <code>"all"</code>, all fit measures available will be
returned. If only a single or a few fit measures are specified by name,
only those are computed and returned. If <code>rescale = "devM"</code> or
<code>"PPMC"</code>, the currently available indices are <code>"BRMSEA"</code>,
<code>"BGammaHat"</code>, <code>"adjBGammaHat"</code>, <code>"BMc"</code>, <code>"BCFI"</code>,
<code>"BTLI"</code>, or <code>"BNFI"</code>. If <code>rescale = "MCMC"</code>, the user may
request any indices returned by <code><a href="lavaan.html#topic+fitMeasures">fitMeasures</a></code> for
objects of class <a href="lavaan.html#topic+lavaan-class">lavaan</a>.</p>
</td></tr>
<tr><td><code id="blavFitIndices_+3A_baseline.model">baseline.model</code></td>
<td>
<p>If not <code>NULL</code>, an object of class
<code><a href="#topic+blavaan-class">blavaan</a></code>, representing a user-specified baseline model.
If a <code>baseline.model</code> is provided, incremental fit indices (BCFI,
BTLI, or BNFI) can be requested in <code>fit.measures</code>. Ignored if
<code>rescale = "MCMC"</code>.</p>
</td></tr>
<tr><td><code id="blavFitIndices_+3A_...">...</code></td>
<td>
<p>Additional arguments to the summary method:</p>
</td></tr>
<tr><td><code id="blavFitIndices_+3A_central.tendency">central.tendency</code></td>
<td>
<p>Takes values &quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, indicating which statistics should
be used to characterize the location of the posterior distribution. By
default, all 3 statistics are returned. The posterior mean is labeled
EAP for <em>expected a posteriori</em> estimate, and the mode is
labeled MAP for <em>modal a posteriori</em>
estimate.</p>
</td></tr>
<tr><td><code id="blavFitIndices_+3A_hpd">hpd</code></td>
<td>
<p>A <code>logical</code> indicating whether to calculate the highest
posterior density (HPD) credible interval for each fit
index (defaults to TRUE).</p>
</td></tr>
<tr><td><code id="blavFitIndices_+3A_prob">prob</code></td>
<td>
<p>The &quot;confidence&quot; level of the
credible interval(s) (defaults to 0.9).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class <code>blavFitIndices</code> consisting of 2 slots:
</p>
<table role = "presentation">
<tr><td><code>@details</code></td>
<td>
<p>A <code>list</code> containing the choices made by the user
(or defaults; e.g., which values of <code>pD</code> and <code>rescale</code> were set),
as well as the posterior distribution of the <code class="reqn">\chi^2</code> (deviance)
statistic (rescaled, if <code>rescale = "devM"</code> or <code>"PPMC"</code>).</p>
</td></tr>
<tr><td><code>@indices</code></td>
<td>
<p>A <code>list</code> containing the posterior distribution
of each requested <code>fit.measure</code>.</p>
</td></tr>
</table>
<p>The <code>summary()</code> method returns a <code>data.frame</code> containing one row
for each requested <code>fit.measure</code>, and columns containing the specified
measure(s) of <code>central.tendency</code>, the posterior <em>SD</em>,
and (if requested) the HPD credible-interval limits.
</p>


<h3>Author(s)</h3>

<p>Mauricio Garnier-Villareal (Vrije Universiteit Amsterdam;
<a href="mailto:mgv@pm.me">mgv@pm.me</a>)
</p>
<p>Terrence D. Jorgensen (University of Amsterdam; <a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>References</h3>

<p><code>rescale = "PPMC"</code> based on:
</p>
<p>Hoofs, H., van de Schoot, R., Jansen, N. W., &amp; Kant, I. (2017).
Evaluating model fit in Bayesian confirmatory factor analysis with large
samples: Simulation study introducing the BRMSEA.
<em>Educational and Psychological Measurement</em>. doi:10.1177/0013164417709314
</p>
<p><code>rescale = "devM"</code> based on:
</p>
<p>Garnier-Villarreal, M., &amp; Jorgensen, T. D. (2020). 
Adapting Fit Indices for Bayesian Structural Equation Modeling: Comparison to Maximum Likelihood. 
<em>Psychological Methods</em>, 25(1), 46&ndash;70. https://doi.org/dx.doi.org/10.1037/met0000224
(See also <a href="https://osf.io/afkcw/">https://osf.io/afkcw/</a>)
</p>
<p>Other references:
</p>
<p>Vehtari, A., Gelman, A., &amp; Gabry, J. (2017). Practical Bayesian model
evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing, 27</em>(5), 1413&ndash;1432.
doi:10.1007/s11222-016-9696-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
data(HolzingerSwineford1939, package = "lavaan")

HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '
## fit target model
fit1 &lt;- bcfa(HS.model, data = HolzingerSwineford1939, 
             n.chains = 2, burnin = 1000, sample = 1000)

## fit null model to calculate CFI, TLI, and NFI
null.model &lt;- c(paste0("x", 1:9, " ~~ x", 1:9), paste0("x", 1:9, " ~ 1"))
fit0 &lt;- bcfa(null.model, data = HolzingerSwineford1939, 
             n.chains = 2, burnin = 1000, sample = 1000)

## calculate posterior distributions of fit indices

## The default method mimics fit indices derived from ML estimation
ML &lt;- blavFitIndices(fit1, baseline.model = fit0)
ML
summary(ML)

## other options:

## - use Hoofs et al.'s (2017) PPMC-based method
## - use the estimated number of parameters from WAIC instead of LOO-IC
PPMC &lt;- blavFitIndices(fit1, baseline.model = fit0,
                       pD = "waic", rescale = "PPMC")
## issues a warning about using rescale="PPMC" with N &lt; 1000 (see Hoofs et al.)

## - specify only the desired measures of central tendency
## - specify a different "confidence" level for the credible intervals
summary(PPMC, central.tendency = c("mean","mode"), prob = .95)



## Access the posterior distributions for further investigation
head(distML &lt;- data.frame(ML@indices))

## For example, diagnostic plots using the bayesplot package:

## distinguish chains
nChains &lt;- blavInspect(fit1, "n.chains")
distML$Chain &lt;- rep(1:nChains, each = nrow(distML) / nChains)

library(bayesplot)
mcmc_pairs(distML, pars = c("BRMSEA","BMc","BGammaHat","BCFI","BTLI"),
           diag_fun = "hist")
## Indices are highly correlated across iterations in both chains

## Compare to PPMC method
distPPMC &lt;- data.frame(PPMC@indices)
distPPMC$Chain &lt;- rep(1:nChains, each = nrow(distPPMC) / nChains)
mcmc_pairs(distPPMC, pars = c("BRMSEA","BMc","BGammaHat","BCFI","BTLI"),
           diag_fun = "dens")
## nonlinear relation between BRMSEA, related to the floor effect of BRMSEA
## that Hoofs et al. found for larger (12-indicator) models


## End(Not run)</code></pre>

<hr>
<h2 id='blavInspect'>Inspect or Extract Information from a Fitted blavaan Object</h2><span id='topic+blavInspect'></span><span id='topic+blavTech'></span>

<h3>Description</h3>

<p>The <code>blavInspect()</code> and <code>blavTech()</code> functions can be used to
inspect/extract information that is stored inside (or can be computed from) a
fitted blavaan object. This is similar to lavaan's <code>lavInspect()</code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>blavInspect(blavobject, what, ...)

blavTech(blavobject, what, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blavInspect_+3A_blavobject">blavobject</code></td>
<td>
<p>An object of class blavaan.</p>
</td></tr>
<tr><td><code id="blavInspect_+3A_what">what</code></td>
<td>
<p>Character. What needs to be inspected/extracted? See Details for Bayes-specific options, and see <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>'s <code>lavInspect()</code> for additional options. Note: the <code>what</code> argument is not case-sensitive (everything is converted to lower case.)</p>
</td></tr>
<tr><td><code id="blavInspect_+3A_...">...</code></td>
<td>
<p>lavaan arguments supplied to <code>lavInspect()</code>; see <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below is a list of Bayesian-specific values for the <code>what</code>
argument; additional values can be found in the <code>lavInspect()</code>
documentation.
</p>

<dl>
<dt><code>"start"</code>:</dt><dd><p>A list of starting values for each chain, unless <code>inits="jags"</code> is used during model estimation. Aliases: <code>"starting.values"</code>, <code>"inits"</code>.</p>
</dd>
<dt><code>"rhat"</code>:</dt><dd><p>Each parameter's potential scale reduction
factor for convergence assessment. Can also use &quot;psrf&quot; instead of &quot;rhat&quot;</p>
</dd>
<dt><code>"ac.10"</code>:</dt><dd><p>Each parameter's estimated lag-10 autocorrelation.</p>
</dd>
<dt><code>"neff"</code>:</dt><dd><p>Each parameters effective sample size, taking into account autocorrelation.</p>
</dd>
<dt><code>"mcmc"</code>:</dt><dd><p>An object of class <code>mcmc</code> containing the individual parameter draws from the MCMC run. Aliases: <code>"draws"</code>, <code>"samples"</code>.</p>
</dd>
<dt><code>"mcobj"</code>:</dt><dd><p>The underlying run.jags or stan object that resulted from the MCMC run.</p>
</dd>
<dt><code>"n.chains"</code>:</dt><dd><p>The number of chains sampled.</p>
</dd>
<dt><code>"cp"</code>:</dt><dd><p>The approach used for estimating covariance
parameters (<code>"srs"</code> or <code>"fa"</code>); these are only relevant if
using JAGS.</p>
</dd>
<dt><code>"dp"</code>:</dt><dd><p>Default prior distributions used for each type of model parameter.</p>
</dd>
<dt><code>"postmode"</code>:</dt><dd><p>Estimated posterior mode of each free parameter.</p>
</dd>
<dt><code>"postmean"</code>:</dt><dd><p>Estimated posterior mean of each free parameter.</p>
</dd>
<dt><code>"postmedian"</code>:</dt><dd><p>Estimated posterior median of each free parameter.</p>
</dd>
<dt><code>"lvs"</code>:</dt><dd><p>An object of class <code>mcmc</code> containing latent variable (factor score) draws. In two-level models, use <code>level = 1</code> or <code>level = 2</code> to specify which factor scores you want.</p>
</dd>
<dt><code>"lvmeans"</code>:</dt><dd><p>A matrix of mean factor scores (rows are observations, columns are variables). Use the additional <code>level</code> argument in the same way.</p>
</dd>
<dt><code>"hpd"</code>:</dt><dd><p>HPD interval of each free parameter. In this case, the <code>prob</code> argument can be used to specify a number in (0,1) reflecting the desired percentage of the interval.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="lavaan.html#topic+lavInspect">lavInspect</a></code>, <code><a href="#topic+bcfa">bcfa</a></code>, <code><a href="#topic+bsem">bsem</a></code>, <code><a href="#topic+bgrowth">bgrowth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The Holzinger and Swineford (1939) example
data(HolzingerSwineford1939, package = "lavaan")

HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- bcfa(HS.model, data = HolzingerSwineford1939,
            bcontrol = list(method = "rjparallel"))

# extract information
blavInspect(fit, "psrf")
blavInspect(fit, "hpd", prob = .9)

## End(Not run)
</code></pre>

<hr>
<h2 id='blavPredict'>Predict the values of latent variables, observed variables, and missing variables.</h2><span id='topic+blavPredict'></span><span id='topic+blavpredict'></span>

<h3>Description</h3>

<p>The purpose of the <code>blavPredict()</code> function is to compute various
types of model predictions, conditioned on observed data. This differs
somewhat from <code>lavPredict()</code> in lavaan.</p>


<h3>Usage</h3>

<pre><code class='language-R'>blavPredict(object, newdata = NULL, type = "lv", level = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blavPredict_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+blavaan-class">blavaan</a></code>.</p>
</td></tr>
<tr><td><code id="blavPredict_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame, containing the same variables as
the data.frame used when fitting the model in object.</p>
</td></tr>
<tr><td><code id="blavPredict_+3A_type">type</code></td>
<td>
<p>A character string. If <code>"lv"</code>, estimated values for the latent
variables in the model are computed. If <code>"ov"</code> or <code>"yhat"</code>, predicted means for
the observed variables in the model are computed. If
<code>"ypred"</code> or <code>"ydist"</code>, predicted values for the
observed variables (including residual noise) are computed. If
<code>"ymis"</code> or <code>"ovmis"</code>, model predicted values (&quot;imputations&quot;)
for the missing data are computed. See details for further information.</p>
</td></tr>
<tr><td><code id="blavPredict_+3A_level">level</code></td>
<td>
<p>For <code>type = "lv"</code>, used to specify whether one desires
the level 1 latent variables or level 2 latent variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>predict()</code> function calls the <code>blavPredict()</code> function
with its default options.
</p>
<p>Below, we provide more information about each <code>type</code> option. Most
options only work for target=&quot;stan&quot;, and &quot;number of samples&quot; is defined
as the number of posterior samples across all chains.
</p>
<p><code>type="lv"</code>: The posterior distribution of latent variables
conditioned on observed variables. Returns a list with
&quot;number of samples&quot; entries, where each entry is a matrix where rows 
are observations and columns are latent variables.
</p>
<p><code>type="yhat"</code>: The posterior expected value of observed variables
conditioned on the sampled latent variables. Returns a list with
&quot;number of samples&quot; entries, where each entry is a matrix where rows
are observations and columns are observed variables.
</p>
<p><code>type="ypred"</code>: The posterior predictive distribution of observed
variables conditioned on the sampled latent variables (including
residual variability). Returns a list with &quot;number of samples&quot; entries,
where each entry is a data frame where rows are observations and columns
are observed variables.
</p>
<p><code>type="ymis"</code>: The posterior predictive distribution of missing
values conditioned on observed variables. Returns a matrix with
&quot;number of samples&quot; rows and &quot;number of missing variables&quot; columns.
</p>


<h3>See Also</h3>

<p>Users may also wish to generate the posterior predictive distribution of
observed data, not conditioned on the latent variables. This
would often be viewed as data from new clusters (people) that were not
observed in the original dataset. For that, see <code>sampleData()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HolzingerSwineford1939, package = "lavaan")

## fit model
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- bcfa(HS.model, data = HolzingerSwineford1939, save.lvs = TRUE)
lapply(blavPredict(fit)[1:2], head) # first 6 rows of first 10 posterior samples
head(blavPredict(fit, type = "yhat")[[1]]) # top of first posterior sample

## multigroup models return a list of factor scores (one per group)
mgfit &lt;- bcfa(HS.model, data = HolzingerSwineford1939, group = "school",
              group.equal = c("loadings","intercepts"), save.lvs = TRUE)

lapply(blavPredict(fit)[1:2], head)
head(blavPredict(fit, type = "ypred")[[1]])

## End(Not run)
</code></pre>

<hr>
<h2 id='bsem'>Fit Structural Equation Models</h2><span id='topic+bsem'></span>

<h3>Description</h3>

<p>Fit a Structural Equation Model (SEM).</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsem(..., cp = "srs",
     dp = NULL, n.chains = 3, burnin, sample,
     adapt, mcmcfile = FALSE, mcmcextra = list(), inits = "simple",
     convergence = "manual", target = "stan", save.lvs = FALSE,
     wiggle = NULL, wiggle.sd = 0.1, prisamp = FALSE, jags.ic = FALSE,
     seed = NULL, bcontrol = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsem_+3A_...">...</code></td>
<td>
<p>Default lavaan arguments.  See <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="bsem_+3A_cp">cp</code></td>
<td>
<p>Handling of prior distributions on covariance parameters:
possible values are <code>"srs"</code> (default) or <code>"fa"</code>. Option <code>"fa"</code> is only available for <code>target="jags"</code>.</p>
</td></tr>
<tr><td><code id="bsem_+3A_dp">dp</code></td>
<td>
<p>Default prior distributions on different types of
parameters, typically the result of a call to <code>dpriors()</code>.
See the <code>dpriors()</code> help file for more information.</p>
</td></tr>
<tr><td><code id="bsem_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of desired MCMC chains.</p>
</td></tr>
<tr><td><code id="bsem_+3A_burnin">burnin</code></td>
<td>
<p>Number of burnin/warmup iterations (not including the adaptive
iterations, for target=&quot;jags&quot;). Defaults to 4000 or target=&quot;jags&quot; and
500 for Stan targets.</p>
</td></tr>
<tr><td><code id="bsem_+3A_sample">sample</code></td>
<td>
<p>The total number of samples to take after burnin. Defaults
to 10000 for target=&quot;jags&quot; and 1000 for Stan targets.</p>
</td></tr>
<tr><td><code id="bsem_+3A_adapt">adapt</code></td>
<td>
<p>For target=&quot;jags&quot;, the number of adaptive iterations to use at the start of
sampling. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="bsem_+3A_mcmcfile">mcmcfile</code></td>
<td>
<p>If <code>TRUE</code>, the JAGS/Stan model will be written to file
(in the lavExport directory). Can also supply a character
string, which serves as the name of the directory to which files will be written.</p>
</td></tr>
<tr><td><code id="bsem_+3A_mcmcextra">mcmcextra</code></td>
<td>
<p>A list with potential names <code>syntax</code> (unavailable
for target=<code>"stan"</code>),
<code>monitor</code>, <code>data</code>, and <code>llnsamp</code>. The <code>syntax</code> object is a text string containing extra
code to insert in the JAGS/Stan model syntax. The <code>data</code> object
is a list of extra data to send to the JAGS/Stan model. If 
<code>moment_match_k_threshold</code> is specified within <code>data</code> the looic of 
the model will be calculated using moment matching. The <code>monitor</code> object
is a character vector containing extra JAGS/Stan parameters to
monitor. The <code>llnsamp</code> object is only relevant to models with ordinal
variables, and specifies the number of samples that should be drawn to approximate
the model log-likelihood (larger numbers imply higher accuracy and
longer time). This log-likelihood is specifically used to compute
information criteria.</p>
</td></tr>
<tr><td><code id="bsem_+3A_inits">inits</code></td>
<td>
<p>If it is a character string, the options are currently
<code>"simple"</code> (default), <code>"Mplus"</code>, <code>"prior"</code>, or <code>"jags"</code>.  In the first two
cases, parameter values are set as though they will be estimated via
ML (see <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>).  The starting parameter value for
each chain is then perturbed from the original values through the
addition of random uniform noise.  If <code>"prior"</code> is used, the starting
parameter values are obtained based on the prior distributions
(while also trying to ensure that the starting values will not crash
the model estimation).  If <code>"jags"</code>, no starting values are
specified and JAGS will choose values on its own (and this will probably
crash Stan targets). You can also supply
a list of starting values for each chain, where the list format can
be obtained from, e.g., <code>blavInspect(fit, "inits")</code>. Finally,
you can specify starting values in a similar way to lavaan,
using the lavaan <code>start</code> argument (see the lavaan
documentation for all the options there). In this case, you should also set
<code>inits="simple"</code>, and be aware that the same starting values
will be used for each chain.</p>
</td></tr>
<tr><td><code id="bsem_+3A_convergence">convergence</code></td>
<td>
<p>Useful only for <code>target="jags"</code>. If <code>"auto"</code>, parameters are
sampled until convergence is achieved (via <code>autorun.jags()</code>). In
this case, the arguments <code>burnin</code> and <code>sample</code> are passed to
<code>autorun.jags()</code> as <code>startburnin</code> and <code>startsample</code>,
respectively. Otherwise, parameters
are sampled as specified by the user (or by the <code>run.jags</code>
defaults).</p>
</td></tr>
<tr><td><code id="bsem_+3A_target">target</code></td>
<td>
<p>Desired MCMC sampling, with <code>"stan"</code> (pre-compiled
marginal approach) as
default. Also available is <code>"vb"</code>, which calls the rstan function
<code>vb()</code>. Other options include <code>"jags"</code>, <code>"stancond"</code>, and
<code>"stanclassic"</code>, which sample latent variables and provide some
greater functionality (because syntax is written &quot;on the fly&quot;). But
they are slower and less efficient.</p>
</td></tr>
<tr><td><code id="bsem_+3A_save.lvs">save.lvs</code></td>
<td>
<p>Should sampled latent variables (factor scores) be saved? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="bsem_+3A_wiggle">wiggle</code></td>
<td>
<p>Labels of equality-constrained parameters that should be
&quot;approximately&quot; equal. Can also be &quot;intercepts&quot;, &quot;loadings&quot;,
&quot;regressions&quot;, &quot;means&quot;.</p>
</td></tr>
<tr><td><code id="bsem_+3A_wiggle.sd">wiggle.sd</code></td>
<td>
<p>The prior sd (of normal distribution) to be used in approximate equality
constraints. Can be one value, or (for target=&quot;stan&quot;) a numeric vector
of values that is the same length as wiggle.</p>
</td></tr>
<tr><td><code id="bsem_+3A_prisamp">prisamp</code></td>
<td>
<p>Should samples be drawn from the prior, instead of the
posterior (<code>target="stan"</code> only)? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="bsem_+3A_jags.ic">jags.ic</code></td>
<td>
<p>Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE</p>
</td></tr>
<tr><td><code id="bsem_+3A_seed">seed</code></td>
<td>
<p>A vector of length <code>n.chains</code> (for target
<code>"jags"</code>) or an integer (for target <code>"stan"</code>) containing random
seeds for the MCMC run. If <code>NULL</code>, seeds will be chosen randomly.</p>
</td></tr>
<tr><td><code id="bsem_+3A_bcontrol">bcontrol</code></td>
<td>
<p>A list containing additional parameters passed to
<code>run.jags</code> (or <code>autorun.jags</code>) or <code>stan</code>.  See the manpage of those functions for an
overview of the additional parameters that can be set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>bsem</code> function is a wrapper for the more general
<code><a href="#topic+blavaan">blavaan</a></code> function, using the following default
<code><a href="lavaan.html#topic+lavaan">lavaan</a></code> arguments:
<code>int.ov.free = TRUE</code>, <code>int.lv.free = FALSE</code>,
<code>auto.fix.first = TRUE</code> (unless <code>std.lv = TRUE</code>),
<code>auto.fix.single = TRUE</code>, <code>auto.var = TRUE</code>,
<code>auto.cov.lv.x = TRUE</code>,
<code>auto.th = TRUE</code>, <code>auto.delta = TRUE</code>,
and <code>auto.cov.y = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <a href="lavaan.html#topic+lavaan-class">lavaan</a>, for which several methods
are available, including a <code>summary</code> method.
</p>


<h3>References</h3>

<p>Edgar C. Merkle, Ellen Fitzsimmons, James Uanhoro, &amp; Ben Goodrich (2021). Efficient Bayesian Structural Equation Modeling in Stan. Journal of Statistical
Software, 100(6), 1-22. URL http://www.jstatsoft.org/v100/i06/.
</p>
<p>Edgar C. Merkle &amp; Yves Rosseel (2018). blavaan: Bayesian Structural
Equation Models via Parameter Expansion. Journal of Statistical
Software, 85(4), 1-30. URL http://www.jstatsoft.org/v85/i04/.
</p>
<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. URL
http://www.jstatsoft.org/v48/i02/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blavaan">blavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The industrialization and Political Democracy Example
# Bollen (1989), page 332
data(PoliticalDemocracy, package = "lavaan")

model &lt;- '
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a*y2 + b*y3 + c*y4
     dem65 =~ y5 + a*y6 + b*y7 + c*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

## Not run: 
# mildly informative priors for mv intercepts and loadings
fit &lt;- bsem(model, data = PoliticalDemocracy,
            dp = dpriors(nu = "normal(5,10)", lambda = "normal(1,.5)"))
summary(fit)

## End(Not run)

# A short run for rough results
fit &lt;- bsem(model, data = PoliticalDemocracy, burnin = 100, sample = 100,
            dp = dpriors(nu = "normal(5,10)", lambda = "normal(1,.5)"),
            n.chains = 2)
summary(fit)
</code></pre>

<hr>
<h2 id='dpriors'>Specify Default Prior Distributions</h2><span id='topic+dpriors'></span>

<h3>Description</h3>

<p>Specify &quot;default&quot; prior distributions for classes of model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpriors(..., target = "stan")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpriors_+3A_...">...</code></td>
<td>
<p>Parameter names paired with desired priors (see example
below).</p>
</td></tr>
<tr><td><code id="dpriors_+3A_target">target</code></td>
<td>
<p>Are the priors for jags, stan (default), or stanclassic?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior distributions always use JAGS/Stan syntax and parameterizations. For
example, the normal distribution in JAGS is parameterized via the
precision, whereas the normal distribution in Stan is parameterized
via the standard deviation.
</p>
<p>User-specified prior distributions for specific parameters
(using the <code>prior()</code> operator within the model syntax) always
override prior distributions set using <code>dpriors()</code>.
</p>
<p>The parameter names are:
</p>

<ul>
<li><p>nu: Observed variable intercept parameters.
</p>
</li>
<li><p>alpha: Latent variable intercept parameters.
</p>
</li>
<li><p>lambda: Loading parameters.
</p>
</li>
<li><p>beta: Regression parameters.
</p>
</li>
<li><p>itheta: Observed variable precision parameters.
</p>
</li>
<li><p>ipsi: Latent variable precision parameters.
</p>
</li>
<li><p>rho: Correlation parameters (associated with covariance parameters).
</p>
</li>
<li><p>ibpsi: Inverse covariance matrix of
blocks of latent variables (used for <code>target="jags"</code>).
</p>
</li>
<li><p>tau: Threshold parameters (ordinal data only).
</p>
</li>
<li><p>delta: Delta parameters (ordinal data only).
</p>
</li></ul>



<h3>Value</h3>

<p>A character vector containing the prior distribution for each type of parameter.
</p>


<h3>References</h3>

<p>Edgar C. Merkle, Ellen Fitzsimmons, James Uanhoro, &amp; Ben Goodrich (2021). Efficient Bayesian Structural Equation Modeling in Stan. Journal of Statistical
Software, 100(6), 1-22. URL http://www.jstatsoft.org/v100/i06/.
</p>
<p>Edgar C. Merkle &amp; Yves Rosseel (2018). blavaan: Bayesian Structural
Equation Models via Parameter Expansion. Journal of Statistical
Software, 85(4), 1-30. URL http://www.jstatsoft.org/v85/i04/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bcfa">bcfa</a></code>, <code><a href="#topic+bsem">bsem</a></code>, <code><a href="#topic+bgrowth">bgrowth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dpriors(nu = "normal(0,10)", lambda = "normal(0,1)", rho = "beta(3,3)")
</code></pre>

<hr>
<h2 id='plot.blavaan'>blavaan Diagnostic Plots</h2><span id='topic+plot.blavaan'></span>

<h3>Description</h3>

<p>Convenience functions to create plots of blavaan objects, via the
bayesplot package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blavaan'
plot(x, pars = NULL, plot.type = "trace", showplot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.blavaan_+3A_x">x</code></td>
<td>
<p>An object of class <code>blavaan</code>.</p>
</td></tr>
<tr><td><code id="plot.blavaan_+3A_pars">pars</code></td>
<td>
<p>Parameter numbers to plot, where the numbers correspond to the order of parameters as reported by <code>coef()</code> (also as shown in the 'free' column of the parTable). If no numbers are provided, all free parameters will be plotted.</p>
</td></tr>
<tr><td><code id="plot.blavaan_+3A_plot.type">plot.type</code></td>
<td>
<p>The type of plot desired. This should be the name of a <code><a href="bayesplot.html#topic+MCMC-overview">MCMC</a></code> function, without the <code>mcmc_</code> prefix.</p>
</td></tr>
<tr><td><code id="plot.blavaan_+3A_showplot">showplot</code></td>
<td>
<p>Should the plot be sent to the graphic device? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.blavaan_+3A_...">...</code></td>
<td>
<p>Other arguments sent to the bayesplot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In previous versions of blavaan, the plotting functionality was
handled separately for JAGS and for Stan (using plot functionality in
packages runjags and rstan, respectively). For uniformity, all
plotting functionality is now handled by bayesplot. If users desire
additional functionality that is not immediately available, they can extract the matrix of MCMC draws via <code>as.matrix(blavInspect(x, 'mcmc'))</code>.
</p>


<h3>Value</h3>

<p>An invisible ggplot object that, if desired, can be further customized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HolzingerSwineford1939, package = "lavaan")

HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- bcfa(HS.model, data = HolzingerSwineford1939)

# trace plots of free loadings
plot(fit, pars = 1:6)

## End(Not run)
</code></pre>

<hr>
<h2 id='ppmc'>Posterior Predictive Model Checks</h2><span id='topic+ppmc'></span><span id='topic+blavPPMC-class'></span><span id='topic+show+2CblavPPMC-method'></span><span id='topic+summary+2CblavPPMC-method'></span><span id='topic+summary.ppmc'></span><span id='topic+plot.blavPPMC'></span><span id='topic+hist.blavPPMC'></span><span id='topic+pairs.blavPPMC'></span>

<h3>Description</h3>

<p>This function allows users to conduct a posterior predictive model check to
assess the global or local fit of a latent variable model using any discrepancy
function that can be applied to a <a href="lavaan.html#topic+lavaan-class">lavaan</a> model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppmc(object, thin = 1, fit.measures = c("srmr","chisq"), discFUN = NULL,
     conditional = FALSE)

## S4 method for signature 'blavPPMC'
summary(object, ...)

## S3 method for class 'ppmc'
summary(object, discFUN, dist = c("obs","sim"),
        central.tendency = c("mean","median","mode"),
        hpd = TRUE, prob = .95, to.data.frame = FALSE, diag = TRUE,
        sort.by = NULL, decreasing = FALSE)

## S3 method for class 'blavPPMC'
plot(x, ..., discFUN, element, central.tendency = "",
     hpd = TRUE, prob = .95, nd = 3)

## S3 method for class 'blavPPMC'
hist(x, ..., discFUN, element, hpd = TRUE, prob = .95,
     printLegend = TRUE, legendArgs = list(x = "topleft"),
     densityArgs = list(), nd = 3)

## S3 method for class 'blavPPMC'
pairs(x, discFUN, horInd = 1:DIM, verInd = 1:DIM,
      printLegend = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppmc_+3A_object">object</code>, <code id="ppmc_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+blavaan-class">blavaan</a></code>.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_thin">thin</code></td>
<td>
<p>Optional <code>integer</code> indicating how much to thin each chain.
Default is <code>1L</code>, indicating not to thin the chains in <code>object</code>.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_fit.measures">fit.measures</code></td>
<td>
<p><code>character</code> vector indicating the names of global
discrepancy measures returned by <code><a href="lavaan.html#topic+fitMeasures">fitMeasures</a></code>. Ignored
unless <code>discFUN</code> is <code>NULL</code>, but users may include
<code>fitMeasures</code> in the <code>list</code> of discrepancy functions in
<code>discFUN</code>. For ordinal models, the <code>"logl"</code> or <code>"chisq"</code>
computations are done via lavaan.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_discfun">discFUN</code></td>
<td>
<p><code>function</code>, or a <code>list</code> of functions, that can be
called on an object of class <a href="lavaan.html#topic+lavaan-class">lavaan</a>. Each function
must return an object whose <code><a href="base.html#topic+mode">mode</a></code> is <code>numeric</code>, but may
be a <code>vector</code>, <code>matrix</code>, or multidimensional <code>array</code>. In
the <code>summary</code> and <code>plot</code> methods, <code>discFUN</code> is a
<code>character</code> indicating which discrepancy function to
summarize.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_conditional">conditional</code></td>
<td>
<p><code>logical</code> indicating whether or not, during artificial data
generation, we should condition on the estimated latent
variables. Requires the model to be estimated with <code>save.lvs = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_element">element</code></td>
<td>
<p><code>numeric</code> or <code>character</code> indicating the index (in
each <code>dim</code>ension of the <code>discFUN</code> output, if multiple) to plot.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_horind">horInd</code>, <code id="ppmc_+3A_verind">verInd</code></td>
<td>
<p>Similar to <code>element</code>, but a <code>numeric</code> or
<code>character</code> vector indicating the indices of a <code>matrix</code> to plot
in a scatterplot matrix. If <code>horInd==verInd</code>, histograms will be
plotted in the upper triangle.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_dist">dist</code></td>
<td>
<p><code>character</code> indicating whether to summarize the distribution
of <code>discFUN</code> on either the <code>obs</code>erved or <code>sim</code>ulated data.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_central.tendency">central.tendency</code></td>
<td>
<p><code>character</code> indicating which statistics should
be used to characterize the location of the posterior (predictive)
distribution. By default, all 3 statistics are returned for the
<code>summary</code> method, but none for the <code>plot</code> method. The posterior
mean is labeled <code>EAP</code> for <em>expected a posteriori</em> estimate, and
the mode is labeled <code>MAP</code> for <em>modal a posteriori</em> estimate.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_hpd">hpd</code></td>
<td>
<p><code>logical</code> indicating whether to calculate the highest
posterior density (HPD) credible interval for <code>discFUN</code>.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_prob">prob</code></td>
<td>
<p>The &quot;confidence&quot; level of the credible interval(s).</p>
</td></tr>
<tr><td><code id="ppmc_+3A_nd">nd</code></td>
<td>
<p>The number of digits to print in the scatter<code>plot</code>.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_to.data.frame">to.data.frame</code></td>
<td>
<p><code>logical</code> indicating whether the <code>summary</code> of a
symmetric 2-dimensional <code>matrix</code> returned by <code>discFUN</code> should have
its unique elements stored in rows of a <code>data.frame</code> that can be sorted
for convenience of identifying large discrepancies. If <code>discFUN</code>
returns an asymmetric 2-dimensional <code>matrix</code>, the list of matrices
returned by the <code>summary</code> can also be converted to a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_diag">diag</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+lower.tri">lower.tri</a></code> if <code>to.data.frame=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_sort.by">sort.by</code></td>
<td>
<p><code>character</code>. If <code>summary</code> returns a <code>data.frame</code>,
it can be sorted by this column name using <code><a href="base.html#topic+order">order</a></code>. Note
that if <code>discFUN</code> returns an asymmetric 2-dimensional <code>matrix</code>,
each <code>data.frame</code> in the returned <code>list</code> will be sorted
independently, so the rows are unlikely to be consistent across
summary statistics.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_decreasing">decreasing</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+order">order</a></code> if
<code>!is.null(sort.by)</code>.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_...">...</code></td>
<td>
<p>Additional <code>graphical <a href="graphics.html#topic+par">par</a>ameters</code> to be
passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_printlegend">printLegend</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), a legend will
be printed with the histogram</p>
</td></tr>
<tr><td><code id="ppmc_+3A_legendargs">legendArgs</code></td>
<td>
<p><code>list</code> of arguments passed to the
<code><a href="graphics.html#topic+legend">legend</a></code> function.  The default argument is a list
placing the legend at the top-left of the figure.</p>
</td></tr>
<tr><td><code id="ppmc_+3A_densityargs">densityArgs</code></td>
<td>
<p><code>list</code> of arguments passed to the
<code><a href="stats.html#topic+density">density</a></code> function, used to obtain densities for the
<code>hist</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class <code>blavPPMC</code> consisting of 5 <code>list</code> slots:
</p>
<table role = "presentation">
<tr><td><code>@discFUN</code></td>
<td>
<p>The user-supplied <code>discFUN</code>, or the <code>call</code> to
<code><a href="lavaan.html#topic+fitMeasures">fitMeasures</a></code> that returns <code>fit.measures</code>.</p>
</td></tr>
<tr><td><code>@dims</code></td>
<td>
<p>The dimensions of the object returned by each
<code>discFUN</code>.</p>
</td></tr>
<tr><td><code>@PPP</code></td>
<td>
<p>The posterior predictive <em>p</em> value for each
<code>discFUN</code> element.</p>
</td></tr>
<tr><td><code>@obsDist</code></td>
<td>
<p>The posterior distribution of realize values of
<code>discFUN</code> applied to observed data.</p>
</td></tr>
<tr><td><code>@simDist</code></td>
<td>
<p>The posterior predictive distribution of values of
<code>discFUN</code> applied to data simulated from the posterior samples.</p>
</td></tr>
</table>
<p>The <code>summary()</code> method returns a <code>numeric</code> vector if <code>discFUN</code>
returns a scalar, a <code>data.frame</code> with one discrepancy function per row
if <code>discFUN</code> returns a <code>numeric</code> vector, and a <code>list</code> with
one summary statistic per element if <code>discFUN</code> returns a <code>matrix</code>
or multidimensional <code>array</code>.
</p>
<p>The <code>plot</code> and <code>pairs</code> methods invisibly return <code>NULL</code>,
printing a plot (or scatterplot matrix) to the current device.
</p>
<p>The <code>hist</code> method invisibly returns a <code>list</code> or arguments that can
be passed to the function for which the <code>list</code> element is named.  Users
can edit the arguments in the list to customize their histograms.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam; <a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>References</h3>

<p>Levy, R. (2011). Bayesian data&ndash;model fit assessment for structural equation
modeling. <em>Structural Equation Modeling, 18</em>(4), 663&ndash;685.
doi:10.1080/10705511.2011.607723
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
data(HolzingerSwineford1939, package = "lavaan")

HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '
## fit single-group model
fit &lt;- bcfa(HS.model, data = HolzingerSwineford1939, 
            n.chains = 2, burnin = 1000, sample = 500)
## fit multigroup model
fitg &lt;- bcfa(HS.model, data = HolzingerSwineford1939,
             n.chains = 2, burnin = 1000, sample = 500, group = "school")


## Use fit.measures as a shortcut for global fitMeasures only
## - Note that indices calculated from the "df" are only appropriate under
##   noninformative priors, such that pD approximates the number of estimated
##   parameters counted under ML estimation; incremental fit indices
##   introduce further complications)

AFIs &lt;- ppmc(fit, thin = 10, fit.measures = c("srmr","chisq","rmsea","cfi"))
summary(AFIs)                 # summarize the whole vector in a data.frame
hist(AFIs, element = "rmsea") # only plot one discrepancy function at a time
plot(AFIs, element = "srmr")


## define a list of custom discrepancy functions
## - (global) fit measures
## - (local) standardized residuals

discFUN &lt;- list(global = function(fit) {
                  fitMeasures(fit, fit.measures = c("cfi","rmsea","srmr","chisq"))
                },
                std.cov.resid = function(fit) lavResiduals(fit, zstat = FALSE,
                                                           summary = FALSE)$cov,
                std.mean.resid = function(fit) lavResiduals(fit, zstat = FALSE,
                                                            summary = FALSE)$mean)
out1g &lt;- ppmc(fit, discFUN = discFUN)

## summarize first discrepancy by default (fit indices)
summary(out1g)
## some model-implied correlations look systematically over/underestimated
summary(out1g, discFUN = "std.cov.resid", central.tendency = "EAP")
hist(out1g, discFUN = "std.cov.resid", element = c(1, 7))
plot(out1g, discFUN = "std.cov.resid", element = c("x1","x7"))
## For ease of investigation, optionally export summary as a data.frame,
## sorted by size of average residual
summary(out1g, discFUN = "std.cov.resid", central.tendency = "EAP",
        to.data.frame = TRUE, sort.by = "EAP")
## or sorted by size of PPP
summary(out1g, discFUN = "std.cov.resid", central.tendency = "EAP",
        to.data.frame = TRUE, sort.by = "PPP_sim_LessThan_obs")

## define a list of custom discrepancy functions for multiple groups
## (return each group's numeric output using a different function)

disc2g &lt;- list(global = function(fit) {
                 fitMeasures(fit, fit.measures = c("cfi","rmsea","mfi","srmr","chisq"))
               },
               cor.resid1 = function(fit) lavResiduals(fit, zstat = FALSE,
                                                       type = "cor.bollen",
                                                       summary = FALSE)[[1]]$cov,
               cor.resid2 = function(fit) lavResiduals(fit, zstat = FALSE,
                                                       type = "cor.bollen",
                                                       summary = FALSE)[[2]]$cov)
out2g &lt;- ppmc(fitg, discFUN = disc2g, thin = 2)
## some residuals look like a bigger problem in one group than another
pairs(out2g, discFUN = "cor.resid1", horInd = 1:3, verInd = 7:9) # group 1
pairs(out2g, discFUN = "cor.resid2", horInd = 1:3, verInd = 7:9) # group 2

## print all to file: must be a LARGE picture. First group 1 ...
png("cor.resid1.png", width = 1600, height = 1200)
pairs(out2g, discFUN = "cor.resid1")
dev.off()
## ... then group 2
png("cor.resid2.png", width = 1600, height = 1200)
pairs(out2g, discFUN = "cor.resid2")
dev.off()

## End(Not run)</code></pre>

<hr>
<h2 id='sampleData'>Sample data from the posterior (or prior) distribution.</h2><span id='topic+sampleData'></span><span id='topic+sampledata'></span>

<h3>Description</h3>

<p>The purpose of the <code>sampleData()</code> function is to simulate new data
from a model that has already been estimated. This can faciliate
posterior predictive checks, as well as prior predictive checks (setting
prisamp = TRUE during model estimation).</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleData(object, nrep = NULL, conditional = FALSE, type = "response",
           simplify = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleData_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+blavaan-class">blavaan</a></code>.</p>
</td></tr>
<tr><td><code id="sampleData_+3A_nrep">nrep</code></td>
<td>
<p>How many datasets to generate? If not supplied, defaults to
the total number of posterior samples.</p>
</td></tr>
<tr><td><code id="sampleData_+3A_conditional">conditional</code></td>
<td>
<p>Logical indicating whether to sample from the
distribution that is marginal over latent variables (<code>FALSE</code>;
default) or from the distribution that conditions on latent variables
(<code>TRUE</code>). For <code>TRUE</code>, you must set <code>save.lvs = TRUE</code>
during model estimation.</p>
</td></tr>
<tr><td><code id="sampleData_+3A_type">type</code></td>
<td>
<p>The type of data desired (only relevant to ordinal
data). The <code>type = "response"</code> option generates ordinal data. The
<code>type = "link"</code> option generates continuous variables underlying
ordinal data (which would be cut by thresholds to yield ordinal data).</p>
</td></tr>
<tr><td><code id="sampleData_+3A_simplify">simplify</code></td>
<td>
<p>For single-group models, should the list structure be
simplified? This makes each dataset a single list entry, instead of a
list within a list (which reflects group 1 of dataset 1). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sampleData_+3A_...">...</code></td>
<td>
<p>Other arguments, which for now is only <code>parallel</code>. Parallelization via <code>future_lapply()</code> is available by setting <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function to generate data for posterior or prior
predictive checking. The underlying code is also used to generate data
for posterior predictive p-value computation.
</p>


<h3>See Also</h3>

<p>This function overlaps with <code>blavPredict()</code>. The
<code>blavPredict()</code> function is more focused on generating pieces of
data conditioned on other pieces of observed data (i.e., latent
variables conditioned on observed variables; missing variables
conditioned on observed variables). In contrast, the <code>sampleData()</code>
function is more focused on generating new data given the sampled model parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HolzingerSwineford1939, package = "lavaan")

## fit model
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- bcfa(HS.model, data = HolzingerSwineford1939)

## 1 dataset generated from the posterior
out &lt;- sampleData(fit, nrep = 1)

## nested lists: 1 list entry per nrep.
## then, within a rep, 1 list entry per group
## so our dataset is here:
dim(out[[1]][[1]])

## 1 posterior dataset per posterior sample:
out &lt;- sampleData(fit)

## obtain the data on x1 across reps and summarize:
x1dat &lt;- sapply(out, function(x) x[[1]][,1])
summary( as.numeric(x1dat) )

## End(Not run)
</code></pre>

<hr>
<h2 id='standardizedPosterior'>Standardized Posterior</h2><span id='topic+standardizedPosterior'></span><span id='topic+standardizedposterior'></span>

<h3>Description</h3>

<p>Standardized posterior distribution of a latent variable model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizedPosterior(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardizedPosterior_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+blavaan-class">blavaan</a></code>.</p>
</td></tr>
<tr><td><code id="standardizedPosterior_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lavaan's
<code>standardizedSolution()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing standardized posterior draws, where rows are draws
and columns are parameters.
</p>


<h3>Note</h3>

<p>The only allowed <code>standardizedSolution()</code> arguments are type,
cov.std, remove.eq, remove.ineq, and remove.def. Other arguments are not
immediately suited to posterior distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(PoliticalDemocracy, package = "lavaan")

model &lt;- ' 
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a*y2 + b*y3 + c*y4
     dem65 =~ y5 + a*y6 + b*y7 + c*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

fit &lt;- bsem(model, data = PoliticalDemocracy,
            dp = dpriors(nu = "normal(5, 10)"))

standardizedPosterior(fit)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
