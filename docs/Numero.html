<!DOCTYPE html><html><head><title>Help for package Numero</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Numero}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nroAggregate'>
<p>Regional averages on a self-organizing map</p></a></li>
<li><a href='#nroColorize'>
<p>Assign colors based on value</p></a></li>
<li><a href='#nroDestratify'><p>Mitigate data stratification</p></a></li>
<li><a href='#nroKmeans'>
<p>K-means clustering</p></a></li>
<li><a href='#nroKohonen'>
<p>Self-organizing map</p></a></li>
<li><a href='#nroLabel'>
<p>Label pruning</p></a></li>
<li><a href='#nroMatch'>
<p>Best-matching districts</p></a></li>
<li><a href='#nroPermute'>
<p>Permutation analysis of map layout</p></a></li>
<li><a href='#nroPlot'><p>Plot a self-organizing map</p></a></li>
<li><a href='#nroPostprocess'><p>Standardization using existing parameters</p></a></li>
<li><a href='#nroPreprocess'>
<p>Data cleaning and standardization</p></a></li>
<li><a href='#nroSummary'>
<p>Estimate subgroup statistics</p></a></li>
<li><a href='#nroTrain'>
<p>Train self-organizing map</p></a></li>
<li><a href='#numero.clean'><p>Clean datasets</p></a></li>
<li><a href='#numero.create'><p>Create a self-organizing map</p></a></li>
<li><a href='#numero.evaluate'><p>Self-organizing map statistics</p></a></li>
<li><a href='#numero.plot'><p>Plot results from SOM analysis</p></a></li>
<li><a href='#numero.prepare'><p>Prepare datasets for analysis</p></a></li>
<li><a href='#numero.quality'><p>Self-organizing map statistics</p></a></li>
<li><a href='#numero.subgroup'><p>Interactive subgroup assignment</p></a></li>
<li><a href='#numero.summary'><p>Summarize subgroup statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Framework to Define Subgroups in Complex Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Song Gao [aut],
  Stefan Mutter [aut],
  Aaron E. Casey [aut],
  Ville-Petteri Makinen [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ville-Petteri Makinen &lt;vpmakine@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>High-dimensional datasets that do not exhibit a clear intrinsic clustered structure pose a challenge to conventional clustering algorithms. For this reason, we developed an unsupervised framework that helps scientists to better subgroup their datasets based on visual cues, please see Gao S, Mutter S, Casey A, Makinen V-P (2019) Numero: a statistical framework to define multivariable subgroups in complex population-based datasets, Int J Epidemiology, 48:369-37, &lt;<a href="https://doi.org/10.1093%2Fije%2Fdyy113">doi:10.1093/ije/dyy113</a>&gt;. The framework includes the necessary functions to construct a self-organizing map of the data, to evaluate the statistical significance of the observed data patterns, and to visualize the results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 18:08:55 UTC; vipmak</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nroAggregate'>
Regional averages on a self-organizing map
</h2><span id='topic+nroAggregate'></span>

<h3>Description</h3>

<p>Estimate district averages based on assigned map locations for each data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroAggregate(topology, districts, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroAggregate_+3A_topology">topology</code></td>
<td>

<p>A data frame with K rows and six columns, see details.  
</p>
</td></tr>
<tr><td><code id="nroAggregate_+3A_districts">districts</code></td>
<td>
 
<p>An integer vector of M best-matching districts.
</p>
</td></tr>
<tr><td><code id="nroAggregate_+3A_data">data</code></td>
<td>

<p>A vector of M elements or an M x N matrix of data values. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Topology can be either the output from <code><a href="#topic+nroKohonen">nroKohonen</a>()</code> or a
data frame in the same format as the element <code>topology</code> within the
the output from <code><a href="#topic+nroKohonen">nroKohonen</a>()</code>.
</p>
<p>The input argument <code>districts</code> is expected to be the output from
<code><a href="#topic+nroMatch">nroMatch</a>()</code>.
</p>


<h3>Value</h3>

<p>If the input argument <code>data</code> is empty, the histogram of the data points
on the map is returned (a vector of K elements).
</p>
<p>If data are available, a matrix of K rows and N columns that contains
the average district values after smoothing is returned. The output includes
the attribute 'histogram' that contains data point counts over each data
column. Column names and the attribute 'binary' are copied from the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars]) 

# K-means clustering.
km &lt;- nroKmeans(data = trdata)

# Self-organizing map.
sm &lt;- nroKohonen(seeds = km)
sm &lt;- nroTrain(map = sm, data = trdata)

# Assign data points into districts.
matches &lt;- nroMatch(centroids = sm, data = trdata)

# District averages for one variable.
chol &lt;- nroAggregate(topology = sm, districts = matches,
                     data = dataset$CHOL)
print(chol)

# District averages for all variables.
planes &lt;- nroAggregate(topology = sm, districts = matches, data = dataset)
print(head(planes))
</code></pre>

<hr>
<h2 id='nroColorize'>
Assign colors based on value
</h2><span id='topic+nroColorize'></span>

<h3>Description</h3>

<p>Assign colors to map districts based on the respective district values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroColorize(values, ranges = NULL, amplitudes = 1, palette = "rhodo")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroColorize_+3A_values">values</code></td>
<td>

<p>A vector of K values or a K x N data frame, where K is the number of map
districts and N is the number of variables.
</p>
</td></tr>
<tr><td><code id="nroColorize_+3A_ranges">ranges</code></td>
<td>

<p>A data frame with N rows and 2 columns, see details.
</p>
</td></tr>
<tr><td><code id="nroColorize_+3A_amplitudes">amplitudes</code></td>
<td>

<p>Single value or a vector of N elements or a data frame of N rows that
contains the column AMPLITUDE.
</p>
</td></tr>
<tr><td><code id="nroColorize_+3A_palette">palette</code></td>
<td>

<p>One of pre-defined colormap names (see details). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>ranges</code> sets the minimum and maximum district values
irrespective of the contents of <code>values</code>. It can be used as a fixed
reference across different colorings to ensure that the same value produces
the same color across function calls.
</p>
<p>The argument <code>amplitudes</code> controls the proportion of the color range
that is available for the district value range. For proportions below 1,
the minimum district value is assigned to a color that is between the
first and middle element in the color palette, and the maximum is assigned
to a color that is between the middle and the last element. If
<code>amplitude</code> is greater than 1, extreme low and high values are
clipped to the first and last color in the palette, respectively.
</p>
<p>Available color palettes include &quot;grey&quot;, &quot;fire&quot;, &quot;jungle&quot;, &quot;miami&quot;, &quot;rhodo&quot;
or &quot;tan&quot;. Any other word will revert to a rainbow colormap.
</p>


<h3>Value</h3>

<p>A matrix of hexadecimal color codes as strings. The output also includes
the attribute 'contrast' that indicates which colors have a good contrast with
black as opposed to white, the attribute 'ranges' that contains a copy
of the dynamic ranges across districts, and the attribute 'palette' that
indicates the color scheme.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars]) 

# K-means clustering.
km &lt;- nroKmeans(data = trdata)

# Self-organizing map.
sm &lt;- nroKohonen(seeds = km)
sm &lt;- nroTrain(map = sm, data = trdata)

# Assign data points into districts.
matches &lt;- nroMatch(centroids = sm, data = trdata)

# District averages for all variables.
planes &lt;- nroAggregate(topology = sm, districts = matches, data = dataset)

# District colors for cholesterol.
chol &lt;- nroColorize(values = planes[,"CHOL"])
print(head(chol))

# District colors for all variables.
colrs &lt;- nroColorize(values = planes)
print(head(colrs))
</code></pre>

<hr>
<h2 id='nroDestratify'>Mitigate data stratification</h2><span id='topic+nroDestratify'></span>

<h3>Description</h3>

<p>Removes differences in value distribution within
subsets of data points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroDestratify(data, labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroDestratify_+3A_data">data</code></td>
<td>

<p>A matrix or a data frame with M rows.
</p>
</td></tr>
<tr><td><code id="nroDestratify_+3A_labels">labels</code></td>
<td>

<p>A vector of M subset labels.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only non-binary numerical columns are processed, the rest will be
excluded from the results.
</p>
<p>The de-stratification algorithm is based on ranked data: the distribution
of each subset will be mapped to the pooled distribution over all subsets
by matching subset-specific ranking with ranking of all values.
</p>


<h3>Value</h3>

<p>A matrix of de-stratified values. The output also includes the attribute
'incomplete' that lists those columns where (some of) the values were set
to missing due to processing failures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Remove sex differences for creatinine.
creat &lt;- nroDestratify(dataset$CREAT, dataset$MALE)

# Compare creatinine distributions.
men &lt;- which(dataset$MALE == 1)
women &lt;- which(dataset$MALE == 0)
print(summary(dataset[men,"CREAT"]))
print(summary(dataset[women,"CREAT"]))
print(summary(creat[men]))
print(summary(creat[women]))

# Remove sex differences (produces warnings for binary traits).
ds &lt;- nroDestratify(dataset, dataset$MALE)

# Compare HDL2C distributions.
print(summary(dataset[men,"HDL2C"]))
print(summary(dataset[women,"HDL2C"]))
print(summary(ds[men,"HDL2C"]))
print(summary(ds[women,"HDL2C"]))
</code></pre>

<hr>
<h2 id='nroKmeans'>
K-means clustering
</h2><span id='topic+nroKmeans'></span>

<h3>Description</h3>

<p>K-means clustering for multi-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroKmeans(data, k = 3, subsample = NULL, balance = 0, message = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroKmeans_+3A_data">data</code></td>
<td>

<p>A data frame or a matrix.
</p>
</td></tr>
<tr><td><code id="nroKmeans_+3A_k">k</code></td>
<td>

<p>Number of centroids.
</p>
</td></tr>  
<tr><td><code id="nroKmeans_+3A_subsample">subsample</code></td>
<td>

<p>Number of randomly selected rows used during a single training cycle.
</p>
</td></tr>    
<tr><td><code id="nroKmeans_+3A_balance">balance</code></td>
<td>

<p>Penalty parameter for size difference between clusters.
</p>
</td></tr>
<tr><td><code id="nroKmeans_+3A_message">message</code></td>
<td>

<p>If positive, progress information is printed at the specified
interval in seconds.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The K centroids are determined by Lloyd's algorithm with Euclidean
distances or by using 1 - Pearson correlation as the distance measure.
</p>
<p>If <code>subsample</code> is less than the number of data rows, a random subset of
the specified size is used for each training cycle. By default,
<code>subsample</code> is set automatically depending on the size of the dataset. 
</p>
<p>If <code>balance = 0.0</code>, the algorithm is applied with no balancing,
if <code>balance = 1.0</code> all the clusters will be forced to be of equal size.
Intermediate values are permitted. Note that if subsampling is applied,
balancing may become less accurate.
</p>


<h3>Value</h3>

<p>A list with named elements: <code>centroids</code> is a matrix of the
main results, <code>layout</code> contains the best-matching centroid labels
and model residuals for each usable data point and <code>history</code> is the
chronological record of training errors. The subsampling parameter that was
used during training is stored in the element <code>subsample</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars]) 

# Unbalanced K-means clustering.
km0 &lt;- nroKmeans(data = trdata, k = 5, balance = 0.0)
print(table(km0$layout$BMC))
print(km0$centroids)

# Balanced K-means clustering.
km1 &lt;- nroKmeans(data = trdata, k = 5, balance = 1.0)
print(table(km1$layout$BMC))
print(km1$centroids)
</code></pre>

<hr>
<h2 id='nroKohonen'>
Self-organizing map
</h2><span id='topic+nroKohonen'></span>

<h3>Description</h3>

<p>Interpolates the initial district profiles of a self-organizing map based
on pre-determined seed profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroKohonen(seeds, radius = 3, smoothness = 1.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroKohonen_+3A_seeds">seeds</code></td>
<td>

<p>A matrix or a data frame of K rows and N columns.
</p>
</td></tr>
<tr><td><code id="nroKohonen_+3A_radius">radius</code></td>
<td>

<p>Map radius.
</p>
</td></tr>
<tr><td><code id="nroKohonen_+3A_smoothness">smoothness</code></td>
<td>

<p>Rigidity of the map to adapt to regional differences.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named elements: <code>centroids</code> contains the N-dimensional
district profiles, and <code>topology</code> is an H x 6 matrix that contains
the 2D spatial layout for the map districts: the first two columns (X, Y)
indicate the positions of districts in Cartesian coordinates, the other
four columns (RADIUS1, RADIUS2, ANGLE1, ANGLE2) define the perimeter of
the district areas for visualisation on a circular map.
</p>
<p>Additional parameters are stored as attributes in <code>topology</code>.
</p>
<p>The function is named after Teuvo Kohonen, the inventor of the
self-organizing map.
</p>


<h3>See Also</h3>

<p>Please see <code><a href="#topic+nroKmeans">nroKmeans</a>()</code> to create the seeds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars]) 

# K-means clustering.
km &lt;- nroKmeans(data = trdata)

# Self-organizing map.
sm &lt;- nroKohonen(seeds = km)
print(head(sm$centroids))
print(head(sm$topology))
</code></pre>

<hr>
<h2 id='nroLabel'>
Label pruning
</h2><span id='topic+nroLabel'></span>

<h3>Description</h3>

<p>Optimize the look and selection of labels on map districts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroLabel(topology, values, gap = 2.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroLabel_+3A_topology">topology</code></td>
<td>

<p>A data frame with K rows and six columns, see details.  
</p>
</td></tr>
<tr><td><code id="nroLabel_+3A_values">values</code></td>
<td>

<p>A vector of K values or a K x N data frame, where K is the number of map
districts and N is the number of variables.
</p>
</td></tr>
<tr><td><code id="nroLabel_+3A_gap">gap</code></td>
<td>

<p>Minimum distance between map districts with non-empty labels.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assigns visible labels for districts based on the absolute
deviations from the average district value. The most extreme districts are
picked first, and then the remaining districts are prioritized based on
their value and distance to the other districts already labeled. Columns
that are listed in the attribute &quot;binary&quot; in <code>values</code> are given
percentage labels.
</p>
<p>Topology can be either the output from <code><a href="#topic+nroKohonen">nroKohonen</a>()</code> or a
data frame in the same format as the element <code>topology</code> within the
aforementioned output list.
</p>


<h3>Value</h3>

<p>A matrix with K rows and N columns that contains selected labels
for the map districts for each of the columns in <code>values</code>. The output
has the attribute 'visible' that contains binary flags to guide visibility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars]) 

# K-means clustering.
km &lt;- nroKmeans(data = trdata)

# Self-organizing map.
sm &lt;- nroKohonen(seeds = km)
sm &lt;- nroTrain(map = sm, data = trdata)

# Assign data points into districts.
matches &lt;- nroMatch(centroids = sm, data = trdata)

# District averages for all variables.
planes &lt;- nroAggregate(topology = sm, districts = matches, data = dataset)

# District labels for cholesterol.
chol &lt;- nroLabel(topology = sm, values = planes[,"CHOL"])
print(head(attr(chol, "visible")))
print(head(chol))

# District labels for all variables.
colrs &lt;- nroLabel(topology = sm, values = planes)
print(head(attr(colrs, "visible")))
print(head(colrs))
</code></pre>

<hr>
<h2 id='nroMatch'>
Best-matching districts
</h2><span id='topic+nroMatch'></span>

<h3>Description</h3>

<p>Compare multi-dimensional data points against the district
profiles of a self-organizing map (SOM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroMatch(centroids, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroMatch_+3A_centroids">centroids</code></td>
<td>

<p>Either a matrix, a data frame or a list that contains the element
<code>centroids</code>.
</p>
</td></tr>
<tr><td><code id="nroMatch_+3A_data">data</code></td>
<td>

<p>A data matrix with identical column names to the centroid matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input argument <code>centroids</code> can be a matrix or a data frame that
contains multivariable data profiles organized row-wise. It can also be
the output list object from <code><a href="#topic+nroKmeans">nroKmeans</a>()</code> or
<code><a href="#topic+nroTrain">nroTrain</a>()</code>.
</p>


<h3>Value</h3>

<p>A vector of integers with elements corresponding to the rows in
<code>data</code>. Each element contains the index of the best matching
row from <code>centroids</code>.
</p>
<p>The vector also has the attribute 'quality' that contains three columns:
RESIDUAL is the distance between a point and a centroid in data space
(shorter is better), RESIDUAL.z is a scale-independent version of RESIDUAL
if the mean residual and standard deviation are available from training
history, and COVERAGE shows the proportion of data elements that were
available for matching.
</p>
<p>The names of the columns that were used for matching are stored in the
attribute <code>variables</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars]) 

# K-means clustering.
km &lt;- nroKmeans(data = trdata, k = 10)

# Assign data points into districts.
matches &lt;- nroMatch(centroids = km, data = trdata)
print(head(attr(matches,"quality")))
print(table(matches))
</code></pre>

<hr>
<h2 id='nroPermute'>
Permutation analysis of map layout
</h2><span id='topic+nroPermute'></span>

<h3>Description</h3>

<p>Estimate the dynamic range and statistical significance for
regional patterns on a self-organizing maps using permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroPermute(map, districts, data, n = 1000, message = NULL,
           zbase = NULL, seed = 0.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroPermute_+3A_map">map</code></td>
<td>

<p>A list object in the format from <code><a href="#topic+nroTrain">nroTrain</a>()</code>.
</p>
</td></tr>
<tr><td><code id="nroPermute_+3A_districts">districts</code></td>
<td>

<p>An integer vector of M best matching districts.
</p>
</td></tr>
<tr><td><code id="nroPermute_+3A_data">data</code></td>
<td>

<p>A numeric vector of M values or an M x N matrix (or data frame), where
M is the number of data points and N is the number of variables.
</p>
</td></tr>
<tr><td><code id="nroPermute_+3A_n">n</code></td>
<td>

<p>Maximum number of permutations per variable.
</p>
</td></tr>
<tr><td><code id="nroPermute_+3A_message">message</code></td>
<td>

<p>If positive, progress information is printed at the specified
interval in seconds.
</p>
</td></tr>
<tr><td><code id="nroPermute_+3A_zbase">zbase</code></td>
<td>

<p>Reference Z-score for determining color amplitudes.
</p>
</td></tr>
<tr><td><code id="nroPermute_+3A_seed">seed</code></td>
<td>

<p>Seed value for random number generator.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input argument <code>map</code> must contain the map topology and the
centroid profiles as returned by the functions <code><a href="#topic+nroKmeans">nroKmeans</a>()</code>,
<code><a href="#topic+nroKohonen">nroKohonen</a>()</code>, or <code><a href="#topic+nroTrain">nroTrain</a>()</code>.
</p>
<p>The input argument <code>districts</code> must contain integers between 1 and K,
where K is the number map units. Any other values will be ignored.
</p>
<p>Training variables and data points are detected by the column names of
<code>map$centroids</code>, the attribute &quot;variables&quot; in <code>districts</code> and
the names of elements in <code>districts</code>.
</p>


<h3>Value</h3>

<p>A data frame with eight columns: P.z is a parametric estimate for statistical
significance, P.freq is the frequency-based estimate for statistical
signicance, and Z is the estimated z-score of how far the
observed map plane is from the average randomly generated layout.
N.data indicates how many data values were used and N.cycles tells the
number of completed permutations. AMPLITUDE is a dynamic range modifier
for colors that can be used in <code><a href="#topic+nroColorize">nroColorize</a>()</code>.
</p>
<p>The output also contains the attribute 'zbase' that indicates the
normalization factor for the color amplitudes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Set row names.
rownames(dataset) &lt;- paste("r", 1:nrow(dataset), sep="")

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars])

# K-means clustering.
km &lt;- nroKmeans(data = trdata)

# Self-organizing map.
sm &lt;- nroKohonen(seeds = km)
sm &lt;- nroTrain(map = sm, data = trdata)

# Assign data points into districts.
matches &lt;- nroMatch(centroids = sm, data = trdata)

# Estimate statistics for cholesterol
chol &lt;- nroPermute(map = sm, districts = matches, data = dataset$CHOL)
print(chol[,c("TRAINING", "Z", "P.z", "P.freq")])

# Estimate statistics.
stats &lt;- nroPermute(map = sm, districts = matches, data = dataset)
print(stats[,c("TRAINING", "Z", "P.z", "P.freq")])
</code></pre>

<hr>
<h2 id='nroPlot'>Plot a self-organizing map</h2><span id='topic+nroPlot'></span><span id='topic+nroPlot.save'></span>

<h3>Description</h3>

<p>Create a graphical interface for selecting subgroups from multiple
map colorings simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroPlot(topology, colors, labels = NULL, subplot = NULL,
        interactive = FALSE, clear = NULL)

nroPlot.save(file, topology, colors, labels = NULL,
             subplot = NULL, font = 1.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroPlot_+3A_topology">topology</code></td>
<td>

<p>A data frame with K rows and six or more columns that contain the district
positions of a self-organizing map and optional region assignments.
</p>
</td></tr>
<tr><td><code id="nroPlot_+3A_colors">colors</code></td>
<td>

<p>A character vector with K elements or a K x N matrix of hexadecimal
color codes as strings.
</p>
</td></tr>
<tr><td><code id="nroPlot_+3A_labels">labels</code></td>
<td>

<p>A character vector with K elements or a K x N matrix of district labels.
</p>
</td></tr>
<tr><td><code id="nroPlot_+3A_subplot">subplot</code></td>
<td>

<p>A two-element vector that sets out the number of rows and columns for
a grid layout of multiple colorings.
</p>
</td></tr>
<tr><td><code id="nroPlot_+3A_clear">clear</code></td>
<td>

<p>If TRUE, all graphics devices are cleared when the plot is refreshed.
</p>
</td></tr>
<tr><td><code id="nroPlot_+3A_interactive">interactive</code></td>
<td>

<p>If TRUE, an interactive version of the plot is launched.
</p>
</td></tr>
<tr><td><code id="nroPlot_+3A_file">file</code></td>
<td>

<p>If non-empty, the figure is saved as an SVG or HTML file
instead of plotting on graphics device.
</p>
</td></tr>
<tr><td><code id="nroPlot_+3A_font">font</code></td>
<td>

<p>Multiplier to adjust font size for SVG and HTML output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>topology</code> must follow the format from
<code><a href="#topic+nroKohonen">nroKohonen</a>()</code>, but may also contain the columns REGION,
and REGION.label that specify the names for subsets of districts and the
single character labels to be shown on top of those districts. The input
can also be the list object as returned by <code><a href="#topic+nroKohonen">nroKohonen</a>()</code>.
</p>
<p>The color input can include the attribute 'contrast' that contains a
binary vector or a matrix of equal size. If an element is set, it means
a dark label or highlight will have better contrast with the background.
</p>
<p>The label input can include the attribute 'visible' that contains a
binary vector or a matrix of equal size. If an element is set, it means
a label is visible, otherwise it will not be shown on the map.
</p>
<p>Some non-alphanumeric characters are not supported and will be
automatically converted to &quot;_&quot;. Too long labels or column names will be
truncated.
</p>
<p>The default value for <code>clear</code> is TRUE to prevent multiple plot windows
from accumulating within the RStudio. If you are running R from the terminal
or using detached devices, setting <code>clear</code> to FALSE will retain the
current window when refreshing.
</p>
<p>If the file name ends with &quot;.html&quot;, an interactive HTML document is
produced, otherwise an SVG document is created. We recommend opening the
HTML file with a web browser to select regions on large maps (i.e. when the
R plot window becomes too slow to use). The HTML page allows you to assign
subgroups and to save the results as tab-delimited text.
</p>


<h3>Value</h3>

<p>The main function returns a data frame with K rows that contains the
topology and subgrouping information. The <code>.save</code> subroutine returns
the number of bytes written in the output file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Detect binary columns.
dataset &lt;- nroPreprocess(dataset, method = "")

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars])

# K-means clustering.
km &lt;- nroKmeans(data = trdata)

# Self-organizing map.
sm &lt;- nroKohonen(seeds = km)
sm &lt;- nroTrain(map = sm, data = trdata)

# Assign data points into districts.
matches &lt;- nroMatch(centroids = sm, data = trdata)

# Select a subset of variables and detect binary data.
vars &lt;- c("AGE", "MALE", "uALB", "CHOL", "DIAB_KIDNEY", "DECEASED")
selected &lt;- nroPreprocess(dataset[,vars], method = "")

# Calculate district averages for seleted variables.
vars &lt;- c("AGE", "MALE", "uALB", "CHOL", "DIAB_KIDNEY", "DECEASED")
planes &lt;- nroAggregate(topology = sm, districts = matches, data = selected)

# Estimate statistics.
stats &lt;- nroPermute(map = sm, districts = matches, data = selected)

# Set visuals.
colrs &lt;- nroColorize(values = planes, amplitudes = stats)
labls &lt;- nroLabel(topology = sm, values = planes)

# Add subgrouping information.
topo &lt;- sm$topology
topo$REGION &lt;- ""
topo$REGION[1:8] &lt;- "Center"
topo$REGION[9:21] &lt;- "Perimeter"

# Add subgroup labels.
topo$REGION.label &lt;- ""
topo$REGION.label[1:8] &lt;- "C"
topo$REGION.label[9:21] &lt;- "P"

# Add subgroup colors.
topo$REGION.color &lt;- ""
topo$REGION.color[1:8] &lt;- "#00f00060"
topo$REGION.color[9:21] &lt;- "#f000f060"

# Plot colorings on screen.
nroPlot(topology = topo, colors = colrs, labels = labls)

# Save colorings in file.
#fn &lt;- "colorings.html"
#n &lt;- nroPlot.save(file = fn, topology = topo,
#    colors = colrs, labels = labls)
#cat(n, " bytes saved in '", fn, "'\n", sep="")
</code></pre>

<hr>
<h2 id='nroPostprocess'>Standardization using existing parameters</h2><span id='topic+nroPostprocess'></span>

<h3>Description</h3>

<p>Process a new dataset using a standardization procedure that
was created for another dataset</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroPostprocess(data, mapping, reverse = FALSE, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroPostprocess_+3A_data">data</code></td>
<td>

<p>A matrix or a data frame with column names.
</p>
</td></tr>
<tr><td><code id="nroPostprocess_+3A_mapping">mapping</code></td>
<td>

<p>A list object or a matrix or a data frame. 
</p>
</td></tr>
<tr><td><code id="nroPostprocess_+3A_reverse">reverse</code></td>
<td>

<p>If true, standardized data will be reverted back to original scale. 
</p>
</td></tr>
<tr><td><code id="nroPostprocess_+3A_trim">trim</code></td>
<td>

<p>If true, unusable rows and columns are removed. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input argument can be a data frame with the attribute 'mapping' as
returned from <code><a href="#topic+nroPreprocess">nroPreprocess</a>()</code> or a list object with the
elements <code>input</code> and <code>output</code> that each contain a data frame or
a matrix of equal size.
</p>
<p>The function projects the input data to the values in <code>mapping$input</code>
to determine the positions of the input values with respect to the rows
in the model. These positions are then used to interpolate corresponding
output values in <code>mapping$output</code>.
</p>
<p>The mapping elements must have consistent row and column names.
</p>


<h3>Value</h3>

<p>A matrix or data frame of processed values.
</p>


<h3>Author(s)</h3>

<p>Ville-Petteri Makinen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Show original data characteristics.
print(summary(dataset))

# Preprocess a subset of data.
ds.pre &lt;- nroPreprocess(dataset[1:100,])
print(summary(ds.pre))

# Repeat preprocessing for the whole dataset (approximation).
ds.post &lt;- nroPostprocess(dataset, ds.pre)
print(summary(ds.post))
</code></pre>

<hr>
<h2 id='nroPreprocess'>
Data cleaning and standardization
</h2><span id='topic+nroPreprocess'></span>

<h3>Description</h3>

<p>Convert to numerical values, remove unusable rows and columns, and
standardize scale of each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroPreprocess(data, method = "standard", clip = 5.0,
    resolution = 100, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroPreprocess_+3A_data">data</code></td>
<td>

<p>A matrix or a data frame. 
</p>
</td></tr>
<tr><td><code id="nroPreprocess_+3A_method">method</code></td>
<td>

<p>Method for standardizing scale and location, see details below.
</p>
</td></tr>
<tr><td><code id="nroPreprocess_+3A_clip">clip</code></td>
<td>

<p>Range for clipping extreme values in multiples of standard deviations.
</p>
</td></tr>
<tr><td><code id="nroPreprocess_+3A_resolution">resolution</code></td>
<td>

<p>Maximum number of sampling points to capture distribution shape.
</p>
</td></tr>
<tr><td><code id="nroPreprocess_+3A_trim">trim</code></td>
<td>

<p>if TRUE, empty rows and columns are removed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standardization methods include empty string for no action, &quot;standard&quot;
for centering by mean and division by standard deviation, &quot;uniform&quot; for
normalized ranks between -1 and 1, &quot;tapered&quot; for a version of the
rank-based method that puts more samples around zero and &quot;normal&quot;
for quantile-based mapping to standard normal distribution.
</p>
<p>The standard method also checks if the distribution is skewed and
applies logarithm if it makes the distribution closer to the normal curve.
</p>
<p>Clipping is not applied if the method is rank-based or if the threshold
is set to NULL.
</p>


<h3>Value</h3>

<p>A matrix of numerical values. A value mapping model is stored in the
attribute 'mapping'. The names of binary columns are stored in the
attribute 'binary'.
</p>


<h3>Author(s)</h3>

<p>Ville-Petteri Makinen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Show original data characteristics.
print(summary(dataset))

# Detect binary columns.
ds &lt;- nroPreprocess(dataset, method = "")
print(attr(ds,"binary"))

# Centering and scaling cholesterol.
ds &lt;- nroPreprocess(dataset$CHOL)
print(summary(ds))

# Centering and scaling.
ds &lt;- nroPreprocess(dataset)
print(summary(ds))

# Tapered ranks.
ds &lt;- nroPreprocess(dataset, method = "tapered")
print(summary(ds))

# Standard normal ranks.
ds &lt;- nroPreprocess(dataset, method = "normal")
print(summary(ds))
</code></pre>

<hr>
<h2 id='nroSummary'>
Estimate subgroup statistics
</h2><span id='topic+nroSummary'></span>

<h3>Description</h3>

<p>Combine data points that reside in districts that belong to a larger region
into a subgroup; compare descriptive statistics between subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroSummary(data, districts, regions = NULL, categlim = 8, capacity = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroSummary_+3A_data">data</code></td>
<td>

<p>A vector of named M elements or an M x N matrix of data values with row names. 
</p>
</td></tr>
<tr><td><code id="nroSummary_+3A_districts">districts</code></td>
<td>
 
<p>An integer vector of M named elements that indicate the best match out of
K districts for each row name in the data matrix, please see <a href="#topic+nroMatch">nroMatch</a>
for an example.
</p>
</td></tr>
<tr><td><code id="nroSummary_+3A_regions">regions</code></td>
<td>

<p>An vector of K elements or a data frame of K rows that defines if a
district belongs to a larger region (i.e. a subgroup), see details.
</p>
</td></tr>
<tr><td><code id="nroSummary_+3A_categlim">categlim</code></td>
<td>

<p>The threshold for the number of unique values before a variable is
considered continuous.
</p>
</td></tr>
<tr><td><code id="nroSummary_+3A_capacity">capacity</code></td>
<td>

<p>Maximum number of subgroups to compare.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If defined, the region vector should have K elements where K is the total
number of map districts.
</p>
<p>The region input can also be a data frame of K rows where the column
REGION will be used for assigning district to regions, and REGION.label
will be used as the character label as seen on the map, see the output
from <code><a href="#topic+nroPlot">nroPlot</a>()</code> for an example.
</p>
<p>Districts and data points are connected by comparing element names in
<code>districts</code> and names or row names of <code>data</code>.
</p>
<p>Districts and regions are connected by comparing element values in
<code>districts</code> and names or row names of <code>regions</code>.
</p>
<p>If the region vector is empty, each district is automatically assigned to
its own region.
</p>
<p>Safeguards are in place to prevent crashes from empty categories; this
reduces statistical power slightly when numbers are small.
</p>


<h3>Value</h3>

<p>A data frame of summary statistics that contains a row for every
combination of subgroups and variables. The chi-squared test is used for
comparisons with respect to categorical variables, and rank-regulated t-test
and ANOVA are applied to continuous variables. Region labels for each row
are stored in the attribute 'labels' and a list that contains the subsets
of rows in each region is stored in the attribute 'subgroups'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars])

# K-means clustering.
km &lt;- nroKmeans(data = trdata)

# Self-organizing map.
sm &lt;- nroKohonen(seeds = km)
sm &lt;- nroTrain(map = sm, data = trdata)

# Assign data points into districts.
matches &lt;- nroMatch(centroids = sm, data = trdata)

# Calculate district averages for urinary albumin.
plane &lt;- nroAggregate(topology = sm, districts = matches,
                      data = dataset$uALB)
plane &lt;- as.vector(plane)

# Assign subgroups based on urinary albumin.
regns &lt;- rep("HighAlb", length.out=length(plane))
regns[which(plane &lt; quantile(plane, 0.67))] &lt;- "MiddleAlb"
regns[which(plane &lt; quantile(plane, 0.33))] &lt;- "LowAlb"

# Add label info and make a data frame.
regns &lt;- data.frame(REGION=regns, REGION.label="",
    stringsAsFactors=FALSE)
regns[which(regns$REGION == "HighAlb"),"REGION.label"] &lt;- "H"
regns[which(regns$REGION == "MiddleAlb"),"REGION.label"] &lt;- "M"
regns[which(regns$REGION == "LowAlb"),"REGION.label"] &lt;- "L"

# Calculate summary statistics.
st &lt;- nroSummary(data = dataset, districts = matches, regions = regns)
print(st[,c("VARIABLE","SUBGROUP","MEAN","P.chisq","P.t","P.anova")])
</code></pre>

<hr>
<h2 id='nroTrain'>
Train self-organizing map
</h2><span id='topic+nroTrain'></span>

<h3>Description</h3>

<p>Iterative algorithm to adapt a self-organizing map (SOM) to a set of
multivariable data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nroTrain(map, data, subsample = NULL, balance = 0, message = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nroTrain_+3A_map">map</code></td>
<td>

<p>A list object as returned by <code><a href="#topic+nroKohonen">nroKohonen</a>()</code>.
</p>
</td></tr>
<tr><td><code id="nroTrain_+3A_data">data</code></td>
<td>

<p>A matrix or a data frame.
</p>
</td></tr>
<tr><td><code id="nroTrain_+3A_subsample">subsample</code></td>
<td>

<p>Number of rows used during a single training cycle.
</p>
</td></tr>
<tr><td><code id="nroTrain_+3A_balance">balance</code></td>
<td>

<p>Penalty parameter for variation in the numbers of resident
samples across disctricts, see <code><a href="#topic+nroKmeans">nroKmeans</a>()</code>.
</p>
</td></tr>
<tr><td><code id="nroTrain_+3A_message">message</code></td>
<td>

<p>If positive, progress information is printed at the specified
interval in seconds.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The map is fitted according to columns that are found both in the
SOM centroids and the input data.
</p>
<p>If <code>subsample</code> is less than the number of data rows, a random subset of
the specified size is used for each training cycle. By default,
<code>subsample</code> is set automatically depending on the size of the dataset. 
</p>


<h3>Value</h3>

<p>A copy of the list object <code>map</code>, where the element <code>centroids</code> is
updated according to the data patterns. The quantization errors during
training are stored in the element <code>history</code>. The subsampling
parameter that was used during training is stored in the element
<code>subsample</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Prepare training data.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- scale.default(dataset[,trvars]) 

# K-means clustering.
km &lt;- nroKmeans(data = trdata)

# Train with full data.
sm &lt;- nroKohonen(seeds = km)
sm &lt;- nroTrain(map = sm, data = trdata, subsample = nrow(trdata))
print(sm$history)

# Train with subsampling.
sm &lt;- nroKohonen(seeds = km)
sm &lt;- nroTrain(map = sm, data = trdata, subsample = 200)
print(sm$history)
</code></pre>

<hr>
<h2 id='numero.clean'>Clean datasets</h2><span id='topic+numero.clean'></span>

<h3>Description</h3>

<p>Sets row names and removes unusable columns and rows.</p>


<h3>Usage</h3>

<pre><code class='language-R'>numero.clean(..., identity = NULL, na.freq = 0.9,
             num.only = TRUE, select = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numero.clean_+3A_...">...</code></td>
<td>

<p>Matrices or a data frames. 
</p>
</td></tr>
<tr><td><code id="numero.clean_+3A_identity">identity</code></td>
<td>

<p>Name(s) of the column(s) that contain identification information.
</p>
</td></tr>
<tr><td><code id="numero.clean_+3A_na.freq">na.freq</code></td>
<td>

<p>The proportion of how many missing values are allowed in
each column and in each row.
</p>
</td></tr>
<tr><td><code id="numero.clean_+3A_num.only">num.only</code></td>
<td>

<p>If true, only numeric columns are included.
</p>
</td></tr>
<tr><td><code id="numero.clean_+3A_select">select</code></td>
<td>

<p>Indicate if only identities present in all datasets
or in exactly one of the datasets are included.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If multiple identity columns are provided, composite identity keys
are constructed by concatenating elements from each column with
&quot;_&quot; added as a separator.
</p>
<p>The frequency of missing values (against <code>na.freq</code>) is tested first
by column then by row.
</p>
<p>Selection can take three values: &quot;&quot; for no selection, &quot;union&quot; for all
identities expanded to every dataset, &quot;shared&quot; for only those data points
present in all usable datasets or &quot;distinct&quot; for excluding any points that
can be found in more than one dataset. Note that the union may result in
rows with no usable values.
</p>


<h3>Value</h3>

<p>A data frame if only one input dataset, or a list of data frames if
multiple datasets.
</p>


<h3>Author(s)</h3>

<p>Ville-Petteri Makinen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Create new versions for testing.
dsA &lt;- dataset[1:250, c("INDEX","AGE","MALE","uALB")]
dsB &lt;- dataset[151:300, c("INDEX","AGE","MALE","uALB","CHOL")]
dsC &lt;- dataset[201:500, c("INDEX","AGE","MALE","DIAB_RETINO")]

# Select all rows.
results &lt;- numero.clean(a = dsA, b = dsB, c = dsC, identity = "INDEX")
cat("\n\nNo selection:\n")
print(nrow(results$a))
print(nrow(results$b))
print(nrow(results$c))

# Select all rows and expanded for all identities.
results &lt;- numero.clean(a = dsA, b = dsB, c = dsC, identity = "INDEX",
                        select = "union")
cat("\n\nUnion:\n")
print(nrow(results$a))
print(nrow(results$b))
print(nrow(results$c))

# Select only rows that are shared between all datasets.
results &lt;- numero.clean(a = dsA, b = dsB, c = dsC, identity = "INDEX",
                        select = "intersection")
cat("\n\nIntersection:\n")
print(nrow(results$a))
print(nrow(results$b))
print(nrow(results$c))

# Select only rows with a unique INDEX ('dsB' has none).
results &lt;- numero.clean(a = dsA, b = dsB, c = dsC, identity = "INDEX",
                        select = "exclusion")
cat("\n\nExclusion:\n")
print(nrow(results$a))
print(nrow(results$b))
print(nrow(results$c))

# Add extra identification information.
dsA$GROUP &lt;- "A"
dsB$GROUP &lt;- "B"
dsC$GROUP &lt;- "C"

# Select rows with a unique identifier.
results &lt;- numero.clean(a = dsA, b = dsB, c = dsC,
                        identity = c("GROUP","INDEX"),
                        select = "exclusion")
cat("\n\nMulti-identities:\n")
print(nrow(results$a))
print(nrow(results$b))
print(nrow(results$c))
</code></pre>

<hr>
<h2 id='numero.create'>Create a self-organizing map</h2><span id='topic+numero.create'></span>

<h3>Description</h3>

<p>Set up a self-organizing map and train it with data</p>


<h3>Usage</h3>

<pre><code class='language-R'>numero.create(data, radius = NULL, smoothness = NULL, subsample = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numero.create_+3A_data">data</code></td>
<td>

<p>A matrix or a data frame. 
</p>
</td></tr>
<tr><td><code id="numero.create_+3A_radius">radius</code></td>
<td>

<p>Map radius.
</p>
</td></tr>
<tr><td><code id="numero.create_+3A_smoothness">smoothness</code></td>
<td>

<p>Rigidity of the map to adapt to regional differences.
</p>
</td></tr>
<tr><td><code id="numero.create_+3A_subsample">subsample</code></td>
<td>

<p>Number of data points used during a single training cycle.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>subsample</code> sets the number of data points that are
randomly picked for each training cycle; if the number is substantially less
than the size of the dataset, the function will finish quicker.
</p>


<h3>Value</h3>

<p>A list with named elements: <code>data</code> contains the training data,
<code>kmeans</code> is the output from <code><a href="#topic+nroKmeans">nroKmeans</a>()</code> during the
initialiation of the SOM, <code>map</code> is the finished self-organising map
from <code><a href="#topic+nroTrain">nroTrain</a>()</code> and <code>layout</code> contains the output from
<code><a href="#topic+nroMatch">nroMatch</a>()</code> for the training data points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Set identities and manage missing data.
dataset &lt;- numero.clean(dataset, identity = "INDEX")

# Prepare training set.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- numero.prepare(data = dataset, variables = trvars)

# Create a self-organizing map.
modl &lt;- numero.create(data = trdata)
</code></pre>

<hr>
<h2 id='numero.evaluate'>Self-organizing map statistics</h2><span id='topic+numero.evaluate'></span>

<h3>Description</h3>

<p>Evaluate regional variation of data values on a
self-organizing map</p>


<h3>Usage</h3>

<pre><code class='language-R'>numero.evaluate(model, data, ranked = TRUE, n = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numero.evaluate_+3A_model">model</code></td>
<td>

<p>A list object that contains a self-organizing map and a data layout.
</p>
</td></tr>
<tr><td><code id="numero.evaluate_+3A_data">data</code></td>
<td>

<p>A matrix or a data frame.
</p>
</td></tr>
<tr><td><code id="numero.evaluate_+3A_ranked">ranked</code></td>
<td>

<p>If true, a rank transform is applied to avoid problems from skewed
distributions or outliers.
</p>
</td></tr>
<tr><td><code id="numero.evaluate_+3A_n">n</code></td>
<td>

<p>Maximum number of permutations per data column.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input argument <code>model</code> can be the output from
<code><a href="#topic+numero.create">numero.create</a>()</code> or from <code><a href="#topic+numero.quality">numero.quality</a>()</code>.
</p>


<h3>Value</h3>

<p>A list with named elements: <code>som</code> contains the self-organizing map,
<code>layout</code> contains the district assignments for data points,
<code>planes</code> contains smoothed district averages from
<code><a href="#topic+nroAggregate">nroAggregate</a>()</code>, the element <code>ranges</code> contains the
reference ranges to be used in <code><a href="#topic+nroColorize">nroColorize</a>()</code>,
the element <code>statistics</code> contains the output from
<code><a href="#topic+nroPermute">nroPermute</a>()</code>, the element <code>palette</code> is the name of
the colormap and the element <code>data</code> contains the data points
that were used for calculating the statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Set identities and manage missing data.
dataset &lt;- numero.clean(dataset, identity = "INDEX")

# Prepare training variables.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- numero.prepare(data = dataset, variables = trvars)

# Create a self-organizing map.
sm &lt;- numero.create(data = trdata)
qc &lt;- numero.quality(model = sm)

# Evaluate map statistics.
results &lt;- numero.evaluate(model = qc, data = dataset)
print(results$statistics[,c("TRAINING", "Z", "P.z", "P.freq")])
</code></pre>

<hr>
<h2 id='numero.plot'>Plot results from SOM analysis</h2><span id='topic+numero.plot'></span>

<h3>Description</h3>

<p>Plot map colorings and save them as vector graphics</p>


<h3>Usage</h3>

<pre><code class='language-R'>numero.plot(results, variables = NULL, topology = NULL, folder = NULL,
            prefix = "figure", reference = NULL, subplot = NULL,
	    gain = 1, detach = FALSE, capacity = 500, font = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numero.plot_+3A_results">results</code></td>
<td>

<p>A list object that contains the self-organizing map and its
statistical colorings.
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_variables">variables</code></td>
<td>

<p>A string vector that contains names of variables to show.
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_topology">topology</code></td>
<td>

<p>The topology of a SOM with subgroup labels.
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_folder">folder</code></td>
<td>

<p>Folder path for saving figures.
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_prefix">prefix</code></td>
<td>

<p>Prefix for each figure file (if saving enabled).
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_reference">reference</code></td>
<td>

<p>Reference color ranges and scales.
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_gain">gain</code></td>
<td>

<p>Modifier for overall color intensity.
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_subplot">subplot</code></td>
<td>

<p>A two-element vector that sets out the number of rows and
columns for subplots per figure.
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_detach">detach</code></td>
<td>

<p>Use detached windows for figures.
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_capacity">capacity</code></td>
<td>

<p>Maximum number of subplots to show on screen.
</p>
</td></tr>
<tr><td><code id="numero.plot_+3A_font">font</code></td>
<td>

<p>Multiplier to adjust font size for SVG and HTML output,
see <code><a href="#topic+nroPlot.save">nroPlot.save</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>results</code> must contain the output from
<code><a href="#topic+numero.evaluate">numero.evaluate</a>()</code> or similar.
</p>
<p>The input argument <code>topology</code> can be the topology of a SOM or with
additional columns as in the output from <code><a href="#topic+numero.subgroup">numero.subgroup</a>()</code>.
</p>
<p>The input argument <code>reference</code> follows the output format from
<code><a href="#topic+numero.evaluate">numero.evaluate</a>()</code>.
</p>
<p>Possible values for <code>detach</code> include &quot;X11&quot;, &quot;aqua&quot;, TRUE or FALSE.
Using multiple figures may result in different behaviour in terminal vs.
RStudio instances. The default behaviour is to create detached windows for each
figure when the X11 display server is available (e.g. in Linux). To use
detached windows in Mac, use the value &quot;aqua&quot;. Setting <code>detach = TRUE</code>
will use a more general approach, however, some systems may behave
unpredictably. To create multiple figures that remain docked within the
RStudio work window, set <code>detach = FALSE</code>.
</p>
<p>If a destination folder is provided, all plots are saved in files
without plotting them on screen.
</p>


<h3>Value</h3>

<p>The number of figures that were created.
</p>


<h3>Author(s)</h3>

<p>Ville-Petteri Makinen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Set identities and manage missing data.
dataset &lt;- numero.clean(dataset, identity = "INDEX")

# Prepare training variables.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- numero.prepare(data = dataset, variables = trvars,
    batch = "MALE", confounders = c("AGE", "T1D_DURAT"))

# Create a self-organizing map.
sm &lt;- numero.create(data = trdata)
qc &lt;- numero.quality(model = sm)

# Evaluate map statistics for all variables.
stats &lt;- numero.evaluate(model = qc, data = dataset)

# Plot map colorings.
numero.plot(results = stats)
</code></pre>

<hr>
<h2 id='numero.prepare'>Prepare datasets for analysis</h2><span id='topic+numero.prepare'></span>

<h3>Description</h3>

<p>Prepare training data by mitigating confounding factors and
standardizing values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>numero.prepare(data, variables = NULL, confounders = NULL,
               batch = NULL, method = "standard", clip = 5.0,
	       pipeline = NULL, undo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numero.prepare_+3A_data">data</code></td>
<td>

<p>A matrix or a data frame.
</p>
</td></tr>
<tr><td><code id="numero.prepare_+3A_variables">variables</code></td>
<td>

<p>A character vector of column names, see details.  
</p>
</td></tr>
<tr><td><code id="numero.prepare_+3A_confounders">confounders</code></td>
<td>

<p>Names of columns that contain confounder data.
</p>
</td></tr>
<tr><td><code id="numero.prepare_+3A_batch">batch</code></td>
<td>

<p>The name of the column that contains batch labels.
</p>
</td></tr>
<tr><td><code id="numero.prepare_+3A_method">method</code></td>
<td>

<p>Method to standardize values, see <code><a href="#topic+nroPreprocess">nroPreprocess</a>()</code>.
</p>
</td></tr>
<tr><td><code id="numero.prepare_+3A_clip">clip</code></td>
<td>

<p>Range for clipping extreme values in multiples of standard deviations.
</p>
</td></tr>  
<tr><td><code id="numero.prepare_+3A_pipeline">pipeline</code></td>
<td>

<p>Processing parameters from a previous use of the function.
</p>
</td></tr>
<tr><td><code id="numero.prepare_+3A_undo">undo</code></td>
<td>

<p>If true, standardization is reversed after adjusting for
batches and confounders.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend first applying <code><a href="#topic+numero.clean">numero.clean</a>()</code> to the full
dataset, then selecting a subset for training using the input argument
<code>variables</code>. This preserves any attributes that may be used in
Numero functions.
</p>
<p>If a previous <code>pipeline</code> is available, it overrides all processing
parameters irrespective of other input arguments.
</p>
<p>Due to safeguards against numerical instability, the standardized values
may deviate slightly from the expected range (&lt;0.1 percent error is typical).
</p>
<p>Clipping of extreme values is applied only during the first round of
standardization before adjustments for confounders. Therefore, the final
output may contain values that exceed the threshold.
</p>


<h3>Value</h3>

<p>A matrix with the attributes 'pipeline' that contains the processing
parameters and 'subsets' that contains row names divided into batches if
batch correction was applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Set identities and manage missing data.
dataset &lt;- numero.clean(dataset, identity = "INDEX")

# Prepare training variables using default standardization.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- numero.prepare(data = dataset, variables = trvars)
print(summary(trdata))

# Prepare training values adjusted for age and sex and
# standardized by rank-based method.
trdata &lt;- numero.prepare(data = dataset, variables = trvars,
                         batch = "MALE", confounders = "AGE",
			 method = "tapered")
print(summary(trdata))
</code></pre>

<hr>
<h2 id='numero.quality'>Self-organizing map statistics</h2><span id='topic+numero.quality'></span>

<h3>Description</h3>

<p>Assign new data points to map districts and
calculate quality measures</p>


<h3>Usage</h3>

<pre><code class='language-R'>numero.quality(model, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numero.quality_+3A_model">model</code></td>
<td>

<p>A list object that contains a self-organizing map (and a data layout).
</p>
</td></tr>
<tr><td><code id="numero.quality_+3A_data">data</code></td>
<td>

<p>A matrix or a data frame.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input argument <code>model</code> must be in the the output format
as returned by <code><a href="#topic+numero.create">numero.create</a>()</code>.
</p>


<h3>Value</h3>

<p>A list with named elements: <code>som</code> contains the self-organizing map;
<code>layout</code> contains the district assignments for data points;
<code>planes</code> contains smoothed district averages of quality measures, see
<code><a href="#topic+nroAggregate">nroAggregate</a>()</code> and <code><a href="#topic+nroMatch">nroMatch</a>()</code>; the element
<code>ranges</code> contains the reference ranges to be used in
<code><a href="#topic+nroColorize">nroColorize</a>()</code>; the element <code>palette</code> is the name of
the colormap to be used for colorings; and <code>statistics</code> contains
the output from <code><a href="#topic+nroPermute">nroPermute</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Set identities and manage missing data.
dataset &lt;- numero.clean(dataset, identity = "INDEX")

# Prepare training variables.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- numero.prepare(data = dataset, variables = trvars)

# Create a self-organizing map.
modl &lt;- numero.create(data = trdata)

# Analyze map quality.
qc &lt;- numero.quality(model = modl)
</code></pre>

<hr>
<h2 id='numero.subgroup'>Interactive subgroup assignment</h2><span id='topic+numero.subgroup'></span>

<h3>Description</h3>

<p>Plot self-organizing map colorings and let the user choose
multi-district regions as subgroups</p>


<h3>Usage</h3>

<pre><code class='language-R'>numero.subgroup(results, variables, topology = NULL, reference = NULL,
                gain = 1, detach = FALSE, capacity = 9, automatic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numero.subgroup_+3A_results">results</code></td>
<td>

<p>A list object that contains the self-organizing map and its
statistical colorings.
</p>
</td></tr>
<tr><td><code id="numero.subgroup_+3A_variables">variables</code></td>
<td>

<p>A string vector that contains names of variables to show on screen.
</p>
</td></tr>
<tr><td><code id="numero.subgroup_+3A_topology">topology</code></td>
<td>

<p>A SOM topology or the output from a previous subgrouping session.
</p>
</td></tr>
<tr><td><code id="numero.subgroup_+3A_reference">reference</code></td>
<td>

<p>Reference color ranges and scales.
</p>
</td></tr>
<tr><td><code id="numero.subgroup_+3A_gain">gain</code></td>
<td>

<p>Modifier for overall color intensity.
</p>
</td></tr>
<tr><td><code id="numero.subgroup_+3A_detach">detach</code></td>
<td>

<p>Use a detached window.
</p>
</td></tr>
<tr><td><code id="numero.subgroup_+3A_capacity">capacity</code></td>
<td>

<p>Maximum number of subplots to show on screen.
</p>
</td></tr>
<tr><td><code id="numero.subgroup_+3A_automatic">automatic</code></td>
<td>

<p>If greater than zero, automatic segmentation of the map is triggered,
the value sets the number of subgroups.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>results</code> must contain the output from
<code><a href="#topic+numero.evaluate">numero.evaluate</a>()</code> or similar.
</p>
<p>The input argument <code>topology</code> can be the structure of a SOM or with
additional columns as in the output from <code><a href="#topic+nroPlot">nroPlot</a>()</code>.
</p>
<p>The input argument <code>reference</code> follows the output format from
<code><a href="#topic+numero.evaluate">numero.evaluate</a>()</code>.
</p>
<p>Setting detach to FALSE will also clear all devices whenever the figure is
refreshed. This may be inconvenient when using R from the terminal,
for example; please see the help page of <code><a href="#topic+numero.plot">numero.plot</a>()</code> for
using a detached window device instead.
</p>
<p>If any districts are left unmarked, they are automatically collected
into a subgroup of their own. If <code>automatic</code> is set, user input
is skipped.
</p>


<h3>Value</h3>

<p>A data frame similar to the format returned by <code><a href="#topic+nroPlot">nroPlot</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Set identities and manage missing data.
dataset &lt;- numero.clean(dataset, identity = "INDEX")

# Prepare training variables.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- numero.prepare(data = dataset, variables = trvars)

# Create a self-organizing map.
sm &lt;- numero.create(data = trdata)
qc &lt;- numero.quality(model = sm)

# Evaluate map statistics for all variables.
stats &lt;- numero.evaluate(model = qc, data = dataset)

# Define subgroups, uncomment to launch interactive window.
#elem &lt;- numero.subgroup(results = stats, variables = trvars)
</code></pre>

<hr>
<h2 id='numero.summary'>Summarize subgroup statistics</h2><span id='topic+numero.summary'></span>

<h3>Description</h3>

<p>Estimates subgroup statistics after self-organizing map
analysis</p>


<h3>Usage</h3>

<pre><code class='language-R'>numero.summary(results, topology, data = NULL, capacity = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numero.summary_+3A_results">results</code></td>
<td>

<p>A list object that contains the self-organizing map and its
statistical colorings.
</p>
</td></tr>
<tr><td><code id="numero.summary_+3A_topology">topology</code></td>
<td>

<p>A SOM topology with additional labels that indicate selected regions.
</p>
</td></tr>
<tr><td><code id="numero.summary_+3A_data">data</code></td>
<td>

<p>A matrix or a data frame.
</p>
</td></tr>
<tr><td><code id="numero.summary_+3A_capacity">capacity</code></td>
<td>

<p>Maximum number of subgroups to compare.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>results</code> must contain the output from
<code><a href="#topic+numero.evaluate">numero.evaluate</a>()</code> or similar.
</p>
<p>The input argument <code>topology</code> must be a definition of a SOM with
additional columns as in the output from <code><a href="#topic+numero.subgroup">numero.subgroup</a>()</code>.
</p>
<p>The function first looks for row names in <code>data</code> that are also included
in <code>results</code>. The rows are then divided into subgroups according to the
district assignments in <code>results</code> and the region labels in
<code>topology</code>. 
</p>


<h3>Value</h3>

<p>A data frame of summary statistics, see <code><a href="#topic+nroSummary">nroSummary</a>()</code>
for details. The data frame also contains additional information on which
variables were used for the training of the SOM.
</p>
<p>The attribute 'layout' is added to the output. It indicates the location
on the map and the subgroup name and label for each data row that were
included in the analysis.
</p>


<h3>Author(s)</h3>

<p>Ville-Petteri Makinen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data.
fname &lt;- system.file("extdata", "finndiane.txt", package = "Numero")
dataset &lt;- read.delim(file = fname)

# Set identities and manage missing data.
dataset &lt;- numero.clean(dataset, identity = "INDEX")

# Prepare training variables.
trvars &lt;- c("CHOL", "HDL2C", "TG", "CREAT", "uALB")
trdata &lt;- numero.prepare(data = dataset, variables = trvars)

# Create a self-organizing map.
sm &lt;- numero.create(data = trdata)
qc &lt;- numero.quality(model = sm)

# Evaluate map statistics for all variables.
stats &lt;- numero.evaluate(model = qc, data = dataset)

# Define subgroups.
x &lt;- stats$planes[,"uALB"]
tops &lt;- which(x &gt;= quantile(x, 0.75, na.rm=TRUE))
bottoms &lt;- which(x &lt;= quantile(x, 0.25, na.rm=TRUE))
elem &lt;- data.frame(stats$map$topology, stringsAsFactors = FALSE)
elem$REGION &lt;- "MiddleAlb"
elem$REGION[tops] &lt;- "HighAlb"
elem$REGION[bottoms] &lt;- "LowAlb"
elem$REGION.label &lt;- "M"
elem$REGION.label[tops] &lt;- "H"
elem$REGION.label[bottoms] &lt;- "L"

# Compare subgroups.
cmp &lt;- numero.summary(results = stats, topology = elem, data = dataset)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
