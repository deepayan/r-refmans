<!DOCTYPE html><html><head><title>Help for package PUlasso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PUlasso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PUlasso-package'><p>PUlasso : An efficient algorithm to solve Positive and Unlabeled(PU) problem with lasso or group lasso penalty</p></a></li>
<li><a href='#cv.grpPUlasso'><p>Cross-validation for PUlasso</p></a></li>
<li><a href='#deviances'><p>Deviance</p></a></li>
<li><a href='#grpPUlasso'><p>Solve PU problem with lasso or group lasso penalty.</p></a></li>
<li><a href='#simulPU'><p>simulated PU data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High-Dimensional Variable Selection with Presence-Only Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient algorithm for solving PU (Positive and Unlabeled) problem in low or high dimensional setting with lasso or group lasso penalty. The algorithm uses Maximization-Minorization and (block) coordinate descent. Sparse calculation and parallel computing are supported for the computational speed-up. See Hyebin Song, Garvesh Raskutti (2018) &lt;<a href="https://doi.org/10.48550/arXiv.1711.08129">doi:10.48550/arXiv.1711.08129</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.8), methods, Matrix, doParallel, foreach,
ggplot2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, Matrix</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://arxiv.org/abs/1711.08129">https://arxiv.org/abs/1711.08129</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hsong1/PUlasso/issues">https://github.com/hsong1/PUlasso/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-18 00:38:18 UTC; hyebins</td>
</tr>
<tr>
<td>Author:</td>
<td>Hyebin Song [aut, cre],
  Garvesh Raskutti [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hyebin Song &lt;hps5320@psu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-18 14:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='PUlasso-package'>PUlasso : An efficient algorithm to solve Positive and Unlabeled(PU) problem with lasso or group lasso penalty</h2><span id='topic+PUlasso'></span><span id='topic+PUlasso-package'></span>

<h3>Description</h3>

<p>The package efficiently solves PU problem in low or high dimensional setting using Maximization-Minorization and (block) coordinate descent. It allows simultaneous feature selection and parameter estimation for classification. Sparse calculation and parallel computing are supported for the further computational speed-up. See Hyebin Song, Garvesh Raskutti (2018) &lt;<a href="https://arxiv.org/abs/1711.08129">https://arxiv.org/abs/1711.08129</a>&gt;.
</p>


<h3>Details</h3>

<p>Main functions: grpPUlasso, cv.grpPUlasso, coef, predict
</p>


<h3>Author(s)</h3>

<p>Hyebin Song, <a href="mailto:hsong@stat.wisc.edu">hsong@stat.wisc.edu</a>, Garvesh Raskutti, <a href="mailto:raskutti@stat.wisc.edu">raskutti@stat.wisc.edu</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://arxiv.org/abs/1711.08129">https://arxiv.org/abs/1711.08129</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hsong1/PUlasso/issues">https://github.com/hsong1/PUlasso/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("simulPU")
fit&lt;-grpPUlasso(X=simulPU$X,z=simulPU$z,py1=simulPU$truePY1)
## Not run: 
cvfit&lt;-cv.grpPUlasso(X=simulPU$X,z=simulPU$z,py1=simulPU$truePY1)

## End(Not run)
coef(fit,lambda=fit$lambda[10])
predict(fit,newdata = head(simulPU$X), lambda= fit$lambda[10],type = "response")
</code></pre>

<hr>
<h2 id='cv.grpPUlasso'>Cross-validation for PUlasso</h2><span id='topic+cv.grpPUlasso'></span>

<h3>Description</h3>

<p>Do a n-fold cross-validation for PUlasso.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.grpPUlasso(
  X,
  z,
  py1,
  initial_coef = NULL,
  group = 1:p,
  penalty = NULL,
  lambda = NULL,
  nlambda = 100,
  lambdaMinRatio = ifelse(N &lt; p, 0.05, 0.005),
  maxit = ifelse(method == "CD", 1000, N * 10),
  weights = NULL,
  eps = 1e-04,
  inner_eps = 0.01,
  verbose = FALSE,
  stepSize = NULL,
  stepSizeAdjustment = NULL,
  batchSize = 1,
  updateFrequency = N,
  samplingProbabilities = NULL,
  method = c("CD", "GD", "SGD", "SVRG", "SAG"),
  nfolds = 10,
  fitInd = 1:nfolds,
  nCores = 1,
  trace = c("none", "param", "fVal", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.grpPUlasso_+3A_x">X</code></td>
<td>
<p>Input matrix; each row is an observation. Can be a matrix or a sparse matrix.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_z">z</code></td>
<td>
<p>Response vector representing whether an observation is labeled or unlabeled.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_py1">py1</code></td>
<td>
<p>True prevalence Pr(Y=1)</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_initial_coef">initial_coef</code></td>
<td>
<p>A vector representing an initial point where we start PUlasso algorithm from.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_group">group</code></td>
<td>
<p>A vector representing grouping of the coefficients. For the least ambiguity, it is recommended if group is provided in the form of vector of consecutive ascending integers.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_penalty">penalty</code></td>
<td>
<p>penalty to be applied to the model. Default is sqrt(group size) for each of the group.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied sequence of lambda values. If unspecified, the function automatically generates its own lambda sequence based on nlambda and lambdaMinRatio.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of lambda values.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_lambdaminratio">lambdaMinRatio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max which leads to the intercept only model.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_weights">weights</code></td>
<td>
<p>observation weights. Default is 1 for each observation.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold for the outer loop. The algorithm iterates until the maximum change in coefficients is less than eps in the outer loop.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_inner_eps">inner_eps</code></td>
<td>
<p>Convergence threshold for the inner loop. The algorithm iterates until the maximum change in coefficients is less than eps in the inner loop.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. if TRUE, the function prints out the fitting process.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_stepsize">stepSize</code></td>
<td>
<p>A step size for gradient-based optimization. if NULL, a step size is taken to be stepSizeAdj/mean(Li) where Li is a Lipschitz constant for ith sample</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_stepsizeadjustment">stepSizeAdjustment</code></td>
<td>
<p>A step size adjustment. By default, adjustment is 1 for GD and SGD, 1/8 for SVRG and 1/16 for SAG.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_batchsize">batchSize</code></td>
<td>
<p>A batch size. Default is 1.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_updatefrequency">updateFrequency</code></td>
<td>
<p>An update frequency of full gradient for method ==&quot;SVRG&quot;</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_samplingprobabilities">samplingProbabilities</code></td>
<td>
<p>sampling probabilities for each of samples for stochastic gradient-based optimization. if NULL, each sample is chosen proportionally to Li.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_method">method</code></td>
<td>
<p>Optimization method. Default is Coordinate Descent. CD for Coordinate Descent, GD for Gradient Descent, SGD for Stochastic Gradient Descent, SVRG for Stochastic Variance Reduction Gradient, SAG for Stochastic Averaging Gradient.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of cross-validation folds to be created.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_fitind">fitInd</code></td>
<td>
<p>A vector of indices of cross-validation models which will be fitted. Default is to fit the model for each of the cross-validation fold.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_ncores">nCores</code></td>
<td>
<p>Number of threads to be used for parallel computing. If nCores=0, it is set to be (the number of processors available-1) . Default value is 1.</p>
</td></tr>
<tr><td><code id="cv.grpPUlasso_+3A_trace">trace</code></td>
<td>
<p>An option for saving intermediate quantities when fitting a full dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cvm Mean cross-validation error
</p>
<p>cvsd Estimate of standard error of cvm
</p>
<p>cvcoef Coefficients for each of the fitted CV models
</p>
<p>cvstdcoef Coefficients in a standardized scale for each of the fitted CV models
</p>
<p>lambda The actual sequence of lambda values used.
</p>
<p>lambda.min Value of lambda that gives minimum cvm.
</p>
<p>lambda.1se The largest value of lambda such that the error is within 1 standard error of the minimum cvm.
</p>
<p>PUfit A fitted PUfit object for the full data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("simulPU")
fit&lt;-cv.grpPUlasso(X=simulPU$X,z=simulPU$z,py1=simulPU$truePY1)
</code></pre>

<hr>
<h2 id='deviances'>Deviance</h2><span id='topic+deviances'></span>

<h3>Description</h3>

<p>Calculate deviances at provided coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviances(X, z, py1, coefMat, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviances_+3A_x">X</code></td>
<td>
<p>Input matrix</p>
</td></tr>
<tr><td><code id="deviances_+3A_z">z</code></td>
<td>
<p>Response vector</p>
</td></tr>
<tr><td><code id="deviances_+3A_py1">py1</code></td>
<td>
<p>True prevalence Pr(Y=1)</p>
</td></tr>
<tr><td><code id="deviances_+3A_coefmat">coefMat</code></td>
<td>
<p>A coefficient matrix whose column corresponds to a set of coefficients</p>
</td></tr>
<tr><td><code id="deviances_+3A_weights">weights</code></td>
<td>
<p>observation weights. Default is 1 for each observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>deviances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("simulPU")
coef0&lt;-replicate(2,runif(ncol(simulPU$X)+1))
deviances(simulPU$X,simulPU$z,py1=simulPU$truePY1,coefMat = coef0)
</code></pre>

<hr>
<h2 id='grpPUlasso'>Solve PU problem with lasso or group lasso penalty.</h2><span id='topic+grpPUlasso'></span>

<h3>Description</h3>

<p>Fit a model using PUlasso algorithm over a regularization path. The regularization path is computed at a grid of values for the regularization parameter lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grpPUlasso(
  X,
  z,
  py1,
  initial_coef = NULL,
  group = 1:ncol(X),
  penalty = NULL,
  lambda = NULL,
  nlambda = 100,
  lambdaMinRatio = ifelse(N &lt; p, 0.05, 0.005),
  maxit = ifelse(method == "CD", 1000, N * 10),
  maxit_inner = 1e+05,
  weights = NULL,
  eps = 1e-04,
  inner_eps = 0.01,
  verbose = FALSE,
  stepSize = NULL,
  stepSizeAdjustment = NULL,
  batchSize = 1,
  updateFrequency = N,
  samplingProbabilities = NULL,
  method = c("CD", "GD", "SGD", "SVRG", "SAG"),
  trace = c("none", "param", "fVal", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grpPUlasso_+3A_x">X</code></td>
<td>
<p>Input matrix; each row is an observation. Can be a matrix or a sparse matrix.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_z">z</code></td>
<td>
<p>Response vector representing whether an observation is labeled or unlabeled.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_py1">py1</code></td>
<td>
<p>True prevalence Pr(Y=1)</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_initial_coef">initial_coef</code></td>
<td>
<p>A vector representing an initial point where we start PUlasso algorithm from.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_group">group</code></td>
<td>
<p>A vector representing grouping of the coefficients. For the least ambiguity, it is recommended if group is provided in the form of vector of consecutive ascending integers.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_penalty">penalty</code></td>
<td>
<p>penalty to be applied to the model. Default is sqrt(group size) for each of the group.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied sequence of lambda values. If unspecified, the function automatically generates its own lambda sequence based on nlambda and lambdaMinRatio.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of lambda values.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_lambdaminratio">lambdaMinRatio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max which leads to the intercept only model.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_maxit_inner">maxit_inner</code></td>
<td>
<p>Maximum number of iterations for a quadratic sub-problem for CD.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_weights">weights</code></td>
<td>
<p>observation weights. Default is 1 for each observation.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold for the outer loop. The algorithm iterates until the maximum change in coefficients is less than eps in the outer loop.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_inner_eps">inner_eps</code></td>
<td>
<p>Convergence threshold for the inner loop. The algorithm iterates until the maximum change in coefficients is less than eps in the inner loop.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. if TRUE, the function prints out the fitting process.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_stepsize">stepSize</code></td>
<td>
<p>A step size for gradient-based optimization. if NULL, a step size is taken to be stepSizeAdj/mean(Li) where Li is a Lipschitz constant for ith sample</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_stepsizeadjustment">stepSizeAdjustment</code></td>
<td>
<p>A step size adjustment. By default, adjustment is 1 for GD and SGD, 1/8 for SVRG and 1/16 for SAG.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_batchsize">batchSize</code></td>
<td>
<p>A batch size. Default is 1.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_updatefrequency">updateFrequency</code></td>
<td>
<p>An update frequency of full gradient for method ==&quot;SVRG&quot;</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_samplingprobabilities">samplingProbabilities</code></td>
<td>
<p>sampling probabilities for each of samples for stochastic gradient-based optimization. if NULL, each sample is chosen proportionally to Li.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_method">method</code></td>
<td>
<p>Optimization method. Default is Coordinate Descent. CD for Coordinate Descent, GD for Gradient Descent, SGD for Stochastic Gradient Descent, SVRG for Stochastic Variance Reduction Gradient, SAG for Stochastic Averaging Gradient.</p>
</td></tr>
<tr><td><code id="grpPUlasso_+3A_trace">trace</code></td>
<td>
<p>An option for saving intermediate quantities. All intermediate standardized-scale parameter estimates(trace==&quot;param&quot;), objective function values at each iteration(trace==&quot;fVal&quot;), or both(trace==&quot;all&quot;) are saved in optResult. Since this is computationally very heavy, it should be only used for decently small-sized dataset and small maxit. A default is &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coef A p by length(lambda) matrix of coefficients
</p>
<p>std_coef A p by length(lambda) matrix of coefficients in a standardized scale
</p>
<p>lambda The actual sequence of lambda values used.
</p>
<p>nullDev Null deviance defined to be 2*(logLik_sat -logLik_null)
</p>
<p>deviance Deviance defined to be 2*(logLik_sat -logLik(model))
</p>
<p>optResult A list containing the result of the optimization. fValues, subGradients contain objective function values and subgradient vectors at each lambda value. If trace = TRUE, corresponding intermediate quantities are saved as well.
</p>
<p>iters Number of iterations(EM updates) if method = &quot;CD&quot;. Number of steps taken otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("simulPU")
fit&lt;-grpPUlasso(X=simulPU$X,z=simulPU$z,py1=simulPU$truePY1)
</code></pre>

<hr>
<h2 id='simulPU'>simulated PU data</h2><span id='topic+simulPU'></span>

<h3>Description</h3>

<p>A simulated data for the illustration. 
Covariates <code class="reqn">x_i</code> are drawn from <code class="reqn">N(\mu,I_{5\times 5})</code> or <code class="reqn">N(-\mu,I_{5\times5})</code> with probability 0.5.
To make the first two variables active,<code class="reqn">\mu = [\mu_1,\dots,\mu_2,0,0,0]^T, \theta = [\theta_0,\dots,\theta_2,0,0,0]^T</code>
and we set <code class="reqn">\mu_i=1.5, \theta_i \sim Unif[0.5,1]</code>
Responses <code class="reqn">y_i</code> is simulated via <code class="reqn">P_\theta(y=1|x) = 1/exp(-\theta^Tx)</code>.
1000 observations are sampled from the sub-population of positives(y=1) and labeled, and another 1000 observations are sampled from the original population and unlabeled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('simulPU')
</code></pre>


<h3>Format</h3>

<p>A list containing model matrix X, true response y, labeled/unlabeled response vector z, and a true positive probability truePY1.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
