<!DOCTYPE html><html lang="en"><head><title>Help for package graphicalMCP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {graphicalMCP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#graphicalMCP-package'><p>graphicalMCP: Graphical Multiple Comparison Procedures</p></a></li>
<li><a href='#adjust_p_bonferroni'><p>Calculate adjusted p-values</p></a></li>
<li><a href='#adjust_weights_parametric'><p>Calculate adjusted hypothesis weights</p></a></li>
<li><a href='#as_initial_graph'><p>Convert between graphicalMCP, gMCP, and igraph graph classes</p></a></li>
<li><a href='#bonferroni'><p>Example graphs of commonly used multiple comparison procedures</p></a></li>
<li><a href='#c_value_function'><p>Calculate adjusted hypothesis weights for parametric tests</p></a></li>
<li><a href='#edge_pairs'><p>Find pairs of vertices that are connected in both directions</p></a></li>
<li><a href='#graph_calculate_power'><p>Calculate power values for a graphical multiple comparison procedure</p></a></li>
<li><a href='#graph_create'><p>Create the initial graph for a multiple comparison procedure</p></a></li>
<li><a href='#graph_generate_weights'><p>Generate the weighting strategy based on a graphical multiple comparison</p>
procedure</a></li>
<li><a href='#graph_rejection_orderings'><p>Find alternate rejection orderings (sequences) for shortcut tests</p></a></li>
<li><a href='#graph_test_closure'><p>Perform closed graphical multiple comparison procedures</p></a></li>
<li><a href='#graph_test_closure_fast'><p>Perform graphical multiple comparison procedures efficiently for power</p>
calculation</a></li>
<li><a href='#graph_test_shortcut'><p>Perform shortcut (sequentially rejective) graphical multiple comparison</p>
procedures</a></li>
<li><a href='#graph_update'><p>Obtain an updated graph by updating an initial graphical after deleting</p>
hypotheses</a></li>
<li><a href='#plot.initial_graph'><p>S3 plot method for class <code>initial_graph</code></p></a></li>
<li><a href='#plot.updated_graph'><p>S3 plot method for the class <code>updated_graph</code></p></a></li>
<li><a href='#print.graph_report'><p>S3 print method for the class <code>graph_report</code></p></a></li>
<li><a href='#print.initial_graph'><p>S3 print method for the class <code>initial_graph</code></p></a></li>
<li><a href='#print.power_report'><p>S3 print method for the class <code>power_report</code></p></a></li>
<li><a href='#print.updated_graph'><p>S3 print method for the class <code>updated_graph</code></p></a></li>
<li><a href='#test_input_val'><p>Validate inputs for testing and power simulations</p></a></li>
<li><a href='#test_values_bonferroni'><p>Organize outputs for testing an intersection hypothesis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graphical Multiple Comparison Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple comparison procedures (MCPs) control the familywise error
    rate in clinical trials. Graphical MCPs include many commonly used
    procedures as special cases; see Bretz et al. (2011)
    &lt;<a href="https://doi.org/10.1002%2Fbimj.201000239">doi:10.1002/bimj.201000239</a>&gt;, Lu (2016) &lt;<a href="https://doi.org/10.1002%2Fsim.6985">doi:10.1002/sim.6985</a>&gt;, and Xi et
    al. (2017) &lt;<a href="https://doi.org/10.1002%2Fbimj.201600233">doi:10.1002/bimj.201600233</a>&gt;. This package is a low-dependency
    implementation of graphical MCPs which allow mixed types of tests. It also
    includes power simulations and visualization of graphical MCPs.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/openpharma/graphicalMCP">https://github.com/openpharma/graphicalMCP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/openpharma/graphicalMCP/issues">https://github.com/openpharma/graphicalMCP/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixStats, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, dplyr, forcats, ggplot2, gMCP, gt, here, htmltools,
igraph, knitr, lrstat, prompt, rmarkdown, scales, testthat (&ge;
3.0.0), tibble, tictoc, tidyr, xfun</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-08 20:35:41 UTC; dxi1</td>
</tr>
<tr>
<td>Author:</td>
<td>Dong Xi [aut, cre],
  Ethan Brockmann [aut],
  Gilead Sciences, Inc. [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dong Xi &lt;dong.xi1@gilead.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-08 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='graphicalMCP-package'>graphicalMCP: Graphical Multiple Comparison Procedures</h2><span id='topic+graphicalMCP'></span><span id='topic+graphicalMCP-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Multiple comparison procedures (MCPs) control the familywise error rate in clinical trials. Graphical MCPs include many commonly used procedures as special cases; see Bretz et al. (2011) doi: <a href="https://doi.org/10.1002/bimj.201000239">10.1002/bimj.201000239</a>, Lu (2016) doi: <a href="https://doi.org/10.1002/sim.6985">10.1002/sim.6985</a>, and Xi et al. (2017) doi: <a href="https://doi.org/10.1002/bimj.201600233">10.1002/bimj.201600233</a>. This package is a low-dependency implementation of graphical MCPs which allow mixed types of tests. It also includes power simulations and visualization of graphical MCPs.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dong Xi <a href="mailto:dong.xi1@gilead.com">dong.xi1@gilead.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Ethan Brockmann <a href="mailto:ethan.brockmann@atorusresearch.com">ethan.brockmann@atorusresearch.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Gilead Sciences, Inc. [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/openpharma/graphicalMCP">https://github.com/openpharma/graphicalMCP</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/openpharma/graphicalMCP/issues">https://github.com/openpharma/graphicalMCP/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adjust_p_bonferroni'>Calculate adjusted p-values</h2><span id='topic+adjust_p_bonferroni'></span><span id='topic+adjust_p_parametric'></span><span id='topic+adjust_p_simes'></span>

<h3>Description</h3>

<p>For an intersection hypothesis, an adjusted p-value is the smallest
significance level at which the intersection hypothesis can be rejected.
The intersection hypothesis can be rejected if its adjusted p-value is less
than or equal to <code class="reqn">\alpha</code>. Currently, there are three test types
supported:
</p>

<ul>
<li><p> Bonferroni tests for <code><a href="#topic+adjust_p_bonferroni">adjust_p_bonferroni()</a></code>,
</p>
</li>
<li><p> Parametric tests for <code><a href="#topic+adjust_p_parametric">adjust_p_parametric()</a></code>,
</p>

<ul>
<li><p> Note that one-sided tests are required for parametric tests.
</p>
</li></ul>

</li>
<li><p> Simes tests for <code><a href="#topic+adjust_p_simes">adjust_p_simes()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>adjust_p_bonferroni(p, hypotheses)

adjust_p_parametric(
  p,
  hypotheses,
  test_corr = NULL,
  maxpts = 25000,
  abseps = 1e-06,
  releps = 0
)

adjust_p_simes(p, hypotheses)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_p_bonferroni_+3A_p">p</code></td>
<td>
<p>A numeric vector of p-values (unadjusted, raw), whose values should
be between 0 &amp; 1. The length should match the length of <code>hypotheses</code>.</p>
</td></tr>
<tr><td><code id="adjust_p_bonferroni_+3A_hypotheses">hypotheses</code></td>
<td>
<p>A numeric vector of hypothesis weights. Must be a vector of
values between 0 &amp; 1 (inclusive). The length should match the length of
<code>p</code>. The sum of hypothesis weights should not exceed 1.</p>
</td></tr>
<tr><td><code id="adjust_p_bonferroni_+3A_test_corr">test_corr</code></td>
<td>
<p>(Optional) A numeric matrix of correlations between test
statistics, which is needed to perform parametric tests using
<code><a href="#topic+adjust_p_parametric">adjust_p_parametric()</a></code>. The number of rows and columns of
this correlation matrix should match the length of <code>p</code>.</p>
</td></tr>
<tr><td><code id="adjust_p_bonferroni_+3A_maxpts">maxpts</code></td>
<td>
<p>(Optional) An integer scalar for the maximum number of function
values, which is needed to perform parametric tests using the
<code>mvtnorm::GenzBretz</code> algorithm. The default is 25000.</p>
</td></tr>
<tr><td><code id="adjust_p_bonferroni_+3A_abseps">abseps</code></td>
<td>
<p>(Optional) A numeric scalar for the absolute error tolerance,
which is needed to perform parametric tests using the <code>mvtnorm::GenzBretz</code>
algorithm. The default is 1e-6.</p>
</td></tr>
<tr><td><code id="adjust_p_bonferroni_+3A_releps">releps</code></td>
<td>
<p>(Optional) A numeric scalar for the relative error tolerance
as double, which is needed to perform parametric tests using the
<code>mvtnorm::GenzBretz</code> algorithm. The default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single adjusted p-value for the intersection hypothesis.
</p>


<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W., and Posch, M. (2009). A graphical
approach to sequentially rejective multiple test procedures.
<em>Statistics in Medicine</em>, 28(4), 586-604.
</p>
<p>Lu, K. (2016). Graphical approaches using a Bonferroni mixture of weighted
Simes tests. <em>Statistics in Medicine</em>, 35(22), 4041-4055.
</p>
<p>Xi, D., Glimm, E., Maurer, W., and Bretz, F. (2017). A unified framework
for weighted parametric multiple test procedures.
<em>Biometrical Journal</em>, 59(5), 918-931.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjust_weights_parametric">adjust_weights_parametric()</a></code> for adjusted hypothesis weights using
parametric tests, <code><a href="#topic+adjust_weights_simes">adjust_weights_simes()</a></code> for adjusted hypothesis weights
using Simes tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hypotheses &lt;- c(H1 = 0.5, H2 = 0.25, H3 = 0.25)
p &lt;- c(0.019, 0.025, 0.05)
adjust_p_bonferroni(p, hypotheses)
set.seed(1234)
hypotheses &lt;- c(H1 = 0.5, H2 = 0.25, H3 = 0.25)
p &lt;- c(0.019, 0.025, 0.05)
# Using the `mvtnorm::GenzBretz` algorithm
corr &lt;- matrix(0.5, nrow = 3, ncol = 3)
diag(corr) &lt;- 1
adjust_p_parametric(p, hypotheses, corr)
hypotheses &lt;- c(H1 = 0.5, H2 = 0.25, H3 = 0.25)
p &lt;- c(0.019, 0.025, 0.05)
adjust_p_simes(p, hypotheses)
</code></pre>

<hr>
<h2 id='adjust_weights_parametric'>Calculate adjusted hypothesis weights</h2><span id='topic+adjust_weights_parametric'></span><span id='topic+adjust_weights_simes'></span>

<h3>Description</h3>

<p>An intersection hypothesis can be rejected if its p-values are less than or
equal to their adjusted significance levels, which are their adjusted
hypothesis weights times <code class="reqn">\alpha</code>. For Bonferroni tests, their adjusted
hypothesis weights are their hypothesis weights of the intersection
hypothesis. Additional adjustment is needed for parametric and Simes tests:
</p>

<ul>
<li><p> Parametric tests for <code><a href="#topic+adjust_weights_parametric">adjust_weights_parametric()</a></code>,
</p>

<ul>
<li><p> Note that one-sided tests are required for parametric tests.
</p>
</li></ul>

</li>
<li><p> Simes tests for <code><a href="#topic+adjust_weights_simes">adjust_weights_simes()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>adjust_weights_parametric(
  matrix_weights,
  matrix_intersections,
  test_corr,
  alpha,
  test_groups,
  maxpts = 25000,
  abseps = 1e-06,
  releps = 0
)

adjust_weights_simes(matrix_weights, p, test_groups)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_weights_parametric_+3A_matrix_weights">matrix_weights</code></td>
<td>
<p>(Optional) A matrix of hypothesis weights of all
intersection hypotheses. This can be obtained as the second half of columns
from the output of <code><a href="#topic+graph_generate_weights">graph_generate_weights()</a></code>.</p>
</td></tr>
<tr><td><code id="adjust_weights_parametric_+3A_matrix_intersections">matrix_intersections</code></td>
<td>
<p>(Optional) A matrix of hypothesis indicators of
all intersection hypotheses. This can be obtained as the first half of
columns from the output of <code><a href="#topic+graph_generate_weights">graph_generate_weights()</a></code>.</p>
</td></tr>
<tr><td><code id="adjust_weights_parametric_+3A_test_corr">test_corr</code></td>
<td>
<p>(Optional) A numeric matrix of correlations between test
statistics, which is needed to perform parametric tests using
<code><a href="#topic+adjust_weights_parametric">adjust_weights_parametric()</a></code>. The number of rows and columns of
this correlation matrix should match the length of <code>p</code>.</p>
</td></tr>
<tr><td><code id="adjust_weights_parametric_+3A_alpha">alpha</code></td>
<td>
<p>(Optional) A numeric value of the overall significance level,
which should be between 0 &amp; 1. The default is 0.025 for one-sided
hypothesis testing problems; another common choice is 0.05 for two-sided
hypothesis testing problems. Note when parametric tests are used, only
one-sided tests are supported.</p>
</td></tr>
<tr><td><code id="adjust_weights_parametric_+3A_test_groups">test_groups</code></td>
<td>
<p>(Optional) A list of numeric vectors specifying hypotheses
to test together. Grouping is needed to correctly perform Simes and
parametric tests.</p>
</td></tr>
<tr><td><code id="adjust_weights_parametric_+3A_maxpts">maxpts</code></td>
<td>
<p>(Optional) An integer scalar for the maximum number of function
values, which is needed to perform parametric tests using the
<code>mvtnorm::GenzBretz</code> algorithm. The default is 25000.</p>
</td></tr>
<tr><td><code id="adjust_weights_parametric_+3A_abseps">abseps</code></td>
<td>
<p>(Optional) A numeric scalar for the absolute error tolerance,
which is needed to perform parametric tests using the <code>mvtnorm::GenzBretz</code>
algorithm. The default is 1e-6.</p>
</td></tr>
<tr><td><code id="adjust_weights_parametric_+3A_releps">releps</code></td>
<td>
<p>(Optional) A numeric scalar for the relative error tolerance
as double, which is needed to perform parametric tests using the
<code>mvtnorm::GenzBretz</code> algorithm. The default is 0.</p>
</td></tr>
<tr><td><code id="adjust_weights_parametric_+3A_p">p</code></td>
<td>
<p>(Optional) A numeric vector of p-values (unadjusted, raw), whose
values should be between 0 &amp; 1. The length should match the number of
columns of <code>matrix_weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+adjust_weights_parametric">adjust_weights_parametric()</a></code> returns a matrix with the same
dimensions as <code>matrix_weights</code>, whose hypothesis weights have been
adjusted according to parametric tests.
</p>
</li>
<li> <p><code><a href="#topic+adjust_weights_simes">adjust_weights_simes()</a></code> returns a matrix with the same
dimensions as <code>matrix_weights</code>, whose hypothesis weights have been
adjusted according to Simes tests.
</p>
</li></ul>



<h3>References</h3>

<p>Lu, K. (2016). Graphical approaches using a Bonferroni mixture of weighted
Simes tests. <em>Statistics in Medicine</em>, 35(22), 4041-4055.
</p>
<p>Xi, D., Glimm, E., Maurer, W., and Bretz, F. (2017). A unified framework
for weighted parametric multiple test procedures.
<em>Biometrical Journal</em>, 59(5), 918-931.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjust_p_parametric">adjust_p_parametric()</a></code> for adjusted p-values using parametric tests,
<code><a href="#topic+adjust_p_simes">adjust_p_simes()</a></code> for adjusted p-values using Simes tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.025
p &lt;- c(0.018, 0.01, 0.105, 0.006)
num_hyps &lt;- length(p)
g &lt;- bonferroni_holm(rep(1 / 4, 4))
weighting_strategy &lt;- graph_generate_weights(g)
matrix_intersections &lt;- weighting_strategy[, seq_len(num_hyps)]
matrix_weights &lt;- weighting_strategy[, -seq_len(num_hyps)]

set.seed(1234)
adjust_weights_parametric(
  matrix_weights = matrix_weights,
  matrix_intersections = matrix_intersections,
  test_corr = diag(4),
  alpha = alpha,
  test_groups = list(1:4)
)
alpha &lt;- 0.025
p &lt;- c(0.018, 0.01, 0.105, 0.006)
num_hyps &lt;- length(p)
g &lt;- bonferroni_holm(rep(1 / 4, 4))
weighting_strategy &lt;- graph_generate_weights(g)
matrix_intersections &lt;- weighting_strategy[, seq_len(num_hyps)]
matrix_weights &lt;- weighting_strategy[, -seq_len(num_hyps)]

adjust_weights_simes(
  matrix_weights = matrix_weights,
  p = p,
  test_groups = list(1:4)
)
</code></pre>

<hr>
<h2 id='as_initial_graph'>Convert between graphicalMCP, gMCP, and igraph graph classes</h2><span id='topic+as_initial_graph'></span><span id='topic+as_initial_graph.graphMCP'></span><span id='topic+as_initial_graph.igraph'></span><span id='topic+as_graphMCP'></span><span id='topic+as_graphMCP.initial_graph'></span><span id='topic+as_igraph'></span><span id='topic+as_igraph.initial_graph'></span>

<h3>Description</h3>

<p>Graph objects have different structures and attributes in <code>graphicalMCP</code>,
<code>gMCP</code>, and <code>igraph</code> R packages. These functions convert between different
classes to increase compatibility.
</p>
<p>Note that <code>igraph</code> and <code>gMCP</code> have additional attributes for vertices, edges,
or a graph itself. These conversion functions only handle attributes related
to hypothesis names, hypothesis weights and transition weights. Other
attributes will be dropped when converting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_initial_graph(graph)

## S3 method for class 'graphMCP'
as_initial_graph(graph)

## S3 method for class 'igraph'
as_initial_graph(graph)

as_graphMCP(graph)

## S3 method for class 'initial_graph'
as_graphMCP(graph)

as_igraph(graph)

## S3 method for class 'initial_graph'
as_igraph(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_initial_graph_+3A_graph">graph</code></td>
<td>
<p>An <code>initial_graph</code> object from the <code>graphicalMCP</code> package, a
<code>graphMCP</code> object from the <code>gMCP</code> package, or an <code>igraph</code> object from the
<code>igraph</code> package, depending on the conversion type.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>as_graphMCP()</code> returns a <code>graphMCP</code> object for the <code>gMCP</code> package.
</p>
</li>
<li> <p><code>as_igraph()</code> returns an <code>igraph</code> object for the <code>igraph</code> package.
</p>
</li>
<li> <p><code>as_initial_graph()</code> returns an <code>initial_graph</code> object for the
<code>graphicalMCP</code> package.
</p>
</li></ul>



<h3>References</h3>

<p>Csardi, G., Nepusz, T., Traag, V., Horvat, S., Zanini, F., Noom, D.,
and Mueller, K. (2024). <em>igraph</em>: Network analysis and visualization
in R. R package version 2.0.3. <a href="https://CRAN.R-project.org/package=igraph">https://CRAN.R-project.org/package=igraph</a>.
</p>
<p>Rohmeyer, K., and Klinglmueller, K. (2024). <em>gMCP</em>: Graph based
multiple test procedures. R package version 0.8-17.
<a href="https://cran.r-project.org/package=gMCP">https://cran.r-project.org/package=gMCP</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_create">graph_create()</a></code> for the initial graph used in the <code>graphicalMCP</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_graphicalMCP &lt;- random_graph(5)

if (requireNamespace("gMCP", quietly = TRUE)) {
  g_gMCP &lt;- as_graphMCP(g_graphicalMCP)

  all.equal(g_graphicalMCP, as_initial_graph(g_gMCP))
}

if (requireNamespace("igraph", quietly = TRUE)) {
  g_igraph &lt;- as_igraph(g_graphicalMCP)

  all.equal(g_graphicalMCP, as_initial_graph(g_igraph))
}
</code></pre>

<hr>
<h2 id='bonferroni'>Example graphs of commonly used multiple comparison procedures</h2><span id='topic+bonferroni'></span><span id='topic+bonferroni_holm'></span><span id='topic+huque_etal'></span><span id='topic+fallback'></span><span id='topic+fallback_improved_1'></span><span id='topic+fallback_improved_2'></span><span id='topic+fixed_sequence'></span><span id='topic+simple_successive_1'></span><span id='topic+simple_successive_2'></span><span id='topic+random_graph'></span><span id='topic+two_doses_two_primary_two_secondary'></span><span id='topic+three_doses_two_primary_two_secondary'></span>

<h3>Description</h3>

<p>Built-in functions to quickly generate select graphical multiple comparison
procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bonferroni(hypotheses, hyp_names = NULL)

bonferroni_holm(hypotheses, hyp_names = NULL)

huque_etal(hyp_names = NULL)

fallback(hypotheses, hyp_names = NULL)

fallback_improved_1(hypotheses, hyp_names = NULL)

fallback_improved_2(hypotheses, epsilon = 1e-04, hyp_names = NULL)

fixed_sequence(num_hyps, hyp_names = NULL)

simple_successive_1(hyp_names = NULL)

simple_successive_2(hyp_names = NULL)

random_graph(num_hyps, hyp_names = NULL)

two_doses_two_primary_two_secondary(hyp_names = NULL)

three_doses_two_primary_two_secondary(hyp_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bonferroni_+3A_hypotheses">hypotheses</code></td>
<td>
<p>(Optional) A numeric vector of hypothesis weights in a
graphical multiple comparison procedure. Must be a vector of values
between 0 &amp; 1 (inclusive). The length should match <code>num_hyps</code> and the
length of <code>hyp_names</code>. The sum of hypothesis weights should not exceed 1.</p>
</td></tr>
<tr><td><code id="bonferroni_+3A_hyp_names">hyp_names</code></td>
<td>
<p>(Optional) A character vector of hypothesis names. The
length should match <code>num_hyps</code> and the length of <code>hypotheses</code>. If
<code>hyp_names</code> are not specified, hypotheses will be named sequentially as
H1, H2, .......</p>
</td></tr>
<tr><td><code id="bonferroni_+3A_epsilon">epsilon</code></td>
<td>
<p>(Optional) A numeric scalar indicating the value of the
<code class="reqn">\epsilon</code> edge. This should be a much smaller value than hypothesis
and transition weights. The default is 1e-4.</p>
</td></tr>
<tr><td><code id="bonferroni_+3A_num_hyps">num_hyps</code></td>
<td>
<p>(Optional) Number of hypotheses in a graphical multiple
comparison procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object as returned by <code><a href="#topic+graph_create">graph_create()</a></code>.
</p>


<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W., and Posch, M. (2009). A graphical
approach to sequentially rejective multiple test procedures.
<em>Statistics in Medicine</em>, 28(4), 586-604.
</p>
<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>
<p>Huque, M. F., Alosh, M., and Bhore, R. (2011). Addressing multiplicity
issues of a composite endpoint and its components in clinical trials.
<em>Journal of Biopharmaceutical Statistics</em>, 21(4), 610-634.
</p>
<p>Maurer, W., Hothorn, L., and Lehmacher, W. (1995). Multiple comparisons in
drug clinical trials and preclinical assays: a-priori ordered hypotheses.
<em>Biometrie in der chemisch-pharmazeutischen Industrie</em>, 6, 3-18.
</p>
<p>Westfall, P. H., and Krishen, A. (2001). Optimally weighted, fixed sequence
and gatekeeper multiple testing procedures.
<em>Journal of Statistical Planning and Inference</em>, 99(1), 25-40.
</p>
<p>Wiens, B. L. (2003). A fixed sequence Bonferroni procedure for testing
multiple endpoints. <em>Pharmaceutical Statistics</em>, 2(3), 211-215.
</p>
<p>Wiens, B. L., and Dmitrienko, A. (2005). The fallback procedure for
evaluating a single family of hypotheses.
<em>Journal of Biopharmaceutical Statistics</em>, 15(6), 929-942.
</p>
<p>Xi, D., and Bretz, F. (2019). Symmetric graphs for equally weighted tests,
with application to the Hochberg procedure. <em>Statistics in Medicine</em>,
38(27), 5268-5282.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_create">graph_create()</a></code> for a general way to create the initial graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bretz et al. (2009)
bonferroni(hypotheses = rep(1 / 3, 3))
# Bretz et al. (2009)
bonferroni_holm(hypotheses = rep(1 / 3, 3))
# Huque et al. (2011)
huque_etal()
# Wiens (2003)
fallback(hypotheses = rep(1 / 3, 3))
# Wiens and Dmitrienko (2005)
fallback_improved_1(hypotheses = rep(1 / 3, 3))
# Bretz et al. (2009)
fallback_improved_2(hypotheses = rep(1 / 3, 3))
# Maurer et al. (1995); Westfall and Krishen (2001)
fixed_sequence(num_hyps = 3)
# Figure 1 in Bretz et al. (2011)
simple_successive_1()
# Figure 4 in Bretz et al. (2011)
simple_successive_2()
# Create a random graph with three hypotheses
random_graph(num_hyps = 3)
# Figure 6 in Xi and Bretz et al. (2019)
two_doses_two_primary_two_secondary()
# Add another dose to Figure 6 in Xi and Bretz et al. (2019)
three_doses_two_primary_two_secondary()
</code></pre>

<hr>
<h2 id='c_value_function'>Calculate adjusted hypothesis weights for parametric tests</h2><span id='topic+c_value_function'></span><span id='topic+solve_c_parametric'></span>

<h3>Description</h3>

<p>An intersection hypothesis can be rejected if its p-values are less than or
equal to their adjusted significance levels, which are their adjusted
hypothesis weights times <code class="reqn">\alpha</code>. For Bonferroni tests, their adjusted
hypothesis weights are their hypothesis weights of the intersection
hypothesis. Additional adjustment is needed for parametric tests:
</p>

<ul>
<li><p> Parametric tests for <code><a href="#topic+adjust_weights_parametric">adjust_weights_parametric()</a></code>,
</p>

<ul>
<li><p> Note that one-sided tests are required for parametric tests.
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>c_value_function(
  x,
  hypotheses,
  test_corr,
  alpha,
  maxpts = 25000,
  abseps = 1e-06,
  releps = 0
)

solve_c_parametric(
  hypotheses,
  test_corr,
  alpha,
  maxpts = 25000,
  abseps = 1e-06,
  releps = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_value_function_+3A_x">x</code></td>
<td>
<p>The root to solve for with <code>stats::uniroot()</code>.</p>
</td></tr>
<tr><td><code id="c_value_function_+3A_hypotheses">hypotheses</code></td>
<td>
<p>A numeric vector of hypothesis weights. Must be a vector of
values between 0 &amp; 1 (inclusive). The sum of hypothesis weights should not
exceed 1.</p>
</td></tr>
<tr><td><code id="c_value_function_+3A_test_corr">test_corr</code></td>
<td>
<p>(Optional) A numeric matrix of correlations between test
statistics, which is needed to perform parametric tests using
<code><a href="#topic+adjust_weights_parametric">adjust_weights_parametric()</a></code>. The number of rows and columns of
this correlation matrix should match the length of <code>p</code>.</p>
</td></tr>
<tr><td><code id="c_value_function_+3A_alpha">alpha</code></td>
<td>
<p>(Optional) A numeric value of the overall significance level,
which should be between 0 &amp; 1. The default is 0.025 for one-sided
hypothesis testing problems; another common choice is 0.05 for two-sided
hypothesis testing problems. Note when parametric tests are used, only
one-sided tests are supported.</p>
</td></tr>
<tr><td><code id="c_value_function_+3A_maxpts">maxpts</code></td>
<td>
<p>(Optional) An integer scalar for the maximum number of function
values, which is needed to perform parametric tests using the
<code>mvtnorm::GenzBretz</code> algorithm. The default is 25000.</p>
</td></tr>
<tr><td><code id="c_value_function_+3A_abseps">abseps</code></td>
<td>
<p>(Optional) A numeric scalar for the absolute error tolerance,
which is needed to perform parametric tests using the <code>mvtnorm::GenzBretz</code>
algorithm. The default is 1e-6.</p>
</td></tr>
<tr><td><code id="c_value_function_+3A_releps">releps</code></td>
<td>
<p>(Optional) A numeric scalar for the relative error tolerance
as double, which is needed to perform parametric tests using the
<code>mvtnorm::GenzBretz</code> algorithm. The default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>c_value_function()</code> returns the difference between
<code class="reqn">\alpha</code> and the Type I error of the parametric test with the <code class="reqn">c</code>
value of <code>x</code>, adjusted for the correlation between test statistics using
parametric tests based on equation (6) of Xi et al. (2017).
</p>
</li>
<li> <p><code>solve_c_parametric()</code> returns the c value adjusted for the
correlation between test statistics using parametric tests based on
equation (6) of Xi et al. (2017).
</p>
</li></ul>



<h3>References</h3>

<p>Xi, D., Glimm, E., Maurer, W., and Bretz, F. (2017). A unified framework
for weighted parametric multiple test procedures.
<em>Biometrical Journal</em>, 59(5), 918-931.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjust_weights_parametric">adjust_weights_parametric()</a></code> for adjusted hypothesis weights using
parametric tests.
</p>

<hr>
<h2 id='edge_pairs'>Find pairs of vertices that are connected in both directions</h2><span id='topic+edge_pairs'></span>

<h3>Description</h3>

<p>For an initial graph, find pairs of hypotheses that are connected in both
directions. This is used to plot graphs using <code><a href="#topic+plot.initial_graph">plot.initial_graph()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_pairs(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge_pairs_+3A_graph">graph</code></td>
<td>
<p>An initial graph as returned by <code><a href="#topic+graph_create">graph_create()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vertex pairs which are connected in both directions. NULL
if no such pairs are found.
</p>

<hr>
<h2 id='graph_calculate_power'>Calculate power values for a graphical multiple comparison procedure</h2><span id='topic+graph_calculate_power'></span>

<h3>Description</h3>

<p>Under the alternative hypotheses, the distribution of test statistics is
assumed to be a multivariate normal distribution. Given this distribution,
this function calculates power values for a graphical multiple comparison
procedure. By default, it calculate the local power, which is the probability
to reject an individual hypothesis, the probability to reject at least one
hypothesis, the probability to reject all hypotheses, the expected number of
rejections, and the probability of user-defined success criteria. See
<code>vignette("shortcut-testing")</code> and <code>vignette("closed-testing")</code> for more
illustration of power calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_calculate_power(
  graph,
  alpha = 0.025,
  power_marginal = rep(alpha, length(graph$hypotheses)),
  test_groups = list(seq_along(graph$hypotheses)),
  test_types = c("bonferroni"),
  test_corr = rep(list(NA), length(test_types)),
  sim_n = 1e+05,
  sim_corr = diag(length(graph$hypotheses)),
  sim_success = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_calculate_power_+3A_graph">graph</code></td>
<td>
<p>An initial graph as returned by <code><a href="#topic+graph_create">graph_create()</a></code>.</p>
</td></tr>
<tr><td><code id="graph_calculate_power_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value of the one-sided overall significance level,
which should be between 0 &amp; 1. The default is 0.025 for one-sided
hypothesis testing. Note that only one-sided tests are supported.</p>
</td></tr>
<tr><td><code id="graph_calculate_power_+3A_power_marginal">power_marginal</code></td>
<td>
<p>A numeric vector of marginal power values to use when
simulating p-values. See Details for more on the simulation process.</p>
</td></tr>
<tr><td><code id="graph_calculate_power_+3A_test_groups">test_groups</code></td>
<td>
<p>A list of numeric vectors specifying hypotheses to test
together. Grouping is needed to correctly perform Simes and parametric
tests.</p>
</td></tr>
<tr><td><code id="graph_calculate_power_+3A_test_types">test_types</code></td>
<td>
<p>A character vector of test types to apply to each test
group. This is needed to correctly perform Simes and parametric
tests. The length should match the number of elements in <code>test_groups</code>.</p>
</td></tr>
<tr><td><code id="graph_calculate_power_+3A_test_corr">test_corr</code></td>
<td>
<p>(Optional) A list of numeric correlation matrices. Each
entry in the list should correspond to each test group. For a test group
using Bonferroni or Simes tests, its corresponding entry in <code>test_corr</code>
should be <code>NA</code>. For a test group using parametric tests, its
corresponding entry in <code>test_corr</code> should be a numeric correlation matrix
specifying the correlation between test statistics for hypotheses in this
test group. The length should match the number of elements in
<code>test_groups</code>.</p>
</td></tr>
<tr><td><code id="graph_calculate_power_+3A_sim_n">sim_n</code></td>
<td>
<p>An integer scalar specifying the number of simulations. The
default is 1e5.</p>
</td></tr>
<tr><td><code id="graph_calculate_power_+3A_sim_corr">sim_corr</code></td>
<td>
<p>A numeric matrix of correlations between test statistics for
all hypotheses. The dimensions should match the number of hypotheses in
<code>graph</code>.</p>
</td></tr>
<tr><td><code id="graph_calculate_power_+3A_sim_success">sim_success</code></td>
<td>
<p>A list of user-defined functions to specify the success
criteria. Functions must take one simulation's logical vector of results as
an input, and return a length-one logical vector. For instance, if
&quot;success&quot; means rejecting hypotheses 1 and 2, use <code>sim_success = list("1 and 2" = function(x) x[1] &amp;&amp; x[2])</code>. If the list is not named, the function
body will be used as the name. Lambda functions also work starting with R
4.1, e.g. <code style="white-space: pre;">&#8288;sim_success = list(\(x) x[3] || x[4])&#8288;</code>.</p>
</td></tr>
<tr><td><code id="graph_calculate_power_+3A_verbose">verbose</code></td>
<td>
<p>A logical scalar specifying whether the details of power
simulations should be included in results. The default is <code>verbose = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>power_report</code> object with a list of 3 elements:
</p>

<ul>
<li> <p><code>inputs</code> - Input parameters, which is a list of:
</p>

<ul>
<li> <p><code>graph</code> - Initial graph,
</p>
</li>
<li> <p><code>alpha</code> - Overall significance level,
</p>
</li>
<li> <p><code>test_groups</code> - Groups of hypotheses for different types of tests,
</p>
</li>
<li> <p><code>test_types</code> - Different types of tests,
</p>
</li>
<li> <p><code>test_corr</code> - Correlation matrices for parametric tests,
</p>
</li>
<li> <p><code>sim_n</code> - Number of simulations,
</p>
</li>
<li> <p><code>power_marginal</code> - Marginal power of all hypotheses
</p>
</li>
<li> <p><code>sim_corr</code> - Correlation matrices for simulations,
</p>
</li>
<li> <p><code>sim_success</code> - User-defined success criteria.
</p>
</li></ul>

</li>
<li> <p><code>power</code> - A list of power values
</p>

<ul>
<li> <p><code>power_local</code> - Local power of all hypotheses, which is the proportion
of simulations in which each hypothesis is rejected,
</p>
</li>
<li> <p><code>rejection_expected</code> - Expected (average) number of rejected hypotheses,
</p>
</li>
<li> <p><code>power_at_least_1</code> - Power to reject at least one hypothesis,
</p>
</li>
<li> <p><code>power_all</code> - Power to reject all hypotheses,
</p>
</li>
<li> <p><code>power_success</code> - Power of user-defined success, which is the
proportion of simulations in which the user-defined success criterion
</p>
</li>
<li> <p><code>sim_success</code> is met.
</p>
</li></ul>

</li>
<li> <p><code>details</code> - An optional list of datasets showing simulated p-values and
results for each simulation.
</p>
</li></ul>



<h3>Simulation details</h3>

<p>The power calculation is based on simulations. The distribution to simulate
from is determined as a multivariate normal distribution by <code>power_marginal</code>
and <code>sim_corr</code>. In particular, <code>power_marginal</code> is a vector of marginal
power values for all hypotheses. The marginal power is the power to reject
the null hypothesis at the significance level <code>alpha</code>
<em>without multiplicity adjustment</em>. This value could be readily available from
standard software and other R packages. Then we can determine the mean of the
multivariate normal distribution as
</p>
<p style="text-align: center;"><code class="reqn">\Phi^{-1}\left(1-\alpha\right)-\Phi^{-1}\left(1-d_i\right)</code>
</p>
<p>,
which is often called the non-centrality parameter or the drift parameter.
Here <code class="reqn">d_i</code> is the marginal power <code>power_marginal</code> of hypothesis <code class="reqn">i</code>.
Given the correlation matrix <code>sim_corr</code>, we can simulate from this
multivariate normal distribution using the <code>mvtnorm</code> R package (Genz and
Bretz, 2009).
</p>
<p>Each set simulated values can be used to calculate the corresponding
one-sided p-values. Then this set of p-values are plugged into the graphical
multiple comparison procedure to determine which hypotheses are rejected.
This process is repeated <code>n_sim</code> times to produce the power values as the
proportion of simulations in which a particular success criterion is met.
</p>


<h3>References</h3>

<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011a). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>
<p>Bretz, F., Maurer, W., and Hommel, G. (2011b). Test and power
considerations for multiple endpoint analyses using sequentially rejective
graphical procedures. <em>Statistics in Medicine</em>, 30(13), 1489-1501.
</p>
<p>Genz, A., and Bretz, F. (2009). <em>Computation of Multivariate Normal
and t Probabilities</em>, series Lecture Notes in Statistics. Springer-Verlag,
Heidelberg.
</p>
<p>Lu, K. (2016). Graphical approaches using a Bonferroni mixture of weighted
Simes tests. <em>Statistics in Medicine</em>, 35(22), 4041-4055.
</p>
<p>Xi, D., Glimm, E., Maurer, W., and Bretz, F. (2017). A unified framework
for weighted parametric multiple test procedures.
<em>Biometrical Journal</em>, 59(5), 918-931.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 4 in Bretz et al. (2011a).
alpha &lt;- 0.025
hypotheses &lt;- c(0.5, 0.5, 0, 0)
delta &lt;- 0.5
transitions &lt;- rbind(
  c(0, delta, 1 - delta, 0),
  c(delta, 0, 0, 1 - delta),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

marginal_power &lt;- c(0.8, 0.8, 0.7, 0.9)
corr1 &lt;- matrix(0.5, nrow = 2, ncol = 2)
diag(corr1) &lt;- 1
corr &lt;- rbind(
  cbind(corr1, 0.5 * corr1),
  cbind(0.5 * corr1, corr1)
)
success_fns &lt;- list(
  # Probability to reject both H1 and H2
  `H1andH2` = function(x) x[1] &amp; x[2],
  # Probability to reject both (H1 and H3) or (H2 and H4)
  `(H1andH3)or(H2andH4)` = function(x) (x[1] &amp; x[3]) | (x[2] &amp; x[4])
)
set.seed(1234)
# Bonferroni tests
# Reduce the number of simulations to save time for package compilation
power_output &lt;- graph_calculate_power(
  g,
  alpha,
  sim_corr = corr,
  sim_n = 1e2,
  power_marginal = marginal_power,
  sim_success = success_fns
)

# Parametric tests for H1 and H2; Simes tests for H3 and H4
# User-defined success: to reject H1 or H2; to reject H1 and H2
# Reduce the number of simulations to save time for package compilation
graph_calculate_power(
  g,
  alpha,
  test_groups = list(1:2, 3:4),
  test_types = c("parametric", "simes"),
  test_corr = list(corr1, NA),
  sim_n = 1e2,
  sim_success = list(
    function(.) .[1] || .[2],
    function(.) .[1] &amp;&amp; .[2]
  )
)

</code></pre>

<hr>
<h2 id='graph_create'>Create the initial graph for a multiple comparison procedure</h2><span id='topic+graph_create'></span>

<h3>Description</h3>

<p>A graphical multiple comparison procedure is represented by 1) a vector of
initial hypothesis weights <code>hypotheses</code>, and 2) a matrix of initial
transition weights <code>transitions</code>. This function creates the initial graph
object using hypothesis weights and transition weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_create(hypotheses, transitions, hyp_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_create_+3A_hypotheses">hypotheses</code></td>
<td>
<p>A numeric vector of hypothesis weights in a graphical
multiple comparison procedure. Must be a vector of values between 0 &amp; 1
(inclusive). The length should match the row and column lengths of
<code>transitions</code>. The sum of hypothesis weights should not exceed 1.</p>
</td></tr>
<tr><td><code id="graph_create_+3A_transitions">transitions</code></td>
<td>
<p>A numeric matrix of transition weights between hypotheses
in a graphical multiple comparison procedure. Must be a square matrix of
values between 0 &amp; 1 (inclusive). The row and column lengths should match
the length of <code>hypotheses</code>. Each row (Transition weights leaving a
hypothesis) can sum to no more than 1. The diagonal entries (Transition
weights from a hypothesis to itself) must be all 0s.</p>
</td></tr>
<tr><td><code id="graph_create_+3A_hyp_names">hyp_names</code></td>
<td>
<p>(Optional) A character vector of hypothesis names. If not
provided, names from <code>hypotheses</code> and <code>transitions</code> will be used. If names
are not specified, hypotheses will be named sequentially as H1, H2, .......</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>initial_graph</code> with a list of 2 elements:
</p>

<ul>
<li><p> Hypothesis weights <code>hypotheses</code>.
</p>
</li>
<li><p> Transition weights <code>transitions</code>.
</p>
</li></ul>



<h3>Validation of inputs</h3>

<p>Inputs are also validated to make sure of the validity of the graph:
</p>

<ul>
<li><p> Hypothesis weights <code>hypotheses</code> are numeric.
</p>
</li>
<li><p> Transition weights <code>transitions</code> are numeric.
</p>
</li>
<li><p> Length of <code>hypotheses</code> and dimensions of <code>transitions</code> match.
</p>
</li>
<li><p> Hypothesis weights <code>hypotheses</code> must be non-negative and sum to no more
than 1.
</p>
</li>
<li><p> Transition weights <code>transitions</code>:
</p>

<ul>
<li><p> Values must be non-negative.
</p>
</li>
<li><p> Rows must sum to no more than 1.
</p>
</li>
<li><p> Diagonal entries must be all 0.
</p>
</li></ul>

</li>
<li><p> Hypothesis names <code>hyp_names</code> override names in <code>hypotheses</code> or
<code>transitions</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W., and Posch, M. (2009). A graphical
approach to sequentially rejective multiple test procedures.
<em>Statistics in Medicine</em>, 28(4), 586-604.
</p>
<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_update">graph_update()</a></code> for the updated graph after hypotheses being deleted
from the initial graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 1 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
hyp_names &lt;- c("H11", "H12", "H21", "H22")
g &lt;- graph_create(hypotheses, transitions, hyp_names)
g

# Explicit names override names in `hypotheses` (with a warning)
hypotheses &lt;- c(h1 = 0.5, h2 = 0.5, h3 = 0, h4 = 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions, hyp_names)
g

# Use names in `transitions`
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  H1 = c(0, 0, 1, 0),
  H2 = c(0, 0, 0, 1),
  H3 = c(0, 1, 0, 0),
  H4 = c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)
g

# Unmatched names in `hypotheses` and `transitions` (with an error)
hypotheses &lt;- c(h1 = 0.5, h2 = 0.5, h3 = 0, h4 = 0)
transitions &lt;- rbind(
  H1 = c(0, 0, 1, 0),
  H2 = c(0, 0, 0, 1),
  H3 = c(0, 1, 0, 0),
  H4 = c(1, 0, 0, 0)
)
try(
g &lt;- graph_create(hypotheses, transitions)
)

# When names are not specified, hypotheses are numbered sequentially as
# H1, H2, ...
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)
g
</code></pre>

<hr>
<h2 id='graph_generate_weights'>Generate the weighting strategy based on a graphical multiple comparison
procedure</h2><span id='topic+graph_generate_weights'></span>

<h3>Description</h3>

<p>A graphical multiple comparison procedure defines a closed test procedure,
which tests each intersection hypothesis and reject an individual hypothesis
if all intersection hypotheses involving it have been rejected. An
intersection hypothesis represents the parameter space where individual null
hypotheses involved are true simultaneously.
</p>
<p>The closure based on a graph consists of all updated graphs (corresponding
to intersection hypotheses) after all combinations of hypotheses are deleted.
For a graphical multiple comparison procedure with <code class="reqn">m</code> hypotheses, there
are <code class="reqn">2^{m}-1</code> updated graphs (intersection hypotheses), including the
initial graph (the overall intersection hypothesis). The weighting strategy
of this graph consists of hypothesis weights from all <code class="reqn">2^{m}-1</code> updated
graphs (intersection hypotheses). The algorithm to derive the weighting
strategy is based on Algorithm 1 in Bretz et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_generate_weights(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_generate_weights_+3A_graph">graph</code></td>
<td>
<p>An initial graph as returned by <code><a href="#topic+graph_create">graph_create()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of all intersection hypotheses and their hypothesis
weights. For a graphical multiple comparison procedure with <code class="reqn">m</code> hypotheses,
the number of rows is <code class="reqn">2^{m}-1</code>, each of which corresponds to an intersection
hypothesis. The number of columns is <code class="reqn">2\cdot m</code>. The first <code class="reqn">m</code> columns
indicate which individual hypotheses are included in a given intersection
hypothesis and the second half of columns provide hypothesis weights for each
individual hypothesis for a given intersection hypothesis.
</p>


<h3>Performance</h3>

<p>Generation of intersection hypotheses is closely related to the power set
of a given set of indices. As the number of hypotheses increases, the memory
and time usage can grow quickly (e.g., at a rate of <code class="reqn">O(2^n)</code>). There are also
multiple ways to implement Algorithm 1 in Bretz et al. (2011). See
<code>vignette("generate-closure")</code> for more information about generating
intersection hypotheses and comparisons of different approaches to calculate
weighting strategies.
</p>


<h3>References</h3>

<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_test_closure">graph_test_closure()</a></code> for graphical multiple comparison procedures using
the closed test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 1 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

graph_generate_weights(g)
</code></pre>

<hr>
<h2 id='graph_rejection_orderings'>Find alternate rejection orderings (sequences) for shortcut tests</h2><span id='topic+graph_rejection_orderings'></span>

<h3>Description</h3>

<p>When multiple hypotheses are rejected by using <code><a href="#topic+graph_test_shortcut">graph_test_shortcut()</a></code>,
there may be multiple orderings or sequences in which hypotheses are rejected
one by one. The default order in <code><a href="#topic+graph_test_shortcut">graph_test_shortcut()</a></code> is based on the
adjusted p-values, from the smallest to the largest. This function
<code><a href="#topic+graph_rejection_orderings">graph_rejection_orderings()</a></code> provides all possible and valid orders
(or sequences) of rejections. Although the order of rejection does not affect
the final rejection decisions Bretz et al. (2009), different sequences could
offer different ways to explain the step-by-step process of shortcut
graphical multiple comparison procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_rejection_orderings(shortcut_test_result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_rejection_orderings_+3A_shortcut_test_result">shortcut_test_result</code></td>
<td>
<p>A <code>graph_report</code> object as returned by
<code><a href="#topic+graph_test_shortcut">graph_test_shortcut()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>graph_report</code> object containing all valid orderings of
rejections of hypotheses
</p>


<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W., and Posch, M. (2009). A graphical
approach to sequentially rejective multiple test procedures.
<em>Statistics in Medicine</em>, 28(4), 586-604.
</p>
<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_test_shortcut">graph_test_shortcut()</a></code> for shortcut graphical multiple comparison
procedures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 4 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
delta &lt;- 0.5
transitions &lt;- rbind(
  c(0, delta, 1 - delta, 0),
  c(delta, 0, 0, 1 - delta),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

p &lt;- c(0.018, 0.01, 0.105, 0.006)
alpha &lt;- 0.025

shortcut_testing &lt;- graph_test_shortcut(g, p, alpha, verbose = TRUE)

# Reject H1, H2, and H4
shortcut_testing$outputs$rejected

# Default order of rejections: H2, H1, H4
shortcut_testing$details$del_seq

# There is another valid sequence of rejection: H2, H4, H1
graph_rejection_orderings(shortcut_testing)$valid_orderings

# Finally, intermediate updated graphs can be obtained by providing the order
# of rejections into `[graph_update()]`
graph_update(g, delete = c(2, 4, 1))
</code></pre>

<hr>
<h2 id='graph_test_closure'>Perform closed graphical multiple comparison procedures</h2><span id='topic+graph_test_closure'></span>

<h3>Description</h3>

<p>Closed graphical multiple comparison procedures, or graphical multiple
comparison procedures based on the closure, generate the closure based on a
graph consisting of all intersection hypotheses. It tests each intersection
hypothesis and rejects an individual hypothesis if all intersection
hypotheses involving it have been rejected. An intersection hypothesis
represents the parameter space where individual null hypotheses involved are
true simultaneously.
</p>
<p>For a graphical multiple comparison procedure with $m$ hypotheses, there are
<code class="reqn">2^m-1</code> intersection hypotheses. For each intersection hypothesis, a test
type could be chosen to determine how to reject the intersection hypothesis.
Current choices of test types include Bonferroni, Simes and parametric. This
implementation offers a more general framework covering Bretz et al. (2011),
Lu (2016), and Xi et al. (2017). See <code>vignette("closed-testing")</code> for more
illustration of closed test procedures and interpretation of their outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_test_closure(
  graph,
  p,
  alpha = 0.025,
  test_groups = list(seq_along(graph$hypotheses)),
  test_types = c("bonferroni"),
  test_corr = rep(list(NA), length(test_types)),
  verbose = FALSE,
  test_values = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_test_closure_+3A_graph">graph</code></td>
<td>
<p>An initial graph as returned by <code><a href="#topic+graph_create">graph_create()</a></code>.</p>
</td></tr>
<tr><td><code id="graph_test_closure_+3A_p">p</code></td>
<td>
<p>A numeric vector of p-values (unadjusted, raw), whose values should
be between 0 &amp; 1. The length should match the number of hypotheses in
<code>graph</code>.</p>
</td></tr>
<tr><td><code id="graph_test_closure_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value of the overall significance level, which should
be between 0 &amp; 1. The default is 0.025 for one-sided hypothesis testing
problems; another common choice is 0.05 for two-sided hypothesis testing
problems. Note when parametric tests are used, only one-sided tests are
supported.</p>
</td></tr>
<tr><td><code id="graph_test_closure_+3A_test_groups">test_groups</code></td>
<td>
<p>A list of numeric vectors specifying hypotheses to test
together. Grouping is needed to correctly perform Simes and parametric
tests.</p>
</td></tr>
<tr><td><code id="graph_test_closure_+3A_test_types">test_types</code></td>
<td>
<p>A character vector of test types to apply to each test
group. This is needed to correctly perform Simes and parametric
tests. The length should match the number of elements in <code>test_groups</code>.</p>
</td></tr>
<tr><td><code id="graph_test_closure_+3A_test_corr">test_corr</code></td>
<td>
<p>(Optional) A list of numeric correlation matrices. Each
entry in the list should correspond to each test group. For a test group
using Bonferroni or Simes tests, its corresponding entry in <code>test_corr</code>
should be <code>NA</code>. For a test group using parametric tests, its
corresponding entry in <code>test_corr</code> should be a numeric correlation matrix
specifying the correlation between test statistics for hypotheses in this
test group. The length should match the number of elements in
<code>test_groups</code>.</p>
</td></tr>
<tr><td><code id="graph_test_closure_+3A_verbose">verbose</code></td>
<td>
<p>A logical scalar specifying whether the details of the
adjusted p-value calculations should be included in results. When
<code>verbose = TRUE</code>, adjusted p-values are provided for each intersection
hypothesis. The default is <code>verbose = FALSE</code>.</p>
</td></tr>
<tr><td><code id="graph_test_closure_+3A_test_values">test_values</code></td>
<td>
<p>A logical scalar specifying whether adjusted significance
levels should be provided for each hypothesis. When <code>test_values = TRUE</code>,
it provides an equivalent way of performing graphical multiple comparison
procedures by comparing each p-value with its significance level. If the
p-value of a hypothesis is less than or equal to its significance level,
the hypothesis is rejected. The default is <code>test_values = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>graph_report</code> object with a list of 4 elements:
</p>

<ul>
<li> <p><code>inputs</code> - Input parameters, which is a list of:
</p>

<ul>
<li> <p><code>graph</code> - Initial graph,
</p>
</li>
<li> <p><code>p</code> - (Unadjusted or raw) p-values,
</p>
</li>
<li> <p><code>alpha</code> - Overall significance level,
</p>
</li>
<li> <p><code>test_groups</code> - Groups of hypotheses for different types of tests,
</p>
</li>
<li> <p><code>test_types</code> - Different types of tests,
</p>
</li>
<li> <p><code>test_corr</code> - Correlation matrices for parametric tests.
</p>
</li></ul>

</li>
<li> <p><code>outputs</code> - Output parameters, which is a list of:
</p>

<ul>
<li> <p><code>adjusted_p</code> - Adjusted p-values,
</p>
</li>
<li> <p><code>rejected</code> - Rejected hypotheses,
</p>
</li>
<li> <p><code>graph</code> - Updated graph after deleting all rejected hypotheses.
</p>
</li></ul>

</li>
<li> <p><code>details</code> - Verbose outputs with adjusted p-values for intersection
hypotheses, if <code>verbose = TRUE</code>.
</p>
</li>
<li> <p><code>test_values</code> - Adjusted significance levels, if <code>test_values = TRUE</code>.
</p>
</li></ul>



<h3>Details for test specification</h3>

<p>Test specification includes three components: <code>test_groups</code>, <code>test_types</code>,
and <code>test_corr</code>. Alignment among entries in these components is important
for correct implementation. There are two ways to provide test specification.
The first approach is the &quot;unnamed&quot; approach, which assumes that all 3
components are ordered the same way, i.e., the $n$-th element of <code>test_types</code>
and <code>test_corr</code> should apply to the $n$-th group in <code>test_groups</code>. The
second &quot;named&quot; approach uses the name of each element of each component to
connect the element of <code>test_types</code> and <code>test_corr</code> with the correct element
of <code>test_groups</code>. Consistency should be ensured for correct implementation.
</p>


<h3>References</h3>

<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>
<p>Lu, K. (2016). Graphical approaches using a Bonferroni mixture of weighted
Simes tests. <em>Statistics in Medicine</em>, 35(22), 4041-4055.
</p>
<p>Xi, D., Glimm, E., Maurer, W., and Bretz, F. (2017). A unified framework
for weighted parametric multiple test procedures.
<em>Biometrical Journal</em>, 59(5), 918-931.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_test_shortcut">graph_test_shortcut()</a></code> for shortcut graphical multiple comparison
procedures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses
# (H1 and H2) and two secondary hypotheses (H3 and H4)
# See Figure 4 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
delta &lt;- 0.5
transitions &lt;- rbind(
  c(0, delta, 1 - delta, 0),
  c(delta, 0, 0, 1 - delta),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

p &lt;- c(0.018, 0.01, 0.105, 0.006)
alpha &lt;- 0.025

# Closed graphical multiple comparison procedure using Bonferroni tests
# Same results as `graph_test_shortcut(g, p, alpha)`
graph_test_closure(g, p, alpha)

# Closed graphical multiple comparison procedure using parametric tests for
# H1 and H2, and Bonferroni tests for H3 and H4
set.seed(1234)
corr_list &lt;- list(matrix(c(1, 0.5, 0.5, 1), nrow = 2), NA)
graph_test_closure(
  graph = g,
  p = p,
  alpha = alpha,
  test_groups = list(1:2, 3:4),
  test_types = c("parametric", "bonferroni"),
  test_corr = corr_list
)
# The "named" approach to obtain the same results
# Note that "group2" appears before "group1" in `test_groups`
set.seed(1234)
corr_list &lt;- list(group1 = matrix(c(1, 0.5, 0.5, 1), nrow = 2), group2 = NA)
graph_test_closure(
  graph = g,
  p = p,
  alpha = alpha,
  test_groups = list(group1 = 1:2, group2 = 3:4),
  test_types = c(group2 = "bonferroni", group1 = "parametric"),
  test_corr = corr_list
)

# Closed graphical multiple comparison procedure using parametric tests for
# H1 and H2, and Simes tests for H3 and H4
set.seed(1234)
graph_test_closure(
  graph = g,
  p = p,
  alpha = alpha,
  test_groups = list(group1 = 1:2, group2 = 3:4),
  test_types = c(group1 = "parametric", group2 = "simes"),
  test_corr = corr_list
)
</code></pre>

<hr>
<h2 id='graph_test_closure_fast'>Perform graphical multiple comparison procedures efficiently for power
calculation</h2><span id='topic+graph_test_closure_fast'></span><span id='topic+graph_test_shortcut_fast'></span>

<h3>Description</h3>

<p>These functions performs similarly to <code><a href="#topic+graph_test_closure">graph_test_closure()</a></code> or
<code><a href="#topic+graph_test_shortcut">graph_test_shortcut()</a></code> but are optimized for efficiently calculating power.
For example, generating weights and calculating adjusted weights can be done
only once. Vectorization has been applied where possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_test_closure_fast(p, alpha, adjusted_weights, matrix_intersections)

graph_test_shortcut_fast(p, alpha, adjusted_weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_test_closure_fast_+3A_p">p</code></td>
<td>
<p>A numeric vector of one-sided p-values (unadjusted, raw), whose
values should be between 0 &amp; 1. The length should match the number of
hypotheses in <code>graph</code>.</p>
</td></tr>
<tr><td><code id="graph_test_closure_fast_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value of the one-sided overall significance level,
which should be between 0 &amp; 1. The default is 0.025 for one-sided
hypothesis testing. Note that only one-sided tests are supported.</p>
</td></tr>
<tr><td><code id="graph_test_closure_fast_+3A_adjusted_weights">adjusted_weights</code></td>
<td>
<p>The adjusted hypothesis weights, which are the
second half of columns from <code><a href="#topic+graph_generate_weights">graph_generate_weights()</a></code> output, adjusted by
the appropriate test types (Bonferroni, Simes, or parametric).</p>
</td></tr>
<tr><td><code id="graph_test_closure_fast_+3A_matrix_intersections">matrix_intersections</code></td>
<td>
<p>A matrix of hypothesis indicators in a weighting
strategy, which are the first half the <code><a href="#topic+graph_generate_weights">graph_generate_weights()</a></code> output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical or integer vector indicating whether each hypothesis can
be rejected or not.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+graph_test_closure">graph_test_closure()</a></code> for closed graphical multiple comparison
procedures.
</p>
</li>
<li> <p><code><a href="#topic+graph_test_shortcut">graph_test_shortcut()</a></code> for shortcut graphical multiple comparison
procedures.
</p>
</li></ul>


<hr>
<h2 id='graph_test_shortcut'>Perform shortcut (sequentially rejective) graphical multiple comparison
procedures</h2><span id='topic+graph_test_shortcut'></span>

<h3>Description</h3>

<p>Shortcut graphical multiple comparison procedures are sequentially rejective
procedure based on Bretz et al. (2009). With $m$ hypotheses, there are at
most $m$ steps to obtain all rejection decisions. These procedure are
equivalent to closed graphical multiple comparison procedures using
Bonferroni tests for intersection hypotheses, but shortcut procedures are
faster to perform. See <code>vignette("shortcut-testing")</code> for more illustration
of shortcut procedures and interpretation of their outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_test_shortcut(
  graph,
  p,
  alpha = 0.025,
  verbose = FALSE,
  test_values = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_test_shortcut_+3A_graph">graph</code></td>
<td>
<p>An initial graph as returned by <code><a href="#topic+graph_create">graph_create()</a></code>.</p>
</td></tr>
<tr><td><code id="graph_test_shortcut_+3A_p">p</code></td>
<td>
<p>A numeric vector of p-values (unadjusted, raw), whose values should
be between 0 &amp; 1. The length should match the number of hypotheses in
<code>graph</code>.</p>
</td></tr>
<tr><td><code id="graph_test_shortcut_+3A_alpha">alpha</code></td>
<td>
<p>A numeric scalar of the overall significance level, which should
be between 0 &amp; 1. The default is 0.025 for one-sided hypothesis testing
problems; another common choice is 0.05 for two-sided hypothesis testing
problems.</p>
</td></tr>
<tr><td><code id="graph_test_shortcut_+3A_verbose">verbose</code></td>
<td>
<p>A logical scalar specifying whether the details of
intermediate update graphs should be included in results. When
<code>verbose = TRUE</code>, intermediate update graphs are provided after deleting
each hypothesis, which has been rejected. The default is <code>verbose = FALSE</code>.</p>
</td></tr>
<tr><td><code id="graph_test_shortcut_+3A_test_values">test_values</code></td>
<td>
<p>A logical scalar specifying whether adjusted significance
levels should be provided for each hypothesis. When <code>test_values = TRUE</code>,
it provides an equivalent way of performing graphical multiple comparison
procedures by comparing each p-value with its significance level. If the
p-value of a hypothesis is less than or equal to its significance level,
the hypothesis is rejected. The order of rejection is based on the order
of adjusted p-values from the smallest to the largest. The default is
<code>test_values = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>graph_report</code> with a list of 4 elements:
</p>

<ul>
<li> <p><code>inputs</code> - Input parameters, which is a list of:
</p>

<ul>
<li> <p><code>graph</code> - Initial graph,
*<code>p</code> - (Unadjusted or raw) p-values,
</p>
</li>
<li> <p><code>alpha</code> - Overall significance level,
</p>
</li>
<li> <p><code>test_groups</code> - Groups of hypotheses for different types of tests,
which are the list of all hypotheses for <code><a href="#topic+graph_test_shortcut">graph_test_shortcut()</a></code>,
</p>
</li>
<li> <p><code>test_types</code> - Different types of tests, which are &quot;bonferroni&quot; for
<code><a href="#topic+graph_test_shortcut">graph_test_shortcut()</a></code>.
</p>
</li></ul>

</li>
<li><p> Output parameters <code>outputs</code>, which is a list of:
</p>

<ul>
<li> <p><code>adjusted_p</code> - Adjusted p-values,
</p>
</li>
<li> <p><code>rejected</code> - Rejected hypotheses,
</p>
</li>
<li> <p><code>graph</code> - Updated graph after deleting all rejected hypotheses.
</p>
</li></ul>

</li>
<li> <p><code>details</code> - Verbose outputs with intermediate updated graphs, if
<code>verbose = TRUE</code>.
</p>
</li>
<li> <p><code>test_values</code> - Adjusted significance levels, if <code>test_values = TRUE</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W., and Posch, M. (2009). A graphical
approach to sequentially rejective multiple test procedures.
<em>Statistics in Medicine</em>, 28(4), 586-604.
</p>
<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+graph_test_closure">graph_test_closure()</a></code> for graphical multiple comparison procedures using
the closed test,
</p>
</li>
<li> <p><code><a href="#topic+graph_rejection_orderings">graph_rejection_orderings()</a></code> for all possible rejection orderings.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 1 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

p &lt;- c(0.018, 0.01, 0.105, 0.006)
alpha &lt;- 0.025
graph_test_shortcut(g, p, alpha)
</code></pre>

<hr>
<h2 id='graph_update'>Obtain an updated graph by updating an initial graphical after deleting
hypotheses</h2><span id='topic+graph_update'></span>

<h3>Description</h3>

<p>After a hypothesis is deleted, an initial graph will be updated. The deleted
hypothesis will have the hypothesis weight of 0 and the transition weight of
0. Remaining hypotheses will have updated hypothesis weights and transition
weights according to Algorithm 1 of Bretz et al. (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_update(graph, delete)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_update_+3A_graph">graph</code></td>
<td>
<p>An initial graph as returned by <code><a href="#topic+graph_create">graph_create()</a></code>.</p>
</td></tr>
<tr><td><code id="graph_update_+3A_delete">delete</code></td>
<td>
<p>A logical or integer vector, denoting which hypotheses to
delete. A logical vector results in the &quot;unordered mode&quot;, which means that
hypotheses corresponding to <code>TRUE</code> in <code>delete</code> will be deleted. The
sequence of deletion will follow the sequence of <code>TRUE</code>'s in <code>delete</code>. In
this case, the length of the logical vector must match the number of
hypotheses in <code>graph</code>. An integer vector results in the &quot;ordered mode&quot;,
which means that <code>delete</code> specifies the sequence in which hypotheses
should be deleted by indicating the location of deleted hypotheses, e.g.,
1st, 2nd, etc. In this case, the integer vector can have any length, but
must only contain valid hypothesis numbers (greater than 0, and less than
or equal to he number of hypotheses in <code>graph</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>updated_graph</code> with a list of 4 elements:
</p>

<ul>
<li> <p><code>initial_graph</code>: The initial graph object.
</p>
</li>
<li> <p><code>updated_graph</code>: The updated graph object with specified hypotheses
deleted.
</p>
</li>
<li> <p><code>deleted</code>: A numeric vector indicating which hypotheses were deleted.
</p>
</li>
<li> <p><code>intermediate_graphs</code>: When using the ordered mode, a list of
intermediate updated graphs after each hypothesis is deleted according
to the sequence specified by <code>delete</code>.
</p>
</li></ul>



<h3>Sequence of deletion</h3>

<p>When there are multiple hypotheses to be deleted from a graph, there are many
sequences of deletion in which an initial graph is updated to an updated
graph. If the interest is in the updated graph after all hypotheses specified
by <code>delete</code> are deleted, this updated graph is the same no matter which
sequence of deletion is used. This property has been proved by Bretz et al.
(2009). If the interest is in the intermediate updated graph after each
hypothesis is deleted according to the sequence specified by <code>delete</code>, an
integer vector of <code>delete</code> should be specified and these detailed outputs
will be provided.
</p>


<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W., and Posch, M. (2009). A graphical
approach to sequentially rejective multiple test procedures.
<em>Statistics in Medicine</em>, 28(4), 586-604.
</p>
<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+graph_create">graph_create()</a></code> for the initial graph.
</p>
</li>
<li> <p><code><a href="#topic+graph_rejection_orderings">graph_rejection_orderings()</a></code> for possible sequences of rejections for a
graphical multiple comparison procedure using shortcut testing.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 1 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

# Delete the second and third hypotheses in the "unordered mode"
graph_update(g, delete = c(FALSE, TRUE, TRUE, FALSE))

# Equivalent way in the "ordered mode" to obtain the updated graph after
# deleting the second and third hypotheses
# Additional intermediate updated graphs are also provided
graph_update(g, delete = 2:3)
</code></pre>

<hr>
<h2 id='plot.initial_graph'>S3 plot method for class <code>initial_graph</code></h2><span id='topic+plot.initial_graph'></span>

<h3>Description</h3>

<p>The plot of an <code>initial_graph</code> translates the <code>hypotheses</code> into vertices and
<code>transitions</code> into edges to create a network plot. Vertices are labeled with
hypothesis names and hypothesis weights, and edges are labeled with
transition weights. See <code>vignette("graph-examples")</code> for more illustration
of commonly used multiple comparison procedure using graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initial_graph'
plot(
  x,
  ...,
  v_palette = c("#6baed6", "#cccccc"),
  layout = "grid",
  nrow = NULL,
  ncol = NULL,
  edge_curves = NULL,
  precision = 4,
  eps = NULL,
  background_color = "white",
  margins = c(0, 0, 0, 0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.initial_graph_+3A_x">x</code></td>
<td>
<p>An object of class <code>initial_graph</code> to plot.</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>igraph::plot.igraph()</code>.</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_v_palette">v_palette</code></td>
<td>
<p>A character vector of length two specifying the colors for
retained and deleted hypotheses. More extensive color customization must be
done with <code>vertex.color</code>.</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_layout">layout</code></td>
<td>
<p>An igraph layout specification (See <code>?igraph.plotting</code>), or
<code>"grid"</code>, which lays out hypotheses left-to-right and top-to-bottom. <code>nrow</code>
and <code>ncol</code> control the grid shape.</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_nrow">nrow</code></td>
<td>
<p>An integer scalar specifying the number of rows in the vertex
grid. If row and column counts are not specified, vertices will be laid out
as close to a square as possible.</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_ncol">ncol</code></td>
<td>
<p>An integer scalar specifying the number of columns in the vertex
grid. If row and column counts are not specified, vertices will be laid out
as close to a square as possible.</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_edge_curves">edge_curves</code></td>
<td>
<p>A named numeric vector specifying the curvature of
specific edges. Edge pairs (Where two vertices share an edge in each
possible direction) are detected automatically and get 0.25 curvature.
Adjust edges by adding an entry with name <code style="white-space: pre;">&#8288;"vertex1|vertex2&#8288;</code>, and adjust
default edge pairs curvature by adding an entry with name <code>"pairs"</code> -
<code>edge_curves = c("pairs" = 0.5, "H1|H3" = 0.25, "H3|H4" = 0.75)</code>.</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_precision">precision</code></td>
<td>
<p>An integer scalar indicating the number of decimal places
to to display.</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_eps">eps</code></td>
<td>
<p>A numeric scalar. The transition weight of <code>eps</code> will be
displayed as <code class="reqn">\epsilon</code>, which indicates edges with infinitesimally small
weights. See Bretz et al. (2009) for more details.</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_background_color">background_color</code></td>
<td>
<p>A character scalar specifying a background color for
the whole plotting area. Passed directly to <code><a href="graphics.html#topic+par">graphics::par()</a></code> (<code>bg</code>).</p>
</td></tr>
<tr><td><code id="plot.initial_graph_+3A_margins">margins</code></td>
<td>
<p>A length 4 numeric vector specifying the margins for the plot.
Defaults to all 0, since igraph plots tend to have large margins. It is
passed directly to <code><a href="graphics.html#topic+par">graphics::par()</a></code> (<code>mar</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object x of class <code>initial_graph</code>, after plotting the initial
graph.
</p>


<h3>Customization of graphs</h3>

<p>There are a few values for <code><a href="igraph.html#topic+plot.igraph">igraph::plot.igraph()</a></code> that get their defaults
changed for graphicalMCP. These values can still be changed by passing them
as arguments to <code>plot.initial_graph()</code>. Here are the new defaults:
</p>

<ul>
<li> <p><code>vertex.color = "#6baed6"</code>,
</p>
</li>
<li> <p><code>vertex.label.color = "black"</code>,
</p>
</li>
<li> <p><code>vertex.size = 20</code>,
</p>
</li>
<li> <p><code>edge.arrow.size = 1</code>,
</p>
</li>
<li> <p><code>edge.arrow.width = 1</code>,
</p>
</li>
<li> <p><code>edge.label.color = "black"</code>
</p>
</li>
<li> <p><code>asp = 0</code>.
</p>
</li></ul>

<p>Neither <code>graphicalMCP</code> nor <code>igraph</code> does anything about overlapping edge
labels. If you run into this problem, and vertices can't practically be
moved enough to avoid collisions of edge labels, using edge curves can help.
<code>igraph</code> puts edge labels closer to the tail of an edge when an edge is
straight, and closer to the head of an edge when it's curved. By setting an
edge's curve to some very small value, an effectively straight edge can be
shifted to a new position.
</p>


<h3>References</h3>

<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>
<p>Xi, D., and Bretz, F. (2019). Symmetric graphs for equally weighted tests,
with application to the Hochberg procedure. <em>Statistics in Medicine</em>,
38(27), 5268-5282.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.updated_graph">plot.updated_graph()</a></code> for the plot method for the updated graph after
hypotheses being deleted from the initial graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 4 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
delta &lt;- 0.5
transitions &lt;- rbind(
  c(0, delta, 1 - delta, 0),
  c(delta, 0, 0, 1 - delta),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)
plot(g)

# A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and four secondary hypotheses (H31, H32, H41, and H42)
# See Figure 6 in Xi and Bretz (2019).
hypotheses &lt;- c(0.5, 0.5, 0, 0, 0, 0)
epsilon &lt;- 1e-5
transitions &lt;- rbind(
  c(0, 0.5, 0.25, 0, 0.25, 0),
  c(0.5, 0, 0, 0.25, 0, 0.25),
  c(0, 0, 0, 0, 1, 0),
  c(epsilon, 0, 0, 0, 0, 1 - epsilon),
  c(0, epsilon, 1 - epsilon, 0, 0, 0),
  c(0, 0, 0, 1, 0, 0)
)
hyp_names &lt;- c("H1", "H2", "H31", "H32", "H41", "H42")
g &lt;- graph_create(hypotheses, transitions, hyp_names)

plot_layout &lt;- rbind(
  c(0.15, 0.5),
  c(0.65, 0.5),
  c(0, 0),
  c(0.5, 0),
  c(0.3, 0),
  c(0.8, 0)
)

plot(g, layout = plot_layout, eps = epsilon, edge_curves = c(pairs = .5))
</code></pre>

<hr>
<h2 id='plot.updated_graph'>S3 plot method for the class <code>updated_graph</code></h2><span id='topic+plot.updated_graph'></span>

<h3>Description</h3>

<p>Plotting an updated graph is a <em>very</em> light wrapper around
<code><a href="#topic+plot.initial_graph">plot.initial_graph()</a></code>, only changing the default vertex color to use gray
for deleted hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'updated_graph'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.updated_graph_+3A_x">x</code></td>
<td>
<p>An object of class <code>updated_graph</code> to plot.</p>
</td></tr>
<tr><td><code id="plot.updated_graph_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+plot.initial_graph">plot.initial_graph</a></code>
</p>

<dl>
<dt><code>v_palette</code></dt><dd><p>A character vector of length two specifying the colors for
retained and deleted hypotheses. More extensive color customization must be
done with <code>vertex.color</code>.</p>
</dd>
<dt><code>layout</code></dt><dd><p>An igraph layout specification (See <code>?igraph.plotting</code>), or
<code>"grid"</code>, which lays out hypotheses left-to-right and top-to-bottom. <code>nrow</code>
and <code>ncol</code> control the grid shape.</p>
</dd>
<dt><code>nrow</code></dt><dd><p>An integer scalar specifying the number of rows in the vertex
grid. If row and column counts are not specified, vertices will be laid out
as close to a square as possible.</p>
</dd>
<dt><code>ncol</code></dt><dd><p>An integer scalar specifying the number of columns in the vertex
grid. If row and column counts are not specified, vertices will be laid out
as close to a square as possible.</p>
</dd>
<dt><code>edge_curves</code></dt><dd><p>A named numeric vector specifying the curvature of
specific edges. Edge pairs (Where two vertices share an edge in each
possible direction) are detected automatically and get 0.25 curvature.
Adjust edges by adding an entry with name <code style="white-space: pre;">&#8288;"vertex1|vertex2&#8288;</code>, and adjust
default edge pairs curvature by adding an entry with name <code>"pairs"</code> -
<code>edge_curves = c("pairs" = 0.5, "H1|H3" = 0.25, "H3|H4" = 0.75)</code>.</p>
</dd>
<dt><code>precision</code></dt><dd><p>An integer scalar indicating the number of decimal places
to to display.</p>
</dd>
<dt><code>eps</code></dt><dd><p>A numeric scalar. The transition weight of <code>eps</code> will be
displayed as <code class="reqn">\epsilon</code>, which indicates edges with infinitesimally small
weights. See Bretz et al. (2009) for more details.</p>
</dd>
<dt><code>background_color</code></dt><dd><p>A character scalar specifying a background color for
the whole plotting area. Passed directly to <code><a href="graphics.html#topic+par">graphics::par()</a></code> (<code>bg</code>).</p>
</dd>
<dt><code>margins</code></dt><dd><p>A length 4 numeric vector specifying the margins for the plot.
Defaults to all 0, since igraph plots tend to have large margins. It is
passed directly to <code><a href="graphics.html#topic+par">graphics::par()</a></code> (<code>mar</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An object x of class <code>updated_graph</code>, after plotting the updated
graph.
</p>


<h3>References</h3>

<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.initial_graph">plot.initial_graph()</a></code> for the plot method for the initial graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 1 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

# Delete the second and third hypotheses in the "unordered mode"
plot(
  graph_update(
    g,
    c(FALSE, TRUE, TRUE, FALSE)
  ),
  layout = "grid"
)
</code></pre>

<hr>
<h2 id='print.graph_report'>S3 print method for the class <code>graph_report</code></h2><span id='topic+print.graph_report'></span>

<h3>Description</h3>

<p>A printed <code>graph_report</code> displays the initial graph, p-values and
significance levels, rejection decisions, and optional detailed test results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graph_report'
print(x, ..., precision = 4, indent = 2, rows = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.graph_report_+3A_x">x</code></td>
<td>
<p>An object of class <code>graph_report</code> to print.</p>
</td></tr>
<tr><td><code id="print.graph_report_+3A_...">...</code></td>
<td>
<p>Other values passed on to other methods (currently unused)</p>
</td></tr>
<tr><td><code id="print.graph_report_+3A_precision">precision</code></td>
<td>
<p>An integer scalar indicating the number of decimal places
to to display.</p>
</td></tr>
<tr><td><code id="print.graph_report_+3A_indent">indent</code></td>
<td>
<p>An integer scalar indicating how many spaces to indent results.</p>
</td></tr>
<tr><td><code id="print.graph_report_+3A_rows">rows</code></td>
<td>
<p>An integer scalar indicating how many rows of detailed test
results to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object x of class <code>graph_report</code>, after printing the report of
conducting a graphical multiple comparison procedure.
</p>


<h3>References</h3>

<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 1 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

p &lt;- c(0.018, 0.01, 0.105, 0.006)
alpha &lt;- 0.025
graph_test_shortcut(g, p, alpha)
</code></pre>

<hr>
<h2 id='print.initial_graph'>S3 print method for the class <code>initial_graph</code></h2><span id='topic+print.initial_graph'></span>

<h3>Description</h3>

<p>A printed <code>initial_graph</code> displays a header stating &quot;Initial graph&quot;,
hypothesis weights, and transition weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initial_graph'
print(x, ..., precision = 4, indent = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.initial_graph_+3A_x">x</code></td>
<td>
<p>An object of class <code>initial_graph</code> to print.</p>
</td></tr>
<tr><td><code id="print.initial_graph_+3A_...">...</code></td>
<td>
<p>Other values passed on to other methods (currently unused).</p>
</td></tr>
<tr><td><code id="print.initial_graph_+3A_precision">precision</code></td>
<td>
<p>An integer scalar indicating the number of decimal places
to to display.</p>
</td></tr>
<tr><td><code id="print.initial_graph_+3A_indent">indent</code></td>
<td>
<p>An integer scalar indicating how many spaces to indent results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object x of class <code>initial_graph</code>, after printing the initial
graph.
</p>


<h3>References</h3>

<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.updated_graph">print.updated_graph()</a></code> for the print method for the updated graph after
hypotheses being deleted from the initial graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 1 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
hyp_names &lt;- c("H11", "H12", "H21", "H22")
g &lt;- graph_create(hypotheses, transitions, hyp_names)
g
</code></pre>

<hr>
<h2 id='print.power_report'>S3 print method for the class <code>power_report</code></h2><span id='topic+print.power_report'></span>

<h3>Description</h3>

<p>A printed <code>power_report</code> displays the initial graph, testing and simulation
options, power outputs, and optional detailed simulations and test results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'power_report'
print(x, ..., precision = 4, indent = 2, rows = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.power_report_+3A_x">x</code></td>
<td>
<p>An object of the class <code>power_report</code> to print</p>
</td></tr>
<tr><td><code id="print.power_report_+3A_...">...</code></td>
<td>
<p>Other values passed on to other methods (currently unused)</p>
</td></tr>
<tr><td><code id="print.power_report_+3A_precision">precision</code></td>
<td>
<p>An integer scalar indicating the number of decimal places
to to display.</p>
</td></tr>
<tr><td><code id="print.power_report_+3A_indent">indent</code></td>
<td>
<p>An integer scalar indicating how many spaces to indent results.</p>
</td></tr>
<tr><td><code id="print.power_report_+3A_rows">rows</code></td>
<td>
<p>An integer scalar indicating how many rows of detailed test
results to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object x of the class <code>power_report</code>, after printing the report of
conducting power simulations based on a graphical multiple comparison
procedure.
</p>


<h3>References</h3>

<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011a). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>
<p>Bretz, F., Maurer, W., and Hommel, G. (2011b). Test and power
considerations for multiple endpoint analyses using sequentially rejective
graphical procedures. <em>Statistics in Medicine</em>, 30(13), 1489-1501.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 4 in Bretz et al. (2011).
alpha &lt;- 0.025
hypotheses &lt;- c(0.5, 0.5, 0, 0)
delta &lt;- 0.5
transitions &lt;- rbind(
  c(0, delta, 1 - delta, 0),
  c(delta, 0, 0, 1 - delta),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

marginal_power &lt;- c(0.8, 0.8, 0.7, 0.9)
corr1 &lt;- matrix(0.5, nrow = 2, ncol = 2)
diag(corr1) &lt;- 1
corr &lt;- rbind(
  cbind(corr1, 0.5 * corr1),
  cbind(0.5 * corr1, corr1)
)
success_fns &lt;- list(
  # Probability to reject both H1 and H2
  `H1andH2` = function(x) x[1] &amp; x[2],
  # Probability to reject both (H1 and H3) or (H2 and H4)
  `(H1andH3)or(H2andH4)` = function(x) (x[1] &amp; x[3]) | (x[2] &amp; x[4])
)
set.seed(1234)
# Bonferroni tests
power_output &lt;- graph_calculate_power(
  g,
  alpha,
  sim_corr = corr,
  sim_n = 1e5,
  power_marginal = marginal_power,
  sim_success = success_fns
)
</code></pre>

<hr>
<h2 id='print.updated_graph'>S3 print method for the class <code>updated_graph</code></h2><span id='topic+print.updated_graph'></span>

<h3>Description</h3>

<p>A printed <code>updated_graph</code> displays the initial graph, the (final) updated
graph, and the sequence of intermediate updated graphs after hypotheses are
deleted (if available).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'updated_graph'
print(x, ..., precision = 6, indent = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.updated_graph_+3A_x">x</code></td>
<td>
<p>An object of the class <code>updated_graph</code> to print.</p>
</td></tr>
<tr><td><code id="print.updated_graph_+3A_...">...</code></td>
<td>
<p>Other values passed on to other methods (currently unused).</p>
</td></tr>
<tr><td><code id="print.updated_graph_+3A_precision">precision</code></td>
<td>
<p>An integer scalar indicating the number of decimal places
to to display.</p>
</td></tr>
<tr><td><code id="print.updated_graph_+3A_indent">indent</code></td>
<td>
<p>An integer scalar indicating how many spaces to indent results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object x of the class <code>updated_graph</code>, after printing the updated
graph.
</p>


<h3>References</h3>

<p>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., and
Rohmeyer, K. (2011a). Graphical approaches for multiple comparison
procedures using weighted Bonferroni, Simes, or parametric tests.
<em>Biometrical Journal</em>, 53(6), 894-913.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.initial_graph">print.initial_graph()</a></code> for the print method for the initial graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graphical multiple comparison procedure with two primary hypotheses (H1
# and H2) and two secondary hypotheses (H3 and H4)
# See Figure 1 in Bretz et al. (2011).
hypotheses &lt;- c(0.5, 0.5, 0, 0)
transitions &lt;- rbind(
  c(0, 0, 1, 0),
  c(0, 0, 0, 1),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)
g &lt;- graph_create(hypotheses, transitions)

# Delete the second and third hypotheses in the "unordered mode"
graph_update(g, delete = c(FALSE, TRUE, TRUE, FALSE))

# Equivalent way in the "ordered mode" to obtain the updated graph after
# deleting the second and third hypotheses
# Additional intermediate updated graphs are also provided
graph_update(g, delete = 2:3)
</code></pre>

<hr>
<h2 id='test_input_val'>Validate inputs for testing and power simulations</h2><span id='topic+test_input_val'></span><span id='topic+power_input_val'></span>

<h3>Description</h3>

<p>Validate inputs for testing and power simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_input_val(
  graph,
  p,
  alpha,
  test_groups = list(seq_along(graph$hypotheses)),
  test_types = c("bonferroni"),
  test_corr,
  verbose,
  test_values
)

power_input_val(graph, sim_n, power_marginal, test_corr, success)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_input_val_+3A_graph">graph</code></td>
<td>
<p>An initial graph as returned by <code><a href="#topic+graph_create">graph_create()</a></code>.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_p">p</code></td>
<td>
<p>A numeric vector of p-values (unadjusted, raw), whose values should
be between 0 &amp; 1. The length should match the number of hypotheses in
<code>graph</code>.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value of the overall significance level, which should
be between 0 &amp; 1. The default is 0.025 for one-sided hypothesis testing
problems; another common choice is 0.05 for two-sided hypothesis testing
problems. Note when parametric tests are used, only one-sided tests are
supported.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_test_groups">test_groups</code></td>
<td>
<p>A list of numeric vectors specifying hypotheses to test
together. Grouping is needed to correctly perform Simes and parametric
tests.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_test_types">test_types</code></td>
<td>
<p>A character vector of test types to apply to each test
group. This is needed to correctly perform Simes and parametric
tests. The length should match the number of elements in <code>test_groups</code>.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_test_corr">test_corr</code></td>
<td>
<p>(Optional) A list of numeric correlation matrices. Each
entry in the list should correspond to each test group. For a test group
using Bonferroni or Simes tests, its corresponding entry in <code>test_corr</code>
should be <code>NA</code>. For a test group using parametric tests, its
corresponding entry in <code>test_corr</code> should be a numeric correlation matrix
specifying the correlation between test statistics for hypotheses in this
test group. The length should match the number of elements in
<code>test_groups</code>.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_verbose">verbose</code></td>
<td>
<p>A logical scalar specifying whether the details of the
adjusted p-value calculations should be included in results. When
<code>verbose = TRUE</code>, adjusted p-values are provided for each intersection
hypothesis. The default is <code>verbose = FALSE</code>.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_test_values">test_values</code></td>
<td>
<p>A logical scalar specifying whether adjusted significance
levels should be provided for each hypothesis. When <code>test_values = TRUE</code>,
it provides an equivalent way of performing graphical multiple comparison
procedures by comparing each p-value with its significance level. If the
p-value of a hypothesis is less than or equal to its significance level,
the hypothesis is rejected. The default is <code>test_values = FALSE</code>.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_sim_n">sim_n</code></td>
<td>
<p>An integer scalar specifying the number of simulations. The
default is 1e5.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_power_marginal">power_marginal</code></td>
<td>
<p>A numeric vector of marginal power values to use when
simulating p-values. See Details for more on the simulation process.</p>
</td></tr>
<tr><td><code id="test_input_val_+3A_success">success</code></td>
<td>
<p>A list of user-defined functions to specify the success
criteria. Functions must take one simulation's logical vector of results as
an input, and return a length-one logical vector. For instance, if
&quot;success&quot; means rejecting hypotheses 1 and 2, use <code>sim_success = list("1 and 2" = function(x) x[1] &amp;&amp; x[2])</code>. If the list is not named, the function
body will be used as the name. Lambda functions also work starting with R
4.1, e.g. <code style="white-space: pre;">&#8288;sim_success = list(\(x) x[3] || x[4])&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>graph</code> invisibly
</p>

<hr>
<h2 id='test_values_bonferroni'>Organize outputs for testing an intersection hypothesis</h2><span id='topic+test_values_bonferroni'></span><span id='topic+test_values_parametric'></span><span id='topic+test_values_simes'></span>

<h3>Description</h3>

<p>An intersection hypothesis can be tested by a mixture of test types including
Bonferroni, parametric and Simes tests. This function organize outputs of
testing and prepare them for <code>graph_report</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_values_bonferroni(p, hypotheses, alpha, intersection = NA)

test_values_parametric(p, hypotheses, alpha, intersection = NA, test_corr)

test_values_simes(p, hypotheses, alpha, intersection = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_values_bonferroni_+3A_p">p</code></td>
<td>
<p>A numeric vector of p-values (unadjusted, raw), whose values should
be between 0 &amp; 1. The length should match the number of hypotheses in
<code>graph</code>.</p>
</td></tr>
<tr><td><code id="test_values_bonferroni_+3A_hypotheses">hypotheses</code></td>
<td>
<p>A numeric vector of hypothesis weights in a graphical
multiple comparison procedure. Must be a vector of values between 0 &amp; 1
(inclusive). The length should match the row and column lengths of
<code>transitions</code>. The sum of hypothesis weights should not exceed 1.</p>
</td></tr>
<tr><td><code id="test_values_bonferroni_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value of the overall significance level, which should
be between 0 &amp; 1. The default is 0.025 for one-sided hypothesis testing
problems; another common choice is 0.05 for two-sided hypothesis testing
problems. Note when parametric tests are used, only one-sided tests are
supported.</p>
</td></tr>
<tr><td><code id="test_values_bonferroni_+3A_intersection">intersection</code></td>
<td>
<p>(optional) A numeric scalar used to name the
intersection hypothesis in a weighting strategy.</p>
</td></tr>
<tr><td><code id="test_values_bonferroni_+3A_test_corr">test_corr</code></td>
<td>
<p>(Optional) A list of numeric correlation matrices. Each
entry in the list should correspond to each test group. For a test group
using Bonferroni or Simes tests, its corresponding entry in <code>test_corr</code>
should be <code>NA</code>. For a test group using parametric tests, its
corresponding entry in <code>test_corr</code> should be a numeric correlation matrix
specifying the correlation between test statistics for hypotheses in this
test group. The length should match the number of elements in
<code>test_groups</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with rows corresponding to individual hypotheses
involved in the intersection hypothesis with hypothesis weights
<code>hypotheses</code>. There are following columns:
</p>

<ul>
<li> <p><code>Intersection</code> - Name of this intersection hypothesis,
</p>
</li>
<li> <p><code>Hypothesis</code> - Name of an individual hypothesis,
</p>
</li>
<li> <p><code>Test</code> - Test type for an individual hypothesis,
</p>
</li>
<li> <p><code>p</code> - (Unadjusted or raw) p-values for a individual hypothesis,
</p>
</li>
<li> <p><code>c_value</code>- C value for parametric tests,
</p>
</li>
<li> <p><code>Weight</code> - Hypothesis weight for an individual hypothesis,
</p>
</li>
<li> <p><code>Alpha</code> - Overall significance level <code class="reqn">\alpha</code>,
</p>
</li>
<li> <p><code>Inequality_holds</code> - Indicator to show if the p-value is less than or
equal to its significance level.
</p>

<ul>
<li><p> For Bonferroni and Simes tests, the significance level is the
hypothesis weight times <code class="reqn">\alpha</code>.
</p>
</li>
<li><p> For parametric tests, the significance level is the c value times
the hypothesis weight times <code class="reqn">\alpha</code>.
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W., and Posch, M. (2009). A graphical
approach to sequentially rejective multiple test procedures.
<em>Statistics in Medicine</em>, 28(4), 586-604.
</p>
<p>Lu, K. (2016). Graphical approaches using a Bonferroni mixture of weighted
Simes tests. <em>Statistics in Medicine</em>, 35(22), 4041-4055.
</p>
<p>Xi, D., Glimm, E., Maurer, W., and Bretz, F. (2017). A unified framework
for weighted parametric multiple test procedures.
<em>Biometrical Journal</em>, 59(5), 918-931.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
