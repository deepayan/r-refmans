<!DOCTYPE html><html><head><title>Help for package metaforest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metaforest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef_test'><p>Test coefficients of a model</p></a></li>
<li><a href='#curry'><p>Happy to Help?</p></a></li>
<li><a href='#extract_proximity'><p>Extract proximity matrix for a MetaForest object.</p></a></li>
<li><a href='#fukkink_lont'><p>Does training matter? A meta-analysis of caregiver training studies</p></a></li>
<li><a href='#MetaForest'><p>Conduct a MetaForest analysis to explore heterogeneity in meta-analytic data.</p></a></li>
<li><a href='#ModelInfo_mf'><p>Returns a MetaForest ModelInfo list for use with caret</p></a></li>
<li><a href='#ModelInfo_rma'><p>Returns an rma ModelInfo list for use with caret</p></a></li>
<li><a href='#PartialDependence'><p>PartialDependence: Partial dependence plots</p></a></li>
<li><a href='#plot.MetaForest'><p>Plots cumulative MSE for a MetaForest object.</p></a></li>
<li><a href='#predict.MetaForest'><p>MetaForest prediction</p></a></li>
<li><a href='#preselect'><p>Preselect variables for MetaForest analysis</p></a></li>
<li><a href='#preselect_vars'><p>Extract variable names from mf_preselect object</p></a></li>
<li><a href='#print.summary.MetaForest'><p>Prints summary.MetaForest object.</p></a></li>
<li><a href='#report'><p>Report formatted number</p></a></li>
<li><a href='#SimulateSMD'><p>Simulates a meta-analytic dataset</p></a></li>
<li><a href='#VarImpPlot'><p>Plots variable importance for a MetaForest object.</p></a></li>
<li><a href='#WeightedScatter'><p>Plots weighted scatterplots for meta-analytic data. Can plot effect size as</p>
a function of either continuous (numeric, integer) or categorical (factor,
character) predictors.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exploring Heterogeneity in Meta-Analysis using Random Forests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Caspar J. van Lissa</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Caspar J. van Lissa &lt;c.j.vanlissa@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Conduct random forests-based meta-analysis, obtain partial dependence plots for metaforest and classic meta-analyses, and cross-validate and tune metaforest- and classic meta-analyses in conjunction with the caret package. A requirement of classic meta-analysis is that the studies being aggregated are conceptually similar, and ideally, close replications. However, in many fields, there is substantial heterogeneity between studies on the same topic. Classic meta-analysis lacks the power to assess more than a handful of univariate moderators. MetaForest, by contrast, has substantial power to explore heterogeneity in meta-analysis. It can identify important moderators from a larger set of potential candidates (Van Lissa, 2020). This is an appealing quality, because many meta-analyses have small sample sizes. Moreover, MetaForest yields a measure of variable importance which can be used to identify important moderators, and offers partial prediction plots to explore the shape of the marginal relationship between moderators and effect size.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2, metafor, ranger, data.table, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtable, grid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, caret, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-26 07:55:42 UTC; vanlissa</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-26 09:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef_test'>Test coefficients of a model</h2><span id='topic+coef_test'></span>

<h3>Description</h3>

<p>Conduct a t-test or z-test for coefficients of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_test(x, par1, par2, distribution = "pt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_test_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="coef_test_+3A_par1">par1</code></td>
<td>
<p>Numeric or character. Name or position of the first parameter.</p>
</td></tr>
<tr><td><code id="coef_test_+3A_par2">par2</code></td>
<td>
<p>Numeric or character. Name or position of the second parameter.</p>
</td></tr>
<tr><td><code id="coef_test_+3A_distribution">distribution</code></td>
<td>
<p>Character. Which distribution to use. Currently, can be
one of <code>c("pt", "pnorm")</code>, for a t-test or z-test, respectively.
Defaults to &quot;pt&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
res &lt;- rma(yi, vi, mods = ~alloc-1, data=dat, method="REML")
coef_test(res, 1, 2)
</code></pre>

<hr>
<h2 id='curry'>Happy to Help?</h2><span id='topic+curry'></span>

<h3>Description</h3>

<p>A systematic review and meta-analysis of the effects of performing acts of
kindness on the well-being of the actor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(curry)
</code></pre>


<h3>Format</h3>

<p>A data.frame with 56 rows and 18 columns.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>study_id</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Unique identifier of the study</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>effect_id</strong> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Unique identifier of the effect size</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>d</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Standardized mean difference between the control group and intervention group</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>vi</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Variance of the effect size</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>n1i</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Number of participants in the intervention group</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>n1c</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Number of participants in the control group</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>sex</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Percentage of male participants</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>age</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Mean age of participants</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>location</strong> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Geographical location of the study</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>donor</strong> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> From what population did the donors (helpers) originate?</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>donorcode</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> From what population did the donors (helpers) originate? Dichotomized to Anxious or Typical</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>interventioniv</strong> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Description of the intervention / independent variable</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>interventioncode</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Description of the intervention / independent variable, categorized to Acts of Kindness, Prosocial Spending, or Other</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>control</strong> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Description of the control condition</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>controlcode</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Description of the control condition, categorized to Neutral Activity, Nothing, or Self Help (performing a kind act for oneself)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>recipients</strong> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Who were the recipients of the act of kindness?</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>outcomedv</strong> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> What was the outcome, or dependent variable, of the study?</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>outcomecode</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> What was the outcome, or dependent variable, of the study? Categorized into Happiness, Life Satisfaction, PN Affect (positive or negative), and Other
</td>
</tr>

</table>



<h3>Source</h3>

<p><a href="https://doi.org/10.1016/j.jesp.2018.02.014">doi:10.1016/j.jesp.2018.02.014</a>
</p>


<h3>References</h3>

<p>Curry, O. S., Rowland, L. A., Van Lissa, C. J., Zlotowitz, S.,
McAlaney, J., &amp; Whitehouse, H. (2018). Happy to help? A systematic review and
meta-analysis of the effects of performing acts of kindness on the well-being
of the actor. Journal of Experimental Social Psychology, 76, 320-329.
<a href="https://doi.org/10.1016/j.jesp.2018.02.014">doi:10.1016/j.jesp.2018.02.014</a>
</p>

<hr>
<h2 id='extract_proximity'>Extract proximity matrix for a MetaForest object.</h2><span id='topic+extract_proximity'></span>

<h3>Description</h3>

<p>Extract proximity matrix for a MetaForest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_proximity(fit, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_proximity_+3A_fit">fit</code></td>
<td>
<p>object of class \'MetaForest\'.</p>
</td></tr>
<tr><td><code id="extract_proximity_+3A_newdata">newdata</code></td>
<td>
<p>new data with the same columns as the data used for <code>fit</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an n x n matrix where position i, j gives the proportion of times
observation i and j are in the same terminal node across all trees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
</code></pre>

<hr>
<h2 id='fukkink_lont'>Does training matter? A meta-analysis of caregiver training studies</h2><span id='topic+fukkink_lont'></span>

<h3>Description</h3>

<p>A review of 17 experimental studies published between 1980 and 2005 on the
effect of specialized training on the competency of caregivers in childcare.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fukkink_lont)
</code></pre>


<h3>Format</h3>

<p>A data.frame with 78 rows and 30 columns.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>id_exp</strong> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Unique identifier of the study</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>yi</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Standardized mean difference between the control group and</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>vi</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Variance of the effect size</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Journal</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Publication type (scientific journal or other publications)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Setting</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Setting (center-based care or family daycare)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Integrated</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Whether the training was integrated into childcare practice</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Supervision</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Whether supervision was part of the training</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Scope</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Scope of the training (narrow or broad)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Location</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Location of the training (one-site or multi-site)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Curriculum</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Fixed curriculum</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Control</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Alternative treatment for control group</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Assignment</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Random assignment or matching (at the level of the individual caregiver or childcare center)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Train_Knowledge</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Explicit focus on knowledge</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Train_Skills</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Explicit focus on skills</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Train_Attitude</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Explicit focus on attitude</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Video</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Use of video feedback</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Design</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Single group, or two-group experimental design</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Pre_Post</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Pretest/posttest design (yes/no)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Blind</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Was a blinding procedure used?</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Attrition</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Attrition from the experimental condition (percentage)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Pretest_es</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Pre-test effect size</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Self_report</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Self-report measures of caregiver competencies versus ‘objective’ test or observation by independent observer</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>DV_Knowledge</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Test focused on knowledge</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>DV_Skills</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Test focused skills</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>DV_Attitude</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Test focused on attitudes</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>DV_Aligned</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Test aligned with the content of the training (yes/no)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Two_group_design</strong> </td><td style="text-align: left;"> <code>factor</code> </td><td style="text-align: left;"> Single group, or two-group experimental design</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Trainee_Age</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Trainees’ age </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Trainee_Experience</strong> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> Trainees’ working experience</td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>n_total</strong> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Total n at post-test
</td>
</tr>

</table>



<h3>Source</h3>

<p><a href="https://doi.org/10.1016/j.ecresq.2007.04.005">doi:10.1016/j.ecresq.2007.04.005</a>
</p>


<h3>References</h3>

<p>Fukkink, R. G., &amp; Lont, A. (2007). Does training matter? A
meta-analysis and review of caregiver training studies.
Early childhood research quarterly, 22(3), 294-311.
<a href="https://doi.org/10.1016/j.ecresq.2007.04.005">doi:10.1016/j.ecresq.2007.04.005</a>
</p>

<hr>
<h2 id='MetaForest'>Conduct a MetaForest analysis to explore heterogeneity in meta-analytic data.</h2><span id='topic+MetaForest'></span>

<h3>Description</h3>

<p>MetaForest uses a weighted random forest to explore heterogeneity in
meta-analytic data. MetaForest is a wrapper for <a href="ranger.html#topic+ranger">ranger</a>
(Wright &amp; Ziegler, 2015). As input, MetaForest takes the study effect sizes
and their variances (these can be computed, for example, using the
<code><a href="metafor.html#topic+rma.uni">metafor</a></code> package), as well as the moderators
that are to be included in the model. By default, MetaForest uses
random-effects weights, and estimates the between-studies variance using a
restricted maximum-likelihood estimator. However, it may be beneficial to
first conduct an unweighted MetaForest, and then use the estimated residual
heterogeneity from this model as the estimate of <code>tau2</code> for a
random-effects weighted MetaForest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetaForest(
  formula,
  data,
  vi = "vi",
  study = NULL,
  whichweights = "random",
  num.trees = 500,
  mtry = NULL,
  method = "REML",
  tau2 = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MetaForest_+3A_formula">formula</code></td>
<td>
<p>Formula. Specify a formula for the MetaForest model, for
example, <code>yi ~ .</code> to predict the outcome <code>yi</code> from all moderators
in the data. Only additive formulas are allowed (i.e., <code>x1+x2+x3</code>).
Interaction terms and non-linear terms are not required, as the random
forests algorithm inherently captures these associations.</p>
</td></tr>
<tr><td><code id="MetaForest_+3A_data">data</code></td>
<td>
<p>A data.frame containing the effect size, moderators, and the
variance of the effect size.</p>
</td></tr>
<tr><td><code id="MetaForest_+3A_vi">vi</code></td>
<td>
<p>Character. Specify the name of the column in the <code>data</code> that
contains the variances of the effect sizes. This column will be removed from
the data prior to analysis. Defaults to <code>"vi"</code>.</p>
</td></tr>
<tr><td><code id="MetaForest_+3A_study">study</code></td>
<td>
<p>Character. Optionally, specify the name of the column in the
<code>data</code> that contains the study id. Use this when the data includes
multiple effect sizes per study. This column can be a vector of integers, or
a factor. This column will be removed from the data prior to analysis.
See <code>Details</code> for more information about analyzing dependent data.</p>
</td></tr>
<tr><td><code id="MetaForest_+3A_whichweights">whichweights</code></td>
<td>
<p>Character. Indicate what time of weights are required.
A random-effects MetaForest is grown by specifying <code>whichweights =
"random"</code>. A fixed-effects MetaForest is grown by specifying
<code>whichweights = "fixed"</code>. An unweighted MetaForest is grown by
specifying <code>whichweights = "unif"</code>. Defaults to <code>"random"</code>.</p>
</td></tr>
<tr><td><code id="MetaForest_+3A_num.trees">num.trees</code></td>
<td>
<p>Atomic integer. Specify the number of trees in the forest.
Defaults to 500.</p>
</td></tr>
<tr><td><code id="MetaForest_+3A_mtry">mtry</code></td>
<td>
<p>Atomic integer. Number of candidate moderators available for each
split. Defaults to the square root of the number moderators (rounded down).</p>
</td></tr>
<tr><td><code id="MetaForest_+3A_method">method</code></td>
<td>
<p>Character. Specify the method by which to estimate the residual
variance. Can be set to one of the following: &quot;DL&quot;, &quot;HE&quot;, &quot;SJ&quot;, &quot;ML&quot;, &quot;REML&quot;,
&quot;EB&quot;, &quot;HS&quot;, or &quot;GENQ&quot;. Default is &quot;REML&quot;. See the
<code><a href="metafor.html#topic+rma.uni">metafor</a></code> package for more information about
these estimators.</p>
</td></tr>
<tr><td><code id="MetaForest_+3A_tau2">tau2</code></td>
<td>
<p>Numeric. Specify a predetermined value for the residual
heterogeneity. Entering a value here supersedes the estimated tau2 value.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="MetaForest_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed directly to <a href="ranger.html#topic+ranger">ranger</a>.
It is recommended not to use additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For dependent data, a clustered MetaForest analysis is more
appropriate. This is because the predictive performance of a MetaForest
analysis is evaluated on out-of-bootstrap cases, and when cases out of the
bootstrap sample originate from the same study, the model will be overly
confident in its ability to predict their value. When the MetaForest is
clustered by the <code>study</code> variable, the dataset is first split into two
cross-validation samples by study. All dependent effect sizes from each study
are thus included in the same cross-validation sample. Then, two random
forests are grown on these cross-validation samples, and for each random
forest, the other sample is used to calculate prediction error and variable
importance, see <a href="https://doi.org/10.1007/s11634-016-0276-4">doi:10.1007/s11634-016-0276-4</a>.
</p>


<h3>Value</h3>

<p>List of length 3. The &quot;forest&quot; element of this list is an object of
class &quot;ranger&quot;, containing the results of the random forests analysis. The
&quot;rma_before&quot; element is an object of class &quot;rma.uni&quot;, containing the results
of a random-effects meta-analysis on the raw data, without moderators. The
&quot;rma_after&quot; element is an object of class &quot;rma.uni&quot;, containing the results
of a random-effects meta-analysis on the residual heterogeneity, or the
difference between the effect sizes predicted by MetaForest and the observed
effect sizes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
#Simulate data with a univariate linear model
set.seed(42)
data &lt;- SimulateSMD()
#Conduct unweighted MetaForest analysis
mf.unif &lt;- MetaForest(formula = yi ~ ., data = data$training,
                      whichweights = "unif", method = "DL")
#Print model
mf.unif
#Conduct random-effects weighted MetaForest analysis
mf.random &lt;- MetaForest(formula = yi ~ ., data = data$training,
                        whichweights = "random", method = "DL",
                        tau2 = 0.0116)
#Print summary
summary(mf.random)

#Example 2: Real data from metafor
#Load and clean data
data &lt;- dat.bangertdrowns2004
data[, c(4:12)] &lt;- apply(data[ , c(4:12)], 2, function(x){
  x[is.na(x)] &lt;- median(x, na.rm = TRUE)
  x})
data$subject &lt;- factor(data$subject)
data$yi &lt;- as.numeric(data$yi)
#Conduct MetaForest analysis
mf.bd2004 &lt;- MetaForest(formula = yi~ grade + length + minutes + wic+
                               meta, data, whichweights = "unif")
#Print MetaForest object
mf.bd2004
#Check convergence plot
plot(mf.bd2004)
#Check summary
summary(mf.bd2004, digits = 4)
#Examine variable importance plot
VarImpPlot(mf.bd2004)
</code></pre>

<hr>
<h2 id='ModelInfo_mf'>Returns a MetaForest ModelInfo list for use with caret</h2><span id='topic+ModelInfo_mf'></span>

<h3>Description</h3>

<p>This function allows users to rely on the powerful <code>caret</code> package for
cross-validating and tuning a MetaForest analysis. Methods for MetaForest
are not included in the caret package, because the interface of caret is not
entirely compatible with MetaForest's model call. Specifically, MetaForest is
not compatible with the <code>train</code> methods for classes 'formula' or
'recipe', because the variance of the effect size must be a column of the
training data x. The name of this column is specified using the argument
'vi'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModelInfo_mf()
</code></pre>


<h3>Details</h3>

<p>To train a clustered MetaForest, for nested data structures, simply provide
the optional argument 'study' to the train function, to specify the study ID.
This should again refer to a column of x.
</p>
<p>When training a clustered MetaForest, make sure to use
'index = groupKFold(your_study_id_variable, k = 10))' in traincontrol, to
sample by study ID when creating cross-validation partitions; otherwise the
testing error will be positively biased.
</p>


<h3>Value</h3>

<p>ModelInfo list of length 17.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Prepare data
data &lt;- dat.bangertdrowns2004
data[, c(4:12)] &lt;- apply(data[ , c(4:12)], 2, function(x){
  x[is.na(x)] &lt;- median(x, na.rm = TRUE)
  x})
data$subject &lt;- factor(data$subject)
data$yi &lt;- as.numeric(data$yi)
# Load caret
library(caret)
set.seed(999)
# Specify the resampling method as 10-fold CV
fit_control &lt;- trainControl(method = "cv", number = 10)
cv_mf_fit &lt;- train(y = data$yi, x = data[,c(3:13, 16)],
                   method = ModelInfo_mf(), trControl = fit_control)


# Cross-validated clustered MetaForest
data &lt;- get(data(dat.bourassa1996))
data &lt;- escalc(measure = "OR", ai = lh.le, bi = lh.re, ci = rh.le, di= rh.re,
               data = data, add = 1/2, to = "all")
data$mage[is.na(data$mage)] &lt;- median(data$mage, na.rm = TRUE)
data[c(5:8)] &lt;- lapply(data[c(5:8)], factor)
data$yi &lt;- as.numeric(data$yi)
# Set up 10-fold grouped CV
fit_control &lt;- trainControl(method = "cv", index = groupKFold(data$sample,
                            k = 10))
# Set up a custom tuning grid for the three tuning parameters of MetaForest
rf_grid &lt;- expand.grid(whichweights = c("random", "fixed", "unif"),
                       mtry = c(2, 4, 6),
                       min.node.size = c(2, 4, 6))
# Train the model
cv.mf.cluster &lt;- train(y = data$yi, x = data[, c("selection", "investigator",
                                                 "hand_assess", "eye_assess",
                                                 "mage", "sex", "vi",
                                                 "sample")],
                       study = "sample", method = ModelInfo_mf(),
                       trControl = fit_control,
                       tuneGrid = rf_grid)

## End(Not run)
</code></pre>

<hr>
<h2 id='ModelInfo_rma'>Returns an rma ModelInfo list for use with caret</h2><span id='topic+ModelInfo_rma'></span>

<h3>Description</h3>

<p>This function allows users to rely on the powerful <code>caret</code> package for
cross-validating and tuning a rma analysis. Methods for rma are not included
in the caret package, because the interface of caret is not entirely
compatible with rma's model call. Specifically, rma is not compatible with
the <code>train</code> methods for classes 'formula' or 'recipe'. The  variance of
the effect sizes can be passed to the 'weights' parameter of <code>train</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModelInfo_rma()
</code></pre>


<h3>Details</h3>

<p>When using clustered data (effect sizes within studies), make sure to use
'index = groupKFold(your_study_id_variable, k = 10))' in traincontrol, to
sample by study ID when creating cross-validation partitions; otherwise the
testing error will be positively biased.
</p>


<h3>Value</h3>

<p>ModelInfo list of length 13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Prepare data
dat &lt;- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
dat$yi &lt;- as.numeric(dat$yi)
dat$alloc &lt;- factor(dat$alloc)
# Run rma
rma.model &lt;- rma(y = dat$yi, mods = dat[, c("ablat", "year")], vi = dat$vi)
# R^2 is estimated to be .64
rma.model$R2
# Now, use cross-validation to see how well this model generalizes
# Leave-one-out cross-validation is more appropriate than 10-fold cv because
# the sample size is very small
fit_control &lt;- trainControl(method = "LOOCV")
# Train the model without tuning, because rma has no tuning parameters
cv.mf.cluster &lt;- train(y = dat$yi, x = dat[, c("ablat", "year")],
                       weights = dat$vi,
                       method = ModelInfo_rma(),
                       trControl = fit_control)
# Cross-validated R^2 is .08, suggesting substantial overfitting of the
# original rma model
cv.mf.cluster$results$Rsquared

## End(Not run)
</code></pre>

<hr>
<h2 id='PartialDependence'>PartialDependence: Partial dependence plots</h2><span id='topic+PartialDependence'></span>

<h3>Description</h3>

<p>Partial dependence plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PartialDependence(
  x,
  vars = NULL,
  pi = NULL,
  rawdata = FALSE,
  bw = FALSE,
  resolution = NULL,
  moderator = NULL,
  mod_levels = NULL,
  output = "plot",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PartialDependence_+3A_x">x</code></td>
<td>
<p>Model object.</p>
</td></tr>
<tr><td><code id="PartialDependence_+3A_vars">vars</code></td>
<td>
<p>Character vector containing the moderator names for which to plot
partial dependence plots. If empty, all moderators are plotted.</p>
</td></tr>
<tr><td><code id="PartialDependence_+3A_pi">pi</code></td>
<td>
<p>Numeric (0-1). What percentile interval should be plotted for the
partial dependence predictions? Defaults to NULL. To obtain a 95% interval,
set to <code>.95</code>.</p>
</td></tr>
<tr><td><code id="PartialDependence_+3A_rawdata">rawdata</code></td>
<td>
<p>Logical, indicating whether to plot weighted raw data.
Defaults to FALSE. Uses the same weights as the model object passed to the
<code>x</code> argument.</p>
</td></tr>
<tr><td><code id="PartialDependence_+3A_bw">bw</code></td>
<td>
<p>Logical, indicating whether the plot should be black and white, or
color.</p>
</td></tr>
<tr><td><code id="PartialDependence_+3A_resolution">resolution</code></td>
<td>
<p>Integer vector of length two, giving the resolution of the
partial predictions. The first element indicates the resolution of the
partial predictions; for Monte-Carlo integration, the second element gives
the number of rows of the data to be sampled without replacement when
averaging over values of the other predictors.</p>
</td></tr>
<tr><td><code id="PartialDependence_+3A_moderator">moderator</code></td>
<td>
<p>Atomic character vector, referencing the name of one
variable in the model. Results in partial prediction plots, conditional on
the moderator. If <code>moderator</code> references a factor variable, separate
lines/boxplots are plotted for each factor level. If <code>moderator</code>
references a numeric variable, heatmaps are plotted - unless the moderator is
categorized using the <code>mod_levels</code> argument.</p>
</td></tr>
<tr><td><code id="PartialDependence_+3A_mod_levels">mod_levels</code></td>
<td>
<p>Vector. If <code>moderator</code> is continuous, specify
thresholds for the <code><a href="base.html#topic+cut">cut</a></code> function. The continuous moderator
is categorized, and predictions are based on the median moderator value
within each category. You can call <code><a href="stats.html#topic+quantile">quantile</a></code> to cut the
moderator at specific quantiles. If <code>moderator</code> is a factor variable,
you can use <code>mod_levels</code> to specify a character vector with the factor
levels to retain in the plot (i.e., dropping the other factor levels).</p>
</td></tr>
<tr><td><code id="PartialDependence_+3A_output">output</code></td>
<td>
<p>Character. What type of output should be returned? Defaults to
<code>"plot"</code>, which returns and plots a gtable object. To obtain a list of
<code>ggplot</code> objects instead, provide the argument <code>"list"</code>.</p>
</td></tr>
<tr><td><code id="PartialDependence_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to and from functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots partial dependence plots (predicted effect size as a function of the
value of each predictor variable) for a MetaForest- or rma model object. For
rma models, it is advisable to mean-center numeric predictors, and to not
include plot_int effects, except when the rma model is bivariate, and the
<code>plot_int</code> argument is set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A gtable object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#' # Partial dependence plot for MetaForest() model:
set.seed(42)
data &lt;- SimulateSMD(k_train = 200, model = es * x[, 1] + es * x[, 2] + es *
                                           x[, 1] * x[, 2])$training
data$X2 &lt;- cut(data$X2, breaks = 2, labels = c("Low", "High"))
mf.random &lt;- MetaForest(formula = yi ~ ., data = data,
                        whichweights = "random", method = "DL",
                        tau2 = 0.2450)
# Examine univariate partial dependence plot for all variables in the model:
PartialDependence(mf.random, pi = .8)
# Examine bivariate partial dependence plot the plot_int between X1 and X2:
pd.plot &lt;- PartialDependence(mf.random, vars = c("X1", "X2"), plot_int = TRUE)
# Save to pdf file
pdf("pd_plot.pdf")
grid.draw(pd.plot)
dev.off()
# Partial dependence plot for metafor rma() model:
dat &lt;- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
dat$yi &lt;- as.numeric(dat$yi)
dat$alloc &lt;- factor(dat$alloc)
dat$ablat_d &lt;- cut(dat$ablat, breaks = 2, labels = c("low", "high"))
# Demonstrate partial dependence plot for a bivariate plot_int
rma.model.int &lt;- rma(yi, vi, mods=cbind(ablat, tpos),
                     data=dat, method="REML")
PartialDependence(rma.model.int, rawdata = TRUE, pi = .95,
                  plot_int = TRUE)

# Compare partial dependence for metaforest and rma
dat2 &lt;- dat
dat2[3:7] &lt;- lapply(dat2[3:7],
                    function(x){as.numeric(scale(x, scale = FALSE))})
mf.model.all &lt;- MetaForest(yi ~ ., dat2[, c(3:11)])
rma.model.all &lt;- rma(dat$yi, dat2$vi,
                  mods = model.matrix(yi~., dat2[, c(3:10)])[, -1],
                  method="REML")
PartialDependence(mf.model.all, rawdata = TRUE, pi = .95)
PartialDependence(rma.model.all, rawdata = TRUE, pi = .95)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.MetaForest'>Plots cumulative MSE for a MetaForest object.</h2><span id='topic+plot.MetaForest'></span>

<h3>Description</h3>

<p>Plots cumulative MSE for a MetaForest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MetaForest'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.MetaForest_+3A_x">x</code></td>
<td>
<p>MetaForest object.</p>
</td></tr>
<tr><td><code id="plot.MetaForest_+3A_y">y</code></td>
<td>
<p>not used for plot.MetaForest</p>
</td></tr>
<tr><td><code id="plot.MetaForest_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, not used for plot.MetaForest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object, visualizing the number of trees on the x-axis, and
the cumulative mean of the MSE of that number of trees on the y-axis. As a
visual aid to assess convergence, a dashed gray line is plotted at the median
cumulative MSE value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
</code></pre>

<hr>
<h2 id='predict.MetaForest'>MetaForest prediction</h2><span id='topic+predict.MetaForest'></span>

<h3>Description</h3>

<p>MetaForest prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MetaForest'
predict(object, data = NULL, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.MetaForest_+3A_object">object</code></td>
<td>
<p><code>MetaForest</code> object.</p>
</td></tr>
<tr><td><code id="predict.MetaForest_+3A_data">data</code></td>
<td>
<p>New test data of class <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="predict.MetaForest_+3A_type">type</code></td>
<td>
<p>Type of prediction. One of 'response', 'se', 'terminalNodes' with default 'response'. See below for details.</p>
</td></tr>
<tr><td><code id="predict.MetaForest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>MetaForest.prediction</code> with elements
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>predictions</code>    </td><td style="text-align: left;"> Predicted classes/values (only for classification and regression)  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>num.trees</code>   </td><td style="text-align: left;"> Number of trees. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>num.independent.variables</code> </td><td style="text-align: left;"> Number of independent variables. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>treetype</code>    </td><td style="text-align: left;"> Type of forest/tree. Classification, regression or survival. </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>num.samples</code>     </td><td style="text-align: left;"> Number of samples.
  </td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="ranger.html#topic+ranger">ranger</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(56)
data &lt;- SimulateSMD(k_train = 100, model = es * x[,1] * x[,2])
#Conduct fixed-effects MetaForest analysis
mf.fixed &lt;- MetaForest(formula = yi ~ ., data = data$training,
                      whichweights = "fixed", method = "DL")
predicted &lt;- predict(mf.fixed, data = data$testing)$predictions
r2_cv &lt;- sum((predicted - mean(data$training$yi)) ^ 2)/
         sum((data$testing$yi - mean(data$training$yi)) ^ 2)
</code></pre>

<hr>
<h2 id='preselect'>Preselect variables for MetaForest analysis</h2><span id='topic+preselect'></span>

<h3>Description</h3>

<p>Takes a <code><a href="#topic+MetaForest">MetaForest</a></code> object, and applies different
algorithms for variable selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preselect(x, replications = 100L, algorithm = "replicate", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preselect_+3A_x">x</code></td>
<td>
<p>Model to perform variable selection for. Accepts MetaForest objects.</p>
</td></tr>
<tr><td><code id="preselect_+3A_replications">replications</code></td>
<td>
<p>Integer. Number of replications to run for variable
preselection. Default: 100.</p>
</td></tr>
<tr><td><code id="preselect_+3A_algorithm">algorithm</code></td>
<td>
<p>Character. Preselection method to apply. Currently,
'replicate', 'recursive', and 'bootstrap' are available.</p>
</td></tr>
<tr><td><code id="preselect_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to and from functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, available methods under <code>algorithm</code> are:
</p>

<dl>
<dt>replicate</dt><dd><p>This simply replicates the analysis, which means the forest
has access to the full data set, but the trees are grown on different
bootstrap samples across replications (thereby varying monte carlo error).</p>
</dd>
<dt>bootstrap</dt><dd><p>This replicates the analysis on bootstrapped samples, which
means each replication has access to a different sub-sample of the full data
set. When selecting this algorithm, cases are either bootstrap-sampled by
<code>study</code>, or a new <code>study</code> column is generated, and a clustered
MetaForest is grown (because some of the rows in the data will be duplicated)
, and this would lead to an under-estimation of the OOB error.</p>
</dd>
<dt>recursive</dt><dd><p>Starting with all moderators, the variable with the most
negative variable importance is dropped from the model, and the analysis
re-run. This is repeated until only variables with a positive variable
importance are left, or no variables are left. The proportion of final models
containing each variable reflects its importance.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class 'mf_preselect'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- get(data(dat.bourassa1996))
data &lt;- escalc(measure = "OR", ai = lh.le, bi = lh.re, ci = rh.le, di= rh.re,
               data = data, add = 1/2, to = "all")
data$mage[is.na(data$mage)] &lt;- median(data$mage, na.rm = TRUE)
data[c(5:8)] &lt;- lapply(data[c(5:8)], factor)
data$yi &lt;- as.numeric(data$yi)
mf.model &lt;- MetaForest(formula = yi~ selection + investigator + hand_assess + eye_assess +
                        mage +sex,
          data, study = "sample",
          whichweights = "unif", num.trees = 300)
preselect(mf.model,
          replications = 10,
          algorithm = "bootstrap")

## End(Not run)
</code></pre>

<hr>
<h2 id='preselect_vars'>Extract variable names from mf_preselect object</h2><span id='topic+preselect_vars'></span>

<h3>Description</h3>

<p>Returns a vector of variable names from an mf_preselect object,
based on a cutoff criterion provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preselect_vars(x, cutoff = NULL, criterion = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preselect_vars_+3A_x">x</code></td>
<td>
<p>Object of class mf_preselect.</p>
</td></tr>
<tr><td><code id="preselect_vars_+3A_cutoff">cutoff</code></td>
<td>
<p>Numeric. Must be a value between 0 and 1. By default, uses .95
for bootstrapped preselection, and .1 for recursive preselection.</p>
</td></tr>
<tr><td><code id="preselect_vars_+3A_criterion">criterion</code></td>
<td>
<p>Character. Which criterion to use. See <code>Details</code> for
more information. By default, uses 'ci' (confidence interval) for
bootstrapped preselection, and 'p' (proportion) for recursive preselection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>criterion = 'p'</code>, the function evaluates the proportion of
replications in which a variable achieved a positive (&gt;0) variable
importance. For <code>criterion = 'ci'</code>, the function evaluates whether the
lower bound of a confidence interval of a variable's importance across
replications exceeds zero. The width of the confidence interval is determined
by <code>cutoff</code>.
</p>
<p>For recursive preselection, any variable not included in a final
model is assigned zero importance.
</p>


<h3>Value</h3>

<p>Character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- get(data(dat.bourassa1996))
data &lt;- escalc(measure = "OR", ai = lh.le, bi = lh.re, ci = rh.le, di= rh.re,
               data = data, add = 1/2, to = "all")
data$mage[is.na(data$mage)] &lt;- median(data$mage, na.rm = TRUE)
data[c(5:8)] &lt;- lapply(data[c(5:8)], factor)
data$yi &lt;- as.numeric(data$yi)
preselected &lt;- preselect(formula = yi~ selection + investigator + hand_assess + eye_assess +
                        mage +sex,
          data, study = "sample",
          whichweights = "unif", num.trees = 300,
          replications = 10,
          algorithm = "bootstrap")
preselect_vars(preselected)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.summary.MetaForest'>Prints summary.MetaForest object.</h2><span id='topic+print.summary.MetaForest'></span>

<h3>Description</h3>

<p>Prints summary.MetaForest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.MetaForest'
print(x, digits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.MetaForest_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.summary.MetaForest_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see <code>print.default</code>.</p>
</td></tr>
<tr><td><code id="print.summary.MetaForest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
</code></pre>

<hr>
<h2 id='report'>Report formatted number</h2><span id='topic+report'></span>

<h3>Description</h3>

<p>Report a number, rounded to a specific number of decimals (defaults to two),
using C-style formats. Intended for RMarkdown reports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report(x, digits = 2, equals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_+3A_x">x</code></td>
<td>
<p>Numeric. Value to be reported</p>
</td></tr>
<tr><td><code id="report_+3A_digits">digits</code></td>
<td>
<p>Integer. Number of digits to round to.</p>
</td></tr>
<tr><td><code id="report_+3A_equals">equals</code></td>
<td>
<p>Logical. Whether to report an equals (or: smaller than) sign.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An atomic character vector.
</p>


<h3>Author(s)</h3>

<p>Caspar J. van Lissa
</p>

<hr>
<h2 id='SimulateSMD'>Simulates a meta-analytic dataset</h2><span id='topic+SimulateSMD'></span>

<h3>Description</h3>

<p>This function simulates a meta-analytic dataset based on the random-effects
model. The simulated effect size is Hedges' G, an estimator of the
Standardized Mean Difference.
The functional form of the model can be specified, and moderators can be
either normally distributed or Bernoulli-distributed. See Van Lissa, 2018,
for a detailed explanation of the simulation procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateSMD(
  k_train = 20,
  k_test = 100,
  mean_n = 40,
  es = 0.5,
  tau2 = 0.04,
  moderators = 5,
  distribution = "normal",
  model = es * x[, 1]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateSMD_+3A_k_train">k_train</code></td>
<td>
<p>Atomic integer. The number of studies in the training dataset.
Defaults to 20.</p>
</td></tr>
<tr><td><code id="SimulateSMD_+3A_k_test">k_test</code></td>
<td>
<p>Atomic integer. The number of studies in the testing dataset.
Defaults to 100.</p>
</td></tr>
<tr><td><code id="SimulateSMD_+3A_mean_n">mean_n</code></td>
<td>
<p>Atomic integer. The mean sample size of each simulated study in
the meta-analytic dataset. Defaults to 40. For each simulated study, the
sample size n is randomly drawn from a normal distribution with mean mean_n,
and sd mean_n/3.</p>
</td></tr>
<tr><td><code id="SimulateSMD_+3A_es">es</code></td>
<td>
<p>Atomic numeric vector. The effect size, also known as beta, used in
the model statement. Defaults to .5.</p>
</td></tr>
<tr><td><code id="SimulateSMD_+3A_tau2">tau2</code></td>
<td>
<p>Atomic numeric vector. The residual heterogeneity.
Defaults to 0.04.</p>
</td></tr>
<tr><td><code id="SimulateSMD_+3A_moderators">moderators</code></td>
<td>
<p>Atomic integer. The number of moderators to simulate for
each study. Make sure that the number of moderators to be simulated is at
least as large as the number of moderators referred to in the model
parameter. Internally, the matrix of moderators is referred to as &quot;x&quot;.
Defaults to 5.</p>
</td></tr>
<tr><td><code id="SimulateSMD_+3A_distribution">distribution</code></td>
<td>
<p>Atomic character. The distribution of the moderators.
Can be set to either &quot;normal&quot; or &quot;bernoulli&quot;. Defaults to &quot;normal&quot;.</p>
</td></tr>
<tr><td><code id="SimulateSMD_+3A_model">model</code></td>
<td>
<p>Expression. An expression to specify the model from which to
simulate the mean true effect size, mu. This formula may use the terms &quot;es&quot;
(referring to the es parameter of the call to SimulateSMD), and &quot;x[, ]&quot;
(referring to the matrix of moderators, x). Thus, to specify that the mean
effect size, mu, is a function of the effect size and the first moderator,
one would pass the value <code>model = es * x[ , 1]</code>.
Defaults to es * x[ , 1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 4. The &quot;training&quot; element of this list is a data.frame
with k_train rows. The columns are the variance of the effect size, vi; the
effect size, yi, and the moderators, X. The &quot;testing&quot; element of this list is
a data.frame with k_test rows. The columns are the effect size, yi, and the
moderators, X. The &quot;housekeeping&quot; element of this list is a data.frame with
k_train + k_test rows. The columns are n, the sample size n for each
simulated study; mu_i, the mean true effect size for each simulated study;
and theta_i, the true effect size for each simulated study.
</p>


<h3>References</h3>

<p>Van Lissa, C. J. (2020). Small sample meta-analyses: exploring
heterogeneity using metaForest. In R. Van De Schoot &amp; M. Miočević (Eds.),
Small sample size solutions (open access): A guide for applied researchers
and practitioners. CRC Press (pp.186–202). <a href="https://doi.org/10.4324/9780429273872-16">doi:10.4324/9780429273872-16</a>
Van Lissa, C. J. (2018). MetaForest: Exploring heterogeneity in meta-analysis
using random forests. PsyArxiv. <a href="https://doi.org/10.31234/osf.io/myg6s">doi:10.31234/osf.io/myg6s</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(8)
SimulateSMD()
SimulateSMD(k_train = 50, distribution = "bernoulli")
SimulateSMD(distribution = "bernoulli", model = es * x[ ,1] * x[ ,2])
</code></pre>

<hr>
<h2 id='VarImpPlot'>Plots variable importance for a MetaForest object.</h2><span id='topic+VarImpPlot'></span>

<h3>Description</h3>

<p>Plots variable importance for a MetaForest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarImpPlot(mf, n.var = 30, sort = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarImpPlot_+3A_mf">mf</code></td>
<td>
<p>MetaForest object.</p>
</td></tr>
<tr><td><code id="VarImpPlot_+3A_n.var">n.var</code></td>
<td>
<p>Number of moderators to plot.</p>
</td></tr>
<tr><td><code id="VarImpPlot_+3A_sort">sort</code></td>
<td>
<p>Should the moderators be sorted from most to least important?</p>
</td></tr>
<tr><td><code id="VarImpPlot_+3A_...">...</code></td>
<td>
<p>Parameters passed to and from other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
data &lt;- SimulateSMD()
mf.random &lt;- MetaForest(formula = yi ~ ., data = data$training,
                        whichweights = "random", method = "DL",
                        tau2 = 0.0116)
VarImpPlot(mf.random)
VarImpPlot(mf.random, n.var = 2)
VarImpPlot(mf.random, sort = FALSE)
</code></pre>

<hr>
<h2 id='WeightedScatter'>Plots weighted scatterplots for meta-analytic data. Can plot effect size as
a function of either continuous (numeric, integer) or categorical (factor,
character) predictors.</h2><span id='topic+WeightedScatter'></span>

<h3>Description</h3>

<p>Plots weighted scatterplots for meta-analytic data. Can plot effect size as
a function of either continuous (numeric, integer) or categorical (factor,
character) predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeightedScatter(
  data,
  yi = "yi",
  vi = "vi",
  vars = NULL,
  tau2 = NULL,
  summarize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WeightedScatter_+3A_data">data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="WeightedScatter_+3A_yi">yi</code></td>
<td>
<p>Character. The name of the column in <code>data</code> that contains the
meta-analysis effect sizes. Defaults to <code>"yi"</code>.</p>
</td></tr>
<tr><td><code id="WeightedScatter_+3A_vi">vi</code></td>
<td>
<p>Character. The name of the column in the <code>data</code> that contains
the variances of the effect sizes. Defaults to <code>"vi"</code>. By default,
<code>vi</code> is used to calculate fixed-effects weights, because fixed effects
weights summarize the data set at hand, rather than generalizing to the
population.</p>
</td></tr>
<tr><td><code id="WeightedScatter_+3A_vars">vars</code></td>
<td>
<p>Character vector containing the names of specific moderator
variables to plot. When set to <code>NULL</code>, the default, all moderators
are plotted.</p>
</td></tr>
<tr><td><code id="WeightedScatter_+3A_tau2">tau2</code></td>
<td>
<p>Numeric. Provide an optional value for tau2. If this value is
provided, random-effects weights will be used instead of fixed-effects
weights.</p>
</td></tr>
<tr><td><code id="WeightedScatter_+3A_summarize">summarize</code></td>
<td>
<p>Logical. Should summary stats be displayed? Defaults to
FALSE. If TRUE, a smooth trend line is displayed for continuous variables,
using [stats::loess()] for less than 1000 observations, and [mgcv::gam()] for
larger datasets. For categorical variables, box-and-whiskers plots are
displayed. Outliers are omitted, because the raw data fulfill this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gtable object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(42)
data &lt;- SimulateSMD(k_train = 100, model = es * x[, 1] + es * x[, 2] + es *
                      x[, 1] * x[, 2])$training
data$X2 &lt;- cut(data$X2, breaks = 2, labels = c("Low", "High"))
data$X3 &lt;- cut(data$X3, breaks = 2, labels = c("Small", "Big"))
WeightedScatter(data, summarize = FALSE)
WeightedScatter(data, vars = c("X3"))
WeightedScatter(data, vars = c("X1", "X3"))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
