<!DOCTYPE html><html><head><title>Help for package ctmva</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ctmva}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ctmva-package'><p>Continuous-time multivariate analysis</p></a></li>
<li><a href='#cca.ct'><p>Continuous-time canonical correlation analysis</p></a></li>
<li><a href='#center.ct'><p>Center a continuous-time multivariate data set</p></a></li>
<li><a href='#cor.ct'><p>Continuous-time correlation or cross-correlation matrix</p></a></li>
<li><a href='#cov.ct'><p>Continuous-time covariance or cross-covariance matrix</p></a></li>
<li><a href='#inprod.cent'><p>Centered inner product matrix for a basis or pair of bases</p></a></li>
<li><a href='#kmeans.ct'><p>Continuous-time k-means clustering</p></a></li>
<li><a href='#lda.ct'><p>Continuous-time Fisher's linear discriminant analysis</p></a></li>
<li><a href='#meanbasis'><p>Compute means of basis functions</p></a></li>
<li><a href='#pca.ct'><p>Continuous-time principal component analysis</p></a></li>
<li><a href='#plot.kmeans.ct'><p>Plot a kmeans.ct object</p></a></li>
<li><a href='#plot.lda.ct'><p>Plot an lda.ct object</p></a></li>
<li><a href='#plot.silhouette.ct'><p>Plot a silhouette.ct object</p></a></li>
<li><a href='#silhouette.ct'><p>Silhouettes for continuous-time k-means clustering</p></a></li>
<li><a href='#standardize.ct'><p>Center and scale a continuous-time multivariate data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous-Time Multivariate Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Biplab Paul &lt;paul.biplab497@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a basis function or functional data analysis framework
             for several techniques of multivariate analysis in continuous-time 
             setting. Specifically, we introduced continuous-time analogues of
             several classical techniques of multivariate analysis, such as 
             principal component analysis, canonical correlation analysis, 
             Fisher linear discriminant analysis, K-means clustering, and so 
             on. Details are in Biplab Paul, Philip T. Reiss and Erjia Cui (2023) 
             "Continuous-time multivariate analysis" &lt;<a href="https://doi.org/10.48550%2FarXiv.2307.09404">doi:10.48550/arXiv.2307.09404</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>fda, polynom</td>
</tr>
<tr>
<td>Suggests:</td>
<td>eegkit, corrplot</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Biplab Paul [aut, cre],
  Philip Tzvi Reiss [aut]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 11:12:57 UTC; GOBINDO</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ctmva-package'>Continuous-time multivariate analysis</h2><span id='topic+ctmva-package'></span><span id='topic+ctmva'></span>

<h3>Description</h3>

<p>Implements continuous-time analogues of several classical techniques of multivariate analysis.
The inputs are <code>"<a href="fda.html#topic+fd">fd</a>"</code> (functional data) objects from the <span class="pkg">fda</span> package.
</p>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>References</h3>

<p>Paul, B., Reiss, P. T. and Cui, E. (2023). Continuous-time multivariate analysis. arXiv:2307.09404 [stat.ME]
</p>

<hr>
<h2 id='cca.ct'>Continuous-time canonical correlation analysis</h2><span id='topic+cca.ct'></span>

<h3>Description</h3>

<p>A continuous-time version of canonical correlation analysis (CCA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cca.ct(fdobj1, fdobj2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cca.ct_+3A_fdobj1">fdobj1</code>, <code id="cca.ct_+3A_fdobj2">fdobj2</code></td>
<td>
<p>a pair of continuous-time multivariate data sets, of class <code>"<a href="fda.html#topic+fd">fd</a>"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of
</p>
<table>
<tr><td><code>vex1</code>, <code>vex2</code></td>
<td>
<p>matrices defining the canonical variates. The first columns of each give the coefficients defining the first pair of canonical variates; and so on.</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>canonical correlations, i.e., correlations between the pairs of canonical variates</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Columns of the output matrix <code>vex2</code> are flipped as needed to ensure positive correlations.
</p>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cancor">cancor</a></code>, for classical CCA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# CCA relating Canadian daily temperature and precipitation data
require(fda)
data(CanadianWeather)
daybasis &lt;- create.bspline.basis(c(0,365), nbasis=80)
tempfd &lt;- smooth.basis(day.5, CanadianWeather$dailyAv[,,"Temperature.C"], daybasis)$fd
precfd &lt;- smooth.basis(day.5, CanadianWeather$dailyAv[,,"log10precip"], daybasis)$fd
tpcor &lt;- cca.ct(tempfd, precfd)
par(mfrow=1:2)
barplot(tpcor$vex1[,1], horiz=TRUE, las=1, main="Temperature",
            sub="First canonical coefficients vector")
barplot(tpcor$vex2[,1], horiz=TRUE, las=1, main="Log precipitation",
            sub="First canonical coefficients vector")


## End(Not run)


</code></pre>

<hr>
<h2 id='center.ct'>Center a continuous-time multivariate data set</h2><span id='topic+center.ct'></span>

<h3>Description</h3>

<p>Subtracts the (continuous-time) mean of each of the variables. This is analogous
to column-centering an <code class="reqn">n \times p</code> data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center.ct(fdobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center.ct_+3A_fdobj">fdobj</code></td>
<td>
<p>continuous-time multivariate data set of class <code>"<a href="fda.html#topic+fd">fd</a>"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A centered version of the input data.
</p>


<h3>Author(s)</h3>

<p>Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standardize.ct">standardize.ct</a></code>
</p>

<hr>
<h2 id='cor.ct'>Continuous-time correlation or cross-correlation matrix</h2><span id='topic+cor.ct'></span>

<h3>Description</h3>

<p>Computes the correlation matrix of a continuous-time multivariate
data set represented as an <code><a href="fda.html#topic+fd">fd</a></code> object; or the cross-correlation
matrix of two such data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.ct(fdobj1, fdobj2 = fdobj1, common_trend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor.ct_+3A_fdobj1">fdobj1</code></td>
<td>
<p>continuous-time multivariate data set of class <code>"<a href="fda.html#topic+fd">fd</a>"</code></p>
</td></tr>
<tr><td><code id="cor.ct_+3A_fdobj2">fdobj2</code></td>
<td>
<p>an optional second data set</p>
</td></tr>
<tr><td><code id="cor.ct_+3A_common_trend">common_trend</code></td>
<td>
<p>logical: centering wrt mean function if <code>TRUE</code>,
without centering if <code>FALSE</code> (the default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of (cross-) correlations
</p>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="fda.html#topic+center.fd">center.fd</a></code>, for centering of <code>"<a href="fda.html#topic+fd">fd</a>"</code> objects;  <code><a href="#topic+inprod.cent">inprod.cent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Canadian temperature data

require(fda)
require(corrplot)
data(CanadianWeather)
daybasis &lt;- create.fourier.basis(c(0,365), nbasis=55)
tempfd &lt;- smooth.basis(day.5, CanadianWeather$dailyAv[,,"Temperature.C"], daybasis)$fd

## The following yields a matrix of correlations that are all near 1:
rawcor &lt;- cor.ct(tempfd)
corrplot(rawcor, method = 'square', type = 'lower', tl.col="black", tl.cex = 0.6)
## This occurs due to a strong seasonal trend that is common to all stations
## Removing this common trend leads to a more interesting result:
dtcor  &lt;- cor.ct(tempfd, common_trend = TRUE)
ord &lt;- corrMatOrder(dtcor)
dtcord &lt;- dtcor[ord,ord]
corrplot(dtcord, method = 'square', type = 'lower', tl.col="black", tl.cex = 0.6)


## End(Not run)

</code></pre>

<hr>
<h2 id='cov.ct'>Continuous-time covariance or cross-covariance matrix</h2><span id='topic+cov.ct'></span>

<h3>Description</h3>

<p>Computes the covariance matrix of a continuous-time multivariate
data set represented as an <code><a href="fda.html#topic+fd">fd</a></code> object; or the
cross-covariance matrix of two such data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.ct(fdobj1, fdobj2 = fdobj1, common_trend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.ct_+3A_fdobj1">fdobj1</code></td>
<td>
<p>continuous-time multivariate data set of class <code>"<a href="fda.html#topic+fd">fd</a>"</code></p>
</td></tr>
<tr><td><code id="cov.ct_+3A_fdobj2">fdobj2</code></td>
<td>
<p>an optional second data set</p>
</td></tr>
<tr><td><code id="cov.ct_+3A_common_trend">common_trend</code></td>
<td>
<p>logical: centering with respect to the mean function if <code>TRUE</code>,
without centering if <code>FALSE</code> (the default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of (cross-) covariances
</p>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor.ct">cor.ct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see example for cor.ct, which works similarly

</code></pre>

<hr>
<h2 id='inprod.cent'>Centered inner product matrix for a basis or pair of bases</h2><span id='topic+inprod.cent'></span>

<h3>Description</h3>

<p>Several methods of continous-time multivariate analysis require a matrix of
inner products of pairs of centered functions from a basis, such as a B-spline basis,
or pairs consisting of one function from each of two bases. This function computes
such matrices via 7-point Newton-Cotes integration, which is exact for cubic
B-splines. For a Fourier basis with the inner product taken over the entire range,
a simple closed form is used instead of integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inprod.cent(basis1, basis2 = basis1, rng = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inprod.cent_+3A_basis1">basis1</code></td>
<td>
<p>basis object from the <code><a href="fda.html#topic+fda">fda</a></code> package.</p>
</td></tr>
<tr><td><code id="inprod.cent_+3A_basis2">basis2</code></td>
<td>
<p>an optional second basis</p>
</td></tr>
<tr><td><code id="inprod.cent_+3A_rng">rng</code></td>
<td>
<p>time range. By default, the entire range spanned by the basis, or the intersection of the ranges of the two bases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of inner products of each pair of centered basis functions.
</p>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="fda.html#topic+create.bspline.basis">create.bspline.basis</a></code> from package <code><a href="fda.html#topic+fda">fda</a></code>, for the most commonly used basis object type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fda)
bbasis6 &lt;- create.bspline.basis(nbasis=6)
inprod.cent(bbasis6)
fbasis7 &lt;- create.fourier.basis(nbasis=7)
inprod.cent(fbasis7)

## End(Not run)

</code></pre>

<hr>
<h2 id='kmeans.ct'>Continuous-time k-means clustering</h2><span id='topic+kmeans.ct'></span>

<h3>Description</h3>

<p>A continuous-time version of k-means clustering in which each cluster is a
time segments or set of time segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeans.ct(
  fdobj,
  k,
  common_trend = FALSE,
  init.pts = NULL,
  tol = 0.001,
  max.iter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeans.ct_+3A_fdobj">fdobj</code></td>
<td>
<p>continuous-time multivariate data set of class <code>"<a href="fda.html#topic+fd">fd</a>"</code></p>
</td></tr>
<tr><td><code id="kmeans.ct_+3A_k">k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="kmeans.ct_+3A_common_trend">common_trend</code></td>
<td>
<p>logical: Should the curves be centered with respect to the mean function?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kmeans.ct_+3A_init.pts">init.pts</code></td>
<td>
<p>a set of k time points. The observations at these time points
serve as initial values for the k means. Randomly generated if not supplied.</p>
</td></tr>
<tr><td><code id="kmeans.ct_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance for the k means</p>
</td></tr>
<tr><td><code id="kmeans.ct_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;<code>kmeans.ct</code>&quot;, a list consisting of
</p>
<table>
<tr><td><code>fdobj</code></td>
<td>
<p>the supplied <code>fdobj</code></p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>means of the k clusters</p>
</td></tr>
<tr><td><code>transitions</code></td>
<td>
<p>transition points between segments</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>cluster memberships in the segments defined by the transitions</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>length of each cluster, i.e. sum of lengths of subintervals making up each cluster</p>
</td></tr>
<tr><td><code>totisd</code></td>
<td>
<p>total integrated sum of distances from the overall mean; this is the analogue of <code>totss</code> from <code>link{kmeans}</code></p>
</td></tr>
<tr><td><code>withinisd</code></td>
<td>
<p>within-cluster integrated sum of distances, i.e. integrated sum of distances from each cluster mean</p>
</td></tr>
<tr><td><code>tot.withinisd</code></td>
<td>
<p>total within-cluster integrated sum of distances, i.e. <code>sum(withinisd)</code></p>
</td></tr>
<tr><td><code>betweenisd</code></td>
<td>
<p>between-cluster integrated sum of distances, i.e. <code>totisd-tot.withinss</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="#topic+plot.kmeans.ct">plot.kmeans.ct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fda)
data(CanadianWeather)
daybasis &lt;- create.bspline.basis(c(0,365), nbasis=55)
tempfd &lt;- smooth.basis(day.5, CanadianWeather$dailyAv[,,"Temperature.C"], daybasis)$fd
kmtemp3 &lt;- kmeans.ct(tempfd, 3)
plot(kmtemp3, axes=FALSE)
axesIntervals(); box()
plot(silhouette.ct(kmtemp3), axes=FALSE)
axesIntervals(); box()

## End(Not run)

</code></pre>

<hr>
<h2 id='lda.ct'>Continuous-time Fisher's linear discriminant analysis</h2><span id='topic+lda.ct'></span>

<h3>Description</h3>

<p>A continuous-time version of Fisher's LDA, in which segments of the time
interval take the place of groups of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lda.ct(fdobj, partition, part.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lda.ct_+3A_fdobj">fdobj</code></td>
<td>
<p>continuous-time multivariate data set of class <code>"<a href="fda.html#topic+fd">fd</a>"</code></p>
</td></tr>
<tr><td><code id="lda.ct_+3A_partition">partition</code></td>
<td>
<p>a priori break points dividing the time interval into segments</p>
</td></tr>
<tr><td><code id="lda.ct_+3A_part.names">part.names</code></td>
<td>
<p>optional character vector of names for the segments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>means</code> and <code>scaling</code> components of the output are similar to
<code><a href="MASS.html#topic+lda">lda</a></code>, but unlike that function, <code>lda.ct</code> performs only
<em>Fisher's</em> LDA and cannot incorporate priors or perform classification.
</p>


<h3>Value</h3>

<p>Object of class &quot;<code>lda.ct</code>&quot;, a list consisting of
</p>
<table>
<tr><td><code>means</code></td>
<td>
<p>means of the variables within each segment</p>
</td></tr>
<tr><td><code>scaling</code></td>
<td>
<p>matrix of coefficients defining the discriminants (as in <code><a href="MASS.html#topic+lda">lda</a></code>)</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>eigenvalues giving the ratios of between to within sums of squares</p>
</td></tr>
<tr><td><code>partition</code></td>
<td>
<p>the supplied <code>partition</code></p>
</td></tr>
<tr><td><code>fdobj</code></td>
<td>
<p>linear discriminants represented as an <code>"<a href="fda.html#topic+fd">fd</a>"</code> object</p>
</td></tr>
<tr><td><code>nld</code></td>
<td>
<p>number of linear discriminants</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.lda.ct">plot.lda.ct</a></code>; <code><a href="MASS.html#topic+lda">lda</a></code>, for the classical version
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see end of example in ?pca.ct

</code></pre>

<hr>
<h2 id='meanbasis'>Compute means of basis functions</h2><span id='topic+meanbasis'></span>

<h3>Description</h3>

<p>Given a basis object as defined in the <span class="pkg">fda</span> package (see <code><a href="fda.html#topic+basisfd">basisfd</a></code>),
this function simply computes the vector of means of the basis functions. Used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanbasis(basis, rng = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanbasis_+3A_basis">basis</code></td>
<td>
<p>a basis object of class <code>"<a href="fda.html#topic+basisfd">basisfd</a>"</code></p>
</td></tr>
<tr><td><code id="meanbasis_+3A_rng">rng</code></td>
<td>
<p>time range. By default, the entire interval spanned by the basis. Must be left NULL for Fourier bases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of means of the basis functions
</p>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(fda)
bbasis6 &lt;- create.bspline.basis(nbasis=6)
meanbasis(bbasis6)
meanbasis(bbasis6, c(.3,.6))
fbasis11 &lt;- create.fourier.basis(nbasis=11)
meanbasis(fbasis11)

</code></pre>

<hr>
<h2 id='pca.ct'>Continuous-time principal component analysis</h2><span id='topic+pca.ct'></span>

<h3>Description</h3>

<p>A continuous-time version of principal component analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca.ct(fdobj, cor = FALSE, common_trend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.ct_+3A_fdobj">fdobj</code></td>
<td>
<p>continuous-time multivariate data set of class <code>"<a href="fda.html#topic+fd">fd</a>"</code></p>
</td></tr>
<tr><td><code id="pca.ct_+3A_cor">cor</code></td>
<td>
<p>logical: use correlation matrix if <code>TRUE</code>,
covariance if <code>FALSE</code> (the default)</p>
</td></tr>
<tr><td><code id="pca.ct_+3A_common_trend">common_trend</code></td>
<td>
<p>logical: Should the curves be centered with respect to the mean function?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list including:
</p>
<table>
<tr><td><code>var</code></td>
<td>
<p>variances of the principal components.</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>the matrix of loadings (i.e., its columns are the
eigenvectors of the continuous-time covariance).</p>
</td></tr>
<tr><td><code>scorefd</code></td>
<td>
<p>score functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.ct">cov.ct</a></code>; <code><a href="stats.html#topic+princomp">princomp</a></code>, for the classical version
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Data for one session from a classic EEG data set
require(fda)
require(eegkit)
data(eegdata)
data(eegcoord)
longdat &lt;- subset(eegdata, subject=="co2a0000369" &amp; trial==0)
widedat &lt;- reshape(longdat, direction="wide", drop=c("subject","group","condition","trial"),
                 v.names="voltage",idvar="channel")

# Convert time series for 64 channels to a functional data object
bsb &lt;- create.bspline.basis(c(0,255),nbasis=30)
fdo &lt;- Data2fd(argvals=0:255, y=t(as.matrix(widedat[,-1])), basisobj=bsb)
plot(fdo)

# Now do PCA and display first loadings for 3 PC's,
# along with percent variance explained by each
pcc &lt;- pca.ct(fdo)
pve &lt;- 100*pcc$var/sum(pcc$var)
par(mfrow=c(1,3))
cidx &lt;- match(widedat[,1],rownames(eegcoord))
eegspace(eegcoord[cidx,4:5],pcc$loadings[,1], colorlab="PC1 loadings",
         main=paste0(round(pve[1],0), "%"), mar=c(17,3,12,2), cex.main=2)
eegspace(eegcoord[cidx,4:5],pcc$loadings[,2], colorlab="PC2 loadings",
         main=paste0(round(pve[2],0), "%"), mar=c(17,3,12,2), cex.main=2)
eegspace(eegcoord[cidx,4:5],pcc$loadings[,3], colorlab="PC3 loadings",
         main=paste0(round(pve[3],0), "%"), mar=c(17,3,12,2), cex.main=2)

# Linear discriminant analysis: discriminating among the 1st, 2nd and 3rd portions
#  of the time interval
ld &lt;- lda.ct(fdo, c(85,170))
plot(ld)
eegspace(eegcoord[cidx,4:5],ld$scaling[,1], colorlab="LD1 coefficients",
         mar=c(17,3,12,2), cex.main=2)
eegspace(eegcoord[cidx,4:5],ld$scaling[,2], colorlab="LD2 coefficients",
         mar=c(17,3,12,2), cex.main=2)


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.kmeans.ct'>Plot a kmeans.ct object</h2><span id='topic+plot.kmeans.ct'></span>

<h3>Description</h3>

<p>Plots a continuous-time k-means clustering object generated by a call
to <code><a href="#topic+kmeans.ct">kmeans.ct</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmeans.ct'
plot(
  x,
  plottype = "functions",
  mark.transitions = TRUE,
  col = NULL,
  lty = NULL,
  xlab = "Time",
  ylab = NULL,
  legend = TRUE,
  ncol.legend = 1,
  cex.legend = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.kmeans.ct_+3A_x">x</code></td>
<td>
<p>clustering object produced by <code><a href="#topic+kmeans.ct">kmeans.ct</a></code></p>
</td></tr>
<tr><td><code id="plot.kmeans.ct_+3A_plottype">plottype</code></td>
<td>
<p>either <code>"functions"</code> (the default), to display each variable
as a smooth function of time, or <code>"distance"</code>, to plot distances from the
k cluster means versus time.</p>
</td></tr>
<tr><td><code id="plot.kmeans.ct_+3A_mark.transitions">mark.transitions</code></td>
<td>
<p>logical: Should transitions between clusters be marked
with vertical lines? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.kmeans.ct_+3A_col">col</code></td>
<td>
<p>plot colors</p>
</td></tr>
<tr><td><code id="plot.kmeans.ct_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="plot.kmeans.ct_+3A_xlab">xlab</code>, <code id="plot.kmeans.ct_+3A_ylab">ylab</code></td>
<td>
<p>x- and y-axis labels</p>
</td></tr>
<tr><td><code id="plot.kmeans.ct_+3A_legend">legend</code></td>
<td>
<p>either a logical variable (whether a legend should be included) or a character
vector to appear in the legend. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.kmeans.ct_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>number of columns for legend</p>
</td></tr>
<tr><td><code id="plot.kmeans.ct_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor for legend</p>
</td></tr>
<tr><td><code id="plot.kmeans.ct_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="graphics.html#topic+matplot">matplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None; a plot is generated.
</p>


<h3>Author(s)</h3>

<p>Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt; and Biplab Paul &lt;paul.biplab497@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeans.ct">kmeans.ct</a></code>, which includes an example
</p>

<hr>
<h2 id='plot.lda.ct'>Plot an lda.ct object</h2><span id='topic+plot.lda.ct'></span>

<h3>Description</h3>

<p>Plots the Fisher's linear discriminant functions generated by a call
to <code><a href="#topic+lda.ct">lda.ct</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lda.ct'
plot(x, ylab = "Discriminants", xlab = "Time", which = NULL, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lda.ct_+3A_x">x</code></td>
<td>
<p>linear discriminant analysis object produced by <code><a href="#topic+lda.ct">lda.ct</a></code></p>
</td></tr>
<tr><td><code id="plot.lda.ct_+3A_ylab">ylab</code>, <code id="plot.lda.ct_+3A_xlab">xlab</code></td>
<td>
<p>y- and x-axis labels</p>
</td></tr>
<tr><td><code id="plot.lda.ct_+3A_which">which</code></td>
<td>
<p>which of the linear discrminants to plot</p>
</td></tr>
<tr><td><code id="plot.lda.ct_+3A_col">col</code></td>
<td>
<p>color vector</p>
</td></tr>
<tr><td><code id="plot.lda.ct_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="graphics.html#topic+matplot">matplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None; a plot is generated.
</p>


<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lda.ct">lda.ct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see the example at the end of ?pca.ct


</code></pre>

<hr>
<h2 id='plot.silhouette.ct'>Plot a silhouette.ct object</h2><span id='topic+plot.silhouette.ct'></span>

<h3>Description</h3>

<p>Plots the silhouette index, generated by a call to
<code><a href="#topic+silhouette.ct">silhouette.ct</a></code>, for a continuous-time k-means clustering object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'silhouette.ct'
plot(x, mark.transitions = TRUE, xlab = "Time", ylab = "Silhouette", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.silhouette.ct_+3A_x">x</code></td>
<td>
<p>silhouette object produced by <code><a href="#topic+silhouette.ct">silhouette.ct</a></code></p>
</td></tr>
<tr><td><code id="plot.silhouette.ct_+3A_mark.transitions">mark.transitions</code></td>
<td>
<p>logical: Should transitions between clusters be marked
with vertical lines? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.silhouette.ct_+3A_xlab">xlab</code>, <code id="plot.silhouette.ct_+3A_ylab">ylab</code></td>
<td>
<p>x- and y-axis labels</p>
</td></tr>
<tr><td><code id="plot.silhouette.ct_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None; a plot is generated.
</p>


<h3>Author(s)</h3>

<p>Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeans.ct">kmeans.ct</a></code>, which includes an example; <code><a href="#topic+silhouette.ct">silhouette.ct</a></code>
</p>

<hr>
<h2 id='silhouette.ct'>Silhouettes for continuous-time k-means clustering</h2><span id='topic+silhouette.ct'></span>

<h3>Description</h3>

<p>Computes the silhouette index, at a grid of time points, for a continuous-time 
k-means clustering object produced by <code><a href="#topic+kmeans.ct">kmeans.ct</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silhouette.ct(kmobj, ngrid = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="silhouette.ct_+3A_kmobj">kmobj</code></td>
<td>
<p>continuous-time k-means clustering from <code><a href="#topic+kmeans.ct">kmeans.ct</a></code></p>
</td></tr>
<tr><td><code id="silhouette.ct_+3A_ngrid">ngrid</code></td>
<td>
<p>number of equally spaced grid points at which to compute the silhouette index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;<code>silhouette.ct</code>&quot;, a list consisting of
</p>
<table>
<tr><td><code>grid</code></td>
<td>
<p>grid of <code>ngrid</code> points spanning the time range</p>
</td></tr> 
<tr><td><code>value</code></td>
<td>
<p>silhouette index at each point along the grid</p>
</td></tr> 
<tr><td><code>transitions</code></td>
<td>
<p>transition points between segments</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>cluster memberships in the segments defined by the transitions</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean silhouette index</p>
</td></tr>
</table>


<h3>Note</h3>

<p>An error is issued if the grid of time points contains one or more of the 
cluster transition points. This should not ordinarily occur, but if it does, it can 
be remedied by modifying <code>ngrid</code>.
</p>


<h3>Author(s)</h3>

<p>Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeans.ct">kmeans.ct</a></code>, which includes an example; <code><a href="#topic+plot.silhouette.ct">plot.silhouette.ct</a></code>
</p>

<hr>
<h2 id='standardize.ct'>Center and scale a continuous-time multivariate data set</h2><span id='topic+standardize.ct'></span>

<h3>Description</h3>

<p>Subtracts the (continuous-time) mean and divides by the (continuous-time) standard
deviation of each of the variables. This is the continuous-time analogue
of taking an <code class="reqn">n \times p</code> data matrix, subtracting the mean of each column, and 
dividing by the standard deviation of each column, as is done by 
<code><a href="base.html#topic+scale">scale</a>(..., center=TRUE, scale=TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize.ct(fdobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize.ct_+3A_fdobj">fdobj</code></td>
<td>
<p>continuous-time multivariate data set of class <code>"<a href="fda.html#topic+fd">fd</a>"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A standardized (centered and scaled) version of the input data.
</p>


<h3>Author(s)</h3>

<p>Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+center.ct">center.ct</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
