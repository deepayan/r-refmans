<!DOCTYPE html><html><head><title>Help for package card</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {card}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#augment.cosinor'><p>Augment data with information from a <code>cosinor</code> object</p></a></li>
<li><a href='#build_sequential_models'><p>Model Building</p></a></li>
<li><a href='#card-package'><p>card: Cardiovascular and Autonomic Research Design</p></a></li>
<li><a href='#circ_center'><p>Center Time Around a Zeitgeiber</p></a></li>
<li><a href='#circ_compare_groups'><p>Compare Repeated Measurements by Group</p></a></li>
<li><a href='#circ_odds'><p>Odds Ratio Table by Time Point</p></a></li>
<li><a href='#circ_rad'><p>Convert Time to Radians</p></a></li>
<li><a href='#circ_sun'><p>Sunrise and Sunset Times</p></a></li>
<li><a href='#cosinor'><p>Fit a <code>cosinor</code></p></a></li>
<li><a href='#cosinor_area'><p>Area of Ellipse</p></a></li>
<li><a href='#cosinor_features'><p>Multiple Component Cosinor Features</p></a></li>
<li><a href='#cosinor_goodness_of_fit'><p>Goodness of Fit of Cosinor</p></a></li>
<li><a href='#cosinor_zero_amplitude'><p>Zero Amplitude Test</p></a></li>
<li><a href='#geh'><p>GEH parameters in a large clinical cohort</p></a></li>
<li><a href='#geom_residuals'><p>Plotting Residual of a Model</p></a></li>
<li><a href='#ggcircadian'><p>Circadian Plot by Group</p></a></li>
<li><a href='#ggcosinor'><p>ggplot of cosinor model</p></a></li>
<li><a href='#ggellipse'><p>Graphical Assessment of Amplitude and Acrophase</p></a></li>
<li><a href='#ggerror'><p>Plotting Error of Models</p></a></li>
<li><a href='#ggforest'><p>Forest Plot of Hourly Odds</p></a></li>
<li><a href='#heart-class'><p><code>heart</code> class</p></a></li>
<li><a href='#hrv'><p>Output from MATLAB HRV Toolbox</p></a></li>
<li><a href='#hrv_linear_model'><p>HRV Linear Modeling</p></a></li>
<li><a href='#mims'><p>Recurrent event sample data</p></a></li>
<li><a href='#predict.cosinor'><p>Predict from a <code>cosinor</code></p></a></li>
<li><a href='#proc_hrv_matlab'><p>Process Toolbox HRV</p></a></li>
<li><a href='#read_hrv_matlab'><p>Read in Toolbox HRV</p></a></li>
<li><a href='#recur_followup_table'><p>Initial and Final Visit Table</p></a></li>
<li><a href='#recur_summary'><p>Recurrent Event Summary Table by Group</p></a></li>
<li><a href='#recur_survival_table'><p>Recurrent Survival Data Format</p></a></li>
<li><a href='#recurrent_model_building'><p>Recurrent Event Sequential Model Building</p></a></li>
<li><a href='#recurrent_propensity'><p>Propensity Score Weighting</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tidy.cosinor'><p>Tidy a(n) cosinor object</p></a></li>
<li><a href='#triplets'><p>Hourly time series data with clinical covariates</p></a></li>
<li><a href='#twins'><p>Hourly time series data with clinical covariates</p></a></li>
<li><a href='#zipcode'><p>Zipcodes with Associated Latitude and Longitude</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cardiovascular and Autonomic Research Design</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools that can aid in the assessment of the autonomic regulation 
		of cardiovascular physiology. The aims of this package are to: 1) study 
		electrocardiography (both intervals and morphology) as extensions 
		of signal processing, 2) study circadian rhythms and how it effects 
		autonomic physiology, 3) assess clinical risk of autonomic dysfunction on 
		cardiovascular health through the perspective of epidemiology and causality.
		The analysis of circadian rhythms through cosinor analysis are built upon 
		the methods by Cornelissen (2014) &lt;<a href="https://doi.org/10.1186%2F1742-4682-11-16">doi:10.1186/1742-4682-11-16</a>&gt; and 
		Refinetti, Cornelissen, Halberg (2014) &lt;<a href="https://doi.org/10.1080%2F09291010600903692">doi:10.1080/09291010600903692</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/asshah4/card">https://github.com/asshah4/card</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/asshah4/card/issues">https://github.com/asshah4/card/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, sf, lutz, magrittr, ggplot2, tidyr, dplyr,
purrr, tibble, readr, lubridate, stringr, rlang, survival,
broom, hardhat, recipes, data.table, Hmisc, generics, methods,
ggrepel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>kableExtra, plyr, stargazer, knitr, rmarkdown, covr, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-29 15:11:54 UTC; asshah4</td>
</tr>
<tr>
<td>Author:</td>
<td>Anish S. Shah <a href="https://orcid.org/0000-0002-9729-1558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anish S. Shah &lt;asshah4@emory.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-03 07:52:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='augment.cosinor'>Augment data with information from a <code>cosinor</code> object</h2><span id='topic+augment.cosinor'></span>

<h3>Description</h3>

<p>Augment accepts a <code>cosinor</code> model object and adds information about each observation in the dataset. This includes the predicted values in the <code>.fitted</code> column and the residuals in the <code>.resid</code> column. New columns always begin with a <code>.</code> prefix to avoid overwriting columns in original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cosinor'
augment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.cosinor_+3A_x">x</code></td>
<td>
<p>A <code>cosinor</code> object created by <code><a href="#topic+cosinor">card::cosinor()</a></code></p>
</td></tr>
<tr><td><code id="augment.cosinor_+3A_...">...</code></td>
<td>
<p>For extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tibble</code> object
</p>


<h3>See Also</h3>

<p>Other cosinor: 
<code><a href="#topic+cosinor">cosinor</a>()</code>,
<code><a href="#topic+ggcosinor">ggcosinor</a>()</code>
</p>

<hr>
<h2 id='build_sequential_models'>Model Building</h2><span id='topic+build_sequential_models'></span>

<h3>Description</h3>

<p>Simplify the process of building multiple models in a sequential
order. This is particularly helpful in epidemiological cases of testing
effect of additional parameters. Every parameter should be theoretically a
part of the causal model for the exposure-outcome relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_sequential_models(formula, data, exposure = NULL, engine = "lm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_sequential_models_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> that shows the names of the
outcomes (can be more than 1) and the names of the predictors (which should
contain the <code>exposure</code> variable).</p>
</td></tr>
<tr><td><code id="build_sequential_models_+3A_data">data</code></td>
<td>
<p>data frame or data table (or tibble) that contains the named
variables</p>
</td></tr>
<tr><td><code id="build_sequential_models_+3A_exposure">exposure</code></td>
<td>
<p>Variable that is forced to be maintained in every model as a
predictor.</p>
</td></tr>
<tr><td><code id="build_sequential_models_+3A_engine">engine</code></td>
<td>
<p>Set the &quot;engine&quot; or the regression tool that will be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is considering what is available with the <code>modelr</code> package and
the <code>tidymodels</code> approach, and finding an in-between for the causality /
epidemiology approach of building intentional, sequentional models. Expect
changes in the process, and potential future dependencies on the
<code>tidymodels</code> appraoches.
</p>


<h3>Value</h3>

<p>A tidy tibble of models. Each one will likely be grouped by its
outcome, and then with sequential columns using increased/additive models.
Each model, in a tidy format, will have two additional columns.
</p>

<ul>
<li> <p><code>outcomes</code> identifies which outcome was used for the specific regression
</p>
</li>
<li> <p><code>covar</code> number of covariates used in sequence of predictors given, with
exposure always being placed in position 1
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(geh)
f &lt;- svg_mag + qrs_tang ~ lab_hba1c + bmi
build_sequential_models(f, data = geh)

</code></pre>

<hr>
<h2 id='card-package'>card: Cardiovascular and Autonomic Research Design</h2><span id='topic+card'></span><span id='topic+card-package'></span>

<h3>Description</h3>

<p>Tools that can aid in the assessment of the autonomic regulation 
of cardiovascular physiology. The aims of this package are to: 1) study 
electrocardiography (both intervals and morphology) as extensions 
of signal processing, 2) study circadian rhythms and how it effects 
autonomic physiology, 3) assess clinical risk of autonomic dysfunction on 
cardiovascular health through the perspective of epidemiology and causality.
The analysis of circadian rhythms through cosinor analysis are built upon 
the methods by Cornelissen (2014) &lt;doi:10.1186/1742-4682-11-16&gt; and 
Refinetti, Cornelissen, Halberg (2014) &lt;doi:10.1080/09291010600903692&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Anish S. Shah <a href="mailto:asshah4@emory.edu">asshah4@emory.edu</a> (<a href="https://orcid.org/0000-0002-9729-1558">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/asshah4/card">https://github.com/asshah4/card</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/asshah4/card/issues">https://github.com/asshah4/card/issues</a>
</p>
</li></ul>


<hr>
<h2 id='circ_center'>Center Time Around a Zeitgeiber</h2><span id='topic+circ_center'></span>

<h3>Description</h3>

<p>Based on a centering time point, shifts a vector to a &quot;before&quot;
and &quot;after&quot; system to help align multiple individuals to a universal time,
like the sunrise or any other appropriate
<a href="https://en.wikipedia.org/wiki/Zeitgeber">zeitgeiber</a>. Originally intended
to expand upon the <a href="#topic+circ_sun">card::circ_sun</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_center(times, zeitgeiber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_center_+3A_times">times</code></td>
<td>
<p>Vector of time series. The earliest time point is presumed to be
the time series onset. Built with the assumption that the duration would be
approximately 24 hours (or less) to remove issues with circadian rhythms
and repeat zeitgeibers (e.g. sunrise). Most importantly, the time series
should be roughly equally spaced, such as 1 hour apart.</p>
</td></tr>
<tr><td><code id="circ_center_+3A_zeitgeiber">zeitgeiber</code></td>
<td>
<p>A single timestamp that should exist within the proposed
<code>times</code>. It can be a POSIX* variable or it can just be a character of a
time stamp in an HMS format. Its used to create a centering point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of centered times around zeitgeiber. Function guesses units of
time based on time series that is input (e.g. duration / number of events).
It returns a vector of relative time in guessed units as <code>double</code>, which
allows centering around the zeitgeiber (Z=0).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("twins")
df &lt;- subset(twins, patid == 7) # Single patient
times &lt;- df$dyxtime
zeitgeiber &lt;- as.POSIXct("2002-03-22 06:40:18", tz = "UTC")
df$zeit &lt;- circ_center(times, zeitgeiber)

</code></pre>

<hr>
<h2 id='circ_compare_groups'>Compare Repeated Measurements by Group</h2><span id='topic+circ_compare_groups'></span>

<h3>Description</h3>

<p>Takes data and returns a summary table of continuous
variable based on a categorical variable. This summary is repeat by
time groups to help describe a circadian pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_compare_groups(data, x, y, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_compare_groups_+3A_data">data</code></td>
<td>
<p>Dataframe containing all the following variables</p>
</td></tr>
<tr><td><code id="circ_compare_groups_+3A_x">x</code></td>
<td>
<p>Continuous variable of interest (x ~ y)</p>
</td></tr>
<tr><td><code id="circ_compare_groups_+3A_y">y</code></td>
<td>
<p>Grouping variable to apply to the <code>cvar</code> (x ~ y). Must be
binary for t-test, otherwise will return data set without pvalues</p>
</td></tr>
<tr><td><code id="circ_compare_groups_+3A_time">time</code></td>
<td>
<p>Name of the time-dependent variable, usually hours</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies a simple data transformation to identify the summary
statistics of the data frame by the stated variables. Results in a
mean, standard deviation, and standard error term. This data is
also used for making a t-test based table, which can then also be
graphed in <a href="#topic+ggcircadian">card::ggcircadian</a>.
</p>


<h3>Value</h3>

<p>Returns a dataframe that has the time variable, the
categorical variable, and the statistics (including p-value) of the
continuous variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("twins")
circ_compare_groups(data = twins, x = "rDYX", y = "sad_cat", time = "hour")

</code></pre>

<hr>
<h2 id='circ_odds'>Odds Ratio Table by Time Point</h2><span id='topic+circ_odds'></span>

<h3>Description</h3>

<p>Creates an OR table for each time point of data given, initially
applied to any grouping variable (particularly hour/time of day).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_odds(data, time, outcome, covar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_odds_+3A_data">data</code></td>
<td>
<p>Dataframe containing subsequent columns</p>
</td></tr>
<tr><td><code id="circ_odds_+3A_time">time</code></td>
<td>
<p>Column name that contains the grouping variable of time</p>
</td></tr>
<tr><td><code id="circ_odds_+3A_outcome">outcome</code></td>
<td>
<p>Column name that identifies the per-row outcome,
binary</p>
</td></tr>
<tr><td><code id="circ_odds_+3A_covar">covar</code></td>
<td>
<p>Vector of independent variables names. First
variable needs to be exposure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an OR table based on the covariate
names supplied. It requires that there is an appropriate outcome
variable selected. It performs a logistic regression. This model
does not allow for conditioning variables (yet).
</p>


<h3>Value</h3>

<p>A data frame of odds ratios
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data
data(twins)

# Create odds ratio tables by hour of day for covariate of interest
ot &lt;- circ_odds(twins, "hour", "sad_bin", "rDYX")

</code></pre>

<hr>
<h2 id='circ_rad'>Convert Time to Radians</h2><span id='topic+circ_rad'></span>

<h3>Description</h3>

<p>Converts a time unit to radians given a known period. Allows for vectorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_rad(t, period)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_rad_+3A_t">t</code></td>
<td>
<p>vector of time units</p>
</td></tr>
<tr><td><code id="circ_rad_+3A_period">period</code></td>
<td>
<p>period of the time units (e.g. 24 hours)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function supports other centering functions to study time series.
</p>


<h3>Value</h3>

<p>Vector converted into radians
</p>

<hr>
<h2 id='circ_sun'>Sunrise and Sunset Times</h2><span id='topic+circ_sun'></span>

<h3>Description</h3>

<p>Gets sunrise and sunset times based on date and location using
the algorithm by the
<a href="http://www.edwilliams.org/sunrise_sunset_algorithm.htm">United States
Naval Observatory</a>. Uses the sensible default of official zenith for
calculations. Requires geographic position in latitude and longitude to
calculate sunrise or sunset. Uses the function <a href="lutz.html#topic+tz_lookup_coords">lutz::tz_lookup_coords</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_sun(date, lat, lon, zenith = "official", sunset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_sun_+3A_date">date</code></td>
<td>
<p>Vector of dates to calculate sun times for</p>
</td></tr>
<tr><td><code id="circ_sun_+3A_lat">lat</code></td>
<td>
<p>Latitude vector in degrees (e.g. Atlanta is 33.749), with negative
values representing south. Each date must have a corresponding latitude.</p>
</td></tr>
<tr><td><code id="circ_sun_+3A_lon">lon</code></td>
<td>
<p>Longitude vector in degrees (e.g. Atlanta is -84.388), with
negative values representing west</p>
</td></tr>
<tr><td><code id="circ_sun_+3A_zenith">zenith</code></td>
<td>
<p>Zenith is the sun's zenith. There are several types, with
different values. &quot;official&quot; = 90.8333 degrees, &quot;civil&quot; = 96 degrees,
&quot;nautical&quot; = 102 degrees, &quot;astronomical&quot; = 108 degrees. They refer to the
angle at which light allows for visibility, which can be affected by
atmosphere and refraction.</p>
</td></tr>
<tr><td><code id="circ_sun_+3A_sunset">sunset</code></td>
<td>
<p>Logical value for if sunset is wanted instead of sunrise.
Default is FALSE (thus returning sunrises).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector of sunrise/sunset times based on the date and location
given. The time zone offset is included for the time zone represented by
the latitude/longitude. The vector always returns UTC, but it has actually
been corrected to the appropriate time-zone. Can use <code>as.character()</code> to
strip the time zone away.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("twins")
twins$lat &lt;- 33.749
twins$lon &lt;- -84.388

# Using latitude/longitude from Atlanta, GA, USA
twins$sunrise &lt;- circ_sun(twins$date, twins$lat, twins$lon)

</code></pre>

<hr>
<h2 id='cosinor'>Fit a <code>cosinor</code></h2><span id='topic+cosinor'></span><span id='topic+cosinor.default'></span><span id='topic+cosinor.data.frame'></span><span id='topic+cosinor.matrix'></span><span id='topic+cosinor.formula'></span><span id='topic+cosinor.recipe'></span>

<h3>Description</h3>

<p><code>cosinor()</code> fits a regression model of a time variable to a
continuous outcome use trigonometric features. This approaches uses the
linearization of the parameters to assess their statistics and
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosinor(t, ...)

## Default S3 method:
cosinor(t, ...)

## S3 method for class 'data.frame'
cosinor(t, y, tau, population = NULL, ...)

## S3 method for class 'matrix'
cosinor(t, y, tau, population = NULL, ...)

## S3 method for class 'formula'
cosinor(formula, data, tau, population = NULL, ...)

## S3 method for class 'recipe'
cosinor(t, data, tau, population = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosinor_+3A_t">t</code></td>
<td>
<p>Represents the <em>ordered</em> time indices that provide the positions for the
cosine wave. Depending on the context:
</p>

<ul>
<li><p> A <strong>data frame</strong> of a time-based predictor/index.
</p>
</li>
<li><p> A <strong>matrix</strong> of time-based predictor/index.
</p>
</li>
<li><p> A <strong>recipe</strong> specifying a set of preprocessing steps
created from <code><a href="recipes.html#topic+recipe">recipes::recipe()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cosinor_+3A_...">...</code></td>
<td>
<p>Not currently used, but required for extensibility.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_y">y</code></td>
<td>
<p>When <code>t</code> is a <strong>data frame</strong> or <strong>matrix</strong>, <code>y</code> is the outcome
specified as:
</p>

<ul>
<li><p> A <strong>data frame</strong> with 1 numeric column.
</p>
</li>
<li><p> A <strong>matrix</strong> with 1 numeric column.
</p>
</li>
<li><p> A numeric <strong>vector</strong>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cosinor_+3A_tau">tau</code></td>
<td>
<p>A vector that determines the periodicity of the time index. The
number of elements in the vector determine the number of components (e.g.
single versus multiple cosinor).
</p>

<ul>
<li><p> A <strong>vector</strong> with a single element = single-component cosinor, e.g.
period = c(24)
</p>
</li>
<li><p> A <strong>vector</strong> with multiple elements = multiple-component
cosinor, e.g. period = c(24, 12)
</p>
</li></ul>
</td></tr>
<tr><td><code id="cosinor_+3A_population">population</code></td>
<td>
<p>Represents the population to be analyzed with a
population-mean cosinor. Defaults to NULL, assuming individual cosinors are
being generated. When a <strong>recipe</strong> or <strong>formula</strong> is used, <code>population</code> is
specified as:
</p>

<ul>
<li><p> A <strong>character</strong> name of the column contained in <code>data</code> that contains
identifiers for each subject. Every row will have a subject name which
should be duplicated for each time index given.
</p>
</li></ul>

<p>When a <strong>data frame</strong> or <strong>matrix</strong> is used, <code>population</code> is specified as:
</p>

<ul>
<li><p> A <strong>vector</strong> of the same length as <code>t</code>, with values representing each
subject at the correct indices.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cosinor_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the outcome terms on the left-hand side,
and the predictor terms on the right-hand side.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_data">data</code></td>
<td>
<p>When a <strong>recipe</strong> or <strong>formula</strong> is used, <code>data</code> is specified as:
</p>

<ul>
<li><p> A <strong>data frame</strong> containing both the predictors and the outcome.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>cosinor</code> object.
</p>


<h3>See Also</h3>

<p>Other cosinor: 
<code><a href="#topic+augment.cosinor">augment.cosinor</a>()</code>,
<code><a href="#topic+ggcosinor">ggcosinor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data setup
data("twins")

# Formula interface
model &lt;- cosinor(rDYX ~ hour, twins, tau = 24)

</code></pre>

<hr>
<h2 id='cosinor_area'>Area of Ellipse</h2><span id='topic+cosinor_area'></span>

<h3>Description</h3>

<p>Formulas for creating the area of the ellipse to identify
confidence intervals, direction, and graphing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosinor_area(object, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosinor_area_+3A_object">object</code></td>
<td>
<p>Model of class <code>cosinor</code></p>
</td></tr>
<tr><td><code id="cosinor_area_+3A_level">level</code></td>
<td>
<p>Confidence level requested</p>
</td></tr>
<tr><td><code id="cosinor_area_+3A_...">...</code></td>
<td>
<p>Not currently used, but required for extensibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Area of potential cosinor for graphical analysis as matrix stored in
a list.
</p>

<hr>
<h2 id='cosinor_features'>Multiple Component Cosinor Features</h2><span id='topic+cosinor_features'></span>

<h3>Description</h3>

<p>Extract the special/global features of a multiple component cosinor. In a multiple component model, there are specific parameters that are not within the model itself, but must be extracted from the model fit. When extracted, can be used to improve the plot of a multiple component cosinor. However, this is only possible if the cosinor is harmonic (see <code>details</code>). For single-component models, the orthophase is the same as the acrophase and the global amplitude
</p>

<ul>
<li><p> Global Amplitude (Ag) = the overall amplitude is defined as half the difference between the peak and trough values
</p>
</li>
<li><p> Orthophase (Po) = the lag until the peak time
</p>
</li>
<li><p> Bathyphase (Pb) =  the lag until the trough time
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cosinor_features(object, population = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosinor_features_+3A_object">object</code></td>
<td>
<p>Model of class <code>cosinor</code> with multiple periods</p>
</td></tr>
<tr><td><code id="cosinor_features_+3A_population">population</code></td>
<td>
<p>If the object is a population cosinor, should the features be calculated for the individual cosinors or for the population-cosinors. Default is TRUE. This has no effect on &quot;Individual&quot; cosinor objects.
</p>

<ul>
<li><p> If TRUE, then will calculate features for entire population.
</p>
</li>
<li><p> If FALSE, then will calculate features for every individual cosinor in the population.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cosinor_features_+3A_...">...</code></td>
<td>
<p>For extensibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These calculations can only occur if the periods of the cosinor are harmonic - as in, the longest period is a integer multiple of the smallest period (known as the fundamental frequency). Otherwise, these statistics are not accurate or interpretable.
</p>


<h3>Value</h3>

<p>When returning the cosinor features for a single model, will return an object of class <code>list</code>. When returning the cosinor features for every individual in a population cosinor, will return an object of class <code>tibble</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(twins)
model &lt;- cosinor(rDYX ~ hour, twins, c(24, 8), "patid")
results &lt;- cosinor_features(model, population = FALSE)
head(results)
</code></pre>

<hr>
<h2 id='cosinor_goodness_of_fit'>Goodness of Fit of Cosinor</h2><span id='topic+cosinor_goodness_of_fit'></span>

<h3>Description</h3>

<p>Goodness of fit of a cosinor from data that has multiple
collections at different timepoints or from multiple cycles. The RSS is
partitioned into pure error (SSPE) and lack of fit (SSLOF). An F-test
compares the SSPE and SSLOF to detect appropriateness of model.
</p>
<p style="text-align: center;"><code class="reqn">SSLOF = RSS - SSPE</code>
</p>

<p style="text-align: center;"><code class="reqn">SSPE = \sum_{i} \sum_{l} ( Y_{il} - \overline{Y}_{i} )^2</code>
</p>

<p>The fitted values for each time point are:
</p>
<p style="text-align: center;"><code class="reqn">\overline{Y}_{i} = \frac{ \sum_{l} Y_{il} }{ n_{i}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>cosinor_goodness_of_fit(object, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosinor_goodness_of_fit_+3A_object">object</code></td>
<td>
<p>requires cosinor model generated with <a href="#topic+cosinor">card::cosinor</a> to
calculate statistics.</p>
</td></tr>
<tr><td><code id="cosinor_goodness_of_fit_+3A_level">level</code></td>
<td>
<p>confidence level desired</p>
</td></tr>
<tr><td><code id="cosinor_goodness_of_fit_+3A_...">...</code></td>
<td>
<p>additional parameters may be needed for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>f-statistic as result of goodness of fit
</p>

<hr>
<h2 id='cosinor_zero_amplitude'>Zero Amplitude Test</h2><span id='topic+cosinor_zero_amplitude'></span>

<h3>Description</h3>

<p>Zero amplitude test assesses how well the circadian pattern fits
the data, essentially detecting the present of a rhythm to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosinor_zero_amplitude(object, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosinor_zero_amplitude_+3A_object">object</code></td>
<td>
<p>model of class <code>cosinor</code></p>
</td></tr>
<tr><td><code id="cosinor_zero_amplitude_+3A_level">level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of test statistics, as well prints out a report of
analysis.
</p>

<hr>
<h2 id='geh'>GEH parameters in a large clinical cohort</h2><span id='topic+geh'></span>

<h3>Description</h3>

<p>Used in the model-building examples for repeat testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geh
</code></pre>


<h3>Format</h3>

<p>A tibble
</p>

<hr>
<h2 id='geom_residuals'>Plotting Residual of a Model</h2><span id='topic+geom_residuals'></span>

<h3>Description</h3>

<p><code>geom_residuals</code> makes a diagnostic plot of residuals versus
fitted data for linear models. Does not yet accept logistic models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_residuals(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_residuals_+3A_model">model</code></td>
<td>
<p>Model to be analyzed, currently only accepts linear models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate residuals versus fitted plot. Functions as an additional
geom layer on ggplot. Models must be linear/gaussian in nature. Covariates
can be included in the model.
</p>


<h3>Value</h3>

<p>Returns a ggplot object of geom type, other layers can be added on as
seen in example.
</p>

<hr>
<h2 id='ggcircadian'>Circadian Plot by Group</h2><span id='topic+ggcircadian'></span>

<h3>Description</h3>

<p>Converts the output of
<a href="#topic+circ_compare_groups">card::circ_compare_groups</a> into a complex geom
that is broken down by time/hour and HRV (or any other continuous
variable). Each hour is then separated by the grouping variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggcircadian(
  data,
  outcome,
  time = "hour",
  mean = "mean",
  n = "n",
  sd = "sd",
  se = "se",
  pval = "pval"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggcircadian_+3A_data">data</code></td>
<td>
<p>Table generated which has time variable, categorical outcome
variable, and summary statistics, including a possible column called &quot;pval&quot;
which, if present, will document statistical significance in plot.</p>
</td></tr>
<tr><td><code id="ggcircadian_+3A_outcome">outcome</code></td>
<td>
<p>Name of categorical variable to stratify the y-axis</p>
</td></tr>
<tr><td><code id="ggcircadian_+3A_time">time</code></td>
<td>
<p>Name of time group variable, such as hours of day, which
ends up being the x-axis</p>
</td></tr>
<tr><td><code id="ggcircadian_+3A_mean">mean</code>, <code id="ggcircadian_+3A_n">n</code>, <code id="ggcircadian_+3A_sd">sd</code>, <code id="ggcircadian_+3A_se">se</code>, <code id="ggcircadian_+3A_pval">pval</code></td>
<td>
<p>Summary statistics to be included in graphics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently creates a ggplot that shows a error bar and
point estimate of values by group (e.g. clinical status). If t-test
values are available in the data frame, shows points of
significance.
</p>


<h3>Value</h3>

<p>Returns a ggplot object of geom type, other layers can be
added on as seen in example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data
data(twins)
tbl &lt;- circ_compare_groups(twins, "rDYX", "sad_cat", "hour")

# Plot
library(ggplot2)
ggcircadian(tbl, outcome = "sad_cat") +
  labs(title = "Example") +
  scale_color_viridis_d(option = "A", begin = 0.0, end = 0.75)

</code></pre>

<hr>
<h2 id='ggcosinor'>ggplot of cosinor model</h2><span id='topic+ggcosinor'></span>

<h3>Description</h3>

<p>ggplot of cosinor model that can visualize a variety of cosinor
model subtypes, including single-component, multiple-component, individual,
and population cosinor models, built using <a href="#topic+cosinor">card::cosinor</a>. For single
component cosinor, the following values are plotted:
</p>

<ul>
<li><p> M = midline estimating statistic of rhythm
</p>
</li>
<li><p> A = amplitude
</p>
</li>
<li><p> P = phi or acrophase (shift from 0 to peak)
</p>
</li></ul>

<p>If using a multiple-component cosinor, the terms are different. If the
periods or frequencies resonate or are harmonic, then the following are
calculated. If the periods are not harmonic, the values are just
descriptors of the curve.
</p>

<ul>
<li><p> M = midline estimating statistic of rhythm
</p>
</li>
<li><p> Ag = global amplitude, which is the distance between peak and trough
(this is the same value as the amplitude from single component)
</p>
</li>
<li><p> Po = orthophase (the equivalent of the acrophase in a single component),
the lag time to peak value
</p>
</li>
<li><p> Pb = bathyphase, the lag time to trough value
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ggcosinor(object, labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggcosinor_+3A_object">object</code></td>
<td>
<p>Model of class <code>cosinor</code>. If instead of a single cosinor model,
multiple objects are to be plotted, can provide a list of cosinor models.
Plotting multiple models simultaneously is preferred if the outcome
variable is similar in scale.</p>
</td></tr>
<tr><td><code id="ggcosinor_+3A_labels">labels</code></td>
<td>
<p>Logical value if annotations should be placed on plot, default
= TRUE. The labels depend on the type of plot. The labels are attempted to
be placed &quot;smartly&quot; using the <code><a href="ggrepel.html#topic+geom_label_repel">ggrepel::geom_label_repel()</a></code> function.</p>
</td></tr>
<tr><td><code id="ggcosinor_+3A_...">...</code></td>
<td>
<p>For extensibility. This function will use different
implementations based on the type of model (single or multiple component).
Attributes of the object will be passed down, or calculated on the fly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>ggplot</code> that can be layered
</p>


<h3>See Also</h3>

<p>Other cosinor: 
<code><a href="#topic+augment.cosinor">augment.cosinor</a>()</code>,
<code><a href="#topic+cosinor">cosinor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(triplets)
m1 &lt;- cosinor(rDYX ~ hour, twins, tau = 24)
m2 &lt;- cosinor(rDYX ~ hour, twins, tau = c(24, 12))
ggcosinor(m1, labels = FALSE)
ggcosinor(m2)
ggcosinor(list(single = m1, multiple = m2))

</code></pre>

<hr>
<h2 id='ggellipse'>Graphical Assessment of Amplitude and Acrophase</h2><span id='topic+ggellipse'></span>

<h3>Description</h3>

<p>This is a ggplot-styled graphical representation of the ellipse
region generated by the cosinor analysis. It requires the same data used by
cosinor model to be fit with the model <a href="#topic+cosinor">card::cosinor</a>. This includes
the amplitude, acrophase,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggellipse(object, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggellipse_+3A_object">object</code></td>
<td>
<p>Requires a cosinor model to extract the correct statistics to
generate the plot.</p>
</td></tr>
<tr><td><code id="ggellipse_+3A_level">level</code></td>
<td>
<p>Confidence level for ellipse</p>
</td></tr>
<tr><td><code id="ggellipse_+3A_...">...</code></td>
<td>
<p>Additional parameters may be needed for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>ggplot</code> to help identify confidence intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("twins")
m &lt;- cosinor(rDYX ~ hour, twins, tau = 24)
ggellipse(m)
</code></pre>

<hr>
<h2 id='ggerror'>Plotting Error of Models</h2><span id='topic+ggerror'></span>

<h3>Description</h3>

<p>Creates a ggplot geom that can be extended and accept other
ggplot layers. Shows residual error from the regression mean for different
types of regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggerror(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggerror_+3A_model">model</code></td>
<td>
<p>Model to be analyzed. The function will detect what type of
family the model is (e.g. linear = &quot;gaussian&quot;, logistic = &quot;binomial&quot;) and
plot the appropriate type of model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate residuals for models. Currently accepts only linear models.
Does not account for covariates yet, although may be able to do this in the
future.
</p>


<h3>Value</h3>

<p>Returns a ggplot object of geom type, other layers can be added on as
seen in example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("twins")
model &lt;- lm(beck_total ~ HR, data = subset(twins, hour == 7))
ggerror(model)
</code></pre>

<hr>
<h2 id='ggforest'>Forest Plot of Hourly Odds</h2><span id='topic+ggforest'></span>

<h3>Description</h3>

<p>Creates an OR plot for each hour of data given. Its a
ggplot format so additional variables, like titles, can be added in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggforest(ot, time = "time", or = "OR", lower = "Lower", upper = "Upper")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggforest_+3A_ot">ot</code></td>
<td>
<p>Odd Ratio table with the following columns.</p>
</td></tr>
<tr><td><code id="ggforest_+3A_time">time</code></td>
<td>
<p>Name of time variable (or &quot;grouping&quot; variable)</p>
</td></tr>
<tr><td><code id="ggforest_+3A_or">or</code></td>
<td>
<p>Name of column containing odds ratio</p>
</td></tr>
<tr><td><code id="ggforest_+3A_lower">lower</code></td>
<td>
<p>Name of column of lower boundary of 95 percent CI</p>
</td></tr>
<tr><td><code id="ggforest_+3A_upper">upper</code></td>
<td>
<p>Name of column of upper boundary of 95 percent CI</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a forest plot using the OR developed
by the <a href="#topic+circ_odds">card::circ_odds</a> function in this package. By default, it
takes the output, which is a tibble named &quot;ot&quot;,
and will generate a forest plot based on the grouping variable
(default is time of day). Original data can be restricted or the
hours can be reduced).
</p>


<h3>Value</h3>

<p>A ggplot of forest plot that can be extended. Default theme is
minimal and default color scheme is viridis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data
data(twins)
ot &lt;- circ_odds(twins, "hour", "sad_bin", "rDYX")

# Plot
library(ggplot2)
ggforest(ot) +
  labs(title = "Example") +
  scale_color_viridis_c(option = "A")

</code></pre>

<hr>
<h2 id='heart-class'><code>heart</code> class</h2><span id='topic+heart-class'></span>

<h3>Description</h3>

<p><code>heart</code> is an S4 class that serves as an object that holds together different components that represent the anatomical heart. A <code>heart</code> object allows for storing clinical information about a patient together, which may more readily allow for analytical approaches to be developed. The heart has plumbing (the coronary arteries), electricity (the nerves), and walls (cardiac chambers). The slots represent these objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pipes</code></dt><dd><p>the epicardial and resistance vessels</p>
</dd>
<dt><code>electric</code></dt><dd><p>the conduction system of nerves</p>
</dd>
<dt><code>structural</code></dt><dd><p>the cardiac chambers and valves</p>
</dd>
</dl>

<hr>
<h2 id='hrv'>Output from MATLAB HRV Toolbox</h2><span id='topic+hrv'></span>

<h3>Description</h3>

<p>Data is a single patient data output from HRV Toolbox. It contains granular data of calculated HRV in 5-second sliding windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrv
</code></pre>


<h3>Format</h3>

<p>An tibble data frame
</p>

<hr>
<h2 id='hrv_linear_model'>HRV Linear Modeling</h2><span id='topic+hrv_linear_model'></span>

<h3>Description</h3>

<p><code>hrv_linear_model</code> Linear models for each HRV measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrv_linear_model(data, covar, hrv, prop.weight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hrv_linear_model_+3A_data">data</code></td>
<td>
<p>Data frame that contains all covariates and outcomes. First
column should be ID</p>
</td></tr>
<tr><td><code id="hrv_linear_model_+3A_covar">covar</code></td>
<td>
<p>Vector names of the covariates, with first covariate being the
primary exposure variable for linear regression</p>
</td></tr>
<tr><td><code id="hrv_linear_model_+3A_hrv">hrv</code></td>
<td>
<p>Vector names of the HRV measures, contained in <code>data</code>, that should
be used. Can be generalized to any dependent variable set.</p>
</td></tr>
<tr><td><code id="hrv_linear_model_+3A_prop.weight">prop.weight</code></td>
<td>
<p>This is a logical value if propensity weighting should be
done instead of traditional covariate adjustment. This calls for the
propensity weighting function defined by
<a href="#topic+recurrent_propensity">card::recurrent_propensity</a> that will generate both a PROP_SCORE
column and PROP_WEIGHT column. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linear models built with dependent variable being the HRV measures
(e.g. HF, LF, SDNN, etc). Allows for covariates to be included as
available.
</p>


<h3>Value</h3>

<p>List of models with names
</p>

<hr>
<h2 id='mims'>Recurrent event sample data</h2><span id='topic+mims'></span>

<h3>Description</h3>

<p>Data is from a outcomes study on cardiovascular outcomes.
It contains the first visit date, the last known date, and
times of various events that have happened. They document death
at right censoring as well. These events are non-ordered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mims
</code></pre>


<h3>Format</h3>

<p>An tibble data frame
</p>

<hr>
<h2 id='predict.cosinor'>Predict from a <code>cosinor</code></h2><span id='topic+predict.cosinor'></span>

<h3>Description</h3>

<p>Predict from a <code>cosinor</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cosinor'
predict(object, new_data, type = "numeric", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cosinor_+3A_object">object</code></td>
<td>
<p>A <code>cosinor</code> object.</p>
</td></tr>
<tr><td><code id="predict.cosinor_+3A_new_data">new_data</code></td>
<td>
<p>A data frame or matrix of new predictors.</p>
</td></tr>
<tr><td><code id="predict.cosinor_+3A_type">type</code></td>
<td>
<p>A single character. The type of predictions to generate.
Valid options are:
</p>

<ul>
<li> <p><code>"numeric"</code> for numeric predictions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.cosinor_+3A_...">...</code></td>
<td>
<p>Not used, but required for extensibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of predictions. The number of rows in the tibble is guaranteed
to be the same as the number of rows in <code>new_data</code>.
</p>

<hr>
<h2 id='proc_hrv_matlab'>Process Toolbox HRV</h2><span id='topic+proc_hrv_matlab'></span>

<h3>Description</h3>

<p>Takes the output from HRV Toolbox and converts it for analysis.
Uses the package <code><a href="data.table.html#topic+fread">data.table::fread()</a></code> for reading in data due to
size/speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc_hrv_matlab(loc, name, time = 3600)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proc_hrv_matlab_+3A_loc">loc</code></td>
<td>
<p>Location of the folder that contains all of the patients
that were analyzed by the Main_HRV_Analysis.m function from the
Toolbox.</p>
</td></tr>
<tr><td><code id="proc_hrv_matlab_+3A_name">name</code></td>
<td>
<p>Name of the patient/ID. There should exist a folder with
the name inside the <code>loc</code> folder. Inside this folder are all the
Toolbox parameters and HRV results in CSV format.</p>
</td></tr>
<tr><td><code id="proc_hrv_matlab_+3A_time">time</code></td>
<td>
<p>Number of seconds to group the HRV data by. Defaults to
3600 seconds (which is 1 hour)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data is taken sequentially (sliding windows), and
summarized over the course of certain time lengths. The data comes
in a standardized pattern from the toolbox. It requires processing
due to its large file sizes (e.g. 24 hours of data for a single
patient can be up to 2 MB in size).
</p>


<h3>Value</h3>

<p>Data frame of HRV summarized by the grouping variable (e.g.
3600 seconds = 1 hour). Also returns an additional column of
percent missing (e.g. 20.0% missing data) by time group.
</p>

<hr>
<h2 id='read_hrv_matlab'>Read in Toolbox HRV</h2><span id='topic+read_hrv_matlab'></span>

<h3>Description</h3>

<p>Takes the output from HRV Toolbox and reads it in for an
individual patient. Unlike <a href="#topic+proc_hrv_matlab">card::proc_hrv_matlab</a>, this does not process
or summarize the data, it just reads it the raw analysis. Uses the package
<code><a href="data.table.html#topic+fread">data.table::fread()</a></code> for reading in data due to size/speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_hrv_matlab(loc, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_hrv_matlab_+3A_loc">loc</code></td>
<td>
<p>Location of the folder that contains all of the patients
that were analyzed by the Main_HRV_Analysis.m function from the
Toolbox</p>
</td></tr>
<tr><td><code id="read_hrv_matlab_+3A_name">name</code></td>
<td>
<p>Name of the patient/ID. There should exist a folder with
the name inside the <code>loc</code> folder. Inside this folder are all the
Toolbox parameters and HRV results in CSV format.
3600 seconds (which is 1 hour)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data is taken sequentially (sliding windows), and is not processed. It is reported and is likely a large file.
</p>


<h3>Value</h3>

<p>Data frame of HRV summarized by the grouping variable (e.g.
3600 seconds = 1 hour). Also returns an additional column of
percent missing (e.g. 20.0% missing data) by time group.
</p>

<hr>
<h2 id='recur_followup_table'>Initial and Final Visit Table</h2><span id='topic+recur_followup_table'></span>

<h3>Description</h3>

<p>Makes a before/after dataset using a unique ID that follows
patients between studies, to allow for comparison over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_followup_table(data, studyid, keyid, date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recur_followup_table_+3A_data">data</code></td>
<td>
<p>Data frame containing all clinical covariates of interest</p>
</td></tr>
<tr><td><code id="recur_followup_table_+3A_studyid">studyid</code></td>
<td>
<p>Should be one ID for every study date/visit. Can have
multiples ONLY if there were several data points gathered on a single visit
(e.g. heart rate measured multiple times on the same day).</p>
</td></tr>
<tr><td><code id="recur_followup_table_+3A_keyid">keyid</code></td>
<td>
<p>Should be the ID that corresponds to each studyid throughout
each visit</p>
</td></tr>
<tr><td><code id="recur_followup_table_+3A_date">date</code></td>
<td>
<p>Name of column containing the date of each visit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently functions by taking two input IDs, one being a ID that is
the same between studies (a true key ID) and an ID that is unique to that
study itself. It will arrange by dates, and and slice data into an initial
visit and the most recent visit. Each row should have a KEY ID and a STUDY
ID. The data is in a long format, such that the STUDY IDs are unique / not
duplicated.
</p>


<h3>Value</h3>

<p>Returns list of initial and most recent data sets. These can easily
be merged after with any naming nomenclature as chosen, or with any merging
keys as chosen (in case there are several merging variables, like keyid +
hour of day for circadian data).
</p>

<hr>
<h2 id='recur_summary'>Recurrent Event Summary Table by Group</h2><span id='topic+recur_summary'></span>

<h3>Description</h3>

<p><code>recur_summary</code> Creates a table with summary of
recurrent events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_summary(data, covar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recur_summary_+3A_data">data</code></td>
<td>
<p>Recurrent event data in marginal format. There must be
an ID column. Must merge in the covariate of interest into this data set.</p>
</td></tr>
<tr><td><code id="recur_summary_+3A_covar">covar</code></td>
<td>
<p>Name of covariate of interest to serve as grouping variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for taking the output of
<a href="#topic+recur_survival_table">card::recur_survival_table</a> marginal format repeat event data,
and creates a summary table that describes the number of events by
strata/event.
</p>


<h3>Value</h3>

<p>Summary table by grouping variable, can be placed into a latex
environment with kableExtra. Assumes that death events may be
present when most recent non-EVENT has status 1.
</p>

<hr>
<h2 id='recur_survival_table'>Recurrent Survival Data Format</h2><span id='topic+recur_survival_table'></span>

<h3>Description</h3>

<p>Reformats recurrent event data (wide) into different models for
survival analysis, but can also be used for simple survival analysis tables
as well. Importantly, for large datasets, this function will show
significant slow-down since it uses an intuitive approach on defining the
datasets. Future iterations will create a vectorized approach that should
provide performance speed-ups.
</p>

<ul>
<li><p> For recurrent events, the final censoring event can include death, or can
be ignored if its not considered a failure event.
</p>
</li>
<li><p> For simple survival analysis, death censoring should be left as NULL, and
the event (e.g. &quot;date_of_death&quot;), should be used as a single <code>event.dates</code>
parameter. The function will do the rest.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>recur_survival_table(
  data,
  id,
  first,
  last,
  event.dates,
  model.type,
  death = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recur_survival_table_+3A_data">data</code></td>
<td>
<p>A dataframe containing the subsequent parameters</p>
</td></tr>
<tr><td><code id="recur_survival_table_+3A_id">id</code></td>
<td>
<p>Column in dataframe that contains unique IDs for each row</p>
</td></tr>
<tr><td><code id="recur_survival_table_+3A_first">first</code></td>
<td>
<p>Column with left/enrollment dates</p>
</td></tr>
<tr><td><code id="recur_survival_table_+3A_last">last</code></td>
<td>
<p>Column with right/censoring time point, or last contact</p>
</td></tr>
<tr><td><code id="recur_survival_table_+3A_event.dates">event.dates</code></td>
<td>
<p>Vector of columns that contain event dates</p>
</td></tr>
<tr><td><code id="recur_survival_table_+3A_model.type">model.type</code></td>
<td>
<p>Character/string = c(&quot;marginal&quot;, &quot;pwptt&quot;, &quot;pwpgt&quot;)</p>
</td></tr>
<tr><td><code id="recur_survival_table_+3A_death">death</code></td>
<td>
<p>Column created for if death is known (0 or 1), original
dataframe (e.g. can add column of zeroes PRN). Death defaults to null for
intermediate calculations otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes every data event date, and creates several types
of recurrent event tables. It orders the data chronologically for repeat
events. Currently does marginal and conditional A and B models. The large
</p>


<h3>Value</h3>

<p>A data frame organized into a survival table format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data
data("mims")

# Parameters
id &lt;- "patid"
first &lt;- "first_visit_date_bl"
last &lt;- "ldka"
event.dates &lt;- c("mi_date_1", "mi_date_2", "mi_date_3")
model.type &lt;- "marginal"
death &lt;- "DEATH_CV_YN"

# Run analysis
tbl &lt;- recur_survival_table(
  mims, id, first, last, event.dates, model.type, death
)


</code></pre>

<hr>
<h2 id='recurrent_model_building'>Recurrent Event Sequential Model Building</h2><span id='topic+recurrent_model_building'></span>

<h3>Description</h3>

<p>Takes a different covariate groups to generate several models
for recurrent event survival analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recurrent_model_building(data, covar.builds, model.type, prop.scores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recurrent_model_building_+3A_data">data</code></td>
<td>
<p>Data frame that is the survival format, potentially made by the
<a href="#topic+recur_survival_table">card::recur_survival_table</a>. Has to be merged with the superset of
covariates that are being tested.</p>
</td></tr>
<tr><td><code id="recurrent_model_building_+3A_covar.builds">covar.builds</code></td>
<td>
<p>This is a vector that names the individual vectors for
each model, likely sequential and additive. The individual vectors contain
the names of the columns in the data frame that will generate regressions.</p>
</td></tr>
<tr><td><code id="recurrent_model_building_+3A_model.type">model.type</code></td>
<td>
<p>Type of recurrent event data, selected from c(&quot;marginal&quot;,
&quot;pwptt&quot;, &quot;pwpgt&quot;)</p>
</td></tr>
<tr><td><code id="recurrent_model_building_+3A_prop.scores">prop.scores</code></td>
<td>
<p>This is a vector of the names of which <code>covar.builds</code>
should be performed with propensity weighting. This will call a separate
function <a href="#topic+recurrent_propensity">card::recurrent_propensity</a> that will generate both a PROP_SCORE
column and PROP_WEIGHT column. Optional parameter, defaults to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the survival models in different types (e.g. marginal, PWP,
etc), to create Cox regressions that are in a sequential order. Using the
covariates given, will create the models on the fly. Need to specify model
type and provide data in a certain format.
</p>


<h3>Value</h3>

<p>List of models in sequential order.
</p>

<hr>
<h2 id='recurrent_propensity'>Propensity Score Weighting</h2><span id='topic+recurrent_propensity'></span>

<h3>Description</h3>

<p><code>recurrent_propensity</code> Adds propensity score to any data set that is being regressed upon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recurrent_propensity(data, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recurrent_propensity_+3A_data">data</code></td>
<td>
<p>Data frame that contains all covariates and outcomes. First column should be ID</p>
</td></tr>
<tr><td><code id="recurrent_propensity_+3A_vars">vars</code></td>
<td>
<p>Variables used for regression. Outcome variable must be first.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using a logistic regression, will take covariates and create propensity scores, and adds the weights. Uses the standard logistic regression to evaluate the propensity score.
</p>


<h3>Value</h3>

<p>Returns a modified table from what was originally given with the new columns propensity scores. Essentially original df + 2 columns.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='tidy.cosinor'>Tidy a(n) cosinor object</h2><span id='topic+tidy.cosinor'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a <code>cosinor</code>
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cosinor'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.cosinor_+3A_x">x</code></td>
<td>
<p>A <code>cosinor</code> object created by <code><a href="#topic+cosinor">card::cosinor()</a></code></p>
</td></tr>
<tr><td><code id="tidy.cosinor_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include confidence
interval in tidied output</p>
</td></tr>
<tr><td><code id="tidy.cosinor_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use if <code>conf.int = TRUE</code>. Must be
between 0 and 1, with default to 0.95 (the 95% confidence interval).</p>
</td></tr>
<tr><td><code id="tidy.cosinor_+3A_...">...</code></td>
<td>
<p>For extensibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cosinor</code> objects do not necessarily have a T-statistic as the
standard error is not based on a mean value, but form a joint-confidence
interval. The standard error is generated using Taylor series expansion as
the object is a subspecies of harmonic regressions.
</p>


<h3>Value</h3>

<p>a <code>tibble</code> object
</p>

<hr>
<h2 id='triplets'>Hourly time series data with clinical covariates</h2><span id='topic+triplets'></span>

<h3>Description</h3>

<p>Clinical data is also available for visualization and comparison. Other HRV measures are used here for comparison and testing out functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triplets
</code></pre>


<h3>Format</h3>

<p>An tibble data frame
</p>

<hr>
<h2 id='twins'>Hourly time series data with clinical covariates</h2><span id='topic+twins'></span>

<h3>Description</h3>

<p>Data is from an algorithm that generates a summary HRV measure using the Poincare phase-space plot, generated from kurtoses of the x and y axis. Clinical data is also available for visualization and comparison. There are repeat rows for each hour that Dyx was taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twins
</code></pre>


<h3>Format</h3>

<p>An tibble data frame
</p>

<hr>
<h2 id='zipcode'>Zipcodes with Associated Latitude and Longitude</h2><span id='topic+zipcode'></span>

<h3>Description</h3>

<p>This is a dataset from the archived/orphaned zipcode package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipcode
</code></pre>


<h3>Format</h3>

<p>A data frame with character vector zipcodes and latitude/longitude
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
