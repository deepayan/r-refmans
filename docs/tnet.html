<!DOCTYPE html><html><head><title>Help for package tnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+20Cross.Parker.Consulting.net.info+20'><p> Intra-organisational networks</p></a></li>
<li><a href='#+20OnlineSocialNetwork.n1899.net+20'><p> Facebook-like Online Social Network</p></a></li>
<li><a href='#add_window_l'><p> Add smoothing window to a longitudinal network</p></a></li>
<li><a href='#as.static.tnet'><p> Transform a longitudinal network to a static edgelist network</p></a></li>
<li><a href='#as.tnet'><p> Ensures that networks conform to the tnet stardards</p></a></li>
<li><a href='#betweenness_w'><p> Betweenness centrality in a weighted network</p></a></li>
<li><a href='#celegans.n306.net'><p> The neural network of the Caenorhabditis elegans worm (c.elegans)</p></a></li>
<li><a href='#closeness_w'><p> Closeness centrality in a weighted network</p></a></li>
<li><a href='#clustering_local_tm'><p> Redefined local clusering coefficient for two-mode networks</p></a></li>
<li><a href='#clustering_local_w'><p> Barrat et al. (2004) generalised local clusering coefficient</p></a></li>
<li><a href='#clustering_tm'><p> Redefined clusering coefficient for two-mode networks</p></a></li>
<li><a href='#clustering_w'><p> Generalised clusering coefficient</p></a></li>
<li><a href='#compress_ids'><p> Remove non-active nodes from one-mode/two-mode/longitudinal networks</p></a></li>
<li><a href='#Cross.Parker.Manufacturing.net.info'><p> Intra-organisational networks</p></a></li>
<li><a href='#Davis.Southern.women.2mode'><p> Davis' Southern Women network</p></a></li>
<li><a href='#degree_tm'><p> Degree centrality in a two-mode network</p></a></li>
<li><a href='#degree_w'><p> Degree centrality in a weighted network</p></a></li>
<li><a href='#dichotomise_tm'><p> Dichotomise a weighted two-mode network into a binary two-mode network</p></a></li>
<li><a href='#dichotomise_w'><p> Dichotomise a weighted one-mode network into a binary one-mode network</p></a></li>
<li><a href='#distance_tm'><p> Distance in a two-mode network</p></a></li>
<li><a href='#distance_w'><p> Distance in a weighted network</p></a></li>
<li><a href='#Freemans.EIES.net.1.n48'><p> Freeman's EIES network data</p></a></li>
<li><a href='#growth_l'><p> Identifies growth mechanisms responsible for tie generation in longitudinal networks</p></a></li>
<li><a href='#Newman.Condmat.95.99.net.2mode'><p> Newman's condmat 95-99 network (two-mode structure)</p></a></li>
<li><a href='#projecting_tm'><p> Projecting binary and weighted two-mode networks onto weighted one-mode networks.</p></a></li>
<li><a href='#reinforcement_tm'><p> Reinforcement_tm</p></a></li>
<li><a href='#rg_reshuffling_l'><p> Reshuffling a longitudinal network</p></a></li>
<li><a href='#rg_reshuffling_tm'><p> Reshuffle of a binary two-mode network</p></a></li>
<li><a href='#rg_reshuffling_w'><p> Reshuffle of a weighted network</p></a></li>
<li><a href='#rg_tm'><p> Random binary and weighted two-mode network</p></a></li>
<li><a href='#rg_w'><p> Random weighted network generator</p></a></li>
<li><a href='#shrink_to_weighted_network'><p> Shrink a repetative edgelist into a weighted</p></a></li>
<li><a href='#symmetrise_w'><p> Symmetrise_w</p></a></li>
<li><a href='#tnet_igraph'><p> Exports a tnet network to an igraph object</p></a></li>
<li><a href='#tnet_ucinet'><p> Exports a tnet network to a DL file for UCINET</p></a></li>
<li><a href='#tnet-package'><p> Collection of functions for analysing weighted networks, two-mode networks, and longitudinal networks</p></a></li>
<li><a href='#USairport.n500.net'><p> The network among the 500 busiest US commercial airports.</p></a></li>
<li><a href='#weighted_richclub_local_w'><p> The weighted rich-club effect (local measure)</p></a></li>
<li><a href='#weighted_richclub_tm'><p> The weighted rich-club effect (two-mode networks)</p></a></li>
<li><a href='#weighted_richclub_w'><p> The weighted rich-club effect</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.16</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighted, Two-Mode, and Longitudinal Networks Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>Tore Opsahl</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tore Opsahl &lt;tore@opsahl.co.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.13.0), igraph, survival</td>
</tr>
<tr>
<td>Description:</td>
<td>Binary ties limit the richness of network analyses as relations are unique. The two-mode structure contains a number of features lost when projection it to a one-mode network. Longitudinal datasets allow for an understanding of the causal relationship among ties, which is not the case in cross-sectional datasets as ties are dependent upon each other.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://toreopsahl.com/tnet/">http://toreopsahl.com/tnet/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-23 17:44:22 UTC; tore</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-24 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+20Cross.Parker.Consulting.net.info+20'> Intra-organisational networks </h2><span id='topic+Cross.Parker.Consulting.net.info'></span><span id='topic+Cross.Parker.Consulting.net.value'></span><span id='topic+Cross.Parker.Consulting.node.gender'></span><span id='topic+Cross.Parker.Consulting.node.location'></span><span id='topic+Cross.Parker.Consulting.node.orglevel'></span><span id='topic+Cross.Parker.Consulting.node.region'></span>

<h3>Description</h3>

<p> This dataset contains two intra-organizational networks from a consulting company (46 employees). These networks was used by Cross and Parker (2004). <br /><br />
In the first network, the ties are differentiated on a scale from 0 to 5 in terms of frequency of information or advice requests (&quot;Please indicate how often you have turned to this person for information or advice on work-related topics in the past three months&quot;). 0: I Do Not Know This Person; 1: Never; 2: Seldom; 3: Sometimes; 4: Often; and 5:Very Often. <br /><br />
In the second network, ties are differentiated in terms of the value placed on the information or advice received (&quot;For each person in the list below, please show how strongly you agree or disagree with the following statement: In general, this person has expertise in areas that are important in the kind of work I do.&quot;). The weights in this network is also based on a scale from 0 to 5. 0: I Do Not Know This Person; 1: Strongly Disagree; 2: Disagree; 3: Neutral; 4: Agree; and 5: Strongly Agree.<br /><br />
In addition to the relational data, the dataset also contains information about the people (nodal attributes). The following attributes are known: the organisational level (1 Research Assistant; 2: Junior Consultant; 3: Senior Consultant; 4: Managing Consultant; 5: Partner), gender (1: male; 2: female), region (1: Europe; 2: USA), and location (1: Boston; 2: London; 3: Paris; 4: Rome; 5: Madrid; 6: Oslo; 7: Copenhagen).<br /><br />
See http://toreopsahl.com/datasets/ </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
Cross.Parker.Consulting.net.info
Cross.Parker.Consulting.net.value
Cross.Parker.Consulting.node.gender
Cross.Parker.Consulting.node.location
Cross.Parker.Consulting.node.orglevel
Cross.Parker.Consulting.node.region
</code></pre>


<h3>Format</h3>

<p> The networks are data frames with three columns. The first column is the id of the sender, the second column is the id of the receiver, and the third column is the weight of the tie. The nodal attributes are vectors. </p>


<h3>References</h3>

<p> Cross, R., Parker, A., 2004. The Hidden Power of Social Networks. Harvard Business School Press, Boston, MA.<br />
http://toreopsahl.com/datasets/ </p>

<hr>
<h2 id='+20OnlineSocialNetwork.n1899.net+20'> Facebook-like Online Social Network </h2><span id='topic+OnlineSocialNetwork.n1899.net'></span><span id='topic+OnlineSocialNetwork.n1899.lnet'></span>

<h3>Description</h3>

<p>This network is the Facebook-like Social Network-dataset used in my Ph.D. thesis. This network has also been described in Patterns and Dynamics of Users' Behaviour and Interaction: Network Analysis of an Online Community and used in Prominence and control: The weighted rich-club effect and Clustering in weighted networks. The network originates from a virtual community among students at University of California, Irvine. The edgelists include the users that sent or received at least one message during that period (1,899). A total number of 59,835 online messages were sent among over 20,296 directed ties.</p>


<h3>Usage</h3>

<pre><code class='language-R'>OnlineSocialNetwork.n1899.net
OnlineSocialNetwork.n1899.lnet
</code></pre>


<h3>Format</h3>

<p> OnlineSocialNetwork.n1899.net: A data frame with three columns. The first column is the id of the sender, the second column is the id of the receiver, and the third column is the weight of the tie.<br />
OnlineSocialNetwork.n1899.lnet: A data frame with four columns. The first column is the timestamp, the second column is the id of the sender, the third column is the id of the receiver, and the fourth column is the weight of the tie (always 1).</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Opsahl, T., Panzarasa, P., 2009. Clustering in weighted networks. Social Networks 31 (2), 155-163, doi: 10.1016/j.socnet.2009.02.002 <br />
http://toreopsahl.com/datasets/</p>

<hr>
<h2 id='add_window_l'> Add smoothing window to a longitudinal network </h2><span id='topic+add_window_l'></span>

<h3>Description</h3>

<p>This function adds negative ties (i.e., a smoothing window) to a longitudinal network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_window_l(net,window=21, remove.nodes=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_window_l_+3A_net">net</code></td>
<td>
<p> Longitudinal network </p>
</td></tr>
<tr><td><code id="add_window_l_+3A_window">window</code></td>
<td>
<p> Number of days before ties 'expire'.</p>
</td></tr>
<tr><td><code id="add_window_l_+3A_remove.nodes">remove.nodes</code></td>
<td>
<p> Whether or not nodes should be removed from the network if they have no more ties. This function adds a self-loop with a negative weight at the time of a node's last tie plus the length of the window. </p>
</td></tr></table>
<p>.
</p>


<h3>Value</h3>

<p>Returns the longitudinal network with negative arcs.</p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> tore@opsahl.co.uk </p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- c('2007-09-12 13:45:00', 
'2007-09-12 13:46:31',
'2007-09-12 13:47:54',
'2007-09-12 13:48:21',
'2007-09-12 13:49:27',
'2007-09-12 13:58:14',
'2007-09-12 13:52:17',
'2007-09-12 13:56:59');
i &lt;- c(1,1,1,1,1,1,1,1);
j &lt;- c(2,2,2,2,2,2,3,3);
w &lt;- c(1,1,1,1,1,1,1,1);
sample &lt;- data.frame(t, i, j, w);

## Run the programme
add_window_l(sample, window=21)

</code></pre>

<hr>
<h2 id='as.static.tnet'> Transform a longitudinal network to a static edgelist network </h2><span id='topic+as.static.tnet'></span>

<h3>Description</h3>

<p>This function transforms a longitudinal network to a static edgelist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.static.tnet(ld)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.static.tnet_+3A_ld">ld</code></td>
<td>
<p> Longitudinal network </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the data in an edgelist format.</p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> tore@opsahl.co.uk </p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- c('2007-09-12 13:45:00', 
'2007-09-12 13:46:31',
'2007-09-12 13:47:54',
'2007-09-12 13:48:21',
'2007-09-12 13:49:27',
'2007-09-12 13:58:14',
'2007-09-12 13:52:17',
'2007-09-12 13:56:59');
i &lt;- c(1,1,1,1,1,1,1,1);
j &lt;- c(2,2,2,2,2,2,3,3);
w &lt;- c(1,1,1,1,1,-1,1,1);
net &lt;- data.frame(t, i, j, w);

## Run the programme
as.static.tnet(net)

</code></pre>

<hr>
<h2 id='as.tnet'> Ensures that networks conform to the tnet stardards </h2><span id='topic+as.tnet'></span>

<h3>Description</h3>

<p>Checks that a network conforms to the tnet stardards, and attaches a label. If the type parameter is not set, the network is assumed to be a binary two-mode network, a weighted one-mode network, or a longitudinal network if there are 2, 3, or 4 columns respectively. Moreover, if a matrix is entered (more than 4 columns and rows), it is assumed to be a weighted one-mode network if square or a two-mode network if non-square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.tnet(net, type=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.tnet_+3A_net">net</code></td>
<td>
<p>A network in an edgelist or matrix format. It can be a weighted one-mode network, a binary two-mode network, a weighted two-mode netork, or a longitudinal network. If the data-object has two-columns, it is assumed to be a binary two-mode network; three columns, weighted one-mode network; four columns, longitudinal; five or more and the same number of rows and columns, weighted one-mode network; five or more and &ndash;not&ndash; the same number of rows and columns, it is assumed to be a two-mode network. </p>
</td></tr>
<tr><td><code id="as.tnet_+3A_type">type</code></td>
<td>
<p>If you would like to specify the type of network. This could be &quot;weighted one-mode tnet&quot;, &quot;binary two-mode tnet&quot;, &quot;weighted two-mode tnet&quot;, or &quot;longitudinal tnet&quot;. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the network with an attached lable.</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- rbind(
c(1,2,4),
c(1,3,2),
c(2,1,4),
c(2,3,4),
c(2,4,1),
c(2,5,2),
c(3,1,2),
c(3,2,4),
c(4,2,1),
c(5,2,2),
c(5,6,1),
c(6,5,1))

## Run the programme
as.tnet(sample)

</code></pre>

<hr>
<h2 id='betweenness_w'> Betweenness centrality in a weighted network </h2><span id='topic+betweenness_w'></span>

<h3>Description</h3>

<p> This function calculates betweenness scores for nodes in a weighted network based on the distance_w-function. <br />
Note: This algorithm relies on the igraphs package's implementation of Dijkstra's algorithm. Currently, it does not find multiple shortest paths if two exist.</p>


<h3>Usage</h3>

<pre><code class='language-R'> betweenness_w(net, directed=NULL, alpha=1) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betweenness_w_+3A_net">net</code></td>
<td>
<p> A weighted edgelist </p>
</td></tr>
<tr><td><code id="betweenness_w_+3A_directed">directed</code></td>
<td>
<p> logical, whether the network is directed or undirected. Default is NULL, this means that the function checks whether the edgelist is directed or not.</p>
</td></tr>
<tr><td><code id="betweenness_w_+3A_alpha">alpha</code></td>
<td>
<p> sets the alpha parameter in the generalised measures from Opsahl, T., Agneessens, F., Skvoretz, J., 2010. Node Centrality in Weighted Networks: Generalizing Degree and Shortest Paths. Social Networks. If this parameter is set to 1 (default), the Dijkstra shortest paths are used. The length of these paths rely simply on the tie weights and disregards the number of nodes on the paths. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a data.frame with two columns: the first column contains the nodes' ids, and the second column contains the nodes' betweenness scores. </p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2009/02/20/betweenness-in-weighted-networks/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sampledata &lt;- rbind(
c(1,2,1),
c(1,3,5),
c(2,1,1),
c(2,4,6),
c(3,1,5),
c(3,4,10),
c(4,2,6),
c(4,3,10))

## Run the programme
betweenness_w(sampledata)

</code></pre>

<hr>
<h2 id='celegans.n306.net'> The neural network of the Caenorhabditis elegans worm (c.elegans) </h2><span id='topic+celegans.n306.net'></span>

<h3>Description</h3>

<p>This dataset contains the neural network of the Caenorhabditis elegans worm (C.elegans). It was studied by Watts and Strogatz (1998). The network contains 306 nodes that represent neurons. Two neurons are connected if at least one synapse or gap junction exist between them. The weight is the number of synapses and gap junctions. This network was obtained from the Collective Dynamics Group's website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>celegans.n306.net 
</code></pre>


<h3>Format</h3>

<p> A data frame with three columns. The first is the id of the sender; the second is the id of the receiver; and the third is the weight of the tie. </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Watts, D. J., Strogatz, S. H., 1998. Collective dynamics of &quot;small-world&quot; networks. Nature 393, 440-442.<br />
http://toreopsahl.com/datasets/</p>

<hr>
<h2 id='closeness_w'> Closeness centrality in a weighted network </h2><span id='topic+closeness_w'></span>

<h3>Description</h3>

<p> This function calculates closeness scores for nodes in a weighted network based on the distance_w-function. </p>


<h3>Usage</h3>

<pre><code class='language-R'> closeness_w(net, directed=NULL, gconly=TRUE, precomp.dist=NULL, alpha=1) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeness_w_+3A_net">net</code></td>
<td>
<p> A weighted edgelist </p>
</td></tr>
<tr><td><code id="closeness_w_+3A_directed">directed</code></td>
<td>
<p> Logical: whether the edgelist is directed or undirected. Default is NULL, then the function detects this parameter. </p>
</td></tr>
<tr><td><code id="closeness_w_+3A_gconly">gconly</code></td>
<td>
<p> Logical: whether to calculate closeness only on the main component (traditional closeness). Default is TRUE. If this parameter is set to FALSE, a closeness measure for all nodes is computed. For details, see http://toreopsahl.com/2010/03/20/closeness-centrality-in-networks-with-disconnected-components/ </p>
</td></tr>
<tr><td><code id="closeness_w_+3A_precomp.dist">precomp.dist</code></td>
<td>
<p> If you have already computed the distance matrix using distance_w-function, you can enter the name of the matrix-object here. </p>
</td></tr>
<tr><td><code id="closeness_w_+3A_alpha">alpha</code></td>
<td>
<p> sets the alpha parameter in the generalised measures from Opsahl, T., Agneessens, F., Skvoretz, J., 2010. Node Centrality in Weighted Networks: Generalizing Degree and Shortest Paths. Social Networks. If this parameter is set to 1 (default), the Dijkstra shortest paths are used. The identification procedure of these paths rely simply on the tie weights and disregards the number of nodes on the paths. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a data.frame with three columns: the first column contains the nodes' ids, the second column contains the closeness scores, and the third column contains the normalised closeness scores (i.e., divided by N-1). </p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2009/01/09/average-shortest-distance-in-weighted-networks/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sampledata &lt;- rbind(
c(1,2,4),
c(1,3,2),
c(2,1,4),
c(2,3,4),
c(2,4,1),
c(2,5,2),
c(3,1,2),
c(3,2,4),
c(4,2,1),
c(5,2,2),
c(5,6,1),
c(6,5,1))

## Run the programme
closeness_w(sampledata)

</code></pre>

<hr>
<h2 id='clustering_local_tm'> Redefined local clusering coefficient for two-mode networks </h2><span id='topic+clustering_local_tm'></span>

<h3>Description</h3>

<p> This function calculates the local two-mode clusering coefficient as proposed in Opsahl, T., 2010. Triadic closure in two-mode networks: Redefining the global and local clustering coefficients. arXiv:1006.0887. </p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering_local_tm(net)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_local_tm_+3A_net">net</code></td>
<td>
<p>A binary or weighted two-mode edgelist</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns the local clustering coefficient for the primary node set (the first of an edgelist or the rows of a matrix) </p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Opsahl, T., 2010. Triadic closure in two-mode networks: Redefining the global and local clustering coefficients. arXiv:1006.0887   </p>


<h3>Examples</h3>

<pre><code class='language-R'># Weighted two-mode network
net &lt;- cbind(
i=c(1,1,2,2,2,3,3,4,5,5,6),
p=c(1,2,1,3,4,2,3,4,3,5,5),
w=c(3,5,6,1,2,6,2,1,3,1,2))

## Run binary clustering function
clustering_local_tm(net[,1:2])

## Run weighted clustering function
clustering_local_tm(net)

</code></pre>

<hr>
<h2 id='clustering_local_w'> Barrat et al. (2004) generalised local clusering coefficient </h2><span id='topic+clustering_local_w'></span>

<h3>Description</h3>

<p> This function calculates Barrat et al. (2004) generalised local clusering coefficient.<br />
See http://toreopsahl.com/2009/01/23/weighted-local-clustering-coefficient/ for a detailed description. By default it defines the triplet value as the average of the two tie weights; however it can also define it differently. See the blog post.<br />
Note: If there are very large tie weights in a network, the geometric method in R fails. However, this can be fixed by transforming the values.<br />
net[,&quot;w&quot;] &lt;- (net[,&quot;w&quot;]/min(net[,&quot;w&quot;])) <br />
This step is not required unless you receive warnings when running the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering_local_w(net, measure = "am")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_local_w_+3A_net">net</code></td>
<td>
<p>A weighted edgelist</p>
</td></tr>
<tr><td><code id="clustering_local_w_+3A_measure">measure</code></td>
<td>
<p> The measure-switch control the method used to calculate the value of the triplets.<br />
am implies the arithmetic mean method (default)<br />
gm implies the geometric mean method<br />
mi implies the minimum method<br />
ma implies the maximum method<br />
bi implies the binary measures<br />
This can be c(&quot;am&quot;, &quot;gm&quot;, &quot;mi&quot;, &quot;ma&quot;, &quot;bi&quot;) to calculate all. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a data.frame with at least two columns: the first column contains the nodes' ids, and the remaining columns contain the corresponding clustering scores. </p>


<h3>Note</h3>

<p> version 1.0.0
</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Barrat, A., Barthelemy, M., Pastor-Satorras, R., Vespignani, A., 2004. The architecture of complex weighted networks. Proceedings of the National Academy of Sciences 101 (11), 3747-3752. arXiv:cond-mat/0311416 <br />
http://toreopsahl.com/2009/01/23/weighted-local-clustering-coefficient/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a random graph
#density: 300/(100*99)=0.03030303; 
#this should be average from random samples
rg &lt;- rg_w(nodes=100,arcs=300,weights=1:10,directed=FALSE)

## Run clustering function
clustering_local_w(rg)

</code></pre>

<hr>
<h2 id='clustering_tm'> Redefined clusering coefficient for two-mode networks </h2><span id='topic+clustering_tm'></span>

<h3>Description</h3>

<p> This function calculates the two-mode clusering coefficient as proposed by Opsahl, T., 2010. Triadic closure in two-mode networks: Redefining the global and local clustering coefficients. arXiv:1006.0887.<br />
Note: If you are having problems with this function (i.e., run out of memory or it being slow for simulations), there is a quicker and much more memory efficient c++ function. However, this function is not fully integrated in R, and requires a few extra steps. Send me an email to get the source-code and Windows-compiled files.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering_tm(net, subsample=1, seed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_tm_+3A_net">net</code></td>
<td>
<p>A binary or weighted two-mode edgelist </p>
</td></tr>
<tr><td><code id="clustering_tm_+3A_subsample">subsample</code></td>
<td>
<p>Whether a only a subset of 4-paths should we used when calculating the measure. This is particularly useful when running out of memory analysing large networks. If it is set to 1, all the 4-paths are analysed. If it set to a value below one, this is roughly the proportion of 4-paths that will be analysed. If it is set to an interger greater than 1, this number of ties that form the first part of a 4-path that will be analysed. Note: The c++ functions are better as they analyse the full network. </p>
</td></tr>
<tr><td><code id="clustering_tm_+3A_seed">seed</code></td>
<td>
<p>If a subset of 4-paths is analysed, by setting this parameter, the results are reproducable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the outcome of the equation presented in the paper</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Tore Opsahl. Triadic closure in two-mode networks: Redefining the global and local clustering coefficients. arXiv:1006.0887  </p>


<h3>Examples</h3>

<pre><code class='language-R'># Weighted two-mode network
net &lt;- cbind(
i=c(1,1,2,2,2,3,3,4,5,5,6),
p=c(1,2,1,3,4,2,3,4,3,5,5),
w=c(3,5,6,1,2,6,2,1,3,1,2))

## Run binary clustering function
clustering_tm(net[,1:2])

## Run weighted clustering function
clustering_tm(net)

</code></pre>

<hr>
<h2 id='clustering_w'> Generalised clusering coefficient </h2><span id='topic+clustering_w'></span>

<h3>Description</h3>

<p> This function calculates the generalised clusering coefficient as proposed by Opsahl, T., Panzarasa, P., 2009. Clustering in weighted networks. Social Networks 31 (2), 155-163, doi: 10.1016/j.socnet.2009.02.002<br />
Note: If you are having problems with this function (i.e., run out of memory or it being slow for simulations), there is a quicker and much more memory efficient c++ function. However, this function is not fully integrated in R, and requires a few extra steps. Send me an email to get the source-code and Windows-compiled files.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering_w(net, measure = "am")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_w_+3A_net">net</code></td>
<td>
<p>A weighted edgelist</p>
</td></tr>
<tr><td><code id="clustering_w_+3A_measure">measure</code></td>
<td>
<p> The measure-switch control the method used to calculate the value of the triplets.<br />
am implies the arithmetic mean method (default)<br />
gm implies the geometric mean method<br />
mi implies the minimum method<br />
ma implies the maximum method<br />
bi implies the binary measure<br />
This can be c(&quot;am&quot;, &quot;gm&quot;, &quot;mi&quot;, &quot;ma&quot;, &quot;bi&quot;) to calculate all. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the outcome of the equation presented in the paper for the method specific (measure)</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Opsahl, T., Panzarasa, P., 2009. Clustering in weighted networks. Social Networks 31 (2), 155-163, doi: 10.1016/j.socnet.2009.02.002 <br />
http://toreopsahl.com/2009/04/03/article-clustering-in-weighted-networks/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a random graph
#density: 300/(100*99)=0.03030303; 
#this should be average from random samples
rg &lt;- rg_w(nodes=100,arcs=300,weights=1:10)

## Run clustering function
clustering_w(rg)

</code></pre>

<hr>
<h2 id='compress_ids'> Remove non-active nodes from one-mode/two-mode/longitudinal networks </h2><span id='topic+compress_ids'></span>

<h3>Description</h3>

<p>The compress_ids function removes non-active nodes from one-mode/two-mode/longitudinal networks. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress_ids(net,type=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress_ids_+3A_net">net</code></td>
<td>
<p>A network in an edgelist or matrix format. See as.tnet </p>
</td></tr>
<tr><td><code id="compress_ids_+3A_type">type</code></td>
<td>
<p> See as.tnet </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with either 2 or 3 objects. The first one is the network with the compressed id. The second object is the translation table between the original node identification numbers and the newly assigned. For two-mode networks, the second object is the translation table of the primary nodes, and the third object is the translation table for the secondary nodes .</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
t &lt;- c("2007-09-12 13:45:00",
  "2007-09-12 13:45:00",
  "2007-09-12 13:45:01",
  "2007-09-12 13:46:31",
  "2007-09-12 13:46:31",
  "2007-09-12 13:47:54",
  "2007-09-12 13:48:21",
  "2007-09-12 13:49:27",
  "2007-09-12 13:49:27",
  "2007-09-12 13:52:17",
  "2007-09-12 13:56:59",
  "2007-09-12 13:58:14")
i &lt;- c(1,2,1,3,1,2,3,5,1,3,1,1);
j &lt;- c(1,2,2,3,3,1,2,5,5,2,3,5);
w &lt;- c(1,1,1,1,1,1,1,1,1,1,1,1);
samplenet &lt;- data.frame(t, i, j, w);

## Run the function
compress_ids(samplenet)


</code></pre>

<hr>
<h2 id='Cross.Parker.Manufacturing.net.info'> Intra-organisational networks </h2><span id='topic+Cross.Parker.Manufacturing.net.info'></span><span id='topic+Cross.Parker.Manufacturing.net.aware'></span><span id='topic+Cross.Parker.Manufacturing.node.location'></span><span id='topic+Cross.Parker.Manufacturing.node.orglevel'></span><span id='topic+Cross.Parker.Manufacturing.node.tenure'></span>

<h3>Description</h3>

<p> This dataset contains two intra-organizational networks from a research team in a manufacturing  company (77 employees). These networks was used by Cross and Parker (2004). <br /><br />
In the first network, the ties among the researchers are differentiated in terms of advice (&quot;Please indicate the extent to which the people listed below provide you with information you use to accomplish your work&quot;). The weights are based on the following scale: 0: I Do Not Know This Person/I Have Never Met this Person; 1: Very Infrequently; 2: Infrequently; 3: Somewhat Infrequently; 4: Somewhat Frequently; 5: Frequently; and 6: Very Frequently.<br /><br />
The second network is based on the employees' awareness of each others' knowledge and skills (&quot;I understand this person's knowledge and skills. This does not necessarily mean that I have these skills or am knowledgeable in these domains but that I understand what skills this person has and domains they are knowledgeable in&quot;). The weight scale in this network is: 0: I Do Not Know This Person/I Have Never Met this Person; 1: Strongly Disagree; 2: Disagree; 3: Somewhat Disagree; 4: Somewhat Agree; 5: Agree; and 6: Strongly Agree.<br /><br />
In addition to the relational data, the dataset also contains information about the people (nodal attributes). The following attributes are known: location (1: Paris; 2: Frankfurt; 3: Warsaw; 4: Geneva), tenure (1: 1-12 months; 2: 13-36 months; 3: 37-60 months; 4: 61+ months) and the organisational level (1: Global Dept Manager; 2: Local Dept Manager; 3: Project Leader; 4: Researcher). <br /><br />
See http://toreopsahl.com/datasets/ </p>


<h3>Usage</h3>

<pre><code class='language-R'>Cross.Parker.Manufacturing.net.info
Cross.Parker.Manufacturing.net.aware
Cross.Parker.Manufacturing.node.location
Cross.Parker.Manufacturing.node.orglevel
Cross.Parker.Manufacturing.node.tenure
</code></pre>


<h3>Format</h3>

<p> The networks are data frames with three columns. The first column is the id of the sender; the second column is the id of the receiver; and the third column is the weight of the tie. The nodal attributes are vectors. </p>


<h3>References</h3>

<p> Cross, R., Parker, A., 2004. The Hidden Power of Social Networks. Harvard Business School Press, Boston, MA.<br />
http://toreopsahl.com/datasets/ </p>

<hr>
<h2 id='Davis.Southern.women.2mode'> Davis' Southern Women network </h2><span id='topic+Davis.Southern.women.2mode'></span><span id='topic+Davis.Southern.women.1mode.Cooccurance'></span><span id='topic+Davis.Southern.women.1mode.Newman'></span>

<h3>Description</h3>

<p>This dataset was collected by Davis and colleague in the 1930s. It contains the observed attendance by 18 Southern women (primary nodes) at 14 social events (secondary nodes). This has been projected onto a co-occurance one-mode network, and a one-mode network based on Newman's (2001) method. </p>


<h3>Usage</h3>

<pre><code class='language-R'>Davis.Southern.women.2mode
Davis.Southern.women.1mode.Cooccurance
Davis.Southern.women.1mode.Newman
</code></pre>


<h3>Format</h3>

<p> The two-mode network is a data frame with two columns (primary nodes and secondary nodes, respectively). The one-mode networks are data frames with three columns: the first column is the id of the sender; the second column is the id of the receiver; and the column third is the weight of the tie. </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Davis, A., Gardner, B. B., Gardner, M. R., 1941. Deep South. University of Chicago Press, Chicago, IL.<br />
http://toreopsahl.com/datasets/</p>

<hr>
<h2 id='degree_tm'> Degree centrality in a two-mode network </h2><span id='topic+degree_tm'></span>

<h3>Description</h3>

<p> This function calculates two degree measures: the number of contacts that a node is connected to, and the sum of weights on ties originating from a node (strength). </p>


<h3>Usage</h3>

<pre><code class='language-R'>degree_tm(net,measure=c("degree","output"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree_tm_+3A_net">net</code></td>
<td>
<p>A two-mode network </p>
</td></tr>
<tr><td><code id="degree_tm_+3A_measure">measure</code></td>
<td>
<p> specifies which measures should be calculated </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a data.frame with two or three columns: the first column contains the nodes' ids, and the remaining columns contain the scores of the measures specified in the measure-parameter. </p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/blog/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
network &lt;- cbind(
i=c(1,1,2,2,2,3,3,4,5,5,6),
p=c(1,2,1,3,4,2,3,4,3,5,5),
w=c(3,5,6,1,2,6,2,1,3,1,2))

## Run the programme
degree_tm(network)

</code></pre>

<hr>
<h2 id='degree_w'> Degree centrality in a weighted network </h2><span id='topic+degree_w'></span>

<h3>Description</h3>

<p> This function calculates two degree measures: the number of contacts that a node is connected to, and the sum of weights on ties originating from a node (out-strength). To calculate the reverse (in-degree, in-strength), specify type=&quot;in&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree_w(net,measure=c("degree","output"), type="out", alpha=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree_w_+3A_net">net</code></td>
<td>
<p>A weighted edgelist</p>
</td></tr>
<tr><td><code id="degree_w_+3A_measure">measure</code></td>
<td>
<p> specifies which measures should be calculated </p>
</td></tr>
<tr><td><code id="degree_w_+3A_type">type</code></td>
<td>
<p> shall out- or in-measures be calculated? Default is out. For undirected networks, this setting is irrelevant, but must be specified. </p>
</td></tr>
<tr><td><code id="degree_w_+3A_alpha">alpha</code></td>
<td>
<p> sets the alpha parameter in the generalised measures from Opsahl, T., Agneessens, F., Skvoretz, J., 2010. Node Centrality in Weighted Networks: Generalizing Degree and Shortest Paths. Social Networks. If this parameter is set to 1 (default), the sum of tie weights is used. This measure simply use the tie weights and disregards the number of nodes on the paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a data.frame with two or more columns: the first column contains the nodes' ids, and the remaining columns contain the scores of the measures specified in the measure-parameter. </p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2008/11/28/network-weighted-network/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
network &lt;- rbind(
c(1,2,4),
c(1,3,2),
c(2,1,4),
c(2,3,4),
c(2,4,1),
c(2,5,2),
c(3,1,2),
c(3,2,4),
c(4,2,1),
c(5,2,2),
c(5,6,1),
c(6,5,1))

## Run the programme
degree_w(network)

</code></pre>

<hr>
<h2 id='dichotomise_tm'> Dichotomise a weighted two-mode network into a binary two-mode network </h2><span id='topic+dichotomise_tm'></span>

<h3>Description</h3>

<p>The dichotomise function creates a binary two-mode network from a weighted edgelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichotomise_tm(net,GT=0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dichotomise_tm_+3A_net">net</code></td>
<td>
<p>A weighted two-mode network </p>
</td></tr>
<tr><td><code id="dichotomise_tm_+3A_gt">GT</code></td>
<td>
<p> the cut-off parameter. Default is set to 0, so edges/arcs with a weight greater than 0 is set to 1. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the edgelist with edges below the cut-off removed, and all weights equal to 1.</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2008/11/28/network-weighted-network/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- cbind(
 i=c(1,1,2,2,2,3,3,4,5,5,6),
 p=c(1,2,1,3,4,2,3,4,3,5,5),
 w=c(3,5,6,1,2,6,2,1,3,1,2))

## Run the programme
dichotomise_tm(sample, GT=2)

</code></pre>

<hr>
<h2 id='dichotomise_w'> Dichotomise a weighted one-mode network into a binary one-mode network </h2><span id='topic+dichotomise_w'></span>

<h3>Description</h3>

<p>The dichotomise function creates a binary one-mode network from a weighted edgelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichotomise_w(net,GT=0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dichotomise_w_+3A_net">net</code></td>
<td>
<p>A weighted one-mode network </p>
</td></tr>
<tr><td><code id="dichotomise_w_+3A_gt">GT</code></td>
<td>
<p> the cut-off parameter. Default is set to 0, so edges/arcs with a weight greater than 0 is set to 1. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the edgelist with edges below the cut-off removed, and all weights equal to 1.</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2008/11/28/network-weighted-network/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- rbind(
c(1,2,4),
c(1,3,2),
c(2,1,4),
c(2,3,4),
c(2,4,1),
c(2,5,2),
c(3,1,2),
c(3,2,4),
c(4,2,1),
c(5,2,2),
c(5,6,1),
c(6,5,1))

## Run the programme
dichotomise_w(sample, GT=2)

</code></pre>

<hr>
<h2 id='distance_tm'> Distance in a two-mode network </h2><span id='topic+distance_tm'></span>

<h3>Description</h3>

<p> The shortest path length, or geodesic distance, between two nodes in a binary network is the minimum number of steps you need to make to go from one of them to the other. See the distance_w-function for more details. </p>


<h3>Usage</h3>

<pre><code class='language-R'> distance_tm(net, projection.method="sum", gconly=TRUE,subsample=1, seed=NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_tm_+3A_net">net</code></td>
<td>
<p>A two-mode network </p>
</td></tr>
<tr><td><code id="distance_tm_+3A_projection.method">projection.method</code></td>
<td>
<p>The way the two-mode network is projected. The sum method defines tie weights as the number of common nodes (e.g., events, projects etc) that two individuals had contact through. In certain cases, &quot;Newman&quot; might be better. See the projecting_tm-function.</p>
</td></tr>
<tr><td><code id="distance_tm_+3A_gconly">gconly</code></td>
<td>
<p> logical, whether the function should only be calculated for the giant component. Default is TRUE.</p>
</td></tr>
<tr><td><code id="distance_tm_+3A_subsample">subsample</code></td>
<td>
<p>Whether a only a subset of starting nodes should we used when calculating the measure. This is particularly useful when running out of memory analysing large networks. If it is set to 1, all distances are analysed. If it set to a value below one, this is roughly the proportion of starting noes that will be analysed. If it is set to an interger greater than 1, this number of starting nodes that will be analysed.</p>
</td></tr>
<tr><td><code id="distance_tm_+3A_seed">seed</code></td>
<td>
<p>If a subset of starting nodes is analysed, by setting this parameter, the results are reproducable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a distance matrix. </p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2009/01/09/average-shortest-distance-in-weighted-networks/ </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load networks
net &lt;- cbind(
 i=c(1,1,2,2,2,3,3,4,5,5,6),
 p=c(1,2,1,3,4,2,3,4,3,5,5),
 w=c(3,5,6,1,2,6,2,1,3,1,2))

# Run the function
distance_tm(net)

</code></pre>

<hr>
<h2 id='distance_w'> Distance in a weighted network </h2><span id='topic+distance_w'></span>

<h3>Description</h3>

<p> The shortest path length, or geodesic distance, between two nodes in a binary network is the minimum number of steps you need to make to go from one of them to the other. This distance is the quickest connection between nodes when all ties are the same. However, in a weighted network, all ties are not the same. See http://toreopsahl.com/2009/01/09/average-shortest-distance-in-weighted-networks/ for more deatails. </p>


<h3>Usage</h3>

<pre><code class='language-R'> distance_w(net, directed=NULL, gconly=TRUE, subsample=1, seed=NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_w_+3A_net">net</code></td>
<td>
<p>A weighted edgelist</p>
</td></tr>
<tr><td><code id="distance_w_+3A_directed">directed</code></td>
<td>
<p> logical, whether the network is directed or undirected. Default is NULL, this means that the function checks whether the edgelist is directed or not.</p>
</td></tr>
<tr><td><code id="distance_w_+3A_gconly">gconly</code></td>
<td>
<p> logical, whether the function should only be calculated for the giant component. Default is TRUE.</p>
</td></tr>
<tr><td><code id="distance_w_+3A_subsample">subsample</code></td>
<td>
<p>Whether a only a subset of starting nodes should we used when calculating the measure. This is particularly useful when running out of memory analysing large networks. If it is set to 1, all distances are analysed. If it set to a value below one, this is roughly the proportion of starting noes that will be analysed. If it is set to an interger greater than 1, this number of starting nodes that will be analysed.</p>
</td></tr>
<tr><td><code id="distance_w_+3A_seed">seed</code></td>
<td>
<p>If a subset of starting nodes is analysed, by setting this parameter, the results are reproducable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a distance matrix. </p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2009/01/09/average-shortest-distance-in-weighted-networks/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- rbind(
c(1,2,8),
c(1,4,1),
c(2,1,8),
c(2,3,6),
c(3,2,6),
c(3,4,10),
c(4,1,1),
c(4,3,10))

## Run the programme
distance_w(sample)

</code></pre>

<hr>
<h2 id='Freemans.EIES.net.1.n48'> Freeman's EIES network data </h2><span id='topic+Freemans.EIES.net.1.n48'></span><span id='topic+Freemans.EIES.net.2.n48'></span><span id='topic+Freemans.EIES.net.3.n32'></span><span id='topic+Freemans.EIES.node.Citations.n32'></span><span id='topic+Freemans.EIES.node.Discipline.n32'></span><span id='topic+Freemans.EIES.node.Name.n32'></span>

<h3>Description</h3>

<p> Freeman's EIES networks (Freeman, 1979) was the main network used in Wasserman and Faust (1994). This dataset was collected in 1978 and contains three networks of researchers working on social network analysis. The first network contains the personal relationships among 48 of the researchers at the beginning of the study (time 1). The second network is the personal relationship at the end of the study (time 2). In these two networks, all ties have a weight between 0 and 4. 4 represents a close personal friend of the researcher's; 3 represents a friend; 2 represents a person the researcher has met; 1 represents a person the researcher has heard of, but not met; and 0 represents a person unknown to the researcher. The third network is different. It is a matrix with the number of messages sent among 32 of the researchers that used an electronic communication tool (frequency matrix). <br /><br />
There are two pieces of information about each of the 32 researchers that were part of the third network (nodal attributes): the main disciplinary affiliation (1: sociology; 2: anthropology; 3: mathematics or statistics; and 4: others) and the number of citations each researcher had in the Social Science Citation Index in 1978.<br /><br />
See http://toreopsahl.com/datasets/ </p>


<h3>Usage</h3>

<pre><code class='language-R'>Freemans.EIES.net.1.n48
Freemans.EIES.net.2.n48
Freemans.EIES.net.3.n32
Freemans.EIES.node.Name.n32
Freemans.EIES.node.Citations.n32
Freemans.EIES.node.Discipline.n32
</code></pre>


<h3>Format</h3>

<p> The networks are data frames with three columns. The first column is the id of the sender, the second column is the id of the receiver; and the third column is the weight of the tie. The attributes are vectors. </p>


<h3>References</h3>

<p> Freeman, S.C., Freeman, L.C., 1979. The networkers network: A study of the impact of a new communications medium on sociometric structure. Social Science Research Reports 46. University of California, Irvine, CA.<br />
See http://toreopsahl.com/datasets/ </p>

<hr>
<h2 id='growth_l'> Identifies growth mechanisms responsible for tie generation in longitudinal networks </h2><span id='topic+growth_l'></span>

<h3>Description</h3>

<p> This function identifies growth mechanisms responsible for tie generation in longitudinal networks. </p>


<h3>Usage</h3>

<pre><code class='language-R'> growth_l(net, perspective = "actor", effects, window=NULL, 
binary=FALSE, nstrata=10, seed=NULL, regression=TRUE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_l_+3A_net">net</code></td>
<td>
<p> A longitudinal network </p>
</td></tr>
<tr><td><code id="growth_l_+3A_perspective">perspective</code></td>
<td>
<p> whether an actor or dyadic perspective should be used (i.e., whether the network is directed or undirected). Currently, only the actor perspective is included. </p>
</td></tr>
<tr><td><code id="growth_l_+3A_effects">effects</code></td>
<td>
<p> The effects to be analysed </p>
</td></tr>
<tr><td><code id="growth_l_+3A_window">window</code></td>
<td>
<p> Whether a window should be used. </p>
</td></tr>
<tr><td><code id="growth_l_+3A_binary">binary</code></td>
<td>
<p> Whether duplicated ties should be removed. </p>
</td></tr>
<tr><td><code id="growth_l_+3A_nstrata">nstrata</code></td>
<td>
<p> Total number of regression observations for each observed tie (i.e., number of control cases plus 1 for the observed tie). Minimum is 2 in which 1 control case is used for each observed case. </p>
</td></tr>
<tr><td><code id="growth_l_+3A_seed">seed</code></td>
<td>
<p> seed for random generator, set to have reproducable results. </p>
</td></tr>
<tr><td><code id="growth_l_+3A_regression">regression</code></td>
<td>
<p> Whether R should perform the regression or output a regression table. If you want to run multiple regression, it is quicker to output the table, and then run multiple regressions. By outputting the table, it is also possible to add square terms and additional data. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a regression result or table. </p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Tore Opsahl, Bernie Hogan. Growth mechanisms in continuously-observed networks: Communication in a Facebook-like community. arXiv:1010.2141 </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
t &lt;- c('2007-09-12 13:45:00', 
'2007-09-12 13:46:31',
'2007-09-12 13:47:54',
'2007-09-12 13:48:21',
'2007-09-12 13:49:27',
'2007-09-12 13:58:14',
'2007-09-12 13:52:17',
'2007-09-12 13:56:59');
i &lt;- c(1,1,2,3,1,3,1,1);
j &lt;- c(2,3,1,2,4,2,3,4);
w &lt;- c(1,1,1,1,1,1,1,1);
sample &lt;- data.frame(t, i, j, w);

## Run the function
growth_l(sample, effects="indegree", nstrata=2)

</code></pre>

<hr>
<h2 id='Newman.Condmat.95.99.net.2mode'> Newman's condmat 95-99 network (two-mode structure) </h2><span id='topic+Newman.Condmat.95.99.net.2mode'></span><span id='topic+Newman.Condmat.95.99.net.1mode.wNewman'></span>

<h3>Description</h3>

<p> This is the co-authorship network of scientists based on preprints posted to Condensed Matter section of arXiv E-Print Archive between 1995 and 1999. <br /><br />
This network can be classified as a two-mode or affiliation network since there are two types of &quot;nodes&quot; (authors and papers) and connections exist only between different types of nodes. An author is connected to a paper if her or his name appeared on it. <br /><br />
Few network measures exist for two-mode networks, and therefore, these networks are often projected onto a one-mode (only one type of nodes) network by selecting one of the types of nodes and linking two nodes if they were connected to the same node (of the other kind). <br /><br />
Traditionally, the ties in projected one-mode networks do not have weights. Recent empirical studies of two-mode networks has created a weighted network by defining the weights as the number of co-occurrences (e.g., the number of papers that two authors had collaborated on). <br /><br />
This method was refined by Newman (2001). He argued that smaller collaborations created stronger social bonds among scientists than larger ones. Therefore, he extended this procedure and proposed to define weights among the nodes use the following formula:<br />
w_ij = sum_p 1/(N_p -1)<br />
where w_ij is the weight between node i and node j, p is the papers that they have collaborated on, and N_p is the number of authors on a paper. This implies that if two authors only write a single paper together with no other co-authors, they get a weight of 1. However, if they have a co-author, the weight on the tie between them is 0.5. If two authors have written two papers together without any co-author, the weight of their tie would be 2. A more complicated example is the tie between two authors who have written two papers together: one without any other co-author and one with one co-author. The first paper would give their tie a weight of 1, and the second tie would add 0.5 to the weight of this tie. Therefore, the weight is 1.5.<br />
Note: This method has been explained in more detail in the following post: <br />
http://toreopsahl.com/2009/05/01/projecting-two-mode-networks-onto-weighted-one-mode-networks/ <br /><br />
This is the two-mode network.
See http://toreopsahl.com/datasets/ </p>


<h3>Usage</h3>

<pre><code class='language-R'>Newman.Condmat.95.99.net.2mode
Newman.Condmat.95.99.net.1mode.wNewman
</code></pre>


<h3>Format</h3>

<p> The two-mode network is a data frame with two columns. The first column is the id of authors and the second column is the id of papers. The one-mode network is a data frame with three columns. The first two columns are ids of the authors, and the third column is the weight of the tie. This is calculated based on Newman's (2001) method for defining tie weights. See the projecting_tm-function. </p>


<h3>References</h3>

<p> Newman, M. E. J., 2001. The structure of scientific collaboration networks. Proceedings of the National Academy of Sciences of the United States of America 98, 404-409.<br />
See http://toreopsahl.com/datasets/ </p>

<hr>
<h2 id='projecting_tm'> Projecting binary and weighted two-mode networks onto weighted one-mode networks. </h2><span id='topic+projecting_tm'></span>

<h3>Description</h3>

<p> This function is the implemtation of the procedure outlined on <br />
http://toreopsahl.com/2009/05/01/projecting-two-mode-networks-onto-weighted-one-mode-networks/ </p>


<h3>Usage</h3>

<pre><code class='language-R'>projecting_tm(net, method = "sum")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projecting_tm_+3A_net">net</code></td>
<td>
<p>A two-mode edgelist</p>
</td></tr>
<tr><td><code id="projecting_tm_+3A_method">method</code></td>
<td>
<p> The method-switch control the method used to calculate the weights.<br />
binary sets all weights to 1<br />
sum sets the weights to the number of cooccurances<br />
Newman bases the weights on Newman's (2001) method of discounting for the size of collaborations. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a one-mode network</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p>Opsahl. T., 2009. Projecting two-mode networks onto weighted one-mode networks. Available at: http://toreopsahl.com/2009/05/01/projecting-two-mode-networks-onto-weighted-one-mode-networks/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## define two-mode network
two.mode.net &lt;- cbind(
i=c(1,1,2,2,2,2,2,3,4,5,5,5,6),
p=c(1,2,1,2,3,4,5,2,3,4,5,6,6))

## Run the function
projecting_tm(two.mode.net, method="Newman")

</code></pre>

<hr>
<h2 id='reinforcement_tm'> Reinforcement_tm </h2><span id='topic+reinforcement_tm'></span>

<h3>Description</h3>

<p> The reinforcement_tm-function computes Robin and Alexander's (2004) 4-cycle metric for two-mode networks. </p>


<h3>Usage</h3>

<pre><code class='language-R'>reinforcement_tm(net)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reinforcement_tm_+3A_net">net</code></td>
<td>
<p>A two-mode network </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the score </p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/tnet/two-mode-networks/clustering/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
net &lt;- rg_tm(10, 7, 0.4)

## Run the programme
reinforcement_tm(net)
</code></pre>

<hr>
<h2 id='rg_reshuffling_l'> Reshuffling a longitudinal network </h2><span id='topic+rg_reshuffling_l'></span>

<h3>Description</h3>

<p>This function reshuffles a longitudinal dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rg_reshuffling_l(net, keep.i = FALSE, keep.j = FALSE, seed = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rg_reshuffling_l_+3A_net">net</code></td>
<td>
<p> Longitudinal network </p>
</td></tr>
<tr><td><code id="rg_reshuffling_l_+3A_keep.i">keep.i</code></td>
<td>
<p> Whether or not the tie creators should be maintained </p>
</td></tr>
<tr><td><code id="rg_reshuffling_l_+3A_keep.j">keep.j</code></td>
<td>
<p> Whether or not the tie receivers should be maintained </p>
</td></tr>
<tr><td><code id="rg_reshuffling_l_+3A_seed">seed</code></td>
<td>
<p> the random seed. If you want it to have reproducable result, set using an integer </p>
</td></tr>
</table>


<h3>Value</h3>

<p>  Returns a reshuffled longitudinal network </p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> tore@opsahl.co.uk </p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- c('2007-09-12 13:45:00', 
'2007-09-12 13:46:31',
'2007-09-12 13:47:54',
'2007-09-12 13:48:21',
'2007-09-12 13:49:27',
'2007-09-12 13:58:14',
'2007-09-12 13:52:17',
'2007-09-12 13:56:59');
i &lt;- c(1,1,1,1,1,1,1,1);
j &lt;- c(2,2,2,2,2,2,3,3);
w &lt;- c(1,1,1,1,1,1,1,1);
sample &lt;- data.frame(t, i, j, w);

rg_reshuffling_l(sample)
</code></pre>

<hr>
<h2 id='rg_reshuffling_tm'> Reshuffle of a binary two-mode network </h2><span id='topic+rg_reshuffling_tm'></span>

<h3>Description</h3>

<p> This function randomly resuffles a binary two-mode edgelist whilst maintaining each nodes' degree (both primary and secondary nodes). </p>


<h3>Usage</h3>

<pre><code class='language-R'> rg_reshuffling_tm(net, option="links", seed=NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rg_reshuffling_tm_+3A_net">net</code></td>
<td>
<p>A two-mode network </p>
</td></tr>
<tr><td><code id="rg_reshuffling_tm_+3A_option">option</code></td>
<td>
<p> Either link reshuffling (option=&quot;links&quot;) or weight reshuffling (option=&quot;weights&quot;), see Opsahl et al. (2008).</p>
</td></tr>
<tr><td><code id="rg_reshuffling_tm_+3A_seed">seed</code></td>
<td>
<p> seed for random generator, set if you want random yet reproducable results. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a binary two-mode edgelist. </p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2009/05/29/weighted-rich-club-effect-a-more-appropriate-null-model-for-scientific-collaboration-networks/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
net &lt;- rg_tm(10, 8, 0.4)

## Run the function on a subset
rg_reshuffling_tm(net, seed=1)


</code></pre>

<hr>
<h2 id='rg_reshuffling_w'> Reshuffle of a weighted network </h2><span id='topic+rg_reshuffling_w'></span>

<h3>Description</h3>

<p> This function randomly resuffles a weighted edgelist. </p>


<h3>Usage</h3>

<pre><code class='language-R'> rg_reshuffling_w(net, option="weights", directed=NULL, seed=NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rg_reshuffling_w_+3A_net">net</code></td>
<td>
<p>A weighted edgelist</p>
</td></tr>
<tr><td><code id="rg_reshuffling_w_+3A_option">option</code></td>
<td>
<p> what should be reshuffled: 1) weights (default): randomly assigns the weights to the edges; 2) links: maintain the degree distribution, but changes the contacts randomly. </p>
</td></tr>
<tr><td><code id="rg_reshuffling_w_+3A_directed">directed</code></td>
<td>
<p> logical: is the network directed or undirected. Default: NULL </p>
</td></tr>
<tr><td><code id="rg_reshuffling_w_+3A_seed">seed</code></td>
<td>
<p> seed for random generator, set if you want random yet reproducable results. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a randomised (reshuffled) network. </p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Molloy, M., Reed, B., 1995. A critical point for random graphs with a given degree sequence. Random Structures and Algorithms 6, 161-180. <br />
Opsahl, T., Colizza, V., Panzarasa, P., Ramasco, J. J., 2008. Prominence and control: The weighted rich-club effect. Physical Review Letters 101 (168702). arXiv:0804.0417. <br />
http://toreopsahl.com/2008/12/12/article-prominence-and-control-the-weighted-rich-club-effect/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sampledata&lt;-rbind(
c(1,2,4),
c(1,3,2),
c(2,1,4),
c(2,3,4),
c(2,4,1),
c(2,5,2),
c(3,1,2),
c(3,2,4),
c(4,2,1),
c(5,2,2),
c(5,6,1),
c(6,5,1));

## Run the function
rg_reshuffling_w(sampledata, option="weights", directed=FALSE)

</code></pre>

<hr>
<h2 id='rg_tm'> Random binary and weighted two-mode network </h2><span id='topic+rg_tm'></span>

<h3>Description</h3>

<p>Creates classical random binary and weighted two-mode networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rg_tm(ni=100,np=100,ties=300,weights=1,seed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rg_tm_+3A_ni">ni</code></td>
<td>
<p> Number of nodes in the first set </p>
</td></tr>
<tr><td><code id="rg_tm_+3A_np">np</code></td>
<td>
<p> Number of nodes in the second set </p>
</td></tr>
<tr><td><code id="rg_tm_+3A_ties">ties</code></td>
<td>
<p> Number of ties; if this value is between 0 and 1, a random network where each tie is based on this probability will be produced </p>
</td></tr>
<tr><td><code id="rg_tm_+3A_weights">weights</code></td>
<td>
<p> A tie weight vector to be randomly sampled. If set to 1 (default), all tie weights will be 1, and hence a binary two-mode network will be created. </p>
</td></tr>
<tr><td><code id="rg_tm_+3A_seed">seed</code></td>
<td>
<p> the random seed. If you want it to be non-reproducable, use NULL otherwise, use a number </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a random two-mode network </p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Tore Opsahl. Triadic closure in two-mode networks: Redefining the global and local clustering coefficients. arXiv:1006.0887 </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Run the programme
rg_tm(ni=10,np=10,ties=20)

</code></pre>

<hr>
<h2 id='rg_w'> Random weighted network generator </h2><span id='topic+rg_w'></span>

<h3>Description</h3>

<p>This function creates a classical random network with random edge weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rg_w(nodes=100,arcs=300,weights=1,directed=TRUE,seed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rg_w_+3A_nodes">nodes</code></td>
<td>
<p> number of nodes </p>
</td></tr>
<tr><td><code id="rg_w_+3A_arcs">arcs</code></td>
<td>
<p> number of arcs; if this value is between 0 and 1, a random network where each tie is based on this probability will be produced </p>
</td></tr>
<tr><td><code id="rg_w_+3A_weights">weights</code></td>
<td>
<p> A tie weight vector to be randomly sampled. </p>
</td></tr>
<tr><td><code id="rg_w_+3A_directed">directed</code></td>
<td>
<p> whether you want a directed or undirected network, values TRUE or FALSE </p>
</td></tr>
<tr><td><code id="rg_w_+3A_seed">seed</code></td>
<td>
<p> the random seed. If you want it to be non-reproducable, use NULL otherwise, use a number </p>
</td></tr>
</table>


<h3>Value</h3>

<p>  Returns a one-mode network with random weights.</p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/tnet/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>rg_w(nodes=10,arcs=30,directed=FALSE,seed=1)
</code></pre>

<hr>
<h2 id='shrink_to_weighted_network'> Shrink a repetative edgelist into a weighted </h2><span id='topic+shrink_to_weighted_network'></span>

<h3>Description</h3>

<p> This function creates a weighted edgelist from a list of edges where a duplicate means an increase in the weight. </p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink_to_weighted_network(net)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink_to_weighted_network_+3A_net">net</code></td>
<td>
<p> can use both undirected and directed edgelist in the following format (sender.id receiver.id):<br />
1 2<br />
1 2<br />
1 2<br />
1 2<br />
1 3<br />
1 3
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a weighted one-mode network, e.g.,<br />
1 2 4 <br />
1 3 2 </p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2008/11/28/network-weighted-network/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- rbind(
c(1,2),
c(1,2),
c(1,2),
c(1,2),
c(1,3),
c(1,3),
c(2,1),
c(2,1),
c(2,1),
c(2,1),
c(2,3),
c(2,3),
c(2,3),
c(2,3),
c(2,4),
c(2,5),
c(2,5),
c(3,1),
c(3,1),
c(3,2),
c(3,2),
c(3,2),
c(3,2),
c(4,2),
c(5,2),
c(5,2),
c(5,6),
c(6,5))

## Run the programme
shrink_to_weighted_network(sample)
</code></pre>

<hr>
<h2 id='symmetrise_w'> Symmetrise_w </h2><span id='topic+symmetrise_w'></span>

<h3>Description</h3>

<p> The symmetrise_w-function creates an undirected one-mode network from a directed one-mode network. </p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetrise_w(net, method="MAX")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetrise_w_+3A_net">net</code></td>
<td>
<p>A one-mode network </p>
</td></tr>
<tr><td><code id="symmetrise_w_+3A_method">method</code></td>
<td>
<p> the method used to decide the weight of the undirected edge. It can be: 
&quot;MAX&quot; sets the weight to the maximum of the weight(s) of the arc(s)
&quot;MIN&quot; sets the weight to the minimumof the weight(s) of the arc(s)
&quot;AMEAN&quot; sets the weight to the average (arithmetic mean) of the weight(s) of the arc(s)
&quot;SUM&quot; sets the weight to the sum of the weight(s) of the arc(s)
&quot;PROD&quot; sets the weight to the product of the weight(s) of the arc(s)
&quot;DIFF&quot; sets the weight to the absolute difference between the weight(s) of the arc(s) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the undirected network </p>


<h3>Note</h3>

<p> version 1.0.0</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/2008/11/28/network-weighted-network/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- rbind(
c(1,2,2),
c(1,3,2),
c(2,1,4),
c(2,3,4),
c(2,4,1),
c(2,5,2),
c(3,1,2),
c(3,2,4),
c(5,2,2),
c(5,6,1))

## Run the programme
symmetrise_w(sample, method="MAX")
</code></pre>

<hr>
<h2 id='tnet_igraph'> Exports a tnet network to an igraph object </h2><span id='topic+tnet_igraph'></span>

<h3>Description</h3>

<p>The tnet_igraph function creates an igraph object from a tnet network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnet_igraph(net,type=NULL, directed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnet_igraph_+3A_net">net</code></td>
<td>
<p>A tnet network </p>
</td></tr>
<tr><td><code id="tnet_igraph_+3A_type">type</code></td>
<td>
<p> type of tnet network, see as.tnet. </p>
</td></tr>
<tr><td><code id="tnet_igraph_+3A_directed">directed</code></td>
<td>
<p> if a one-mode networks, this can be set to avoid testing whether the network is directed. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the igraph object.</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- rbind(
c(1,2,4),
c(1,3,2),
c(2,1,4),
c(2,3,4),
c(2,4,1),
c(2,5,2),
c(3,1,2),
c(3,2,4),
c(4,2,1),
c(5,2,2),
c(5,6,1),
c(6,5,1))

## Run the programme
tnet_igraph(sample, type="weighted one-mode tnet")

</code></pre>

<hr>
<h2 id='tnet_ucinet'> Exports a tnet network to a DL file for UCINET </h2><span id='topic+tnet_ucinet'></span>

<h3>Description</h3>

<p>The tnet_sna function creates a DL file which can easily be imported into UCINET.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnet_ucinet(net, type=NULL, file=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnet_ucinet_+3A_net">net</code></td>
<td>
<p>A tnet network </p>
</td></tr>
<tr><td><code id="tnet_ucinet_+3A_type">type</code></td>
<td>
<p> type of tnet network, see as.tnet. </p>
</td></tr>
<tr><td><code id="tnet_ucinet_+3A_file">file</code></td>
<td>
<p> filename of output file. If this is set to NULL, a file is created in the working directory with the current time (e.g., tnet_ucinet_network-2011-04-10_150817.dl). </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Writes a UCINET dl file.</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- rbind(
c(1,2,4),
c(1,3,2),
c(2,1,4),
c(2,3,4),
c(2,4,1),
c(2,5,2),
c(3,1,2),
c(3,2,4),
c(4,2,1),
c(5,2,2),
c(5,6,1),
c(6,5,1))

## Run the programme
tnet_ucinet(sample, type="weighted one-mode tnet")

</code></pre>

<hr>
<h2 id='tnet-package'> Collection of functions for analysing weighted networks, two-mode networks, and longitudinal networks </h2><span id='topic+tnet'></span>

<h3>Description</h3>

<p> This package is created to analyse weighted networks, two-mode networks, and longitudinal networks datasets. Binary ties limit the richness of network analyses as relations are unique. The two-mode structure contains a number of features lost when projection it to a one-mode network. Longitudinal datasets allow for an understanding of the causal relationship among ties, which is not the case in cross-sectional datasets as ties are dependent upon each other. </p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> tnet</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.0.16</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-02-23 </td>
</tr>

</table>

<p>This package is created to analyse weighted networks, two-mode networks, and longitudinal networks datasets. More information is available on http://toreopsahl.com/tnet/
</p>
<p>It utilises three forms of data structures (it can automatically convert matrices etc into these formats, see the as.tnet-function):
</p>
<p>1) simple weighted data in the following format (creator.node.id target.node.id tie.weight): <br />
1 2 4<br />
1 3 2<br />
Note: For undirected networks, each tie must be mentioned twice (see the symmetrise_w-function). For example, <br />
1 2 4<br />
2 1 4<br />
1 3 2<br />
3 1 2<br />
</p>
<p>2) two-mode data in the following format (primary.node.id secondar.node.id tie.weight.optional): <br />
1 1 1<br />
2 1 2<br />
</p>
<p>3) timed data in the following format (MySQL-timestamp.as.character.string creator.node.id target.node.id tie.weight):<br />
&quot;2007-09-12 13:45:00&quot; 1 2 1<br />
&quot;2007-09-12 13:46:31&quot; 1 2 1<br />
If ties are repeated, the tie increases the weighted. The weight column decides how much weight is added at each time (this can take a negative value to decrease the weight). 
</p>
<p>Attribute files are read as follows:<br />
0 1 3 <br />
0 3 2 <br />
1 3 3 <br />
where the first row refers to node 1, the second row to node 2, etc. The first column refers to the first attribute, second column to the second attribute and so on.
</p>
<p>A big thank you to the igraph guys as this package relies on their work for many of the more computational tasks!
</p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> http://toreopsahl.com/tnet/ </p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random weighted graph
rg &lt;- rg_w(nodes=100,arcs=300,directed=TRUE)

# Calculate clustering coefficient
clustering_w(rg)
</code></pre>

<hr>
<h2 id='USairport.n500.net'> The network among the 500 busiest US commercial airports. </h2><span id='topic+USairport.n500.net'></span>

<h3>Description</h3>

<p> The nodes in this network is the 500 busiest commercial airports in the United States. A tie exists between two airports if a flight was scheduled between them in 2002. The weights corresponds to the number of seats available on the scheduled flights. Even thought this type of networks is directed by nature as a flight is scheduled from one airport and to another, the networks are highly symmetric (Barrat et al., 2004). Therefore, the version of this network is undirected (i.e., the weight of the tie from one airport towards another is equal to the weight of the reciprocal tie). This network was obtained from the Complex Networks Collaboratory's website<br /><br />
See http://toreopsahl.com/datasets/ </p>


<h3>Usage</h3>

<pre><code class='language-R'>USairport.n500.net</code></pre>


<h3>Format</h3>

<p> A data frame with three columns. The first two columns are the nodes' ids, and the third column is the weight of the tie. </p>


<h3>References</h3>

<p> Colizza, V., Pastor-Satorras, R., Vespignani, A., 2007. Reaction-diffusion processes and metapopulation models in heterogeneous networks. Nature Physics 3, 276-282.<br />
See http://toreopsahl.com/datasets/ </p>

<hr>
<h2 id='weighted_richclub_local_w'> The weighted rich-club effect (local measure) </h2><span id='topic+weighted_richclub_local_w'></span>

<h3>Description</h3>

<p> This function calculates the local weighted rich-club coefficient proposed in Opsahl, T., 2008. Local weighted rich-club measure. <br />
http://toreopsahl.com/2008/12/26/local-weighted-rich-club-measure/ </p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_richclub_local_w(net, prominence)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_richclub_local_w_+3A_net">net</code></td>
<td>
<p>A weighted edgelist</p>
</td></tr>
<tr><td><code id="weighted_richclub_local_w_+3A_prominence">prominence</code></td>
<td>
<p> A vector with 1 denoting prominent, and 0 non-prominent. This list must be as long as the highest node id number. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>  Returns a table with the fraction of phi(observed) over phi(null) for each k or s in the dataset.</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Opsahl et al., 2008. Prominence and control: The weighted rich-club effect. PRL 101<br />
http://toreopsahl.com/2008/12/12/article-prominence-and-control-the-weighted-rich-club-effect/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- cbind(
i=c(1,1,2,2,2,2,3,3,4,5,5,6),
j=c(2,3,1,3,4,5,1,2,2,2,6,5),
w=c(4,2,4,4,1,2,2,4,1,2,1,1))
prominence &lt;- c(1,1,1,0,0,0)

## Run the function
weighted_richclub_local_w(sample, prominence)

</code></pre>

<hr>
<h2 id='weighted_richclub_tm'> The weighted rich-club effect (two-mode networks) </h2><span id='topic+weighted_richclub_tm'></span>

<h3>Description</h3>

<p>This function calculates the weighted rich-club coefficient proposed in Opsahl, T., Colizza, V., Panzarasa, P., Ramasco, J.J., 2008. Prominence and control: The weighted rich-club effect. PRL 101. It incorporates two extentions explained in this blog post http://toreopsahl.com/2009/05/29/weighted-rich-club-effect-a-more-appropriate-null-model-for-scientific-collaboration-networks/:<br />
1) a new way of reshuffling (two-mode link reshuffling; <br />
2) calculating significance levels if there are more than 100 random networks (see my PhD thesis; http://toreopsahl.com/publications/thesis/)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_richclub_tm(net, NR=1000, seed=NULL, projection.method="Newman", nbins=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_richclub_tm_+3A_net">net</code></td>
<td>
<p>A binary two-mode edgelist</p>
</td></tr>
<tr><td><code id="weighted_richclub_tm_+3A_nr">NR</code></td>
<td>
<p> number of random networks used. </p>
</td></tr>
<tr><td><code id="weighted_richclub_tm_+3A_seed">seed</code></td>
<td>
<p> the random generators seed, used to produce random yet reproducable results. </p>
</td></tr>
<tr><td><code id="weighted_richclub_tm_+3A_projection.method">projection.method</code></td>
<td>
<p> the method used to project the two-mode network to a weighted one-mode network: either &quot;sum&quot; or &quot;Newman&quot; </p>
</td></tr>
<tr><td><code id="weighted_richclub_tm_+3A_nbins">nbins</code></td>
<td>
<p> the number of bins in the output </p>
</td></tr>
</table>


<h3>Value</h3>

<p>  Returns a table with the fraction of phi(observed) over phi(null). Nbins controls the number of rows.</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Opsahl et al., 2008. Prominence and control: The weighted rich-club effect. PRL 101<br />
http://toreopsahl.com/2008/12/12/article-prominence-and-control-the-weighted-rich-club-effect/ <br />
http://toreopsahl.com/2009/05/29/weighted-rich-club-effect-a-more-appropriate-null-model-for-scientific-collaboration-networks/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load  data
data(tnet)

## Run the function on a subset
weighted_richclub_tm(Newman.Condmat.95.99.net.2mode[1:100,], NR=10)

</code></pre>

<hr>
<h2 id='weighted_richclub_w'> The weighted rich-club effect </h2><span id='topic+weighted_richclub_w'></span>

<h3>Description</h3>

<p> This function calculates the weighted rich-club coefficient proposed in Opsahl, T., Colizza, V., Panzarasa, P., Ramasco, J.J., 2008. Prominence and control: The weighted rich-club effect. PRL 101. <br />
http://toreopsahl.com/2008/12/12/article-prominence-and-control-the-weighted-rich-club-effect/ </p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_richclub_w(net, rich="k", reshuffle="weights", NR=1000, 
nbins=30, seed=NULL, directed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_richclub_w_+3A_net">net</code></td>
<td>
<p>A weighted edgelist</p>
</td></tr>
<tr><td><code id="weighted_richclub_w_+3A_rich">rich</code></td>
<td>
<p> specifies the richness parameter, either &quot;k&quot; or &quot;s&quot;. </p>
</td></tr>
<tr><td><code id="weighted_richclub_w_+3A_reshuffle">reshuffle</code></td>
<td>
<p> specifies the reshuffling procedure used, either &quot;weights&quot; or &quot;links&quot;. </p>
</td></tr>
<tr><td><code id="weighted_richclub_w_+3A_nr">NR</code></td>
<td>
<p> number of random networks used. </p>
</td></tr>
<tr><td><code id="weighted_richclub_w_+3A_nbins">nbins</code></td>
<td>
<p> the number of bins in the output </p>
</td></tr>
<tr><td><code id="weighted_richclub_w_+3A_seed">seed</code></td>
<td>
<p> the random generators seed, used to produce random yet reproducable results. </p>
</td></tr>
<tr><td><code id="weighted_richclub_w_+3A_directed">directed</code></td>
<td>
<p> logical parameter: whether the network is directed or undirected. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>  Returns a table with the fraction of phi(observed) over phi(null) for each k or s in the dataset.</p>


<h3>Note</h3>

<p> version 1.0.0 </p>


<h3>Author(s)</h3>

<p> Tore Opsahl; http://toreopsahl.com </p>


<h3>References</h3>

<p> Opsahl et al., 2008. Prominence and control: The weighted rich-club effect. PRL 101<br />
http://toreopsahl.com/2008/12/12/article-prominence-and-control-the-weighted-rich-club-effect/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load sample data
sample &lt;- cbind(
i=c(1,1,2,2,2,2,3,3,4,5),
j=c(2,3,1,3,4,5,1,2,2,2),
w=c(4,2,4,4,1,2,2,4,1,2))

## Run the function
weighted_richclub_w(sample, rich="k", reshuffle="weights", NR = 100)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
