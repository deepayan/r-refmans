<!DOCTYPE html><html lang="en"><head><title>Help for package StratifiedSampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StratifiedSampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#balseq'><p>Sequential balanced sampling</p></a></li>
<li><a href='#balstrat'><p>Balanced Stratification</p></a></li>
<li><a href='#bsmatch'><p>Statistical matching using optimal transport and balanced sampling</p></a></li>
<li><a href='#c_bound'><p>C bound</p></a></li>
<li><a href='#c_bound2'><p>C bound</p></a></li>
<li><a href='#calibRaking'><p>Calibration using raking ratio</p></a></li>
<li><a href='#cps'><p>Conditional Poisson sampling design</p></a></li>
<li><a href='#disj'><p>Disjunctive</p></a></li>
<li><a href='#disjMatrix'><p>Disjunctive for matrix</p></a></li>
<li><a href='#distUnitk'><p>Squared Euclidean distances of the unit k.</p></a></li>
<li><a href='#fbs'><p>Fast Balanced Sampling</p></a></li>
<li><a href='#ffphase'><p>Fast flight phase of the cube method</p></a></li>
<li><a href='#findB'><p>Find best sub-matrix B in stratifiedcube</p></a></li>
<li><a href='#gencalibRaking'><p>Generalized calibration using raking ratio</p></a></li>
<li><a href='#harmonize'><p>Harmonization by calibration</p></a></li>
<li><a href='#inclprob'><p>Inclusion Probabilities</p></a></li>
<li><a href='#landingRM'><p>Landing by suppression of variables</p></a></li>
<li><a href='#maxentpi2'><p>Joint inclusion probabilities of maximum entropy.</p></a></li>
<li><a href='#ncat'><p>Number of categories</p></a></li>
<li><a href='#osod'><p>One-step One Decision sampling method</p></a></li>
<li><a href='#otmatch'><p>Statistical Matching using Optimal transport</p></a></li>
<li><a href='#pikfromq'><p>pik from q</p></a></li>
<li><a href='#piktfrompik'><p>pikt from pik</p></a></li>
<li><a href='#qfromw'><p>q from w</p></a></li>
<li><a href='#sfromq'><p>s from q</p></a></li>
<li><a href='#stratifiedcube'><p>Stratified Sampling</p></a></li>
<li><a href='#sys_deville'><p>Deville's systematic</p></a></li>
<li><a href='#sys_devillepi2'><p>Second order inclusion probabilities of Deville's systematic</p></a></li>
<li><a href='#vApp'><p>Approximated variance for balanced sample</p></a></li>
<li><a href='#varApp'><p>Approximated variance for balanced sampling</p></a></li>
<li><a href='#varEst'><p>Estimator of the approximated variance for balanced sampling</p></a></li>
<li><a href='#vDBS'><p>Variance Estimation for Doubly Balanced Sample.</p></a></li>
<li><a href='#vEst'><p>Variance Estimation for balanced sample</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Different Methods for Stratified Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Integrating a stratified structure in the population in a sampling design can considerably reduce the variance of the Horvitz-Thompson estimator. We propose in this package different methods to handle the selection of a balanced sample in stratified population. For more details see Raphaël Jauslin, Esther Eustache and Yves Tillé (2021) &lt;<a href="https://doi.org/10.1007%2Fs42081-021-00134-y">doi:10.1007/s42081-021-00134-y</a>&gt;. The package propose also a method based on optimal transport and balanced sampling, see Raphaël Jauslin and Yves Tillé &lt;<a href="https://doi.org/10.1016%2Fj.jspi.2022.12.003">doi:10.1016/j.jspi.2022.12.003</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RJauslin/StratifiedSampling">https://github.com/RJauslin/StratifiedSampling</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RJauslin/StratifiedSampling/issues">https://github.com/RJauslin/StratifiedSampling/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, transport, proxy, MASS, sampling, Rglpk</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, BalancedSampling, stats, testthat,
StatMatch, laeken, prettydoc, ggplot2, viridis, geojsonio, sf,
rmapshaper</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-31 12:48:04 UTC; Raphael</td>
</tr>
<tr>
<td>Author:</td>
<td>Raphael Jauslin <a href="https://orcid.org/0000-0003-1088-3356"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Esther Eustache [aut],
  Bardia Panahbehagh
    <a href="https://orcid.org/0000-0001-9122-7777"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Yves Tillé <a href="https://orcid.org/0000-0003-0904-5523"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raphael Jauslin &lt;raphael.jauslin@bfs.admin.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-31 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='balseq'>Sequential balanced sampling</h2><span id='topic+balseq'></span>

<h3>Description</h3>

<p>Selects at the same time a well-spread and a balanced sample using a sequential implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balseq(pik, Xaux, Xspread = NULL, rord = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balseq_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="balseq_+3A_xaux">Xaux</code></td>
<td>
<p>A matrix of auxiliary variables. The matrix must contains the <code>pik</code> vector to have fixed sample size.</p>
</td></tr>
<tr><td><code id="balseq_+3A_xspread">Xspread</code></td>
<td>
<p>An optional matrix of spatial coordinates.</p>
</td></tr>
<tr><td><code id="balseq_+3A_rord">rord</code></td>
<td>
<p>A logical variable that specify if reordering is applied. Default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function selects a sample using a sequential algorithm. At the same time, it respects the balancing equations (<code>Xaux</code>) and select a well-spread sample (<code>Xspread</code>). Algorithm uses a 
linear program to satisfy the constraints.
</p>


<h3>Value</h3>

<p>Return the selected indices in 1,2,...,N
</p>


<h3>See Also</h3>

<p><code><a href="BalancedSampling.html#topic+lcube">BalancedSampling:lcube</a></code>, <code><a href="sampling.html#topic+samplecube">sampling:samplecube</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
n &lt;- 10
p &lt;- 10

pik &lt;- rep(n/N,N)

Xaux &lt;- array(rnorm(N*p,3,1),c(N,p))

Xspread &lt;- cbind(runif(N),runif(N)) 
Xaux &lt;- cbind(pik,Xaux)

s &lt;- balseq(pik,Xaux)
colSums(Xaux[s,]/as.vector(pik[s]))
colSums(Xaux)


s &lt;- balseq(pik,Xaux,Xspread)
colSums(Xaux[s,]/as.vector(pik[s]))
colSums(Xaux)



</code></pre>

<hr>
<h2 id='balstrat'>Balanced Stratification</h2><span id='topic+balstrat'></span>

<h3>Description</h3>

<p>Select a stratified balanced sample. The function is similar to <code><a href="sampling.html#topic+balancedstratification">balancedstratification</a></code> of the package sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balstrat(X, strata, pik, rand = TRUE, landing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balstrat_+3A_x">X</code></td>
<td>
<p>A matrix of size (<code class="reqn">N</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="balstrat_+3A_strata">strata</code></td>
<td>
<p>A vector of integers that specifies the stratification.</p>
</td></tr>
<tr><td><code id="balstrat_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="balstrat_+3A_rand">rand</code></td>
<td>
<p>if TRUE, the data are randomly arranged. Default TRUE</p>
</td></tr>
<tr><td><code id="balstrat_+3A_landing">landing</code></td>
<td>
<p>if TRUE, landing by linear programming otherwise supression of variables. Default TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the method proposed by Chauvet (2009). Firstly, a flight phase is performed on each strata. Secondly, a flight phase is applied on the whole population by aggregating the strata. Finally, a landing phase is applied by suppression of variables.
</p>


<h3>Value</h3>

<p>A vector with elements equal to 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for rejected units.
</p>


<h3>References</h3>

<p>Chauvet, G. (2009). Stratified balanced sampling. <em>Survey Methodology</em>, 35:115-119.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffphase">ffphase</a></code>, <code><a href="#topic+landingRM">landingRM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 100
n &lt;- 10
p &lt;- 4
X &lt;- matrix(rgamma(N*p,4,25),ncol = p)
strata &lt;- as.matrix(rep(1:n,each = N/n))
pik &lt;- rep(n/N,N)

s &lt;- balstrat(X,strata,pik)

t(X/pik)%*%s
t(X/pik)%*%pik

Xcat &lt;- disj(strata)

t(Xcat)%*%s
t(Xcat)%*%pik
</code></pre>

<hr>
<h2 id='bsmatch'>Statistical matching using optimal transport and balanced sampling</h2><span id='topic+bsmatch'></span>

<h3>Description</h3>

<p>We propose a method based on the output of the function <code><a href="#topic+otmatch">otmatch</a></code>. The method consists of choosing a unit from sample 2 to assign to a particular unit from sample 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsmatch(object, Z2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsmatch_+3A_object">object</code></td>
<td>
<p>A data.frame, output from the function <code><a href="#topic+otmatch">otmatch</a></code>.</p>
</td></tr>
<tr><td><code id="bsmatch_+3A_z2">Z2</code></td>
<td>
<p>A optional matrix, if we want to add some variables for the stratified balanced sampling step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All details of the method can be seen in the manuscript: Raphaël Jauslin and Yves Tillé (2021) &lt;arXiv:2105.08379&gt;.
</p>


<h3>Value</h3>

<p>A list of two objects, A data.frame that contains the matching and the normalized weights. The first two columns of the data.frame contain the unit identities of the two samples. The third column are the final weights. All remaining columns are the matching variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+otmatch">otmatch</a></code>, <code><a href="#topic+stratifiedcube">stratifiedcube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#--- SET UP
N=1000
p=5
X=array(rnorm(N*p),c(N,p))
EPS= 1e-9

n1=100
n2=200

s1=sampling::srswor(n1,N)
s2=sampling::srswor(n2,N)


id1=(1:N)[s1==1]
id2=(1:N)[s2==1]

d1=rep(N/n1,n1)
d2=rep(N/n2,n2)

X1=X[s1==1,]
X2=X[s2==1,]

#--- HARMONIZATION

re=harmonize(X1,d1,id1,X2,d2,id2)
w1=re$w1
w2=re$w2

#--- STATISTICAL MATCHING WITH OT

object = otmatch(X1,id1,X2,id2,w1,w2)

#--- BALANCED SAMPLING

out &lt;- bsmatch(object)


</code></pre>

<hr>
<h2 id='c_bound'>C bound</h2><span id='topic+c_bound'></span>

<h3>Description</h3>

<p>This function is returning the number of unit that we need such that some conditions are fulfilled. See Details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_bound(pik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_bound_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is computing the number of unit <code class="reqn">K</code> that we need to add such that the following conditions are fulfilled :
</p>

<ul>
<li> <p><code class="reqn">\sum_{k = 1}^K \pi_k \geq 1</code>
</p>
</li>
<li> <p><code class="reqn">\sum_{k = 1}^K 1 - \pi_k \geq 1</code>
</p>
</li>
<li><p> Let <code class="reqn">c</code> be the constant such that <code class="reqn">\sum_{k = 2}^K min(c\pi_k,1) = n </code>, we must have that <code class="reqn"> \pi_1 \geq 1- 1/c</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An integer value, the number of units that we need to respect the constraints.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+osod">osod</a></code>
</p>

<hr>
<h2 id='c_bound2'>C bound</h2><span id='topic+c_bound2'></span>

<h3>Description</h3>

<p>This function is returning the number of unit that we need such that some conditions are fulfilled. See Details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_bound2(pik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_bound2_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is computing the number of unit <code class="reqn">K</code> that we need to add such that the following conditions are fulfilled :
</p>

<ul>
<li> <p><code class="reqn">\sum_{k = 1}^K \pi_k \geq 1</code>
</p>
</li>
<li> <p><code class="reqn">\sum_{k = 1}^K 1 - \pi_k \geq 1</code>
</p>
</li>
<li><p> Let <code class="reqn">c</code> be the constant such that <code class="reqn">\sum_{k = 2}^K min(c\pi_k,1) = n </code>, we must have that <code class="reqn"> \pi_1 \geq 1- 1/c</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An integer value, the number of units that we need to respect the constraints.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+osod">osod</a></code>
</p>

<hr>
<h2 id='calibRaking'>Calibration using raking ratio</h2><span id='topic+calibRaking'></span>

<h3>Description</h3>

<p>This function is inspired by the function <code><a href="sampling.html#topic+calib">calib</a></code> of the package sampling. It computes the g-weights of the calibration estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibRaking(Xs, d, total, q, max_iter = 500L, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibRaking_+3A_xs">Xs</code></td>
<td>
<p>A matrix of calibration variables.</p>
</td></tr>
<tr><td><code id="calibRaking_+3A_d">d</code></td>
<td>
<p>A vector, the initial weights.</p>
</td></tr>
<tr><td><code id="calibRaking_+3A_total">total</code></td>
<td>
<p>A vector that represents the initial weights.</p>
</td></tr>
<tr><td><code id="calibRaking_+3A_q">q</code></td>
<td>
<p>A vector of positive value that account for heteroscedasticity.</p>
</td></tr>
<tr><td><code id="calibRaking_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer, the maximum number of iterations. Default = 500.</p>
</td></tr>
<tr><td><code id="calibRaking_+3A_tol">tol</code></td>
<td>
<p>A scalar that represents the tolerance value for the algorithm. Default = 1e-9.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details on the different calibration methods can be read in Tillé Y. (2020).
</p>


<h3>Value</h3>

<p>A vector, the value of the g-weights.
</p>


<h3>References</h3>

<p>Tillé, Y. (2020). <em>Sampling and estimation from finite populations</em>. Wiley, New York
</p>

<hr>
<h2 id='cps'>Conditional Poisson sampling design</h2><span id='topic+cps'></span>

<h3>Description</h3>

<p>Maximum entropy sampling with fixed sample size. It select a sample with fixed sample size with unequal inclusion probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cps(pik, eps = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cps_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="cps_+3A_eps">eps</code></td>
<td>
<p>A scalar that specify the tolerance to transform a small value to the value 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conditional Poisson sampling, the sampling design maximizes the entropy:
</p>
<p style="text-align: center;"><code class="reqn">I(p) = - \sum s p(s) log[p(s)].</code>
</p>

<p>where s is of fixed sample size. Indeed, Poisson sampling is known for maximizing the entropy but has no fixed sample size. The function selects a sample of fixed sample that maximizes entropy.
</p>
<p>This function is a C++ implementation of <code><a href="sampling.html#topic+UPmaxentropy">UPmaxentropy</a></code> of the package <code>sampling</code>. More details could be find in Tille (2006).
</p>


<h3>Value</h3>

<p>A vector with elements equal to 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for rejected units.
</p>


<h3>References</h3>

<p>Tille, Y. (2006), Sampling Algorithms, springer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pik &lt;- inclprob(seq(100,1,length.out = 100),10)
s &lt;-  cps(pik)



# simulation with piktfrompik MUCH MORE FASTER
s &lt;- rep(0,length(pik))
SIM &lt;- 100
pikt &lt;- piktfrompik(pik)
w &lt;- pikt/(1-pikt)
q &lt;- qfromw(w,sum(pik))
for(i in 1 :SIM){
  s &lt;- s + sfromq(q)
}
p &lt;- s/SIM # estimated inclusion probabilities
t &lt;- (p-pik)/sqrt(pik*(1-pik)/SIM)
1 - sum(t &gt; 1.6449)/length(pik) # should be approximately equal to 0.95 

</code></pre>

<hr>
<h2 id='disj'>Disjunctive</h2><span id='topic+disj'></span>

<h3>Description</h3>

<p>This function transforms a categorical vector into a matrix of indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disj(strata_input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disj_+3A_strata_input">strata_input</code></td>
<td>
<p>A vector of integers that represents the categories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of indicators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strata &lt;- rep(c(1,2,3),each = 4)
disj(strata)

</code></pre>

<hr>
<h2 id='disjMatrix'>Disjunctive for matrix</h2><span id='topic+disjMatrix'></span>

<h3>Description</h3>

<p>This function transforms a categorical matrix into a matrix of indicators variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disjMatrix(strata_input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disjMatrix_+3A_strata_input">strata_input</code></td>
<td>
<p>A matrix of integers that contains categorical vector in each column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of indicators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xcat &lt;-  matrix(c(sample(x = 1:6, size = 100, replace = TRUE),
            sample(x = 1:6, size = 100, replace = TRUE),
            sample(x = 1:6, size = 100, replace = TRUE)),ncol = 3)
disjMatrix(Xcat)

</code></pre>

<hr>
<h2 id='distUnitk'>Squared Euclidean distances of the unit k.</h2><span id='topic+distUnitk'></span>

<h3>Description</h3>

<p>Calculate the squared Euclidean distance from unit <code class="reqn">k</code> to the other units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distUnitk(X, k, tore, toreBound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distUnitk_+3A_x">X</code></td>
<td>
<p>matrix representing the spatial coordinates.</p>
</td></tr>
<tr><td><code id="distUnitk_+3A_k">k</code></td>
<td>
<p>the unit index to be used.</p>
</td></tr>
<tr><td><code id="distUnitk_+3A_tore">tore</code></td>
<td>
<p>an optional logical value, if we are considering the distance on a tore. See Details.</p>
</td></tr>
<tr><td><code id="distUnitk_+3A_torebound">toreBound</code></td>
<td>
<p>an optional numeric value that specify the length of the tore.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\mathbf{x}_k,\mathbf{x}_l</code> be the spatial coordinates of the unit <code class="reqn">k,l \in U</code>. The classical euclidean distance is given by
</p>
<p style="text-align: center;"><code class="reqn">d^2(k,l) = (\mathbf{x}_k - \mathbf{x}_l)^\top (\mathbf{x}_k - \mathbf{x}_l). </code>
</p>

<p>When the points are distributed on a <code class="reqn">N_1 \times N_2</code> regular grid of <code class="reqn">R^2</code>.
It is possible to consider the units like they were placed on a tore. It can be illustrated by Pac-Man passing through the wall to get away from ghosts. Specifically,
we could consider two units on the same column (resp. row) that are on the opposite have a small distance,
</p>
<p style="text-align: center;"><code class="reqn"> d^2_T(k,l) = min( (x_{k_1} - x_{l_1})^2,
                      (x_{k_1} + N_1 - x_{l_1})^2,
                      (x_{k_1} - N_1 - x_{l_1})^2) +</code>
</p>

<p style="text-align: center;"><code class="reqn"> min( (x_{k_2} - x_{l_2})^2,
                      (x_{k_2} + N_2 - x_{l_2})^2,
                      (x_{k_2} - N_2 - x_{l_2})^2).</code>
</p>

<p>The option <code>toreBound</code> specify the length of the tore in the case of <code class="reqn">N_1 = N_2 = N</code>. 
It is omitted if the <code>tore</code> option is equal to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>a vector of length <code class="reqn">N</code> that contains the distances from the unit <code class="reqn">k</code> to all other units.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  N &lt;- 5
  x &lt;- seq(1,N,1)
  X &lt;- as.matrix(expand.grid(x,x))
  distUnitk(X,k = 2,tore = TRUE,toreBound = 5)
  distUnitk(X,k = 2,tore = FALSE,toreBound = -1)
</code></pre>

<hr>
<h2 id='fbs'>Fast Balanced Sampling</h2><span id='topic+fbs'></span>

<h3>Description</h3>

<p>This function implements the method proposed by Hasler and Tillé (2014). It should be used for selecting a sample from highly stratified population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbs(X, strata, pik, rand = TRUE, landing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbs_+3A_x">X</code></td>
<td>
<p>A matrix of size (<code class="reqn">N</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="fbs_+3A_strata">strata</code></td>
<td>
<p>A vector of integers that specifies the stratification.</p>
</td></tr>
<tr><td><code id="fbs_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="fbs_+3A_rand">rand</code></td>
<td>
<p>if TRUE, the data are randomly arranged. Default TRUE</p>
</td></tr>
<tr><td><code id="fbs_+3A_landing">landing</code></td>
<td>
<p>if TRUE, landing by linear programming otherwise supression of variables. Default TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly a flight phase is performed on each strata. Secondly, several flight phases are applied by adding one by one the stratum. By doing this, some strata are managed on-the-fly. Finally, a landing phase is applied by suppression of the variables. If the number of element selected in each stratum is not equal to an integer, the function can be very time-consuming.
</p>


<h3>Value</h3>

<p>A vector with elements equal to 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for rejected units.
</p>


<h3>References</h3>

<p>Hasler, C. and Tillé Y. (2014). Fast balanced sampling for highly stratified population. <em>Computational Statistics and Data Analysis</em>, 74, 81-94
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 100
n &lt;- 10
x1 &lt;- rgamma(N,4,25)
x2 &lt;- rgamma(N,4,25)

strata &lt;- rep(1:n,each = N/n)

pik &lt;- rep(n/N,N)
X &lt;- as.matrix(cbind(matrix(c(x1,x2),ncol = 2)))

s &lt;- fbs(X,strata,pik)

t(X/pik)%*%s
t(X/pik)%*%pik

Xcat &lt;- disj(strata)

t(Xcat)%*%s
t(Xcat)%*%pik


</code></pre>

<hr>
<h2 id='ffphase'>Fast flight phase of the cube method</h2><span id='topic+ffphase'></span>

<h3>Description</h3>

<p>This function computes the flight phase of the cube method proposed by Chauvet and Tillé (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffphase(Xbal, prob, order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ffphase_+3A_xbal">Xbal</code></td>
<td>
<p>A matrix of size (<code class="reqn">N</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="ffphase_+3A_prob">prob</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="ffphase_+3A_order">order</code></td>
<td>
<p>if the units are reordered, Default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the method proposed by (Chauvet and Tillé 2006). It recursively transforms the vector of inclusion probabilities <code>pik</code> into a
sample that respects the balancing equations. The algorithm stops when the null space of the sub-matrix <code class="reqn">B</code> is empty.
For more information see (Chauvet and Tillé 2006).
</p>


<h3>Value</h3>

<p>Updated vector of <code>pik</code> that contains 0 and 1 for unit that are rejected or selected.
</p>


<h3>See Also</h3>

<p><code><a href="sampling.html#topic+samplecube">fastflightphase</a></code>, <code><a href="BalancedSampling.html#topic+cube">cube</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
n &lt;- 10
p &lt;- 4
pik &lt;- rep(n/N,N)
X &lt;- cbind(pik,matrix(rgamma(N*p,4,25),ncol= p))

pikstar &lt;- ffphase(X,pik) 
t(X/pik)%*%pikstar
t(X/pik)%*%pik
pikstar
</code></pre>

<hr>
<h2 id='findB'>Find best sub-matrix B in stratifiedcube</h2><span id='topic+findB'></span>

<h3>Description</h3>

<p>This function is computing a sub-matrix used in <code><a href="#topic+stratifiedcube">stratifiedcube</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findB(X, strata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findB_+3A_x">X</code></td>
<td>
<p>A matrix of size (<code class="reqn">N</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="findB_+3A_strata">strata</code></td>
<td>
<p>A vector of integers that specifies the stratification.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function finds the smallest matrix B such that it contains only one more row than the number of columns.
It consecutively adds the right number of rows depending on the number of categories that is added.
</p>


<h3>Value</h3>

<p>A list of two components. The sub-matrix of <code>X</code> and the corresponding disjunctive matrix.
If we use the function <code>cbind</code> to combine the two matrices, the resulting matrix has only one more row than the number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000
strata &lt;-  sample(x = 1:6, size = N, replace = TRUE)

p &lt;- 3
X &lt;- matrix(rnorm(N*p),ncol = 3)
findB(X,strata)

</code></pre>

<hr>
<h2 id='gencalibRaking'>Generalized calibration using raking ratio</h2><span id='topic+gencalibRaking'></span>

<h3>Description</h3>

<p>This function is inspired by the function <code><a href="sampling.html#topic+calib">calib</a></code> of the package sampling. It computes the g-weights of the calibration estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gencalibRaking(Xs, Zs, d, total, q, max_iter = 500L, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gencalibRaking_+3A_xs">Xs</code></td>
<td>
<p>A matrix of calibration variables.</p>
</td></tr>
<tr><td><code id="gencalibRaking_+3A_zs">Zs</code></td>
<td>
<p>A matrix of instrumental variables with same dimension as Xs.</p>
</td></tr>
<tr><td><code id="gencalibRaking_+3A_d">d</code></td>
<td>
<p>A vector, the initial weights.</p>
</td></tr>
<tr><td><code id="gencalibRaking_+3A_total">total</code></td>
<td>
<p>A vector that represents the initial weights.</p>
</td></tr>
<tr><td><code id="gencalibRaking_+3A_q">q</code></td>
<td>
<p>A vector of positive value that account for heteroscedasticity.</p>
</td></tr>
<tr><td><code id="gencalibRaking_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer, the maximum number of iterations. Default = 500.</p>
</td></tr>
<tr><td><code id="gencalibRaking_+3A_tol">tol</code></td>
<td>
<p>A scalar that represents the tolerance value for the algorithm. Default = 1e-9.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details on the different calibration methods can be read in Tillé Y. (2020).
</p>


<h3>Value</h3>

<p>A vector, the value of the g-weights.
</p>


<h3>References</h3>

<p>Tillé, Y. (2020). <em>Sampling and estimation from finite populations</em>. Wiley, New York
</p>

<hr>
<h2 id='harmonize'>Harmonization by calibration</h2><span id='topic+harmonize'></span>

<h3>Description</h3>

<p>This function harmonize the two weight schemes such that the totals are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonize(X1, d1, id1, X2, d2, id2, totals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="harmonize_+3A_x1">X1</code></td>
<td>
<p>A matrix, the matching variables of sample 1.</p>
</td></tr>
<tr><td><code id="harmonize_+3A_d1">d1</code></td>
<td>
<p>A numeric vector that contains the initial weights of the sample 1.</p>
</td></tr>
<tr><td><code id="harmonize_+3A_id1">id1</code></td>
<td>
<p>A character or numeric vector that contains the labels of the units in sample 1.</p>
</td></tr>
<tr><td><code id="harmonize_+3A_x2">X2</code></td>
<td>
<p>A matrix, the matching variables of sample 2.</p>
</td></tr>
<tr><td><code id="harmonize_+3A_d2">d2</code></td>
<td>
<p>A numeric vector that contains the initial weights of the sample 1.</p>
</td></tr>
<tr><td><code id="harmonize_+3A_id2">id2</code></td>
<td>
<p>A character or numeric vector that contains the labels of the units in sample 2.</p>
</td></tr>
<tr><td><code id="harmonize_+3A_totals">totals</code></td>
<td>
<p>An optional numeric vector that contains the totals of the matching variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All details of the method can be seen in the manuscript: Raphaël Jauslin and Yves Tillé (2021) &lt;arXiv:&gt;.
</p>


<h3>Value</h3>

<p>A list of two vectors, the new weights of sample 1 (respectively new weights of sample 2).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#--- SET UP

N = 1000
p = 5
X = array(rnorm(N*p),c(N,p))

n1=100
n2=200

s1 = sampling::srswor(n1,N)
s2 = sampling::srswor(n2,N)

id1=(1:N)[s1==1]
id2=(1:N)[s2==1]

d1=rep(N/n1,n1)
d2=rep(N/n2,n2)

X1 = X[s1==1,]
X2 = X[s2==1,]

re &lt;- harmonize(X1,d1,id1,X2,d2,id2)

colSums(re$w1*X1)
colSums(re$w2*X2)

#---  if the true totals is known

totals &lt;- c(N,colSums(X))
re &lt;- harmonize(X1,d1,id1,X2,d2,id2,totals)

colSums(re$w1*X1)
colSums(re$w2*X2)
colSums(X)

</code></pre>

<hr>
<h2 id='inclprob'>Inclusion Probabilities</h2><span id='topic+inclprob'></span>

<h3>Description</h3>

<p>Computes first-order inclusion probabilities from a vector of positive numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclprob(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inclprob_+3A_x">x</code></td>
<td>
<p>vector of positive numbers.</p>
</td></tr>
<tr><td><code id="inclprob_+3A_n">n</code></td>
<td>
<p>sample size (could be a positive real value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is implemented in C++ so that it can be used in the code of other C++ functions. The implementation is based on the function  <code><a href="sampling.html#topic+inclusionprobabilities">inclusionprobabilities</a></code> of the package sampling.
</p>


<h3>Value</h3>

<p>A vector of inclusion probabilities proportional to <code>x</code> and such that the sum is equal to the value <code>n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="sampling.html#topic+inclusionprobabilities">inclusionprobabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- runif(100)
pik &lt;- inclprob(x,70)
sum(pik)

</code></pre>

<hr>
<h2 id='landingRM'>Landing by suppression of variables</h2><span id='topic+landingRM'></span>

<h3>Description</h3>

<p>This function performs the landing phase of the cube method using suppression of variables proposed by Chauvet and Tillé (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landingRM(A, pikstar, EPS = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landingRM_+3A_a">A</code></td>
<td>
<p>matrix of auxiliary variables on which the sample must be balanced. (The matrix should be divided by the original inclusion probabilities.)</p>
</td></tr>
<tr><td><code id="landingRM_+3A_pikstar">pikstar</code></td>
<td>
<p>vector of updated inclusion probabilities by the flight phase. See <code><a href="#topic+ffphase">ffphase</a></code></p>
</td></tr>
<tr><td><code id="landingRM_+3A_eps">EPS</code></td>
<td>
<p>epsilon value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with elements equal to 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for rejected units.
</p>


<h3>References</h3>

<p>Chauvet, G. and Tillé, Y. (2006). A fast algorithm of balanced sampling. <em>Computational Statistics</em>, 21/1:53-62
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fbs">fbs</a></code>, <code><a href="#topic+balstrat">balstrat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000
n &lt;- 10
p &lt;- 4
pik &lt;- rep(n/N,N)
X &lt;- cbind(pik,matrix(rgamma(N*p,4,25),ncol= p))
pikstar &lt;- ffphase(X,pik) 
s &lt;- landingRM(X/pik*pikstar,pikstar)
sum(s)
t(X/pik)%*%pik
t(X/pik)%*%pikstar
t(X/pik)%*%s
</code></pre>

<hr>
<h2 id='maxentpi2'>Joint inclusion probabilities of maximum entropy.</h2><span id='topic+maxentpi2'></span>

<h3>Description</h3>

<p>This function computes the matrix of the joint inclusion of the maximum entropy sampling with fixed sample size. It can handle unequal inclusion probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxentpi2(pikr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxentpi2_+3A_pikr">pikr</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampling design maximizes the entropy design:
</p>
<p style="text-align: center;"><code class="reqn">I(p) = - \sum s p(s) log[p(s)].</code>
</p>

<p>This function is a C++ implementation of <code><a href="sampling.html#topic+UPMEpik2frompikw">UPMEpik2frompikw</a></code>.
More details could be find in Tille (2006).
</p>


<h3>Value</h3>

<p>A matrix, the joint inclusion probabilities.
</p>


<h3>References</h3>

<p>Tille, Y. (2006), Sampling Algorithms, springer
</p>

<hr>
<h2 id='ncat'>Number of categories</h2><span id='topic+ncat'></span>

<h3>Description</h3>

<p>This function returns the number of factor in each column of a categorical matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncat(Xcat_input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ncat_+3A_xcat_input">Xcat_input</code></td>
<td>
<p>A matrix of integers that contains categorical vector in each column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row vector that contains the number of categories in each column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xcat &lt;-  matrix(c(sample(x = 1:6, size = 100, replace = TRUE),
            sample(x = 1:6, size = 100, replace = TRUE),
            sample(x = 1:6, size = 100, replace = TRUE)),ncol = 3)
ncat(Xcat)
</code></pre>

<hr>
<h2 id='osod'>One-step One Decision sampling method</h2><span id='topic+osod'></span>

<h3>Description</h3>

<p>This function implements the One-step One Decision method. It can be used using equal or unequal inclusion probabilities. The method is particularly useful for selecting a sample from a stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osod(pikr, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="osod_+3A_pikr">pikr</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="osod_+3A_full">full</code></td>
<td>
<p>An optional boolean value, to specify whether the full population (the entire vector) is used to update inclusion probabilities. Default: FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method sequentially transforms the vector of inclusion probabilities into a sample whose values are equal to 0 or 1. The method respects the inclusion probabilities and can
handle equal or unequal inclusion probabilities.
</p>
<p>The method does not take into account the whole vector of inclusion probabilities by having a sequential implementation. This means that the method is fast and can be implemented in a flow.
</p>


<h3>Value</h3>

<p>A vector with elements equal to 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for rejected units.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c_bound">c_bound</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 1000
n &lt;- 100
pik &lt;- inclprob(runif(N),n)
s &lt;- osod(pik)

</code></pre>

<hr>
<h2 id='otmatch'>Statistical Matching using Optimal transport</h2><span id='topic+otmatch'></span>

<h3>Description</h3>

<p>This function computes the statistical matching between two complex survey samples with weighting schemes. The function uses the function <code><a href="transport.html#topic+transport">transport</a></code> of the package <code>transport</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otmatch(
  X1,
  id1,
  X2,
  id2,
  w1,
  w2,
  dist_method = "Euclidean",
  transport_method = "shortsimplex",
  EPS = 1e-09
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="otmatch_+3A_x1">X1</code></td>
<td>
<p>A matrix, the matching variables of sample 1.</p>
</td></tr>
<tr><td><code id="otmatch_+3A_id1">id1</code></td>
<td>
<p>A character or numeric vector that contains the labels of the units in sample 1.</p>
</td></tr>
<tr><td><code id="otmatch_+3A_x2">X2</code></td>
<td>
<p>A matrix, the matching variables of sample 2.</p>
</td></tr>
<tr><td><code id="otmatch_+3A_id2">id2</code></td>
<td>
<p>A character or numeric vector that contains the labels of the units in sample 1.</p>
</td></tr>
<tr><td><code id="otmatch_+3A_w1">w1</code></td>
<td>
<p>A numeric vector that contains the weights of the sample 1, harmonized by the function <code><a href="#topic+harmonize">harmonize</a></code>.</p>
</td></tr>
<tr><td><code id="otmatch_+3A_w2">w2</code></td>
<td>
<p>A numeric vector that contains the weights of the sample 2, harmonized by the function <code><a href="#topic+harmonize">harmonize</a></code>.</p>
</td></tr>
<tr><td><code id="otmatch_+3A_dist_method">dist_method</code></td>
<td>
<p>A string that specified the  distance used by the function <code><a href="proxy.html#topic+dist">dist</a></code> of the package <code>proxy</code>. Default <code>"Euclidean"</code>.</p>
</td></tr>
<tr><td><code id="otmatch_+3A_transport_method">transport_method</code></td>
<td>
<p>A string that specified the  distance used by the function <code><a href="transport.html#topic+transport">transport</a></code> of the package <code>transport</code>. Default <code>"shortsimplex"</code>.</p>
</td></tr>
<tr><td><code id="otmatch_+3A_eps">EPS</code></td>
<td>
<p>an numeric scalar to determine if the value is rounded to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All details of the method can be seen in : Raphaël Jauslin and Yves Tillé (2021) &lt;arXiv:2105.08379&gt;.
</p>


<h3>Value</h3>

<p>A data.frame that contains the matching. The first two columns contain the unit identities of the two samples. The third column is the final weights. All remaining columns are the matching variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#--- SET UP
N=1000
p=5
X=array(rnorm(N*p),c(N,p))
EPS= 1e-9

n1=100
n2=200

s1 = sampling::srswor(n1,N)
s2 = sampling::srswor(n2,N)


id1=(1:N)[s1==1]
id2=(1:N)[s2==1]

d1=rep(N/n1,n1)
d2=rep(N/n2,n2)

X1=X[s1==1,]
X2=X[s2==1,]

#--- HARMONIZATION

re=harmonize(X1,d1,id1,X2,d2,id2)
w1=re$w1
w2=re$w2

#--- STATISTICAL MATCHING WITH OT

object = otmatch(X1,id1,X2,id2,w1,w2)


round(colSums(object$weight*object[,4:ncol(object)]),3)
round(colSums(w1*X1),3)
round(colSums(w2*X2),3)
</code></pre>

<hr>
<h2 id='pikfromq'>pik from q</h2><span id='topic+pikfromq'></span>

<h3>Description</h3>

<p>This function finds the <code>pik</code> from an initial <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pikfromq(q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pikfromq_+3A_q">q</code></td>
<td>
<p>A matrix that is computed from the function <code><a href="#topic+qfromw">qfromw</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details could be find in Tille (2006).
</p>


<h3>Value</h3>

<p>A vector of inclusion probability computed from the matrix <code>q</code>.
</p>


<h3>References</h3>

<p>Tille, Y. (2006), Sampling Algorithms, springer
</p>

<hr>
<h2 id='piktfrompik'>pikt from pik</h2><span id='topic+piktfrompik'></span>

<h3>Description</h3>

<p>This function finds the <code>pikt</code> from an initial <code>pik</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piktfrompik(pik, max_iter = 500L, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="piktfrompik_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities. The vector must contains only value that are not integer.</p>
</td></tr>
<tr><td><code id="piktfrompik_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer that specify the maximum iteration in the Newton-Raphson algorithm. Default <code>500</code>.</p>
</td></tr>
<tr><td><code id="piktfrompik_+3A_tol">tol</code></td>
<td>
<p>A scalar that specify the tolerance convergence for the Newton-Raphson algorithm. Default <code>1e-8</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The management of probabilities equal to 0 or 1 is done in the cps function.
</p>
<p><code>pikt</code> is the vector of inclusion probabilities of a Poisson sampling with the right parameter. The vector is found by Newtwon-Raphson algorithm.
</p>
<p>More details could be find in Tille (2006).
</p>


<h3>Value</h3>

<p>An updated vector of inclusion probability.
</p>


<h3>References</h3>

<p>Tille, Y. (2006), Sampling Algorithms, springer
</p>

<hr>
<h2 id='qfromw'>q from w</h2><span id='topic+qfromw'></span>

<h3>Description</h3>

<p>This function finds the matrix <code>q</code> form a particular <code>w</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfromw(w, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qfromw_+3A_w">w</code></td>
<td>
<p>A vector of weights.</p>
</td></tr>
<tr><td><code id="qfromw_+3A_n">n</code></td>
<td>
<p>An integer that is equal to the sum of the inclusion probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>w</code> is generally computed by the formula <code>pik/(1-pik)</code>, where <code>n</code> is equal to the sum of the vector <code>pik</code>.
More details could be find in Tille (2006).
</p>


<h3>Value</h3>

<p>A matrix of size <code>N</code> x <code>n</code>, where <code>N</code> is equal to the length of the vector <code>w</code>.
</p>


<h3>References</h3>

<p>Tille, Y. (2006), Sampling Algorithms, springer
</p>

<hr>
<h2 id='sfromq'>s from q</h2><span id='topic+sfromq'></span>

<h3>Description</h3>

<p>This function finds sample <code>s</code> form the matrix <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfromq(q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfromq_+3A_q">q</code></td>
<td>
<p>A matrix that is computed from the function <code><a href="#topic+qfromw">qfromw</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details could be find in Tille (2006).
</p>


<h3>Value</h3>

<p>A vector with elements equal to 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for rejected units.
</p>


<h3>References</h3>

<p>Tille, Y. (2006), Sampling Algorithms, springer
</p>

<hr>
<h2 id='stratifiedcube'>Stratified Sampling</h2><span id='topic+stratifiedcube'></span>

<h3>Description</h3>

<p>This function implements a method for selecting a stratified sample. It really improves the performance of the function <code><a href="#topic+fbs">fbs</a></code> and <code><a href="#topic+balstrat">balstrat</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratifiedcube(
  X,
  strata,
  pik,
  EPS = 1e-07,
  rand = TRUE,
  landing = TRUE,
  lp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stratifiedcube_+3A_x">X</code></td>
<td>
<p>A matrix of size (<code class="reqn">N</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="stratifiedcube_+3A_strata">strata</code></td>
<td>
<p>A vector of integers that specifies the stratification..</p>
</td></tr>
<tr><td><code id="stratifiedcube_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="stratifiedcube_+3A_eps">EPS</code></td>
<td>
<p>epsilon value</p>
</td></tr>
<tr><td><code id="stratifiedcube_+3A_rand">rand</code></td>
<td>
<p>if TRUE, the data are randomly arranged. Default TRUE</p>
</td></tr>
<tr><td><code id="stratifiedcube_+3A_landing">landing</code></td>
<td>
<p>if FALSE, no landing phase is done.</p>
</td></tr>
<tr><td><code id="stratifiedcube_+3A_lp">lp</code></td>
<td>
<p>if TRUE, landing by linear programming otherwise supression of variables. Default TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is selecting a balanced sample very quickly even if the sum of inclusion probabilities within strata are non-integer. The function should be used in preference. Firstly, a flight phase is performed on each strata. Secondly, the function <code><a href="#topic+findB">findB</a></code> is used to find a particular matrix to apply a flight phase by using the cube method proposed by Chauvet, G. and Tillé, Y. (2006). Finally, a landing phase is applied by suppression of variables.
</p>


<h3>Value</h3>

<p>A vector with elements equal to 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for rejected units.
</p>


<h3>References</h3>

<p>Chauvet, G. and Tillé, Y. (2006). A fast algorithm of balanced sampling. <em>Computational Statistics</em>, 21/1:53-62
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fbs">fbs</a></code>, <code><a href="#topic+balstrat">balstrat</a></code>, <code><a href="#topic+landingRM">landingRM</a></code>, <code><a href="#topic+ffphase">ffphase</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE WITH EQUAL INCLUSION PROBABILITES AND SUM IN EACH STRATA INTEGER
N &lt;- 100
n &lt;- 10
p &lt;- 4
X &lt;- matrix(rgamma(N*p,4,25),ncol = p)
strata &lt;- rep(1:n,each = N/n)
pik &lt;- rep(n/N,N)

s &lt;- stratifiedcube(X,strata,pik)

t(X/pik)%*%s
t(X/pik)%*%pik

Xcat &lt;- disj(strata)

t(Xcat)%*%s
t(Xcat)%*%pik


# EXAMPLE WITH UNEQUAL INCLUSION PROBABILITES AND SUM IN EACH STRATA INTEGER
N &lt;- 100
n &lt;- 10
X &lt;- cbind(rgamma(N,4,25),rbinom(N,20,0.1),rlnorm(N,9,0.1),runif(N))
colSums(X)
strata &lt;- rbinom(N,10,0.7)
strata &lt;- sampling::cleanstrata(strata)
pik &lt;- as.vector(sampling::inclusionprobastrata(strata,ceiling(table(strata)*0.10)))
EPS = 1e-7

s &lt;- stratifiedcube(X,strata,pik)
test &lt;- stratifiedcube(X,strata,pik,landing = FALSE)

t(X/pik)%*%s
t(X/pik)%*%test
t(X/pik)%*%pik

Xcat &lt;- disj(strata)

t(Xcat)%*%s
t(Xcat)%*%test
t(Xcat)%*%pik


# EXAMPLE WITH UNEQUAL INCLUSION PROBABILITES AND SUM IN EACH STRATA NOT INTEGER
set.seed(3)
N &lt;- 100
n &lt;- 10
X &lt;- cbind(rgamma(N,4,25),rbinom(N,20,0.1),rlnorm(N,9,0.1),runif(N))
strata &lt;- rbinom(N,10,0.7)
strata &lt;- sampling::cleanstrata(strata)
pik &lt;- runif(N)
EPS = 1e-7
tapply(pik,strata,sum)
table(strata)


s &lt;- stratifiedcube(X,strata,pik,landing = TRUE)
test &lt;- stratifiedcube(X,strata,pik,landing = FALSE)


t(X/pik)%*%s
t(X/pik)%*%test
t(X/pik)%*%pik

Xcat &lt;- disj(strata)

t(Xcat)%*%s
t(Xcat)%*%pik
t(Xcat)%*%test


</code></pre>

<hr>
<h2 id='sys_deville'>Deville's systematic</h2><span id='topic+sys_deville'></span>

<h3>Description</h3>

<p>This function implements a method to select a sample using the Deville's systmatic algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sys_deville(pik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sys_deville_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the selected indices in 1,2,...,N
</p>


<h3>References</h3>

<p>Deville, J.-C. (1998), Une nouvelle méthode de tirage à probabilité inégales. Technical Report 9804, Ensai, France.
</p>
<p>Chauvet, G. (2012), On a characterization of ordered pivotal sampling, Bernoulli, 18(4):1320-1340
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
pik &lt;- c(0.2,0.5,0.3,0.4,0.9,0.8,0.5,0.4)
sys_deville(pik)
</code></pre>

<hr>
<h2 id='sys_devillepi2'>Second order inclusion probabilities of Deville's systematic</h2><span id='topic+sys_devillepi2'></span>

<h3>Description</h3>

<p>This function returns the second order inclusion probabilities of Deville's systematic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sys_devillepi2(pik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sys_devillepi2_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of second order inclusion probabilities.
</p>


<h3>References</h3>

<p>Deville, J.-C. (1998), Une nouvelle méthode de tirage à probabilité inégales. Technical Report 9804, Ensai, France.
</p>
<p>Chauvet, G. (2012), On a characterization of ordered pivotal sampling, Bernoulli, 18(4):1320-1340
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
N &lt;- 30
n &lt;- 4
pik &lt;- as.vector(inclprob(runif(N),n))
PI &lt;- sys_devillepi2(pik)
#image(as(as.matrix(PI),"sparseMatrix"))

pik &lt;- c(0.2,0.5,0.3,0.4,0.9,0.8,0.5,0.4)
PI &lt;- sys_devillepi2(pik)
#image(as(as.matrix(PI),"sparseMatrix"))
</code></pre>

<hr>
<h2 id='vApp'>Approximated variance for balanced sample</h2><span id='topic+vApp'></span>

<h3>Description</h3>

<p>Variance approximation calculated as the conditional variance with respect to the balancing equations of a particular Poisson design. See Tillé (2020)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vApp(Xaux, pik, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vApp_+3A_xaux">Xaux</code></td>
<td>
<p>A matrix of size (<code class="reqn">N</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="vApp_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities. The vector has the size <code class="reqn">N</code> of the population <code class="reqn">U</code>.</p>
</td></tr>
<tr><td><code id="vApp_+3A_y">y</code></td>
<td>
<p>A variable of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Approximated variance of the Horvitz-Thompson estimator.
</p>


<h3>References</h3>

<p>Tillé, Y. (2020), Sampling and Estimation from finite populations, Wiley,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vDBS">vDBS</a></code> <code><a href="#topic+vApp">vApp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 100 
n &lt;- 40
x1 &lt;- rgamma(N,4,25)
x2 &lt;- rgamma(N,4,25)

pik &lt;- rep(n/N,N)
Xaux &lt;- cbind(pik,as.matrix(matrix(c(x1,x2),ncol = 2)))
Xspread &lt;- cbind(runif(N),runif(N))
  

s &lt;- balseq(pik,Xaux,Xspread)
  
y &lt;- Xaux%*%c(1,1,3) + rnorm(N,120) # variable of interest
  
vEst(Xaux[s,],pik[s],y[s])
vDBS(Xaux[s,],Xspread[s,],pik[s],y[s])
vApp(Xaux,pik,y)

</code></pre>

<hr>
<h2 id='varApp'>Approximated variance for balanced sampling</h2><span id='topic+varApp'></span>

<h3>Description</h3>

<p>Approximated variance for balanced sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varApp(X, strata, pik, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varApp_+3A_x">X</code></td>
<td>
<p>A matrix of size (<code class="reqn">N</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="varApp_+3A_strata">strata</code></td>
<td>
<p>A vector of integers that represents the categories.</p>
</td></tr>
<tr><td><code id="varApp_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="varApp_+3A_y">y</code></td>
<td>
<p>A variable of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives an approximation of the variance of the Horvitz-Thompson total estimator presented by Hasler and Tillé (2014).
</p>


<h3>Value</h3>

<p>a scalar, the value of the approximated variance.
</p>


<h3>References</h3>

<p>Hasler, C. and Tillé, Y. (2014). Fast balanced sampling for highly stratified population. <em>Computational Statistics and Data Analysis</em>, 74:81-94.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varEst">varEst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 1000
n &lt;- 400
x1 &lt;- rgamma(N,4,25)
x2 &lt;- rgamma(N,4,25)

strata &lt;- as.matrix(rep(1:40,each = 25)) # 25 strata
Xcat &lt;- disjMatrix(strata)
pik &lt;- rep(n/N,N)
X &lt;- as.matrix(matrix(c(x1,x2),ncol = 2))
 
s &lt;- stratifiedcube(X,strata,pik)
 
y &lt;- 20*strata + rnorm(1000,120) # variable of interest
# y_ht &lt;- sum(y[which(s==1)]/pik[which(s == 1)]) # Horvitz-Thompson estimator
# (sum(y_ht) - sum(y))^2 # true variance
varEst(X,strata,pik,s,y)
varApp(X,strata,pik,y)
</code></pre>

<hr>
<h2 id='varEst'>Estimator of the approximated variance for balanced sampling</h2><span id='topic+varEst'></span>

<h3>Description</h3>

<p>Estimator of the approximated variance for balanced sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varEst(X, strata, pik, s, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varEst_+3A_x">X</code></td>
<td>
<p>A matrix of size (<code class="reqn">N</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="varEst_+3A_strata">strata</code></td>
<td>
<p>A vector of integers that represents the categories.</p>
</td></tr>
<tr><td><code id="varEst_+3A_pik">pik</code></td>
<td>
<p>A vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="varEst_+3A_s">s</code></td>
<td>
<p>A sample (vector of 0 and 1, if rejected or selected).</p>
</td></tr>
<tr><td><code id="varEst_+3A_y">y</code></td>
<td>
<p>A variable of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives an estimator of the approximated variance of the Horvitz-Thompson total estimator presented by Hasler C. and Tillé Y. (2014).
</p>


<h3>Value</h3>

<p>a scalar, the value of the estimated variance.
</p>


<h3>Author(s)</h3>

<p>Raphaël Jauslin <a href="mailto:raphael.jauslin@unine.ch">raphael.jauslin@unine.ch</a>
</p>


<h3>References</h3>

<p>Hasler, C. and Tillé, Y. (2014). Fast balanced sampling for highly stratified population. <em>Computational Statistics and Data Analysis</em>, 74:81-94.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varApp">varApp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 1000
n &lt;- 400
x1 &lt;- rgamma(N,4,25)
x2 &lt;- rgamma(N,4,25)

strata &lt;- as.matrix(rep(1:40,each = 25)) # 25 strata
Xcat &lt;- disjMatrix(strata)
pik &lt;- rep(n/N,N)
X &lt;- as.matrix(matrix(c(x1,x2),ncol = 2))
 
s &lt;- stratifiedcube(X,strata,pik)
 
y &lt;- 20*strata + rnorm(1000,120) # variable of interest
# y_ht &lt;- sum(y[which(s==1)]/pik[which(s == 1)]) # Horvitz-Thompson estimator
# (sum(y_ht) - sum(y))^2 # true variance
varEst(X,strata,pik,s,y)
varApp(X,strata,pik,y)
</code></pre>

<hr>
<h2 id='vDBS'>Variance Estimation for Doubly Balanced Sample.</h2><span id='topic+vDBS'></span>

<h3>Description</h3>

<p>Variance estimator for sample that are at the same time well spread and balanced on auxiliary variables. See Grafstr\&quot;om and Till\'e (2013)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vDBS(Xauxs, Xspreads, piks, ys)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vDBS_+3A_xauxs">Xauxs</code></td>
<td>
<p>A matrix of size (<code class="reqn">n</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="vDBS_+3A_xspreads">Xspreads</code></td>
<td>
<p>Matrix of spatial coordinates.</p>
</td></tr>
<tr><td><code id="vDBS_+3A_piks">piks</code></td>
<td>
<p>A vector of inclusion probabilities. The vector has the size <code class="reqn">n</code> of the sample <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="vDBS_+3A_ys">ys</code></td>
<td>
<p>A variable of interest. The vector has the size <code class="reqn">n</code> of the sample <code class="reqn">s</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated variance of the horvitz-thompson estimator.
</p>


<h3>References</h3>

<p>Grafstr\&quot;om, A. and Till\'e, Y. (2013), Doubly balanced spatial sampling with spreading and restitution of auxiliary totals, Environmetrics, 14(2):120-131
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vDBS">vDBS</a></code> <code><a href="#topic+vApp">vApp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 100 
n &lt;- 40
x1 &lt;- rgamma(N,4,25)
x2 &lt;- rgamma(N,4,25)

pik &lt;- rep(n/N,N)
Xaux &lt;- cbind(pik,as.matrix(matrix(c(x1,x2),ncol = 2)))
Xspread &lt;- cbind(runif(N),runif(N))
  

s &lt;- balseq(pik,Xaux,Xspread)
  
y &lt;- Xaux%*%c(1,1,3) + rnorm(N,120) # variable of interest
  
vEst(Xaux[s,],pik[s],y[s])
vDBS(Xaux[s,],Xspread[s,],pik[s],y[s])
vApp(Xaux,pik,y)

</code></pre>

<hr>
<h2 id='vEst'>Variance Estimation for balanced sample</h2><span id='topic+vEst'></span>

<h3>Description</h3>

<p>Estimated variance approximation calculated as the conditional variance with respect to the balancing equations of a particular Poisson design. See Tillé (2020)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vEst(Xauxs, piks, ys)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vEst_+3A_xauxs">Xauxs</code></td>
<td>
<p>A matrix of size (<code class="reqn">n</code> x <code class="reqn">p</code>) of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="vEst_+3A_piks">piks</code></td>
<td>
<p>A vector of inclusion probabilities. The vector has the size of the sample <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="vEst_+3A_ys">ys</code></td>
<td>
<p>A variable of interest.The vector has the size <code class="reqn">n</code> of the sample <code class="reqn">s</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated variance of the horvitz-thompson estimator.
</p>


<h3>References</h3>

<p>Tillé, Y. (2020), Sampling and Estimation from finite populations, Wiley,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vDBS">vDBS</a></code> <code><a href="#topic+vApp">vApp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 100 
n &lt;- 40
x1 &lt;- rgamma(N,4,25)
x2 &lt;- rgamma(N,4,25)

pik &lt;- rep(n/N,N)
Xaux &lt;- cbind(pik,as.matrix(matrix(c(x1,x2),ncol = 2)))
Xspread &lt;- cbind(runif(N),runif(N))
  

s &lt;- balseq(pik,Xaux,Xspread)
  
y &lt;- Xaux%*%c(1,1,3) + rnorm(N,120) # variable of interest
  
vEst(Xaux[s,],pik[s],y[s])
vDBS(Xaux[s,],Xspread[s,],pik[s],y[s])
vApp(Xaux,pik,y)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
